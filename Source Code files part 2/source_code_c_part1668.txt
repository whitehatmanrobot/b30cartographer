//
//  Return Value:
//                  None
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
void SaveDontShowMeThisAgain(HWND hwndDlg)
{
   DBG_ENTER(_T("SaveDontShowMeThisAgain"));

    //
    // let's save the "Don't show me again" state
    //
    if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_DONT_SHOW), BM_GETCHECK, 0, 0))
    {
        //
        // User pressed the "Don't show me again" checkbox
        //
        HKEY hFaxKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                        REGKEY_FAX_SETUP,
                                        TRUE,
                                        KEY_WRITE);
        if (!hFaxKey)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("OpenRegistryKey(REGKEY_FAX_SETUP)"), GetLastError());
        }
        else
        {
            if (!SetRegistryDword (hFaxKey,
                                   REGVAL_DONT_UNATTEND_INSTALL,
                                   1))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryDword(REGVAL_DONT_UNATTEND_INSTALL)"), GetLastError());
            }
            RegCloseKey (hFaxKey);
        }
    }
}

static
INT_PTR 
CALLBACK 
prv_dlgInstallFaxQuestionPropPage(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgInstallFaxQuestionPropPage

Routine description:

    Dialogs procedure for "Install fax" dialog

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hwndDlg                       [in]    - Handle to dialog box
    uMsg                          [in]    - Message
    wParam                        [in]    - First message parameter
    parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("prv_dlgInstallFaxQuestionPropPage"));

    switch (uMsg) 
    {
        case WM_INITDIALOG: 
            // no return value here.
            PropSheet_SetWizButtons(GetParent(hwndDlg),PSWIZB_NEXT);
                
            SetFocus(hwndDlg);
            if (!CheckDlgButton(hwndDlg,IDC_INSTALL_FAX_NOW,BST_CHECKED))
            {
                dwRes = GetLastError();
                CALL_FAIL (GENERAL_ERR, TEXT("CheckDlgButton"), dwRes);
            }
            break;
        
        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
            case PSN_WIZNEXT:
                SaveDontShowMeThisAgain(hwndDlg);
                //
                // let's get the "Install Fax Now" state
                //
                if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_INSTALL_FAX_NOW), BM_GETCHECK, 0, 0))
                {
                    //
                    // User pressed the "Install Fax Now" checkbox
                    //
                    dwRes = InstallFaxUnattended();
                    if (dwRes!=ERROR_SUCCESS)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), dwRes);
                    }
                }
                return TRUE;
            }
            break;

    }
    return FALSE;
}   // prv_dlgInstallFaxQuestionPropPage

static
INT_PTR 
CALLBACK 
prv_dlgInstallFaxQuestion(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgInstallFaxQuestion

Routine description:

	Dialogs procedure for "Install fax" dialog

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	hwndDlg                       [in]    - Handle to dialog box
	uMsg                          [in]    - Message
	wParam                        [in]    - First message parameter
	parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
{
    INT_PTR iRes = IDIGNORE;
    DBG_ENTER(_T("prv_dlgInstallFaxQuestion"));

    switch (uMsg) 
    {
		case WM_INITDIALOG:
			SetFocus(hwndDlg);
			break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) 
            {
                case IDC_ANSWER_YES:
                    iRes = IDYES;
                    break;

                case IDC_ANSWER_NO:
                    iRes = IDNO;
                    break;
            }
            if (IDIGNORE != iRes)
            {
                SaveDontShowMeThisAgain(hwndDlg);
                EndDialog (hwndDlg, iRes);
                return TRUE;
            }
            break;
    }
    return FALSE;
}   // prv_dlgInstallFaxQuestion


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  AllowInstallationProposal
//
//  Purpose:        
//                  Verify we can propose to the user to install Fax 
//                  Check if Fax is installed
//                  Check if the user has marked the 'don't show this again'
//                  
//  Params:
//                  None
//
//  Return Value:
//                  true - ok to propose the installation of Fax
//                  false - do not propose the Fax installation
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
bool AllowInstallationProposal()
{
    DWORD   ec            = NO_ERROR;
    BOOL    bFaxInstalled = FALSE;

    DBG_ENTER(_T("AllowInstallationProposal"));
    
    ec = IsFaxInstalled (&bFaxInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsFaxInstalled"), ec);
        return false;
    }
    if (bFaxInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax is already installed"));
        return false;
    }
    //
    // Let's find out if we're allowed to add a property page 
    //
    BOOL bDontShowThisAgain = FALSE;
    HKEY hFaxKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                    REGKEY_FAX_SETUP,
                                    FALSE,
                                    KEY_READ);
    if (!hFaxKey)
    {
        //
        // No value there
        //
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("OpenRegistryKey(REGKEY_FAX_SETUP)"), ec);
        // let's go on.
    }
    else
    {
        bDontShowThisAgain = GetRegistryDword (hFaxKey,REGVAL_DONT_UNATTEND_INSTALL);
        RegCloseKey (hFaxKey);
    }
    if (bDontShowThisAgain)
    {
        //
        // User previously checked the "Don't ask me again" checkbox
        //
        VERBOSE (DBG_MSG, TEXT("Used previously checked the \"Don't ask me again\" checkbox"));
        return false;
    }

    return true;
}

/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleNonPnpDevices
//
//  Purpose:        
//                  Handles DIF_INSTALLDEVICE
//                  A new device has finished installing and we check if this is a non PnP device
//                  if it is we propose the user to install Fax using a message box.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleNonPnpDevices()
{
    DWORD ec = NO_ERROR;
    DBG_ENTER(_T("HandleNonPnpDevices"), ec);

    // if this is a PnP installation don't do anything here
    if (bIsPnpInstallation)
    {
        VERBOSE(DBG_MSG,_T("This is a PnP device installation, exiting"));
        goto exit;
    }

    // if Fax is installed or the user has checked the 'Don't show me this again' do not propose
    if (!AllowInstallationProposal())
    {
        VERBOSE(DBG_MSG,TEXT("Not allowed to install, exit"));
        goto exit;
    }

    //
    // Let's ask the user if he wishes to install a fax now
    //
    INT_PTR iResult = DialogBox (faxocm_GetAppInstance(),
                                 MAKEINTRESOURCE(IDD_INSTALL_FAX),
                                 NULL,
                                 prv_dlgInstallFaxQuestion);
    if (iResult==-1)
    {
        ec = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("DialogBox(IDD_INSTALL_FAX)"), ec);
        goto exit;
    }

    if (iResult==IDYES)
    {
        //
        // User wishes to install the fax now - do so.
        //
        ec = InstallFaxUnattended();
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), ec);
        }
    }

exit:
    return ec;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  GetModemDriverInfo
//
//  Purpose:        
//                  Gets the modem's selected driver and retrieves the modem's INF 
//                  filename and section within the INF file
//
//  Params:
//                  IN HDEVINFO hDeviceInfoSet                        - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData               - passed from CoDevice Installer
//                  OUT PSP_DRVINFO_DETAIL_DATA pspDrvInfoDetailData  - passes out the driver details
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//                  Caller must call MemFree on returned pointer.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD GetModemDriverInfo
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA pspDrvInfoDetailData
)
{
    DWORD                   ec                      = NO_ERROR;
    DWORD                   dwRequiredSize          = 0;
    SP_DRVINFO_DATA         spDrvInfoData;

    DBG_ENTER(_T("GetModemDriverInfo"), ec);

    pspDrvInfoDetailData = NULL;
    spDrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (SetupDiGetSelectedDriver(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData))
    {
        if (!SetupDiGetDriverInfoDetail(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData,NULL,0,&dwRequiredSize))
        {
            ec = GetLastError(); 
            if (ec==ERROR_INSUFFICIENT_BUFFER)
            {
                ec = NO_ERROR;
                if (pspDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA)MemAlloc(dwRequiredSize))
                {
                    pspDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (SetupDiGetDriverInfoDetail(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData,pspDrvInfoDetailData,dwRequiredSize,NULL))
                    {
                        VERBOSE(DBG_MSG,_T("Driver Inf Name is: %s"),pspDrvInfoDetailData->InfFileName);
                        VERBOSE(DBG_MSG,_T("Driver Section Name is: %s"),pspDrvInfoDetailData->SectionName);
                        VERBOSE(DBG_MSG,_T("Driver Description is: %s"),pspDrvInfoDetailData->DrvDescription);
                        VERBOSE(DBG_MSG,_T("Driver Hardware ID is: %s"),pspDrvInfoDetailData->HardwareID);
                    }
                    else
                    {
                        ec = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail"), ec);
                    }
                }
                else
                {
                    ec = ERROR_NOT_ENOUGH_MEMORY;
                    VERBOSE(GENERAL_ERR, TEXT("MemAlloc failed"));
                }
            }
            else
            {
                ec = GetLastError();
                CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail"), ec);
            }
        }
        else
        {
            ec = ERROR_INVALID_PARAMETER;
            VERBOSE(GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail should have failed"));
        }
    }
    else
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetSelectedDriver"), ec);
    }

    return ec;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SearchModemInfFaxSection
//
//  Purpose:        
//                  Search the modem's INF to find if a Fax section exists.
//                  If a Fax section exists, try to find the InstallFax key
//                  If it's there, install Fax unattended.
//                  
//  Params:
//                  IN HDEVINFO hDeviceInfoSet              - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData     - passed from CoDevice Installer
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Mar-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD SearchModemInfFaxSection
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData
)
{
    DWORD                   ec                      = NO_ERROR;
    DWORD                   Size                    = sizeof(DWORD);
    DWORD                   Type                    = 0;
    DWORD                   Value                   = 0;
    HKEY                    hDeviceKey              = NULL;
    HKEY                    hFaxKey                 = NULL;
    LPTSTR                  lptstrInstallFax        = NULL;

    DBG_ENTER(_T("SearchModemInfFaxSection"), ec);

    // get the device key under HKLM\SYSTEM\CurrentControlSet\Control\Class\ClassGUID\InstanceID
    hDeviceKey = SetupDiOpenDevRegKey(hDeviceInfoSet,pDeviceInfoData,DICS_FLAG_GLOBAL,0,DIREG_DRV,KEY_READ);
    if (hDeviceKey==NULL)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiOpenDevRegKey"), ec);
        goto exit;
    }
    // check if the Fax subkey exists.
    hFaxKey = OpenRegistryKey(hDeviceKey,_T("Fax"),FALSE,KEY_READ);
    if (hFaxKey==NULL)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does not have a Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    // this modem has a Fax section.
    // let's check if it uses the 'InstallFax' REG_SZ
    lptstrInstallFax = GetRegistryString(hFaxKey,_T("InstallFax"),NULL);
    if (lptstrInstallFax==NULL)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does not have an InstallFax REG_SZ in the Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    // check if the InstallFax is 0 (unlikely, but...)
    if (_tcsicmp(lptstrInstallFax,_T("0"))==0)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does has an InstallFax=0 REG_SZ in the Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    //if (InSystemSetup(hDeviceInfoSet,pDeviceInfoData))
    {
        // if we're in system setup, we should just notify our component that it should install.
    }
    //else
    {
        // finally, Install Fax.
        ec = InstallFaxUnattended();
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), ec);
        }
    }

exit:

    if (hDeviceKey)
    {
        RegCloseKey(hDeviceKey);
    }
    if (hFaxKey)
    {
        RegCloseKey(hFaxKey);
    }
    return ec;
}

*/

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleInstallDevice
//
//  Purpose:        
//                  Handles DIF_INSTALLDEVICE
//                  A new device has finished installing and we're allowed to install a printer
//                  if Fax is already on the box
//                  In this case we do the following:
//                  
//                  1. Check if Fax is installed, it it's not then attemp to install Fax based on INF
//                  2. Check if there's a Fax printer, if there is leave
//                  3. Install a Fax printer
//                  4. Ensure the service is up
//                  5. Leave
//                  
//  Params:
//                  IN HDEVINFO hDeviceInfoSet              - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData     - passed from CoDevice Installer
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleInstallDevice
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData
)
{
    DWORD ec = NO_ERROR;
    BOOL  bFaxInstalled;
    BOOL  bLocalFaxPrinterInstalled;

    DBG_ENTER(_T("HandleInstallDevice"), ec);

    // Now we know a new modem installation succeeded.
    // Let's check if our component is installed.
    //

    ec = IsFaxInstalled(&bFaxInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsFaxInstalled"), ec);
        goto exit;
    }
    if (!bFaxInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax is not installed, search modem's INF for Fax section..."));
/*
        ec = SearchModemInfFaxSection(hDeviceInfoSet,pDeviceInfoData);
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SearchModemInfFaxSection"), ec);
        }*/
        goto exit;
    }
    //
    // Let's see if we have a local fax printer
    //
    ec = IsLocalFaxPrinterInstalled (&bLocalFaxPrinterInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsLocalFaxPrinterInstalled"), ec);
        goto exit;
    }
    if (bLocalFaxPrinterInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax Printer is installed, exit"));
        goto exit;
    }
    //
    // This is the time to install a local fax printer.
    //
    ec = AddLocalFaxPrinter (FAX_PRINTER_NAME, NULL);
    if (ERROR_SUCCESS != ec)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AddLocalFaxPrinter"), ec);
        goto exit;
    }
    //
    // Make sure the service is running.
    // This is important because there may have been jobs in the queue that now, when we have
    // a new modem device, can finally be executed.
    //
    if (!EnsureFaxServiceIsStarted (NULL))
    {
        ec = GetLastError ();
        CALL_FAIL (GENERAL_ERR, TEXT("EnsureFaxServiceIsStarted"), ec);
        goto exit;
    }

exit:
    return ec;
}   

/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleNewDeviceWizardFinishInstall
//
//  Purpose:        
//                  Handles DIF_NEWDEVICEWIZARD_FINISHINSTALL
//                  A new device has finished installing and we're allowed to add a property page
//                  asking the user to install Fax
//                  In this case we do the following:
//                  
//                  1. Check if Fax is installed, if it is leave
//                  2. Check if we're allowed to add a property page, if not leave
//                  3. Add a property page to the wizard.
//                  4. Leave
//                  
//  Params:
//                  See CoClassInstaller documentation in DDK
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleNewDeviceWizardFinishInstall
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
)
{
    DWORD                   ec                          = NO_ERROR;
    BOOL                    bFaxInstalled               = FALSE;
    TCHAR*                  WizardTitle                 = NULL;
    TCHAR*                  WizardSubTitle              = NULL;
    SP_NEWDEVICEWIZARD_DATA nddClassInstallParams       = {0};
    DWORD                   dwClassInstallParamsSize    = sizeof(SP_NEWDEVICEWIZARD_DATA);
    HPROPSHEETPAGE          hPsp                        = NULL;
    PROPSHEETPAGE           psp                         = {0};

    DBG_ENTER(_T("HandleNewDeviceWizardFinishInstall"), ec);

    if (!AllowInstallationProposal())
    {
        VERBOSE(DBG_MSG,TEXT("Not allowed to install, exit"));
        goto exit;
    }

    nddClassInstallParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

    // get the class install parameters by calling SetupDiGetClassInstallParams 
    if (!SetupDiGetClassInstallParams(  hDeviceInfoSet,
                                        pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&nddClassInstallParams,
                                        dwClassInstallParamsSize,
                                        NULL))
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetClassInstallParams"), ec);
        goto exit;
    }

    // check whether NumDynamicPages has reached the max
    if (nddClassInstallParams.NumDynamicPages>=MAX_INSTALLWIZARD_DYNAPAGES)
    {
        VERBOSE (GENERAL_ERR, TEXT("Too many property pages, can't add another one"));
        ec = ERROR_BUFFER_OVERFLOW;
        goto exit;
    }
    // fill in the PROPSHEETPAGE structure
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance = faxocm_GetAppInstance();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_INSTALL_FAX_PROP);
    psp.pfnDlgProc = prv_dlgInstallFaxQuestionPropPage;

    WizardTitle = (TCHAR*)MemAlloc(MAX_PATH * sizeof(TCHAR) );
    if(WizardTitle)
    {
        if (!LoadString(psp.hInstance, IDS_NEW_DEVICE_TITLE, WizardTitle, MAX_PATH))
        {
            ec = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
            WizardTitle[0] = 0;
        }
        else
        {
            psp.pszHeaderTitle = WizardTitle;
        }
    }

    WizardSubTitle = (TCHAR*)MemAlloc(MAX_PATH * sizeof(TCHAR) );
    if(WizardSubTitle)
    {
        if (!LoadString(psp.hInstance, IDS_NEW_DEVICE_SUBTITLE, WizardSubTitle, MAX_PATH))
        {
            ec = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
            WizardSubTitle[0] = 0;
        }
        else
        {
            psp.pszHeaderSubTitle = WizardSubTitle;
        }
    }
    // add the page and increment the NumDynamicPages counter
    hPsp = CreatePropertySheetPage(&psp);
    if (hPsp==NULL)
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CreatePropertySheetPage"), ec);
        goto exit;
    }

    nddClassInstallParams.DynamicPages[nddClassInstallParams.NumDynamicPages++] = hPsp;

    // apply the modified params by calling SetupDiSetClassInstallParams
    if (!SetupDiSetClassInstallParams(  hDeviceInfoSet,
                                        pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&nddClassInstallParams,
                                        dwClassInstallParamsSize))
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
        goto exit;
    }

exit:

    return ec;
}   
*/
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FaxModemCoClassInstaller
//
//  Purpose:        
//                  Our Fax CoClassInstaller, handles newly discovered modems
//
//  Params:
//                  See CoClassInstaller documentation in DDK
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK FaxModemCoClassInstaller
(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
)
{
    DWORD ec = NO_ERROR;

    DBG_ENTER(_T("FaxModemCoClassInstaller"), ec, TEXT("Processing %s request"), DifDebug[InstallFunction].DifString);

    //  We handle two events:
    //
    //  DIF_INSTALLDEVICE
    //  A new device has finished installing and we're allowed to install a printer
    //  if Fax is already on the box
    //  In this case we do the following:
    //
    //  1. Check if Fax is installed, if it's not leave
    //  2. Check if there's a Fax printer, if there is leave
    //  3. Install a Fax printer
    //  4. Ensure the service is up
    //  5. Leave
    //
    //  DIF_NEWDEVICEWIZARD_FINISHINSTALL
    //  A new device has finished installing and we're allowed to add a property page
    //  asking the user to install Fax
    //  In this case we do the following:
    //
    //  1. Check if Fax is installed, if it is leave
    //  2. Check if we're allowed to add a property page, if not leave
    //  3. Add a property page to the wizard.
    //  4. Leave
    switch (InstallFunction)
    {
        case DIF_INSTALLWIZARD:
            VERBOSE (DBG_MSG, L"Marking installation as potential non PnP");
            bIsPnpInstallation = false;
            break;

        case DIF_INSTALLDEVICE:                     
            if (!Context->PostProcessing) 
            {
                //
                // The modem device is not installed yet
                //
                VERBOSE (DBG_MSG, L"Pre-installation, waiting for post-installation call");
                ec = ERROR_DI_POSTPROCESSING_REQUIRED;
                return ec;
            }
            if (Context->InstallResult!=NO_ERROR) 
            {
                //
                // The modem device had some problems during installation
                //
                VERBOSE (DBG_MSG, L"Previous error causing installation failure, 0x%08x", Context->InstallResult);
                ec = Context->InstallResult;
                return ec;
            }
            if (HandleInstallDevice(hDeviceInfoSet,pDeviceInfoData)!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleInstallDevice"), GetLastError());
                // do not fail the CoClassInstaller
            }
            /* No UI until futher notice
            if (HandleNonPnpDevices()!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleNonPnpDevices"), GetLastError());
                // do not fail the CoClassInstaller
            }
            */
            break;

        case DIF_NEWDEVICEWIZARD_FINISHINSTALL:
            /* No UI until futher notice
            Assert(bIsPnpInstallation);
            if (HandleNewDeviceWizardFinishInstall(hDeviceInfoSet,pDeviceInfoData)!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleNewDeviceWizardFinishInstall"), GetLastError());
                // do not fail the CoClassInstaller
            }
            */
            break;

        default:
            VERBOSE(DBG_MSG,TEXT("We do not handle %s"),DifDebug[InstallFunction].DifString);
            break;
    }

    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocreg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocReg.cpp
//
// Abstract:        This provides the registry routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#define prv_WAIT_TIMEOUT_MILLISEC        10000

#define prv_LODCTR        _T("lodctr %systemroot%\\system32\\") FAX_FILENAME_FAXPERF_INI
#define prv_UNLODCTR      _T("unlodctr fax")

//////////////////////// Static Function Prototypes ////////////////////////
static DWORD prv_InstallDynamicRegistry(const TCHAR     *pszSection);
static DWORD prv_UninstallDynamicRegistry(const TCHAR     *pszSection);

static DWORD prv_CreatePerformanceCounters(void);
static DWORD prv_DeletePerformanceCounters(void);

///////////////////////////////
// fxocReg_Init
//
// Initialize registry handling
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Registry Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocReg_Term
//
// Terminate the registry handling
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//

DWORD fxocReg_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Registry Module"),dwRes);

    return dwRes;
}


///////////////////////////////
// fxocReg_Install
//
// Create registry settings as 
// specified in INF file, as well
// as dynamic settings that can only
// be done at run time (such as 
// performance counter setup, etc).
// 
// Params:
//      - pszSubcomponentId
//      - pszInstallSection
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Install(const TCHAR     *pszSubcomponentId,
                      const TCHAR     *pszInstallSection)
{
    DWORD       dwReturn        = NO_ERROR;
    DWORD       dwNumDevices    = 0;
    HINF        hInf            = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocReg_Install"),
                dwReturn,   
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if (pszInstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Set up the static registry data found in the INF file

    // This will perform all necessary install steps as specified
    // by the SPINST_* flags below.  Since we already queued up our
    // files to be copied, we are using this API only to setup our 
    // registry settings as specified in the FAX install section in 
    // the INF file.

    // Notice that this function works both for installing and uninstalling.
    // It determines whether to install or uninstall based on the "pszSection"
    // parameter passed in from the INF file.  The INF file will be structured
    // such that the install sections will have 'AddReg', etc, while the 
    // uninstall sections will have 'DelReg', etc.

    // Lastly, notice the SPINST_* flags specified.  We tell it to install
    // everything (via SPINST_ALL) with the exception of FILES since they
    // were copied over by the QUEUE_OPS operation before, and with the 
    // exception of PROFILEITEMS (shortcut link creation) because we want
    // to do that only after we have confirmed everything has succeeded.
    // Shortcut links are explictely created/deleted in faxocm.cpp (via 
    // fxocLink_Install/fxocLink_Uninstall functions)


    dwReturn = fxocUtil_DoSetup(
                             hInf, 
                             pszInstallSection, 
                             TRUE, 
                             SPINST_ALL & ~(SPINST_FILES | SPINST_PROFILEITEMS),
                             _T("fxocReg_Install"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed static registry ")
                _T("settings as specified in INF file"));

        // Place any dynamic registry data you need to create on the fly
        // here.
        //
        dwReturn = prv_InstallDynamicRegistry(pszInstallSection);
    }

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Registry Install, installing performance ")
                _T("counters..."));

        // first delete any performance counters we have before
        prv_DeletePerformanceCounters();

        // install performance counters
        dwReturn = prv_CreatePerformanceCounters();
    }

    // now do RegSvr for platform dependent DLLs
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Registry Install, Doing REGSVR"));

        dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_REGISTER_DLL_PLATFORM,SPINST_REGSVR,NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully Registered Fax DLLs - platform dependent")
                    _T("from INF file, section '%s'"), 
                    pszInstallSection);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to Registered Fax DLLs - platform dependent")
                    _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                    pszInstallSection, 
                    dwReturn);
        }
    }

    // now do AddReg for platform dependent registry settings
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Registry Install, Doing AddReg_Platform"));

        dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_ADDREG_PLATFORM,SPINST_REGISTRY,NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully Installed Registry- platform dependent")
                    _T("from INF file, section '%s'"), 
                    pszInstallSection);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to Install Registry- platform dependent")
                    _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                    pszInstallSection, 
                    dwReturn);
        }
    }
    return dwReturn;
}

///////////////////////////////
// fxocReg_Uninstall
//
// Delete registry settings as 
// specified in INF file, as well
// as dynamic settings that can only
// be done at run time (such as 
// performance counter setup, etc).
// 
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Uninstall(const TCHAR     *pszSubcomponentId,
                        const TCHAR     *pszUninstallSection)
{
    DWORD dwReturn  = NO_ERROR;
    HINF  hInf      = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocReg_Uninstall"),
                dwReturn,   
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if (pszUninstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // try to cleanup regardless of the return value.
    prv_UninstallDynamicRegistry(pszUninstallSection);

    // remove any performance counters related to fax.
    prv_DeletePerformanceCounters();

    // remove the static registry settings specified in the INF file    
    fxocUtil_DoSetup(hInf, 
                     pszUninstallSection, 
                     FALSE, 
                     SPINST_ALL & ~(SPINST_FILES | SPINST_PROFILEITEMS),
                     _T("fxocReg_Uninstall"));

    return dwReturn;
}

///////////////////////////////
// prv_InstallDynamicRegistry
//
// Installs dynamic registry 
// settings that can only be 
// done at run time (as opposed
// to via the faxsetup.inf file)
//
// Params:
//      - pszSection -
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_InstallDynamicRegistry(const TCHAR     *pszSection)
{
    DWORD   dwReturn          = NO_ERROR;
    LONG    lResult           = ERROR_SUCCESS;
    HKEY    hKey              = NULL;
    BOOL    bIsServerInstall  = FALSE;
    DWORD   dwProductType     = 0;

    DBG_ENTER(  _T("prv_InstallDynamicRegistry"),
                dwReturn,   
                _T("%s"),
                pszSection);

    if (pszSection == NULL) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    // open the install type registry key.
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, 
                           REGKEY_FAX_SETUP, 
                           0, 
                           KEY_ALL_ACCESS, 
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        bIsServerInstall = fxState_IsOsServerBeingInstalled();

        if (bIsServerInstall)
        {
            dwProductType = FAX_INSTALL_SERVER;
        }
        else
        {
            dwProductType = FAX_INSTALL_WORKSTATION;
        }

        lResult = ::RegSetValueEx(hKey, 
                                  REGVAL_FAXINSTALL_TYPE, 
                                  0, 
                                  REG_DWORD, 
                                  (BYTE*) &dwProductType, 
                                  sizeof(dwProductType));

        if (lResult != ERROR_SUCCESS)
        {
            dwReturn = (DWORD) lResult;
            VERBOSE(SETUP_ERR,
                    _T("Failed to set InstallType, ")
                    _T("rc = 0x%lx"), 
                    lResult);
        }
    }

    if (hKey)
    {
        ::RegCloseKey(hKey);
        hKey = NULL;
    }

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed dynamic Registry ")
                _T("settings from INF file, section '%s'"), 
                pszSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install dynamic Registry ")
                _T("settings from INF file, section '%s', ")
                _T("rc = 0x%lx"), 
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// prv_UninstallDynamicRegistry
//
// Uninstall dynamic registry.
//
// Params:
//      - pszSection.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_UninstallDynamicRegistry(const TCHAR     *pszSection)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(  _T("prv_InstallDynamicRegistry"),
                dwRes,   
                _T("%s"),
                pszSection);

    return dwRes;
}

///////////////////////////////
// prv_CreatePerformanceCounters
//
// Create the performance counters 
// for fax in the registry.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_CreatePerformanceCounters(void)
{
    BOOL                bSuccess            = TRUE;
    DWORD               dwReturn            = NO_ERROR;
    HANDLE              hNull               = NULL;
    TCHAR               szCmdLine[2047 + 1] = {0};
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD               dwNumChars          = 0;

    DBG_ENTER(_T("prv_CreatePerformanceCounters"),dwReturn);

    hNull = CreateFile(_T("nul"),
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    // this should never happen.
    if (hNull == INVALID_HANDLE_VALUE) 
    {
        dwReturn = GetLastError();
        return dwReturn;
    }

    dwNumChars = ::ExpandEnvironmentStrings(
                                            prv_LODCTR,
                                            szCmdLine, 
                                            sizeof(szCmdLine) / sizeof(TCHAR));

    if (dwNumChars == 0)
    {
        dwReturn = ::GetLastError();

        VERBOSE(SETUP_ERR,
                _T("ExpandEnvironmentStrings failed, rc = 0x%lx"),
                dwReturn);

        return dwReturn;
    }

    if (szCmdLine[0] != 0)
    {
        memset(&StartupInfo, 0, sizeof(StartupInfo));
        memset(&ProcessInfo, 0, sizeof(ProcessInfo));

        GetStartupInfo(&StartupInfo);
        StartupInfo.hStdInput   = hNull;
        StartupInfo.hStdOutput  = hNull;
        StartupInfo.hStdError   = hNull;
        StartupInfo.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_HIDE;

        VERBOSE(DBG_MSG,
                _T("CreatePerformanceCounters, launching ")
                _T("process '%s'"), 
                szCmdLine);

        bSuccess = CreateProcess(NULL,
                                 szCmdLine,
                                 NULL,
                                 NULL,
                                 TRUE,
                                 DETACHED_PROCESS,
                                 NULL,
                                 NULL,
                                 &StartupInfo,
                                 &ProcessInfo);

        if (bSuccess)
        {
            DWORD dwWait = 0;

            VERBOSE(DBG_MSG,
                    _T("CreatePerformanceCounters, successfully")
                    _T("launched process, waiting for it to complete..."));

            dwWait = WaitForSingleObject(ProcessInfo.hProcess, 
                                         prv_WAIT_TIMEOUT_MILLISEC);

            if (dwWait == WAIT_TIMEOUT)
            {
                VERBOSE(SETUP_ERR,
                        _T("Timed out waiting for process '%s'")
                        _T("to complete."), 
                        szCmdLine);
            }
            else
            {
                VERBOSE(DBG_MSG, _T("Process completed."));
            }
        }
        else
        {
            dwReturn = ::GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("Failed to create process '%s', rc=0x%lx"),
                    szCmdLine, 
                    dwReturn);
        }
    }

    if (ProcessInfo.hProcess)
    {
        CloseHandle(ProcessInfo.hProcess);
        ProcessInfo.hProcess = NULL;
    }

    if (ProcessInfo.hThread)
    {
        CloseHandle(ProcessInfo.hThread);
        ProcessInfo.hThread = NULL;
    }

    if (hNull)
    {
        CloseHandle(hNull);
        hNull = NULL;
    }

    return dwReturn;
}

///////////////////////////////
// prv_DeletePerformanceCounters
//
// Delete the performance counters 
// for fax in the registry.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//      
static DWORD prv_DeletePerformanceCounters(void)
{
    DWORD               dwReturn = NO_ERROR;
    HANDLE              hNull    = NULL;
    BOOL                bSuccess = TRUE;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    TCHAR szCmdLine[128];

    DBG_ENTER(_T("prv_DeletePerformanceCounters"),dwReturn);

    memset(&StartupInfo, 0, sizeof(StartupInfo));
    memset(&ProcessInfo, 0, sizeof(ProcessInfo));

    // make sure that all output goes to nul.

    hNull = CreateFile(_T("nul"),
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    // this should never happen.
    if (hNull == INVALID_HANDLE_VALUE) 
    {
        dwReturn = GetLastError();
        return dwReturn;
    }

    GetStartupInfo(&StartupInfo);
    StartupInfo.hStdInput   = hNull;
    StartupInfo.hStdOutput  = hNull;
    StartupInfo.hStdError   = hNull;
    StartupInfo.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    _tcsncpy(szCmdLine, prv_UNLODCTR, (sizeof(szCmdLine) / sizeof(TCHAR)));
	szCmdLine[(sizeof(szCmdLine) / sizeof(TCHAR)) -1] = TEXT('\0');

    VERBOSE(DBG_MSG,
            _T("DeletePerformanceCounters, launching process '%s'"),
            szCmdLine);

    bSuccess = CreateProcess(NULL,
                             szCmdLine,
                             NULL,
                             NULL,
                             TRUE,
                             DETACHED_PROCESS,
                             NULL,
                             NULL,
                             &StartupInfo,
                             &ProcessInfo);

    if (bSuccess)
    {
        DWORD dwWait = 0;

        VERBOSE(DBG_MSG, _T("Waiting for process to complete..."));

        dwWait = WaitForSingleObject(ProcessInfo.hProcess, 
                                     prv_WAIT_TIMEOUT_MILLISEC);

        if (dwWait == WAIT_TIMEOUT)
        {
            VERBOSE(SETUP_ERR,
                    _T("Timed out waiting for process '%s' ")
                    _T("to complete"), 
                    szCmdLine);
        }
        else
        {
            VERBOSE(DBG_MSG, _T("Process complete."));
        }
    }
    else
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to create process '%s', rc=0x%lx"),
                szCmdLine, 
                dwReturn);
    }

    if (ProcessInfo.hProcess)
    {
        CloseHandle(ProcessInfo.hProcess);
    }

    if (ProcessInfo.hThread)
    {
        CloseHandle(ProcessInfo.hThread);
    }

    if (hNull)
    {
        CloseHandle(hNull);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocreg.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       FXOCREG.h
//
// Abstract:        Header file used by Registry source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCREG_H_
#define _FXOCREG_H_

DWORD fxocReg_Init(void);
DWORD fxocReg_Term(void);
DWORD fxocReg_Install(const TCHAR   *pszSubcomponentId,
                      const TCHAR   *pszInstallSection);
DWORD fxocReg_Uninstall(const TCHAR *pszSubcomponentId,
                        const TCHAR *pszUninstallSection);


#endif  // _FXOCREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocsvc.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocSvc.h
//
// Abstract:        Header file used by Service source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCSVC_H_
#define _FXOCSVC_H_


DWORD fxocSvc_Init(void);
DWORD fxocSvc_Term(void);
DWORD fxocSvc_Install(const TCHAR   *pszSubcomponentId,
                      const TCHAR   *pszInstallSection);
DWORD fxocSvc_Uninstall(const TCHAR *pszSubcomponentId,
                        const TCHAR *pszUninstallSection);

DWORD fxocSvc_StartService(const TCHAR *pszServiceName);
DWORD fxocSvc_StartFaxService();
DWORD fxocSvc_StopFaxService(HINF hInf,
                             const TCHAR *pszSection);

#endif  // _FXOCSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocsvc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocSvc.cpp
//
// Abstract:        This provides the Service routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#include <Accctrl.h>
#include <Aclapi.h>

/////////////////////// Static Function Prototypes /////////////////////////

///////////////////////////////
// fxocSvc_Init
//
// Initialize the fax service
// setup subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Service Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocSvc_Term
//
// Terminate the fax service
// setup subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Service Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocSvc_Install
//
// Create/delete the fax service as
// specified in the INF file
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF we are installing from
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Install(const TCHAR  *pszSubcomponentId,
                      const TCHAR  *pszInstallSection)
{
    DWORD                 dwReturn  = NO_ERROR;
    BOOL                  bSuccess  = FALSE;
    HINF                  hInf      = faxocm_GetComponentInf();
    OCMANAGER_ROUTINES    *pHelpers = faxocm_GetComponentHelperRoutines();

    DBG_ENTER(  _T("fxocSvc_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if ((hInf               == NULL) ||
        (pszInstallSection  == NULL) ||
        (pHelpers           == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // attempt to install any Services specified in the Fax
    // install section in the INF file.  

    bSuccess = ::SetupInstallServicesFromInfSection(hInf, 
                                                    pszInstallSection,
                                                    0);
    if (bSuccess)
    {
        VERBOSE(DBG_MSG, 
                _T("Successfully installed fax service from ")
                _T("section '%s'"), 
                pszInstallSection);

            // if this install is being done through the control panel via the 
            // Add/Remove Windows Components dialog (i.e. NOT a clean/upgrade install
            // of the OS), then start the service if a reboot is not required.

            // If this is not a stand alone install, then the machine will be rebooted
            // anyway so the fax service will auto-start.

        if (fxState_IsStandAlone())
        {
            dwReturn = fxocSvc_StartFaxService();

            if (dwReturn == NO_ERROR)
            {
                VERBOSE(DBG_MSG,_T("Successfully started fax service..."));
            }
            else
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to start fax service, rc = 0x%lx"),
                        dwReturn);
            }
        }
    }
    else
    {
        dwReturn = ::GetLastError();

        VERBOSE(SETUP_ERR,
                _T("Failed to install the services section in ")
                _T("section '%s', rc = 0x%lx"), 
                pszInstallSection,
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocSvc_Uninstall
//
// Delete the fax service as
// specified in the INF file
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF we are installing from
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Uninstall(const TCHAR  *pszSubcomponentId,
                        const TCHAR  *pszUninstallSection)
{
    DWORD dwReturn  = NO_ERROR;
    HINF  hInf      = faxocm_GetComponentInf();
    BOOL  bSuccess  = FALSE;

    DBG_ENTER(  _T("fxocSvc_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if ((hInf                == NULL) ||
        (pszUninstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwReturn == NO_ERROR)
    {
        dwReturn = StopService(NULL, FAX_SERVICE_NAME, TRUE);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Uninstall failed to stop fax service, ec = 0x%lx, ")
                    _T("attempting to uninstall fax service anyway"),
                    dwReturn);
        }

        bSuccess = ::SetupInstallServicesFromInfSection(hInf, 
                                                        pszUninstallSection,
                                                        0);

        if (bSuccess)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully uninstalled service ")
                    _T("from section '%s'"), 
                    pszUninstallSection);
        }
        else
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall ")
                    _T("service, SubcomponentId = '%s', ")
                    _T("uninstall Section = '%s', rc = 0x%lx"),
                    pszSubcomponentId,
                    pszUninstallSection,
                    dwReturn);
        }
    }

    return dwReturn;
}

///////////////////////////////
// fxocSvc_StartFaxService
//
// Start the fax service 
// specified in the given
// INF file's section.
//
// Params:
//      None
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocSvc_StartFaxService()
{
    DWORD               dwReturn                    = NO_ERROR;

    DBG_ENTER(  _T("fxocSvc_StartFaxService"),
                dwReturn);

    if (!EnsureFaxServiceIsStarted (NULL))
    {
        dwReturn = GetLastError ();
    }
    return dwReturn;
}


///////////////////////////////
// fxocSvc_StartService
//
// Start the specified service 
//
// Params:
//      - pszServiceName
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocSvc_StartService(const TCHAR *pszServiceName)
{
    BOOL                bSuccess    = FALSE;
    DWORD               dwReturn    = NO_ERROR;
    SC_HANDLE           hSvcMgr     = NULL;
    SC_HANDLE           hService    = NULL;
    DWORD               i           = 0;

    DBG_ENTER(  _T("fxocSvc_StartService"),
                dwReturn,
                _T("%s"),
                pszServiceName);

    // open the service manager
    hSvcMgr = ::OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS);

    if (hSvcMgr == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open the service manager, rc = 0x%lx"),
                dwReturn);
    }

    if (dwReturn == NO_ERROR)
    {
        hService = ::OpenService(hSvcMgr,
                                 pszServiceName,
                                 SERVICE_ALL_ACCESS);

        if (hService == NULL)
        {
            dwReturn = ::GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("fxocSvc_StartService, Failed to open service ")
                    _T("'%s', rc = 0x%lx"), 
                    pszServiceName,
                    dwReturn);
        }
    }

    // Start the fax service.
    if (dwReturn == NO_ERROR)
    {
        bSuccess = StartService(hService, 0, NULL);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();
            if (dwReturn == ERROR_SERVICE_ALREADY_RUNNING)
            {
                dwReturn = NO_ERROR;
            }
            else
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to start service '%s', ")
                        _T("rc = 0x%lx"), 
                        pszServiceName, 
                        dwReturn);
            }
        }
    }

    if (dwReturn == NO_ERROR)
    {
        SERVICE_STATUS Status;
        int i = 0;

        do 
        {
            QueryServiceStatus(hService, &Status);
            i++;

            if (Status.dwCurrentState != SERVICE_RUNNING)
            {
                Sleep(1000);
            }

        } while ((i < 60) && (Status.dwCurrentState != SERVICE_RUNNING));

        if (Status.dwCurrentState != SERVICE_RUNNING)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service"),
                    pszServiceName);
        }
    }

    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hSvcMgr)
    {
        CloseServiceHandle(hSvcMgr);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocupgrade.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	fxocUpgrade.h

Abstract:

	Header file for Upgrade process

Author:

	Iv Garber (IvG)	Mar, 2001

Revision History:

--*/

#ifndef _FXOCUPGRADE_H_
#define _FXOCUPGRADE_H_

//
//  MSI DLL is used for checking the SBS 5.0 Client presence on the system
//
#include "faxSetup.h"


/**
    Following functions are used at OS Upgrade, where Windows XP Fax should replace other 
        installed Fax applications.

    The process is as following :
        fxocUpg_Init() will check which Fax applications are installed.

        fxocUpg_SaveSettings() will save different settings of these old Fax applications. 

        fxocUpg_Uninstall() will remove these old Fax applications.

        fxocUpg_MoveFiles() will move files of these old Fax applications to new places.

        fxocUpg_RestoreSettings() will restore back the settings that were stored at the SaveSettings().
**/


DWORD   fxocUpg_Init(void);
DWORD   fxocUpg_Uninstall(void);                 
DWORD   fxocUpg_MoveFiles(void);
DWORD   fxocUpg_SaveSettings(void);
DWORD   fxocUpg_RestoreSettings(void);          
DWORD   fxocUpg_WhichFaxWasUninstalled(DWORD dwFaxAppList);
DWORD   fxocUpg_GetUpgradeApp(void);

#define UNINSTALL_TIMEOUT           5 * 60 * 1000       //  5 minutes in milliseconds
#define MAX_SETUP_STRING_LEN        256


#define CP_PREFIX_W2K               _T("Win2K")
#define CP_PREFIX_SBS               _T("SBS")


#define FAXOCM_NAME                 _T("FAXOCM.DLL")
#define CPDIR_RESOURCE_ID           627


#define REGKEY_PFW_ROUTING          _T("Routing")
#define REGKEY_SBS50SERVER          _T("Software\\Microsoft\\SharedFax")


#define REGVAL_PFW_OUTBOXDIR        _T("ArchiveDirectory")
#define REGVAL_PFW_INBOXDIR         _T("Store Directory")


#endif  // _FXOCUPGRADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocupgrade.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	fxocUpgrade.cpp

Abstract:

	Implementation of the Upgrade process

Author:

	Iv Garber (IvG)	Mar, 2001

Revision History:

--*/

#include "faxocm.h"
#pragma hdrstop


//
//  EnumDevicesType is used to call prv_StoreDevices() callback function during the Enumeration of
//      Devices in the Registry.
//
typedef enum prv_EnumDevicesType
{
    edt_None        =   0x00,
    edt_SBSDevices  =   0x01,       //  Enumerate SBS 5.0 Server Devices
    edt_PFWDevices  =   0x02,       //  Enumerate W2K Fax Devices
    edt_Inbox       =   0x04        //  Find List of Inbox Folders for W2K Fax
};


//
//  Local Static Variable, to store data between OS Manager calls
//
static struct prv_Data
{
    bool    fSBS50ServerInstalled;  //  whether SBS 5.0 Server is installed before upgrade
    bool    fSBS50ClientInstalled;  //  whether SBS 5.0 Client is installed before upgrade
    bool    fXPDLClientInstalled;   //  whether XP DL Client is installed before upgrade

    //
    //  data for SBS 5.0 Server
    //
    PRINTER_INFO_2  *pPrinters;     //  array of ALL printers installed on the machine before upgrade
    DWORD           dwNumPrinters;  //  TOTAL number of printers in the pPrinters array

    //
    //  data for PFW
    //
    TCHAR   tszCommonCPDir[MAX_PATH];   //  Folder for Common Cover Pages 
    LPTSTR  *plptstrInboxFolders;       //  Array of different Inbox Folders 
    DWORD   dwInboxFoldersCount;        //  number of Inbox Folders in the plptstrInboxFolders array

} prv_Data = 
{
    false,                      //  fSBS50ServerInstalled
    false,                      //  fSBS50ClientInstalled
    false,                      //  fXPDLClientInstalled

    NULL,                       //  pPrinters
    0,                          //  dwNumPrinters

    {0},                        //  tszCommonCPDir
    NULL,                       //  plptstrInboxFolders
    0                           //  dwInboxFoldersCount
};

//
//  Internal assisting functions
//
static DWORD prv_StorePrinterConnections(void);
static DWORD prv_RestorePrinterConnections(void);

static DWORD prv_UninstallProduct(LPTSTR lptstrProductCode);

BOOL prv_StoreDevices(HKEY hKey, LPWSTR lpwstrKeyName, DWORD dwIndex, LPVOID lpContext);

static DWORD prv_MoveCoverPages(LPTSTR lptstrSourceDir, LPTSTR lptstrDestDir, LPTSTR lptstrPrefix);

static DWORD prv_GetPFWCommonCPDir(void);
static DWORD prv_GetSBSServerCPDir(LPTSTR lptstrCPDir) {return NO_ERROR; };

static DWORD prv_SaveArchives(void);


DWORD fxocUpg_WhichFaxWasUninstalled(
    DWORD   dwFaxAppList
)
/*++

Routine name : fxocUpg_WhichFaxWasUninstalled

Routine description:

	Set flags regarding fax applications installed before upgrade. Called from SaveUnattendedData() if 
    the corresponding data is found in the Answer File.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

	FaxApp      [in]    - the combination of the applications that were installed before the upgrade

Return Value:

    Standard Win32 error code

--*/
{
    DWORD   dwReturn = NO_ERROR;

    DBG_ENTER(_T("fxocUpg_WhichFaxWasUninstalled"), dwReturn);

    if (dwFaxAppList & FXSTATE_UPGRADE_APP_SBS50_CLIENT)
    {
        prv_Data.fSBS50ClientInstalled = true;
    }

    if (dwFaxAppList & FXSTATE_UPGRADE_APP_XP_CLIENT)
    {
        prv_Data.fXPDLClientInstalled = true;
    }

    if (dwFaxAppList & FXSTATE_UPGRADE_APP_SBS50_SERVER)
    {
        prv_Data.fSBS50ServerInstalled = true;
    }

    return dwReturn;
}


DWORD fxocUpg_GetUpgradeApp(void)
/*++

Routine name : fxocUpg_GetUpgradeApp

Routine description:

	Return type of the upgrade, which indicates which fax applications were installed before the upgrade.

Author:

	Iv Garber (IvG),	May, 2001

Return Value:

    The type of the upgrade

--*/
{
    DWORD   dwFlags = FXSTATE_UPGRADE_APP_NONE;

    if (prv_Data.fSBS50ServerInstalled)
    {
        dwFlags |= FXSTATE_UPGRADE_APP_SBS50_SERVER;
    }

    if (prv_Data.fSBS50ClientInstalled)
    {
        dwFlags |= FXSTATE_UPGRADE_APP_SBS50_CLIENT;
    }

    if (prv_Data.fXPDLClientInstalled)
    {
        dwFlags |= FXSTATE_UPGRADE_APP_XP_CLIENT;
    }

    return dwFlags;
}


DWORD fxocUpg_Init(void)
/*++

Routine name : fxocUpg_Init

Routine description:

	checks which Fax applications are installed on the machine, 
    and set global flags in prv_Data.

Author:

	Iv Garber (IvG),	May, 2001

Return Value:

    DWORD - failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
                                                  
    DBG_ENTER(_T("fxocUpg_Init"), dwReturn);

    //
    //  Initialize the flags to the default value.
    //
    prv_Data.fSBS50ServerInstalled = false;

    //
    //  Check presence of the SBS 5.0 Server 
    //
    dwReturn = CheckInstalledFax(NULL, NULL, &(prv_Data.fSBS50ServerInstalled));
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_WARNING, _T("CheckInstalledFax() failed, ec=%ld."), dwReturn);
    }

    return dwReturn;
}


DWORD fxocUpg_SaveSettings(void)
/*++

Routine name : fxocUpg_SaveSettings

Routine description:

    Save settings of SBS 5.0 Server to allow smooth migration to the Windows XP Fax.

    Device Settings should be stored BEFORE handling of the Registry ( which deletes the Devices key )
        and BEFORE the Service Start ( which creates new devices and uses settings that are stored here ).

Author:

	Iv Garber (IvG),	May, 2001

Return Value:

    DWORD   -   failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
    HKEY    hKey        = NULL;
    DWORD   dwEnumType  = edt_None;

    DBG_ENTER(_T("fxocUpg_SaveSettings"), dwReturn);

    if (prv_Data.fSBS50ServerInstalled)
    {
        //
        //  For SBS 5.0 0 Server -- Save Fax Printer and Printer Connections.
        //
        dwReturn = prv_StorePrinterConnections();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, 
                _T("prv_StorePrinterConnections() for SBS 5.0 Server is failed, ec=%ld"), 
                dwReturn);
        }

        //
        //  For SBS 5.0 Server -- Save Device Settings
        //
        hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_SBS50SERVER, FALSE, KEY_READ);
        if (!hKey)
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to open Registry for SBS 5.0 Server, ec = %ld."), dwReturn);
        }
        else
        {
            dwEnumType = edt_SBSDevices;
            dwReturn = EnumerateRegistryKeys(hKey, REGKEY_DEVICES, FALSE, prv_StoreDevices, &dwEnumType);
            VERBOSE(DBG_MSG, _T("For SBS 5.0 Server, enumerated %ld devices."), dwReturn);

            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    //
    //  Handle Upgrade from W2K/PFW Fax
    //
    if ( (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_NT) || (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_W2K) )
    {
        //
        //  Save its Common CP Dir. This should be done BEFORE Copy/Delete Files of Windows XPFax.
        //
        dwReturn = prv_GetPFWCommonCPDir();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_GetPFWCommonCPDir() failed, ec=%ld."), dwReturn);
        }

        //
        //  Store Device Settings of PFW -- if SBS 5.0 Server is not present on the machine.
        //  Also, find Inbox Folders List of the PFW Devices.
        //
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ);
        if (!hKey)
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax, ec = %ld."), dwReturn);
            return dwReturn;
        }

        if (prv_Data.fSBS50ServerInstalled)
        {
            //
            //  Devices already enumerated, through SBS 5.0 Server
            //  Enumerate only Inbox Folders
            //
            dwEnumType = edt_Inbox;
        }
        else
        {
            //
            //  Full Enumeration for PFW Devices : Devices Settings + Inbox Folders
            //
            dwEnumType = edt_PFWDevices | edt_Inbox;
        }
        
        dwReturn = EnumerateRegistryKeys(hKey, REGKEY_DEVICES, FALSE, prv_StoreDevices, &dwEnumType);
        VERBOSE(DBG_MSG, _T("For PFW, enumerated %ld devices."), dwReturn);

        RegCloseKey(hKey);

        //
        //  prv_StoreDevices stored list of PFW's Inbox Folders in prv_Data.
        //  Now save the Inbox Folders List and SentItems Folder
        //
        dwReturn = prv_SaveArchives();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_SaveArchives() failed, ec=%ld."), dwReturn);
        }

        dwReturn = NO_ERROR;
    }

    return dwReturn;
}


static DWORD prv_StorePrinterConnections(void)
/*++

Routine name : prv_StorePrinterConnections

Routine description:

	Store Printer Connections. 
    Used when upgrading from SBS 5.0 Server to Windows XP Fax.
    Stores Printer Connections in prv_Data.
    Stores ALL Printer Connections, but only if ANY Fax Printer/Printer Connection is present.

Author:

	Iv Garber (IvG),	Mar, 2001

Return Value:

    static DWORD    --  success or failure

--*/
{
    DWORD           dwReturn = NO_ERROR;
    bool            bFaxPrinterFound = false;

    DBG_ENTER(_T("prv_StorePrinterConnections"), dwReturn);

    //
    //  Set defaults
    //
    prv_Data.pPrinters = NULL;
    prv_Data.dwNumPrinters = 0;

    //
    //  Get array of all the printers installed on the machine
    //
    prv_Data.pPrinters = (PPRINTER_INFO_2)MyEnumPrinters(NULL, 
        2, 
        &(prv_Data.dwNumPrinters), 
        (PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS));

    if (!(prv_Data.pPrinters))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Zero Printers Found, ec = %ld"), dwReturn);

        prv_Data.pPrinters = NULL;
        prv_Data.dwNumPrinters = 0;
        return dwReturn;
    }

    VERBOSE(DBG_MSG, _T("Found Total of %d printers"), prv_Data.dwNumPrinters);

    //
    //  find the Fax Printer Connection. 
    //  This is indicated by Printer with Driver Name equal to "Microsoft Shared Fax Driver"
    //
    for ( DWORD i = 0 ; i < prv_Data.dwNumPrinters ; i++ ) 
    {
        if ( _tcsicmp(prv_Data.pPrinters[i].pDriverName, FAX_DRIVER_NAME) == 0)
        {
            //
            //  found at least one fax printer connection
            //
            bFaxPrinterFound = true;
            break;
        }
    }

    if (!bFaxPrinterFound)
    {
        //
        //  did not find any fax printer connection
        //
        MemFree(prv_Data.pPrinters);
        prv_Data.pPrinters = NULL;
        prv_Data.dwNumPrinters = 0;

        VERBOSE(DBG_WARNING, _T("No Shared Fax Printer Connections is found, ec = %ld"));
        return dwReturn;
    }

    VERBOSE(DBG_MSG, _T("Found at least one Shared Fax Printer Connection."));

    //
    //  ALL printers are stored. They will be processed in fxocUpg_RestoreSettings()
    //
    return dwReturn;
}

 
BOOL
prv_StoreDevices(HKEY hDeviceKey,
                LPWSTR lpwstrKeyName,
                DWORD dwIndex,
                LPVOID lpContextData
)
/*++

Routine name : prv_StoreDevices

Routine description:

	Callback function used in enumeration of devices in the registry.

    Stores device's data in the Registry, under Setup/Original Setup Data.
    Creates List of Inbox Folders ( used for PFW ) and saves it in the prv_Data.

    Used when upgrading from PFW/SBS 5.0 Server to Windows XP Fax.

Author:

	Iv Garber (IvG),	Mar, 2001

Arguments:

	hKey            [in]    - current key
	lpwstrKeyName   [in]    - name of the current key, if exists
	dwIndex         [in]    - count of all the subkeys for the given key / index of the current key
	lpContextData   [in]    - NULL, not used

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    HKEY    hSetupKey = NULL;
    DWORD   dwReturn = NO_ERROR;
    DWORD   dwNumber = 0;
    TCHAR   tszNewKeyName[MAX_PATH] = {0};
    LPTSTR  lptstrString = NULL;
    DWORD   *pdwEnumType = NULL;

    DBG_ENTER(_T("prv_StoreDevices"));

    if (lpwstrKeyName == NULL) 
    {
        //
        //  This is the SubKey we started at ( i.e. Devices )
        //  
        //  If InboxFolders should be stored, then allocate 
        //      enough memory for prv_Data.plptstrInboxFolders.
        //  dwIndex contains TOTAL number of subkeys ( Devices ).
        //
        pdwEnumType = (DWORD *)lpContextData;

        if ( (*pdwEnumType & edt_Inbox) == edt_Inbox )
        {
            prv_Data.plptstrInboxFolders = (LPTSTR *)MemAlloc(sizeof(LPTSTR) * dwIndex);
            if (prv_Data.plptstrInboxFolders)
            {
                ZeroMemory(prv_Data.plptstrInboxFolders, sizeof(LPTSTR) * dwIndex);
            }
            else
            {
                //
                //  Not enough memory
                //
                VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
            }
        }

        return TRUE;
    }

    //
    //  The per Device section
    //

    //
    //  Store Device's Inbox Folder
    //
    if (prv_Data.plptstrInboxFolders)
    {
        //
        //  we are here only when lpContextData contains edt_InboxFolders
        //      and the memory allocation succeded.
        //

        //
        //  Open Routing SubKey 
        //
        hSetupKey = OpenRegistryKey(hDeviceKey, REGKEY_PFW_ROUTING, FALSE, KEY_READ);
        if (!hSetupKey)
        {
            //
            //  Failed to open Routing Subkey
            //
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to open 'Registry' Key for Device #ld, ec = %ld."), dwIndex, dwReturn);
            goto ContinueStoreDevice;
        }

        //
        //  Take 'Store Directory' Value
        //
        lptstrString = GetRegistryString(hSetupKey, REGVAL_PFW_INBOXDIR, EMPTY_STRING);
        if ((!lptstrString) || (_tcslen(lptstrString) == 0))
        {
            //
            //  Failed to take the value
            //
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to get StoreDirectory value for Device #ld, ec = %ld."), dwIndex, dwReturn);
            goto ContinueStoreDevice;
        }

        //
        //  Check if it is already present
        //
        DWORD dwI;
        for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
        {
            if (prv_Data.plptstrInboxFolders[dwI])
            {
                if (_tcscmp(prv_Data.plptstrInboxFolders[dwI], lptstrString) == 0)
                {
                    //
                    //  String found
                    //
                    goto ContinueStoreDevice;
                }
            }
        }

        //
        //  String was NOT found between all already registered string, so add it
        //
        prv_Data.plptstrInboxFolders[dwI] = LPTSTR(MemAlloc(sizeof(TCHAR) * (_tcslen(lptstrString) + 1)));
        if (prv_Data.plptstrInboxFolders[dwI])
        {
            //
            //  copy string & update the counter
            //
            _tcscpy(prv_Data.plptstrInboxFolders[dwI], lptstrString);
            prv_Data.dwInboxFoldersCount++;
        }
        else
        {
            //
            //  Not enough memory
            //
            VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
        }

ContinueStoreDevice:

        if (hSetupKey)
        {
            RegCloseKey(hSetupKey);
            hSetupKey = NULL;
        }

        MemFree(lptstrString);
        lptstrString = NULL;
    }

    //
    //  Check whether to store Device's Data and how
    //
    pdwEnumType = (DWORD *)lpContextData;

    if ((*pdwEnumType & edt_SBSDevices) == edt_SBSDevices)
    {
        //
        //  Store SBS Devices Data
        //
        lptstrString = REGVAL_TAPI_PERMANENT_LINEID;
    }
    else if ((*pdwEnumType & edt_PFWDevices) == edt_PFWDevices)
    {
        //
        //  Store PFW Devices Data
        //
        lptstrString = REGVAL_PERMANENT_LINEID;
    }
    else
    {
        //
        //  no need to save any Device Data
        //
        return TRUE;
    }

    //
    //  Take Device's Permanent Line Id
    //
    dwReturn = GetRegistryDwordEx(hDeviceKey, lptstrString, &dwNumber);
    if (dwReturn != ERROR_SUCCESS)
    {
        //
        //  Cannot find TAPI Permanent LineId --> This is invalid Device Registry
        //
        return TRUE;
    }

    VERBOSE(DBG_MSG, _T("Current Tapi Line Id = %ld"), dwNumber);

    //
    //  Create a SubKey Name from it
    //
    _sntprintf(tszNewKeyName, MAX_PATH, TEXT("%s\\%010d"), REGKEY_FAX_SETUP_ORIG, dwNumber);
    hSetupKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, tszNewKeyName, TRUE, 0);
    if (!hSetupKey)
    {
        //
        //  Failed to create registry key
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, 
            _T("Failed to create a SubKey for the Original Setup Data of the Device, ec = %ld."), 
            dwReturn);

        //
        //  Continue to the next device
        //
        return TRUE;
    }

    //
    //  Set the Flags for the newly created key
    //
    dwNumber = GetRegistryDword(hDeviceKey, REGVAL_FLAGS);
    SetRegistryDword(hSetupKey, REGVAL_FLAGS, dwNumber);
    VERBOSE(DBG_MSG, _T("Flags are : %ld"), dwNumber);

    //
    //  Set the Rings for the newly created key
    //
    dwNumber = GetRegistryDword(hDeviceKey, REGVAL_RINGS);
    SetRegistryDword(hSetupKey, REGVAL_RINGS, dwNumber);
    VERBOSE(DBG_MSG, _T("Rings are : %ld"), dwNumber);

    //
    //  Set the TSID for the newly created key
    //
    lptstrString = GetRegistryString(hDeviceKey, REGVAL_ROUTING_TSID, REGVAL_DEFAULT_TSID);
    SetRegistryString(hSetupKey, REGVAL_ROUTING_TSID, lptstrString);
    VERBOSE(DBG_MSG, _T("TSID is : %s"), lptstrString);
    MemFree(lptstrString);

    //
    //  Set the CSID for the newly created key
    //
    lptstrString = GetRegistryString(hDeviceKey, REGVAL_ROUTING_CSID, REGVAL_DEFAULT_CSID);
    SetRegistryString(hSetupKey, REGVAL_ROUTING_CSID, lptstrString);
    VERBOSE(DBG_MSG, _T("CSID is : %s"), lptstrString);
    MemFree(lptstrString);

    RegCloseKey(hSetupKey);
    return TRUE;
}


DWORD fxocUpg_Uninstall() 
/*++

Routine name : fxocUpg_Uninstall()

Routine description:

	Upgrade the current Fax applications and replace them by the Windows XP Fax.
    Uninstall them after we stored all the needed information for restore.

    Currently supports uninstall of SBS 5.0 Server.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

Return Value:

    DWORD - failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;

    DBG_ENTER(_T("fxocUpg_Uninstall"), dwReturn);

    if (prv_Data.fSBS50ServerInstalled)
    {
        //
        //  SBS 5.0 Server is installed --> should be uninstalled
        //
        dwReturn = prv_UninstallProduct(PRODCODE_SBS50SERVER);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("Failed to Uninstall SBS 5.0 Server, ec = %ld"), dwReturn);
        }
    }

    return dwReturn;
}

static DWORD prv_UninstallProduct(
    LPTSTR lptstrProductCode
) 
/*++

Routine name : prv_UninstallProduct()

Routine description:

    Uninstall the Product using MsiExec.Exe and given Product Code.
    Called from the fxoc_Upgrade().

Author:

	Iv Garber (IvG),	Feb, 2001

Arguments:

Return Value:

    DWORD - failure or success

--*/
{
    DWORD               dwReturn = NO_ERROR;
    STARTUPINFO         sui = {0};
    PROCESS_INFORMATION pi = {0};
    TCHAR               tszCommandLine[MAX_SETUP_STRING_LEN] = 
        _T("msiexec.exe REBOOT=ReallySuppress REMOVE=ALL /q /x ");

    DBG_ENTER(_T("prv_UninstallProduct"), dwReturn);

    //
    //  Append the product code to the command line
    //
    _tcsncat(tszCommandLine, lptstrProductCode, (MAX_SETUP_STRING_LEN - _tcslen(tszCommandLine) - 1));

    //
    //  Create process for uninstall
    //
    ZeroMemory(&sui, sizeof(sui));
    ZeroMemory(&pi, sizeof(pi));
    sui.cb = sizeof(STARTUPINFO);

    if(CreateProcess(NULL,              //  module name
        tszCommandLine,                 // command line
        NULL,                           //  handle to SECURITY_ATTRIBUTES, NULL means process's handle is not inheritable
        NULL,                           //  the same about thread handle 
        TRUE,                           //  inherit all caller's inheritable handles
        CREATE_UNICODE_ENVIRONMENT | NORMAL_PRIORITY_CLASS,     //  priority & creation flags
        NULL,                           //  use environment block of the caller process
        NULL,                           //  use current directory of the caller process
        &sui,                           //  start-up information for the new process
        &pi))                           //  result : info about new created process
    {
        //
        //  Successed to create new process
        //
        VERBOSE(DBG_MSG, _T("CreateProcess for msiexec successed."));

        //
        //  wait until its done
        //
        dwReturn = WaitForMultipleObjects(1, &pi.hProcess, FALSE, UNINSTALL_TIMEOUT);

        if (dwReturn == WAIT_OBJECT_0)
        {
            //
            //  the process has ended
            //
            VERBOSE(DBG_MSG, _T("'msiexec.exe' process is ended."));
        }
        else
        {
            //
            //  dwReturn == WAIT_FAILED or WAIT_TIMEOUT
            //
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("WaitForMultipleObjects() failed : ec = %ld OR timeout-ed."), dwReturn);
            goto Exit;
        }

        //
        //  check process'es return code
        //
        if (!GetExitCodeProcess(pi.hProcess, &dwReturn))
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("GetExitCodeProcess() failed, ec=%ld"), dwReturn);
            goto Exit;
        }
        else
        {
            VERBOSE(DBG_MSG, _T("GetExitCodeProcess returned %ld."), dwReturn);

            if (dwReturn == ERROR_SUCCESS_REBOOT_REQUIRED)
            {
                VERBOSE(DBG_WARNING, _T("Uninstall of SBS 5.0 Server requires Reboot."));
                dwReturn = NO_ERROR;
            }
        }
    }
    else
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to create new 'msiexec.exe' process, ec=%ld."), dwReturn);
    }

Exit:
    if (pi.hProcess)
    {
        CloseHandle(pi.hProcess);
    }

    if (pi.hThread)
    {
        CloseHandle(pi.hThread);
    }

    return dwReturn;
}

DWORD fxocUpg_RestoreSettings(void) 
/*++

Routine name : fxocUpg_RestoreSettings

Routine description:

    Restore settings that were stored at the SaveSettings().

Author:

	Iv Garber (IvG),	Feb, 2001

Return Value:

    DWORD - failure or success

--*/
{ 
    DWORD   dwReturn = NO_ERROR;
    HANDLE  hPrinter = NULL;

    DBG_ENTER(_T("fxocUpg_RestoreSettings"), dwReturn);

    if (prv_Data.fSBS50ServerInstalled)
    {
        //
        //  Restore the Printer Connections
        //
        dwReturn = prv_RestorePrinterConnections();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_RestorePrinterConnections() failed, ec = %ld"), dwReturn);
        }
    }

    return dwReturn;
}


static DWORD prv_RestorePrinterConnections(void)
/*++

Routine name : prv_RestorePrinterConnections

Routine description:

    Restore Printer Connections that were stored at prv_StorePrinterConnections().

Author:

	Iv Garber (IvG),	Feb, 2001

Return Value:

    DWORD - failure or success

--*/
{ 
    DWORD   dwReturn = NO_ERROR;
    HANDLE  hPrinter = NULL;

    DBG_ENTER(_T("prv_RestorePrinterConnections"), dwReturn);


    if (!prv_Data.pPrinters || (prv_Data.dwNumPrinters == 0))
    {
        //
        //  There was some error at Preparations stage and nothing is available for restore
        //
        VERBOSE(DBG_MSG, _T("Nothing to restore."));
        return dwReturn;
    }

    //
    //  go over all the printers before the upgrade and find Fax Printer Connections
    //
    for ( DWORD i = 0 ; i < prv_Data.dwNumPrinters ; i++ ) 
    {
        if ( _tcsicmp(prv_Data.pPrinters[i].pDriverName, FAX_DRIVER_NAME) == 0)
        {
            //
            //  This is SBS 5.0 Server Fax Printer Connection.
            //  SBS 5.0 Uninstall removed this from the system.
            //  We need to put it back.
            //
            hPrinter = AddPrinter(NULL, 2, LPBYTE(&(prv_Data.pPrinters[i])));
            if (!hPrinter)
            {
                //
                //  Failed to add printer
                //
                dwReturn = GetLastError();
                VERBOSE(DBG_WARNING, _T("Failed to restore printer # %d, ec=%ld."), i, dwReturn);
                continue;
            }

            VERBOSE(DBG_MSG, _T("Installed printer # %d."), i);
            ClosePrinter(hPrinter);
            hPrinter = NULL;
        }
    }

    MemFree(prv_Data.pPrinters);
    prv_Data.pPrinters = NULL;
    prv_Data.dwNumPrinters = 0;

    return dwReturn;
}


DWORD fxocUpg_MoveFiles(void)
/*++

Routine name : fxocUpg_MoveFiles

Routine description:

    Move files from the folders that should be deleted.
    Should be called BEFORE directories delete.

Author:

	Iv Garber (IvG),	Feb, 2001

Return Value:

    DWORD - failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
    TCHAR   tszDestination[MAX_PATH] = {0};
    LPTSTR  lptstrCPDir = NULL;

    DBG_ENTER(_T("fxocUpg_MoveFiles"), dwReturn);

    if ( (fxState_IsUpgrade() != FXSTATE_UPGRADE_TYPE_NT) && 
        (fxState_IsUpgrade() != FXSTATE_UPGRADE_TYPE_W2K) && 
        !prv_Data.fSBS50ServerInstalled )
    {
        //
        //  This is not PFW / SBS 5.0 Server upgrade. Do nothing
        //
        VERBOSE(DBG_MSG, _T("No need to Move any Files from any Folders."));
        return dwReturn;
    }

    //
    //  Find Destination Folder : COMMON APP DATA + ServiceCPDir from the Registry
    //
    if (!GetServerCpDir(NULL, tszDestination, MAX_PATH))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetServerCPDir() failed, ec=%ld."), dwReturn);
        return dwReturn;
    }

    if ( (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_NT) || (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_W2K) )
    {
        //
        //  PFW Server CP Dir is stored at SaveSettings() in prv_Data.lptstrPFWCommonCPDir
        //
        dwReturn = prv_MoveCoverPages(prv_Data.tszCommonCPDir, tszDestination, CP_PREFIX_W2K);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_MoveCoverPages() for Win2K failed, ec = %ld"), dwReturn);
        }
    }

    if (prv_Data.fSBS50ServerInstalled)
    {
        //
        //  Get SBS Server CP Dir
        //
        dwReturn = prv_GetSBSServerCPDir(lptstrCPDir);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_GetSBSServerCPDir() failed, ec=%ld"), dwReturn);
            return dwReturn;
        }

        //
        //  Move Cover Pages
        //
        dwReturn = prv_MoveCoverPages(lptstrCPDir, tszDestination, CP_PREFIX_SBS);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_MoveCoverPages() for SBS failed, ec = %ld"), dwReturn);
        }

        MemFree(lptstrCPDir);
    }

    return dwReturn;
}


static DWORD
prv_MoveCoverPages(
    LPTSTR lptstrSourceDir,
	LPTSTR lptstrDestDir,
	LPTSTR lptstrPrefix
)
/*++

Routine name : prv_MoveCoverPages

Routine description:

	Move all the Cover Pages from Source folder to Destination folder
    and add a prefix to all the Cover Page names.

Author:

	Iv Garber (IvG),	Mar, 2001

Arguments:

	lptstrSourceDir              [IN]    - Source Directory where Cover Pages are reside before the upgrade
	lptstrDestDir                [IN]    - where the Cover Pages should reside after the upgrade
	lptstrPrefix                 [IN]    - prefix that should be added to the Cover Page file names

Return Value:

    Success or Failure Error Code.

--*/
{
    DWORD           dwReturn            = ERROR_SUCCESS;
	TCHAR           szSearch[MAX_PATH]  = {0};
	HANDLE          hFind               = NULL;
    WIN32_FIND_DATA FindFileData        = {0};
	TCHAR           szFrom[MAX_PATH]    = {0};
	TCHAR           szTo[MAX_PATH]      = {0};

    DBG_ENTER(_T("prv_MoveCoverPages"), dwReturn);

    if ((!lptstrSourceDir) || (_tcslen(lptstrSourceDir) == 0))
    {
        //
        //  we do not know from where to take Cover Pages 
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        VERBOSE(DBG_WARNING, _T("SourceDir is NULL. Cannot move Cover Pages. Exiting..."));
        return dwReturn;
    }

    if ((!lptstrDestDir) || (_tcslen(lptstrDestDir) == 0))
    {
        //
        //  we do not know where to put the Cover Pages
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        VERBOSE(DBG_WARNING, _T("DestDir is NULL. Cannot move Cover Pages. Exiting..."));
        return dwReturn;
    }

    //
    //  Find all Cover Page files in the given Source Directory
    //
	_sntprintf(szSearch, MAX_PATH, _T("%s\\*.cov"), lptstrSourceDir);

	hFind = FindFirstFile(szSearch, &FindFileData);
	if (INVALID_HANDLE_VALUE == hFind)
	{
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, 
            _T("FindFirstFile() on %s folder for Cover Pages is failed, ec = %ld"), 
            lptstrSourceDir,
            dwReturn);
        return dwReturn;
	}

    //
    //  Go for each Cover Page 
    //
    do
    {
        //
        //  This is full current Cover Page file name
        //
        _sntprintf(szFrom, MAX_PATH, _T("%s\\%s"), lptstrSourceDir, FindFileData.cFileName);

        //
        //  This is full new Cover Page file name
        //
        _sntprintf(szTo, MAX_PATH, _T("%s\\%s_%s"), lptstrDestDir, lptstrPrefix, FindFileData.cFileName);

        //
        //  Move the file
        //
        if (!MoveFile(szFrom, szTo))
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("MoveFile() for %s Cover Page failed, ec=%ld"), szFrom, dwReturn);
        }

    } while(FindNextFile(hFind, &FindFileData));

    VERBOSE(DBG_MSG, _T("last call to FindNextFile() returns %ld."), GetLastError());

    //
    //  Close Handle
    //
    FindClose(hFind);

    return dwReturn;
}


static DWORD prv_GetPFWCommonCPDir(
) 
/*++

Routine name : prv_GetPFWCommonCPDir

Routine description:

	Return Folder for Common Cover Pages used for PFW.

    This Folder is equal to : CSIDL_COMMON_DOCUMENTS + Localized Dir
    This Localized Dir name we can take from the Resource of Win2K's FaxOcm.Dll.
    So, this function should be called BEFORE Copy/Delete Files of Install that will remove old FaxOcm.Dll.
    Currently it is called at SaveSettings(), which IS called before CopyFiles.

Author:

	Iv Garber (IvG),	Mar, 2001

Return Value:

    static DWORD    --  failure or success

--*/
{
    DWORD   dwReturn            = NO_ERROR;
    HMODULE hModule             = NULL;
    TCHAR   tszName[MAX_PATH]   = {0};

    DBG_ENTER(_T("prv_GetPFWCommonCPDir"), dwReturn);

    //
    //  find full path to FaxOcm.Dll
    //
    if (!GetSpecialPath(CSIDL_SYSTEM, tszName))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetSpecialPath(CSIDL_SYSTEM) failed, ec = %ld"), dwReturn);
        return dwReturn;
    }

    if ((_tcslen(tszName) + _tcslen(FAXOCM_NAME)) > MAX_PATH)
    {
        //
        //  not enough place
        //
        dwReturn = ERROR_OUTOFMEMORY;
        VERBOSE(DBG_WARNING, _T("FaxOcm.Dll path is too long, ec = %ld"), dwReturn);
        return dwReturn;
    }

    ConcatenatePaths(tszName, FAXOCM_NAME);
    VERBOSE(DBG_MSG, _T("Full Name of FaxOcm is %s"), tszName);

    hModule = LoadLibraryEx(tszName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (!hModule)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("LoadLibrary(%s) failed, ec = %ld."), tszName, dwReturn);
        return dwReturn;
    }

    dwReturn = LoadString(hModule, CPDIR_RESOURCE_ID, tszName, MAX_PATH);
    if (dwReturn == 0)
    {
        //
        //  Resource string is not found
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("LoadString() failed, ec = %ld."), dwReturn);
        goto Exit;
    }

    VERBOSE(DBG_MSG, _T("FaxOcm returned '%s'"), tszName);

    //
    //  Take the Base part of the Folder name
    //
    if (!GetSpecialPath(CSIDL_COMMON_DOCUMENTS, prv_Data.tszCommonCPDir))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetSpecialPath(CSIDL_COMMON_DOCUMENTS) failed, ec = %ld"), dwReturn);
        prv_Data.tszCommonCPDir[0] = _T('\0');
        goto Exit;
    }

    //
    //  Combine the full Folder name
    //
    if ((_tcslen(tszName) + _tcslen(prv_Data.tszCommonCPDir)) > MAX_PATH)
    {
        //
        //  not enough place
        //
        dwReturn = ERROR_OUTOFMEMORY;
        VERBOSE(DBG_WARNING, _T("Full path to the Common CP dir for PFW is too long, ec = %ld"), dwReturn);
        goto Exit;
    }

    ConcatenatePaths(prv_Data.tszCommonCPDir, tszName);

    VERBOSE(DBG_MSG, _T("Full path for Common PFW Cover Pages is '%s'"), prv_Data.tszCommonCPDir);

Exit:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return dwReturn; 
}

static DWORD prv_SaveArchives(
) 
/*++

Routine name : prv_SaveArchives

Routine description:

	Store PFW SentItems & Inbox Archive Folder. 

    SentItems is taken from Registry : under Fax/Archive Directory.

    Inbox Folders List is created by prv_StoreDevices(), that should be called before and that fills
        prv_Data.plptstrInboxFolder with an array of Inbox Folders.
    This function transforms the data in prv_Data.plptstrInboxFolders into the required format,
        and stores in the Registry.

    Frees the prv_Data.plptstrInboxFolders.

Author:

	Iv Garber (IvG),	Mar, 2001

Return Value:

    static DWORD    --  failure or success

--*/
{
    DWORD   dwReturn        = NO_ERROR;
    DWORD   dwListLen       = 0;
    DWORD   dwI             = 0;
    HKEY    hFromKey        = NULL;
    HKEY    hToKey          = NULL;
    LPTSTR  lptstrFolder    = NULL;
    LPTSTR  lptstrCursor    = NULL;

    DBG_ENTER(_T("prv_SaveArchives"), dwReturn);

    //
    //  Open Registry Key to read the ArchiveDirectory value
    //
    hFromKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ);
    if (!hFromKey)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax, ec = %ld."), dwReturn);
        goto Exit;
    }

    //
    //  Open Registry Key to write the Archive values
    //
    hToKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, FALSE, KEY_SET_VALUE);
    if (!hToKey)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax/Setup, ec = %ld."), dwReturn);
        goto Exit;
    }

    //
    //  Read & Write Outgoing Archive Folder
    //
    lptstrFolder = GetRegistryString(hFromKey, REGVAL_PFW_OUTBOXDIR, EMPTY_STRING);
    VERBOSE(DBG_MSG, _T("Outgoing Archive Folder is : %s"), lptstrFolder);
    SetRegistryString(hToKey, REGVAL_W2K_SENT_ITEMS, lptstrFolder);
    MemFree(lptstrFolder);
    lptstrFolder = NULL;

    //
    //  Create valid REG_MULTI_SZ string from List of Inbox Folders 
    //
    if (!prv_Data.plptstrInboxFolders || prv_Data.dwInboxFoldersCount == 0)
    {
        //
        //  no Inbox Folders found
        //
        goto Exit;
    }

    //
    //  Calculate the length of the string 
    //
    for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
    {
        dwListLen += _tcslen(prv_Data.plptstrInboxFolders[dwI]) + 1;
    }

    //
    //  Allocate that string
    //
    lptstrFolder = LPTSTR(MemAlloc((dwListLen + 1) * sizeof(TCHAR)));
    if (!lptstrFolder)
    {
        //
        //  Not enough memory
        //
        VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
        goto Exit;
    }
    
    ZeroMemory(lptstrFolder, ((dwListLen + 1) * sizeof(TCHAR)));

    lptstrCursor = lptstrFolder;

    //
    //  Fill with the Inbox Folders
    //
    for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
    {
        if (prv_Data.plptstrInboxFolders[dwI])
        {
            _tcscpy(lptstrCursor, prv_Data.plptstrInboxFolders[dwI]);
            lptstrCursor += _tcslen(prv_Data.plptstrInboxFolders[dwI]) + 1;
            MemFree(prv_Data.plptstrInboxFolders[dwI]);
        }
    }
    MemFree(prv_Data.plptstrInboxFolders);
    prv_Data.plptstrInboxFolders = NULL;
    prv_Data.dwInboxFoldersCount = 0;

    //
    //  Additional NULL at the end
    //
    *lptstrCursor = _T('\0');

    if (!SetRegistryStringMultiSz(hToKey, REGVAL_W2K_INBOX, lptstrFolder, ((dwListLen + 1) * sizeof(TCHAR))))
    {
        //
        //  Failed to store Inbox Folders
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to SetRegistryStringMultiSz() for W2K_Inbox, ec = %ld."), dwReturn);
    }

Exit:

    if (hFromKey)
    {
        RegCloseKey(hFromKey);
    }

    if (hToKey)
    {
        RegCloseKey(hToKey);
    }

    MemFree(lptstrFolder);

    if (prv_Data.plptstrInboxFolders)
    {
        for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
        {
            MemFree(prv_Data.plptstrInboxFolders[dwI]);
        }

        MemFree(prv_Data.plptstrInboxFolders);
        prv_Data.plptstrInboxFolders = NULL;
    }

    prv_Data.dwInboxFoldersCount = 0;

    return dwReturn;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxstate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxState.cpp
//
// Abstract:        This provides the state routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created file, cleanup routines
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

///////////////////////////////
// fxState_Init
//
// Initialize the state handling
// module for Faxocm.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxState_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init State module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxState_Term
//
// Terminate the state handling module
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxState_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term State module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxState_IsUnattended
//
// Determines if this is an unattended install
// It interprets flags given to us
// by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - TRUE if unattended install.
//      - FALSE if not.
//
BOOL fxState_IsUnattended(void)
{
    DWORDLONG   dwlFlags = 0;

    // get the setup flags.
    dwlFlags = faxocm_GetComponentFlags();

    // if SETOP_BATCH flag is set, then we are in unattended mode.
    return (dwlFlags & SETUPOP_BATCH) ? TRUE : FALSE;
}

///////////////////////////////
// fxState_IsCleanInstall
//
// Determines if this a clean install.
// A clean install is when we are 
// NOT upgrading, and we are not 
// running in stand alone mode (see below for def'n).
//
// Params:
//      - void.
// Returns:
//      - TRUE if clean install.
//      - FALSE if not.
//
BOOL fxState_IsCleanInstall(void)
{
    BOOL        bClean   = FALSE;    

    // a clean install is if we are NOT upgrading AND we are not in
    // stand alone mode.
    if (!fxState_IsUpgrade() && !fxState_IsStandAlone())
    {
        bClean = TRUE;
    }

    return bClean;
}

///////////////////////////////
// fxState_IsStandAlone
//
// Determines if we are running in
// standalone mode or not.  We are
// in this mode if the user started 
// us up via "sysocmgr.exe" found
// in %systemroot%\system32, as opposed
// to via the install setup, or the
// Add/Remove Windows Components.
//
// Params:
//      - void.
// Returns: 
//      - TRUE if we are in stand alone mode.
//      - FALSE if we are not.
//
BOOL fxState_IsStandAlone(void)
{
    DWORDLONG dwlFlags = 0;

    dwlFlags = faxocm_GetComponentFlags();

    return ((dwlFlags & SETUPOP_STANDALONE) ? TRUE : FALSE);
}

///////////////////////////////
// fxState_IsUpgrade
//
// Determines if we are upgrading
// the OS, as opposed to a clean
// installation.
//
// Params:
//      - void.
// Returns:
//      - fxState_UpgradeType_e enumerated
//        type indicating the type of upgrade.
//        (i.e. are we upgrading from Win9X,
//         W2K, etc).
//
fxState_UpgradeType_e fxState_IsUpgrade(void)
{
    fxState_UpgradeType_e   eUpgradeType = FXSTATE_UPGRADE_TYPE_NONE;
    DWORDLONG               dwlFlags     = 0;

    dwlFlags = faxocm_GetComponentFlags();

    if ((dwlFlags & SETUPOP_WIN31UPGRADE) == SETUPOP_WIN31UPGRADE)
    {
        eUpgradeType = FXSTATE_UPGRADE_TYPE_WIN31;
    }
    else if ((dwlFlags & SETUPOP_WIN95UPGRADE) == SETUPOP_WIN95UPGRADE)
    {
        eUpgradeType = FXSTATE_UPGRADE_TYPE_WIN9X;
    }
    else if ((dwlFlags & SETUPOP_NTUPGRADE) == SETUPOP_NTUPGRADE)
    {
        eUpgradeType = FXSTATE_UPGRADE_TYPE_NT;
    }

    return eUpgradeType;
}

///////////////////////////////
// fxState_IsOsServerBeingInstalled
//
// Are we installing the Server
// version of the OS, or a workstation
// or personal version.
//
// Params:
//      - void.
// Returns:
//      - TRUE if we are installing a server version.
//      - FALSE if we are not.

BOOL fxState_IsOsServerBeingInstalled(void)
{
    BOOL  bIsServerInstall  = FALSE;
    DWORD dwProductType     = 0;

    dwProductType = faxocm_GetProductType();

    if (dwProductType == PRODUCT_WORKSTATION)
    {
        bIsServerInstall = FALSE;
    }
    else
    {
        bIsServerInstall = TRUE;
    }

    return bIsServerInstall;
}

///////////////////////////////
// fxState_GetInstallType
//
// This function returns one
// of the INF_KEYWORD_INSTALLTYPE_*
// constants found in 
// fxconst.h/fxconst.cpp
//
// Params:
//      - pszCurrentSection - section we are installing from
// Returns:
//      - ptr to one of INF_KEYWORD_INSTALLTYPE_* constants.
//
const TCHAR* fxState_GetInstallType(const TCHAR* pszCurrentSection)
{
    DWORD dwErr                 = NO_ERROR;
    BOOL  bInstall              = TRUE;
    BOOL  bSelectionHasChanged  = FALSE;

    DBG_ENTER(_T("fxState_GetInstallType"),_T("%s"),pszCurrentSection);

    if (pszCurrentSection == NULL)
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // determine if we are installing or uninstalling
    dwErr = faxocm_HasSelectionStateChanged(pszCurrentSection, 
                                            &bSelectionHasChanged,
                                            &bInstall, 
                                            NULL);

    if (dwErr != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("faxocm_HasSelectionStateChanged failed, rc = 0x%lx"),
                dwErr);

        return NULL;
    }

    // we expect the INF to look something like this:
    // [Fax]
    //
    // FaxCleanInstall     = Fax.CleanInstall
    // FaxUpgradeFromWin9x = Fax.UpgradeFromWin9x
    // FaxUpgradeFromWinNT = Fax.UpgradeFromWinNT
    // FaxUninstall        = Fax.Uninstall
    //
    // [Fax.CleanInstall]
    // CopyFiles = ...
    // etc.
    //
    // Thus the goal of this function is to determine if we are
    // clean installing, upgrading, etc., and then get the section
    // name pointed to by one of 'FaxCleanInstall', 'FaxUpgradeFromWin9x'
    // 'FaxUpgradeFromWinNT', or 'FaxUninstall'.
    //
    // So for example, if we determined we are clean installing, then
    // this function will find the "FaxCleanInstall" keyword, and then
    // return "Fax.CleanInstall" in the 'pszSectionToProcess' buffer.

    if (bInstall)
    {
        fxState_UpgradeType_e eUpgrade = FXSTATE_UPGRADE_TYPE_NONE;

        if (fxState_IsCleanInstall())
        {
            // we are a clean install of the OS, user is not upgrading from
            // another OS, they are installing a clean version of the OS.
            return INF_KEYWORD_INSTALLTYPE_CLEAN;
        }
        else if (fxState_IsUpgrade())
        {
            // We are installing as an Upgrade to another OS.
            // Determine which OS we are upgrading, then determine
            // the type of install to perform.

            eUpgrade = fxState_IsUpgrade();

            switch (eUpgrade)
            {
                case FXSTATE_UPGRADE_TYPE_NONE:
                    return INF_KEYWORD_INSTALLTYPE_CLEAN;
                break;

                case FXSTATE_UPGRADE_TYPE_WIN9X:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X;
                break;

                case FXSTATE_UPGRADE_TYPE_NT:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMWINNT;
                break;

                case FXSTATE_UPGRADE_TYPE_W2K:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K;
                break;

                default:
                    VERBOSE(SETUP_ERR, 
                            _T("Failed to get section to process "),
                            _T("for install.  Upgrade Type = %lu"),
                            eUpgrade);
                break;
            }
        }
        else if (fxState_IsStandAlone())
        {
            // we are being run from SysOcMgr.exe.
            // SysOcMgr.exe is either invoked from the command line 
            // (usually as a way to test new OCM components - not really in 
            // the retail world), or it is invoked by the Add/Remove 
            // Windows Components in control panel.  In either case, 
            // treat it as a clean install.

            return INF_KEYWORD_INSTALLTYPE_CLEAN;
        }
    }
    else
    {
        return INF_KEYWORD_INSTALLTYPE_UNINSTALL;
    }

    return NULL;
}


///////////////////////////////
// fxState_DumpSetupState
//
// Dumps to debug the state we
// are running in.
//
// Params:
//      void
// Returns:
//      void
//
//
void fxState_DumpSetupState(void)
{
    DWORD dwExpectedOCManagerVersion    = 0;
    DWORD dwCurrentOCManagerVersion     = 0;
    TCHAR szComponentID[255 + 1]        = {0};
    TCHAR szSourcePath[_MAX_PATH + 1]   = {0};
    TCHAR szUnattendFile[_MAX_PATH + 1]   = {0};

    DBG_ENTER(_T("fxState_DumpSetupState"));

    faxocm_GetComponentID(szComponentID, 
                          sizeof(szComponentID) / sizeof(TCHAR));

    faxocm_GetComponentSourcePath(szSourcePath, 
                                  sizeof(szSourcePath) / sizeof(TCHAR));

    faxocm_GetComponentUnattendFile(szUnattendFile, 
                                  sizeof(szUnattendFile) / sizeof(TCHAR));

    faxocm_GetVersionInfo(&dwExpectedOCManagerVersion,
                          &dwCurrentOCManagerVersion);

    VERBOSE(DBG_MSG,
            _T("IsCleanInstall: '%lu'"), 
            fxState_IsCleanInstall());

    VERBOSE(DBG_MSG,
            _T("IsStandAlone: '%lu'"), 
            fxState_IsStandAlone());

    VERBOSE(DBG_MSG,
            _T("IsUpgrade (0 = No, 1 = Win31, 2 = Win9X, 3 = WinNT, 4 = Win2K: '%lu'"), 
            fxState_IsUpgrade());

    VERBOSE(DBG_MSG,
            _T("IsUnattended: '%lu'"), 
            fxState_IsUnattended());

    VERBOSE(DBG_MSG, _T("ComponentID: '%s'"), szComponentID);
    VERBOSE(DBG_MSG, _T("Source Path: '%s'"), szSourcePath);
    VERBOSE(DBG_MSG, _T("Unattend File: '%s'"), szUnattendFile);

    VERBOSE(DBG_MSG,
            _T("Expected OC Manager Version: 0x%lx"),
            dwExpectedOCManagerVersion);

    VERBOSE(DBG_MSG,
            _T("Current OC Manager Version:  0x%lx"),
            dwCurrentOCManagerVersion);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocutil.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocUtil.h
//
// Abstract:        Header file used by Utility source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCUTIL_H_
#define _FXOCUTIL_H_

DWORD fxocUtil_Init(void);
DWORD fxocUtil_Term(void);

DWORD fxocUtil_GetUninstallSection(const TCHAR *pszSection,
                                   TCHAR       *pszValue,
                                   DWORD       dwNumBufChars);

DWORD fxocUtil_GetKeywordValue(const TCHAR *pszSection,
                               const TCHAR *pszKeyword,
                               TCHAR       *pszValue,
                               DWORD       dwNumBufChars);

DWORD fxocUtil_DoSetup(HINF            hInf,
                       const TCHAR     *pszSection,
                       BOOL            bInstall,
                       DWORD           dwFlags,
                       const TCHAR     *pszFnName);

BOOL fxocUtil_CreateNetworkShare(const FAX_SHARE_Description* fsdShare);

BOOL fxocUtil_DeleteNetworkShare(LPCWSTR lpcwstrShareName);

DWORD fxocUtil_SearchAndExecute
(
    const TCHAR*    pszInstallSection,
    const TCHAR*    pszSearchKey,
    UINT            Flags,
    HSPFILEQ        hQueue
);


#endif  // _FXOCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocutil.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocUtil.cpp
//
// Abstract:        This provides the utility routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

// Project Includes
#include "faxocm.h"

// System Includes
#include <lmshare.h>
#include <lmaccess.h>
#include <lmerr.h>

#pragma hdrstop

//////////////////////// Static Function Prototypes //////////////////////////

///////////////////////////////
// fxocUtil_Init
//
// Initialize the misc. utilities
// required by faxocm.dll.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
DWORD fxocUtil_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Util module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocUtil_Term
//
// Terminate the misc. utilities
// required by faxocm.dll
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocUtil_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Util module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocUtil_GetUninstallSection
//
// Get field value in the INF 
// pointed to by the INF_KEYWORD_INSTALLTYPE_UNINSTALL
// keyword.
//
// Params:
//      - pszSection - section to search for keyword in.
//      - pszValue - IN - buffer returning the value of the keyword
//      - dwNumBufChars - # of chars the pszValue buffer can hold
//
DWORD fxocUtil_GetUninstallSection(const TCHAR *pszSection,
                                   TCHAR       *pszValue,
                                   DWORD       dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(_T("fxocUtil_GetUninstallSection"),dwReturn,_T("%s"),pszSection);

    if ((pszSection    == NULL) ||
        (pszValue      == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = fxocUtil_GetKeywordValue(pszSection, 
                                        INF_KEYWORD_INSTALLTYPE_UNINSTALL,
                                        pszValue,
                                        dwNumBufChars);
    return dwReturn;
}


///////////////////////////////
// fxocUtil_GetKeywordValue
//
// This is used for getting the 
// various Install/Uninstall
// sections, dependent on if we
// are a clean install, upgrade,
// etc.
//
// The format in the INF will look like this:
//
// [Section]
// Keyword = Value
//
// Params:
//      - pszSection - section to search for the keyword in.
//      - pszKeyword - keyword to get the value for.
//      - pszValue   - OUT - buffer that will hold the keyword's value
//      - dwNumBufChars - # of characters the pszValue buffer can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocUtil_GetKeywordValue(const TCHAR *pszSection,
                               const TCHAR *pszKeyword,
                               TCHAR       *pszValue,
                               DWORD       dwNumBufChars)
{
    HINF        hInf     = faxocm_GetComponentInf();
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;
    INFCONTEXT  Context;

    DBG_ENTER(  _T("fxocUtil_GetKeywordValue"),
                dwReturn,
                _T("%s - %s "),
                pszSection,
                pszKeyword);

    if ((pszSection     == NULL) ||
        (pszKeyword     == NULL) ||
        (pszValue       == NULL) ||
        (dwNumBufChars  == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }


    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection,
                                    pszKeyword,
                                    &Context);

    if (bSuccess)
    {
        bSuccess = ::SetupGetStringField(&Context,
                                         1,
                                         pszValue,
                                         dwNumBufChars,
                                         NULL);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("faxocm_GetKeywordValue, failed to get ")
                    _T("keyword value for section '%s', ")
                    _T("keyword '%s', rc = 0x%lx"),
                    pszSection, 
                    pszKeyword, 
                    dwReturn);
        }
    }
    else
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("faxocm_GetKeywordValue, failed to get ")
                _T("keyword value for component '%s', rc = 0x%lx"),
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocUtil_DoSetup
//
// Generic fn to create/delete program links
// 
// Params:
//      - hInf - handle to INF file
//      - pszSection - section to install/uninstall from
//      - bInstall   - TRUE if installing, FALSE if uninstalling
//      - pszFnName  - name of calling fn (for debug).
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocUtil_DoSetup(HINF            hInf,
                       const TCHAR     *pszSection,
                       BOOL            bInstall,
                       DWORD           dwFlags,
                       const TCHAR     *pszFnName)
{
    DWORD       dwReturn        = NO_ERROR;
    BOOL        bSuccess        = FALSE;

    DBG_ENTER(  _T("fxocUtil_DoSetup"),
                dwReturn,
                _T("%s - %s "),
                pszSection,
                pszFnName);

    if ((hInf == NULL) || 
        (pszSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // This function call will install or uninstall the shortcuts depending
    // on the value of the "pszSection" parameter.  If the section references
    // the install section, then the shortcuts will be installed, otherwise
    // they will be uninstalled.

    bSuccess = ::SetupInstallFromInfSection(NULL,                                
                                    hInf,
                                    pszSection,
                                    dwFlags,
                                    NULL,   // relative key root
                                    NULL,   // source root path
                                    0,      // copy flags
                                    NULL,   // callback routine
                                    NULL,   // callback routine context
                                    NULL,   // device info set
                                    NULL);  // device info struct

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();

        VERBOSE(SETUP_ERR,
                _T("SetupInstallFromInfSection failed, rc = 0x%lx"),
                dwReturn);
    }

    return dwReturn;
}

//////////////////////////////////
// fxocUtil_CreateNetworkShare
// 
//
// Create share on the current machine.
// If the share name is already exist, 
// then the function will try to erase the share
// and then create new one to lpctstrPath 
// 
// Params:
//      - const FAX_SHARE_Description* fsdShare - share description
// Returns:
//      - Returns TRUE on success
//      - FALSE otherwise
//
BOOL fxocUtil_CreateNetworkShare(const FAX_SHARE_Description* fsdShare)
{
    SHARE_INFO_502  ShareInfo502;
    NET_API_STATUS  rVal        = 0;
    DWORD           dwShareType = 0;
    DWORD           dwNumChars  = 0;

    WCHAR szExpandedPath[MAX_PATH*2];

    DBG_ENTER(_T("fxocUtil_CreateNetworkShare"));

    ZeroMemory(&ShareInfo502, sizeof(SHARE_INFO_502));

    dwNumChars = ExpandEnvironmentStrings(fsdShare->szPath, szExpandedPath, sizeof(szExpandedPath)/sizeof(szExpandedPath[0]));
    if (dwNumChars == 0)
    {
        VERBOSE(SETUP_ERR,
                _T("ExpandEnvironmentStrings failed, rc = 0x%lx"),
                ::GetLastError());

        return FALSE;
    }

    ShareInfo502.shi502_netname        = (LPTSTR)fsdShare->szName;
    ShareInfo502.shi502_type           = STYPE_DISKTREE;
    ShareInfo502.shi502_remark         = (LPTSTR)fsdShare->szComment;
    ShareInfo502.shi502_permissions    = ACCESS_ALL;
    ShareInfo502.shi502_max_uses       = (DWORD) -1,
    ShareInfo502.shi502_current_uses   = (DWORD) -1;
    ShareInfo502.shi502_path           = szExpandedPath;
    ShareInfo502.shi502_passwd         = NULL;
    ShareInfo502.shi502_security_descriptor = fsdShare->pSD;

    rVal = ::NetShareAdd(NULL,
                         502,
                         (LPBYTE) &ShareInfo502,
                         NULL);

    if (rVal == NERR_Success)
    {
        VERBOSE(DBG_MSG, _T("Successfully added '%s' share."), fsdShare->szName);
    }
    else if (rVal == NERR_DuplicateShare)
    {
        // share by the same name was found, attempt to delete it, and re-add it.

        VERBOSE(SETUP_ERR,
                _T("The share %s already exist, (err=%ld) ")
                _T("CreateNetworkShare will try to remove the share and ")
                _T("re-create it."),
                fsdShare->szName,
                GetLastError());

        // delete duplicate share.
        rVal = ::NetShareDel(NULL,
                             (LPTSTR) fsdShare->szName,
                             0);

        VERBOSE(DBG_MSG,
                _T("NetShareDel returned 0x%lx"),
                rVal);

        if (rVal != NERR_Success)
        {
            // failed to delete duplicate share.
            VERBOSE(SETUP_ERR,
                    _T("NetShareDel failed to delete '%s' share, rc = 0x%lx,")
                    _T("attempting to recreate it anyway"),
                    fsdShare->szName,
                    rVal);
        }

        // attempt to add new share, even if we failed to delete the duplicate share.  
        // Hopefully this will work regardless of the delete failure.
        rVal = ::NetShareAdd(NULL,
                             502,
                             (LPBYTE) &ShareInfo502,
                             NULL);

        if (rVal == NERR_Success)
        {
            VERBOSE(DBG_MSG, _T("Successfully added '%s' share."), fsdShare->szName);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to add '%s' share on second attempt, ")
                    _T("rc = 0x%lx"),
                    rVal);

            ::SetLastError(rVal);
        }
    }
    else
    {
        ::SetLastError(rVal);
    }

    return (rVal == NERR_Success);
}

//////////////////////////////////
// fxocUtil_DeleteNetworkShare
//
// Delete a share on the current machine.
// Returns TRUE on success, FALSE otherwise
//
// Params:
//      - LPCWSTR lpcwstrShareName :    : share name to delete
// Returns:
//      - TRUE on Success
//      - FALSE otherwise
//

BOOL fxocUtil_DeleteNetworkShare(LPCWSTR pszShareName)
{
    NET_API_STATUS rVal;

    DBG_ENTER(  _T("fxocUtil_DeleteNetworkShare"),
                _T("%s"),
                pszShareName);

    rVal = NetShareDel(NULL,                      // Local computer's share
                       (LPTSTR) pszShareName, // Name of the share to delete.
                       0);

    return (rVal == NERR_Success);
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  fxocUtil_SearchAndExecute
//
//  Purpose:        
//                  Searches a specified INF section for keywords of the type 'pszSearchKey'
//                  Each keyword should be in the format 'pszSearchKey' = platform, section to process.
//                  If the platform matches, then the section is processed according to Flags
//                  passed to SetupInstallFromInfSection                  
//
//  Params:
//                  const TCHAR*    pszInstallSection  - section to search in
//                  const TCHAR*    pszSearchKey       - keyword to find
//                  UINT            Flags              - flags to pass to SetupInstallFromInfSection
//                  HSPFILEQ        hQueue             - handle to file queue, if specified, this function
//                                                       will attemp to install files using the 
//                                                       SetupInstallFilesFromInfSection API
//                  
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code - otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 02-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD fxocUtil_SearchAndExecute
(
    const TCHAR*    pszInstallSection,
    const TCHAR*    pszSearchKey,
    UINT            Flags,
    HSPFILEQ        hQueue
)
{
    DWORD       dwReturn = NO_ERROR;
    INFCONTEXT  Context;
    BOOL        bNextSearchKeyFound = TRUE;
    HINF        hInf     = faxocm_GetComponentInf();
 
    DBG_ENTER(_T("fxocUtil_SearchAndExecute"),dwReturn,_T("%s - %s"),pszInstallSection,pszSearchKey);

    // let's look for 'pszSearchKey' directives
    bNextSearchKeyFound = ::SetupFindFirstLine( hInf,
                                                pszInstallSection, 
                                                pszSearchKey,
                                                &Context);
    if (!bNextSearchKeyFound)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszSearchKey, 
                pszInstallSection);

        goto exit;
    }

    while (bNextSearchKeyFound)
    {
        // we have a CreateShortcut section.
        DWORD dwCount = ::SetupGetFieldCount(&Context);
        if (dwCount!=2)
        {
            VERBOSE(SETUP_ERR,_T("Invalid %s section, has %d param instead of 2"),pszSearchKey,dwCount);
            goto exit;
        }
        // get the platform specifier
        INT iPlatform = 0;
        if (!::SetupGetIntField(&Context, 1, &iPlatform))
        {
            dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),dwReturn);
            goto exit;
        }
        // check the platform we read against the specifier
        if (iPlatform & GetProductSKU())
        {
            // we should process this section, get the section name
            TCHAR szSectionName[MAX_PATH] = {0};
            if (!::SetupGetStringField(&Context,2,szSectionName,MAX_PATH,NULL))
            {
                dwReturn = GetLastError();
                VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),dwReturn);
                goto exit;
            }
            // check if a file operation was requested
            if (hQueue)
            {
                if (::SetupInstallFilesFromInfSection(hInf,NULL,hQueue,szSectionName,NULL,Flags))
                {
                    VERBOSE(DBG_MSG,
                            _T("Successfully queued files from Section: '%s'"),
                            szSectionName);
                }
                else
                {
                    dwReturn = GetLastError();
                    VERBOSE(DBG_MSG,
                            _T("Failed to queue files from Section: '%s', Error Code = 0x%lx"),
                            szSectionName, 
                            dwReturn);
                }
            }
            else
            {
                if (::SetupInstallFromInfSection(NULL,hInf,szSectionName,Flags,NULL,NULL,0,NULL,NULL,NULL,NULL))
                {
                    VERBOSE(DBG_MSG,
                            _T("Successfully installed from INF file, section '%s'"),
                            szSectionName);
                }
                else
                {
                    dwReturn = GetLastError();
                    VERBOSE(SETUP_ERR,
                            _T("Failed to install from INF file, section '%s', dwReturn = 0x%lx"),
                            szSectionName, 
                            dwReturn);
                }
            }
        }
        
        // get the next section.
        bNextSearchKeyFound = ::SetupFindNextMatchLine( &Context,
                                                        pszSearchKey,
                                                        &Context);
        if (!bNextSearchKeyFound)
        {
            VERBOSE(DBG_MSG,
                    _T("Did not find '%s' keyword in ")
                    _T("section '%s'.  No action will be taken."),
                    pszSearchKey, 
                    pszInstallSection);
        }
    }
exit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxunatnd.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxUnatnd.h
//
// Abstract:        Fax OCM Unattend file processing
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 27-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXUNATND_H_
#define _FXUNATND_H_

///////////////////////////////
// fxUnatnd_UnattendedData_t
//
// This type is used to store
// the unattended data retrieved
// from the unattend.txt file
// and update the registry with
// these values.
//
typedef struct fxUnatnd_UnattendedData_t
{
    TCHAR   szFaxPrinterName[_MAX_PATH + 1];

    TCHAR   szCSID[_MAX_PATH + 1];
    TCHAR   szTSID[_MAX_PATH + 1];
    DWORD   dwRings;

    DWORD   dwSendFaxes;
    DWORD   dwReceiveFaxes;

    // should we run the configuration wizard for this unattended installation.
    DWORD   dwSuppressConfigurationWizard;

    // SMTP configuration
    TCHAR   szFaxUserName[_MAX_PATH + 1];
    TCHAR   szFaxUserPassword[_MAX_PATH + 1];
    BOOL    bSmtpNotificationsEnabled;
    TCHAR   szSmtpSenderAddress[_MAX_PATH + 1];
    TCHAR   szSmptServerAddress[_MAX_PATH + 1];
    DWORD   dwSmtpServerPort;
    TCHAR   szSmtpServerAuthenticationMechanism[_MAX_PATH + 1];

    // route incoming faxes to printer?
    BOOL    bRouteToPrinter;
    TCHAR   szRoutePrinterName[_MAX_PATH + 1];

    // route incoming faxes to email?
    BOOL    bRouteToEmail;
    TCHAR   szRouteEmailName[_MAX_PATH + 1];

    // Inbox configuration
    BOOL    bArchiveIncoming;
    TCHAR   szArchiveIncomingDir[_MAX_PATH + 1];

    // route incoming faxes to a specific directory.
    BOOL    bRouteToDir;
    TCHAR   szRouteDir[_MAX_PATH + 1];

    // archive outgoing faxes in a specific directory.
    BOOL    bArchiveOutgoing;
    TCHAR   szArchiveOutgoingDir[_MAX_PATH + 1];

    //  Fax Applicaitons uninstalled during Upgrade
    DWORD   dwUninstalledFaxApps;

} fxUnatnd_UnattendedData_t;


DWORD fxUnatnd_Init(void);
DWORD fxUnatnd_Term(void);
DWORD fxUnatnd_LoadUnattendedData();
DWORD fxUnatnd_SaveUnattendedData();

TCHAR* fxUnatnd_GetPrinterName();


#endif  // _FXUNATND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\ifaxcontrol.h ===
// IFaxControl.h : Declaration of the CFaxControl

#ifndef __IFAXCONTROL_H_
#define __IFAXCONTROL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFaxControl
class ATL_NO_VTABLE CFaxControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxControl, &CLSID_FaxControl>,
	public IDispatchImpl<IFaxControl, &IID_IFaxControl, &LIBID_FAXCONTROLLib>
{
public:
	CFaxControl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IFAXCONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxControl)
	COM_INTERFACE_ENTRY(IFaxControl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxControl
public:
	STDMETHOD(get_IsLocalFaxPrinterInstalled)(/*[out, retval]*/ VARIANT_BOOL *pbVal);
	STDMETHOD(get_IsFaxServiceInstalled)(/*[out, retval]*/ VARIANT_BOOL *pbVal);
	STDMETHOD(InstallLocalFaxPrinter)();
	STDMETHOD(InstallFaxService)();
};

#endif //__IFAXCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\ifaxcontrol.cpp ===
// IFaxControl.cpp : Implementation of CFaxControl
#include "stdafx.h"
#include "FaxControl.h"
#include "IFaxControl.h"
#include "faxocm.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxControl

FaxInstallationReportType g_InstallReportType = REPORT_FAX_DETECT;

//
// IsFaxInstalled and InstallFaxUnattended are implemented in fxocprnt.cpp
//
DWORD
IsFaxInstalled (
    LPBOOL lpbInstalled
    );

DWORD 
InstallFaxUnattended ();

STDMETHODIMP CFaxControl::get_IsFaxServiceInstalled(VARIANT_BOOL *pbResult)
{
    HRESULT hr;
    BOOL bRes;
    DBG_ENTER(_T("CFaxControl::get_IsFaxServiceInstalled"), hr);

    DWORD dwRes = ERROR_SUCCESS;
    
    switch (g_InstallReportType)
    {
        case REPORT_FAX_INSTALLED:
            bRes = TRUE;
            break;

        case REPORT_FAX_UNINSTALLED:
            bRes = FALSE;
            break;

        case REPORT_FAX_DETECT:
            dwRes = IsFaxInstalled (&bRes);
            break;

        default:
            ASSERTION_FAILURE;
            bRes = FALSE;
            break;
    }
    if (ERROR_SUCCESS == dwRes)
    {
        *pbResult = bRes ? VARIANT_TRUE : VARIANT_FALSE;
    }            
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::get_IsLocalFaxPrinterInstalled(VARIANT_BOOL *pbResult)
{
    HRESULT hr;
    BOOL bRes;
    DBG_ENTER(_T("CFaxControl::get_IsLocalFaxPrinterInstalled"), hr);

    DWORD dwRes = ::IsLocalFaxPrinterInstalled (&bRes);
    if (ERROR_SUCCESS == dwRes)
    {
        *pbResult = bRes ? VARIANT_TRUE : VARIANT_FALSE;
    }            
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::InstallFaxService()
{
    HRESULT hr;
    DBG_ENTER(_T("CFaxControl::InstallFaxService"), hr);

    DWORD dwRes = InstallFaxUnattended ();
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::InstallLocalFaxPrinter()
{
    HRESULT hr;
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(_T("CFaxControl::InstallLocalFaxPrinter"), hr);

    dwRes = AddLocalFaxPrinter (FAX_PRINTER_NAME, NULL);
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxstate.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxState.h
//
// Abstract:        Header file used by Faxocm source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXSTATE_H_
#define _FXSTATE_H_

typedef enum fxState_UpgradeType_e
{
    FXSTATE_UPGRADE_TYPE_NONE  = 0,
    FXSTATE_UPGRADE_TYPE_WIN31 = 1,
    FXSTATE_UPGRADE_TYPE_WIN9X = 2,
    FXSTATE_UPGRADE_TYPE_NT    = 3,
    FXSTATE_UPGRADE_TYPE_W2K   = 4
};

DWORD                   fxState_Init(void);
DWORD                   fxState_Term(void);
BOOL                    fxState_IsCleanInstall(void);
fxState_UpgradeType_e   fxState_IsUpgrade(void);
BOOL                    fxState_IsUnattended(void);
BOOL                    fxState_IsStandAlone(void);
void                    fxState_DumpSetupState(void);
BOOL                    fxState_IsOsServerBeingInstalled(void);

///////////////////////////////
// fxState_GetInstallType
//
// This function returns one
// of the INF_KEYWORD_INSTALLTYPE_*
// constants found in 
// fxconst.h/fxconst.cpp
//
//
const TCHAR* fxState_GetInstallType(const TCHAR* pszCurrentSection);


#endif  // _FXSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\resource.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       Resource.h
//
// Abstract:        Defines resource IDs for resources in faxocm.rc
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define FAX_EULA                                100
#define IDI_FAX_ICON                            101
#define IDR_IFAXCONTROL                         102
#define IDC_STATIC                              -1
#define IDS_FAXXP_DISPLAY_NAME                  500
#define IDS_FAXAB_DISPLAY_NAME                  501
#define IDC_DONT_SHOW                           504
#define IDC_INSTALL_FAX_NOW                     505
#define IDS_NEW_DEVICE_TITLE                    508
#define IDS_NEW_DEVICE_SUBTITLE                 509
#define IDC_ANSWER_YES                          511
#define IDC_ANSWER_NO                           512
#define IDD_WHERE_DID_MY_FAX_GO                 513
#define IDC_REMOVE_LINK                         514
#define IDC_OK                                  515

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED_)
#define AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxunatnd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxUnatnd.cpp
//
// Abstract:        Fax OCM Setup unattended file processing
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 27-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

static DWORD SaveSettingsFromAnswerFile();

#define prv_VALID_BOOL_VALUE_YES        _T("yes")
#define prv_VALID_BOOL_VALUE_NO         _T("no")
#define prv_VALID_BOOL_VALUE_TRUE       _T("true")
#define prv_VALID_BOOL_VALUE_FALSE      _T("false")

#define prv_HKLM                        HKEY_LOCAL_MACHINE
#define prv_HKCU                        HKEY_CURRENT_USER


///////////////////////////////
// prv_GVAR
//
// This is used as temporary
// storage so that we can
// reference the individual
// fields in the prv_UnattendedRules
// table below.
//
static struct prv_GVAR
{
    fxUnatnd_UnattendedData_t   UnattendedData;
} prv_GVAR;

///////////////////////////////
// prv_UnattendedRule_t
//
// Structure used as a table
// entry below.
//
typedef struct prv_UnattendedRule_t
{
    DWORD           dwType;
    const TCHAR     *pszFromInfKeyName;
    HKEY            hKeyTo;
    const TCHAR     *pszToRegPath;
    const TCHAR     *pszToRegKey;
    void            *pData;
    BOOL            bValid;
} prv_UnattendedRule_t;

#define RULE_CSID                               _T("Csid")
#define RULE_TSID                               _T("Tsid")
#define RULE_RINGS                              _T("Rings")
#define RULE_SENDFAXES                          _T("SendFaxes")
#define RULE_RECEIVEFAXES                       _T("ReceiveFaxes")
#define RULE_SUPPRESSCONFIGURATIONWIZARD        _T("SuppressConfigurationWizard")
#define RULE_ARCHIVEINCOMING                    _T("ArchiveIncoming")
#define RULE_ARCHIVEINCOMINGFOLDERNAME          _T("ArchiveIncomingFolderName")
#define RULE_ARCHIVEOUTGOING                    _T("ArchiveOutgoing")
#define RULE_ARCHIVEFOLDERNAME                  _T("ArchiveFolderName")
#define RULE_ARCHIVEOUTGOINGFOLDERNAME          _T("ArchiveOutgoingFolderName")
#define RULE_FAXUSERNAME                        _T("FaxUserName")
#define RULE_FAXUSERPASSWORD                    _T("FaxUserPassword")
#define RULE_SMTPNOTIFICATIONSENABLED           _T("SmtpNotificationsEnabled")
#define RULE_SMTPSENDERADDRESS                  _T("SmtpSenderAddress")
#define RULE_SMTPSERVERADDRESS                  _T("SmtpServerAddress")
#define RULE_SMTPSERVERPORT                     _T("SmtpServerPort")
#define RULE_SMTPSERVERAUTHENTICATIONMECHANISM  _T("SmtpServerAuthenticationMechanism")
#define RULE_FAXPRINTERNAME                     _T("FaxPrinterName")
#define RULE_ROUTETOPRINTER                     _T("RouteToPrinter")
#define RULE_ROUTEPRINTERNAME                   _T("RoutePrinterName")
#define RULE_ROUTETOEMAIL                       _T("RouteToEmail")
#define RULE_ROUTETOEMAILRECIPIENT              _T("RouteToEmailRecipient")
#define RULE_ROUTETOFOLDER                      _T("RouteToFolder")
#define RULE_ROUTEFOLDERNAME                    _T("RouteFolderName")

#define ANSWER_ANONYMOUS                        _T("Anonymous")
#define ANSWER_BASIC                            _T("Basic")
#define ANSWER_WINDOWSSECURITY                  _T("WindowsSecurity")

///////////////////////////////
// prv_UnattendedRules
//
// Simply put, these rules describe
// what registry values to set
// based on keywords found in an
// unattended file.
//
// The format of these rules is
// self explanatory after looking
// at the structure definition above.
// Basically, we read in a value from
// the unattended file which is specified
// in the 'pszFromInfKeyName'.  This is
// then stored in 'pData'.  Once
// "SaveUnattendedData" is called, 'pData'
// is committed to the registry location
// specified by 'hKeyTo' and 'pszToRegPath'
// and 'pszToRegKey'.
//
static prv_UnattendedRule_t prv_UnattendedRules[] =
{
    {REG_SZ,    RULE_CSID,                              prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_ROUTING_CSID,    prv_GVAR.UnattendedData.szCSID,                                 FALSE},
    {REG_SZ,    RULE_TSID,                              prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_ROUTING_TSID,    prv_GVAR.UnattendedData.szTSID,                                 FALSE},
    {REG_DWORD, RULE_RINGS,                             prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_RINGS,           &prv_GVAR.UnattendedData.dwRings,                               FALSE},
    {REG_DWORD, RULE_SENDFAXES,                         NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.dwSendFaxes,                           FALSE},
    {REG_DWORD, RULE_RECEIVEFAXES,                      NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.dwReceiveFaxes,                        FALSE},
    // should we run the configuration wizard for this unattended installation
    {REG_DWORD, RULE_SUPPRESSCONFIGURATIONWIZARD,       prv_HKLM,   REGKEY_FAXSERVER,       REGVAL_CFGWZRD_DEVICE,  &prv_GVAR.UnattendedData.dwSuppressConfigurationWizard,         TRUE},
    // Inbox configuration.
    {REG_DWORD, RULE_ARCHIVEINCOMING,                   prv_HKLM,   REGKEY_FAX_INBOX,       REGVAL_ARCHIVE_USE,     &prv_GVAR.UnattendedData.bArchiveIncoming,                      FALSE},
    {REG_SZ,    RULE_ARCHIVEINCOMINGFOLDERNAME,         prv_HKLM,   REGKEY_FAX_INBOX,       REGVAL_ARCHIVE_FOLDER,  prv_GVAR.UnattendedData.szArchiveIncomingDir,                   FALSE},
    // save outgoing faxes in a directory.
    {REG_DWORD, RULE_ARCHIVEOUTGOING,                   prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_USE,     &prv_GVAR.UnattendedData.bArchiveOutgoing,                      FALSE},
    {REG_SZ,    RULE_ARCHIVEFOLDERNAME,                 prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_FOLDER,  prv_GVAR.UnattendedData.szArchiveOutgoingDir,                   FALSE},
    {REG_SZ,    RULE_ARCHIVEOUTGOINGFOLDERNAME,         prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_FOLDER,  prv_GVAR.UnattendedData.szArchiveOutgoingDir,                   FALSE},
    // SMTP receipts and server configuration
    {REG_SZ,    RULE_FAXUSERNAME,                       NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szFaxUserName,                          FALSE},              
    {REG_SZ,    RULE_FAXUSERPASSWORD,                   NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szFaxUserPassword,                      FALSE},              
    {REG_DWORD, RULE_SMTPNOTIFICATIONSENABLED,          NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.bSmtpNotificationsEnabled,             FALSE},              
    {REG_SZ,    RULE_SMTPSENDERADDRESS,                 NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szSmtpSenderAddress,                    FALSE},              
    {REG_SZ,    RULE_SMTPSERVERADDRESS,                 NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szSmptServerAddress,                    FALSE},              
    {REG_DWORD, RULE_SMTPSERVERPORT,                    NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.dwSmtpServerPort,                      FALSE},              
    {REG_SZ,    RULE_SMTPSERVERAUTHENTICATIONMECHANISM, NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szSmtpServerAuthenticationMechanism,    FALSE},              
    // user information.                                                                                            
    {REG_SZ,    RULE_FAXPRINTERNAME,                    NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szFaxPrinterName,                       FALSE},
    // route to printer information.                                                                                
    {REG_DWORD, RULE_ROUTETOPRINTER,                    NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.bRouteToPrinter,                       FALSE},
    {REG_SZ,    RULE_ROUTEPRINTERNAME,                  NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szRoutePrinterName,                     FALSE},
    // route to email information.                                                                                  
    {REG_DWORD, RULE_ROUTETOEMAIL,                      NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.bRouteToEmail,                         FALSE},
    {REG_SZ,    RULE_ROUTETOEMAILRECIPIENT,             NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szRouteEmailName,                       FALSE},
    // route to a specific directory                                                                                
    {REG_DWORD, RULE_ROUTETOFOLDER,                     NULL,       NULL,                   NULL,                   &prv_GVAR.UnattendedData.bRouteToDir,                           FALSE},
    {REG_SZ,    RULE_ROUTEFOLDERNAME,                   NULL,       NULL,                   NULL,                   prv_GVAR.UnattendedData.szRouteDir,                             FALSE},

   //   Fax Applications uninstalled during Upgrade
   {REG_DWORD, UNINSTALLEDFAX_INFKEY, NULL, NULL, NULL, &prv_GVAR.UnattendedData.dwUninstalledFaxApps, FALSE}

};
#define prv_NUM_UNATTENDED_RULES sizeof(prv_UnattendedRules) / sizeof(prv_UnattendedRules[0])

///////////////////////// Static Function Prototypes ///////////////////////

static BOOL prv_FindKeyName(const TCHAR             *pszID,
                            prv_UnattendedRule_t    **ppUnattendedKey);

static BOOL prv_SaveKeyValue(prv_UnattendedRule_t  *pUnattendedKey,
                             TCHAR                 *pszValue);

///////////////////////////////
// fxUnatnd_Init
//
// Initialize the unattended
// subsystem
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_Init(void)
{
    prv_UnattendedRule_t  *pUnattendedKey = NULL;
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Unattended module"),dwRes);

    memset(&prv_GVAR, 0, sizeof(prv_GVAR));

    // this is always valid, and defaults to false.
    if (prv_FindKeyName(RULE_SUPPRESSCONFIGURATIONWIZARD, &pUnattendedKey))
    {
        if (!prv_SaveKeyValue(pUnattendedKey,_T("1")))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("prv_SaveKeyValue"), GetLastError());
            pUnattendedKey->bValid = FALSE;
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("prv_FindKeyName RULE_SUPPRESSCONFIGURATIONWIZARD"), GetLastError());
    }
    return dwRes;
}

///////////////////////////////
// fxUnatnd_Term
//
// Terminate the unattended subsystem
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Unattended module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxUnatnd_LoadUnattendedData
//
// Load the unattended data found
// in the unattended file according
// to the rules table above.
//
// Basically we look in the unattended
// file for the keywords in the rule
// table above, and read them into the
// passed in parameter.
//
// Params:
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_LoadUnattendedData()
{
    DWORD                   dwReturn        = NO_ERROR;
    BOOL                    bSuccess        = TRUE;
    HINF                    hInf            = faxocm_GetComponentInf();
    HINF                    hUnattendInf    = INVALID_HANDLE_VALUE;
    OCMANAGER_ROUTINES      *pHelpers       = faxocm_GetComponentHelperRoutines();
    INFCONTEXT              Context;
    prv_UnattendedRule_t    *pUnattendedKey = NULL;
    TCHAR                   szKeyName[255 + 1];
    TCHAR                   szValue[255 + 1];
    TCHAR                   szUnattendFile[MAX_PATH] = {0};

    DBG_ENTER(_T("fxUnatnd_LoadUnattendedData"),dwReturn);

    if ((hInf == NULL) || (hInf == INVALID_HANDLE_VALUE) || (pHelpers == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    faxocm_GetComponentUnattendFile(szUnattendFile,sizeof(szUnattendFile)/sizeof(szUnattendFile[0]));
    
    hUnattendInf = SetupOpenInfFile (szUnattendFile, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (hUnattendInf == INVALID_HANDLE_VALUE)
    {
        VERBOSE(SETUP_ERR,
                _T("LoadUnattendData, Unattended ")
                _T("mode, but could not get Unattended file INF ")
                _T("handle. ec=%d"), GetLastError());

        return NO_ERROR;
    }

    VERBOSE(DBG_MSG, _T("Succeded to open setup unattended mode file."));
        
    if (dwReturn == NO_ERROR)
    {
        bSuccess = ::SetupFindFirstLine(hUnattendInf,
                                        UNATTEND_FAX_SECTION,
                                        NULL,
                                        &Context);

        if (bSuccess)
        {
            VERBOSE(DBG_MSG,
                    _T("Found '%s' section in unattended file, ")
                    _T("beginning unattended file processing"),
                    UNATTEND_FAX_SECTION);

            while (bSuccess)
            {
                // get the keyname of the first line in the fax section of the
                // INF file.  (Note index #0 specified in the
                // 'SetupGetStringField' API will actually get us the key name.
                // Index 1 will be the first value found after the '=' sign.

                memset(szKeyName, 0, sizeof(szKeyName));

                bSuccess = ::SetupGetStringField(
                                            &Context,
                                            0,
                                            szKeyName,
                                            sizeof(szKeyName)/sizeof(TCHAR),
                                            NULL);
                if (bSuccess)
                {
                    // find the key in our unattended table above.
                    pUnattendedKey = NULL;
                    bSuccess = prv_FindKeyName(szKeyName, &pUnattendedKey);
                }

                if (bSuccess)
                {
                    VERBOSE(DBG_MSG, _T("Found '%s' key in 'Fax' section."), szKeyName);

                    //
                    // get the keyname's value.  Notice now we get index #1
                    // which is the first value found after the '=' sign.
                    //

                    memset(szValue, 0, sizeof(szValue));

                    bSuccess = ::SetupGetStringField(
                                                 &Context,
                                                 1,
                                                 szValue,
                                                 sizeof(szValue)/sizeof(TCHAR),
                                                 NULL);

                    VERBOSE(DBG_MSG, _T("The value we read is : %s."), szValue);
                }

                if (bSuccess)
                {
                    //
                    // save the keyname's value in the dataptr
                    //
                    bSuccess = prv_SaveKeyValue(pUnattendedKey, szValue);
                }

                // move to the next line in the unattended file fax section.
                bSuccess = ::SetupFindNextLine(&Context, &Context);
            }
        }
        else
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("::SetupFindFirstLine() failed, ec = %ld"), dwReturn);
        }
    }

    SetupCloseInfFile(hUnattendInf);

    return dwReturn;
}

///////////////////////////////
// fxUnatnd_SaveUnattendedData
//
// Commit the unattended data
// we read from the file to the
// registry.
//
// Params:
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_SaveUnattendedData()
{
    DWORD   dwReturn    = NO_ERROR;
    DWORD   i           = 0;
    HKEY    hKey        = NULL;
    DWORD   dwDataSize  = 0;
    LRESULT lResult     = ERROR_SUCCESS;
    prv_UnattendedRule_t    *pRule = NULL;

    DBG_ENTER(_T("fxUnatnd_SaveUnattendedData"),dwReturn);

    // Iterate through each unattended rule.
    // If the hKeyTo is not NULL, then write the value of pData to the
    // specified registry location.

    for (i = 0; i < prv_NUM_UNATTENDED_RULES; i++)
    {
        pRule = &prv_UnattendedRules[i];

        if ((pRule->hKeyTo != NULL) && (pRule->bValid))
        {
            lResult = ::RegOpenKeyEx(pRule->hKeyTo,
                                     pRule->pszToRegPath,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hKey);

            if (lResult == ERROR_SUCCESS)
            {
                dwDataSize = 0;

                if (pRule->dwType == REG_SZ)
                {
                    dwDataSize = sizeof(TCHAR) * _tcslen((TCHAR*) pRule->pData);
                    // write the value to the registry.
                    lResult = ::RegSetValueEx(hKey,
                                              pRule->pszToRegKey,
                                              0,
                                              pRule->dwType,
                                              (BYTE*) pRule->pData,
                                              dwDataSize);
                }
                else if (pRule->dwType == REG_DWORD)
                {
                    dwDataSize = sizeof(DWORD);
                    // write the value to the registry.
                    lResult = ::RegSetValueEx(hKey,
                                              pRule->pszToRegKey,
                                              0,
                                              pRule->dwType,
                                              (BYTE*) &(pRule->pData),
                                              dwDataSize);
                }
                else
                {
                    VERBOSE(SETUP_ERR,
                            _T("SaveUnattendedData ")
                            _T("do not recognize data type = '%lu'"),
                            pRule->dwType);
                }
            }

            if (hKey)
            {
                ::RegCloseKey(hKey);
            }
        }
    }

    // now save dynamic data...
    lResult = SaveSettingsFromAnswerFile();
    if (lResult!=ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR,_T("SaveSettingsFromAnswerFile failed (ec=%d)"),GetLastError());
    }

    //
    //  Mark which Fax Applications were installed before the upgrade
    //
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    if ((prv_FindKeyName(UNINSTALLEDFAX_INFKEY, &pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        fxocUpg_WhichFaxWasUninstalled((DWORD)(PtrToUlong(pUnattendedKey->pData)));
    }

    return dwReturn;
}


TCHAR* fxUnatnd_GetPrinterName()
{
    TCHAR* retValue = NULL;
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    if (prv_FindKeyName(
        RULE_FAXPRINTERNAME,
        &pUnattendedKey))
    {
        retValue = (TCHAR *) (pUnattendedKey->pData);
    }
    return retValue;    
}


///////////////////////////////
// prv_FindKeyName
//
// Find specified key name in our table
//
// Params:
//      - pszKeyName - key name to search for.
//      - ppUnattendedKey - OUT - rule we found.
// Returns:
//      - TRUE if we found the keyname
//      - FALSE otherwise.
//
static BOOL prv_FindKeyName(const TCHAR              *pszKeyName,
                            prv_UnattendedRule_t     **ppUnattendedKey)
{
    BOOL  bFound   = FALSE;
    DWORD i        = 0;

    if ((pszKeyName     == NULL) ||
        (ppUnattendedKey == NULL))

    {
        return FALSE;
    }

    for (i = 0; (i < prv_NUM_UNATTENDED_RULES) && (!bFound); i++)
    {
        if (_tcsicmp(pszKeyName, prv_UnattendedRules[i].pszFromInfKeyName) == 0)
        {
            bFound = TRUE;
            *ppUnattendedKey = &prv_UnattendedRules[i];
        }
    }

    return bFound;
}

///////////////////////////////
// prv_SaveKeyValue
//
// Store the specified value
// with the specified rule
//
// Params:
//      - pUnattendedKey - rule where the value will be stored
//      - pszValue       - value to store.
// Returns:
//      - TRUE on success.
//      - FALSE otherwise.
//
static BOOL prv_SaveKeyValue(prv_UnattendedRule_t  *pUnattendedKey,
                             TCHAR                 *pszValue)
{
    BOOL    bSuccess     = TRUE;
    //DWORD dwBufferSize = 0;

    DBG_ENTER(_T("prv_SaveKeyValue"), bSuccess);

    if ((pUnattendedKey == NULL) ||
        (pszValue       == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (bSuccess)
    {
        switch (pUnattendedKey->dwType)
        {
            case REG_SZ:
                _tcsncpy((TCHAR*) pUnattendedKey->pData,
                         pszValue,
                         _MAX_PATH
                         );
            break;

            case REG_DWORD:
                // check if we got a true/false, or yes/no.
                if ((!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_YES)) ||
                    (!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_TRUE)))
                {
                    pUnattendedKey->pData = (void*) TRUE;
                }
                else if ((!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_NO)) ||
                         (!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_FALSE)))
                {
                    pUnattendedKey->pData = (void*) FALSE;
                }
                else
                {
                    // assume the value if an integer.
                    pUnattendedKey->pData = ULongToPtr(_tcstoul(pszValue, NULL, 10));
                }

            break;
        }
    }
    pUnattendedKey->bValid = TRUE;
    return bSuccess;
}


typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXCONNECTFAXSERVERW)          (LPCWSTR MachineName,LPHANDLE FaxHandle);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXENUMPORTSEXW)               (HANDLE hFaxHandle,PFAX_PORT_INFO_EXW* ppPorts,PDWORD lpdwNumPorts);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETPORTEXW)                 (HANDLE hFaxHandle,DWORD dwDeviceId,PFAX_PORT_INFO_EXW pPortInfo);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXGETPORTEXW)                 (HANDLE hFaxHandle,DWORD dwDeviceId,PFAX_PORT_INFO_EXW *ppPortInfo);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXCLOSE)                      (HANDLE FaxHandle);
typedef WINFAXAPI VOID (WINAPI *FUNC_FAXFREEBUFFER)                 (LPVOID Buffer);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETEXTENSIONDATAW)          (HANDLE hFaxHandle,DWORD dwDeviceID,LPCWSTR lpctstrNameGUID,CONST PVOID pData,CONST DWORD dwDataSize);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXGETRECEIPTSCONFIGURATIONW)  (HANDLE hFaxHandle,PFAX_RECEIPTS_CONFIGW *ppReceipts);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETRECEIPTSCONFIGURATIONW)  (HANDLE hFaxHandle,CONST PFAX_RECEIPTS_CONFIGW pReceipts);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXGETARCHIVECONFIGURATIONW)   (HANDLE hFaxHandle,FAX_ENUM_MESSAGE_FOLDER Folder,PFAX_ARCHIVE_CONFIGW *ppArchiveCfg);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETARCHIVECONFIGURATIONW)   (HANDLE hFaxHandle,FAX_ENUM_MESSAGE_FOLDER Folder,CONST PFAX_ARCHIVE_CONFIGW pArchiveCfg);


typedef struct _FaxServerAPI
{
    HMODULE hModule;

    FUNC_FAXCONNECTFAXSERVERW           pfFaxConnectFaxServerW;
    FUNC_FAXENUMPORTSEXW                pfFaxEnumPortsExW;
    FUNC_FAXSETPORTEXW                  pfFaxSetPortExW;
    FUNC_FAXCLOSE                       pfFaxClose;
    FUNC_FAXFREEBUFFER                  pfFaxFreeBuffer;
    FUNC_FAXSETEXTENSIONDATAW           pfFaxSetExtensionDataW;
    FUNC_FAXGETRECEIPTSCONFIGURATIONW   pfFaxGetReceiptsConfigurationW;
    FUNC_FAXSETRECEIPTSCONFIGURATIONW   pfFaxSetReceiptsConfigurationW;
    FUNC_FAXGETARCHIVECONFIGURATIONW    pfFaxGetArchiveConfigurationW;
    FUNC_FAXSETARCHIVECONFIGURATIONW    pfFaxSetArchiveConfigurationW;

} _FaxServerAPI = 
{
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

static _FaxServerAPI faxServerAPI;

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  InitFaxServerConnectionAndFunctions
//
//  Purpose:        Load FXSAPI.DLL and get all the needed function ptrs
//                  call FaxConnectFaxServer and pass the handle
//                  back to the caller
//
//  Params:
//                  LPHANDLE hFaxHandle - pointer to the FaxHandle to pass to FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 12-mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD InitFaxServerConnectionAndFunctions(LPHANDLE hFaxHandle)
{
    DWORD   dwErr   = ERROR_SUCCESS;

    DBG_ENTER(_T("InitFaxServerConnectionAndFunctions"),dwErr);

    (*hFaxHandle) = NULL;
    // load the FXSAPI.DLL
    faxServerAPI.hModule = LoadLibrary(FAX_API_MODULE_NAME);
    if (faxServerAPI.hModule==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("LoadLibrary failed (ec=%d)"),dwErr);
        goto exit;
    }
    // get the following functions:
    // 1. FaxConnectFaxServer
    // 2. FaxEnumPortsEx
    // 3. FaxSetPortEx
    // 4. FaxClose
    // 5. FaxFreeBuffer
    // 6. FaxSetExtensionData
    // 7. FaxGetReceiptsConfiguration
    // 8. FaxSetReceiptsConfiguration
    // 9. FaxGetArchiveConfigurationW
    // 10.FaxSetArchiveConfigurationW
    faxServerAPI.pfFaxConnectFaxServerW = (FUNC_FAXCONNECTFAXSERVERW)GetProcAddress(faxServerAPI.hModule,"FaxConnectFaxServerW");
    if (faxServerAPI.pfFaxConnectFaxServerW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxConnectFaxServerW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxEnumPortsExW = (FUNC_FAXENUMPORTSEXW)GetProcAddress(faxServerAPI.hModule,"FaxEnumPortsExW");
    if (faxServerAPI.pfFaxEnumPortsExW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxEnumPortsExW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxSetPortExW = (FUNC_FAXSETPORTEXW)GetProcAddress(faxServerAPI.hModule,"FaxSetPortExW");
    if (faxServerAPI.pfFaxSetPortExW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxSetPortExW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxClose = (FUNC_FAXCLOSE)GetProcAddress(faxServerAPI.hModule,"FaxClose");
    if (faxServerAPI.pfFaxClose==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxClose failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxFreeBuffer = (FUNC_FAXFREEBUFFER)GetProcAddress(faxServerAPI.hModule,"FaxFreeBuffer");
    if (faxServerAPI.pfFaxFreeBuffer==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxFreeBuffer failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxSetExtensionDataW = (FUNC_FAXSETEXTENSIONDATAW)GetProcAddress(faxServerAPI.hModule,"FaxSetExtensionDataW");
    if (faxServerAPI.pfFaxSetExtensionDataW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxSetExtensionDataW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxGetReceiptsConfigurationW = (FUNC_FAXGETRECEIPTSCONFIGURATIONW)GetProcAddress(faxServerAPI.hModule,"FaxGetReceiptsConfigurationW");
    if (faxServerAPI.pfFaxGetReceiptsConfigurationW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxGetReceiptsConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxSetReceiptsConfigurationW = (FUNC_FAXSETRECEIPTSCONFIGURATIONW)GetProcAddress(faxServerAPI.hModule,"FaxSetReceiptsConfigurationW");
    if (faxServerAPI.pfFaxSetReceiptsConfigurationW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxSetReceiptsConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxGetArchiveConfigurationW = (FUNC_FAXGETARCHIVECONFIGURATIONW)GetProcAddress(faxServerAPI.hModule,"FaxGetArchiveConfigurationW");
    if (faxServerAPI.pfFaxGetArchiveConfigurationW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("GetProcAddress FaxGetArchiveConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }
    faxServerAPI.pfFaxSetArchiveConfigurationW = (FUNC_FAXSETARCHIVECONFIGURATIONW)GetProcAddress(faxServerAPI.hModule,"FaxSetArchiveConfigurationW");
    if (faxServerAPI.pfFaxSetArchiveConfigurationW==NULL)
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("FaxSetArchiveConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }

    // try to connect to the fax server
    if (!(*faxServerAPI.pfFaxConnectFaxServerW)(NULL,hFaxHandle))
    {
        (*hFaxHandle) = NULL;
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("pfFaxConnectFaxServerW failed (ec=%d)"),dwErr);
        goto exit;
    }

exit:
    if (((*hFaxHandle)==NULL) && (dwErr==ERROR_SUCCESS))
    {
        // one of the functions failed to set last error upon failure
        dwErr = ERROR_FUNCTION_FAILED;
    }
    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConfigureSMTPFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for SMTP
//                  receipts and try to set the server configuration
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 22-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL ConfigureSMTPFromAnswerFile(HANDLE hFaxHandle)
{
    BOOL                    bRet                = TRUE;
    DWORD                   dwErr               = NO_ERROR;
    PFAX_RECEIPTS_CONFIGW   pFaxReceiptsConfigW = NULL;
    prv_UnattendedRule_t*   pUnattendedKey      = NULL;

    DBG_ENTER(_T("ConfigureSMTPFromAnswerFile"),bRet);

    // call FaxGetReceiptsConfiguration
    if (!(*faxServerAPI.pfFaxGetReceiptsConfigurationW)(hFaxHandle,&pFaxReceiptsConfigW))
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("FaxGetReceiptsConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }
    // get FaxUserName, this is the lptstrSMTPUserName member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_FAXUSERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->lptstrSMTPUserName = (TCHAR*)pUnattendedKey->pData;
    }
    // get FaxUserPassword, this is the lptstrSMTPPassword member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_FAXUSERPASSWORD,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->lptstrSMTPPassword = (TCHAR*)pUnattendedKey->pData;
    }
    // get SmtpNotificationsEnabled, this is part of dwAllowedReceipts member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_SMTPNOTIFICATIONSENABLED,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->dwAllowedReceipts |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? DRT_EMAIL : 0;
    }
    // get SmtpSenderAddress, this is the lptstrSMTPFrom member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_SMTPSENDERADDRESS,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->lptstrSMTPFrom = (TCHAR*)pUnattendedKey->pData;
    }
    // get SmptServerAddress, this is the lptstrSMTPServer member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_SMTPSERVERADDRESS,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->lptstrSMTPServer = (TCHAR*)pUnattendedKey->pData;
    }
    // get SmtpServerPort, this is the dwSMTPPort member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_SMTPSERVERPORT,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        pFaxReceiptsConfigW->dwSMTPPort = (DWORD)(PtrToUlong(pUnattendedKey->pData));
    }
    // get SmtpServerAuthenticationMechanism, this is the SMTPAuthOption member of PFAX_RECEIPTS_CONFIGW
    if ((prv_FindKeyName(RULE_SMTPSERVERAUTHENTICATIONMECHANISM,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_ANONYMOUS)==0)
        {
            pFaxReceiptsConfigW->SMTPAuthOption = FAX_SMTP_AUTH_ANONYMOUS;
        }
        else if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_BASIC)==0)
        {
            pFaxReceiptsConfigW->SMTPAuthOption = FAX_SMTP_AUTH_BASIC;
        }
        else if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_WINDOWSSECURITY)==0)
        {
            pFaxReceiptsConfigW->SMTPAuthOption = FAX_SMTP_AUTH_NTLM;
        }
    }
    
    // now set the new configuration
    if (!(*faxServerAPI.pfFaxSetReceiptsConfigurationW)(hFaxHandle,pFaxReceiptsConfigW))
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("FaxSetReceiptsConfigurationW failed (ec=%d)"),dwErr);
        goto exit;
    }


exit:
    if (pFaxReceiptsConfigW)
    {
        if(faxServerAPI.pfFaxFreeBuffer)
        {
            (*faxServerAPI.pfFaxFreeBuffer)(pFaxReceiptsConfigW);
        }
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConfigureArchivesFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for Archives
//                  and try to set the server configuration
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 22-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL ConfigureArchivesFromAnswerFile(HANDLE hFaxHandle)
{
    BOOL                    bRet                        = TRUE;
    DWORD                   dwErr                       = NO_ERROR;
    PFAX_ARCHIVE_CONFIGW    pFaxInboxArchiveConfigW     = NULL;
    PFAX_ARCHIVE_CONFIGW    pFaxSentItemsArchiveConfigW = NULL;
    prv_UnattendedRule_t*   pUnattendedKey              = NULL;

    DBG_ENTER(_T("ConfigureArchivesFromAnswerFile"),bRet);

    // call FaxGetArchiveConfiguration to get the inbox configuration
    if ((*faxServerAPI.pfFaxGetArchiveConfigurationW)(hFaxHandle,FAX_MESSAGE_FOLDER_INBOX,&pFaxInboxArchiveConfigW))
    {
        // Inbox enable
        if ((prv_FindKeyName(RULE_ARCHIVEINCOMING,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxInboxArchiveConfigW->bUseArchive= (BOOL)PtrToUlong(pUnattendedKey->pData);
        }
        // Inbox folder
        if ((prv_FindKeyName(RULE_ARCHIVEINCOMINGFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxInboxArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // now set the new configuration
        if (!(*faxServerAPI.pfFaxSetArchiveConfigurationW)(hFaxHandle,FAX_MESSAGE_FOLDER_INBOX,pFaxInboxArchiveConfigW))
        {
            dwErr = GetLastError();
            VERBOSE(DBG_WARNING,_T("FaxSetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
        }
    }
    else
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("FaxGetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
    }

    // call FaxGetArchiveConfiguration to get the SentItems configuration
    if ((*faxServerAPI.pfFaxGetArchiveConfigurationW)(hFaxHandle,FAX_MESSAGE_FOLDER_SENTITEMS,&pFaxSentItemsArchiveConfigW))
    {
        // SentItems enable
        if ((prv_FindKeyName(RULE_ARCHIVEOUTGOING,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->bUseArchive= (BOOL)PtrToUlong(pUnattendedKey->pData);
        }
        // SentItems folder
        if ((prv_FindKeyName(RULE_ARCHIVEFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // SentItems folder could also come from this rule
        if ((prv_FindKeyName(RULE_ARCHIVEOUTGOINGFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // now set the new configuration
        if (!(*faxServerAPI.pfFaxSetArchiveConfigurationW)(hFaxHandle,FAX_MESSAGE_FOLDER_SENTITEMS,pFaxSentItemsArchiveConfigW))
        {
            dwErr = GetLastError();
            VERBOSE(DBG_WARNING,_T("FaxSetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
        }
    }
    else
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("FaxGetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
    }

    if (pFaxInboxArchiveConfigW)
    {
        if(faxServerAPI.pfFaxFreeBuffer)
        {
            (*faxServerAPI.pfFaxFreeBuffer)(pFaxInboxArchiveConfigW);
        }
    }
    if (pFaxSentItemsArchiveConfigW)
    {
        if(faxServerAPI.pfFaxFreeBuffer)
        {
            (*faxServerAPI.pfFaxFreeBuffer)(pFaxSentItemsArchiveConfigW);
        }
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetPerDeviceConfigFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for device
//                  settings and routing extension settings
//                  and set all the existing devices.
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 12-mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD SetPerDeviceConfigFromAnswerFile(HANDLE hFaxHandle)
{
    DWORD                           dwErr                           = ERROR_SUCCESS;
    PFAX_PORT_INFO_EXW              pFaxPortInfoExW                 = NULL;
    DWORD                           dwNumPorts                      = 0;
    DWORD                           dwIndex                         = 0;
    DWORD                           dwFlags                         = 0;
    prv_UnattendedRule_t*           pUnattendedKey                  = NULL;

    DBG_ENTER(_T("SetPerDeviceConfigFromAnswerFile"),dwErr);

    // call EnumPortsEx
    if (!(*faxServerAPI.pfFaxEnumPortsExW)(hFaxHandle,&pFaxPortInfoExW,&dwNumPorts))
    {
        dwErr = GetLastError();
        VERBOSE(SETUP_ERR,_T("pfFaxConnectFaxServerW failed (ec=%d)"),dwErr);
        goto exit;
    }

    for (dwIndex=0; dwIndex<dwNumPorts; dwIndex++)
    {
        // handle CSID
        if ((prv_FindKeyName(RULE_CSID,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxPortInfoExW[dwIndex].lptstrCsid = (TCHAR*)pUnattendedKey->pData;
        }

        // handle TSID
        if ((prv_FindKeyName(RULE_TSID,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxPortInfoExW[dwIndex].lptstrTsid = (TCHAR*)pUnattendedKey->pData;
        }

        // handle Rings
        if ((prv_FindKeyName(RULE_RINGS,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxPortInfoExW[dwIndex].dwRings = (DWORD)(PtrToUlong(pUnattendedKey->pData));
        }

        // handle Flags
        if ((prv_FindKeyName(RULE_SENDFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxPortInfoExW[dwIndex].bSend = ((BOOL)PtrToUlong(pUnattendedKey->pData));
        }
        if ((prv_FindKeyName(RULE_RECEIVEFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxPortInfoExW[dwIndex].ReceiveMode = ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF;
        }

        // Set CSID, TSID and Rings
        if(!(*faxServerAPI.pfFaxSetPortExW)(hFaxHandle, pFaxPortInfoExW[dwIndex].dwDeviceID, &pFaxPortInfoExW[dwIndex]))
        {
            dwErr = GetLastError();
            VERBOSE(SETUP_ERR,_T("Can't save fax port data. Error code is %d."),dwErr);
            // nothing to worry about, let's try some other answers...
            dwErr = ERROR_SUCCESS;
        }

        // handle Route to Folder - folder name
        if ((prv_FindKeyName(RULE_ROUTEFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            if(!(*faxServerAPI.pfFaxSetExtensionDataW)( hFaxHandle, 
                                                        pFaxPortInfoExW[dwIndex].dwDeviceID, 
                                                        REGVAL_RM_FOLDER_GUID, 
                                                        (LPBYTE)pUnattendedKey->pData, 
                                                        StringSize((TCHAR*)(pUnattendedKey->pData))) )
            {
                dwErr = GetLastError();
                VERBOSE(SETUP_ERR, 
                             _T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
                             pFaxPortInfoExW[dwIndex].dwDeviceID, 
                             REGVAL_RM_FOLDER_GUID,
                             dwErr);
                // nothing to worry about, let's try some other answers...
                dwErr = ERROR_SUCCESS;
            }
        }

        // handle Route to Printer - printer name
        if ((prv_FindKeyName(RULE_ROUTEPRINTERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            if(!(*faxServerAPI.pfFaxSetExtensionDataW)( hFaxHandle, 
                                                        pFaxPortInfoExW[dwIndex].dwDeviceID, 
                                                        REGVAL_RM_PRINTING_GUID, 
                                                        (LPBYTE)pUnattendedKey->pData, 
                                                        StringSize((TCHAR*)(pUnattendedKey->pData))) )
            {
                dwErr = GetLastError();
                VERBOSE(SETUP_ERR, 
                             _T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
                             pFaxPortInfoExW[dwIndex].dwDeviceID, 
                             REGVAL_RM_FOLDER_GUID,
                             dwErr);
                // nothing to worry about, let's try some other answers...
                dwErr = ERROR_SUCCESS;
            }
        }
        if (!IsDesktopSKU())
        {
            // handle Route to Email - email name
            if ((prv_FindKeyName(RULE_ROUTETOEMAILRECIPIENT,&pUnattendedKey)) && (pUnattendedKey->bValid))
            {
                if(!(*faxServerAPI.pfFaxSetExtensionDataW)( hFaxHandle, 
                                                            pFaxPortInfoExW[dwIndex].dwDeviceID, 
                                                            REGVAL_RM_EMAIL_GUID, 
                                                            (LPBYTE)pUnattendedKey->pData, 
                                                            StringSize((TCHAR*)(pUnattendedKey->pData))) )
                {
                    dwErr = GetLastError();
                    VERBOSE(SETUP_ERR, 
                                 _T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
                                 pFaxPortInfoExW[dwIndex].dwDeviceID, 
                                 REGVAL_RM_EMAIL_GUID,
                                 dwErr);
                    // nothing to worry about, let's try some other answers...
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
        // handle Route to Folder, printer and Email- enable
        if ((prv_FindKeyName(RULE_ROUTETOPRINTER,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? LR_PRINT : 0;
        }
        if ((prv_FindKeyName(RULE_ROUTETOFOLDER,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL) PtrToUlong(pUnattendedKey->pData)) ? LR_STORE : 0;
        }
        if (!IsDesktopSKU())
        {
            if ((prv_FindKeyName(RULE_ROUTETOEMAIL,&pUnattendedKey)) && (pUnattendedKey->bValid))
            {
                dwFlags |= ((BOOL) PtrToUlong(pUnattendedKey->pData)) ? LR_EMAIL : 0;
            }
        }
        if(!(*faxServerAPI.pfFaxSetExtensionDataW)( hFaxHandle, 
                                                    pFaxPortInfoExW[dwIndex].dwDeviceID, 
                                                    REGVAL_RM_FLAGS_GUID, 
                                                    (LPBYTE)&dwFlags, 
                                                    sizeof(DWORD)) )
        {
            dwErr = GetLastError();
            VERBOSE(SETUP_ERR, 
                         _T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
                         pFaxPortInfoExW[dwIndex].dwDeviceID, 
                         REGVAL_RM_FOLDER_GUID,
                         dwErr);
            // nothing to worry about, let's try some other answers...
            dwErr = ERROR_SUCCESS;
        }
    }

exit:
    if (pFaxPortInfoExW)
    {
        if(faxServerAPI.pfFaxFreeBuffer)
        {
            (*faxServerAPI.pfFaxFreeBuffer)(pFaxPortInfoExW);
        }
    }

    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SaveSettingsFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for device
//                  settings and routing extension settings
//                  and set all the existing devices.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 12-mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD SaveSettingsFromAnswerFile()
{
    DWORD                           dwErr                           = ERROR_SUCCESS;
    DWORD                           dwFlags                         = 0;
    HANDLE                          hFaxHandle                      = NULL;
    prv_UnattendedRule_t*           pUnattendedKey                  = NULL;

    DBG_ENTER(_T("SaveSettingsFromAnswerFile"),dwErr);

    dwErr = InitFaxServerConnectionAndFunctions(&hFaxHandle);
    if (dwErr!=ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR,_T("InitFaxServerConnectionAndFunctions failed (ec=%d)"),dwErr);
        goto exit;
    }

    // set the SMTP server configuration, on Server SKUs only
    if (!IsDesktopSKU())
    {
        if (!ConfigureSMTPFromAnswerFile(hFaxHandle))
        {
            dwErr = GetLastError();
            VERBOSE(DBG_WARNING,_T("ConfigureSMTPFromAnswerFile failed (ec=%d)"),dwErr);
            // this is not fatal, continue...
        }
    }

    if (!ConfigureArchivesFromAnswerFile(hFaxHandle))
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("ConfigureArchivesFromAnswerFile failed (ec=%d)"),dwErr);
        // this is not fatal, continue...
    }

    if (SetPerDeviceConfigFromAnswerFile(hFaxHandle)!=NO_ERROR)
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("SetPerDeviceConfigFromAnswerFile failed (ec=%d)"),dwErr);
        // this is not fatal, continue...
    }

    // finally set HKLM... Fax\Setup\Original Setup Data REG_DWORD Flags to configure any future device.
    HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP_ORIG,FALSE,KEY_ALL_ACCESS);
    if (hKey)
    {
        BOOL bFound = FALSE;
        DWORD dwFlags = FPF_SEND;   // this is the default
        if ((prv_FindKeyName(RULE_SENDFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FPF_SEND : 0;
            bFound = TRUE;
        }
        if ((prv_FindKeyName(RULE_RECEIVEFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FPF_RECEIVE : 0;
            bFound = TRUE;
        }
        if (bFound)
        {
            if (!SetRegistryDword(hKey,REGVAL_FLAGS,dwFlags))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryDword(REGVAL_FLAGS)"), GetLastError());
            }
        }
        RegCloseKey(hKey);
    }
    else
    {
        CALL_FAIL(SETUP_ERR,TEXT("OpenRegistryKey"),GetLastError());
    }

exit:
    if (hFaxHandle)
    {
        if (faxServerAPI.pfFaxClose)
        {
            (*faxServerAPI.pfFaxClose)(hFaxHandle);
        }
    }
    if (faxServerAPI.hModule)
    {
        FreeLibrary(faxServerAPI.hModule);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\shortcuts.cpp ===
#include <setuputil.h>
#include <debugex.h>

// 
// Function:    CompleteToFullPathInSystemDirectory
// Description: Get file name and a buffer. Return in the given buffer the full path to the file name in the 
//				system directory
// Returns:		TRUE for success, FALSE otherwise
//
// Remarks: It is possible that the file name is in the given buffer.
//
// Args:
// LPTSTR  lptstrFullPath (OUT) : Buffer that will have the full path
// LPTCSTR lptstrFileName (IN)  : File name
//
// Author:      AsafS

BOOL
CompleteToFullPathInSystemDirectory(
	LPTSTR  lptstrFullPath,
	LPCTSTR lptstrFileName
	)
{
	DBG_ENTER(TEXT("CompleteToFullPathInSystemDirectory"));
	TCHAR szFileName[MAX_PATH+1] = {0};
	DWORD dwSize = 0;
	
	_tcsncpy(szFileName, lptstrFileName, MAX_PATH);

	if (!GetSystemDirectory(lptstrFullPath, MAX_PATH))
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("GetSystemDirectory"),
			GetLastError()
			);
		return FALSE;
	}

	dwSize = _tcslen(lptstrFullPath);

	_tcsncat(
		lptstrFullPath, 
		TEXT("\\"),
		(MAX_PATH - dwSize)
		);
	dwSize++;

	_tcsncat(
		lptstrFullPath, 
		szFileName, 
		(MAX_PATH - dwSize)
		);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\install.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    install.c

Abstract:

    This file contains common setup routines for fax.

Author:

    Iv Garber (ivg) May-2001

Environment:

    User Mode

--*/
#include "SetupUtil.h"
#include "FaxSetup.h"
#include "FaxUtil.h"

DWORD CheckInstalledFax(
    bool *pbSBSClient, 
    bool *pbXPDLClient,
    bool *pbSBSServer
)
/*++

Routine name : CheckInstalledFax

Routine description:

	Checks whether SBS 5.0 Client / SBS 5.0 Server / XP Down Level Client is installed on the computer.
    If any of the parameters is NULL, the application of this parameter is not checked for presence.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

	pbSBSClient     [out]    - address of a bool variable to receive True if SBS 5.0 Client is installed, otherwise False
	pbXPDLClient    [out]    - address of a bool variable to receive True if XP DL Client is installed, otherwise False
	pbSBSServer     [out]    - address of a bool variable to receive True if SBS 5.0 Server is installed, otherwise False

Return Value:

    DWORD - failure or success code

--*/
{
    DWORD                   dwReturn = NO_ERROR;
    HMODULE                 hMsiModule = NULL;
    PF_MSIQUERYPRODUCTSTATE pFunc = NULL;

#ifdef UNICODE
    LPCSTR                  lpcstrFunctionName = "MsiQueryProductStateW";
#else
    LPCSTR                  lpcstrFunctionName = "MsiQueryProductStateA";
#endif

    DEBUG_FUNCTION_NAME(_T("CheckInstalledFax"));

    //
    //  at least one of the parameters should be valid
    //
    if (!pbSBSClient && !pbXPDLClient && !pbSBSServer)
    {
        DebugPrintEx(DEBUG_MSG, _T("All parameters are NULL. Nothing to check."));
        return dwReturn;
    }

    //
    //  Initialize the flags
    //
    if (pbSBSClient) 
    {
        *pbSBSClient = false;
    }
    if (pbXPDLClient)
    {
        *pbXPDLClient = false;
    }
    if (pbSBSServer)
    {
        *pbSBSServer = false;
    }

    //
    //  Load MSI DLL
    //

    hMsiModule = LoadLibrary(_T("msi.dll"));
    if (!hMsiModule)
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("Failed to LoadLibrary(msi.dll), ec=%ld."), dwReturn);
        return dwReturn;
    }

    //
    //  get the function we need to check presence of the applications
    //
    pFunc = (PF_MSIQUERYPRODUCTSTATE)GetProcAddress(hMsiModule, lpcstrFunctionName);
    if (!pFunc)
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("Failed to GetProcAddress( ' %s ' ) on Msi, ec=%ld."), lpcstrFunctionName, dwReturn);
        goto FreeLibrary;
    }

    //
    //  check for SBS 5.0 Client
    //
    if (pbSBSClient)
    {
        *pbSBSClient = (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_SBS50CLIENT));
        if (*pbSBSClient)
        {
            DebugPrintEx(DEBUG_MSG, _T("SBS 5.0 Client is installed on this machine."));
        }
    }

    //
    //  check for XP Down Level Client
    //
    if (pbXPDLClient)
    {
        *pbXPDLClient = (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_XPDLCLIENT));
        if (*pbXPDLClient)
        {
            DebugPrintEx(DEBUG_MSG, _T("Windows XP Down Level Client is installed on this machine."));
        }
    }

    //
    //  check for SBS 5.0 Server
    //
    if (pbSBSServer)
    {
        *pbSBSServer = (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_SBS50SERVER));
        if (*pbSBSServer)
        {
            DebugPrintEx(DEBUG_MSG, _T("SBS 5.0 Server is installed on this machine."));
        }
    }

FreeLibrary:

    if (!FreeLibrary(hMsiModule))
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("Failed to FreeLibrary() for Msi, ec=%ld."), dwReturn);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\security_patch\security.cpp ===
// security.cpp : Defines the entry point for the application.
//

#include <windows.h>
#include <tchar.h>
#include <faxreg.h>
#include <debugex.h>
#include <sddl.h>
#include <faxutil.h>

#define FXSTMP_FOLDER_ACL  _T("D:PAI(A;;0x100003;;;BU)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)(A;OICIIO;FA;;;CO)")

// These forward declarations belong to functions from util\service.cpp. They should
// be in inc\faxutil.h, but that means changing the util library, which will change ALL
// our binaries for XPSP.
DWORD 
FaxOpenService (
    LPCTSTR    lpctstrMachine,
    LPCTSTR    lpctstrService,
    SC_HANDLE *phSCM,
    SC_HANDLE *phSvc,
    DWORD      dwSCMDesiredAccess,
    DWORD      dwSvcDesiredAccess,
    LPDWORD    lpdwStatus
);

DWORD
FaxCloseService (
    SC_HANDLE hScm,
    SC_HANDLE hSvc
);    


DWORD SetServiceAccount(LPCTSTR lpszServiceName, LPCTSTR lpszServiceStartName, LPCTSTR lpszPassword) 
{ 
    SC_HANDLE schSCManager = NULL;
    SC_HANDLE schService   = NULL;
    DWORD ec               = ERROR_SUCCESS;            

    DBG_ENTER(TEXT("SetServiceAccount"));

    ec = FaxOpenService (
        NULL,      // lpctstrMachine,
        lpszServiceName,
        &schSCManager,
        &schService,
        GENERIC_WRITE,
        SERVICE_CHANGE_CONFIG,
        NULL );
    if (ec != ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR,_T("FaxOpenService failed, ec=%d"), ec);
        goto exit;
    }
   
    // Make the changes. 
    if (!ChangeServiceConfig( 
        schService,        // handle of service 
        SERVICE_NO_CHANGE, // service type: no change 
        SERVICE_NO_CHANGE, // change service start type 
        SERVICE_NO_CHANGE, // error control: no change 
        NULL,              // binary path: no change 
        NULL,              // load order group: no change 
        NULL,              // tag ID: no change 
        NULL,              // dependencies: no change 
        lpszServiceStartName, // account name 
        lpszPassword,      // password
        NULL) )            // display name: no change
    {
        ec = GetLastError();
        VERBOSE(SETUP_ERR,_T("ChangeServiceConfig failed, ec=%d"), ec);
        goto exit;
    }

    VERBOSE(DBG_MSG,_T("Changed Service %s to run under account %s"),
        lpszServiceName, lpszServiceStartName);
    ec = ERROR_SUCCESS;
 
exit:
    // Close the handle to the service. 
    FaxCloseService (schSCManager, schService);
    
    return ec; 
} 


BOOL SetFxstmpSecurity()
{
	TCHAR					tszPath[MAX_PATH]	= {0};
	PSECURITY_DESCRIPTOR	pSD					= NULL;

    DBG_ENTER(TEXT("SetFxstmpSecurity"));

	// get the system folder
	if (!GetSystemDirectory(tszPath,MAX_PATH-_tcslen(FAX_PREVIEW_TMP_DIR)-1))
	{
		// failed to get system folder, exit.
		VERBOSE(SETUP_ERR, _T("GetSystemDirectory failed (ec=%d)"), GetLastError());
		return FALSE;
	}

	// add FxsTmp to it
	_tcsncat(tszPath,_T("\\"),MAX_PATH-_tcslen(tszPath));
	_tcsncat(tszPath,FAX_PREVIEW_TMP_DIR,MAX_PATH-_tcslen(tszPath));
	VERBOSE(DBG_MSG,_T("Folder to secure is: %s"),tszPath);

	// convert the ACL to a SD
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(FXSTMP_FOLDER_ACL,SDDL_REVISION_1,&pSD,NULL))
    {
        VERBOSE(SETUP_ERR,_T("ConvertStringSecurityDescriptorToSecurityDescriptor failed (%s) (ec=%d)"),FXSTMP_FOLDER_ACL,GetLastError());
		return FALSE;
    }

	// apply the SD to the folder
    if (!SetFileSecurity(tszPath,DACL_SECURITY_INFORMATION,pSD))
    {
        VERBOSE(SETUP_ERR, _T("SetFileSecurity failed (ec=%d)"), GetLastError());
    }

	if (pSD)
	{
		LocalFree(pSD);
	}
	return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    int RetVal = 0;
    DWORD ec;
    
    DBG_ENTER(TEXT("FaxPatch"));

    if (!SetFxstmpSecurity())
    {
        VERBOSE(SETUP_ERR, _T("SetFxstmpSecurity failed (ec=%d)"), GetLastError());
        RetVal = -1;
    }

    // If a user ran Win2K with Fax Serice under a different user account (as documented
    // in Win2K Fax help), and upgraded to XP RTM, the Service would still run under 
    // that account and be broken.
    // So, set the Fax service to run under LocalSystem account
    if (ec = SetServiceAccount(FAX_SERVICE_NAME, _T(".\\LocalSystem"), _T("")) != ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR,_T("SetServiceAccount failed, ec=%d"), ec);
        RetVal = -2;
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdlib\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains utilitarian functions for
    the FAX TIFF library.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}


INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\printers.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    printers.cpp

Abstract:

    This file implements printer manipulation common setup routines

Author:

    Asaf Shaar (AsafS) 7-Nov-2000

Environment:

    User Mode

--*/
#include <windows.h>
#include <Winspool.h>
#include <SetupUtil.h>


//
//
// Function:    DeleteFaxPrinter
// Description: Delete fax printer driver for win2k from current machine
//              In case of failure, log it and returns FALSE.
//              Returns TRUE on success
//              
// Args:        lpctstrFaxPrinterName (LPTSTR): Fax printer name
//
//
// Author:      AsafS

BOOL
DeleteFaxPrinter(
    LPCTSTR lpctstrFaxPrinterName  // printer name
    )
{
    BOOL fSuccess = TRUE;
    DBG_ENTER(TEXT("DeleteFaxPrinter"), fSuccess, TEXT("%s"), lpctstrFaxPrinterName);

    HANDLE hPrinter = NULL;
    
    DWORD ec = ERROR_SUCCESS;

    PRINTER_DEFAULTS Default;

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = PRINTER_ACCESS_ADMINISTER|DELETE;
    
    if (!OpenPrinter(
        (LPTSTR) lpctstrFaxPrinterName,
        &hPrinter,
        &Default)
        )
    {
        ec = GetLastError();
        ASSERTION(!hPrinter); 
        VERBOSE (PRINT_ERR,
                 TEXT("OpenPrinter() for %s failed (ec: %ld)"),
                 lpctstrFaxPrinterName,
                 ec);
        goto Exit;
    }
    
    ASSERTION(hPrinter); // be sure that we got valid printer handle

    // purge all the print jobs -- can't delete a printer with jobs in queue (printed or not)
    if (!SetPrinter(
        hPrinter, 
        0, 
        NULL, 
        PRINTER_CONTROL_PURGE)
        )
    {
        // Don't let a failure here keep us from attempting the delete
        VERBOSE(PRINT_ERR,
                TEXT("SetPrinter failed (purge jobs before uninstall %s)!")
                TEXT("Last error: %d"),
                lpctstrFaxPrinterName,
                GetLastError());
    }

    if (!DeletePrinter(hPrinter))
    {
        ec = GetLastError();
        VERBOSE (PRINT_ERR,
                 TEXT("Delete Printer %s failed (ec: %ld)"),
                 lpctstrFaxPrinterName,
                 ec);
        goto Exit;
    }
    
    VERBOSE (DBG_MSG,
             TEXT("DeletePrinter() for %s succeeded"),
             lpctstrFaxPrinterName);
Exit:
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
    }
    SetLastError(ec);
    fSuccess = (ERROR_SUCCESS == ec);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\covepages.cpp ===
#include <setuputil.h>
#include <debugex.h>


// 
// Function:    IsTheSameFileAlreadyExist
// Description: Compare old cover page against new cover page and copy only if the are different.
//			    
// Returns:		TRUE if the files are identical, FALSE otherwise
//
// Remarks:     
//
// Args:
// LPCTSTR lpctstrSourceDirectory (IN)		: The source directory (old cover pages directory)
// LPCTSTR lpctstrDestinationDirectory (IN)	: The destination directory (new cover pages directory)
// LPCTSTR lpctstrFileName (IN)				: The name of the file (must be prefixes with '_' )

//
// Author:      AsafS

BOOL
IsTheSameFileAlreadyExist(
	LPCTSTR lpctstrSourceDirectory,
	LPCTSTR lpctstrDestinationDirectory,
	LPCTSTR lpctstrFileName			
	)
{
	BOOL fRet = FALSE;
	DBG_ENTER(TEXT("IsTheSameFileAlreadyExist"), fRet);

	LPCTSTR installedCoverPages[] = 
    {
        TEXT("confdent.cov"),
        TEXT("fyi.cov"),
        TEXT("generic.cov"),
        TEXT("urgent.cov")
    };

	TCHAR szOldFile[MAX_PATH] = {0};
	TCHAR szNewFile[MAX_PATH] = {0};

	HANDLE hOldFile = NULL;
	HANDLE hNewFile = NULL;

	HANDLE hOldFileMapping = NULL;
	HANDLE hNewFileMapping = NULL;

	LPVOID lpvoidNewMapView = NULL;
	LPVOID lpvoidOldMapView = NULL;

	DWORD dwOldFileSize = 0;
	DWORD dwNewFileSize = 0;

	DWORD dwFileSize = 0;

	int iNumberOfFiles = sizeof(installedCoverPages)/sizeof(LPCTSTR);
	int index;

	if (lpctstrFileName[0] != TEXT('_'))
	{
		VERBOSE(
			DBG_MSG, 
			TEXT("File %s is not original cover page"),
			lpctstrFileName
			);
		return FALSE;
	}

	lpctstrFileName++;

	for (index=0; index<iNumberOfFiles; index++)
	{
		if (0 == _tcscmp(
			lpctstrFileName,
			installedCoverPages[index]
			))
		{
			break;
		}
	}

	if (index == iNumberOfFiles)
	{
		return FALSE;
	}

	// We have found a file from SBS4.5, lets compare it to the file that was installed in SBS2000
	
	_stprintf(
		szOldFile,
		TEXT("%s\\_%s"),
		lpctstrSourceDirectory,
		lpctstrFileName
		);

	_stprintf(
		szNewFile,
		TEXT("%s\\%s"),
		lpctstrDestinationDirectory,
		lpctstrFileName
		);

	hOldFile = CreateFile(
		szOldFile,
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if (INVALID_HANDLE_VALUE == hOldFile)
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("CreateFile"),
			GetLastError());		
		goto exit;
	}

	hNewFile = CreateFile(
		szNewFile,
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if (INVALID_HANDLE_VALUE == hNewFile)
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("CreateFile"),
			GetLastError());
		goto exit;
	}


	dwOldFileSize = GetFileSize(
		hOldFile,
		NULL
		);
	dwNewFileSize = GetFileSize(
		hNewFile,
		NULL
		);

	if ((dwOldFileSize != dwNewFileSize) || (0 == dwOldFileSize) || (0 == dwNewFileSize))
	{
		VERBOSE(
			DBG_MSG, 
			TEXT("The file sizes are not equal or one of the file is of size 0")
			);
		goto exit;
	}

	dwFileSize = dwOldFileSize;
	
	hOldFileMapping = CreateFileMapping(
		hOldFile,
		NULL,
		PAGE_READONLY,
		0,
		0,
		NULL
		);
	if (!hOldFileMapping)
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("CreateFileMapping"),
			GetLastError());
		goto exit;
	}

	hNewFileMapping = CreateFileMapping(
		hOldFile,
		NULL,
		PAGE_READONLY,
		0,
		0,
		NULL
		);
	if (!hOldFileMapping)
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("CreateFileMapping"),
			GetLastError());
		goto exit;
	}

	lpvoidOldMapView = MapViewOfFile(
		hOldFileMapping,
		FILE_MAP_READ,
		0,
		0,
		0
		);

	lpvoidNewMapView = MapViewOfFile(
		hOldFileMapping,
		FILE_MAP_READ,
		0,
		0,
		0
		);

	if ((!lpvoidOldMapView) || (!lpvoidNewMapView))
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("MapViewOfFile"),
			GetLastError());
		goto exit;
	}

	if (memcmp(
		lpvoidOldMapView,
		lpvoidNewMapView,
		dwFileSize
		) == 0)
	{
		fRet = TRUE;
	}

exit:
	if (!lpvoidOldMapView)
	{
		UnmapViewOfFile(lpvoidOldMapView);
	}

	if (!lpvoidNewMapView)
	{
		UnmapViewOfFile(lpvoidNewMapView);
	}

	if (hOldFileMapping)
	{
		CloseHandle(hOldFileMapping);
	}
	if (hNewFileMapping)
	{
		CloseHandle(hNewFileMapping);
	}
	
	if ((hOldFile) &&  (INVALID_HANDLE_VALUE != hOldFile))
	{
		CloseHandle(hOldFile);
	}
	
	if ((hNewFile) &&  (INVALID_HANDLE_VALUE != hNewFile))
	{
		CloseHandle(hNewFile);
	}

	return fRet;
}


// 
// Function:    CopyCoverPagesFiles
// Description: Copy file from one directory to another. The files that will be copied are *.cov
//				All file names will get the same prefix
//			    and migrate it to a given fax server
// LPCTSTR		lpctstrSourceDirectory (IN)		 : The source directory (without '\' at the end)
// LPCTSTR		lpctstrDestinationDirectory (IN) : The destination directory (without '\' at the end)
// LPCTSTR		lpctstrPrefix (IN)				 : The prefix needed for the file
// BOOL	        fCheckIfExist(IN)				 : If TRUE then check if the same file already exist before copy
//
// Returns:		TRUE for success, FALSE otherwise
//
// Remarks:     If the file already exist, it would be replaced
//
// Author:      AsafS

BOOL
CopyCoverPagesFiles(
	LPCTSTR lpctstrSourceDirectory,
	LPCTSTR lpctstrDestinationDirectory,
	LPCTSTR lpctstrPrefix,
	BOOL	fCheckIfExist
	)
{
	BOOL fRet = FALSE;
	DBG_ENTER(TEXT("CopyCoverPagesFiles"), fRet);

	
	TCHAR szSource[MAX_PATH]		= {0};
	TCHAR szDestination[MAX_PATH]	= {0};
	TCHAR szSearch[MAX_PATH]		= {0};

	HANDLE hFind = NULL;
	WIN32_FIND_DATA FindFileData;

	

	_stprintf(
		szSearch, 
		TEXT("%s\\*.cov"),
		lpctstrSourceDirectory
		);
	
	hFind = FindFirstFile(
		szSearch,
		&FindFileData
		);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("FindFirstFile"),
			GetLastError());
		goto error;
	}

	do
	{
		if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			_stprintf(
				szSource, 
				TEXT("%s\\%s"),
				lpctstrSourceDirectory,
				FindFileData.cFileName
				);
			_stprintf(
				szDestination, 
				TEXT("%s\\%s_%s"),
				lpctstrDestinationDirectory,
				lpctstrPrefix,
				FindFileData.cFileName
				);
			
			if ((fCheckIfExist) && (IsTheSameFileAlreadyExist(
				lpctstrSourceDirectory,
				lpctstrDestinationDirectory,
				FindFileData.cFileName
				)))
			{
				VERBOSE(
					DBG_MSG, 
					TEXT("File %s was not change and will not be copied"),
					FindFileData.cFileName
					);
			}
			else
			{
			
				VERBOSE(
					DBG_MSG, 
					TEXT("Copy (%s => %s)"),
					szSource,
					szDestination
					);

				if (!CopyFile(
					szSource,
					szDestination,
					FALSE
					))
				{
					CALL_FAIL(
						GENERAL_ERR,
						TEXT("CopyFile"),
						GetLastError()
						);
				}
				else
				{
					// should we try to delete the orignal file (like MoveFile do)
				}
			}
		}
	} while (FindNextFile(hFind, &FindFileData));


	fRet = TRUE;
error:
	if (hFind)
	{
		FindClose(hFind);
	}
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\setup.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    product.c

Abstract:

    This file implements common setup routines for fax.

Author:

    Mooly Beery (MoolyB) 16-Aug-2000

Environment:

    User Mode

--*/
#include <SetupUtil.h>
#include <MsiQuery.h>

// 
//
// Function:    PrivateMsiGetProperty
// Description: Gets a property from Windows Installer API 
//              In case of failure , returns FALSE
//              In case of success , returns TRUE
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
//
// Author:      MoolyB
BOOL PrivateMsiGetProperty
(
    MSIHANDLE hInstall,    // installer handle
    LPCTSTR szName,        // property identifier, case-sensitive
    LPTSTR szValueBuf      // buffer for returned property value
)
{
    UINT    uiRet   = ERROR_SUCCESS;
    int     iCount  = 0;
    DWORD   cchValue = MAX_PATH;

    DBG_ENTER(TEXT("PrivateMsiGetProperty"));

    uiRet = MsiGetProperty(hInstall,szName,szValueBuf,&cchValue);
    if (uiRet==ERROR_SUCCESS && (iCount=_tcslen(szValueBuf)))
    {
        VERBOSE(    DBG_MSG,
                    _T("MsiGetProperty:%s returned %s."),
                    szName,
                    szValueBuf);
    }
    else if (iCount==0)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MsiGetProperty:%s returned an empty string."),
                szName);

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    else
    {
        VERBOSE(GENERAL_ERR, 
                _T("MsiGetProperty:%s failed (ec: %ld)."),
                szName,
                uiRet);

        SetLastError(uiRet);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\util\sources.inc ===
!ifndef FAXROOT
FAXROOT=$(BASEDIR)\private\fax
!endif
USECXX_FLAG=/Tp

!include $(FAXROOT)\faxsrc.inc

TARGETNAME=setuputil
TARGETPATH=obj
TARGETTYPE=LIBRARY

UMTYPE=windows

INCLUDES=   $(INCLUDES); \
            ..\..\inc;   \

C_DEFINES= $(C_DEFINES) -DENABLE_FRE_LOGGING

SOURCES=\
  ..\covepages.cpp      \
  ..\shortcuts.cpp      \
  ..\setup.cpp			\
  ..\printers.cpp	    \
  ..\install.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdvstub\resource.h ===
// resource.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// This file contains the resource constants for the AWD viewer stub.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-18

#define IDS_USEAGE	200
#define IDS_TITLE	201
#define IDS_NOVIEW	202
#define IDS_ERRCONV	203
#define IDS_NOTEMPPATH  204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\dcxcodec\dcxcodec.cpp ===
/*==============================================================================
This code module handles HRAW<==>DCX conversions.

DATE       NAME      COMMENTS
13-Apr-93  RajeevD   Adapted to C++ from WFW.
05-Oct-93  RajeevD   Moved out of faxcodec.dll
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <dcxcodec.h>

#ifdef DEBUG
DBGPARAM dpCurSettings = {"DCXCODEC"};
#endif

// Context Object
typedef struct FAR DCX : public FC_PARAM
{
	LPBYTE lpbSave;
	UINT   cbSave;
	LPBYTE lpbIn, lpbOut;
	UINT   cbIn,  cbOut;
	UINT   ibLine;
	BYTE   bVal, bRun;
	
	void Init (LPFC_PARAM lpfcParam)
	{
			_fmemcpy (this, lpfcParam, sizeof(FC_PARAM));
			ibLine = 0;
			bRun = 0;
			cbSave = 0;
			lpbSave = (LPBYTE) (this + 1);
	}

	FC_STATUS Convert (LPBUFFER, LPBUFFER);
	void RawToDcx (void);
	void DcxToRaw (void);
}
	FAR *LPDCX;

//==============================================================================
FC_STATUS DCX::Convert
	(LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	// Trap end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
		return FC_INPUT_EMPTY;

	// Get buffer parameters.
	lpbIn = lpbufIn->lpbBegData;		
	cbIn = lpbufIn->wLengthData;
	lpbOut = lpbufOut->EndData();

  // Restore raw overflow.
	if (cbSave)
	{
		DEBUGCHK (nTypeOut == HRAW_DATA);
		_fmemcpy (lpbOut, lpbSave, cbSave);
		lpbOut += cbSave;
	}

  // Calculate output buffer.
	cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	// Execute the conversion.
	nTypeOut == DCX_DATA ? RawToDcx() : DcxToRaw();

	// Adjust buffers.
	lpbufIn->lpbBegData = lpbIn;
	lpbufIn->wLengthData = (USHORT)cbIn;
	lpbufOut->wLengthData = (USHORT)(lpbOut - lpbufOut->lpbBegData);

	// Save raw overflow.
	if (nTypeOut == HRAW_DATA)
 	{
		cbSave = lpbufOut->wLengthData % cbLine;
		lpbufOut->wLengthData -= (USHORT)cbSave;
		_fmemcpy (lpbSave, lpbufOut->EndData(), cbSave);
	}

	// Return status.
	return cbIn? FC_OUTPUT_FULL : FC_INPUT_EMPTY;
}

/*==============================================================================
This procedure decodes HRAW bitmaps from DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty, or the output is full.  Unlike the consumers and producers 
in the t4core.asm, it does not automatically return at the first EOL.
==============================================================================*/
void DCX::DcxToRaw (void)
{
  // Loop until input is empty or output is full.
	while (1)
	{
		if (bRun >= 0xC0)		    // Has the run been decoded?
		{
			if (!cbIn) return;    // Check if input is empty.
			if (ibLine >= cbLine) // If at end of line,
				ibLine = 0;         //   wrap the position.
			bVal = ~(*lpbIn++);   // Fetch the value of the run.
			cbIn--;
			bRun -= 0xC0;         // Decode the run length.
		}

#if 0 // transparent version

    // Write out the run.
		while (bRun) 
		{	
			*lpbOut++ = bVal;
	 		cbOut--;
	 		ibLine++;
			bRun--;
		}

#else // optimized version

		if (bRun)
		{
			// Write out the run.
			BYTE bLen = min (bRun, cbOut);
			_fmemset (lpbOut, bVal, bLen);

			// Adjust the output parameters.
			bRun -= bLen;
			lpbOut += bLen;
			cbOut -= bLen;
			ibLine += bLen;
											
			// Check if output is full.
			if (!cbOut) return;
		}

#endif // optimize switch

		if (!cbIn) return;    // Fetch the next byte.
		if (ibLine >= cbLine)	// If at end of line,
			ibLine = 0;         //   wrap the position.
		if (*lpbIn >= 0xC0)		// If the byte is a run length, set up.
			bRun = *lpbIn++;

		else                  // Otherwise the byte is a single value.
			{ bRun = 1; bVal = ~(*lpbIn++);}
		cbIn--;

	} // while (1)
	
}
 
/*==============================================================================
This procedure encodes HRAW bitmaps for DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty or the output is full.  Unlike its brethren in T4, it does 
not return automatically at EOL.
==============================================================================*/
void DCX::RawToDcx (void)
{
	BYTE bVal, bRun;

	// Convert until input is empty or output is full.
	// The output is full if only one byte is available
	// because one input byte may produce two output bytes.
	while (cbIn && cbOut > 1)
	{
		if (ibLine >= cbLine) ibLine = 0;	// If EOL, wrap the position.
			
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
		ibLine++;
		
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The end of the current line has been reached.
		// (3) The run length has reached the maximum of 63.
		// (4) The first byte does not match the current one.

#if 0 // Transparent Version.	

		while (/*1*/ cbIn	// Check first to avoid GP faults!
				&& /*4*/ bVal == *lpbIn
				&& /*2*/ ibLine < cbLine
				&& /*3*/ bRun < 63
					)
		{ lpbIn++; cbIn--; bRun++; ibLine++; }

#else // Optimized Version
	
	// If the next byte matches, scan for a run.
	// This test has been unrolled from the loop.
 	if (cbIn && bVal == *lpbIn)
	{
		BYTE ubMaxRest, ubRest;
		
		// Calculate the maximum number of bytes remaining.
		ubMaxRest = min (cbIn, 62);
		ubMaxRest = min (ubMaxRest, cbLine - ibLine);

		// Scan for a run.
		ubRest = 0;
		while (bVal == *lpbIn && ubRest < ubMaxRest)
			{lpbIn++; ubRest++;}

		// Adjust state.
		cbIn -= ubRest;
		ibLine += ubRest;
		bRun = ++ubRest;
	}

#endif // End of Compile Switch
 			
		bVal = ~bVal;		// Flip black and white.

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{ // Yes, encode the run length.
		  // (Possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut--;
		}	

		*lpbOut++ = bVal;		// Encode the value.
		cbOut--;

	} // while (1)
}

//==============================================================================
// C Export Wrappers
//==============================================================================

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
UINT WINAPI DcxCodecInit
	(LPVOID lpContext, LPFC_PARAM lpfcParam)
{
	UINT cbContext = sizeof(DCX);
	if (lpfcParam->nTypeOut == HRAW_DATA)
		cbContext += lpfcParam->cbLine;

	if (lpContext)
		((LPDCX) lpContext)->Init (lpfcParam);
	return cbContext;
}
 
//==============================================================================
FC_STATUS WINAPI DcxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPDCX) lpContext)->Convert (lpbufIn, lpbufOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\dcxcodec\raw2dcx.c ===
/*==============================================================================
This procedure converts HRAW to DCX in memory.

ASSUMES
1) Input buffer contains a single scan line.
2) Output buffer is twice as large as input.

29-Apr-94    RajeevD    Adapted from dcxcodec.dll
==============================================================================*/
#include <windows.h>

UINT              // output data size
DCXEncode
(
	LPBYTE lpbIn,   // raw input buffer
  LPBYTE lpbOut,  // dcx output buffer
	UINT cbIn       // input data size
)
{
	UINT cbOut = 0;
	BYTE bVal, bRun;

  while (cbIn)
  {
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
	
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The run length has reached the maximum of 63.
		// (3) The first byte does not match the current one.

	 	if (cbIn && bVal == *lpbIn)
		{
			BYTE cbMax, cbRest;
			
			// Calculate the maximum number of bytes remaining.
			cbMax = min (cbIn, 62);

			// Scan for a run.
			cbRest = 0;
			while (bVal == *lpbIn && cbRest < cbMax)
				{lpbIn++; cbRest++;}

			// Adjust state.
			cbIn -= cbRest;
			bRun = ++cbRest;
		}	
		
	  // Flip black and white.
		bVal = ~bVal;	

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{
			// Yes, encode the run length.
		  // (possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut++;
		}	

		// Encode the value.
		*lpbOut++ = bVal;		
		cbOut++;
	
	} // while (cbIn)

	return cbOut;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\bitrev.c ===
#include <ifaxos.h>
#include <faxcodec.h>

//==============================================================================
const BYTE BitRev[256] = // bit reversal of index
{
	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

//==============================================================================
void WINAPI BitReverseBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb; 
	USHORT cb; 

	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);

	switch (lpbuf->dwMetaData)
	{
		case LRAW_DATA:	lpbuf->dwMetaData = HRAW_DATA; break;
		case HRAW_DATA:	lpbuf->dwMetaData = LRAW_DATA; break;
		default:
			DEBUGMSG (1, ("FaxCodecRevBuf invalid metadata %d\r\n",lpbuf->dwMetaData));
	}

	lpb = lpbuf->lpbBegData;
	cb = lpbuf->wLengthData;
	while (cb--)
		*lpb++ =  BitRev[*lpb];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\client.c ===
/*==============================================================================
This source file is an example of a faxcodec.dll client.
          
DATE				NAME			COMMENT
13-Apr-93		rajeevd		Moved out of faxcodec.dll
18-Nov-93   rajeevd   Updated to new faxcodec API.
==============================================================================*/
#include <windows.h>
#include <buffers.h>
#include <faxcodec.h>

/*==============================================================================
This procedure performs any conversion indicated by a star in the table below:

                            Output

                 HRAW   LRAW   MH   MR    MMR

          HRAW                 *     *     *

          LRAW		             *     *     *

  Input   MH       *     *           *     *

          MR       *     *     *           *

          MMR      *     *     *     *      

The input and output are assumed to be in non-overlapping memory buffers.
==============================================================================*/

UINT MemConvert      // returns output data size (0 on failure)
	(
		LPBYTE lpbIn,    // input data pointer
		UINT   cbIn,     // input data size
		DWORD  nTypeIn,  // input data encoding
		
		LPBYTE lpbOut,   // output buffer pointer
		UINT   cbOut,    // output buffer size
		DWORD  nTypeOut, // output data encoding
		
		UINT   cbLine,   // scan line width
		UINT   nKFactor  // K factor (significant if nTypeOut==MR_DATA)
	)
{
	UINT cbRet = 0; 
	
	BUFFER bufIn, bufOut, bufEOP;
	BOOL fRevIn, fRevOut;

	HANDLE hContext;
	LPVOID lpContext;
	UINT cbContext;

	FC_PARAM  fcp;
	FC_STATUS fcs;
	
	// Set up input buffer.
	bufIn.lpbBegBuf = lpbIn;	
	bufIn.wLengthBuf  = cbIn;  
	bufIn.lpbBegData  = lpbIn;
	bufIn.wLengthData = cbIn;
	bufIn.dwMetaData   = nTypeIn;
	
	// Set up output buffer.
	bufOut.lpbBegBuf   = lpbOut;
	bufOut.lpbBegData  = lpbOut;
	bufOut.wLengthBuf  = cbOut;
	bufOut.wLengthData = 0;
	bufOut.dwMetaData   = nTypeOut;
	
	// Initialize EOP buffer
	bufEOP.dwMetaData = END_OF_PAGE;

	// Handle input bit reversal.
	if (nTypeIn == HRAW_DATA)
	{
		fRevIn = TRUE;
		BitReverseBuf (&bufIn);
	}	
	else fRevIn = FALSE;
	
	// Detect output bit reversal.
	if (nTypeOut == HRAW_DATA)
	{
		fRevOut = TRUE;
		nTypeOut = LRAW_DATA;
	}
	else fRevOut = FALSE;

	// Initialize parameters.
	fcp.nTypeIn  = nTypeIn;
	fcp.nTypeOut = nTypeOut;
	fcp.cbLine   = cbLine;
	fcp.nKFactor = nKFactor;

	// Query for size of context.
	cbContext = FaxCodecInit (NULL, &fcp);
	if (!cbContext)
		goto err;

	// Allocate context memory.
	hContext = GlobalAlloc (GMEM_FIXED, cbContext);
	if (!hContext)
		goto err;
	lpContext = GlobalLock (hContext);

	// Initialize context.
	FaxCodecInit (lpContext, &fcp); 

	// Convert data in single pass.
	fcs = FaxCodecConvert (lpContext, &bufIn,  &bufOut); 

	// Flush EOFB for nTypeOut == MMR_DATA
	FaxCodecConvert (lpContext, &bufEOP, &bufOut);

	// Free context memory.
	GlobalUnlock (hContext);
	GlobalFree (hContext);
	
	// Undo input bit reversal.
	if (fRevIn)
	{
		bufIn.lpbBegData = lpbIn;
		bufIn.wLengthData = cbIn;
		BitReverseBuf (&bufIn);
	}

	// Handle output bit reversal.
	if (fRevOut)
		BitReverseBuf (&bufOut);
	
	if (fcs == FC_INPUT_EMPTY)
		cbRet = bufOut.wLengthData;

err:
	return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\faxcodec.cpp ===
/*=============================================================================
This code module dispatches external C calls to internal C++ calls.

DATE        NAME      COMMENTS
12-Apr-93   RajeevD   Adapted to C++ from WFW.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>
#include <memory.h>
#include "context.hpp"

#ifdef DEBUG
#ifdef WIN32
DBGPARAM dpCurSettings = {"AWCODC32"};
#else
DBGPARAM dpCurSettings = {"FAXCODEC"};
#endif
#endif

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

#define CONTEXT_SLACK (RAWBUF_SLACK + 2*CHANGE_SLACK)

//==============================================================================
UINT WINAPI FaxCodecInit (LPVOID lpContext, LPFC_PARAM lpParam)
{
	// Do we need double buffered change vector?
	BOOL f2DInit = 
		  lpParam->nTypeIn  ==  MR_DATA
   || lpParam->nTypeIn  == MMR_DATA
	 || lpParam->nTypeOut ==  MR_DATA 
	 || lpParam->nTypeOut == MMR_DATA;

	// Enforce 64K limit on size of context.
	DEBUGCHK (!(lpParam->cbLine > (f2DInit? 1875U : 3750U)));
	if (lpParam->cbLine > (f2DInit? 1875U : 3750U)) return 0;

	// Enforce nonzero K factor if encoding MR.
	DEBUGCHK (lpParam->nKFactor || lpParam->nTypeOut != MR_DATA);

	if (lpContext)
		((LPCODEC) lpContext)->Init (lpParam, f2DInit);
	return sizeof(CODEC) + CONTEXT_SLACK + (f2DInit ? 33:17) * lpParam->cbLine;
}

//==============================================================================
UINT WINAPI FaxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPCODEC) lpContext)->Convert (lpbufIn, lpbufOut);
}

//==============================================================================
void WINAPI FaxCodecCount (LPVOID lpContext, LPFC_COUNT lpCountOut)
{
	LPFC_COUNT lpCountIn = &((LPCODEC) lpContext)->fcCount;
	DEBUGMSG(1,("FaxCodecCount: good=%ld bad=%ld\n consec=%ld",
		lpCountIn->cTotalGood, lpCountIn->cTotalBad, lpCountIn->cMaxRunBad));
	_fmemcpy (lpCountOut, lpCountIn, sizeof(FC_COUNT));
	_fmemset (lpCountIn, 0, sizeof(FC_COUNT));
}	

//==============================================================================
void WINAPI InvertBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb = lpbuf->lpbBegData;
	WORD    cb = lpbuf->wLengthData;
	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);
	while (cb--) *lpb++ = ~*lpb;
}

//==============================================================================
void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,      // input LRAW scan line
	UINT    cbLine,       // scan line byte width
  LPSHORT lpsChange     // output change vector
)
{
	T4STATE t4;

	t4.lpbIn   = lpbLine;
	t4.lpbOut  = (LPBYTE) lpsChange;
	t4.cbIn    = (WORD)cbLine;
	t4.cbOut   = cbLine * 16;
	t4.cbLine  = (WORD)cbLine;
	t4.wColumn = 0;
	t4.wColor  = 0;
	t4.wWord   = 0;
	t4.wBit    = 0;
	t4.cbSlack = CHANGE_SLACK;
	t4.wRet    = RET_BEG_OF_PAGE;

	RawToChange (&t4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\bmrotate.c ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/

/*============================================================================
// FILE                     RPBMVER.C
//
// MODULE                   Jumbo Cartridge Code
//
// PURPOSE                  This file contains Vertical Bitmap Code
//
// DESCRIBED IN             This module is described in jumbo .
//
// MNEMONICS                Standard Hungarian
//
// HISTORY
//
// 05/26/92  RodneyK        Original implimentation:
// 05/11/94  RajeevD        Adapted for unified.
//==========================================================================*/

#include <windows.h>
#include "jtypes.h"         /* Jumbo type definitions.                */

/*--------------------------------------------------------------------------*/

USHORT WINAPI RP_BITMAPV
(
   USHORT  usRow,             /* Row to start Bitmap             */
   USHORT  usCol,             /* Column to Start Bitmap          */
   UBYTE   ubTopPadBits,      /* Bits to skip in the data stream */
   USHORT  usHeight,          /* Number of bits to draw          */
   UBYTE FAR  *ubBitmapData,  /* Data to draw                    */
   LPBYTE  lpbOut,            // output band buffer
   UINT    cbLine             // bytes per scan line
)
/*
//
//  PURPOSE               This function draws vertical bitmaps in source
//                        copy mode.
//
//
// ASSUMPTIONS &          The code assumes nothing other than it gets valid
// ASSERTIONS             input data.
//
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
// UNRESOLVED ISSUES      None
//
//
//--------------------------------------------------------------------------*/
{
   UBYTE     *pubDest;
   SHORT     sIterations;
   USHORT    usReturnVal;
   USHORT    us1stByte;
   UBYTE     ubMask;
   UBYTE     ubNotMask;
   UBYTE     ubRotator;
   UBYTE     ubCurByte;


   usReturnVal = (ubTopPadBits + usHeight + 7) >> 3;

   pubDest = (UBYTE *) lpbOut + (usRow * cbLine) + (usCol >> 3);
   ubMask  = 0x80 >> (usCol & 7);
   ubNotMask = ~ubMask;

   ubCurByte = *ubBitmapData++;
   us1stByte = 8-ubTopPadBits;

   ubRotator = 0x80 >> ubTopPadBits;
   switch (us1stByte)
   {
      case 8 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               --usHeight;
      default:
               break;
   }

   ubCurByte = *ubBitmapData++;
   sIterations = usHeight >> 3;

   while (--sIterations >= 0)
   {
      /* 1 */
      *pubDest = (0x80 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 2 */
      *pubDest = (0x40 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 3 */
      *pubDest = (0x20 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 4 */
      *pubDest = (0x10 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 5 */
      *pubDest = (0x08 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 6 */
      *pubDest = (0x04 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 7 */
      *pubDest = (0x02 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 8 */
      *pubDest = (0x01 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;

      ubCurByte = *ubBitmapData++;
   }

   ubRotator = 0x80;
   switch (usHeight & 0x07)
   {
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      default:
               break;
   }

   return (usReturnVal); /* Return the number of byte in the list */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdlib\awdlib.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

awd library

Routines for reading from an AWD file.

Author:
  Brian Dewey (t-briand) 1997-7-2
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include <awdlib.h>		// Header file for this library.

// ------------------------------------------------------------
// Auxiliary routines

// OpenAWDFile
//
// Opens an AWD file and fills in the psStorages structure.
//
// Parameters:
//	pwcsFilename		name of file to open (UNICODE)
//	psStorages		Pointer to structure that will hold
//				the major storages used in an AWD file.
//
// Returns:
//	TRUE on success, FALSE on failure.  One or more storages may be
//	NULL even when the routine returns TRUE.  The client needs to
//	check for this.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-30
BOOL
OpenAWDFile(const WCHAR *pwcsFilename, AWD_FILE *psStorages)
{
    HRESULT hStatus;		// Status indicator for reporting errors.

    hStatus = StgOpenStorage(pwcsFilename,
			     NULL,
			     STGM_READ | STGM_SHARE_EXCLUSIVE,
			     NULL,
			     0,
			     &psStorages->psAWDFile);
    if(FAILED(hStatus)) {
	return FALSE;
    }
	// If we get here, we've succeeded.  Now open the related storages.
    psStorages->psDocuments = OpenAWDSubStorage(psStorages->psAWDFile,
						L"Documents");
    psStorages->psPersistInfo = OpenAWDSubStorage(psStorages->psAWDFile,
						  L"Persistent Information");
    psStorages->psDocInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					      L"Document Information");
    psStorages->psPageInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					       L"Page Information");
    psStorages->psGlobalInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
						 L"Global Information");
    return TRUE;
}

// CloseAWDFile
//
// Closes an AWD file.
//
// Parameters:
//	psStorages		Pointer to the AWD file.
//	
// Returns:
// 	TRUE on success, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
CloseAWDFile(AWD_FILE *psStorages)
{
	// This should probably use some exception mechanism.
    BOOL success = TRUE;
    if(FAILED(psStorages->psGlobalInfo->lpVtbl->Release(psStorages->psGlobalInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPageInfo->lpVtbl->Release(psStorages->psPageInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocInfo->lpVtbl->Release(psStorages->psDocInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPersistInfo->lpVtbl->Release(psStorages->psPersistInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocuments->lpVtbl->Release(psStorages->psDocuments))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psAWDFile->lpVtbl->Release(psStorages->psAWDFile))) {
	success = FALSE;
    }
    return success;
}

// OpenAWDSubStorage
//
// Get a substorage from a parent storage.  Checks for errors
// and exits on error conditions.  Note that it's not an error if
// the substorage doesn't exist, so the caller should still check for NULL.
//
// Parameters:
//	psParent		Pointer to the parent storage.
//	pwcsStorageName		Name of the substorage (UNICODE).
//
// Returns:
//	A pointer to the substorage, or NULL if the substorage doesn't exist.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
IStorage *
OpenAWDSubStorage(IStorage *psParent, const WCHAR *pwcsStorageName)
{
    IStorage *psSubStorage;	    // The substorage.
    HRESULT hStatus;		    // Status of the call.

    if(psParent == NULL) return NULL;
    hStatus = psParent->lpVtbl->OpenStorage(psParent,
					    pwcsStorageName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    NULL,
					    0,
					    &psSubStorage);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) {
	    fwprintf(stderr, L"OpenAWDSubStorage:No such substorage '%s'.\n",
		     pwcsStorageName);
	    return NULL;
	}
	    // use the wide-printf() to get the UNICODE filename.
	fwprintf(stderr, L"OpenAWDSubStorage:Unable to open substorage %s.\n",
		pwcsStorageName);
	exit(1);
    }
    return psSubStorage;
}

// OpenAWDStream
//
// This function opens an AWD stream for exclusive read access.  It
// checks for errors and exits on an error condition.  Not found is
// not considered a fatal error.
//
// Parameters:
// 	psStorage		Pointer to the storage holding the stream.
//	pwcsStreamName		Name of the stream (UNICODE).
//
// Returns:
// 	A pointer to the stream.  If no such stream exists, returns NULL.
// 	It will abort on any other error.
//
// Author:
// 	Brian Dewey (t-briand)	1997-6-27
IStream *
OpenAWDStream(IStorage *psStorage, const WCHAR *pwcsStreamName)
{
    HRESULT hStatus;
    IStream *psStream;

    assert(psStorage != NULL);		    // Sanity check.
    fwprintf(stderr, L"OpenAWDStream:Opening stream '%s'.\n", pwcsStreamName);
    hStatus = psStorage->lpVtbl->OpenStream(psStorage,
					    pwcsStreamName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) return NULL;
	fwprintf(stderr, L"OpenAWDStream:Error %x when opening stream %s.\n",
		 hStatus, pwcsStreamName);
	exit(1);
    }
    return psStream;
}

// AWDViewed
//
// This function tests if the AWD file has previously been viewed by
// a viewer.  It does this by checking for the presence of a stream
// called "BeenViewed."  See AWD specs.
//
// Parameters:
//	psStorage		Pointer to the "Persistent Information"
//				substorage.
//
// Returns:
//	TRUE if the file has been viewed, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
AWDViewed(AWD_FILE *psStorages)
{
    IStream *psStream;		    // Pointer to the been-viewed stream.
    HRESULT hStatus;		    // Holds the status of the call.

	// Attempt to open the BeenViewed stream.
    hStatus = psStorages->psPersistInfo->lpVtbl->OpenStream(psStorages->psPersistInfo,
					    L"BeenViewed",
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
	// If succeeded, then definately found.
    if(SUCCEEDED(hStatus)) return TRUE;
	// If not found, then definately hasn't been viewed.
    if(hStatus == STG_E_FILENOTFOUND) return FALSE;
    fprintf(stderr, "AWDViewed:Unexpected status %x.\n", hStatus);
	// Assume that we've been viewed.
    return TRUE;
}

// DumpAWDDocuments
//
// This function prints out the name of the fax documents contained in the
// file in their display order.  Output is to stdout.
//
// New AWD files have a "Display Order" stream in the psGlobalInfo that defines
// all of the documents.  Old AWD files need to enumerate through the
// "Documents" substorage.  
//
// Parameters:
//	psStorages		Pointer to the storages of an AWD file.
//
// Returns:
//	Nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-27
void
DumpAWDDocuments(AWD_FILE *psStorages)
{
    printf("Document list:\n");
    printf("-------- -----\n");
    EnumDocuments(psStorages, DisplayDocNames);

}

// EnumDocuments
//
// This function enumerates through all of the things in the "Documents"
// substorage and prints their names.  It's a helper routine to DumpAWDDocuments().
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pfnDocProc			Pointer to function that should be called
//					with the names of the documents in the
//					AWD file.
//
// Returns:
//	TRUE if all iterations succeeded, FALSE otherwise.
//
// Author:
// 	Brian Dewey (t-briand)  1997-6-30
BOOL
EnumDocuments(AWD_FILE *psStorages, AWD_DOC_PROCESSOR pfnDocProc)
{
    IEnumSTATSTG *psEnum;
    STATSTG      sData;
    WCHAR        awcNameBuf[MAX_AWD_NAME]; // 32 == longest possible name.
    UINT         uiNameOffset;
    IStream      *psDisplayOrder;	   // Points to the display order stream.
    char         chData;		   // A single byte of data.
    ULONG        cbRead;		   // Count of bytes read.

    //[RB]assert(psGlobalInfo != NULL);   // Sanity check.
    psDisplayOrder = OpenAWDStream(psStorages->psGlobalInfo, L"Display Order");
    if(psDisplayOrder == NULL) {
	fprintf(stderr, "There is no 'Display Order' stream.  This is an old AWD file.\n");
	if(FAILED(psStorages->psDocuments->lpVtbl->EnumElements(psStorages->psDocuments,
								0,
								NULL,
								0,
								&psEnum))) {
	    return FALSE;
	}
	sData.pwcsName = awcNameBuf;
	
	while(psEnum->lpVtbl->Next(psEnum, 1, &sData, NULL) == S_OK) {
		// We succeeded!
	    if(!(*pfnDocProc)(psStorages, sData.pwcsName))
		return FALSE;	// The enumeration has been aborted.
	}
	psEnum->lpVtbl->Release(psEnum);
	return TRUE;
    }

	// The display order list is a stream of document names.  Each
	// name is null-terminated, and a second null ends the stream.
	// The document names are ANSI characters.
	//
	// The easy way to read this, which is what I do, is to read
	// the stream a byte at a time.  For efficiency, this should be
	// changed to reading larger blocks.

	// Prime the loop by reading the first character.
    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    while(chData) {		    // Until I've read a null...
	    // This inner loop prints out a single string.
	uiNameOffset = 0;
	while(chData) {
	    awcNameBuf[uiNameOffset++] = chData;
	    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
	};
	awcNameBuf[uiNameOffset] = 0;
	    // We've now read & printed a whole string.  Call the enumerator.
	if(!(*pfnDocProc)(psStorages, awcNameBuf)) {
	    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
	    return FALSE;	// The enumeration has been aborted.
	}
	    // And re-prime the engine.
	psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    }

    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
    return TRUE;
}

// DisplayDocNames
//
// This is a simple little routine that prints out the names of all of the
// documents in an AWD file.  Used in conjunction w/ EnumDocuments.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DisplayDocNames(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    wprintf(L"Document '%s'.\n", pwcsDocName);
    return TRUE;
}

// DetailedDocDump
//
// This function displays lots of information about a particular document.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE on success; FALSE on error.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DetailedDocDump(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    IStream *psDocInfoStream;		    // Stream containing doc information.
    DOCUMENT_INFORMATION sDocInfo;	    // Document information.
    ULONG cbRead;			    // Count of bytes read.
    
    wprintf(L"Information for document '%s' --\n", pwcsDocName);
    psDocInfoStream = OpenAWDStream(psStorages->psDocInfo,
				    pwcsDocName);
    if(psDocInfoStream == NULL) {
	fprintf(stderr, "DetailedDocDump:No document info stream.\n");
	    // This is not a fatal error, so don't exit.
    } else {
	psDocInfoStream->lpVtbl->Read(psDocInfoStream,
				      &sDocInfo,
				      sizeof(sDocInfo),
				      &cbRead);
	if(sizeof(sDocInfo) != cbRead) {
	    fwprintf(stderr, L"DetailedDocDump:Error reading document information "
		     L"for %s.\n", pwcsDocName);
	} else {
	    printf("\tDocument signature = %x.\n", sDocInfo.Signature);
	    printf("\tDocument version = %x.\n", sDocInfo.Version);
	}
    }
    PrintPageInfo(&sDocInfo.PageInformation);
    return TRUE;
}

// PrintPageInfo
//
// This function displays the fields of a PAGE_INFORMATION structure to standard
// output.
//
// Parameters:
//	psPageInfo			The PAGE_INFORMATION structure to display.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30

void
PrintPageInfo(PAGE_INFORMATION *psPageInfo)
{
    printf("\tStructure signature = %x\n", psPageInfo->Signature);
    printf("\tStructure version   = %x\n", psPageInfo->Version);

    if(psPageInfo->awdFlags & AWD_FIT_WIDTH)
	printf("\tAWD_FIT_WIDTH flag is set.\n");
    if(psPageInfo->awdFlags & AWD_FIT_HEIGHT)
	printf("\tAWD_FIT_HEIGHT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_INVERT)
	printf("\tAWD_INVERT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_IGNORE)
	printf("\tAWD_IGNORE flag is set.\n");

    printf("\tRotation = %d degrees counterclockwise.\n", psPageInfo->Rotation);
    printf("\tScaleX = %d.\n", psPageInfo->ScaleX);
    printf("\tScaleY = %d.\n", psPageInfo->ScaleY);
}

// DumpData
//
// A simple utility function that will write the specified data to a file
// for post-mortem examining.
//
// Parameters
//	pszFileName		Name of the output file.
//	pbData			Pointer to the data.
//	cbCount			Number of bytes to write.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-7
void
DumpData(LPTSTR pszFileName, LPBYTE pbData, DWORD cbCount)
{
    HANDLE hFile;
    DWORD  cbWritten;

    hFile = CreateFile(
	pszFileName,		// Open this file...
	GENERIC_WRITE,		// We want to write.
	0,			// Don't share.
	NULL,			// No need to inherit.
	CREATE_ALWAYS,		// Always create a new file.
	FILE_ATTRIBUTE_COMPRESSED, // Save disk space... might want to change this later.
	NULL);			// No template file.
    if(hFile != INVALID_HANDLE_VALUE) {
	WriteFile(hFile,
		  pbData,
		  cbCount,
		  &cbWritten,
		  NULL);
	CloseHandle(hFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdlib\awd_tiff.c ===
/*++
  Copyright (c) 1997  Microsoft Corporation

  This file contains the parts of the AWD library that are also TIFF-aware
  (i.e., conversion routines).

  Author:
  Brian Dewey (t-briand)  1997-7-16
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include "awdlib.h"		// Header file for this library.
#include "viewrend.h"		// AWD rendering library.
#include "tifflibp.h"		// Need this for the stolen compression routines.

// ------------------------------------------------------------
// Defines
#define FAX_IMAGE_WIDTH		(1728)

// ------------------------------------------------------------
// Global variables
HANDLE hTiffDest;		// Used in the internal OutputPage()
				// and ConvertAWDToTiff().

// ------------------------------------------------------------
// Internal prototypes
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    );				// Routine stolen from tiff library.
				// Used to be EncodeMmrBranding().

void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight);

BOOL OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName);

// ------------------------------------------------------------
// Routines

// ConvertAWDToTiff
//
// This function does exactly what it says.  Given the name of an AWD file, it
// attempts to convert it to a tiff file.
//
// Parameters:
//	pwcsAwdFile		name of the AWD file.
//	pwcsTiffFile		name of the TIFF file.
//
// Returns:
//	TRUE on successful conversion, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-14
BOOL
ConvertAWDToTiff(const WCHAR *pwcsAwdFile, WCHAR *pwcsTiffFile)
{
    BOOL bRetVal;		// Holds our return value.
    AWD_FILE sAWDStorages;	// Holds the main storages of the AWD file.
    
	// Initialization.
    HeapInitialize(NULL, NULL, NULL, 0);

	// Open the source.
    if(!OpenAWDFile(pwcsAwdFile, &sAWDStorages)) {
	return FALSE;		
    }

	// Open the destination
    hTiffDest = TiffCreate(pwcsTiffFile,
			   TIFF_COMPRESSION_MMR,
			   FAX_IMAGE_WIDTH,
			   2,	// Fill order 2 == LSB2MSB (I think).
			   1);	// HIRES
    if(hTiffDest == NULL) {
	CloseAWDFile(&sAWDStorages);
	return FALSE;
    }
    bRetVal = EnumDocuments(&sAWDStorages, OutputPage);
    CloseAWDFile(&sAWDStorages);
    TiffClose(hTiffDest);
    return bRetVal;
}

// CompressBitmapStrip
//
// Stolen from Tiff library, where it's called EncodeMmrBranding().
//
// Author: ???
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    )

/*++

Routine Description:

   Encode an MMR branding from uncompressed branding bits.
   I don't have enough time to write an optimized
   Uncompressed -> MMR convertor, so the compromise is
   to use the existing Uncompressed Decoder (fast enough)
   and use the optimized MMR Encoder.
   Since we only convert few lines for Branding, it's OK.

--*/

{
    INT         a0, a1, a2, b1, b2, distance;
    LPBYTE      prefline;
    BYTE        pZeroline[1728/8];
    INT         delta = BrandWidth / BYTEBITS;
    INT         Lines = 0;
    LPDWORD     lpdwOut = pMmrBrandBits;
    BYTE        BitOut = 0;



#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif


    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory(pZeroline, BrandWidth/8);

    // loop til all lines done

    do {

        a0 = 0;
        a1 = GetBit( pBrandBits, 0) ? 0 : NextChangingElement(pBrandBits, 0, BrandWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, BrandWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= BrandWidth) ? BrandWidth :
                    NextChangingElement( prefline, b1, BrandWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
                (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
                }


#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                // OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
                (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
                if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
                }

#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= BrandWidth) ? BrandWidth :
                        NextChangingElement( pBrandBits, a1, BrandWidth, GetBit( pBrandBits, a1 ) );

                // OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
                (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
                }



#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( pBrandBits, a0 )) {

                    //OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    //OutputRun( TiffInstance, a2-a1, WhiteRunCodes );
                    OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);

                } else {

                    //OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    //OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                    OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);

                }

                a0 = a2;
            }

            if (a0 >= BrandWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( pBrandBits, a0, BrandWidth, GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, a0, BrandWidth, !GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, b1, BrandWidth, GetBit( pBrandBits, a0 ) );
        }

        prefline = pBrandBits;
        pBrandBits += (BrandWidth / 8);

    } while (Lines < BrandHeight);

    *DwordsOut = (DWORD)(lpdwOut - pMmrBrandBits);
    *BitsOut  = BitOut;

    return TRUE;
}

// ConvertWidth
//
// Changes the width of a bitmap.  If the desired width is smaller than the current
// width, this is accomplished by truncating lines.  If the desired width is greater
// than the current width, data will be copied up from the next line.
//
// Parameters:
//	lpSrc			Bitmap source.
//	dwSrcWidth		Its width.
//	lpDest			Pointer to destination.
//	dwDestWidth		Desired width of destination
//	dwHeight		Height of image (won't change).
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-10
void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight)
{
    LPBYTE lpSrcCur, lpDestCur;
    DWORD  dwCurLine;

    for(lpSrcCur = lpSrc, lpDestCur = lpDest, dwCurLine = 0;
	dwCurLine < dwHeight;
	lpSrcCur += dwSrcWidth, lpDestCur += dwDestWidth, dwCurLine++) {
	memcpy(lpDestCur, lpSrcCur, dwDestWidth);
    }
}

// OutputPage
//
// This is the core of the converter; it takes a single AWD page and writes it
// to the TIFF file.
//
// Parameters:
//	psStorages		Pointer to the AWD file from which we read.
//	pwcsDocName		Name of the page.
//
// Returns:
//	TRUE on success, FALSE on failure.
//
// Author:
//	Brian Dewey (t-briand)  1997-7-2
BOOL
OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    BITMAP bmBand;		// A band of image data.
    LPBYTE lpOutBuf;		// Output bitmap (resized).
    LPBYTE lpOutCur;		// Used to write one line at a time.
    LPDWORD lpdwOutCompressed;	// Compressed output.
    DWORD dwDwordsOut,		// Number of DWORDS in compressed output...
	dwBitsOut = 0;		// Number of bits in compressed output.
    DWORD dwBitsOutOld = 0;	// BitsOut from the *previous* band compression.
    LPVOID lpViewerContext;	// The viewer context; used by viewrend library.
    VIEWINFO sViewInfo;		// Information about the image.
    WORD awResolution[2],	// Holds X & Y resolutions
	wBandSize = 256;	// Desired band size; will be reset by ViewerOpen.
    IStream *psDocument;	// Our document stream.
    BOOL bRet = FALSE;		// Return value; FALSE by default.
    UINT iCurPage;		// Current page.
    const DWORD dwMagicHeight = 3000; // FIXBKD

    if((psDocument = OpenAWDStream(psStorages->psDocuments, pwcsDocName)) == NULL) {
	fwprintf(stderr, L"OutputPage:Unable to open stream '%s'.\n",
		pwcsDocName);
	return FALSE;		// We failed.
    }
	// Now, open a viewer context and start reading bands of the image.
    if((lpViewerContext = ViewerOpen(psDocument,
				     HRAW_DATA,
				     awResolution,
				     &wBandSize,
				     &sViewInfo)) == NULL) {
	fprintf(stderr, "OutputPage:Unable to open viewer context.\n");
	return FALSE;
    }

    iCurPage = 0;		// Initialize our counter.

    bmBand.bmBits = malloc(wBandSize);	// Allocate memory to hold the band.
    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
	fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
	return FALSE;
    }
	// lpOutBuf = malloc(bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
    lpOutBuf = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	// Provided compression actually *compresses*, we should have more than
	// enough memory allocated.
    lpdwOutCompressed = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));

    if(!lpOutBuf || !lpdwOutCompressed) {
		// check whether we are short in memory
		TiffEndPage(hTiffDest);
		if(lpOutBuf) free(lpOutBuf);
		if(lpdwOutCompressed) free(lpdwOutCompressed);
		return FALSE;		// This will stop the conversion process.
    }

	memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
    memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));


	// Main loop
    while(iCurPage < sViewInfo.cPage) {
	lpOutCur = lpOutBuf;
	while(bmBand.bmHeight) {
		// Make sure our bitmap has FAX_IMAGE_WIDTH as its width.
	    ConvertWidth(bmBand.bmBits, bmBand.bmWidth / 8,
			 lpOutCur, FAX_IMAGE_WIDTH / 8,
			 bmBand.bmHeight);
	    lpOutCur += (bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
	    
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	} // while (wasn't that easy?)

	memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	CompressBitmapStrip(lpOutBuf,
			    lpdwOutCompressed,
			    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8)),
			    FAX_IMAGE_WIDTH,
			    &dwDwordsOut,
			    &dwBitsOut);
	memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	fprintf(stderr, "OutputPage:Compressed image to %d dwords, %d bits.\n",
		dwDwordsOut, dwBitsOut);
			
	if(!TiffStartPage(hTiffDest)) {
	    fprintf(stderr, "OutputPage:Unable to open output page.\n");
	    return FALSE;	// We can't begin a page for some reason.
	    if(lpOutBuf) free(lpOutBuf);
	    if(lpdwOutCompressed) free(lpdwOutCompressed);
	}
	TiffWriteRaw(hTiffDest, (LPBYTE)lpdwOutCompressed,
		     (dwDwordsOut + 1) * sizeof(DWORD));
	((PTIFF_INSTANCE_DATA)hTiffDest)->Lines =
	    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8));
	if(sViewInfo.yRes <= 100)
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 98;
	else
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 196;
	TiffEndPage(hTiffDest);

	    // Now, move to a new page of the data.
	iCurPage++;
	if(iCurPage < sViewInfo.cPage) {
	    ViewerSetPage(lpViewerContext, iCurPage);
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	}
    }

	// Free memory.
    bRet = TRUE;
  output_exit:
    free(lpdwOutCompressed);
    free(lpOutBuf);
    free(bmBand.bmBits);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\constant.h ===
// constants defined
// History: 9/28/93 mslin
//             RES_DIR_SIZE changed to 2048 for Acorn printer
//          10/22/93  mslin         
//             change expand brush to only 16 lines instead 
//             of 32 for saving memory because currently the 
//             repeat pattern is 16x16
//             BYTESPERSACNLINE enlarge to 616 for 600 dpi.
//
#define SUCCESS   1
#define FAILURE   0
#define EXTERN
#define PRIVATE

#ifdef DEBUG
#define  MAXBAND  24   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\ddbitblt.c ===
/*==============================================================================
These routines are wrappers for the display driver BitBlt interface.

05-30-93     RajeevD     Created.
02-15-94     RajeevD     Integrated into unified resource executor.
==============================================================================*/

#include <windows.h>
#include <windowsx.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"
#include "hreext.h"

#include "ddbitblt.h"

USHORT usBrushWidth; // just a dummy

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{ 
	LPDD_BITMAP lpbmPat;
	LPBITMAP lpbmBand;
 
	// Initialize source.
	lpRE->bmSrc.bmPlanes = 1;
	lpRE->bmSrc.bmBitsPixel = 1;
	
	// Initialize destination.
	lpbmBand = lpRE->lpBandBuffer;
	lpRE->bmDst.bmPlanes = 1;
	lpRE->bmDst.bmBitsPixel = 1;
	lpRE->bmDst.bmWidth = lpbmBand->bmWidth;
	lpRE->bmDst.bmHeight = lpbmBand->bmHeight;
	lpRE->bmDst.bmWidthBytes = lpbmBand->bmWidthBytes;
	lpRE->bmDst.bmWidthPlanes = lpRE->bmDst.bmWidthBytes * lpRE->bmDst.bmHeight;
	lpRE->bmDst.bmBits = lpbmBand->bmBits;

	// Initialize DRAWMODE.
	ddColorInfo (&lpRE->bmDst, 0xFFFFFF, &lpRE->DrawMode.dwbgColor);
	ddColorInfo (&lpRE->bmDst, 0x000000, &lpRE->DrawMode.dwfgColor);
	lpRE->DrawMode.bkMode = 1; // transparent
	
	// Initialize LOGBRUSH.
	lpRE->lb.lbStyle = BS_PATTERN;
	lpRE->lb.lbHatch = GlobalAlloc (GMEM_ZEROINIT, sizeof(DD_BITMAP));
	if (!lpRE->lb.lbHatch)
		return FALSE;
	lpbmPat = (LPDD_BITMAP) GlobalLock (lpRE->lb.lbHatch);

  // Set brush origin.
  lpRE->wPoint[0] = 0;
  lpRE->wPoint[1] = yBrush;
  
	// Initialize pattern bitmap.
	lpbmPat->bmPlanes = 1;
	lpbmPat->bmBitsPixel = 1;
	lpbmPat->bmWidth = 32;
	lpbmPat->bmHeight = 32;
	lpbmPat->bmWidthBytes = 4;
	lpbmPat->bmWidthPlanes = 128;
	lpbmPat->bmBits = lpRE->TiledPat;
	GlobalUnlock (lpRE->lb.lbHatch);

  // Set physical brush.
	lpRE->lpBrush = NULL;

	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{
	GlobalFree (lpRE->lb.lbHatch);
	if (lpRE->lpBrush)
		GlobalFreePtr (lpRE->lpBrush);
}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
 	LPDD_BITMAP lpbmPat = (LPDD_BITMAP) GlobalLock (lpRE->lb.lbHatch);
	UINT cbBrush;
	
  // Delete previous brush, if any.
	if (lpRE->lpBrush)
	{
		ddRealize (&lpRE->bmDst, -OBJ_BRUSH, &lpRE->lb, lpRE->lpBrush, lpRE->wPoint);
		GlobalFreePtr (lpRE->lpBrush);
	}

	// Realize new physical brush.
	lpbmPat->bmBits = lpRE->lpCurBrush;
	cbBrush = ddRealize (&lpRE->bmDst, OBJ_BRUSH, &lpRE->lb, NULL, lpRE->wPoint);
	lpRE->lpBrush = GlobalAllocPtr (GMEM_FIXED, cbBrush);
	ddRealize (&lpRE->bmDst, OBJ_BRUSH, &lpRE->lb, lpRE->lpBrush, lpRE->wPoint);

	GlobalUnlock (lpRE->lb.lbHatch);
	return TRUE;
}

//==============================================================================
// Clipping to top and bottom of band is performed, but
// ideally should be handled by caller as needed.

DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,   // Left padding
	short   yDst,	  // Top row of destination.
	short   xDst,	  // Left column of destination.
	WORD    clLine, // Longs per scan line
	WORD    yExt,   // Height in pixels
	WORD    xExt,   // Width in pixels 
	LPDWORD lpSrc,  // Far pointer to source
	LPDWORD lpPat,  // Far pointer to pattern
	DWORD   dwRop		// Raster operation
)
{
	LPBITMAP lpbmBand;
	WORD ySrc;
			
	// Record parameters.
	lpRE->bmSrc.bmWidth = xExt + xSrc;
	lpRE->bmSrc.bmHeight = yExt;
	lpRE->bmSrc.bmWidthBytes = 4 * clLine;
	lpRE->bmSrc.bmWidthPlanes = lpRE->bmSrc.bmWidthBytes * lpRE->bmSrc.bmHeight;
	lpRE->bmSrc.bmBits = lpSrc;
	
	// Clip to top of band.
	if (yDst >= 0)
		ySrc = 0;
	else
	{
		ySrc = -yDst;
		yExt -= ySrc;
		yDst = 0;
	}

	// Clip to bottom of band.
	lpbmBand = lpRE->lpBandBuffer;
	if (yExt > (WORD) lpbmBand->bmHeight - yDst)
		yExt = lpbmBand->bmHeight - yDst;

	ddBitBlt
	(
		&lpRE->bmDst, xDst, yDst, &lpRE->bmSrc, xSrc, ySrc,
		xExt, yExt, lpRE->dwRop, lpRE->lpBrush, &lpRE->DrawMode
	);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\ddbitblt.h ===
/*==============================================================================
Structures and prototypes for display driver interface.

09-Jun-93     RajeevD     Created.
==============================================================================*/
#ifndef _INC_DDBITBLT
#define _INC_DDBITBLT

// Logical Brush 
typedef struct
{
	WORD lbStyle;
  WORD lbColor; 
  WORD lbHatch;
  WORD lbBkColor;
}
	DD_BRUSH;

// Physical Bitmap
typedef struct
{ 
	WORD   bmType;
  WORD   bmWidth;
  WORD   bmHeight;
  WORD   bmWidthBytes;
  BYTE   bmPlanes;
  BYTE   bmBitsPixel;
  LPVOID bmBits;
  DWORD  bmWidthPlanes;
  LPVOID bmlpPDevice;
  WORD   bmSegmentIndex;
  WORD   bmScanSegment;
	WORD bmFillBytes;
}
	DD_BITMAP, FAR* LPDD_BITMAP;

// Draw Mode
typedef struct
{
	short Rop2;
	short bkMode;
	DWORD dwbgColor;
	DWORD dwfgColor;
}
	DD_DRAWMODE;

// API Prototypes
BOOL FAR PASCAL ddBitBlt
	(LPVOID, WORD, WORD, LPVOID, WORD, WORD,
	WORD, WORD, DWORD, LPVOID, LPVOID);

BOOL FAR PASCAL ddRealize
	(LPVOID, short, LPVOID, LPVOID, LPVOID);

DWORD FAR PASCAL ddColorInfo
  (LPVOID, DWORD, LPDWORD);

#endif // _INC_DDBITBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\context.hpp ===
/*==============================================================================
This include file defines C++ objects for each type of instance.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>

#ifdef DEBUG
extern DBGPARAM dpCurSettings;
#endif

//==============================================================================
typedef struct T4STATE   // keep in sync with t4core.asm!
{
	LPBYTE lpbIn;          // read-only input buffer 
	LPBYTE lpbOut;         // output buffer
	WORD wOffset;					 // segment offset of change vector buffer (for consumers)
	WORD cbIn;             // input data size
	WORD cbOut;            // output buffer size
	WORD cbLine;           // width of line in bytes
	WORD wColumn;          // current position in bits
	WORD wColor;           // current color
	WORD wWord;            // current word
	WORD wBit;             // bit modulus
	WORD cbSlack;
	LPBYTE lpbRef;         // read-only reference change vector
	LPBYTE lpbBegRef;      // for client
	WORD wRet;             // return status
	WORD wToggle;
	WORD iKFactor;         // K counter
	WORD wMode;            // for MR
	short a0;	             // for MMR
	DWORD nType;           // type of data being produced/consumed
}
	FAR* LPT4STATE;

// Values for wRet
#define RET_INPUT_EMPTY1   1
#define RET_INPUT_EMPTY2   2
#define RET_OUTPUT_FULL    3
#define RET_END_OF_LINE    4
#define RET_SPURIOUS_EOL   5
#define RET_BEG_OF_PAGE    6
#define RET_END_OF_PAGE		10
#define RET_DECODE_ERR   253

#ifdef __cplusplus
extern "C" { 
#endif

	// ASM methods
	void ChangeToRaw (LPT4STATE);
	void RawToChange (LPT4STATE);
	void ChangeToMH  (LPT4STATE);
	void MHToChange  (LPT4STATE);
	void ChangeToMR  (LPT4STATE);
	void MRToChange  (LPT4STATE);
	void ChangeToMMR (LPT4STATE);
	void MMRToChange (LPT4STATE);

#ifdef __cplusplus
} // extern "C"
#endif

//==============================================================================

#ifdef __cplusplus

typedef class FAR CODEC : FC_PARAM
{
	LPBYTE lpbLine;
	UINT xExt;
	UINT cSpurious;
	LPBYTE lpbChange;
	LPBYTE lpbRef;
	BOOL f2D;
	T4STATE t4C, t4P;
	void (*Consumer)(LPT4STATE);
	void (*Producer)(LPT4STATE);
	WORD wBad;

public:
	FC_COUNT fcCount;

	void Init (LPFC_PARAM, BOOL f2DInit);
	FC_STATUS Convert (LPBUFFER, LPBUFFER);

private:
	void SwapChange (void);
	void ResetBad (void);
	void EndLine (void);
	void StartPage (void);
	void EndPage (LPBUFFER lpbufOut);
	FC_STATUS ConvertToT4  (LPBUFFER lpbufIn, LPBUFFER lpbufOut);
	FC_STATUS ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut);

}
	FAR *LPCODEC;

#endif // C++
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\convert.cpp ===
/*==============================================================================
This code module handles T4 conversion instances.

DATE        NAME       COMMENTS
12-Apr-93   RajeevD    Adapted to C++ from WFW.
20-Apr-93   RajeevD    Overhauled buffer handling.
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <faxcodec.h>
#include "context.hpp"

#define RTC_EOL 5

#define VALIDATE_CHANGE

typedef short FAR *LPSHORT;

//==============================================================================
#pragma warning(disable:4704)

#ifdef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	SHORT sPrev = -1;

	SHORT cChange = xExt;

	while (cChange--)
	{
		// Check monotonicity.
		if (*lpsChange <= sPrev)
			return 0;
		sPrev = *lpsChange++;

		if (sPrev == xExt)
		{
			// Check EOL termination.
			if
			(   *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == -1
			 && *lpsChange++ == -1
		  )
			return sizeof(WORD) * (xExt - cChange) ;
		else
			return 0;
		}
		
	} // while (cChange--)

	return 0; // Hit end of change vector buffer.
}

#else // ifndef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	UINT uRet;

	_asm
	{
		push	ds
		push	si

		lds		si, DWORD PTR [lpsChange]	; lpsChange
		mov		dx, -1						; sPrev
		mov		cx, xExt					; cChange
		mov		bx, cx						; xExt
		jmp		enterloop

	fooie:
		lodsw
		cmp		ax, dx
		jle		error		; need SIGNED compare
		mov		dx, ax
		cmp		dx, bx
		je		goteol
	enterloop:
		loop	fooie
	error:
		xor		ax, ax
		jmp		done

	goteol:
		lodsw
		cmp		ax, bx		; bx == xExt
		jne		error
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

		xor		bx, bx
		not		bx			; bx == -1
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

    // uRet = sizeof(WORD) * (xExt - cChange) ;
		mov   ax, xExt
		sub   ax, cx
		inc   ax
		shl   ax, 1
    
	done:
		pop		si
		pop		ds
		mov		uRet, ax
	}
	return uRet;
}

#endif // WIN32

//==============================================================================
void CODEC::ResetBad (void)
{
	DEBUGMSG (1,("FAXCODEC: decoded %d bad line(s)\r\n", wBad));
	if (fcCount.cMaxRunBad < wBad)
		fcCount.cMaxRunBad = wBad;
	wBad = 0;
}

//==============================================================================
void CODEC::SwapChange (void)
{
	LPBYTE lpbTemp;
	lpbTemp = lpbChange;
	lpbChange = lpbRef;
	lpbRef = lpbTemp;
}

//==============================================================================
void CODEC::EndLine (void)
{
	if (f2D)
	{
		// Reset consumer and producer.
		t4C.lpbRef =    lpbRef;
		t4C.lpbBegRef = lpbRef;
		t4P.lpbRef =    lpbRef;
		t4P.lpbBegRef = lpbRef;

		// Increment K Factor
		t4P.iKFactor++;
		if (t4P.iKFactor == nKFactor)
			t4P.iKFactor = 0;
	}

	// Clear change vector buffer (debug only).
	DEBUGSTMT (_fmemset (lpbChange, 0xCD, sizeof(WORD) * xExt + CHANGE_SLACK));

	// Reset consumer.
	t4C.wColumn = 0;
	t4C.wColor = 0;
	t4C.lpbOut = lpbChange;
	t4C.wOffset = LOWORD(lpbChange);
	t4C.wToggle = 0;

	// Reset producer.	
	t4P.wColumn = 0;
	t4P.wColor = 0;
	t4P.lpbIn = lpbChange;
}

//==============================================================================
void CODEC::StartPage (void)
{
	if (wBad) ResetBad();
	cSpurious = 0;
	EndLine ();

	// Reset consumer.
	t4C.wWord = 0;
	t4C.wBit = 0;
	t4C.wRet = RET_BEG_OF_PAGE;

	// Reset producer.
	t4P.wWord = 0;
	t4P.wBit = 0;
	t4P.wRet = RET_BEG_OF_PAGE;

	// Blank buffered output line.
	_fmemset (lpbLine, 0, cbLine);

	if (f2D)
	{
		// Blank reference vector.
		LPWORD lpwRef = (LPWORD) lpbRef;

		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = 0xFFFF;
		*lpwRef++ = 0xFFFF;

		t4C.wMode = 0;
		t4P.wMode = 0;
		t4P.iKFactor = 0;
	}
}

//==============================================================================
void CODEC::EndPage (LPBUFFER lpbufOut)
{
	// Flush last byte and end-of-block code.
	switch (nTypeOut)
	{
		case LRAW_DATA:
		case NULL_DATA:
			return;
			
		case MH_DATA:
		case MR_DATA:
#ifndef WIN32
			return;
#endif		
		case MMR_DATA:
		{
			LPBYTE lpbBeg = lpbufOut->EndData();
    	t4P.lpbOut = lpbBeg;
    	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);
    	t4P.wRet = RET_END_OF_PAGE;
    	Producer (&t4P);
    	lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBeg);
    	return;
		}
		
    default: DEBUGCHK (FALSE);
	}
}

/*==============================================================================
This method initializes a CODEC context.
==============================================================================*/
void CODEC::Init (LPFC_PARAM lpParam, BOOL f2DInit)
{
		DEBUGMSG (1, ("FAXCODEC: nTypeIn  = %lx\n\r", lpParam->nTypeIn));
		DEBUGMSG (1, ("FAXCODEC: nTypeOut = %lx\n\r", lpParam->nTypeOut));
		DEBUGMSG (1, ("FAXCODEC: cbLine   = %d\n\r", lpParam->cbLine));
		DEBUGMSG (1, ("FAXCODEC: nKFactor = %d\n\r", lpParam->nKFactor));
	
		// Initialize constants.
		_fmemcpy (this, lpParam, sizeof(FC_PARAM));
		xExt = 8 * cbLine;
		f2D = f2DInit;

		switch (nTypeIn)        // Determine the consumer.
		{
			case LRAW_DATA:   Consumer = RawToChange;	break;
			case MH_DATA:			Consumer = MHToChange;	break;
    	case MR_DATA:			Consumer = MRToChange;  break;
			case MMR_DATA:		Consumer = MMRToChange;	break;
			default:					DEBUGCHK (FALSE);
		}
		
		switch (nTypeOut)       // Determine the producer.
		{
			case NULL_DATA:   Producer = NULL;         break;		
			case LRAW_DATA:   Producer = ChangeToRaw;  break;
		  case MH_DATA:     Producer = ChangeToMH;   break;
		  case MR_DATA:     Producer = ChangeToMR;   break;
		  case MMR_DATA:    Producer = ChangeToMMR;  break;
			default:          DEBUGCHK (FALSE);
		}

	 	// Initialize memory buffers.
		lpbLine = (LPBYTE) (this + 1);
		lpbChange = lpbLine + cbLine + RAWBUF_SLACK;
		lpbRef = lpbChange;
		if (f2D)
			lpbRef += xExt * sizeof(USHORT) + CHANGE_SLACK;
 
		// Initialize consumer state.
		t4C.cbSlack = CHANGE_SLACK;
		t4C.cbLine  = (WORD)cbLine;
		t4C.nType   = nTypeIn;
		
		// Initialize producer state.
		t4P.cbSlack = OUTBUF_SLACK;
		t4P.cbLine  = (WORD)cbLine;
		t4P.nType   = nTypeOut;
		
		// Initialize error counts.
		_fmemset (&fcCount, 0, sizeof(fcCount));
		wBad = 0;
		
		// Reset for beginning of page.
		StartPage();
}

/*==============================================================================
This method executes a CODEC conversion.
==============================================================================*/
FC_STATUS CODEC::Convert (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	FC_STATUS ret;

	// A null input buffer is flag for end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
	{
	  DEBUGMSG (1,("FAXCODEC: got EOP\r\n"));
		EndPage (lpbufOut);
		StartPage ();
		return FC_INPUT_EMPTY;
	}

  // Ignore input after RTC but before end of page.
	if (cSpurious == RTC_EOL)
	{
	  DEBUGMSG (1,("FAXCODEC: ignoring input after RTC or EOFB\r\n"));
		return FC_INPUT_EMPTY;
  }
  
#ifndef WIN32

	if (t4C.wRet == RET_BEG_OF_PAGE)
	{
		if (nTypeOut == MH_DATA || nTypeOut == MR_DATA)
		{
		  // Start page with EOL.
			if (lpbufOut->EndBuf() - lpbufOut->EndData() < OUTBUF_SLACK)
				return FC_OUTPUT_FULL;
			*((LPWORD) lpbufOut->EndData()) = 0x8000;
			lpbufOut->wLengthData += 2;
		}
	}
	
#endif // WIN32
		
	// Initialize input buffer of consumer.
	t4C.lpbIn = lpbufIn->lpbBegData;
	t4C.cbIn = lpbufIn->wLengthData;

	// Dispatch to 2 or 3 phase conversion.
	if (nTypeOut == LRAW_DATA || nTypeOut == NULL_DATA)
		ret = ConvertToRaw (lpbufIn, lpbufOut);
	else
		ret = ConvertToT4 (lpbufIn, lpbufOut);

	// Adjust input buffer header.
	lpbufIn->lpbBegData = t4C.lpbIn;
	lpbufIn->wLengthData = t4C.cbIn;

	return ret;
}

//==============================================================================
FC_STATUS CODEC::ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbOut = lpbufOut->EndData();
	UINT cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
		goto copy_phase;

	while (1)
	{
		Consumer (&t4C); // generate change vector

		switch (t4C.wRet)
		{		
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (USHORT)ValidChangeVector ((LPSHORT) lpbChange, (SHORT)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

    // Handle decode errors.
		if (t4C.wRet == RET_DECODE_ERR)
		{
			if (nTypeIn == MMR_DATA)
	 			return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      _fmemset (lpbLine, 0xFF, cbLine); // emit black line
#endif

			if (f2D)
			{
			  // Replicate change vector.
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);
			  DEBUGCHK (t4P.cbIn);
			  _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
			}
		
		  if (nTypeOut == NULL_DATA)
				goto EOL;

			if (!f2D)
				goto copy_phase;
    }

    // Optimize validation.
		if (nTypeOut == NULL_DATA)
			goto EOL;

	  // Run the producer.
		t4P.lpbOut = lpbLine;
		t4P.cbOut = (WORD)cbLine;
		ChangeToRaw (&t4P);

copy_phase:

		if (cbOut < cbLine)
		{
			t4P.wRet = RET_OUTPUT_FULL;
			return FC_OUTPUT_FULL;
		}

		// Append buffered line to output.
		t4P.wRet = RET_END_OF_LINE;
		_fmemcpy (lpbOut, lpbLine, cbLine);
		lpbufOut->wLengthData += (WORD)cbLine;
		lpbOut += cbLine;
		cbOut -= cbLine;

EOL:
		SwapChange ();
		EndLine ();

	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE);
	return FC_DECODE_ERR;
}

//==============================================================================
FC_STATUS CODEC::ConvertToT4 (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbBegOut;
	
	t4P.lpbOut = lpbufOut->EndData();
	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
  	goto producer_phase;

	while (1)  // Loop until input is empty or output is full.
	{
		Consumer (&t4C);

		switch (t4C.wRet)
		{
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbChange, (WORD)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

		if (t4C.wRet == RET_DECODE_ERR)
		{
			DEBUGCHK (f2D && nTypeIn != LRAW_DATA);
			if (nTypeIn == MMR_DATA)
				return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      {
      	// Substitute all black line.
	     	LPWORD lpwChange = (LPWORD) lpbChange;
			  *lpwChange++ = 0;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = 0xFFFF;
			  *lpwChange++ = 0xFFFF;
			  t4P.cbIn = 4;
			 }
#else
	    // Replicate previous line
	    t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);   
	   	DEBUGCHK (t4P.cbIn);
	    _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
#endif

		}

producer_phase:

    lpbBegOut = t4P.lpbOut;
		Producer (&t4P);
		lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBegOut);

		// Check if output is full.
		if (t4P.wRet == RET_OUTPUT_FULL)
			return FC_OUTPUT_FULL;

// EOL:
		SwapChange();
		EndLine ();
		
	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE); 
	return FC_DECODE_ERR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdvstub\awdvstub.c ===
/*++
  awdvstub.c

  Copyright (c) 1997  Microsoft Corporation


  This program is a stub AWD viewer... it will first convert an awd file named
  on the command line to a tiff file in the temp directory, then it will launch
  the tiff viewer on that file.

  Also, when used with the '/c' switch, it's an AWD converter.  Two programs in one!

  Author:
  Brian Dewey (t-briand)    1997-7-15
--*/

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "awdlib.h"     // Gives access to the AWD routines.
#include "tifflib.h"        // TIFF routines.
#include "tifflibp.h"       // I need access to the private TIFF definitions.
#include "faxutil.h"        // not sure why I need this...
#include "viewrend.h"       // win95 viewer library.
#include "resource.h"       // resource constants

// ------------------------------------------------------------
// Prototypes
void Useage(HINSTANCE hInst);
void PopupError(UINT uID, HINSTANCE hModule);

// ------------------------------------------------------------
// WinMain

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
    )
{
    LPWSTR *argv;
    DWORD   argc;
    UINT    uiCurrentArg;   // Used for iterating through arguments.
    UINT    uiNumFiles=0;   // This is the number of files we've gotten
                // from the command line.
    WCHAR   szTempPath[MAX_PATH]; // Holds the temporary path.
    WCHAR   szTempFile[MAX_PATH]; // Holds the temporary file name.
    WCHAR   szAwdFile[MAX_PATH]; // Holds the name of the AWD file we're viewing or converting.
    int     iStrLen;
    BOOL    bConvert = FALSE;   // TRUE if we're to do a permanent conversion.
                // If FALSE, we do a conversion to a temporary file &
                // launch the viewer.
    BOOL    bTempProvided = FALSE;// If TRUE, then the user provided the destination file.
    UINT    uiHackPosition = 0; // Oh, this is part of some awful code below...


    argv = CommandLineToArgvW( GetCommandLine(), &argc );
    if(NULL == argv)
    {
        return 1;
    }
    if(argc < 2)
    {
        Useage(hInstance);
        return 1;
    }
    
    
    for(uiCurrentArg = 1; uiCurrentArg < argc; uiCurrentArg++) 
    {
        if((argv[uiCurrentArg][0] == L'-') ||
           (argv[uiCurrentArg][0] == L'/')) 
        {
                switch(argv[uiCurrentArg][1]) 
                {
                    // We're doing a switch based on the character after the
                    // command-argument specifier ('-' or '/').  Put additional
                    // arguments here as needed.
                  case L'c':
                  case L'C':
                if (argc<3)
                {
                    Useage(hInstance);
                    return 1;
                }
                bConvert = TRUE; // We're meant to do a permanent conversion.
                break;
                  default:
                    // Should an invalid parameter be an error?
                Useage(hInstance);
                return 1;
                } // Switch
        } else 
            {
            switch(uiNumFiles) {
              case 0:
                // If we haven't encountered any files before, then
                // this is the name of the AWD file.
            wcscpy(szAwdFile, argv[uiCurrentArg]);
            break;
              case 1:
                // Now, we're reading the name of the TIF file for permanent conversion.
            bTempProvided = TRUE;
            wcscpy(szTempFile, argv[uiCurrentArg]);
            break;
              default:
                // Too many parameters!
            Useage(hInstance);
            return 1;
            }
            uiNumFiles++;
        }
    } // For

    if(!bTempProvided) {
    if(!bConvert) {
        // If the user didn't give a temp file name, we provide one.
        if(!GetTempPath(MAX_PATH, szTempPath)) {
        PopupError(IDS_NOTEMPPATH, hInstance);
        return 1;       // Failed to get the path. 
        }
        GetTempFileName(
        szTempPath,     // put the file in this directory.
        TEXT("avs"),        // prefix -- "awd viewer stub"
        0,          // Generate a unique name.
        szTempFile      // Will hold the new name
        );
        DeleteFile(szTempFile); // Get rid of that file name.
                    // (created when obtained.)
    } else {
        // The user requested permanent conversion, but didn't
        // supply a name.  In this case, change the extention of
        // the file to TIF instead of generating a temp file name.
        wcscpy(szTempFile, szAwdFile);
    }
        // Make sure the file has the TIF extension.
    iStrLen = wcslen(szTempFile);
    szTempFile[iStrLen-3] = L't';
    szTempFile[iStrLen-2] = L'i';
    szTempFile[iStrLen-1] = L'f';
    } // if(bTempProvided)...
    
    if(ConvertAWDToTiff(szAwdFile, szTempFile)) 
    {
        SHELLEXECUTEINFO sei = {0};
        if(bConvert) 
        {
            return 0;      // We're done!
        }
        // now we have to tiff in szTempFile.
        // let's run ShellExecute on it to open it.
        // and wait for the viewer to close.
        sei.cbSize = sizeof (SHELLEXECUTEINFO);
        sei.fMask = SEE_MASK_NOCLOSEPROCESS;

        sei.lpVerb = TEXT("open");
        sei.lpFile = szTempFile;
        sei.lpParameters = NULL;
        sei.lpDirectory  = TEXT(".");
        sei.nShow  = SW_MAXIMIZE;

        if(!ShellExecuteEx(&sei))
        {
            PopupError(IDS_NOVIEW, hInstance);
        }
    
        WaitForSingleObject(sei.hProcess, INFINITE);
        // When we get here, the viewer has terminated.
        DeleteFile(szTempFile); // Erase our tracks.
    } 
    else
    {
        PopupError(IDS_ERRCONV, hInstance);
    }
    return 0;
}

// Useage
//
// Displays command useage.
//
// Parameters:
//  hInst           Current module instance.
//
// Returns:
//  Nothing.
//
// Author:
//  Brian Dewey (t-briand)  1997-8-7
void
Useage(HINSTANCE hInst)
{
    PopupError(IDS_USEAGE, hInst);
}

// PopupError
//
// Displays a message box with an error message.
//
// Parameters:
//  uID     String resource ID
//  hModule     Module instance.
//
// Returns:
//  Nothing.
//
// Author:
//  Brian Dewey (t-briand)  1997-8-19
void
PopupError(UINT uID, HINSTANCE hModule)
{
    TCHAR szTitle[512], szMsg[512];

    if(!LoadString(hModule,
           IDS_TITLE,
           szTitle,
           sizeof(szTitle)/sizeof(TCHAR))) 
    {
        return;
    }
    if(!LoadString(hModule,
           uID,
           szMsg,
           sizeof(szMsg)/sizeof(TCHAR))) 
    {
        return;
    }
    AlignedMessageBox(NULL, szMsg, szTitle, MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\gdi32blt.c ===
#include <windows.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"         /* Jumbo type definitions.                */
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"          /* Slice Descriptor defs.                 */
#include "hreext.h"

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{
	HDC hdcScreen;
	HBITMAP hbmDst;
  LPBITMAP lpbmBand = lpRE->lpBandBuffer;
 	UINT cbBand = lpbmBand->bmHeight * lpbmBand->bmWidthBytes;
 	LPVOID lpBits;
 	
	struct
	{
		BITMAPINFOHEADER bmih;
    DWORD dwPal[2];
	}
		bmiDst;

  // Create memory device contexts.
  hdcScreen = CreateIC ("DISPLAY", NULL, NULL, NULL);
  lpRE->hdcDst = CreateCompatibleDC (hdcScreen);
  lpRE->hdcSrc = CreateCompatibleDC (hdcScreen);
  DeleteDC (hdcScreen);

 	// Initialize destination bitmap.
  bmiDst.bmih.biSize = sizeof(BITMAPINFOHEADER);
  bmiDst.bmih.biWidth = lpbmBand->bmWidth;
  bmiDst.bmih.biHeight = -lpbmBand->bmHeight; // top-down
  bmiDst.bmih.biPlanes = 1;
  bmiDst.bmih.biBitCount = 1;
  bmiDst.bmih.biCompression = BI_RGB;
  bmiDst.bmih.biSizeImage = 0;
  bmiDst.bmih.biClrUsed = 0;
  bmiDst.bmih.biClrImportant = 0;
  bmiDst.dwPal[0] = RGB (  0,   0,   0);
  bmiDst.dwPal[1] = RGB (255, 255, 255);

  // Create DIB section.
	hbmDst = CreateDIBSection
	 	(lpRE->hdcDst, (LPBITMAPINFO) &bmiDst, DIB_RGB_COLORS, &lpBits, NULL, 0);
	if (!hbmDst)
		return FALSE;
	lpRE->hbmDef = SelectObject (lpRE->hdcDst, hbmDst);
  lpRE->hbrDef = NULL;
  		
  // Swap frame buffers.
  lpRE->lpBandSave = lpbmBand->bmBits;
  lpbmBand->bmBits = lpBits;

  // Disable GDI batching.
  GdiSetBatchLimit (1);

	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{
	// Restore frame buffer.
	LPBITMAP lpbmBand = lpRE->lpBandBuffer;
 	UINT cbBand = lpbmBand->bmHeight * lpbmBand->bmWidthBytes;
  memcpy (lpRE->lpBandSave, lpbmBand->bmBits, cbBand);
	lpbmBand->bmBits = lpRE->lpBandSave;

  // Restore default objects.
  DeleteObject (SelectObject (lpRE->hdcDst, lpRE->hbmDef));
  DeleteObject (SelectObject (lpRE->hdcDst, lpRE->hbrDef));

  // Destroy memory device contexts.
 	DeleteDC (lpRE->hdcDst);
 	DeleteDC (lpRE->hdcSrc);

 	// Restore GDI batching.
  GdiSetBatchLimit (0);
}

//==============================================================================
DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop		 // Raster operation
)
{
	HBITMAP hbmSrc, hbmOld;
	
  // Create source bitmap.
	hbmSrc = CreateCompatibleBitmap (lpRE->hdcSrc, 32*clLine, yExt);
	SetBitmapBits (hbmSrc, 4*clLine*yExt, lpSrc);
	hbmOld = SelectObject (lpRE->hdcSrc, hbmSrc);

  // Call GDI BitBlt.
	BitBlt (lpRE->hdcDst, xDst, yDst, xExt, yExt, lpRE->hdcSrc, xSrc, 0, lpRE->dwRop);

  // Destroy source bitmap.
  SelectObject (lpRE->hdcSrc, hbmOld);
  DeleteObject (hbmSrc);
	return 0;	
}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
	HBITMAP hbmPat;
	HBRUSH hbrPat, hbrOld;

  // Create pattern brush.
  hbmPat = CreateBitmap (32, 32, 1, 1, lpRE->lpCurBrush);
	hbrPat = CreatePatternBrush (hbmPat);
	DeleteObject (hbmPat);

	// Replace previous brush.
	hbrOld = SelectObject (lpRE->hdcDst, hbrPat);
	if (lpRE->hbrDef)
		DeleteObject (hbrOld);  // delete old brush
	else
		lpRE->hbrDef = hbrOld;  // save default brush

	return TRUE;
}

//==============================================================================
ULONG FAR PASCAL RP_FILLSCANROW
(
	LPRESTATE  lpRE,       // resource executor context
	USHORT     xDst,       // rectangle left
	USHORT     yDst,       // rectangle right
	USHORT     xExt,       // rectangle width
	USHORT     yExt,       // rectangle height
	UBYTE FAR* lpPat,      // 32x32 pattern bitmap
	DWORD      dwRop,      // raster operation
	LPVOID     lpBand,     // output band buffer
	UINT       cbLine,     // band width in bytes
	WORD       yBrush      // brush position offset
)
{
	return PatBlt (lpRE->hdcDst, xDst, yDst, xExt, yExt, lpRE->dwRop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\genconst.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENCONST.BLT
;
; Constants for general use in BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is a catchall for constants for use in BitBLT.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

;	The following equates are for stuffing into the generated BLT.
;	For full 16-bit values, the two bytes are reversed so that they
;	come out correctly when stored in memory (i.e. the 8088 stores
;	the LSB first).


I_ADD_AL_BYTE_I		equ	004h	;ADD	al,byte immediate
I_ADD_AX_WORD_I		equ	005h	;ADD	ax,word immediate
I_ADD_DI_WORD_I		equ	0C781h	;ADD	di,immediate
I_ADD_SI_WORD_I		equ	0C681h	;ADD	si,immediate
I_AND_AL_MEM		equ	00622h	;AND	al,[addr]
I_AND_AL_BYTE_I		equ	024h	;AND	al,byte immediate

I_CMP_AL_BYTE_I		equ	03Ch	;CMP	al,byte immediate
I_CMP_AX_WORD_I		equ	03Dh	;CMP	ax,word immediate
I_CMP_CX_2		equ	0F983h	;CMP	cx,2
I_CS_OVERRIDE		equ	02Eh	;CS:

I_DEC_SI_DEC_DI		equ	04F4Eh	;DEC	si
					;DEC	di
I_ES_OVERRIDE		equ	026h	;ES:
I_FS_OVERRIDE		equ	064h	;FS:
I_GS_OVERRIDE		equ	065h	;GS:

I_INC_SI_INC_DI		equ	04746h	;INC	si
					;INC	di
I_JC_P5H		equ	00372h	;JC	$+5
I_JC_P0DH		equ	00B72h	;JC	$+0Dh
I_JC_P12H		equ	01072h	;JC	$+12h
I_JMP_NEAR		equ	0E9h	;JMP	near
I_JNC			equ	073h	;JNC	short
I_JNC_P12H		equ	01073h	;JNC	$+12h
I_JNS_P6		equ	00479H	;JNS	$+6
I_JLE_P2                equ     0007EH  ;JLE    $+2     mslin

I_LEA_AX_SI_DISP16	equ	0848Dh	;lea	ax,WordDisp[si]
I_LEA_AX_DI_DISP16	equ	0858Dh	;lea	ax,WordDisp[di]
I_LODSB			equ	0ACh	;LODSB
I_LOOP			equ	0E2h	;LOOP

I_MOV_AH_AL		equ	0E08Ah	;MOV	ah,al
I_MOV_AH_DEST		equ	0258Ah	;MOV	ah,[di]
I_MOV_AH_SI_DISP16	equ	0A48Ah	;MOV	ah,WordDisp[si]
I_MOV_AL_0FFH		equ	0FFB0h	;MOV	al,0FFH
I_MOV_AL_AH		equ	0C48Ah	;MOV	al,ah
I_MOV_AL_DL		equ	0C28Ah	;MOV	al,dl
I_MOV_AL_DH		equ	0C68Ah	;MOV	al,dh
I_MOV_AL_DEST		equ	0058Ah	;MOV	al,[di]
I_MOV_AL_MEM		equ	0A0h	;MOV	al,[addr]
I_MOV_AL_SI_DISP16	equ	0848Ah	;MOV	al,WordDisp[si]
I_MOV_AX_DS		equ	0D88Ch	;MOV	ax,ds
I_MOV_AX_DI		equ	0C78Bh	;MOV	ax,di
I_MOV_AX_ES		equ	0C08Ch	;MOV	ax,es
I_MOV_AX_SI		equ	0C68Bh	;MOV	ax,si
I_MOV_AX_WORD_I		equ	0B8h	;MOV	ax,immediate
I_MOV_BL_AL		equ	0D88Ah	;MOV	bl,al
I_MOV_AL_BYTE_I		equ	0B0h	;MOV	al,immediate    mslin
I_MOV_BL_BYTE_I		equ	0B3h	;MOV	bl,immediate
I_MOV_BP_WORD_I		equ	0BDh	;MOV	bp,immediate
I_MOV_BX_WORD_I		equ	0BBh	;MOV	bx,word immediate
I_MOV_CX_DS		equ	0D98Ch	;MOV	cx,ds
I_MOV_CX_WORD_I		equ	0B9h	;MOV	cx,immediate
I_MOV_DH_BX_DISP8	equ	0778Ah	;MOV	dh,ByteDisp[si]
I_MOV_DI_AX		equ	0F88Bh	;MOV	di,ax
I_MOV_DL_AL		equ	0D08Ah	;MOV	dl,al
I_MOV_DS_AX		equ	0D88Eh	;MOV	ds,ax
I_MOV_DS_CX		equ	0D98Eh	;MOV	ds,cx
I_MOV_ES_AX		equ	0C08Eh	;MOV	es,ax
I_MOV_MEM_AL		equ	0A2h	;MOV	[addr],al
I_MOV_SI_AX		equ	0F08Bh	;MOV	si,ax
I_MOVSB			equ	0A4h	;MOVSB
I_MOVSW			equ	0A5h	;MOVSW
I_MOV_MEM_AX		equ	0A2h	;MOV	[addr],ax       ;mslin

I_MOV_BL_BYTE_I         equ     0B3h    ;MOV    bl, byte immediate

I_NOT_AL		equ	0D0F6h	;NOT	al
I_NOT_AX		equ	0D0F7h	;NOT	ax

I_OR_AL_AH		equ	0C40Ah	;OR	al,ah
I_OR_AH_AL		equ	0E00Ah	;OR	ah,al

I_POP_BX		equ	05Bh	;POP	bx
I_POP_SI		equ	05Eh	;POP	si
I_POP_DI_POP_CX		equ	0595Fh	;POP	di
					;POP	cx
I_PUSH_BX		equ	053h	;PUSH	bx
I_PUSH_SI		equ	056h	;PUSH	si
I_PUSH_CX_PUSH_DI	equ	05751h	;PUSH	cx
					;PUSH	di
I_REP			equ	0F3h	;REP
I_RET_NEAR		equ	0C3h	;RET	near
I_RET_FAR		equ	0CBh	;RET	far
I_ROL_AL_1		equ	0C0D0h	;ROL	al,1
I_ROR_AL_1		equ	0C8D0h	;ROR	al,1
I_ROL_AL_N		equ	0C0C0h	;ROL	al,N  -- next byte is N
I_ROR_AL_N		equ	0C8C0h	;ROR	al,N  -- next byte is N

I_SHL_BL_1		equ	0E3D0h	;SHL	bl,1
I_SS_OVERRIDE		equ	036h	;SS:
I_STOSB			equ	0AAh	;STOSB
I_STOSW			equ	0ABh	;STOSW

I_XOR_AL_MEM		equ	00632h	;XOR	al,[addr]
I_XOR_AL_BYTE_I		equ	034h	;XOR	al,byte immediate
I_XOR_AX_WORD_I		equ	035h	;XOR	ax,word immediate
I_XOR_BH_BH		equ	0FF32h	;XOR	BH,BH
I_XOR_MEM_WORD_I	equ	03681H	;XOR	[addr],word immediate

;mslin added
I_MOV_DX_WORD_I		equ	0BAh	;MOV	dx,immediate
I_POP_DX		equ	05Ah	;POP	dx
I_MOV_DX_DS		equ	0DA8Ch	;MOV	dx,ds
I_MOV_AL_000H		equ	000B0h	;MOV	al,000H


	page

;	INCREASE is the flag used to show that the BLT operation will be
;	increasing in Y (Y+).
;
;	DECREASE is the flag used to show that the BLT operation will be
;	decreasing in Y (Y-).
;
;	STEPLEFT is the flag used to show that the BLT will be stepping
;	left (i.e. start at the right hand corner of the source, stepping
;	left, or X-).
;
;	STEPRIGHT is the flag used to show that the BLT will be stepping
;	right (i.e. start at the left hand corner of the source, stepping
;	right, or X+).


INCREASE	equ	1		;Incrementing
DECREASE	equ	-1		;Decrementing
STEPLEFT	equ	0		;Stepping to the left
STEPRIGHT	equ	1		;Stepping to the right

	page

;	gl_the_flags
;
;	F0_GAG_CHOKE	Set if the source and destination are of different
;			color formats.	When set, some form of color
;			conversion will be required.
;
;			Once you see what all is involved with color
;			conversion, you'll understand why this flag is
;			called this.
;
;	F0_COLOR_PAT	Set if color pattern fetch code will be used.  If
;			clear, then mono pattern fetch code will be used.
;			Mono/color pattern fetch is always based on the
;			destination being mono/color (it is the same).
;
;	F0_PAT_PRESENT	Set if a pattern is involved in the BLT.
;
;	F0_SRC_PRESENT	Set if a source  is involved in the BLT.
;
;	F0_SRC_IS_DEV	Set if the source is the physical device.  Clear if
;			the source is a memory bitmap.
;
;	F0_SRC_IS_COLOR	Set if the source is color, clear if monochrome.
;
;	F0_DEST_IS_DEV	Set if the destination is the physical device.
;			Clear if the destination is a memory bitmap.
;
;	F0_DEST_IS_COLOR
;			Set if the destination is color, clear if
;			monochrome.


F0_GAG_CHOKE		equ	10000000b	;Going mono <==> color
F0_COLOR_PAT		equ	01000000b	;Use color pattern fetch code
F0_PAT_PRESENT		equ	00100000b	;Pattern is involved in blt
F0_SRC_PRESENT		equ	00010000b	;Source is involved in blt
F0_SRC_IS_DEV		equ	00001000b	;Source is the device
F0_SRC_IS_COLOR		equ	00000100b	;Source is color
F0_DEST_IS_DEV		equ	00000010b	;Destination is the device
F0_DEST_IS_COLOR	equ	00000001b	;Destination is color

;-----------------------------------------------------------------------;
; Definitions for fbFetch
;-----------------------------------------------------------------------;

FF_NO_LAST_FETCH	equ	00000010b	;Final fetch might GP
FF_TWO_INIT_FETCHES	equ	00000001b	;Two initial fetches needed
FF_ONE_INIT_FETCH	equ	       0	;One initial fetche  needed
FF_ONLY_1_DEST_BYTE	equ	00000100b	;Only one destination byte
FF_ONLY_1_SRC_BYTE	equ	00001000b	;Only one source byte


;-----------------------------------------------------------------------;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\gendata.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENDATA.BLT
;
; Data definitions for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is a catchall for data definitions other that code templates
; for BitBLT.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
; 03/06/92  dstseng change bitmask_tbl1/bitmask_tbl2 to private
;-----------------------------------------------------------------------;

;	The following two bitmask tables are used for fetching
;	the first and last byte used-bits bitmask.


;	public bitmask_tbl1
;	public _bitmask_tbl1
bitmask_tbl1	label	byte
_bitmask_tbl1	label	byte
	db	11111111b		;Masks for leftmost byte
	db	01111111b
	db	00111111b
	db	00011111b
	db	00001111b
	db	00000111b
	db	00000011b
	db	00000001b


;	public bitmask_tbl2
;	public _bitmask_tbl2
bitmask_tbl2	label	byte
_bitmask_tbl2	label	byte
	db	10000000b		;Masks for rightmost byte
	db	11000000b
	db	11100000b
	db	11110000b
	db	11111000b
	db	11111100b
	db	11111110b
	db	11111111b



;	phase_tbl1 is used for loading the "used" bits and "saved" bits
;	bitmasks for cases 1,2,3 where the step direction is left to
;	right.	If it weren't for the case of zero, this could be done
;	with a simple rotate of 00FF.	For cases 4,5,6, a simple rotate
;	can create the mask needed.


;	public	phase_tbl1
phase_tbl1	label	word
	db	11111111b,00000000b		;Used bits, saved bits
	db	00000001b,11111110b
	db	00000011b,11111100b
	db	00000111b,11111000b
	db	00001111b,11110000b
	db	00011111b,11100000b
	db	00111111b,11000000b
	db	01111111b,10000000b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\genlocal.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENLOCAL.BLT
;
; Parameters and generic local variables for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file contains the parameters passed to BitBLT, as well as local
; variables that all of its code expects.
;
; The prefix "gl_" stands for "generic local". Other prefixes are "cl_"
; for "color-related local" and "dl_" for "device-related local".
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        parmD   _PRT_FrameStart      ;Get pointer to destination
        parmD   _lpgBrush
        parmW   _PRT_BytesPerScanline
        parmW   _usBrushWidth
        parmW   _PRT_Max_X
        parmW   _PRT_Max_Y
        parmW   _usgPosOff      ; dstseng 08/06/92 To get correct Brush Offset
        parmW   SrcxOrg                 ;Source      origin - x coordinate
        parmW   DestyOrg                ;Destination origin - y coordinate
        parmW   DestxOrg                ;Destination origin - x coordinate
        parmW   DestWarp                ;Destination # of DWord per scanline
        parmW   yExt                    ;y extent of the BLT
        parmW   xExt                    ;x extent of the BLT
        parmD   lpSrcDev                ;--> to source bitmap descriptor
        parmD   lpPBrush                ;--> to a physical brush (pattern)
        parmD   Rop                     ;Raster operation descriptor

;       Generic locals (i.e. used by all BitBLT code)

ifdef   THIS_IS_DOS_3_STUFF
else
;        localW  ScreenSelector
endif
        localB  gl_phase_h              ;Horizontal phase (rotate count)
        localW  gl_pat_row              ;Current row for patterns [0..31]
;mslin        localB  gl_direction            ;Increment/decrement flag

        localB  local_enable_flag       ;Local copy of the enable flag
;       localB  mask_flags              ;Number of first fetches needed
;
;MF_PHASE               equ     00000111b
;MF_PHASE_POSITIVE      equ     00001000b
;MF_STEP_RIGHT          equ     00010000b
;MF_WORD_FETCH          equ     00100000b
;MF_BIG_PHASE           equ     01000000b ; phase > 4
;MF_UN_USED             equ     10000000b

        localB  gl_the_flags
        localB  gl_first_fetch          ;Number of first fetches needed
        localB  gl_step_direction       ;Direction of move (left right)
        localW  gl_start_mask           ;Mask for first dest byte
        localW  gl_last_mask            ;Mask for last  dest byte
        localW  gl_mask_p               ;Horizontal phase mask
        localW  gl_inner_loop_count     ;# of entire bytes to BLT in innerloop
        localW  gl_operands             ;Operand string
        localW  gl_start_fl             ;Start of fetch/logic operation
        localW  gl_end_fl               ;End   of fetch/logic operation
        localW  gl_end_fls              ;End   of fetch/logic/store operation
        localD  gl_blt_addr             ;BLT offset address
        localW  WorkSelector            ; selector to use
        localW  cFetchCode              ;size of the fetch code alone


        localW  SrcxOrg                 ;Source origin - x coordinate
        localW  SrcyOrg                 ;Source origin - y coordinate
        localW  gl_pattern_ptr          ;next fetch byte pattern address
        localW  destOffset
        localW  gl_pat_col              ;Current row for patterns [0..3]
        localW  gl_brush_width          ;Current brush width in byte
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\brushpat.c ===
/*==============================================================================
This file defines 8x8 pixel monochrome patterns for standard GDI brushes.  
The patterns are for 6 hatched brushes and 65 gray levels of solid brushes.

05-30-93     RajeevD     Created.
02-15-94     RajeevD     Integrated into unified resource executor.
05-12-94     RajeevD     Ported to C for Win32.
==============================================================================*/

#define DB(b7,b6,b5,b4,b3,b2,b1,b0)\
  ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0)

const unsigned char BrushPat[71][8] = 
{
	// HS_HORIZONTAL
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),

	// HS_VERTICAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),

	// HS_FDIAGONAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,0,1,1,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,1,1),
	DB(1,0,0,0,0,0,0,1),
	DB(1,1,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,1,1,0,0,0,0),

	// HS_BDIAGONAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,1,1,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,0,0,0,0,0,0),
	DB(1,0,0,0,0,0,0,1),
	DB(0,0,0,0,0,0,1,1),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,0,0),

	// HS_CROSS
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),

	// HS_DIAGCROSS 
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,1,1,1,1,0,0),
	DB(0,1,1,0,0,1,1,0),
	DB(1,1,0,0,0,0,1,1),
	DB(1,0,0,0,0,0,0,1),
	DB(1,1,0,0,0,0,1,1),
	DB(0,1,1,0,0,1,1,0),
	DB(0,0,1,1,1,1,0,0),

	// BS_SOLID[0,0h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0,1,h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[02h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[03h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[04h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[05h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[06h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[07h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[08h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[09h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Ah]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Bh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Ch]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Dh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,0,0),

	// BS_SOLID[0Eh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,0,0),

	// BS_SOLID[0Fh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),

	// BS_SOLID[1,0h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),

	// BS_SOLID[1,1,h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,2h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,3h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,4h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,5h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,6h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,7h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,8h]
	DB(0,1,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,9h]
	DB(0,1,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Ah]
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Bh]
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Ch]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Dh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[1,Eh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[1,Fh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[20h]
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[21,h]
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[22h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[23h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[24h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[25h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[26h]
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[27h]
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[28h]
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[29h]
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Ah]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Bh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Ch]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Dh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Eh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Fh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),

	// BS_SOLID[30h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),

	// BS_SOLID[31,h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),

	// BS_SOLID[32h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),

	// BS_SOLID[33h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[34h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[35h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[36h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[37h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[38h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[39h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Ah]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Bh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Ch]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Dh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Eh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Fh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[40h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\faxcodec\t4core.c ===
/* Copyright Microsoft Corp 1993, 1994
 *
 *      t4core.c
 *
 *      MH/MR/MMR/LRAW conversion utilities
 *
 *      Created:        12/06/93
 *      Author:         mikegins
 *      Reviewer:       rajeevd
 */

/* WARNING: This code may not be machine byte order independent, since it uses
   WORD manipulations
 */

/* On Change->X, need to return correct lpbOut */
/* On X->Change, need to return correct lpbOut, lpbIn, cbIn */

/*  Change->LRAW : Takes change vectors, outputs LRAW.
    LRAW->Change : Takes LRAW, outputs change vectors.
    Change->MMR  : Takes change vectors, generates MMR.  On END_OF_PAGE,
	flushes and appends EOFB.
    MMR->Change  : Takes MMR, generates change vectors.  On EOFB, returns
	END_OF_PAGE.
    MH->Change   : Takes change vectors, generates EOL/MH/EOL/MH/etc.  On
	END_OF_PAGE, flushes output.
    Change->MH   : Takes <optional garbage>/EOL/MH/EOL/MH/etc.  Returns EOL
	after MH line decoded.
    MR->Change   : Takes change vectors, generates EOL/MR/EOL/MR/etc.  On
	END_OF_PAGE, flushes output.
    Change->MR   : Takes <optional garbage>/EOL/MR/EOL/MR/etc.  Returns EOL
	after MR line decoded.
 */
#include <ifaxos.h>
#include "context.hpp"

#define  MH_OUTPUT_SLACK 32 // Enough bytes for anything to be output!
#define MMR_OUTPUT_SLACK 32 // Enough bytes for anything to be output!

#define SIZE_MKUP 0x8000
#define SIZE_SPEC 0x4000 /* size -> special instruction */
#define S_ZERO    0x4000
#define S_ERR     0x4001
#define S_EOL     0x4002
#define SIZE_MASK 0x3fff

static WORD dbg=0;

typedef struct
{
	WORD data;
  WORD bitsused;
}
	RUNINFO, FAR *LPRUNINFO;

RUNINFO EOFB = {0x0800,12}; /* Must repeat twice */
RUNINFO PASS = {0x0008,4};
RUNINFO HORIZ = {0x0004,3};

RUNINFO VERT[7] =
{
	{0x0060, 0x07}, {0x0030, 0x06}, {0x0006, 0x03}, {0x0001, 0x01},
  {0x0002, 0x03}, {0x0010, 0x06}, {0x0020, 0x07}
};

RUNINFO WhiteMkup[40] =
{
    {0x001B, 0x05}, {0x0009, 0x05}, {0x003A, 0x06}, {0x0076, 0x07},
    {0x006C, 0x08}, {0x00EC, 0x08}, {0x0026, 0x08}, {0x00A6, 0x08},
    {0x0016, 0x08}, {0x00E6, 0x08}, {0x0066, 0x09}, {0x0166, 0x09},
    {0x0096, 0x09}, {0x0196, 0x09}, {0x0056, 0x09}, {0x0156, 0x09},
    {0x00D6, 0x09}, {0x01D6, 0x09}, {0x0036, 0x09}, {0x0136, 0x09},
    {0x00B6, 0x09}, {0x01B6, 0x09}, {0x0032, 0x09}, {0x0132, 0x09},
    {0x00B2, 0x09}, {0x0006, 0x06}, {0x01B2, 0x09}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO WhiteTCode[64] =
{
    {0x00AC, 0x08}, {0x0038, 0x06}, {0x000E, 0x04}, {0x0001, 0x04},
    {0x000D, 0x04}, {0x0003, 0x04}, {0x0007, 0x04}, {0x000F, 0x04},
    {0x0019, 0x05}, {0x0005, 0x05}, {0x001C, 0x05}, {0x0002, 0x05},
    {0x0004, 0x06}, {0x0030, 0x06}, {0x000B, 0x06}, {0x002B, 0x06},
    {0x0015, 0x06}, {0x0035, 0x06}, {0x0072, 0x07}, {0x0018, 0x07},
    {0x0008, 0x07}, {0x0074, 0x07}, {0x0060, 0x07}, {0x0010, 0x07},
    {0x000A, 0x07}, {0x006A, 0x07}, {0x0064, 0x07}, {0x0012, 0x07},
    {0x000C, 0x07}, {0x0040, 0x08}, {0x00C0, 0x08}, {0x0058, 0x08},
    {0x00D8, 0x08}, {0x0048, 0x08}, {0x00C8, 0x08}, {0x0028, 0x08},
    {0x00A8, 0x08}, {0x0068, 0x08}, {0x00E8, 0x08}, {0x0014, 0x08},
    {0x0094, 0x08}, {0x0054, 0x08}, {0x00D4, 0x08}, {0x0034, 0x08},
    {0x00B4, 0x08}, {0x0020, 0x08}, {0x00A0, 0x08}, {0x0050, 0x08},
    {0x00D0, 0x08}, {0x004A, 0x08}, {0x00CA, 0x08}, {0x002A, 0x08},
    {0x00AA, 0x08}, {0x0024, 0x08}, {0x00A4, 0x08}, {0x001A, 0x08},
    {0x009A, 0x08}, {0x005A, 0x08}, {0x00DA, 0x08}, {0x0052, 0x08},
    {0x00D2, 0x08}, {0x004C, 0x08}, {0x00CC, 0x08}, {0x002C, 0x08}, 
};

RUNINFO BlackMkup[40] =
{
    {0x03C0, 0x0A}, {0x0130, 0x0C}, {0x0930, 0x0C}, {0x0DA0, 0x0C},
    {0x0CC0, 0x0C}, {0x02C0, 0x0C}, {0x0AC0, 0x0C}, {0x06C0, 0x0D},
    {0x16C0, 0x0D}, {0x0A40, 0x0D}, {0x1A40, 0x0D}, {0x0640, 0x0D},
    {0x1640, 0x0D}, {0x09C0, 0x0D}, {0x19C0, 0x0D}, {0x05C0, 0x0D},
    {0x15C0, 0x0D}, {0x0DC0, 0x0D}, {0x1DC0, 0x0D}, {0x0940, 0x0D},
    {0x1940, 0x0D}, {0x0540, 0x0D}, {0x1540, 0x0D}, {0x0B40, 0x0D},
    {0x1B40, 0x0D}, {0x04C0, 0x0D}, {0x14C0, 0x0D}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO BlackTCode[64] =
{
    {0x03B0, 0x0A}, {0x0002, 0x03}, {0x0003, 0x02}, {0x0001, 0x02},
    {0x0006, 0x03}, {0x000C, 0x04}, {0x0004, 0x04}, {0x0018, 0x05},
    {0x0028, 0x06}, {0x0008, 0x06}, {0x0010, 0x07}, {0x0050, 0x07},
    {0x0070, 0x07}, {0x0020, 0x08}, {0x00E0, 0x08}, {0x0030, 0x09},
    {0x03A0, 0x0A}, {0x0060, 0x0A}, {0x0040, 0x0A}, {0x0730, 0x0B},
    {0x00B0, 0x0B}, {0x01B0, 0x0B}, {0x0760, 0x0B}, {0x00A0, 0x0B},
    {0x0740, 0x0B}, {0x00C0, 0x0B}, {0x0530, 0x0C}, {0x0D30, 0x0C},
    {0x0330, 0x0C}, {0x0B30, 0x0C}, {0x0160, 0x0C}, {0x0960, 0x0C},
    {0x0560, 0x0C}, {0x0D60, 0x0C}, {0x04B0, 0x0C}, {0x0CB0, 0x0C},
    {0x02B0, 0x0C}, {0x0AB0, 0x0C}, {0x06B0, 0x0C}, {0x0EB0, 0x0C},
    {0x0360, 0x0C}, {0x0B60, 0x0C}, {0x05B0, 0x0C}, {0x0DB0, 0x0C},
    {0x02A0, 0x0C}, {0x0AA0, 0x0C}, {0x06A0, 0x0C}, {0x0EA0, 0x0C},
    {0x0260, 0x0C}, {0x0A60, 0x0C}, {0x04A0, 0x0C}, {0x0CA0, 0x0C},
    {0x0240, 0x0C}, {0x0EC0, 0x0C}, {0x01C0, 0x0C}, {0x0E40, 0x0C},
    {0x0140, 0x0C}, {0x01A0, 0x0C}, {0x09A0, 0x0C}, {0x0D40, 0x0C},
    {0x0340, 0x0C}, {0x05A0, 0x0C}, {0x0660, 0x0C}, {0x0E60, 0x0C}
};

// Common States
#define W    0
#define W0  50
#define W1  51
#define B  108
#define B0 109
#define B1 110

#define M SIZE_MKUP

typedef struct
{
	WORD nextstate;
  WORD size;
}
	nextinfo_t;

typedef struct
{
	nextinfo_t nextinf[4];
}
	State;

State MHStates[229] = {
/*   0 : W               */ {  1,     0,   2,     0,   3,     0,   4,     0}, 
/*   1 : W00             */ {  5,     0,   6,     0,   7,     0,   8,     0}, 
/*   2 : W10             */ {  B,     3,   9,     0,  10,     0,   B,     4}, 
/*   3 : W01             */ { 11,     0,  12,     0,  13,     0,   B,     2}, 
/*   4 : W11             */ {  B,     5,   B,     6,  14,     0,   B,     7}, 
/*   5 : W0000           */ { 15,     0,  16,     0,  17,     0,   B,    13}, 
/*   6 : W0010           */ {  B,    12,  18,     0,  19,     0,  20,     0}, 
/*   7 : W0001           */ { 21,     0,  22,     0,  23,     0,   B,     1}, 
/*   8 : W0011           */ { 24,     0,  B0,    10,  25,     0,  B1,    10}, 
/*   9 : W1010           */ { B0,     9,   B,    16,  B1,     9,   B,    17}, 
/*  10 : W1001           */ { W0, M|128,  B0,     8,  W1, M|128,  B1,     8}, 
/*  11 : W0100           */ { B0,    11,  26,     0,  B1,    11,  27,     0}, 
/*  12 : W0110           */ {  W,M|1664,  28,     0,  29,     0,  30,     0}, 
/*  13 : W0101           */ { 31,     W,  32,     0,  33,     0,   W, M|192}, 
/*  14 : W1101           */ {  B,    14,  W0,  M|64,   B,    15,  W1,  M|64}, 
/*  15 : W000000         */ { 34,     0,   B,    29,  35,     0,   B,    30}, 
/*  16 : W000010         */ { B0,    23,   B,    47,  B1,    23,   B,    48}, 
/*  17 : W000001         */ {  B,    45,  B0,    22,   B,    46,  B1,    22}, 
/*  18 : W001010         */ {  B,    39,   B,    41,   B,    40,   B,    42}, 
/*  19 : W001001         */ {  B,    53,  B0,    26,   B,    54,  B1,    26}, 
/*  20 : W001011         */ {  B,    43,  B0,    21,   B,    44,  B1,    21}, 
/*  21 : W000100         */ { B0,    20,   B,    33,  B1,    20,   B,    34}, 
/*  22 : W000110         */ { B0,    19,   B,    31,  B1,    19,   B,    32}, 
/*  23 : W000101         */ {  B,    35,   B,    37,   B,    36,   B,    38}, 
/*  24 : W001100         */ { B0,    28,   B,    61,  B1,    28,   B,    62}, 
/*  25 : W001101         */ {  B,    63,   W, M|320,   B,S_ZERO,   W, M|384}, 
/*  26 : W010010         */ { B0,    27,   B,    59,  B1,    27,   B,    60}, 
/*  27 : W010011         */ { 36,     0,  B0,    18,  37,     0,  B1,    18}, 
/*  28 : W011010         */ {  W, M|576,  38,     0,  39,     0,  40,     0}, 
/*  29 : W011001         */ {  W, M|448,  41,     0,   W, M|512,   W, M|640}, 
/*  30 : W011011         */ { 42,     0,  W0, M|256,  43,     0,  W1, M|256}, 
/*  31 : W010100         */ { B0,    24,   B,    49,  B1,    24,   B,    50}, 
/*  32 : W010110         */ {  B,    55,   B,    57,   B,    56,   B,    58}, 
/*  33 : W010101         */ {  B,    51,  B0,    25,   B,    52,  B1,    25}, 
/*  34 : W00000000       */ { 44,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  35 : W00000001       */ { 46,     0,  47,     0,  48,     0,  49,     0}, 
/*  36 : W01001100       */ { W0,M|1472,  W0,M|1536,  W1,M|1472,  W1,M|1536}, 
/*  37 : W01001101       */ { W0,M|1600,  W0,M|1728,  W1,M|1600,  W1,M|1728}, 
/*  38 : W01101010       */ { W0, M|960,  W0,M|1024,  W1, M|960,  W1,M|1024}, 
/*  39 : W01101001       */ { W0, M|832,  W0, M|896,  W1, M|832,  W1, M|896}, 
/*  40 : W01101011       */ { W0,M|1088,  W0,M|1152,  W1,M|1088,  W1,M|1152}, 
/*  41 : W01100110       */ { W0, M|704,  W0, M|768,  W1, M|704,  W1, M|768}, 
/*  42 : W01101100       */ { W0,M|1216,  W0,M|1280,  W1,M|1216,  W1,M|1280}, 
/*  43 : W01101101       */ { W0,M|1344,  W0,M|1408,  W1,M|1344,  W1,M|1408}, 
/*  44 : W0000000000     */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  45 : W00000000000    */ { 45,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/*  46 : W0000000100     */ { W0,M|1792,   W,M|1984,  W1,M|1792,   W,M|2048}, 
/*  47 : W0000000110     */ { W0,M|1856,  W0,M|1920,  W1,M|1856,  W1,M|1920}, 
/*  48 : W0000000101     */ {  W,M|2112,   W,M|2240,   W,M|2176,   W,M|2304}, 
/*  49 : W0000000111     */ {  W,M|2368,   W,M|2496,   W,M|2432,   W,M|2560}, 
/*  50 : W0              */ { 52,     0,  53,     0,  54,     0,  55,     0}, 
/*  51 : W1              */ { 56,     0,  57,     0,  58,     0,  59,     0}, 
/*  52 : W000            */ { 60,     0,  61,     0,  62,     0,  63,     0}, 
/*  53 : W010            */ {  B,    11,  64,     0,  65,     0,  66,     0}, 
/*  54 : W001            */ { 67,     0,  68,     0,  69,     0,   B,    10}, 
/*  55 : W011            */ { 70,     0,  B0,     2,  71,     0,  B1,     2}, 
/*  56 : W100            */ { B0,     3,   W, M|128,  B1,     3,   B,     8}, 
/*  57 : W110            */ { B0,     5,  72,     0,  B1,     5,   W,  M|64}, 
/*  58 : W101            */ {  B,     9,  B0,     4,  73,     0,  B1,     4}, 
/*  59 : W111            */ { B0,     6,  B0,     7,  B1,     6,  B1,     7}, 
/*  60 : W00000          */ { 74,     0,  75,     0,  76,     0,   B,    22}, 
/*  61 : W00010          */ {  B,    20,  77,     0,  78,     0,  79,     0}, 
/*  62 : W00001          */ {  B,    23,  B0,    13,  80,     0,  B1,    13}, 
/*  63 : W00011          */ {  B,    19,  B0,     1,  81,     0,  B1,     1}, 
/*  64 : W01010          */ {  B,    24,  82,     0,  83,     0,   B,    25}, 
/*  65 : W01001          */ {  B,    27,  84,     0,  85,     0,   B,    18}, 
/*  66 : W01011          */ { 86,     0,  W0, M|192,  87,     0,  W1, M|192}, 
/*  67 : W00100          */ { B0,    12,  88,     0,  B1,    12,   B,    26}, 
/*  68 : W00110          */ {  B,    28,  89,     0,  90,     0,  91,     0}, 
/*  69 : W00101          */ { 92,     0,  93,     0,  94,     0,   B,    21}, 
/*  70 : W01100          */ { W0,M|1664,  95,     0,  W1,M|1664,  96,     0}, 
/*  71 : W01101          */ { 97,     0,  98,     0,  99,     0,   0, M|256}, 
/*  72 : W11010          */ { B0,    14,  B0,    15,  B1,    14,  B1,    15}, 
/*  73 : W10101          */ { B0,    16,  B0,    17,  B1,    16,  B1,    17}, 
/*  74 : W0000000        */ {100,     0, 101,     0, 216, S_ERR, 102,     0}, 
/*  75 : W0000010        */ { B0,    45,  B0,    46,  B1,    45,  B1,    46}, 
/*  76 : W0000001        */ { B0,    29,  B0,    30,  B1,    29,  B1,    30}, 
/*  77 : W0001010        */ { B0,    35,  B0,    36,  B1,    35,  B1,    36}, 
/*  78 : W0001001        */ { B0,    33,  B0,    34,  B1,    33,  B1,    34}, 
/*  79 : W0001011        */ { B0,    37,  B0,    38,  B1,    37,  B1,    38}, 
/*  80 : W0000101        */ { B0,    47,  B0,    48,  B1,    47,  B1,    48}, 
/*  81 : W0001101        */ { B0,    31,  B0,    32,  B1,    31,  B1,    32}, 
/*  82 : W0101010        */ { B0,    51,  B0,    52,  B1,    W1,  B1,    52}, 
/*  83 : W0101001        */ { B0,    49,  B0,    W0,  B1,    49,  B1,    W0}, 
/*  84 : W0100110        */ {  W,M|1472,   W,M|1600,   W,M|1536,   W,M|1728}, 
/*  85 : W0100101        */ { B0,    59,  B0,    60,  B1,    59,  B1,    60}, 
/*  86 : W0101100        */ { B0,    55,  B0,    56,  B1,    55,  B1,    56}, 
/*  87 : W0101101        */ { B0,    57,  B0,    58,  B1,    57,  B1,    58}, 
/*  88 : W0010010        */ { B0,    53,  B0,    54,  B1,    53,  B1,    54}, 
/*  89 : W0011010        */ { B0,    63,  B0,S_ZERO,  B1,    63,  B1,S_ZERO}, 
/*  90 : W0011001        */ { B0,    61,  B0,    62,  B1,    61,  B1,    62}, 
/*  91 : W0011011        */ { W0, M|320,  W0, M|384,  W1, M|320,  W1, M|384}, 
/*  92 : W0010100        */ { B0,    39,  B0,    40,  B1,    39,  B1,    40}, 
/*  93 : W0010110        */ { B0,    43,  B0,    44,  B1,    43,  B1,    44}, 
/*  94 : W0010101        */ { B0,    41,  B0,    42,  B1,    41,  B1,    42}, 
/*  95 : W0110010        */ { W0, M|448,  W0, M|512,  W1, M|448,  W1, M|512}, 
/*  96 : W0110011        */ {  W, M|704,  W0, M|640,   W, M|768,  W1, M|640}, 
/*  97 : W0110100        */ { W0, M|576,   W, M|832,  W1, M|576,   W, M|896}, 
/*  98 : W0110110        */ {  W,M|1216,   W,M|1344,   W,M|1280,   W,M|1408}, 
/*  99 : W0110101        */ {  W, M|960,   W,M|1088,   W,M|1024,   W,M|1152}, 
/* 100 : W000000000      */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 101 : W000000010      */ {  W,M|1792, 103,     0, 104,     0, 105,     0}, 
/* 102 : W000000011      */ {  W,M|1856, 106,     0,   W,M|1920, 107,     0}, 
/* 103 : W00000001010    */ { W0,M|2112,  W0,M|2176,  W1,M|2112,  W1,M|2176}, 
/* 104 : W00000001001    */ { W0,M|1984,  W0,M|2048,  W1,M|1984,  W1,M|2048}, 
/* 105 : W00000001011    */ { W0,M|2240,  W0,M|2304,  W1,M|2240,  W1,M|2304}, 
/* 106 : W00000001110    */ { W0,M|2368,  W0,M|2432,  W1,M|2368,  W1,M|2432}, 
/* 107 : W00000001111    */ { W0,M|2496,  W0,M|2560,  W1,M|2496,  W1,M|2560}, 
/* 108 : B               */ {111,     0,   W,     3, 112,     0,   W,     2}, 
/* 109 : B0              */ {113,     0,   W,     1, 114,     0,   W,     4}, 
/* 110 : B1              */ { W0,     3,  W0,     2,  W1,     3,  W1,     2}, 
/* 111 : B00             */ {115,     0,   W,     6, 116,     0,   W,     5}, 
/* 112 : B01             */ { W0,     1,  W0,     4,  W1,     1,  W1,     4}, 
/* 113 : B000            */ {117,     0, 118,     0, 119,     0,   W,     7}, 
/* 114 : B001            */ { W0,     6,  W0,     5,  W1,     6,  W1,     5}, 
/* 115 : B0000           */ {120,     0, 121,     0, 122,     0, 123,     0}, 
/* 116 : B0001           */ {  W,     9,  W0,     7,   W,     8,  W1,     7}, 
/* 117 : B00000          */ {124,     0, 125,     0, 126,     0, 127,     0}, 
/* 118 : B00010          */ { W0,     9,  W0,     8,  W1,     9,  W1,     8}, 
/* 119 : B00001          */ {  W,    10, 128,     0,   W,    11,   W,    12}, 
/* 120 : B000000         */ {129,     0, 130,     0, 131,     0, 132,     0}, 
/* 121 : B000010         */ { W0,    10,  W0,    11,  W1,    10,  W1,    11}, 
/* 122 : B000001         */ {  W,    13, 133,     0, 134,     0,   W,    14}, 
/* 123 : B000011         */ {135,     0,  W0,    12, 136,     0,  W1,    12}, 
/* 124 : B0000000        */ {137,     0, 138,     0, 216, S_ERR, 139,     0}, 
/* 125 : B0000010        */ { W0,    13, 140,     0,  W1,    13, 141,     0}, 
/* 126 : B0000001        */ {142,     0, 143,     0, 144,     0, 145,     0}, 
/* 127 : B0000011        */ {146,     0,  W0,    14, 147,     0,  W1,    14}, 
/* 128 : B0000110        */ {  W,    15, 148,     0, 149,     0, 150,     0}, 
/* 129 : B00000000       */ {151,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 130 : B00000010       */ {  W,    18, 152,     0, 153,     0, 154,     0}, 
/* 131 : B00000001       */ {155,     0, 156,     0, 157,     0, 158,     0}, 
/* 132 : B00000011       */ {159,     0, 160,     0, 161,     0,   B,  M|64}, 
/* 133 : B00000110       */ {  W,    17, 162,     0, 163,     0, 164,     0}, 
/* 134 : B00000101       */ {165,     0, 166,     0, 167,     0,   W,    16}, 
/* 135 : B00001100       */ { W0,    15, 168,     0,  W1,    15, 169,     0},  
/* 136 : B00001101       */ {170,     0, 171,     0, 172,     0,   W,S_ZERO}, 
/* 137 : B000000000      */ {173,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 138 : B000000010      */ {  B,M|1792, 174,     0, 175,     0, 176,     0}, 
/* 139 : B000000011      */ {  B,M|1856, 177,     0,   B,M|1920, 178,     0}, 
/* 140 : B000001010      */ {  W,    23, 179,     0, 180,     0, 181,     0}, 
/* 141 : B000001011      */ {182,     0,  W0,    16, 183,     0,  W1,    16}, 
/* 142 : B000000100      */ { W0,    18, 184,     0,  W1,    18, 185,     0}, 
/* 143 : B000000110      */ {  W,    25, 186,     0, 187,     0, 188,     0}, 
/* 144 : B000000101      */ {189,     0, 190,     0, 191,     0,   W,    24}, 
/* 145 : B000000111      */ {192,     0,  B0,  M|64, 193,     0,  B1,  M|64}, 
/* 146 : B000001100      */ { W0,    17, 194,     0,  W1,    17, 195,     0}, 
/* 147 : B000001101      */ {196,     0, 197,     0, 198,     0,   W,    22}, 
/* 148 : B000011010      */ {  W,    20, 199,     0, 200,     0, 201,     0}, 
/* 149 : B000011001      */ {202,     0, 203,     0, 204,     0,   W,    19}, 
/* 150 : B000011011      */ {  W,    21,  W0,S_ZERO, 205,     0,  W1,S_ZERO}, 
/* 151 : B0000000000     */ {173,     0, 216, S_ERR,   W, S_EOL, 216, S_ERR}, 
/* 152 : B0000001010     */ {  W,    56, 206,     0, 207,     0,   W,    59}, 
/* 153 : B0000001001     */ {  W,    52, 208,     0, 209,     0,   W,    55}, 
/* 154 : B0000001011     */ {  W,    60,  W0,    24, 210,     0,  W1,    24}, 
/* 155 : B0000000100     */ { B0,M|1792,   B,M|1984,  B1,M|1792,   B,M|2048}, 
/* 156 : B0000000110     */ { B0,M|1856,  B0,M|1920,  B1,M|1856,  B1,M|1920}, 
/* 157 : B0000000101     */ {  B,M|2112,   B,M|2240,   B,M|2176,   B,M|2304}, 
/* 158 : B0000000111     */ {  B,M|2368,   B,M|2496,   B,M|2432,   B,M|2560}, 
/* 159 : B0000001100     */ { W0,    25, 211,     0,  W1,    25,   B, M|320}, 
/* 160 : B0000001110     */ {  W,    54, 212,     0, 213,     0, 214,     0}, 
/* 161 : B0000001101     */ {  B, M|384, 215,     0,   B, M|448,   W,    53}, 
/* 162 : B0000011010     */ {  W,    30,   W,    32,   W,    31,   W,    33}, 
/* 163 : B0000011001     */ {  W,    48,   W,    62,   W,    49,   W,    63}, 
/* 164 : B0000011011     */ {  W,    40,  W0,    22,   W,    41,  W1,    22}, 
/* 165 : B0000010100     */ { W0,    23,   W,    W0,  51,    23,   W,    51}, 
/* 166 : B0000010110     */ {  W,    57,   W,    61,   W,    58,   B, M|256}, 
/* 167 : B0000010101     */ {  W,    44,   W,    46,   W,    45,   W,    47}, 
/* 168 : B0000110010     */ {  B, M|128,   W,    26,   B, M|192,   W,    27}, 
/* 169 : B0000110011     */ {  W,    28,  W0,    19,   W,    29,  W1,    19}, 
/* 170 : B0000110100     */ { W0,    20,   W,    34,  W1,    20,   W,    35}, 
/* 171 : B0000110110     */ { W0,    21,   W,    42,  W1,    21,   W,    43}, 
/* 172 : B0000110101     */ {  W,    36,   W,    38,   W,    37,   W,    39}, 
/* 173 : B00000000000    */ {173,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/* 174 : B00000001010    */ { B0,M|2112,  B0,M|2176,  B1,M|2112,  B1,M|2176}, 
/* 175 : B00000001001    */ { B0,M|1984,  B0,M|2048,  B1,M|1984,  B1,M|2048}, 
/* 176 : B00000001011    */ { B0,M|2240,  B0,M|2304,  B1,M|2240,  B1,M|2304}, 
/* 177 : B00000001110    */ { B0,M|2368,  B0,M|2432,  B1,M|2368,  B1,M|2432}, 
/* 178 : B00000001111    */ { B0,M|2496,  B0,M|2560,  B1,M|2496,  B1,M|2560}, 
/* 179 : B00000101010    */ { W0,    44,  W0,    45,  W1,    44,  W1,    45}, 
/* 180 : B00000101001    */ { W0,    50,  W0,    51,  W1,    50,  W1,    51}, 
/* 181 : B00000101011    */ { W0,    46,  W0,    47,  W1,    46,  W1,    47}, 
/* 182 : B00000101100    */ { W0,    57,  W0,    58,  W1,    57,  W1,    58}, 
/* 183 : B00000101101    */ { W0,    61,  B0, M|256,  W1,    61,  B1, M|256}, 
/* 184 : B00000010010    */ { W0,    52,   B, M|640,  W1,    52,   B, M|704}, 
/* 185 : B00000010011    */ {  B, M|768,  W0,    55,   B, M|832,  W1,    55}, 
/* 186 : B00000011010    */ { B0, M|384,  B0, M|448,  B1, M|384,  B1, M|448}, 
/* 187 : B00000011001    */ {  B,M|1664,  B0, M|320,   B,M|1728,  B1, M|320}, 
/* 188 : B00000011011    */ {  B, M|512,  W0,    53,   B, M|576,  W1,    53}, 
/* 189 : B00000010100    */ { W0,    56,   B,M|1280,  W1,    56,   B,M|1344}, 
/* 190 : B00000010110    */ { W0,    60,   B,M|1536,  W1,    60,   B,M|1600}, 
/* 191 : B00000010101    */ {  B,M|1408,  W0,    59,   B,M|1472,  W1,    59}, 
/* 192 : B00000011100    */ { W0,    54,   B, M|896,  W1,    54,   B, M|960}, 
/* 193 : B00000011101    */ {  B,M|1024,   B,M|1152,   B,M|1088,   B,M|1216}, 
/* 194 : B00000110010    */ { W0,    48,  W0,    49,  W1,    48,  W1,    49}, 
/* 195 : B00000110011    */ { W0,    62,  W0,    63,  W1,    62,  W1,    63}, 
/* 196 : B00000110100    */ { W0,    30,  W0,    31,  W1,    30,  W1,    31}, 
/* 197 : B00000110110    */ { W0,    40,  W0,    41,  W1,    40,  W1,    41}, 
/* 198 : B00000110101    */ { W0,    32,  W0,    33,  W1,    32,  W1,    33}, 
/* 199 : B00001101010    */ { W0,    36,  W0,    37,  W1,    36,  W1,    37}, 
/* 200 : B00001101001    */ { W0,    34,  W0,    35,  W1,    34,  W1,    35}, 
/* 201 : B00001101011    */ { W0,    38,  W0,    39,  W1,    38,  W1,    39}, 
/* 202 : B00001100100    */ { B0, M|128,  B0, M|192,  B1, M|128,  B1, M|192}, 
/* 203 : B00001100110    */ { W0,    28,  W0,    29,  W1,    28,  W1,    29}, 
/* 204 : B00001100101    */ { W0,    26,  W0,    27,  W1,    26,  W1,    27}, 
/* 205 : B00001101101    */ { W0,    42,  W0,    43,  W1,    42,  W1,    43}, 
/* 206 : B000000101010   */ { B0,M|1408,  B0,M|1472,  B1,M|1408,  B1,M|1472}, 
/* 207 : B000000101001   */ { B0,M|1280,  B0,M|1344,  B1,M|1280,  B1,M|1344}, 
/* 208 : B000000100110   */ { B0, M|768,  B0, M|832,  B1, M|768,  B1, M|832}, 
/* 209 : B000000100101   */ { B0, M|640,  B0, M|704,  B1, M|640,  B1, M|704}, 
/* 210 : B000000101101   */ { B0,M|1536,  B0,M|1600,  B1,M|1536,  B1,M|1600}, 
/* 211 : B000000110010   */ { B0,M|1664,  B0,M|1728,  B1,M|1664,  B1,M|1728}, 
/* 212 : B000000111010   */ { B0,M|1024,  B0,M|1088,  B1,M|1024,  B1,M|1088}, 
/* 213 : B000000111001   */ { B0, M|896,  B0, M|960,  B1, M|896,  B1, M|960}, 
/* 214 : B000000111011   */ { B0,M|1152,  B0,M|1216,  B1,M|1152,  B1,M|1216}, 
/* 215 : B000000110110   */ { B0, M|512,  B0, M|576,  B1, M|512,  B1, M|576}, 
/* 216 : error state     */ {216,     0, 216,     0, 216,     0, 216,     0}, 
/* 217 : KillEol (0)     */ {219,     0, 218,     0, 217,     0, 217,     0}, 
/* 218 : KillEol (1)     */ {220,     0, 218,     0, 217,     0, 217,     0}, 
/* 219 : KillEol (2)     */ {221,     0, 218,     0, 217,     0, 217,     0}, 
/* 220 : KillEol (3)     */ {222,     0, 218,     0, 217,     0, 217,     0}, 
/* 221 : KillEol (4)     */ {223,     0, 218,     0, 217,     0, 217,     0}, 
/* 222 : KillEol (5)     */ {224,     0, 218,     0, 217,     0, 217,     0}, 
/* 223 : KillEol (6)     */ {225,     0, 218,     0, 217,     0, 217,     0}, 
/* 224 : KillEol (7)     */ {226,     0, 218,     0, 217,     0, 217,     0}, 
/* 225 : KillEol (8)     */ {227,     0, 218,     0, 217,     0, 217,     0}, 
/* 226 : KillEol (9)     */ {228,     0, 218,     0, 217,     0, 217,     0}, 
/* 227 : KillEol (10)    */ {228,     0, 218,     0,   0,     0, 217,     0}, 
/* 228 : KillEol (11)    */ {228,     0,  W0,     0,   0,     0,  W1,     0}
};

#define HIGHSET 0xff00
#define LOWSET  0x00ff
#define HIGHSHIFT 8
#define P       0x0100
#define VL3     0x0200
#define VL2     0x0300
#define VL1     0x0400
#define V0      0x0500
#define VR1     0x0600
#define VR2     0x0700
#define VR3     0x0800
#define H       0x0900
#define H0      0x0a00
#define H1      0x0b00
#define EOFB6   0x0c00
#define EOFB7   0x0d00
    
#define ERR     0x0f00

#define VL3V0   (VL3|(V0>>HIGHSHIFT))
#define VL2V0   (VL2|(V0>>HIGHSHIFT))
#define VL1V0   (VL1|(V0>>HIGHSHIFT))
#define V0V0    (V0|(V0>>HIGHSHIFT))
#define VR1V0   (VR1|(V0>>HIGHSHIFT))
#define VR2V0   (VR2|(V0>>HIGHSHIFT))
#define VR3V0   (VR3|(V0>>HIGHSHIFT))
#define PV0     (P|(V0>>HIGHSHIFT))

State MMRStates[9] = {
/*    0 : no bits       */ {  1,     0,  2,   V0,  3,    0,  0, V0V0},
/*    1 : 00            */ {  4,     0,  0,   H0,  0,    P,  0,   H1},
/*    2 : 0             */ {  5,     0,  0,  VL1,  0,    H,  0,  VR1},
/*    3 : 01            */ {  2,   VL1,  2,  VR1,  0,VL1V0,  0,VR1V0},
/*    4 : 0000          */ {  0, EOFB6,  0,  VL2,  6,    0,  0,  VR2},
/*    5 : 000           */ {  7,     0,  2,    P,  8,    0,  0,  PV0},
/*    6 : 000001        */ {  2,   VL3,  2,  VR3,  0,VL3V0,  0,VR3V0},
/*    7 : 00000         */ {  0, EOFB7,  0,  VL3,  0,  ERR,  0,  VR3},
/*    8 : 00001         */ {  2,   VL2,  2,  VR2,  0,VL2V0,  0,VR2V0}
};

//==============================================================================
const BYTE whitespace[256] =
{
    8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
};

void RawToChange(LPT4STATE lpt4s)
{
	LPWORD outptr = (LPWORD)lpt4s->lpbOut;
	LPBYTE inptr = lpt4s->lpbIn;
	LPBYTE inend = inptr + lpt4s->cbIn;
	WORD bitwidth = lpt4s->cbLine * 8;
	WORD currcolumn = lpt4s->wColumn;
	WORD currcolor = lpt4s->wColor;
	WORD currbit = lpt4s->wBit;
	BYTE currbyte;
	WORD space;
	
  if (inptr >= inend)
		goto inempty;
	if (currcolor)
		goto black;

white:
	if (currbyte = *inptr >> currbit)
	{
		space = whitespace[currbyte];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	    currbit -= (currcolumn-bitwidth);
	    goto eol;
		}

		*outptr++ = currcolumn;
	}

  else if ((currcolumn += (8-currbit)) >= bitwidth)
  {
  	currbit = 8 - (currcolumn - bitwidth);
		goto eol;
  }

  else
  {
		currbit = 0;
		while ((++inptr < inend) && (!*inptr))
		{
	    currcolumn += 8;
	    if (currcolumn >= bitwidth)
	    {
				currbit = 8-(currcolumn-bitwidth);
				goto eol;
	    }
		}
		if (inptr >= inend)
	    goto inempty;
		space = whitespace[*inptr];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	    currbit -= (currcolumn-bitwidth);
	    goto eol;
		}
		*outptr++ = currcolumn;
	}
  currcolor = 1;

black:

	if ((currbyte = ((signed char)*inptr) >> currbit) != 0xff)
	{
		space = whitespace[255-currbyte];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	  	currbit -= (currcolumn-bitwidth);
	    goto eol;
		}
		*outptr++ = currcolumn;
  }

  else if ((currcolumn += (8-currbit)) >= bitwidth)
  {
		currbit = 8 - (currcolumn - bitwidth);
		goto eol;
  }

  else
  {
		currbit = 0;
		while ((++inptr < inend) && (*inptr==0xff))
		{
			currcolumn += 8;
			if (currcolumn >= bitwidth)
			{
				currbit = 8-(currcolumn-bitwidth);
				goto eol;
			}
		}

		if (inptr >= inend)
			goto inempty;
		space = whitespace[255 - *inptr];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
			currbit -= (currcolumn-bitwidth);
			goto eol;
		}
		*outptr++ = currcolumn;
	}

	currcolor = 0;
	goto white;

eol:
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = (WORD)-1;
	*outptr++ = (WORD)-1;
	
	lpt4s->wBit = currbit;
	lpt4s->cbIn = (WORD)(((LPBYTE)inend) - ((LPBYTE)inptr));
	lpt4s->lpbIn = inptr;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->wColor = 0;
	lpt4s->wColumn = 0;
	lpt4s->wRet = RET_END_OF_LINE;
	return;

inempty:

	lpt4s->wBit = 0;
	lpt4s->cbIn = 0;
	lpt4s->lpbIn = inend;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->wColor = currcolor;
	lpt4s->wColumn = currcolumn;
	lpt4s->wRet = RET_INPUT_EMPTY1;
	return;
}

//==============================================================================
__inline void EncodeRun(LPRUNINFO ptr, LPWORD FAR *outptr, LPWORD currbit)
{
	WORD bits = ptr->bitsused;
  WORD data = ptr->data;

  if (!*currbit)
  {
		**outptr = data;
		*currbit = bits;
  }

  else
  {
		**outptr |= (data << *currbit);
		*currbit += bits;
		if (*currbit > 15)
		{
	    *++*outptr = data >> ((16 - (*currbit - bits)));
	    *currbit &= 15;
		}
	}
}

//==============================================================================
void MMRToChange(LPT4STATE lpt4s)
{
	nextinfo_t FAR *nextptr;
	BYTE currbyte;
	WORD size;
	short b1,b2;
	LPWORD x;

	// Load context
	LPBYTE inptr    =          lpt4s->lpbIn;
	LPWORD outptr   = (LPWORD) lpt4s->lpbOut;
	LPWORD refline  = (LPWORD) lpt4s->lpbRef;
	LPBYTE inend    =          lpt4s->lpbIn + lpt4s->cbIn;
	WORD state      =          lpt4s->wToggle;
	WORD bitwidth   =          lpt4s->cbLine * 8;
	WORD currbit    =          lpt4s->wBit;
	WORD currstate  =          lpt4s->wWord;
	WORD currcolumn =          lpt4s->wColumn;
	WORD currcolor  =          lpt4s->wColor;

	DEBUGMSG(dbg && lpt4s->wRet == RET_INPUT_EMPTY1,
		("IN:  Column %d, color %d, state %d, currstate %d, *ref = %d\n\r",
			currcolumn,currcolor,state,currstate,*refline));
			
	if (inptr >= inend)
	{
		switch (lpt4s->wRet)
		{
			case RET_END_OF_LINE:
			case RET_BEG_OF_PAGE:
				lpt4s->wRet = RET_INPUT_EMPTY2;
				break;
				
			default:
				lpt4s->wRet = RET_INPUT_EMPTY1;
				break;
		}
		DEBUGMSG(dbg,("Bailing 1 %d\n\r",lpt4s->wRet));
		return;
	}

	switch (lpt4s->wRet)
	{
		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:
			state = 0; // yes, fall through
		case RET_INPUT_EMPTY2:
			b1 = *refline;
			b2 = *(refline + 1);
			break;

		default:
			x = refline + currcolor;
			if ((b1 = *x++) <= (short)currcolumn)
			{
	    	x++;
	    	while ((b1 = *x++) <= (short)currcolumn)
	    	{
					x++;
					refline += 2;
				}
			}
			b2 = *x++;
			break;
	}
		
	if (currbit & 1)
	{
		currbit++;
		state = 0;
		currstate = 0;
		currcolor ^= 1;
		currcolumn = *outptr++ = b1;

		if (currcolumn < bitwidth)
		{
	  	x = refline+currcolor;
	  	if ((b1 = *x++) <= (short)currcolumn)
	  	{
				x++;
				while ((b1 = *x++) <= (short)currcolumn)
					{ x++; refline += 2; }
	    }
	    b2 = *x++;
		}

		else
		{
	  	currbit-=2;
	    goto eol;
		}
	} // end if (currbit & 1)
	
  if (currbit == 8)
  {
		currbit = 0;
		if (++inptr == inend)
		{
	    DEBUGMSG(dbg,("Bailing 2\n\r"));
	    currbit = (WORD)(-2); //adjusted +2 below
	    lpt4s->wRet = RET_INPUT_EMPTY1;
	    goto out;
		}
	}

	do // fetch bytes
	{
		currbyte = *inptr >> currbit;

		do // fetch bits
		{
	    if (!state)
	    {
				DEBUGMSG(dbg,("Currstate = %d\n\r",currstate));
				nextptr = &MMRStates[currstate].nextinf[currbyte & 3];
				currstate = nextptr->nextstate;
				DEBUGMSG(dbg,("Currstate set to %d\n\r",currstate));

				if (size = nextptr->size)
				{
		    	if (size & HIGHSET)
		    	{
						DEBUGMSG(dbg,("Taking high: %4.4x\n\r",size & HIGHSET));

						switch (size & HIGHSET)
						{
							case VL3:
							case VL2:
							case VL1:
							case V0:
							case VR1:
							case VR2:
							case VR3:
								currcolumn = b1+(size>>HIGHSHIFT)- (V0>>HIGHSHIFT);
								*outptr++ = currcolumn;
								currcolor^=1;
								break;
								
							case P:
								currcolumn = b2;
								break;
								
							case H:
								state = 1;
								currstate = (currcolor? B:W);
								break;
								
							case H0:
								state = 1;
								currstate = (currcolor? B0:W0);
								break;
								
							case H1:
								state = 1;
								currstate = (currcolor?B1:W1);
								break;
								
							case ERR:
								DEBUGMSG(dbg,("Bailing 3\n\r"));
								lpt4s->wRet = RET_DECODE_ERR;
								goto out;
								
							case EOFB6:
								state = 3;
								currstate = 6;
								break;
								
							case EOFB7:
								state = 3;
								currstate = 7;
								break;
								
						} // end switch (size & HIGHSET)
						
						size &= ~HIGHSET;

						if (currcolumn < bitwidth)
						{
			    		x = refline + currcolor;
			    		if ((b1 = *x++) <= (short)currcolumn)
			    		{
								x++;
								while ((b1 = *x++) <= (short)currcolumn)
								{
				    			x++;
				    			refline += 2;
								}
			    		}
			    		b2 = *x++;
						}

						else if (size & LOWSET)
						{
							currbit--;
							DEBUGMSG(dbg,("Bailing 4\n\r"));
							goto eol;
						}
		    	} // end if (size & HIGHSET)
		    	
		    	if (size & LOWSET)
		    	{
		    		DEBUGMSG(dbg,("Taking low : %4.4x\n\r", (size & LOWSET)<<HIGHSHIFT));

		    		switch ((size & LOWSET) << HIGHSHIFT)
		    		{
							case V0:
								currcolumn = *outptr++ = b1;
								currcolor^=1;
								break;
						}

						if (currcolumn >= bitwidth)
						{
							DEBUGMSG(dbg,("Taking new escape!\n\r"));
							goto eol;
						}
						
						size &= ~HIGHSET;
						x = refline + currcolor;
						DEBUGMSG(dbg,("Current column = %d, bitwidth = %d\n\r",
							currcolumn,bitwidth));

						if ((b1 = *x++) <= (short)currcolumn)
						{
			    		DEBUGMSG(dbg,("Looping, b1 = %d, *x = %d\n\r", b1,*x));
			   			x++;
			    		while ((b1 = *x++) <= (short)currcolumn)
			    		{
			    			DEBUGMSG(dbg,("Looping, b1 = %d, *x = %d\n\r", b1,*x));
								x++;
								refline += 2;
			    		}
						}
						b2 = *x++;
						
		    	} // end if (size & LOWSET)

				}
			}

			else if (state < 3)
			{
				DEBUGMSG(dbg,("MHCurrstate = %d (%d)\n\r",currstate,state));
				nextptr = &MHStates[currstate].nextinf[currbyte & 3];
				currstate = nextptr->nextstate;

				DEBUGMSG(dbg,("MHCurrstate set to %d\n\r",currstate));

				if (size = nextptr->size)
				{
					switch (size & ~SIZE_MASK)
		  		{
						case 0:
							currcolumn += size;
							if ((state == 2) || (currcolumn != bitwidth))
								*outptr++ = currcolumn;
							currcolor ^= 1;
							state = (state+1)%3;
							break;
					
						case SIZE_SPEC:
						  if (size == SIZE_SPEC)
						  {
								if ((state == 2) || (currcolumn != bitwidth))
							  	*outptr++ = currcolumn;
								currcolor ^= 1;
								state = (state+1)%3;
								break;
							}
							else
							{
								lpt4s->wRet = RET_SPURIOUS_EOL;
								goto out;
							}

						default:
					    currcolumn += size & SIZE_MASK;
					    break;
					    
		    	} 
				} // end if (size = nextptr->size)
		
				if (!state)
				{
		    	if (currcolumn < bitwidth)
		    	{
						x = refline + currcolor;
						b1 = *x++;
						while (b1 <= (short)currcolumn)
							{ x++; b1 = *x++; }
						b2 = *x++;
		   		}

		    	switch (currstate)
		    	{
						case W:
						case B:
					    currstate = W;
					    break;
					    
						case W0:
						case B0:
					    currstate = 2;
					    break;
					    
						case W1:
						case B1:
			    		currstate = 0;
					    if (currcolumn < bitwidth)
					    {
								currcolumn = *outptr++ = b1;
								currcolor^=1;
								if (currcolumn < bitwidth)
								{
							    x = refline + currcolor;
							    b1 = *x++;
							    while (b1 <= (short)currcolumn)
							    	{ x++; b1 = *x++; }
				    			b2 = *x++;
								}
			    		}

			    		else
			    		{
								currbit--;
								goto eol;
							}
		    		} // end switch (currstate)

					}
	    }

	    else 
	    {
				switch (currbyte & 3)
				{
		    	case 0:
		    		break;
		    		
		    	case 1:
						if ((currstate != 11) && (currstate != 23))
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 7\n\r"));
			   			goto out;
						}
						break;

		    	case 2:
						if ((currstate != 10) && (currstate != 22))
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 8\n\r"));
			    		goto out;
						}
						break;

		    	case 3:
						if (currstate != 23)
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 9\n\r"));
			    		goto out;
						}
						break;
				}

				currstate += 2;

				if (currstate >= 24)
				{
		    	DEBUGMSG(dbg,("Bailing 10\n\r"));
		    	inptr++; // consume last byte
		    	lpt4s->wRet = RET_END_OF_PAGE;
		    	goto out;
				}
	    }
eol:
		if (!state && (currcolumn == bitwidth))
		{
			DEBUGMSG(dbg,("Bailing 11\n\r"));
			lpt4s->wRet = RET_END_OF_LINE;
			*outptr++ = bitwidth;
			*outptr++ = bitwidth;
			*outptr++ = bitwidth;
			*outptr++ = (WORD)-1;
			*outptr++ = (WORD)-1;
			goto out;
    }

    else if (currcolumn > bitwidth)
    {
			DEBUGMSG(dbg,("Bailing 12\n\r"));
			lpt4s->wRet = RET_DECODE_ERR;
			goto out;
 	  }
	  currbyte >>= 2;

	} while ((currbit += 2) < 8); // fetch bits

	currbit = 0;

	} while (++inptr < inend); // fetch bytes
		
  currbit = (WORD) -2;
  lpt4s->wRet = RET_INPUT_EMPTY1;
  DEBUGMSG(dbg,("Bailing 13\n\r"));

out:

  if (currcolumn==bitwidth && lpt4s->wRet != RET_END_OF_LINE)
  	lpt4s->wRet = RET_INPUT_EMPTY2;

	if ((currcolumn == 0) && (currcolor == 0) && (lpt4s->wRet == RET_INPUT_EMPTY1))
		lpt4s->wRet = RET_INPUT_EMPTY2;

	lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
	lpt4s->lpbIn = inptr;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->lpbRef = (LPBYTE)refline;
	lpt4s->wBit = currbit+2;
	lpt4s->wWord = currstate;
	lpt4s->wColumn = currcolumn;
	lpt4s->wToggle = state;
	lpt4s->wColor = currcolor;
}

//==============================================================================
void MHToChange(LPT4STATE lpt4s)
{
	WORD size;
	BYTE currbyte;
	nextinfo_t FAR *nextptr;

  // Load context.
	LPBYTE inptr    =          lpt4s->lpbIn;
	LPWORD outptr   = (LPWORD) lpt4s->lpbOut;
	LPBYTE inend    =          lpt4s->lpbIn + lpt4s->cbIn;
	WORD bitwidth   =          lpt4s->cbLine * 8;
	WORD currbit    =          lpt4s->wBit;
	WORD currstate  =          lpt4s->wWord;
	WORD currcolumn =          lpt4s->wColumn;
	WORD ismkup     =          lpt4s->wColor;
	
  if (inptr >= inend)
  {
  	switch (lpt4s->wRet)
  	{
  		case RET_END_OF_LINE:
  		case RET_BEG_OF_PAGE:
  			lpt4s->wRet = RET_INPUT_EMPTY2;
  			break;
  			
  		default:
  			lpt4s->wRet = RET_INPUT_EMPTY1;
  			break;
  	}
  	return;
  }

  switch (lpt4s->wRet)
  {
  	case RET_END_OF_LINE:
  	case RET_BEG_OF_PAGE:
  	case RET_INPUT_EMPTY2:
  		switch (currstate)
  		{
  			case B0:
  			case W0:
  				currstate = 218;
  				break;
  				
  			default:
  				currstate = 217;
  				break;
  		}
  }
  
  if (currstate == 216)
		currstate = 217;

  if (currbit == 8)
  {
		currbit = 0;
		if (++inptr == inend)
		{
	    lpt4s->wRet = RET_INPUT_EMPTY1;
	    goto out;
		}
  }

  
  do // fetch bytes
  {
		currbyte = *inptr >> currbit;
		DEBUGMSG(dbg,("MH currbyte = %4.4x, currbit %d, cc %d\n\r",*inptr,currbit,currcolumn));

		do // fetch bits
		{
	    nextptr = &MHStates[currstate].nextinf[currbyte & 3];
	    currstate = nextptr->nextstate;
	    if (size = nextptr->size)
	    {
				switch (size & ~SIZE_MASK)
				{
					case 0:
						ismkup = 0;
						currcolumn += size;
						*outptr++ = currcolumn;
						break;

					case SIZE_MKUP:
						ismkup = 1;
						currcolumn += size & SIZE_MASK;
						break;

				  case SIZE_SPEC:
						switch (size)
						{
							case S_ZERO:
								if (*(outptr-1) != currcolumn || LOWORD(outptr) == lpt4s->wOffset)
									*outptr++ = currcolumn;
                else outptr--; // Back up one change on bogus zero runs. -RajeevD
								ismkup = 0;
								break;
									
							case S_ERR:
								lpt4s->wRet = RET_DECODE_ERR;
								goto out;
								
							case S_EOL:
								if (!currcolumn)
								{
									DEBUGMSG(dbg,("SPURIOUS EOL!\n\r"));
									lpt4s->wRet = RET_SPURIOUS_EOL;
								}
								else
								{
									currstate = 216;
									lpt4s->wRet = RET_DECODE_ERR;
								}
								goto out;

							default: DEBUGCHK (FALSE);
						}
						break;

					default: DEBUGCHK (FALSE);
					
				} // switch (size & ~SIZE_MASK)
	    }

			if ((currcolumn == bitwidth) && (*(outptr-1) == bitwidth))
			{
				*outptr++ = bitwidth;
				*outptr++ = bitwidth;
				*outptr++ = bitwidth;
				*outptr++ = (WORD)-1;
				*outptr++ = (WORD)-1;
			  lpt4s->wRet = RET_END_OF_LINE;
				goto out;
			}
			
	    currbyte >>= 2;

		} while ((currbit += 2) < 8); // fetch bits

		currbit = 0;

	} while (++inptr < inend); // fetch bytes


	 currbit = (WORD)-2; /* Since already done above */
	 lpt4s->wRet = RET_INPUT_EMPTY1;

out: // Save context.
	lpt4s->wBit    = currbit+2;
	lpt4s->cbIn   -= (WORD)(inptr - lpt4s->lpbIn);
	lpt4s->lpbIn   = inptr;
	lpt4s->lpbOut  = (LPBYTE)outptr;
	lpt4s->wWord   = currstate;
	lpt4s->wColumn = currcolumn;
	lpt4s->wColor  = ismkup;
}

//==============================================================================
#define MRMODE_INIT    0
#define MRMODE_GETEOL  1
#define MRMODE_1D      2
#define MRMODE_2D      3
#define MRMODE_GOTEOL  4
#define MRMODE_PENDERR 5

void MRToChange(LPT4STATE lpt4s)
{
	WORD mode = lpt4s->wMode;
	LPBYTE inptr, inend;
	WORD currbit, currbyte, count;
	
  if (!lpt4s->cbIn)
  {
		lpt4s->wRet = RET_INPUT_EMPTY1;
		return;
  }

	if (mode == MRMODE_PENDERR)
	{
    lpt4s->wMode = MRMODE_INIT;
    lpt4s->wRet = RET_DECODE_ERR;
    return;
	}
	
  if (mode == MRMODE_INIT || mode == MRMODE_GETEOL)
  {
	  inptr = lpt4s->lpbIn;
		inend = inptr + lpt4s->cbIn;
		currbit = lpt4s->wBit;
		count = lpt4s->wWord;

		do // fetch bytes
		{
	  	currbyte = *inptr >> currbit;

	    do // fetch bits
	    {    
				switch (currbyte & 3)
				{
		    	case 0:
						count+=2;
						break;
						
			    case 1:
						if (count >= 11)
						{
							mode = MRMODE_2D;
							lpt4s->wWord = 0;
							lpt4s->wRet = RET_END_OF_LINE;
							goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
							lpt4s->wMode = MRMODE_INIT;
							lpt4s->wWord = 1;
							goto eolseekerr;
						}
						else count = 1;
						break;
						
		    	case 2:
						if (count >= 10)
						{
			    		mode = MRMODE_GOTEOL;
			    		goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
					    lpt4s->wMode = MRMODE_INIT;
					    lpt4s->wWord = 0;
			    		goto eolseekerr;
						}
						else count = 0;
						break;
						
		    	case 3:
						if (count >= 11)
						{
					    mode = MRMODE_1D;
					    lpt4s->wRet = RET_INPUT_EMPTY1;
					    lpt4s->wWord = 0;
					    goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
					    lpt4s->wMode = MRMODE_INIT;
					    lpt4s->wWord = 0;
					    goto eolseekerr;
						}
						else count = 0;
						break;
						
					} // switch (currbyte & 3)
					
					currbyte >>= 2;

	    } while ((currbit += 2) < 8); // fetch bits

	    currbit = 0;

		} while (++inptr < inend); // fetch bytes

		lpt4s->wBit = 0;
		lpt4s->wMode = mode;
		lpt4s->wWord = count;
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
		lpt4s->wRet = RET_INPUT_EMPTY1;
		return;

eolseekerr:

		if ((lpt4s->wBit = currbit+2)==8)
		{
		    lpt4s->wBit = 0;
		    inptr++;
		}
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
		lpt4s->wRet = RET_DECODE_ERR;
		return;
	
processmr:

		if ((lpt4s->wBit = currbit+2)==8)
		{
	    lpt4s->wBit = 0;
	    inptr++;
		}
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
  }

  if (mode == MRMODE_GOTEOL)
  {
		BYTE bits = *lpt4s->lpbIn >> lpt4s->wBit;

		if (bits & 1)
		{
	    mode = MRMODE_1D;
	    lpt4s->wWord = (bits & 2 ? W1 : W0);
	    lpt4s->wRet = RET_INPUT_EMPTY1;
		} 
		else
		{
	    mode = MRMODE_2D;
	    if (bits & 2)
				lpt4s->wBit--;
	    else
				lpt4s->wWord = 2;
	    lpt4s->wRet = RET_END_OF_LINE;
		}
		
		if ((lpt4s->wBit += 2) == 8)
		{
	    lpt4s->wBit = 0;
	    lpt4s->lpbIn++;
	    lpt4s->cbIn--;
		}
  } // if (mode == 4)

  if (mode == MRMODE_1D)
  {
		MHToChange(lpt4s);
		if ((lpt4s->wRet == RET_END_OF_LINE)
		 || (lpt4s->wRet == RET_SPURIOUS_EOL))
    {
    	switch (lpt4s->wWord)
    	{
    		case W:
    		case B:
    			mode = MRMODE_GETEOL;
    			lpt4s->wWord = 0;
    			break;
    			
    		case W0:
    		case B0:
					mode = MRMODE_GETEOL;
					lpt4s->wWord = 1;
					break;
					
    		case W1:
    		case B1:
    		  mode = MRMODE_PENDERR;
    		  lpt4s->wWord = 0;
  				break;

  			default: DEBUGCHK (FALSE);
  		}		
		}
  }
  
	else if (mode == MRMODE_2D)
	{
		MMRToChange(lpt4s);
		if (lpt4s->wRet == RET_END_OF_LINE)
		{
	    if (lpt4s->wBit & 1)
	    {
	      // Found extra 1 bit.
				lpt4s->wBit++;
				lpt4s->wWord = 0;
				mode = MRMODE_PENDERR;
	    }
	    else 
	    {
    		switch (lpt4s->wWord)
    		{
    			case 0: lpt4s->wWord = 0; break;
    			case 2: lpt4s->wWord = 1; break;
    			default: DEBUGCHK (FALSE);
    		}
    		mode = MRMODE_GETEOL;
    	}
		}
  }
  
	if (lpt4s->wRet == RET_DECODE_ERR)
		mode = MRMODE_INIT;
	lpt4s->wMode = mode;
}

//==============================================================================
const BYTE blackstart[8] = {0x00,0xfe,0xfc,0xf8,0xf0,0xe0,0xc0,0x80};
const BYTE blackend[8]   = {0x00,0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f};

void ChangeToRaw(LPT4STATE lpt4s)
{
	WORD sbyte,ebyte,start,end;

	WORD    width =          lpt4s->cbLine;
	LPBYTE outptr =          lpt4s->lpbOut;
	LPWORD  inptr = (LPWORD) lpt4s->lpbIn;

	if (width>lpt4s->cbOut)
	{
		lpt4s->wRet = RET_OUTPUT_FULL;
		return;
	}

  lpt4s->wRet = RET_END_OF_LINE;
  lpt4s->cbOut -= width;
  _fmemset(outptr,0,width);
  width *= 8;

  while (*inptr != width)
  {
		start = *inptr & 7;
		sbyte = *inptr++ >>3;
		end   = *inptr & 7;
		ebyte = *inptr++ >>3;

		if (start)
		{
	    if (sbyte == ebyte)
	    {
				outptr[sbyte] |= blackstart[start] & blackend[end];
				continue;
	    }
	    else
				outptr[sbyte++] |= blackstart[start];
		}
		if (ebyte!=sbyte)
	    _fmemset(outptr + sbyte, 0xff, ebyte - sbyte);
		outptr[ebyte] |= blackend[end];
   }
}

//==============================================================================
void ChangeToMMR(LPT4STATE lpt4s)
{
	LPWORD refline, inptr, outptr, eoout;
	WORD bitwidth, currbit, currcolor, runsize;
	short a0,a1,a2,b1,b2;
	LPWORD x;
	
	a0 = lpt4s->a0;
	refline = (LPWORD)lpt4s->lpbRef;
	inptr = (LPWORD)lpt4s->lpbIn;
	outptr = (LPWORD)lpt4s->lpbOut;
	bitwidth = lpt4s->cbLine * 8;
	currbit = lpt4s->wBit;
	currcolor = lpt4s->wColor;
	*outptr = lpt4s->wWord;
	eoout = outptr + (lpt4s->cbOut/2)-(MMR_OUTPUT_SLACK/2);

	if (lpt4s->wRet == RET_END_OF_PAGE)
	{
		EncodeRun(&EOFB,&outptr,&currbit);
		EncodeRun(&EOFB,&outptr,&currbit);
		
		if (currbit)
		{
	    currbit = 0;
	    outptr++;
		}
		goto end;
	}

  a1 = *inptr;
  a2 = *(inptr+1);

	switch (lpt4s->wRet)
	{
		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:
			a0 = 0;
			b1 = *refline;
			b2 = *(refline+1);
			goto top2;

		default:
	 		a0 = lpt4s->a0;
		  if (a0 == (short)bitwidth)
		  {
				lpt4s->wRet = RET_END_OF_LINE;
				goto end;
		  }
			break;
	}

top:

  x = refline + currcolor;
  if ((b1 = *x++) <= a0)
  {
		x++;
		while ((b1 = *x++) <= a0)
		{
	    x++;
	    refline += 2;
		}
  }

  b2 = *x++;

top2:

  if (b2 < a1) // pass mode
  {
		EncodeRun (&PASS,&outptr,&currbit);
		a0 = b2;
  }

  else if ((a1+3>=b1) && (a1-3)<=b1) // vertical mode
  {
		EncodeRun (&VERT[b1-a1+3],&outptr,&currbit);
		currcolor ^= 1;
		a0 = a1;
		a1 = *++inptr;
		a2 = *(inptr+1);
  }

  else // horizontal mode
  {
		EncodeRun(&HORIZ, &outptr, &currbit);

		if (!currcolor)
		{
		  // Encode white run.
	    runsize = a1 - a0;
	    while (runsize >= 2560)
	    {
				EncodeRun(&WhiteMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);

      // Encode black run.
	    runsize = a2 - a1;
	    while (runsize >= 2560)
	    {
				EncodeRun(&BlackMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
			EncodeRun(&BlackTCode[runsize],&outptr,&currbit);
		}

		else
		{
			// Encode black run.
			runsize = a1 - a0;

	    while (runsize >= 2560)
	    {
				EncodeRun(&BlackMkup[39],&outptr,&currbit);
				runsize -= 2560;
			}
	    if (runsize >= 64)
	    {
				EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&BlackTCode[runsize],&outptr,&currbit);

      // Encode white run.
	    runsize = a2 - a1;
	    while (runsize >= 2560)
	    {
				EncodeRun(&WhiteMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);
		}

		a0 = a2;
		inptr += 2;
		a1 = *inptr;
		a2 = *(inptr+1);
  }

  if (outptr >= eoout)
  {
		lpt4s->wRet = RET_OUTPUT_FULL;
		goto end;
  }
  
  if (a0 < (short)bitwidth)
		goto top;
  lpt4s->wRet = RET_END_OF_LINE;

end:
	lpt4s->a0 = a0;
	lpt4s->wColor = currcolor;
	lpt4s->wWord = currbit ? *outptr : 0;
	lpt4s->wBit = currbit;
	lpt4s->lpbIn = (LPBYTE)inptr;
	lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->lpbRef = (LPBYTE)refline;
	return;
}

//==============================================================================
void ChangeToMH (LPT4STATE lpt4s)
{
	LPWORD inptr = (LPWORD)lpt4s->lpbIn;
	LPWORD outptr = (LPWORD)lpt4s->lpbOut;
	LPWORD eoout;
	WORD bitwidth = lpt4s->cbLine * 8;
	WORD currbit, currcolor, currcolumn, runsize;
	currbit = lpt4s->wBit;
	currcolumn = lpt4s->wColumn;
	currcolor = lpt4s->wColor;
	eoout = outptr + (lpt4s->cbOut/2)-(MH_OUTPUT_SLACK/2);
	*outptr = lpt4s->wWord;

	switch (lpt4s->wRet)
	{
		case RET_END_OF_PAGE:
	    if (currbit)
		    lpt4s->lpbOut+=2;
			*((LPWORD)lpt4s->lpbOut) = 0x8000;
			lpt4s->lpbOut += 2;
	    return;

		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:

	    if (lpt4s->nType == MH_DATA)
	    {
				if (currbit)
				{
		    	currbit = 0;
		    	outptr++;
				}
				*outptr++ = 0x8000;
	    }
	    break;
  }

  if (outptr > eoout)
		goto eooutput;

  if (currcolor)
		goto black;

white:

	currcolor = 1;
	runsize = *inptr - currcolumn;
	currcolumn = *inptr;
  while (runsize >= 2560)
  {
		EncodeRun(&WhiteMkup[39],&outptr,&currbit);
		runsize -= 2560;
  }
  if (runsize >= 64)
  {
		EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
		runsize &= 63;
  }
  EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);

  if (*inptr++ == bitwidth)
		goto eoln;
  if (outptr > eoout)
		goto eooutput;

black:

	currcolor = 0;
	runsize = *inptr - currcolumn;
	currcolumn = *inptr;

	while (runsize >= 2560)
	{
		EncodeRun(&BlackMkup[39],&outptr,&currbit);
		runsize -= 2560;
	}
	if (runsize >= 64)
	{
		EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
		runsize &= 63;
  }
  EncodeRun(&BlackTCode[runsize],&outptr,&currbit);

  if (*inptr++ == bitwidth)
		goto eoln;
  if (outptr > eoout)
		goto eooutput;
  goto white;

eoln:
    lpt4s->wColumn = 0;
    lpt4s->wColor = 0;
    lpt4s->wWord = currbit ? *outptr : 0;
    lpt4s->wBit = currbit;
    lpt4s->lpbIn = (LPBYTE)inptr;
    lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
    lpt4s->lpbOut = (LPBYTE)outptr;
    lpt4s->wRet = RET_END_OF_LINE;
    return;

eooutput:

    lpt4s->wColumn = currcolumn;
    lpt4s->wColor = currcolor;
    lpt4s->wWord = currbit ? *outptr : 0;
    lpt4s->wBit = currbit;
    lpt4s->lpbIn = (LPBYTE)inptr;
    lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
    lpt4s->lpbOut = (LPBYTE)outptr;
    lpt4s->wRet = RET_OUTPUT_FULL;
    return;
}

//==============================================================================
void ChangeToMR(LPT4STATE lpt4s)
{
	switch (lpt4s->wRet)
	{
		case RET_END_OF_PAGE:
		
	  	if (lpt4s->wBit)
	    {
				*((LPWORD)lpt4s->lpbOut) = lpt4s->wWord;
        lpt4s->lpbOut += 2;
			}
			*((LPWORD)lpt4s->lpbOut) = 0x8000;
			lpt4s->lpbOut += 2;
	    return;

		case RET_BEG_OF_PAGE:
		case RET_END_OF_LINE:
	    if (lpt4s->wBit)
	    {
				lpt4s->wBit = 0;
				*((LPWORD)lpt4s->lpbOut)++ = lpt4s->wWord;
				lpt4s->cbOut-=2;
	    }
	    *((LPWORD)lpt4s->lpbOut)++ = lpt4s->iKFactor ? 0x4000 : 0xc000;
	    lpt4s->cbOut -= 2;
	    lpt4s->wWord = 0;
	    break;
	}

  if (lpt4s->iKFactor)
		ChangeToMMR(lpt4s);
  else
		ChangeToMH(lpt4s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\hreext.h ===
// Extern functions declaration

#ifndef _HREEXT_
#define _HREEXT_

// Execute an RPL
void DoRPL (LPHRESTATE lpHREState, LPRPLLIST lpRPL);

BOOL InitDisplay (LPRESTATE, UINT);

// BitBlt: source is aligned, destination is not aligned
ULONG FAR PASCAL RP_BITMAP1TO1
(
	 LPVOID   lpContext,          // resource executor context
   USHORT   us_xoffset,         /* left offset of source bitmap */
   short    ul_row,             /* top row position */
   short    ul_col,             /* left column position */
   USHORT   ul_warp,            /* longs per scan line */
   USHORT   ul_height,          /* num of dot rows */
   USHORT   ul_width,           /* num of significant dot columns */
   ULONG FAR *pul_src,          /* bit map data to be copied */
   ULONG FAR *pul_pat,          /* pattern pointer */
   ULONG    ul_rop
);

// PatBlt
ULONG FAR PASCAL RP_FILLSCANROW
(
	LPRESTATE  lpRE,       // resource executor context
	USHORT     xDst,       // rectangle left
	USHORT     yDst,       // rectangle right
	USHORT     xExt,       // rectangle width
	USHORT     yExt,       // rectangle height
	UBYTE FAR* lpPat,      // 32x32 pattern bitmap
	DWORD      dwRop,      // raster operation
	LPVOID     lpBand,     // output band buffer
	UINT       cbLine,     // band width in bytes
	WORD       yBrush      // brush position offset
);

// Vertical Bitmaps
USHORT FAR PASCAL RP_BITMAPV
(
   USHORT  usRow,             /* Row to start Bitmap             */
   USHORT  usCol,             /* Column to Start Bitmap          */
   UBYTE   ubTopPadBits,      /* Bits to skip in the data stream */
   USHORT  usHeight,          /* Number of bits to draw          */
   UBYTE FAR  *ubBitmapData,  /* Data to draw                    */
   LPVOID  lpBits,            // output band buffer
   UINT    cbLine             // bytes per scan line
);

UINT RP_LineEE_Draw
(
	RP_SLICE_DESC FAR *slice,
	LPBITMAP lpbmBand
);
 
// Convert a line from endpoint form to slice form
void RP_SliceLine
(
   SHORT s_x1, SHORT s_y1,  // endpoint 1
   SHORT s_x2, SHORT s_y2,  // endpoint 2
   RP_SLICE_DESC FAR* lpsd, // output slice form of line
   UBYTE fb_keep_order      // keep drawing order on styled lines/
);

#endif // _HREEXT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\hretype.h ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/
//===========================================================================
// FILE                         HRETYPE.h
//
// MODULE                       HRE (Host Resource Executor Interface)
//
// PURPOSE                      provide specification of HRE interface
//
// DESCRIBED IN                 Resource Executor design spec
//                              Host resource executor interface design spec
//
// EXTERNAL INTERFACES          This file defines the interface exported by
//                              the HPRS for use by the D'Jumbo Driver and
//                              sleek product queue processors.
//
// INTERNAL INTERFACES          
//
// MNEMONICS                    
//
// HISTORY  01/18/92 mslin     created it.
//          04/15/92 mslin     added uiStatus in _RESDIR structure for dumbo
//
//===========================================================================

// --------------------------------------------------------------------------
// Data Type definition
// --------------------------------------------------------------------------

// Host Resource Store hash table
typedef struct _RESDIR
{
  UINT      uiStatus;           // Resource status, RS_RELEASE/RS_AVAILABLE
                                 //mslin, 4/15/92 for dumbo
  UINT      uiCount;
  LPFRAME   lpFrameArray;
}
	RESDIR, *PRESDIR, FAR *LPRESDIR;

// RPL link list, it will be executed in the sequence of store
typedef struct _RPLLIST
{
   struct _RPLLIST   FAR *lpNextRPL;
   LPFRAME           lpFrame;
   UINT              uiCount;
}
	RPLLIST, FAR *LPRPLLIST;

// state of Resource Executor
typedef struct
{
   LPSTR          lpBrushBuf;   // expanded brush buffer, 3/30/92 mslin
   LPBYTE         lpBrushPat;   // pointer to custom stock brush patterns
   BYTE           TiledPat[128];// buffer for 8x8 pattern tiled into 32x32
   LPJG_BM_HDR    lpCurBitmap;  // current bitmap resource
   ULONG FAR*     lpCurBitmapPtr;   // current bitmap resource
   ULONG FAR*     lpCurBrush;   // current brush resource
   LPJG_GS_HDR    lpCurGS;      // current glyph set
   LPJG_RES_HDR   lpCurRPL;     // current RPL
   SHORT          sCol;         // current column position
   SHORT          sRow;         // current row position
   LPBITMAP       lpBandBuffer; // band buffer ??? should we save ???
   SHORT          sCol2;        // 2nd current column position
   UBYTE          ubPenStyle;   // current pen style
   USHORT         usPenPhase;   // current pen phase
   WORD           wColor;       // pen color

   // BitBlt
   ULONG          ulRop;        // shifted ropcode
   UBYTE          ubRop;        // original ropcode
	 USHORT         usBrushWidth; // brush buffer
   UINT           yPat;         // brush offset
   
#ifdef WIN32
	 // GDI32 BitBlt
   LPVOID  lpBandSave;
   HDC     hdcDst, hdcSrc;
   HBITMAP hbmDef;
   HBRUSH  hbrDef;
   DWORD   dwRop;
#endif
   
}
	RESTATE, FAR *LPRESTATE;

typedef struct
{
   HANDLE      hHREState;     // handle
   SCOUNT      scDlResDir;    // size of download resource directory
   LPRESDIR    lpDlResDir;    // download resource directory
   LPRPLLIST   lpRPLHead;     // RPL list head
   LPRPLLIST   lpRPLTail;     // RPL list tail
   LPRESTATE   lpREState;     // RE rendering state

} HRESTATE, FAR *LPHRESTATE;

// Slice descriptor, line in slice form
typedef struct
{
   USHORT us_x1,us_y1;          /* location of first dot drawn in line */
   USHORT us_x2,us_y2;          /* location of last dot drawn in line */
   SHORT  s_dx_draw,s_dy_draw;  /* direction of slice drawing */
   SHORT  s_dx_skip,s_dy_skip;  /* direction of skip between slices */
   SHORT  s_dis;                /* slice discriminant, >=0 large, <0 small */
   SHORT  s_dis_lg,s_dis_sm;    /* large/small slice discriminant adjust */
   USHORT us_first,us_last;     /* length of first and last slice in pels */
   USHORT us_n_slices;          /* number of intermediate slices */
   USHORT us_small;             /* length small slice (large is implicit) */
}
   RP_SLICE_DESC;               /* prefix "sd" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\jres.h ===
/*---------------------------------------------------------------------------
 JRES.H -- Jumbo Resource definitions

 Bert Douglas  6/10/91    Adapted for use in printer
 mslin         2/15/92    Adapted for use in Host Resource Executor
                          Baseline 3.0
*/

/*---------------------------------------------------------------------------
 Resource Section
/*---------------------------------------------------------------------------
*/

#include <pshpack2.h>		// BKD 1997-7-9: added

/* Resource Header */
typedef struct 
{
      UID         ulUid;        /* shortened version of uid */
      USHORT      usClass;      /* shortened version of class */
} 
   JG_RES_HDR, *PJG_RES_HDR, FAR *LPJG_RES_HDR;

/* resource state codes */

#define JG_RES_STATE_DEFAULT ((UBYTE) 0x00)
#define JG_RES_STATE_RELEASE ((UBYTE) 0x01)
#define JG_RES_STATE_RETAIN  ((UBYTE) 0x02)
#define JG_RES_STATE_MAX     ((UBYTE) 0x03)


/* usClass Resource Description */

#define JG_RS_NULL   ( (UBYTE) 0x00 )   /* Null                       */
#define JG_RS_GLYPH  ( (UBYTE) 0x01 )   /* Glyph Set                  */
#define JG_RS_BRUSH  ( (UBYTE) 0x02 )   /* Brush                      */
#define JG_RS_BITMAP ( (UBYTE) 0x03 )   /* Horizontal Bitmap          */
#define JG_RS_RPL    ( (UBYTE) 0x04 )   /* Redner Primitive List      */
#define JG_RS_SPL    ( (UBYTE) 0x05 )   /* Supervisory Primitive List */
#define JG_RS_MAX    ( (UBYTE) 0x06 )   /* Non-inclusive limit        */

/*---------------------------------------------------------------------------
 JG_RS_GS (Glyph Set) Resource Definitions
*/

typedef struct 
{
   JG_RES_HDR  ResHdr;              /* resource header             */
   USHORT      usGlyphs;         /* count of glyphs in resource */
   USHORT      ausOffset[1];     /* table of offsets to the glyphs */
} *PJG_GS_HDR, FAR *LPJG_GS_HDR, JG_GS_HDR;

   
typedef struct 
{
   USHORT      usHeight;
   USHORT      usWidth;
   ULONG       aulPels[1];       /* start of pixel array */
} *PJG_GLYPH, FAR *LPJG_GLYPH, G_GLYPH;


/*---------------------------------------------------------------------------
 Brush Resource Definitions
*/

typedef struct 
{
   JG_RES_HDR  ResHdr;              /* resource header */
   ULONG       aulPels[32];      /* bitmap array */
} *PJG_BRUSH, FAR *LPJG_BRUSH, JG_BRUSH;

typedef struct
{
   JG_RES_HDR  ResHdr;
   UBYTE       ubCompress;
   UBYTE       ubLeft;
   USHORT      usHeight;
   USHORT      usWidth;
   ULONG       aulPels[1];
} *PJG_BM_HDR, FAR *LPJG_BM_HDR, JG_BM_HDR;


/*---------------------------------------------------------------------------
 Render Primitives Section
/*---------------------------------------------------------------------------
*/

/* RPL (Render Primitive List) Header */
typedef struct 
{
   JG_RES_HDR  ResHdr;           //resource header
   USHORT      usTopRow;         //top row, banding
   USHORT      usBotomRow;       //bottom row, banding
   USHORT      usLongs;          //number of long parm
   USHORT      usShorts;         //number of short parm
   USHORT      usBytes;          //number of byte parm
   ULONG       ulParm[1];      //start of long parm
} *PJG_RPL_HDR, FAR *LPJG_RPL_HDR, JG_RPL_HDR;


/* RP Opcode Definition */

#define JG_RP_SetRowAbsS       ( (UBYTE) 0x00 )
#define JG_RP_SetRowRelB       ( (UBYTE) 0x01 )
#define JG_RP_SetColAbsS       ( (UBYTE) 0x02 )
#define JG_RP_SetColRelB       ( (UBYTE) 0x03 )
#define JG_RP_SetExtAbsS       ( (UBYTE) 0x04 )
#define JG_RP_SetExtRelB       ( (UBYTE) 0x05 )

#define JG_RP_SelectL          ( (UBYTE) 0x10 )
#define JG_RP_SelectS          ( (UBYTE) 0x11 )
#define JG_RP_SelectB          ( (UBYTE) 0x12 )
#define JG_RP_Null             ( (UBYTE) 0x13 )
#define JG_RP_End              ( (UBYTE) 0x14 )
#define JG_RP_SetRop           ( (UBYTE) 0x15 )
#define JG_RP_SetPenStyle      ( (UBYTE) 0x16 )
#define JG_RP_ShowText         ( (UBYTE) 0x17 )
#define JG_RP_ShowField        ( (UBYTE) 0x18 )
#define JG_RP_SetRopAndBrush   ( (UBYTE) 0x19 )
#define JG_RP_SetPatternPhase  ( (UBYTE) 0x1A )

#define JG_RP_LineAbsS1        ( (UBYTE) 0x20 )
#define JG_RP_LineAbsSN        ( (UBYTE) 0x21 )
#define JG_RP_LineRelB1        ( (UBYTE) 0x22 )
#define JG_RP_LineRelBN        ( (UBYTE) 0x23 )
#define JG_RP_LineSlice        ( (UBYTE) 0x24 )
#define JG_RP_StylePos         ( (UBYTE) 0x25 )


#define JG_RP_FillRow1         ( (UBYTE) 0x30 )
#define JG_RP_FillRowD         ( (UBYTE) 0x31 )

#define JG_RP_RectB            ( (UBYTE) 0x40 )
#define JG_RP_RectS            ( (UBYTE) 0x41 )

#define JG_RP_BitMapHI         ( (UBYTE) 0x50 )
#define JG_RP_BitMapHR         ( (UBYTE) 0x51 )
#define JG_RP_BitMapV          ( (UBYTE) 0x52 )

#define JG_RP_GlyphB1          ( (UBYTE) 0x60 )
#define JG_RP_GlyphS1          ( (UBYTE) 0x61 )
#define JG_RP_GlyphBD          ( (UBYTE) 0x62 )
#define JG_RP_GlyphSD          ( (UBYTE) 0x63 )
#define JG_RP_GlyphBDN         ( (UBYTE) 0x64 )

#define JG_RP_WedgeB           ( (UBYTE) 0x70 )
#define JG_RP_WedgeS           ( (UBYTE) 0x71 )

/* fbEnds */
#define JG_NO_FIRST_PEL  ( (UBYTE) (1<<0) )   /* first pel excluded      */
#define JG_NO_LAST_PEL   ( (UBYTE) (1<<1) )   /* last pel excluded       */

#include <poppack.h>		// BKD 1997-7-9: added
/* End --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\jtypes.h ===
/*---------------------------------------------------------------------------
 JTYPES.H -- Jumbo basic type definitions

 Chia-Chi Teng 5/23/91    Created (for use in Jasm assembler)
 Bert Douglas  6/10/91    Adapted for use in printer
*/

#ifndef jtypes_h
#define jtypes_h

#ifndef FAR
#define FAR far
#endif
#ifndef NEAR
#define NEAR near
#endif
#ifndef WINAPI
#define WINAPI 
#endif

/*---------------------------------------------------------------------------
 Variable naming conventions

   -------   ------   ----------------------------------------------------
   Typedef   Prefix   Description
   -------   ------   ----------------------------------------------------
   SBYTE     b        8 bit signed integer
   SHORT     s        16 bit signed integer
   SLONG     l        32 bit signed integer

   UBYTE     ub       8 bit unsigned integer
   USHORT    us       16 bit unsigned integer
   ULONG     ul       32 bit unsigned integer

   BFIX      bfx      8 bit (4.4) signed fixed point number
   SFIX      sfx      16 bit (12.4) signed fixed point number
   LFIX      lfx      32 bit (28.4) signed fixed point number

   UBFIX     ubfx     8 bit (4.4) unsigned fixed point number
   USFIX     usfx     16 bit (12.4) unsigned fixed point number
   ULFIX     ulfx     32 bit (28.4) unsigned fixed point number

   FBYTE     fb       set of 8 bit flags
   FSHORT    fs       set of 16 bit flags

   BPOINT    bpt      byte index into the point table (UBYTE)
   SPOINT    spt      short index into the point table (USHORT)

   BCOUNT    bc       8 bit "count" of objects
   SCOUNT    sc       16 bit "count" of objects
   LCOUNT    lc       32 bit "count" of objects
                      The number of objects is one more than the "count".
                      There must be at least one object.

   UID       uid      32 bit unique identifier
   -------   ------   ----------------------------------------------------
*/

typedef char                SBYTE, BFIX;
typedef unsigned char       FBYTE, UBYTE, BPOINT, BCOUNT, UBFIX;
typedef short               SFIX, SHORT;
typedef unsigned short      USHORT, FSHORT, SPOINT, SCOUNT, USFIX;
typedef long                LFIX, SLONG;
typedef unsigned long       ULONG, LCOUNT, ULFIX, UID;

#endif /* jtypes_h */

/* End --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\devconst.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: DEVCONST.BLT
;
; Device-specific constants.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

;	MAX_BLT_SIZE is the maximum stack space required for the BITBLT
;	code.  This is a hard number to compute.  It must be based on
;	the worst case situation:
;
;		worst phase alignment
;		worst color conversions
;		first byte present
;		last byte present
;		full inner loop
;		jump into the inner loop
;
;	and any other factor which could increase the size of the code.


MAX_BLT_SIZE	=	452		;Max stack space a BLT will require


ifdef	GEN_COLOR_BLT
;	The following flags are used in the inner loops to both control
;	the EGA read/write enable registers, and the plane loop count.
;
;	They are based on a simple relationship of the EGA's Map Mask
;	register and Read Map Select Register when used as a three plane
;	system:
;
;	Map Mask:     D3 D2 D1 D0	   Read Map: D2 D1 D0
;
;	  C0 plane     0  0  0	1		      0  0  0
;	  C1 plane     0  0  1	0		      0  0  1
;	  C2 plane     0  1  0	0		      0  1  0
;
;
;	Note that to convert the map mask into a read mask for the
;	same plane only requires a "SHR x,1" instruction.  This trick
;	would not work if all four planes were used.
;
;	In four plane mode, when the above mapping occurs becomes:
;
;	  C3 plane     1  0  0	0		      1  0  0
;
;	  To map this into the correct read map register of 11b:
;
;		cmp	mask,100b	;Set 'C' if not C3
;		adc	mask,-1 	;sub -1 only if C3
;
;
;
;	The "loop counter" will consist of a bit shifted left every
;	interation of the loop, which will be used as stated above.
;	When this bit mask reaches a predetermined value, the loop
;	will terminate.


COLOR_OP	equ	C0_BIT		;Color operations start with C0
MONO_OP		equ	MONO_BIT 	;Mono operations start with mono bit

ifdef	FOUR_PLANE
END_OP		equ	(C3_BIT+MONO_BIT) SHL 1	;Loop terminating bits
else
END_OP		equ	(C2_BIT+MONO_BIT) SHL 1	;Loop terminating bits
endif





;	dl_moore_flags
;
;	dl_moore_flags pertain to color conversion only.  If color
;	conversion doesn't apply to the BLT, these flags will not
;	be defined.
;
;
;	F1_REP_OK		When F1_REP_OK is set, then the innerloop code can
;			use a REP MOVSx instruction.  This will be the
;			case if:
;
;			a)  The source is the EGA and the color compare
;			    register can be used to do the conversion
;			    from color to monochrome.
;
;			b)  The source is monochrome, the background
;			    color white, and the foreground color black,
;			    in which case color converison of the source
;			    would just give the source.
;
;	F1_NO_MUNGE 	Set under the same conditions as "b" above.


F1_REP_OK	equ	10000000b	;Using REP is ok (when F0_GAG_CHOKE)
F1_NO_MUNGE 	equ	01000000b	;No mono ==> color conversion table
;		equ	00100000b
;		equ	00010000b
;		equ	00001000b
;		equ	00000100b
;		equ	00000010b
;		equ	00000001b

endif	;GEN_COLOR_BLT


	page

;	The DEV structure contains all the information taken from the
;	PDevices passed in.  PDevices are copied to the frame to reduce
;	the number of long pointer loads required.  Having the data
;	contained in the structure allows MOVSW to be used when copying
;	the data.
;
;	width_bits	The number of pixels wide the device is.
;
;	height		The number of scans high the device is.
;
;	width_b		The width of a scan in bytes.
;
;	lp_bits		The pointer to the actual bits of the device.
;			It will be adjusted as necessary to point to the
;			first byte to be modified by the BLT operation.
;
;	plane_w		Width of one plane of data.  Only used if the
;			device is a small color bitmap.
;
;	seg_index	Index to get to the next segment of the bitmap.
;			Only defined if the bitmap is a huge bitmap.
;
;	scans_seg	Number of scan lines per 64K segment.  Only
;			defined if the bitmap is a huge bitmap.
;
;	fill_bytes	Number of unused bytes per 64K segment.  Only
;			defined if the bitmap is a huge bitmap.
;
;	dev_flags	Device Specific Flags
;			SPANS_SEG   - BLT will span 64K segment of the device
;			IS_DEVICE   - This is the physical device
;			COLOR_UP    - Generate color scan line update
;			IS_COLOR    - Device is a color device
;
;	comp_test	JC or JNC opcode, used in the huge bitmap scan line
;			update code.  This opcode is based on whether the
;			BLT is Y+, or Y-.
;
;	comp_value	Range of addresses to compare the offset against
;			to determine if overflow occured.  comp_test is the
;			conditional jump to use for no overflow after doing
;			a compare with the offset register and this value.
;
;	next_scan	Bias to get to the next (previous) scan line.


DEV		struc

  width_bits	dw	?		;Width in bits
  height	dw	?		;Height in scans
  width_b	dw	?		;Width in bytes
  lp_bits	dd	?		;Pointer to the bits
  plane_w	dw	?		;Increment to next plane
  seg_index	dw	?		;Index to next segment if huge bitmap
  scans_seg	dw	?		;Scans per segment if huge
  fill_bytes	dw	?		;Filler bytes per segment if huge
  dev_flags	db	?		;Device flags as given above
  comp_test	db	?		;JC or JNC opcode
  comp_value	dw	?		;Huge bitmap overflow range
  next_scan	dw	?		;Index to next scan

DEV		ends


;	Constants for use in dev_flags field of DEV structure:

IS_COLOR 	equ	00000001b	;Device is color
IS_DEVICE	equ	00000010b	;Physical Device
COLOR_UP 	equ	00000100b	;Color scan line update
SPANS_SEG	equ	10000000b	;BLT spans a segment boundary

OFF_LP_BITS	equ	wptr lp_bits	;Offset  portion of lp_bits
SEG_LP_BITS	equ	wptr lp_bits+2	;Segment portion of lp_bits
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\dorpl.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         DORPL.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Convert A-form to B-form for jumbo driver
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
//
// HISTORY  1/17/92 mslin       extracted functions from cartrige JUMBO.C
//                              and then modified.
//				03/09/92 dstseng	  RP_FillScanRow -> RP_FILLSCANROW (.asm)
//				03/10/92 dssteng	  add one parameter SrcxOrg to RP_BITMAP1TO1()
//										  to handle the case xOffset <> 0
//				03/11/92 dstseng	  <3> optimize fill rect. by calling RP_FILLSCANROW()	
//              05/21/92 mslin  Add DUMBO compiled switch for Fixed memory
//                              because real time interrupt routine will call
//                              hre when printing in real-time rendering mode
//          08/18/92 dstseng    @1 fix bug that trashed the value of usPosOff
//          08/21/92 dstseng    @2 fix a inadvertent bug in BitMapHI
//          10/12/92 dstseng    @3 fix "Glyph range checking" bug
//          11/12/92 dstseng    @4 special treatment for hollow brush
//          11/12/92 dstseng    @5 fix bug in command ShowText & ShowField
//          09/27/93 mslin      add BuildPcrDirectory600() for Spicewood 6.
//
//
//===========================================================================

// Include files
//
#include <ifaxos.h>
#include <resexec.h>

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c
#include "hreext.h"     // declaration extern global var. and extern func.
#include "multbyte.h"   // define macros to take care of byte ordering
#include "stllnent.h"   // declare style line functions.

#ifdef DEBUG
DBGPARAM dpCurSettings = {"RESEXEC"};
#endif

#define Brush40Gray (ULONG)0x8140     /* all black */

extern const WORD wRopTable[256];
extern BYTE BrushPat[72][8];

#define ASSERT(cond,mesg) if (cond) {DEBUGMSG (1, mesg); goto EndRPL;}

// functions prototypes
static   void  RP_NewRop (LPRESTATE lpRE, UBYTE ubRop);
static   int   SelectResource(LPHRESTATE lpHREState, UINT uid);
extern   void  GetTotalPixels (RP_SLICE_DESC FAR* psdSlice);
extern   BOOL  OpenBlt     (LPRESTATE, UINT);
extern   BOOL  SetBrush    (LPRESTATE);
extern   void  CloseBlt    (LPRESTATE);

//---------------------------------------------------------------------------
void

DoRPL
(
   LPHRESTATE lpHREState,       // far pointer to current job context
                                // corresponding to the job HANDLE
   LPRPLLIST lpRPLList          // pointer to RPL list
)
// PURPOSE                      Execute a Render Primitive List (RPL)
//                              which is a list of RPL block.
//                              
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          None visible outside of HRE.
//
// UNRESOLVED ISSUES            programmer development notes
//
//---------------------------------------------------------------------------       
{
   LPBITMAP          lpbmBand;
   LPRESTATE         lpRE;
   UBYTE      FAR*   lpub;
   USHORT     FAR*   lpus;
   ULONG      FAR*   lpul;
   UBYTE      FAR*   lpubLimit;
   LPJG_RPL_HDR      lpRPL;
   USHORT            usTop;
   USHORT            yBrush;
   USHORT            iGlyph;
   LPFRAME           lpFrame;
   LPRESDIR          lpResDir;
   SHORT             sLoopCount;
   RP_SLICE_DESC     slice;

   lpRPL = (LPJG_RPL_HDR)lpRPLList->lpFrame->lpData;
   usTop = GETUSHORT(&lpRPL->usTopRow);
   yBrush = usTop & 0x001F;
   // 08/06/92 dstseng, Because band is not always 32x, 
   // We have difficulty to paint our brush with correct offset
   // Unless We have a variable to keep the offset of usTop.
   
   lpRE = lpHREState->lpREState;
   lpbmBand = lpRE->lpBandBuffer;

   if (!OpenBlt (lpRE, yBrush))
   	return;

#ifdef MARSHAL

      lpFrame = lpRPLList->lpFrame;

      /* interpret the RPL, get parm list ptrs */
      lpul = (ULONG FAR*)((++lpFrame)->lpData);
      lpus = (USHORT FAR*)((++lpFrame)->lpData);
      lpub = (UBYTE FAR*)((++lpFrame)->lpData); 
      /* get resource limit address */
      lpubLimit = (UBYTE FAR*)(lpub + lpFrame->wSize);

#else
 
      /* interpret the RPL, get parm list ptrs */
      lpul = (ULONG FAR*)(lpRPL->ulParm);
      lpus = (USHORT FAR*) (GETUSHORT(&lpRPL->usLongs) * 4 +
                      (UBYTE FAR*)(lpul));
      lpub = (UBYTE FAR*) (GETUSHORT(&lpRPL->usShorts) * 2 +
                      (UBYTE FAR*)(lpus));
      /* get resource limit address */
      lpubLimit = (UBYTE FAR*)lpRPL + lpRPLList->lpFrame->wSize + 1;

#endif

      // if first time call then initialize state variables ???
      /* state variables */
      /* Set to default value at beginning of each RPL. */
      /* The order of RPL execution is not specified and there must not be */
      /* any dependency on the previous RPL. */
      lpRE->sRow = 0 - usTop;    //mslin 3/14/92 ccteng
      lpRE->sCol = lpRE->sCol2 = 0;
      lpRE->ubPenStyle = 0;  /* set solid line */
      lpRE->usPenPhase = 0;  /* restart the pattern */

      /* no current glyph set */
      lpRE->lpCurGS = NULL;
      SelectResource(lpHREState, Brush40Gray);
      lpRE->lpCurBitmap = NULL;

      /* set default ROP */
      RP_NewRop(lpRE, 0x88);

      while (1)
      {
      	if (lpub > lpubLimit)
      	{
         	DEBUGMSG (1, ("HRE: Execution past end of RPL."));
					goto EndRPL;
		}
				
         switch ( *lpub++ )
         {
         /* 0x00 - 0x05 */
         case JG_RP_SetRowAbsS:
            /* long row setting */
            lpRE->sRow = GETUSHORTINC(lpus);
            lpRE->sRow -= usTop;
            break;

         case JG_RP_SetRowRelB:
            lpRE->sRow += (SBYTE)*lpub++;
            break;

         case JG_RP_SetColAbsS:
            /* short column setting */
            lpRE->sCol = GETUSHORTINC(lpus);
            break;

         case JG_RP_SetColRelB:
            lpRE->sCol += (SBYTE)*lpub++;
            break;

         case JG_RP_SetExtAbsS:
            lpRE->sCol2 = GETUSHORTINC(lpus);
               break;

         case JG_RP_SetExtRelB:
            lpRE->sCol2 += (SBYTE)*lpub++;
               break;

         /* 0x10 - 0x1A */

         case JG_RP_SelectS:
            /* make resource current */
            if (!SelectResource(lpHREState, GETUSHORT(lpus)))
               goto EndRPL;   // select resource failure
            lpus++;
            break;

         case JG_RP_SelectB:
            /* make resource current */
            if (!SelectResource(lpHREState, *lpub))
               goto EndRPL;   // select resource failure
            lpub += 1;
            break;

         case JG_RP_Null:
         case JG_RP_End:
            goto EndRPL;

         case JG_RP_SetRop:
            /* raster op setting */
            RP_NewRop(lpRE, *lpub++);
            break;

         case JG_RP_SetPenStyle:
            // if (lpREState->ubPenStyle != *lpub)
            //   lpREState->usPenPhase = 0;  /* restart the pattern */
            lpRE->ubPenStyle = *lpub++;
            break;

#if 0
         case JG_RP_ShowText:   
            {
            UBYTE ubCount;
            lpub++;             // ubFontCode  @5
            ubCount = *lpub++;   // ubNChars
            lpub += ubCount;    // ubCharCode ...  @5
            break;
            }

         case JG_RP_ShowField:
            lpub++;             // ubFontCode  @5
            lpus++;             // usFieldCode @5
            break;
#endif

         case JG_RP_SetRopAndBrush :
            RP_NewRop (lpRE, *lpub++);
            /* make resource current */
            if (!SelectResource(lpHREState, GETUSHORT(lpus)))
               goto EndRPL;   // select resource failure
            lpus++;
            break;

         case JG_RP_SetPatternPhase :
            lpRE->usPenPhase = GETUSHORTINC(lpus);
            break;

         /* 0x20 - 0x23 */
         case JG_RP_LineAbsS1:
         {
            USHORT   usX, usY;

            /* draw line */
            usY = GETUSHORTINC(lpus);     // absolute row
            usY -= usTop;
            usX = GETUSHORTINC(lpus);     // absolute col
            
            ASSERT ((lpRE->sRow < 0) || (lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
              ("HRE: LineAbsS1 y1 = %d\r\n", lpRE->sRow));
            ASSERT ((usY >= (WORD) lpbmBand->bmHeight),
              ("HRE: LineAbsS1 y2 = %d\r\n", usY));

            RP_SliceLine (lpRE->sCol, lpRE->sRow, usX , usY, &slice, lpRE->ubPenStyle);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
                RP_LineEE_Draw(&slice, lpbmBand);
            /* update current position */
            lpRE->sRow = usY;
            lpRE->sCol = usX;
            break;
         }
         
         case JG_RP_LineRelB1:
         {
            SHORT sX, sY;

            /* draw line */
            sY = lpRE->sRow + (SBYTE)*lpub++;    // delta row
            sX = lpRE->sCol + (SBYTE)*lpub++;    // delta col
            
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
            	("HRE: LineRelB1 y1 = %d\r\n", lpRE->sRow));
            ASSERT ((sY < 0 || sY >= (SHORT)lpbmBand->bmHeight),
            	("HRE: LineRelB1 y2 = %d\r\n", sY));
            
            RP_SliceLine (lpRE->sCol, lpRE->sRow, sX , sY, &slice, lpRE->ubPenStyle);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
                RP_LineEE_Draw(&slice, lpbmBand);
            /* update current position */
            lpRE->sRow = sY;
            lpRE->sCol = sX;
            break;
         }
     
         case JG_RP_LineSlice:
            {
            USHORT us_trow, us_tcol;
            us_trow = *lpub++;
            slice.us_n_slices = *lpub++;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dy_skip = us_tcol;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dx_skip = us_tcol;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dy_draw = us_tcol;
            us_tcol = us_trow;                us_tcol &= 3; us_tcol -= 1;
            slice.s_dx_draw = us_tcol;
            slice.s_dis    = GETUSHORTINC(lpus);
            slice.s_dis_lg = GETUSHORTINC(lpus);
            slice.s_dis_sm = GETUSHORTINC(lpus);
            slice.us_first = GETUSHORTINC(lpus);
            slice.us_last  = GETUSHORTINC(lpus);
            slice.us_small = GETUSHORTINC(lpus);
            slice.us_x1 = lpRE->sCol;
            slice.us_y1 = lpRE->sRow;
            slice.us_x2 = lpRE->sCol;
            slice.us_y2 = lpRE->sRow;
            GetTotalPixels(&slice);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
               RP_LineEE_Draw(&slice, lpbmBand);
            break;
            }

         case JG_RP_FillRowD:

            lpRE->sCol  += (SBYTE)*lpub++; 
            lpRE->sCol2 += (SBYTE)*lpub++;
           
            // Yes, this should fall through!

         case JG_RP_FillRow1:

            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
          		("HRE: FillRow1 y1 = %d\r\n", lpRE->sRow));
          	ASSERT ((lpRE->sCol2 - lpRE->sCol <= 0),
            	("HRE: FillRow1 Width <= 0"));

            RP_FILLSCANROW
            (
            	lpRE, lpRE->sCol, lpRE->sRow, (USHORT)(lpRE->sCol2 - lpRE->sCol), 1,
              (LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            lpRE->sRow++;
            break;

         /* 0x40 - 0x41 */
         case JG_RP_RectB:
         {
            UBYTE ubHeight = *lpub++;
            UBYTE ubWidth  = *lpub++;

            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
            	("HRE: RectB y1 = %d\r\n", lpRE->sRow));
            ASSERT ((lpRE->sRow + ubHeight > (SHORT)lpbmBand->bmHeight),
                ("HRE: RectB y2 = %d\r\n", lpRE->sRow + ubHeight));

            RP_FILLSCANROW
            (
            	lpRE, lpRE->sCol, lpRE->sRow, ubWidth, ubHeight,
            	(LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            break;
         }

         case JG_RP_RectS:
         {
            USHORT   usHeight = *lpus++;
            USHORT   usWidth  = *lpus++;            

            ASSERT ((lpRE->sCol < 0 || lpRE->sCol >= (SHORT) lpbmBand->bmWidth),
                ("HRE: RectS xLeft = %d\r\n", lpRE->sCol));
            ASSERT ((lpRE->sCol + (SHORT)usWidth> (SHORT) lpbmBand->bmWidth),
                ("HRE: RectS xRight = %d\r\n", lpRE->sCol + usWidth));
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
                ("HRE: RectS yTop = %d\r\n", lpRE->sRow));
            ASSERT ((lpRE->sRow + (SHORT)usHeight > (SHORT)lpbmBand->bmHeight),
                ("HRE: RectS yBottom = %d\r\n", lpRE->sRow + usHeight));

            RP_FILLSCANROW
						(
							lpRE, lpRE->sCol,	lpRE->sRow, usWidth, usHeight,
							(LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            break;
         }

         case JG_RP_BitMapHI:
         {
            UBYTE    ubCompress;
            UBYTE    ubLeft;
            USHORT   usHeight;
            USHORT   usWidth;
            ULONG FAR *ulBitMap;

            ubCompress = *lpub++;
            ubLeft = *lpub++;
            usHeight = GETUSHORTINC(lpus);
            usWidth = GETUSHORTINC(lpus);
            // ulBitMap = (ULONG FAR *)GETULONGINC(lpul);
            ulBitMap = lpul;

            RP_BITMAP1TO1
            ( 
              lpRE,
              (USHORT) ubLeft,
              (USHORT) lpRE->sRow,
              (USHORT) (lpRE->sCol + ubLeft),
              (USHORT) ((usWidth+ubLeft+0x1f) >>5),
              (USHORT) usHeight,
              (USHORT) usWidth,
              (ULONG FAR *) ulBitMap,
              (ULONG FAR *) lpRE->lpCurBrush,
              lpRE->ulRop
            );
            lpul += usHeight * ((usWidth + ubLeft + 0x1F) >> 5);  // @2
            break;

         }

         case JG_RP_BitMapHR:
         {
            LPJG_BM_HDR lpBmp;
            UBYTE    ubCompress;
            UBYTE    ubLeft;
            USHORT   usHeight;
            USHORT   usWidth;
            ULONG FAR *ulBitMap;

            lpBmp = lpRE->lpCurBitmap;
			if (NULL == lpBmp)
			{
				// this is unexpected case.
				// the automatic tools warn us against this option
				// check windows bug# 333678 for details.
				// the simple cure: exit the function!
				goto EndRPL;
			}

            ubCompress = lpBmp->ubCompress;
            ubLeft = lpBmp->ubLeft;
            usHeight = GETUSHORT(&lpBmp->usHeight);
            usWidth = GETUSHORT(&lpBmp->usWidth);
            ulBitMap = lpRE->lpCurBitmapPtr;

            // Special case band bitmap.
            if (ulBitMap == (ULONG FAR*) lpbmBand->bmBits)
            	break;

            // Call bitblt.
            RP_BITMAP1TO1
            (
              lpRE,
              (USHORT) ubLeft,
              (USHORT) lpRE->sRow,
              (USHORT) (lpRE->sCol + ubLeft),
              (USHORT) ((usWidth+ubLeft+0x1f) >>5),
              (USHORT) usHeight,
              (USHORT) usWidth,
              (ULONG FAR *) ulBitMap,
              (ULONG FAR *) lpRE->lpCurBrush,
              lpRE->ulRop
            );
            break;

         }
         case JG_RP_BitMapV:
         {
            UBYTE      ubTopPad;
            USHORT     usHeight;

            ubTopPad = *lpub++;
            usHeight = GETUSHORTINC(lpus);

            ASSERT ((lpRE->sRow - (SHORT)usHeight + 1 < 0 ||
                lpRE->sRow - (SHORT)usHeight + 1 >= (SHORT)lpbmBand->bmHeight),
                ("HRE: BitmapV y1 = %d\r\n", lpRE->sRow + usHeight));
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
              ("HRE: BitmapV y2 = %d\r\n", lpRE->sRow));

            lpub += RP_BITMAPV (lpRE->sRow, lpRE->sCol, ubTopPad, 
              usHeight, lpub, lpbmBand->bmBits, lpbmBand->bmWidthBytes);
            lpRE->sCol--;
            break;
         }

         /* 0x60 - 0x63 */
         case JG_RP_GlyphB1:
            iGlyph = (USHORT)*lpub++;
            sLoopCount = 1;
            goto  PlaceGlyph;

         case JG_RP_GlyphBD:
            lpRE->sRow += (SBYTE)*lpub++;
            lpRE->sCol += (SBYTE)*lpub++;
            iGlyph = (USHORT)*lpub++;
            sLoopCount = 1;
            goto PlaceGlyph;

         case JG_RP_GlyphBDN:
            sLoopCount = *lpub++;
            lpRE->sRow += (SBYTE)*lpub++;
            lpRE->sCol += (SBYTE)*lpub++;
            iGlyph = (USHORT)*lpub++;
            goto PlaceGlyph;

      PlaceGlyph:
      {
         SHORT       i;

         /* render the glyph */
         lpResDir = (LPRESDIR)(lpRE->lpCurGS);
         ASSERT ((!lpResDir), ("No selected glyph set!"));
         lpFrame = (LPFRAME)(lpResDir->lpFrameArray);

         for (i = 1; i <= sLoopCount; i++)
         {
            LPJG_GLYPH lpGlyph;
            ULONG FAR *lpSrc;

						
#ifndef MARSHAL
                LPJG_GS_HDR lpGh  = (LPJG_GS_HDR) (lpFrame->lpData);

                // Check that glyph index is within bounds.
                if (iGlyph >= lpGh->usGlyphs)
                {
                	RETAILMSG(("WPSFAXRE DoRpl glyph index out of range!\n"));
                	iGlyph = 0;
                }
             
                lpGlyph = (LPJG_GLYPH) (((UBYTE FAR*) &lpGh->ResHdr.ulUid)
                      + GETUSHORT(&(lpGh->ausOffset[iGlyph])));
                lpSrc = (ULONG FAR *)&lpGlyph->aulPels[0];
#else
                lpGlyph = (LPJG_GLYPH)(lpFrame[(iGlyph+1) << 1].lpData);
                lpSrc = (ULONG FAR*)(lpFrame[((iGlyph+1) << 1) + 1].lpData);
#endif

             RP_BITMAP1TO1
             (
               lpRE,
               (USHORT)0,
               (USHORT)lpRE->sRow,
               (USHORT)lpRE->sCol,
               (USHORT) ((lpGlyph->usWidth + 31) / 32),
               (USHORT) lpGlyph->usHeight,
               (USHORT) lpGlyph->usWidth,
               (ULONG FAR *) lpSrc,
               (ULONG FAR *)lpRE->lpCurBrush,
               (ULONG)lpRE->ulRop
             );

             if (i != sLoopCount)
             {
                // only GlyphBDN comes here 
                lpRE->sRow += (SBYTE)*lpub++;
                lpRE->sCol += (SBYTE)*lpub++;
                iGlyph = (USHORT)*lpub++;
             }
         }
         break;
      }

      default:

      	ASSERT ((TRUE), ("Unsupported RPL command."));
      }
   }

EndRPL:

	CloseBlt (lpRE);
}

// PRIVATE FUNCTIONS
//---------------------------------------------------------------------------
static
void                        
RP_NewRop
(
	LPRESTATE lpRE,  
	UBYTE ubRop                  // one byte ROP code from driver, this
                               // ROP should be convert to printer ROP code
                               // in this routine
)
// PURPOSE                      set new ROP value, also do conversion
//                              since value 1 is black in printer
//                              while value 0 is black in display
//                              
//---------------------------------------------------------------------------       
{
   lpRE->usBrushWidth = 0; // reset pattern width

   lpRE->ubRop = ubRop;         // save old Rop code

   ubRop = (UBYTE) (
           (ubRop>>7&0x01) | (ubRop<<7&0x80) |
           (ubRop>>5&0x02) | (ubRop<<5&0x40) |
           (ubRop>>3&0x04) | (ubRop<<3&0x20) |
           (ubRop>>1&0x08) | (ubRop<<1&0x10)
           );
   ubRop = (UBYTE)~ubRop;

   lpRE->ulRop = ((ULONG) ubRop) << 16;
   
#ifdef WIN32
   lpRE->dwRop = lpRE->ulRop | wRopTable[lpRE->ubRop];
#endif

}
	 
//==============================================================================
void TileBrush (LPBYTE lpbPat8, LPDWORD lpdwPat32)
{
	UINT iRow;
	
	for (iRow = 0; iRow < 8; iRow++)
	{
		DWORD dwRow = *lpbPat8++;
		dwRow |= dwRow << 8;
		dwRow |= dwRow << 16;

		lpdwPat32[iRow]      = dwRow;
		lpdwPat32[iRow + 8]  = dwRow;
		lpdwPat32[iRow + 16] = dwRow;
		lpdwPat32[iRow + 24] = dwRow;
	}
}

//---------------------------------------------------------------------------
static
int
SelectResource
(
   LPHRESTATE lpHREState,      // far pointer to current job context
                               // corresponding to the job HANDLE
   UINT uid                     // specified resource uid.
)
// PURPOSE                      given a resource block pointer
//                              set this resource as current resource
//                              only glyph, brush and bitmap can be
//                              selected.
//---------------------------------------------------------------------------       
{
   LPRESDIR          lprh;
   LPRESDIR          lpResDir;
   LPJG_RES_HDR      lprh1;
   ULONG FAR         *lpBrSrc;
   LPFRAME           lpFrame;
   USHORT            usClass;
   LPRESTATE         lpRE = lpHREState->lpREState;
   
   lpRE->wColor = (uid == 0x8100)? 0x0000 : 0xFFFF;
   
   // Trap stock brushes.
   if ( uid & 0x8000 )
   {
     UINT iBrush = (uid < 0x8100)? uid - 0x8000 : uid - 0x8100 + 6;
		 if (lpRE->lpBrushPat)
       lpRE->lpCurBrush = (LPDWORD) (lpRE->lpBrushPat + 128*iBrush);
		 else
		 {
       lpRE->lpCurBrush = (LPDWORD) lpRE->TiledPat;
       TileBrush (BrushPat[iBrush], lpRE->lpCurBrush);
     }

     SetBrush (lpRE);
	   return SUCCESS;
   }
   
   /* must be downloaded resource */
   lprh = (&lpHREState->lpDlResDir[uid]);

   if ((lpResDir = (LPRESDIR)lprh) == NULL)
      return(FAILURE);

   lprh1 = (LPJG_RES_HDR)lpResDir->lpFrameArray->lpData;

   usClass = GETUSHORT(&lprh1->usClass);
   switch (usClass)
   {

   case JG_RS_GLYPH:
      lpRE->lpCurGS = (LPJG_GS_HDR)lprh;
      break;

   case JG_RS_BRUSH:
      lpFrame = (LPFRAME)(lpResDir->lpFrameArray);

#ifdef MARSHAL
      lpBrSrc = (ULONG FAR *)((++lpFrame)->lpData);
#else
      {
         LPJG_BRUSH  lpBr = (LPJG_BRUSH)(lpFrame->lpData);
         lpBrSrc = (ULONG FAR *)(lpBr->aulPels);
      }
#endif
     
      lpRE->lpCurBrush = (ULONG FAR *)lpBrSrc;
      SetBrush (lpRE);
      break;

   case JG_RS_BITMAP:
      lpFrame = (LPFRAME)(lpResDir->lpFrameArray);
      lpRE->lpCurBitmap = (LPJG_BM_HDR)(lpFrame->lpData);
      lpFrame++;

#ifdef MARSHAL      
         lpRE->lpCurBitmapPtr = (ULONG FAR *)(lpFrame->lpData);
#else
         lpRE->lpCurBitmapPtr = (ULONG FAR *)lpRE->lpCurBitmap->aulPels;
#endif

   default:
      break;
    }
    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\multbyte.h ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         multbyte.h
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      
//    This file defines macros to allow processor independent 
//    manipulation of (possibly "foreign") multibyte records.
//
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
// 
// HISTORY  1/17/92 mslin       created
//
//===========================================================================
    
#define GETUSHORT(p) (*p)
#define GETULONG(p) (*p)
#define GETUSHORTINC(a)   GETUSHORT((a)); a++  /* Do NOT parenthesize! */
#define GETULONGINC(a)    GETULONG((a)); a++  /* Do NOT parenthesize! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

	subttl	Raster Operation Definitions
	page


;	Raster Op Definitions
;
;
;	The include file COMMENT.BLT contains a good description
;	of the encoding of the raster operations.  It should be
;	read before examining the definitions that follow.
;
;	The sixteen-bit number indicating which raster Op is to be
;	performed is encoded in the following manner:


EPS_OFF	=	0000000000000011b	;Offset within parse string
EPS_INDEX =	0000000000011100b	;Parse string index
LogPar	=	0000000000100000b	;(1 indicates implied NOT as Logop6)
LogOp1	=	0000000011000000b	;Logical Operation #1
LogOp2	=	0000001100000000b	;Logical Operation #2
LogOp3	=	0000110000000000b	;Logical Operation #3
LogOp4	=	0011000000000000b	;Logical Operation #4
LogOp5	=	1100000000000000b	;Logical Operation #5


;	The parity bit is used to encode an optional sixth logical operation
;	which will always be a "NOT".  In most cases this is used to get an
;	even number of "NOT"s so that reduction can take place (two sequential
;	trailing "NOT"s cancel each other out and thus are eliminated).



;	Each LogOp (Logical Operation) is encoded as follows:

LogNOT	=	00b			;NOT result
LogXOR	=	01b			;XOR result with next operand
LogOR	=	10b			;OR  result with next operand
LogAND	=	11b			;AND result with next operand



;	The parse string is a string which contains the operands for
;	the logical operation sequences (source, destination, pattern).
;	The logic opcodes are applied to the current result and the next
;	element of the given string (unless the LogOp is a NOT which only
;	affects the result).
;
;	The string is encoded as eight two-bit numbers indicating which
;	operand is to be used

opDefs		struc
  OpSpec	db	?		  ;Special Operand as noted below
  OpSrc 	db	?		  ;Operand is source field
  OpDest	db	?		  ;Operand is destination field
  OpPat 	db	?		  ;Operand is pattern field
opDefs		ends



;	The special operand is used for a few rops that would not fit into
;	an RPN format.	On the first occurance of an OpSpec, the current result
;	is "PUSHED", and the next operand is loaded.  On the second occurance
;	of the OpSpec, the given logic operation is performed between the
;	current result and the "PUSHED" value.
;
;	**NOTE**  Since there can be no guarantee that the client will call
;	the BLT routine with one of the 256 published raster ops, it is
;	possible that a value might be "PUSHED" and then never "POPPED".
;	If these "PUSHES" are made to the stack, then care must be made to
;	remove the "PUSHED" value.
;
;	In any case, since the raster op was not one of the published
;	"magic numbers", the BLT can be aborted or the result can be
;	computed to the extent possible.  The only restriction is that it
;	must not crash the system (i.e. don't leave extra stuff on the stack).
;
;		Simply: Compute garbage, but don't crash!




;	Define the parse strings to be allocated later.
;
;	An example parse string for the pattern "SDPSDPSD" would be
;	"0110110110110110b"


parseStr0	=	07AAAh		;src,pat,dest,dest,dest,dest,dest,dest
parseStr1	=	079E7h		;src,pat,dest,src,pat,dest,src,pat
parseStr2	=	06DB6h		;src,dest,pat,src,dest,pat,src,dest
parseStr3	=	0AAAAh		;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4	=	0AAAAh		;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5	=	04725h		;src,spec,src,pat,spec,dest,src,src
parseStr6	=	04739h		;src,spec,src,pat,spec,pat,dest,src
parseStr7	=	04639h		;src,spec,src,dest,spec,pat,dest,src



;	The following equates are for certain special functions that are
;	derived from the very first string (index of SpecParseStrIndex).
;
;	These strings will have their innerloops special cased for
;	speed enhancements (i.e MOVSx and STOSx for pattern copys and
;	white/black fill, and MOVSx for source copy if possible)

PAT_COPY 	equ	0021h		;P    - dest = Pattern
NOTPAT_COPY	equ	0001h		;Pn   - dest = NOT Pattern
FILL_BLACK	equ	0042h		;DDx  - dest = 0 (black)
FILL_WHITE	equ	0062h		;DDxn - dest = 1
SOURCE_COPY	equ	0020h		;S    - dest = source


	errnz	LogXOR-01b		;These must hold true for above equates
	errnz	LogOp1-0000000011000000b
	errnz	LogPar-0000000000100000b
	errnz	parseStr0-7AAAh 	;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ	0	;Special cased strings index


if @Version LT 600
if2
  %out	Static Raster Operations
endif
else
  %out	Static Raster Operations
endif



;	The raster operation table consists of a word for each of
;	the first 128 raster operations (00 through 7F).  The second
;	half of the raster operations (FF through 80) are the inverse
;	of the first half.
;
;	The table is encoded as follows:
;
;	    N S P LLL OOOOOOOOOO
;	    | | |  |	  |
;	    | | |  |	  |_____  Offset of code from roptable.
;	    | | |  |
;	    | | |  |____________  Length index
;	    | | |
;	    | | |_______________  Pattern is present
;	    | |
;	    | |_________________  Source is present
;	    |
;	    |___________________  Generate trailing NOT
;
;
;	To map the ROPS 80h through FFh to 00h through 7Fh, take the
;	1's complement of the ROP, and invert 'N' above.
;
;
;	Notes:
;
;	    1)	An offset of 0 is reserved for source copy.  This
;		was done to reduce the number of LLLs to 8, so that
;		the above encoding could fit into a 16-bit integer.
;
;
;	    2)	LLL only allows a maximum of 8 different template sizes!
;		Actual length is at roptable+256+LLL.
;
;
;
;
;	ROP is the macro that generates the equates which will be
;	stored into the roptable as specified above.
;
;	Usage:
;
;	    ROPDEF	Pattern,Number
;
;	Where
;
;	    Pattern	Is the RPN definition of the raster operation.
;			It is used as the label of the first byte of
;			the template.  It also is used to determine
;			is there is a (S)ource, (P)attern, and if the
;			final result is to be (n)egated.
;
;	    Number	is the boolean result of the raster operation
;			based on a P=F0, S=CC, and D=AA.  These labels
;			and indexes can be found in the file COMMENT.BLT
;
;			Since there are many equivelent boolean expresions,
;			some of the rops will not match the label given.
;			The label is for reference only.  The final result
;			is what counts.



ROPOffset	equ	0000001111111111b
ROPLength	equ	0001110000000000b
SOURCE_PRESENT	equ	0010000000000000b
PATTERN_PRESENT	equ	0100000000000000b
NEGATE_NEEDED	equ	1000000000000000b


;	Define the eight template length indices.

ROPLen2  	equ	0
ROPLen3  	equ	1
ROPLen4  	equ	2
ROPLen5  	equ	3
ROPLen7  	equ	4
ROPLen9  	equ	5
ROPLen11 	equ	6
ROPLen13 	equ	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\roptable.c ===
/*==============================================================================
This table generates the low word of a 32-bit ROP from an 8-bit ROP.

11-Jun-93    RajeevD    Created
==============================================================================*/

const unsigned short wRopTable[256] = 
{
	0x0042, // 0 (BLACKNESS)
	0x0289, // DPSoon
	0x0C89, // DPSona
	0x00AA, // PSon
	0x0C88, // SDPona
	0x00A9, // DPon
	0x0865, // PDSxnon
	0x02C5, // PDSaon
	0x0F08, // SDPnaa
	0x0245, // PDSxon
	0x0329, // DPna
	0x0B2A, // PSDnaon
	0x0324, // SPna
	0x0B25, // PDSnaon
	0x08A5, // PDSonon
	0x0001, // Pn
	0x0C85, // PDSona
	0x00A6, // DSon (NOTSRCERASE)
	0x0868, // SDPxnon
	0x02C8, // SDPaon
	0x0869, // DPSxnon
	0x02C9, // DPSaon
	0x5CCA, // PSDPSanaxx
	0x1D54, // SSPxDSxaxn
	0x0D59, // SPxPDxa
	0x1CC8, // SDPSanaxn
	0x06C5, // PDSPaox
	0x0768, // SDPSxaxn
	0x06CA, // PSDPaox
	0x0766, // DSPDxaxn
	0x01A5, // PDSox
	0x0385, // PDSoan
	0x0F09, // DPSnaa
	0x0248, // SDPxon
	0x0326, // DSna
	0x0B24, // SPDnaon
	0x0D55, // SPxDSxa
	0x1CC5, // PDSPanaxn
	0x06C8, // SDPSaox
	0x1868, // SDPSxnox
	0x0369, // DPSxa
	0x16CA, // PSDPSaoxxn
	0x0CC9, // DPSana
	0x1D58, // SSPxPDxaxn
	0x0784, // SPDSoax
	0x060A, // PSDnox
	0x064A, // PSDPxox
	0x0E2A, // PSDnoan
	0x032A, // PSna
	0x0B28, // SDPnaon
	0x0688, // SDPSoox
	0x0008, // Sn (NOTSRCCOPY)
	0x06C4, // SPDSaox
	0x1864, // SPDSxnox
	0x01A8, // SDPox
	0x0388, // SDPoan
	0x078A, // PSDPoax
	0x0604, // SPDnox
	0x0644, // SPDSxox
	0x0E24, // SPDnoan
	0x004A, // PSx
	0x18A4, // SPDSonox
	0x1B24, // SPDSnaox
	0x00EA, // PSan
	0x0F0A, // PSDnaa
	0x0249, // DPSxon
	0x0D5D, // SDxPDxa
	0x1CC4, // SPDSanaxn
	0x0328, // SDna (SRCERASE)
	0x0B29, // DPSnaon
	0x06C6, // DSPDaox
	0x076A, // PSDPxaxn
	0x0368, // SDPxa
	0x16C5, // PDSPDaoxxn
	0x0789, // DPSDoax
	0x0605, // PDSnox
	0x0CC8, // SDPana
	0x1954, // SSPxDSxoxn
	0x0645, // PDSPxox
	0x0E25, // PDSnoan
	0x0325, // PDna
	0x0B26, // DSPnaon
	0x06C9, // DPSDaox
	0x0764, // SPDSxaxn
	0x08A9, // DPSonon
	0x0009, // Dn, // DSTINVERT
	0x01A9, // DPSox
	0x0389, // DPSoan
	0x0785, // PDSPoax
	0x0609, // DPSnox
	0x0049, // DPx (PATINVERT)
	0x18A9, // DPSDonox
	0x0649, // DPSDxox
	0x0E29, // DPSnoan
	0x1B29, // DPSDnaox
	0x00E9, // DPan
	0x0365, // PDSxa
	0x16C6, // DSPDSaoxxn
	0x0786, // DSPDoax
	0x0608, // SDPnox
	0x0788, // SDPSoax
	0x0606, // DSPnox
	0x0046, // DSx (SRCINVERT)
	0x18A8, // SDPSonox
	0x58A6, // DSPDSonoxxn
	0x0145, // PDSxxn
	0x01E9, // DPSax
	0x178A, // PSDPSoaxxn
	0x01E8, // SDPax
	0x1785, // PDSPDoaxxn
	0x1E28, // SDPSnoax
	0x0C65, // PDSxnan
	0x0CC5, // PDSana
	0x1D5C, // SSDxPDxaxn
	0x0648, // SDPSxox
	0x0E28, // SDPnoan
	0x0646, // DSPDxox
	0x0E26, // DSPnoan
	0x1B28, // SDPSnaox
	0x00E6, // DSan
	0x01E5, // PDSax
	0x1786, // DSPDSoaxxn
	0x1E29, // DPSDnoax
	0x0C68, // SDPxnan
	0x1E24, // SPDSnoax
	0x0C69, // DPSxnan
	0x0955, // SPxDSxo
	0x03C9, // DPSaan
	0x03E9, // DPSaa
	0x0975, // SPxDSxon
	0x0C49, // DPSxna
	0x1E04, // SPDSnoaxn
	0x0C48, // SDPxna
	0x1E05, // PDSPnoaxn
	0x17A6, // DSPDSoaxx
	0x01C5, // PDSaxn
	0x00C6, // DSa (SRCAND)
	0x1B08, // SDPSnaoxn
	0x0E06, // DSPnoa
	0x0666, // DSPDxoxn
	0x0E08, // SDPnoa
	0x0668, // SDPSxoxn
	0x1D7C, // SSDxPDxax
	0x0CE5, // PDSanan
	0x0C45, // PDSxna
	0x1E08, // SDPSnoaxn
	0x17A9, // DPSDPoaxx
	0x01C4, // SPDaxn
	0x17AA, // PSDPSoaxx
	0x01C9, // DPSaxn
	0x0169, // DPSxx
	0x588A, // PSDPSonoxx
	0x1888, // SDPSonoxn
	0x0066, // DSxn
	0x0709, // DPSnax
	0x07A8, // SDPSoaxn
	0x0704, // SPDnax
	0x07A6, // DSPDoaxn
	0x16E6, // DSPDSaoxx
	0x0345, // PDSxan
	0x00C9, // DPa
	0x1B05, // PDSPnaoxn
	0x0E09, // DPSnoa
	0x0669, // DPSDxoxn
	0x1885, // PDSPonoxn
	0x0065, // PDxn
	0x0706, // DSPnax
	0x07A5, // PDSPoaxn
	0x03A9, // DPSoa
	0x0189, // DPSoxn
	0x0029, // D
	0x0889, // DPSono
	0x0744, // SPDSxax
	0x06E9, // DPSDaoxn
	0x0B06, // DSPnao
	0x0229, // DPno
	0x0E05, // PDSnoa
	0x0665, // PDSPxoxn
	0x1974, // SSPxDSxox
	0x0CE8, // SDPanan
	0x070A, // PSDnax
	0x07A9, // DPSDoaxn
	0x16E9, // DPSDPaoxx
	0x0348, // SDPxan
	0x074A, // PSDPxax
	0x06E6, // DSPDaoxn
	0x0B09, // DPSnao
	0x0226, // DSno (MERGEPAINT)
	0x1CE4, // SPDSanax
	0x0D7D, // SDxPDxan
	0x0269, // DPSxo
	0x08C9, // DPSano
	0x00CA, // PSa (MERGECOPY)
	0x1B04, // SPDSnaoxn
	0x1884, // SPDSonoxn
	0x006A, // PSxn
	0x0E04, // SPDnoa
	0x0664, // SPDSxoxn
	0x0708, // SDPnax
	0x07AA, // PSDPoaxn
	0x03A8, // SDPoa
	0x0184, // SPDoxn
	0x0749, // DPSDxax
	0x06E4, // SPDSaoxn
	0x0020, // S (SRCCOPY)
	0x0888, // SDPono
	0x0B08, // SDPnao
	0x0224, // SPno
	0x0E0A, // PSDnoa
	0x066A, // PSDPxoxn
	0x0705, // PDSnax
	0x07A4, // SPDSoaxn
	0x1D78, // SSPxPDxax
	0x0CE9, // DPSanan
	0x16EA, // PSDPSaoxx
	0x0349, // DPSxan
	0x0745, // PDSPxax
	0x06E8, // SDPSaoxn
	0x1CE9, // DPSDanax
	0x0D75, // SPxDSxan
	0x0B04, // SPDnao
	0x0228, // SDno
	0x0268, // SDPxo
	0x08C8, // SDPano
	0x03A5, // PDSoa
	0x0185, // PDSoxn
	0x0746, // DSPDxax
	0x06EA, // PSDPaoxn
	0x0748, // SDPSxax
	0x06E5, // PDSPaoxn
	0x1CE8, // SDPSanax
	0x0D79, // SPxPDxan
	0x1D74, // SSPxDSxax
	0x5CE6, // DSPDSanaxxn
	0x02E9, // DPSao
	0x0849, // DPSxno
	0x02E8, // SDPao
	0x0848, // SDPxno
	0x0086, // DSo (SRCPAINT)
	0x0A08, // SDPnoo
	0x0021, // P (PATCOPY)
	0x0885, // PDSono
	0x0B05, // PDSnao
	0x022A, // PSno
	0x0B0A, // PSDnao
	0x0225, // PDno
	0x0265, // PDSxo
	0x08C5, // PDSano
	0x02E5, // PDSao
	0x0845, // PDSxno
	0x0089, // DPo
	0x0A09, // DPSnoo (PATPAINT)
	0x008A, // PSo
	0x0A0A, // PSDnoo
	0x02A9, // DPSoo
	0x0062, // 1 (WHITENESS)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\frame.h ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//==============================================================================
// FILE                         FRAME.H
//
// MODULE                       JUMBO Printer Driver, Queue Processor,
//                              Resource Executor, & Comm Module
//
// PURPOSE                      FRAME structure format
//
// DESCRIBED IN                 Jumbo Device Driver Design Description
//
// EXTERNAL INTERFACES
//
// INTERNAL INTERFACES
//
// MNEMONICS
//
// HISTORY  07/12/91 o-rflagg   Created
//          01/15/92 steveflu   bring up to coding conventions,
//                              change for QP interface
//
//==============================================================================


#ifndef _FRAME_
#define _FRAME_

// Don't change FRAME unless you also change the COMM driver and
// the Queue Processor, and the Resource Executor, and ....
typedef struct FRAMEtag
{
    WORD wReserved;
    WORD wSize;             // size of this block
    LPBYTE lpData;          // pointer to frame data
} FRAME;
typedef FRAME FAR *LPFRAME;
typedef FRAME NEAR *PFRAME;

#endif // _FRAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\glyph.cpp ===
/*==============================================================================
This source file contains routines for chaingon decompression of glyphs.

29-Dec-93    RajeevD    Integrated into unified resource executor.
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include "resexec.h"

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

#define CEIL32(val) (((val) + 31) & ~31)

#define RUN_FLAG ((short) 0x8000)

// Bit Stream Object
typedef class FAR BITIO
{
private:
	UINT uBit;
public:
	LPBYTE lpb;

	BITIO (LPBYTE lpbInit) {lpb = lpbInit, uBit = 0;}
	BITIO () {uBit = 0;}

	short Read2  (void);
	short Read4  (void);
	short Read6  (void);
	short Read8  (void);
	WORD  Read8U (void);
	short Read16 (void);
	WORD  ReadU  (void);

	short DecodeDelta (void);
}
	FAR *LPBITIO;

//==============================================================================
short BITIO::Read2 (void)
{
	short s;

	// Mask and shift 2-bit field.
	s = (*lpb >> (6 - uBit)) & 0x03;

	// Advance stream pointer.
	uBit += 2;
	if (uBit == 8)
		{lpb++; uBit = 0;}

#ifndef BITIO_NOSIGNEXT
	if (s >= 2)
		s -= 4;	// Sign extend into short.
#endif
	return s;
}

//========================================================================
short BITIO::Read4 (void)
{
	LPBYTE lpbVal;
	short s;
	
	if (uBit == 6)
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= 6;
		s &= 0x000F;
		uBit = 2;
	}

	else
	{
		s = (*lpb >> (4 - uBit)) & 0x0F;
		uBit += 4;
		if (uBit == 8)
			{ lpb++; uBit = 0; }
	}

#ifndef BITIO_NOSIGNEXT
	if (s >= 8)
		s -= 16; // Sign extend into short.
#endif

	return s;
}

//========================================================================
short BITIO::Read6 (void)
{
	LPBYTE lpbVal;
	short s;
	
	switch (uBit/2)
	{
		case 0:
			s = (short) (*lpb >> 2);
			uBit = 6;
			break;
				
		case 1:
			s = (short) *lpb++;
			uBit = 0;
			break;
			
		case 2:
			lpbVal = (LPBYTE) &s;
			lpbVal[1] = *lpb++;
			lpbVal[0] = *lpb;
			s >>= 6;
			uBit = 2;
			break;
			
		case 3:
			lpbVal = (BYTE *) &s;
			lpbVal[1] = *lpb++;
			lpbVal[0] = *lpb;
			s >>= 4;
			uBit = 4;
			break;
	}

	s &= 0x003F;
	
#ifndef BITIO_NOSIGNEXT
	if (s >= 32)
		s -= 64; // Sign extend into short.
#endif
	return s;
}

//========================================================================
short BITIO::Read8 (void)
{
	short s;
	LPBYTE lpbVal;

	if (uBit == 0)
		s = (short) *lpb++;

	else
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= (8 - uBit);
		s &= 0x00FF;
	}

#ifndef BITIO_NOSIGNEXT
	if (s >= 128)
		s -= 256;	// Sign extend into short.
#endif

	return s;
}

//========================================================================
WORD BITIO::Read8U (void)
{
	short s;
	LPBYTE lpbVal;

	if (uBit == 0)
		s = (short) *lpb++;

	else
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= (8 - uBit);
		s &= 0x00FF;
	}

	return s;
}

//========================================================================
short BITIO::Read16 (void)
{
	short s;
	LPBYTE lpbVal = (LPBYTE) &s;

	lpbVal[1] = *lpb++;
	lpbVal[0] = *lpb++;

	switch (uBit/2)
	{
		case 0:
			break;
			
		case 1:
			s <<= 2;
			s |= (*lpb >> 6) & 0x03;
			break;
			
		case 2:
			s <<= 4;
			s |= (*lpb >> 4) & 0x0F;
			break;
			
		case 3:
			s <<= 6;
			s |= (*lpb >> 2) & 0x3F;
			break;
	}

	return s;
}

//==============================================================================
WORD BITIO::ReadU (void)
{
	WORD w = Read8U();
	if (w == 0xFF)
		w = Read16();
	return w;
}


/*==============================================================================
This utility procedure uses an OR operation to fill runs in a scan buffer.
==============================================================================*/
LPBYTE FillRun     // Returns next scan line
(
	LPBYTE lpbLine,   // first output scan line
	UINT   cbLine,    // width of a scan line
 	UINT   xLeft,     // left column, inclusive
	UINT   xRight,    // right column, exclusive
	UINT   cLines = 1 // number of scan lines
)
{
	const static WORD wFill[16] =
	{
		0xFFFF, 0xFF7F, 0xFF3F, 0xFF1F,
		0xFF0F, 0xFF07, 0xFF03, 0xFF01,
		0xFF00, 0x7F00, 0x3F00, 0x1F00,
		0x0F00, 0x0700, 0x0300, 0x0100,
	};

	UINT iwLeft, iwRight;
	WORD wLeft,  wRight; // masks
	LPWORD lpwLine = (LPWORD) lpbLine;
	UINT cwLine = cbLine / 2;

	iwLeft  = xLeft  / 16;
	iwRight = xRight / 16;
	wLeft  =  wFill [xLeft  & 15];
	wRight = ~wFill [xRight & 15];
	
	if (iwLeft == iwRight)
	{
		while (cLines--)
		{
			// Run is within a single WORD.
			lpwLine[iwLeft] |= wLeft & wRight;
			lpwLine += cwLine;
		}
	}
	
	else
	{
		UINT cbMiddle = 2 * (iwRight - iwLeft - 1);

		while (cLines--)
		{
			// Run spans more than one WORD.
			lpwLine[iwLeft] |= wLeft;
			_fmemset (lpwLine + iwLeft + 1, 0xFF, cbMiddle);
			if (wRight) // Don't access beyond output!
				lpwLine[iwRight] |= wRight;
			lpwLine += cwLine;
		}	
	}

	return (LPBYTE) lpwLine;
}

//==============================================================================
UINT              // unpacked size
UnpackGlyph  
(	
	LPBYTE lpbIn,   // packed glyph
	LPBYTE lpbOut   // output buffer
)
{
	BITIO bitio (lpbIn); // input bit stream
	LPWORD lpwOut;       // alias for lpbOut
	WORD xExt, yExt;     // glyph dimensions
	UINT cbLine;         // scan line width

	// Decode glyph header.
	xExt = bitio.ReadU();
	yExt = bitio.ReadU();
	cbLine = CEIL32(xExt) / 8;
	
	// Write glyph dimensions.
	lpwOut = (LPWORD) lpbOut;
	*lpwOut++ = yExt;
	*lpwOut++ = xExt;
	lpbOut = (LPBYTE) lpwOut;

	// Clear output buffer.
	_fmemset (lpbOut, 0x00, cbLine * yExt);

	// Unpack each chain.
	while (1)	
	{
		LPBYTE lpbScan;         // output buffer
		UINT yTop;              // top of chaingon
		UINT xLeft, xRight;     // left and right bound
		short dxLeft, dxRight;  // left and right delta
		UINT cLine, cRun;       // line counters

		// Decode chain header.
		xRight = bitio.ReadU();
		if (!xRight) // termination
			goto done;
		cLine  = bitio.ReadU();
		xLeft  = bitio.ReadU();
    yTop   = bitio.ReadU();
		lpbScan = lpbOut + yTop * cbLine;
		xRight += xLeft;
	
		// Fill first row.
		lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight);
		cLine--;

		// Fill remaining rows.
		while (cLine)
		{
			dxLeft = bitio.DecodeDelta ();

			if (dxLeft == RUN_FLAG) 
			{
				// Decode run of repeated lines.
 				cRun = (bitio.Read4() & 0xF) + 3;
				lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight, cRun);
				cLine -= cRun;
			}
			
			else 
			{
				// Adjust by deltas.
				dxRight = bitio.DecodeDelta();
				xLeft  += dxLeft;
				xRight += dxRight;
				lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight);
				cLine--;
   		}

	 	} // while (cLine--)

	} // while (1)

done:
	return 2 * sizeof(WORD) + yExt * cbLine;
}
	
//==============================================================================
void WINAPI UnpackGlyphSet (LPVOID lpIn, LPVOID lpOut)
{
	LPJG_GS_HDR lpSetIn  = (LPJG_GS_HDR) lpIn;
	LPJG_GS_HDR lpSetOut = (LPJG_GS_HDR) lpOut;
	LPBYTE lpbOut;
	WORD iGlyph;

	// Copy header.
	_fmemcpy (lpSetOut, lpSetIn, sizeof(JG_RES_HDR) + sizeof(WORD));

	// Create pointer to end of offset tables.
	lpbOut = ((LPBYTE) lpSetOut) + lpSetIn->ausOffset[0];

	// Unpack the glyphs.	
	for (iGlyph=0; iGlyph<lpSetIn->usGlyphs; iGlyph++)
 	{
		lpSetOut->ausOffset[iGlyph] = (USHORT)(lpbOut - (LPBYTE) lpSetOut);
		lpbOut += UnpackGlyph
			((LPBYTE) lpSetIn + lpSetIn->ausOffset[iGlyph], lpbOut);
 	}
}

//==============================================================================
short  // Returns delta (or RUN_FLAG)
BITIO::DecodeDelta (void)
{
	short s;

	s = Read2();	     
	if (s != -2)       // Trap -1, 0, +1.
		return s;

	s = Read4();	     // Get 4-bit prefix.
	switch (s)
	{
		case 0: // run of zeros
			return RUN_FLAG;

		case 1: // 6-bit literal
			s = Read6();
			return (s >= 0? s + 8  : s - 7);

		case -1: // 8-bit literal
			s = Read8();
			return (s >= 0? s + 40 : s - 39);

		case -8: // 16-bit literal
			return Read16();

		default: // 4-bit literal
			return s;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\hreblt.c ===
#include <ifaxos.h>
#include <resexec.h>
#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{
	lpRE->usBrushWidth = 0;
	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{

}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
	lpRE->usBrushWidth = 0;
	return TRUE;
}

//==============================================================================
DWORD FAR PASCAL HREBitBlt
(
	LPVOID  PRT_FrameStart,
	LPVOID  lpgBrush,
	WORD    PRT_BytesPerScanLine,
	WORD    usBrushWidth,
	WORD    PRT_Max_X,
	WORD    PRT_Max_Y,
	WORD    usgPosOff,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop	 // Raster operation
);

DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop		 // Raster operation
)
{
	LPBITMAP lpbmBand = lpRE->lpBandBuffer;

	return HREBitBlt
		(
			lpbmBand->bmBits, lpRE->lpBrushBuf, lpbmBand->bmWidthBytes,
			lpRE->usBrushWidth, lpbmBand->bmWidth, lpbmBand->bmHeight, lpRE->yPat,
			xSrc, yDst, xDst, clLine, yExt, xExt, lpSrc, lpPat, dwRop
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\mflags.inc ===
;--------------------------------------------------
;MASMFLAGS definitions
;--------------------------------------------------
   EGA    =  0001h		;Build the EGA driver.
   VGA    =  0002h		;Build the VGA driver.
   SVGA   =  0004h		;Build the SuperVGA driver.
   ROM    =  0008h		;Build A ROMable driver.
   PENWIN =  0010h		;Build A PenWin compliant driver.
   PUBDEFS=  4000h		;Make symbols public.
   DEBUG  =  8000h		;Build a debug driver.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\macros.inc ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	MACROS.MAC
;
; This file contains macros definitions for all display drivers to use.
;
; Created: 06-Jan-1987
; Author:  Walt Moore [waltm]
;
; Copyright (c) 1987 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:	none
;
; Public Data:		none
;
; General Description:
;
;	Two text equates are given as short hand for WORD PTR
;	and BYTE PTR.
;
;	A Macro is defined for performing 16-bit output on machines
;	which cannot correctly do so.
;
;	The macro which is invoked by CMACROS for private stack
;	checking is defined.
;
; Restrictions:
;	The use of the ?CHKSTKPROC macro requires it to be defined
;	before CMACROS is included.  If CMACROS is included before
;	the include file, a ?CHKSTKPROC macro should be defined
;	with a null macro body.  This macro will then redefine the
;	earlier macro.
;
;	The out16 macro is intended as documentation for anyone
;	converting a driver to a machine which cannot do 16-bit
;	outputs correctly.  There is no guarantee that any code
;	will have been tested (only one machine is known to have
;	the problem).
;
;-----------------------------------------------------------------------;




;	The following two equates are just used as shorthand
;	for the "word ptr" and "byte ptr" overrides.

wptr	equ	word ptr
bptr	equ	byte ptr
		
		.286

;---------------------------------Macro---------------------------------;
; out16
;
; out16 is a macro used wherever any 16-bit output is performed.
; The macro is intended to serve as documentation for those machines
; which do not perform 16-bit outputs correctly (where correctly is
; defined as the way the IBM AT does it).
;
; usage
;
;     out16   d,a
;
; where
;
;     d   -   I/O address register. Included as documentation
;	      only.  Must always be DX (lower case).
;
;     a   -   Register to output.  Included as documentation
;	      only.  Must always be AX (lower case).
;
; Entry:
;	AX	= data to output
;	DX	= I/O port address
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	FLAGS
; Registers Preserved:
;	AX,BX,CX,DX,SI,DI,BP,DS,ES
; Calls:
;       none
; History:
;	Fri 16-Jan-1987 16:49:03 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


ifndef	IO8				;;If normal 16 bit outputs
  out16   equ	  out
else					;;If 8-bit outputs
  out16 macro d,a
	ifdif <a>,<ax>
	%out out16 - invalid register, must be ax
	.err
	endif
	ifdif	<d>,<dx>
	%out	out16 - invalid register, must be dx
	.err
	endif
	ifdif <is>,<cli>		;;  If interrupts not off
	cli				;;    then turn them off
	endif				;;
	out	dx,al			;;  Output LSB portion
	inc	dx			;;  --> next address
	xchg	al,ah			;;  Get MSB of output value
	out	dx,al			;;  Output MSB portion
	ifdif <ie>,<cli>		;;  If not explicitly told to leave
	sti				;;    interrupts off, turn them on
	endif				;;
	ifdif <rd>,<dont_save_DL>	;;  If not explicitly told to trash DX,
	dec	dx			;;    restore it.
	xchg	al,ah
	endif
	endm
endif



;---------------------------------Macro---------------------------------;
; ?CHKSTKPROC
;
; Private Stack Checking Macro
;
; ?CHKSTKPROC will be invoked by the CMACROS for any procedure
; with local variables if both ?CHKSTK and ?CHKSTKPROC were
; defined prior to including the CMACROS.
;
; The macro has one parameter, which is the number of bytes
; to allocate, which is supplied by the CMACROS.
;
; The usage of this macro is defined by the CMACROS.  There is no
; user control over the macro.	Register usage will be as defined
; by the routine my_check_stack.
;
; Calls:
;	my_check_stack
; History:
;	Fri 16-Jan-1987 16:49:03 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


ifdef	?CHKSTK 			;;Only define macro if
ifdef	?CHKSTKPROC			;;  private stack checking
ifndef	?CHKSTKNAME			;;If user name differs from default
extrn	my_check_stack:near		;;Procedure to do the checking
endif
?CHKSTKPROC macro s			;;Actual macro text
	mov	ax,s			;;my_check_stack takes requested space
ifdef	?CHKSTKNAME
	?CHKSTKNAME
else
	call	my_check_stack		;;  in AX
endif
endm
endif
endif



;-----------------------------------------------------------------------;
; odd	--- macro for odd alignment, counterpart for masm's "even".
;
; Arguments:
;	none
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Sun Mar 01, 1987 07:48:01p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


odd	macro
	ife (offset $) AND 1
	nop
	endif
	endm



;-----------------------------------------------------------------------;
; pushem
; popem
;
; Allows giving a list of registers to push/pop on a single line.
; Also allows easy verificaton that pushes and pops are balanced
; because arguements are given in the same order:
;
;	pushem	ax,bx,cx   goes with
;	popem	ax,bx,cx
;
; Arguments:
;	registers to push/pop
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


pushem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12>
	ifnb	<x>
	push	x
	endif
	endm
	endm

popem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r12,r11,r10,rF,rE,rD,rC,rB,rA,r9,r8,r7,r6,r5,r4,r3,r2,r1>
	ifnb	<x>
	pop	x
	endif
	endm
	endm



;-----------------------------------------------------------------------;
; smov
;
; smove moves the contents of one segment register into another
; segment register.
;
; usage
;
;	smov	x,y
;
; where
;
;	x is the destination register
;	y is the source register
;
; Arguments:
;	y is source segment register
; Returns:
;	x segment register = y segment register
; Alters:
;	x segment register
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


smov	macro	x,y
	push	y
	pop	x
	endm



;--------------------------------------------------------------------------;
; abs_ax
;	takes absolute value of AX
; Entry:
;	AX	= integer
; Returns:
;	AX	= abs(AX)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Thu Mar 05, 1987 06:15:46p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


abs_ax	macro
	cwd
	xor	ax,dx
	sub	ax,dx
	endm



;--------------------------------------------------------------------------;
; min_ax
;	returns min of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= min(AX,REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:39:04p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


min_ax	macro	REG
	sub	ax,REG
	cwd
	and	ax,dx
	add	ax,REG
	endm



;--------------------------------------------------------------------------;
; max_ax
;	returns max of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= max(AX, REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:41:38p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


max_ax	macro	REG
	sub	ax,REG
	cwd
	not	dx
	and	ax,dx
	add	ax,REG
	endm



;	The following equates are used for defining the target
;	processor to the shift macros.


GENERIC	equ	0

CPU	equ	GENERIC
;CPU	equ	88
;CPU	equ	86
;CPU	equ	186
;CPU	equ	286
;CPU	equ	386



;--------------------------------------------------------------------------;
; shiftl
;
; shiftl is used to implement the advanced shift left immediate
; (SHL dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shl COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:30p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shl	DEST,COUNT
else
	REPT	COUNT
	shl	DEST,1
	ENDM
endif
	endm



;--------------------------------------------------------------------------;
; shiftr
;
; shiftr is used to implement the advanced shift right immediate
; (SHR dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shr COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:52p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shr	DEST,COUNT
else
	REPT	COUNT
	shr	DEST,1
	ENDM
endif
	endm


;--------------------------------------------------------------------------;
; rotcr, rotcl
; rotr, rotl
;
; Use just like you would rcr (or rcl, rol, ror) immediate in 286 specific
; code.  If the processor does not support the immediate count (>1 on 808[68])
; then the macro generates multiple rcr (...) by one statements.
;
; Entry:
;	DEST	= var to rotate
;	COUNT	= number to rotate by
; Returns:
;	DEST	= DEST shr COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
; 
;  Fri Apr 17, 1987 08:39:39p	-by-	Wesley O. Rupel	  [wesleyr]
; added rotl and rotr
;
;  Sun Apr 12, 1987 07:34:37p	-by-	Wesley O. Rupel	  [wesleyr]
; wrote it
;--------------------------------------------------------------------------;


rotcr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rcr	DEST,COUNT
else
	REPT	COUNT
	rcr	DEST,1
	ENDM
endif
	endm

rotcl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rcl	DEST,COUNT
else
	REPT	COUNT
	rcl	DEST,1
	ENDM
endif
	endm



rotl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rol	DEST,COUNT
else
	REPT	COUNT
	rol	DEST,1
	ENDM
endif
	endm


rotr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	ror	DEST,COUNT
else
	REPT	COUNT
	ror	DEST,1
	ENDM
endif
	endm


;--------------------------------------------------------------------------;
; ashiftr
;
; ashiftr is used to implement the advanced shift arithmetic right immediate
; (SAR dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST sar COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:45:06p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


ashiftr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	sar	DEST,COUNT
else
	REPT	COUNT
	sar	DEST,1
	ENDM
endif
	endm



;---------------------------------Macro---------------------------------;
; jmpnext
; jmpnext stop
;
; jmpnext is used in the generation of fall through chains.  It
; generates the opcode used to swallow the next two bytes of object
; code (cmp ax,immediate word), and performs error checking to
; ensure that only two bytes of object code exist between any
; use of jmpnext.
;
; The chain is terminated by use of an optional parameter to jmpnext.
; If this optional field is non-blank, the chain is terminated.
;
; usage
;
;	dog:
;	      mov    al,34
;	     jmpnext
;
;	foo:
;	     mov     al,0
;	     jmpnext
;
;	bar:
;	     mov     al,1
;	     jmpnext stop			;End of the chain
;
; Entry:
;	none
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	FLAGS
; Registers Preserved:
;	AX,BX,CX,DX,SI,DI,BP,DS,ES
; Calls:
;       none
; History:
;	Fri 13-Mar-1987 12:03:16 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e> 				;;If not the end of the chain
	db	03Dh			;;cmp ax, next two bytes
errn$	??ji&j,+2			;;next lable must be two bytes away
endif
??ji=j					;;increment counter
endm



;---------------------------------Macro---------------------------------;
; missing_code
;
; missing_code is a macro which will display a message on the screen
; at assembly time.  It is used to flag code sequences which have not
; been completed.
;
; usage
;
;	missing_code	<text>
;
; Entry:
;	none
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	ALL
; Calls:
;       none
; History:
;	Sun 22-Mar-1987 18:21:34 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;

missing_code	macro	x
	if1
	??_out	<&! Missing Code &!  x>
	endif
	endm

;---------------------------Macro---------------------------------------;
; LMHtoP
;
; Converts a Local Memory Handle to a local pointer.
;
; Entry:
; 	reg1[,reg2]
; Returns:
; 	reg1 = pointer
; Error Returns:
; 	
; Registers Destroyed:
; 	none
; History:
;  Mon Mar 23, 1987 06:54:26a  -by-  Charles Whitmer [chuckwh]
; Imported from GDI.
;-----------------------------------------------------------------------;

LMHtoP macro r1,r2		;; Local Movable Handle to pointer
ifnb <r2>
	mov	r1,[r2]
else
	mov	r1,[r1]
endif
endm


;-------------------------Macro-----------------------------------------;
; REPSTOSB Dst
;
; store <cx> copies of al at Dst, aliging destination on WORD writes
;
;   Dst 	destination, must be of the form SEL:[di] (default is es:[di])
;
; Entry:
;   Dst 	-> points to dest buffer
;   al		byte to write
;   cx		count bytes
;
; NOTE a dest segment other than ES is handled by generating a loop
; all other cases generate a rep mov
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; NOTE cx must be non-zero
;
; Returns:
;
; History:
;	Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPSTOSB macro Dst
	local	l1
	local	l2
	local	l3
	local	localdest

IFIDNI <Dst>, <NOAHLOAD>
	localdest EQU es:[di]
ELSE
	localdest EQU Dst
	mov	ah,al		    ; make sure ah == al
ENDIF

	test	di,1
	jz	l1
	stos	byte ptr localdest
	dec	cx
l1:
	shr	cx,1
	rep	stos word ptr localdest
	adc	cl,cl
	rep	stos byte ptr localdest

	endm

REPSTOSB macro Dst
ifb <Dst>
	?REPSTOSB es:[di]
else
	?REPSTOSB Dst
endif
	endm

;-------------------------Macro-----------------------------------------;
; REPMOVSB Dst, Src, alignR
;
; copy <cx> bytes from Src to Dst, aliging destination or source
; on WORD writes
;
;   Dst 	destination, must be of the form SEL:[di] (default is es:[di])
;   Src 	source,      must be of the form SEL:[si] (default is ds:[si])
;   alignR	register to align   si or di (default is di)
;
; Entry:
;   Src 	-> points to source buffer
;   Dst 	-> points to dest buffer
;   cx		count bytes
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; NOTE cx must be non-zero
;
; Returns:
;
; History:
;	Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;-----------------------------------------------------------------------;

?REPMOVSB  macro Dst, Src, alignR
	local	l1
	local	l2
	local	l3

	test	alignR,1
	jz	l1
	movs	byte ptr Dst, byte ptr Src
	dec	cx
l1:	shr	cx,1
	rep	movs	word ptr Dst, word ptr Src
	adc	cl,cl
	rep	movs	byte ptr Dst, byte ptr Src

	endm

REPMOVSB  macro Dst, Src, alignR

ifb <Dst>
	?REPMOVSB es:[di],ds:[si],di
	exitm
endif

ifb <Src>
	?REPMOVSB Dst,ds:[si],di
	exitm
endif

ifb <alignR>
	?REPMOVSB Dst,Src,di
	exitm
endif
	?REPMOVSB Dst,Src,alignR

	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\rplnee.h ===
typedef char             int8;           /* signed byte: -128..127          */
typedef unsigned char    uint8;          /* unsigned byte: 0..255           */
typedef unsigned short   uint16;         /* unsigned integer: 0..65535      */
typedef short            int16;          /* signed integer: -32768..32767   */
typedef unsigned long    uint32;         /* unsigned long integer: 0..2^32-1*/
typedef long             int32;          /* signed long integer: -2^31..2^31*/

#define FIRST    (uint16)1
#define LAST     (uint16)2
#define ALLONE   (uint16)0xFFFF
#define SECTOR0  0
#define SECTOR1  4
#define SECTOR2  7
#define SECTOR3  9
#define SECTOR4  11
#define SECTOR5  13
#define SECTOR6  12
#define SECTOR7  8

struct DRAWINFO
{
    uint16 FAR *bytePosition;
    int    nextY;
    uint16 bitPosition;
};

typedef struct DRAWINFO drawInfoStructType;

static void Sector07(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector16(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector25(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector34(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);

void (*sector_function[14])(RP_SLICE_DESC FAR*, LPBITMAP lpbm) =
{
	Sector07,
	     0,
	     0,
	     0,
	Sector16,
	     0,
	     0,
	Sector25,
	Sector07,
	Sector34,
	     0,
	Sector34,
	Sector16,
	Sector25
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\hre.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         HRE.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Convert A-form to B-form for jumbo driver
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
// 
// HISTORY  1/17/92 mslin       created
//          3/30/92 mslin       Pre-compiled brush generated for each job.
//                              ideal case would be initialize PcrBrush in
//                              HRE.DLL loading, and free up when HRE 
//                              terminate. but we had problem in Dumbo, ???
//                              Expanded Brush Buffer allocated for each job.
//                              lpgBrush will be set to lpREState->lpBrushBuf
//                              in DoRpl().
//          4/15/92 mslin       added uiHREExecuteRPL() for dumbo.
//          9/27/93 mslin       added a new bit of wFlags in hHREOpen() for
//                              300/600 dpi:
//                                  bit2: 0 -- 300 dpi
//                                  bit2: 1 -- 600 dpi
//                              also remove DUMBO compiler switch. 
//          2/09/94 rajeevd     Undid all of the above changes.
//===========================================================================

// include file
#include <windows.h>
#include <windowsx.h>
#include <resexec.h>

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

#include "hreext.h"
#include "multbyte.h"   // define macros to take care of byte ordering

#define HRE_SUCCESS             0x0     // successful return from HRE
#define HRE_EXECUTED_RPL        0x01    // Executed the final RP in an RPL
#define HRE_EXECUTED_ONE        0x02    // Executed only one RP from an RPL
                                        // (not the last one)
#define HRE_ERROR               0x03    // General HRE failure

// PRIVATE functions
static   UINT        PutRPL(LPHRESTATE lpHREState, LPFRAME lpFrameArray,
                     UINT uiCount);
static   UINT        FreeRPL(LPRPLLIST lpRPL);

#ifdef DEBUG
DWORD    dwrgTime[MAXBAND];
SHORT    sCurrentLine;
ULONG    ulgPageId = 0;
ULONG    ulgTimes[1000] = {0};
#endif

#include "windows.h"

//==============================================================================

#ifndef WIN32

BOOL WINAPI LibMain
    (HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

int WINAPI WEP (int nParam);
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
HANDLE                 // context handle (NULL on failure)
WINAPI hHREOpen
(
    LPVOID lpBrushPat,   // array of 32x32 brush patterns
    UINT   cbLine,       // maximum page width in bytes
    UINT   cResDir       // entries in resource directory
)
{
   HANDLE      hHREState;
   LPHRESTATE  lpHREState;
   LPRESTATE   lpREState;
   LPRESDIR    lpDlResDir;

   // create a handle for the new session 
   if (!(hHREState = GlobalAlloc(GMEM_MOVEABLE, sizeof(HRESTATE))))
      return (NULL);
   lpHREState = (LPHRESTATE) GlobalLock (hHREState);

   // allocate Download ResDir Table
   if (!(lpDlResDir = (LPRESDIR) GlobalAllocPtr (GMEM_ZEROINIT, sizeof(RESDIR) * cResDir)))
   {
      // unlock and free HRESTATE
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      return(NULL);
   }
   
   // allocate RESTATE data structure and Initialize it
   // this is graphic state of rendering 
   if (!(lpREState = (LPRESTATE) GlobalAllocPtr (GMEM_ZEROINIT, sizeof(RESTATE))))
   {
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      GlobalFreePtr (lpDlResDir);
      return (NULL);
   }

#ifdef WIN32

  lpREState->lpBrushBuf = NULL;

#else

   if (!(lpREState->lpBrushBuf = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, (cbLine + 4) * 16)))
   {
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      GlobalFreePtr (lpDlResDir);
      GlobalFreePtr (lpREState);
      return (NULL);
   }

#endif
      
   // Initialize RESTATE
   lpREState->lpBrushPat = lpBrushPat;
                                            
   // Initialize HRESTATE
   lpHREState->hHREState = hHREState;
   lpHREState->scDlResDir = (USHORT)cResDir;
   lpHREState->lpDlResDir = lpDlResDir;
   lpHREState->lpRPLHead= NULL;
   lpHREState->lpRPLTail= NULL;
   lpHREState->lpREState = lpREState;

   GlobalUnlock(hHREState);
   return(hHREState);
}

//---------------------------------------------------------------------------
UINT                            // will be zero (0) if resource is processed
                                // succesfully, otherwise it will be an error
                                // code as defined above.
WINAPI uiHREWrite
(
    HANDLE      hHREState,      // handle returned previously by hREOpen
    LPFRAME     lpFrameArray,   // FAR pointer to an array of FRAME structs
    UINT        uiCount         // Number of FRAME structs pointed to by 
                                // lpFrameArray
)

// PURPOSE                      To add a resource block (RPLK) to the
//                              HRE state hash table for the context
//                              identified by hHREState.
//
// ASSUMPTIONS & ASSERTIONS     The memory for the RBLK has allready been
//                              Allocated and locked.  HRE will not copy the
//                              data, just the pointers.
//                              The lpFrameArray does not point to an SPL.
//                              All SPL's will be handled externally to HRE.
//
// INTERNAL STRUCTURES          
//
// UNRESOLVED ISSUES            
//
//---------------------------------------------------------------------------       
{
   LPHRESTATE     lpHREState;
   LPJG_RES_HDR   lpResHdr;
   LPRESDIR       lpResDir;
   ULONG          ulUID;
   USHORT         usClass;
   HANDLE         hFrame;
   LPFRAME        lpFrameArrayDup, lpFrame;
   UINT           uiLoopCount;

   lpHREState = (LPHRESTATE) GlobalLock (hHREState);

   // get resource class                                            
   lpResHdr = (LPJG_RES_HDR )lpFrameArray->lpData;
   usClass = GETUSHORT(&lpResHdr->usClass);
   switch(usClass)
   {
      case JG_RS_RPL: /*0x4*/
         // store into RPL list
         if( PutRPL(lpHREState, lpFrameArray, uiCount) != HRE_SUCCESS )
         {
            GlobalUnlock(hHREState);
            return(HRE_ERROR);   // out of memory
         }
         break;

      case JG_RS_GLYPH: /*0x1*/
      case JG_RS_BRUSH: /*0x2*/
      case JG_RS_BITMAP: /*0x3*/
         // check to see if uid >= size of hash table then reallocate
         ulUID = GETULONG(&lpResHdr->ulUid);
         lpResDir = lpHREState->lpDlResDir;
         if (ulUID >= lpHREState->scDlResDir)
         {
               return(HRE_ERROR);
         }

         // Free frame array of previous resource block
         lpFrameArrayDup = lpResDir[ulUID].lpFrameArray;
         if(lpFrameArrayDup)
           GlobalFreePtr (lpFrameArrayDup);
          
         // copy frame array
         if (!(hFrame = GlobalAlloc(GMEM_MOVEABLE, uiCount * sizeof(FRAME))))
            return (HRE_ERROR);
         if (!(lpFrameArrayDup = (LPFRAME)GlobalLock(hFrame)))
         {
            GlobalFree(hFrame);
            return (HRE_ERROR);
         }
         lpFrame = lpFrameArrayDup;
         for(uiLoopCount=0; uiLoopCount<uiCount; uiLoopCount++)
         {
            *lpFrame++ = *lpFrameArray++;
         }

         // put into hash table
         lpResDir[ulUID].lpFrameArray = lpFrameArrayDup;
         lpResDir[ulUID].uiCount = uiCount;
         break;
         
      default:
         // error return 
         break;

   }

   GlobalUnlock(hHREState);
   return(HRE_SUCCESS);

}


//---------------------------------------------------------------------------
UINT   WINAPI uiHREExecute
(
    HANDLE   hHREState,  // resource executor context
  LPBITMAP lpbmBand,   // output band buffer
  LPVOID   lpBrushPat  // array of 32x32 brush patterns
)
{
   LPHRESTATE  lpHREState;
   LPRESTATE   lpRE;
   LPRPLLIST   lpRPL, lpRPLSave;

   lpHREState = (LPHRESTATE) GlobalLock (hHREState);
   
   // Record parameters in RESTATE.
   lpRE = lpHREState->lpREState;
   lpRE->lpBandBuffer = lpbmBand;
   lpRE->lpBrushPat   = lpBrushPat;

   lpRPL = lpHREState->lpRPLHead;
   do
   {
     DoRPL(lpHREState, lpRPL);
      lpRPLSave = lpRPL;
      lpRPL=lpRPL->lpNextRPL;
      FreeRPL(lpRPLSave);
   }
   while(lpRPL);
   // if last RP executed then update lpRPLHead
   lpHREState->lpRPLHead = lpRPL;
   
   GlobalUnlock(hHREState);
   return(HRE_EXECUTED_RPL);

}

//---------------------------------------------------------------------------
UINT                            // will be zero (0) if HRE context is closed
                                // succesfully, otherwise it will be an error
                                // code as defined above.
WINAPI uiHREClose
(
    HANDLE      hHREState       // handle returned previously by hREOpen
)

// PURPOSE                      To close a previously opened context in the
//                              HRE.  All memory and state information 
//                              associated with the context will be freed.
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          None.
//
// UNRESOLVED ISSUES            programmer development notes
//
// --------------------------------------------------------------------------
{
   LPHRESTATE  lpHREState;
   LPRESTATE   lpRE;
   LPRESDIR    lpDlResDir;
   SCOUNT      scDlResDir;
   SCOUNT      sc;
   LPFRAME     lpFrameArray;
    
   if (!(lpHREState = (LPHRESTATE) GlobalLock (hHREState)))
     return HRE_ERROR;

   lpDlResDir = lpHREState->lpDlResDir;
   if(lpDlResDir != NULL)                 // mslin, 4/15/92 for dumbo
   {
      scDlResDir = lpHREState->scDlResDir;
      // free frame array of DlResDir
      for(sc = 0; sc < scDlResDir; sc++)
      {
         if( (lpFrameArray = lpDlResDir[sc].lpFrameArray) != NULL)
           GlobalFreePtr (lpFrameArray);
      }

      // unlock and free DlResDir
      GlobalFreePtr(lpDlResDir);
   }

     lpRE = lpHREState->lpREState;

#ifndef WIN32
   GlobalFreePtr (lpRE->lpBrushBuf);
#endif   
   GlobalFreePtr (lpRE);
   
   GlobalUnlock(hHREState);
   GlobalFree(hHREState);
   
   return(HRE_SUCCESS);
}
 
// ------------------------------------------------------------------------
static
UINT                         // HRE_SUCCESS if allocate memory OK
                             // HRE_ERROR if allocate memory failure
PutRPL
(
   LPHRESTATE lpHREState,
   LPFRAME lpFrameArray,
   UINT uiCount
)
// PURPOSE
//                            Allocate a RPL entry and then put RPL into 
//                            tail of RPL list.
//
//           
// ------------------------------------------------------------------------
{
   HANDLE      hRPL;
   LPRPLLIST   lpRPL;
   HANDLE      hFrame;
   LPFRAME     lpFrameArrayDup, lpFrame;
   UINT        uiLoopCount;

   BOOL        fAllocMemory = FALSE;
   if (hRPL = GlobalAlloc(GMEM_MOVEABLE, sizeof(RPLLIST)))
   {
        if (lpRPL = (LPRPLLIST)GlobalLock(hRPL))
        {
            if (hFrame = GlobalAlloc(GMEM_MOVEABLE, uiCount * sizeof(FRAME)))
            {
                if (lpFrameArrayDup = (LPFRAME)GlobalLock(hFrame))
                {
                    // all allocations are ok:
                    fAllocMemory = TRUE;
                }
                else
                {
                    GlobalFree(hFrame);
                    GlobalUnlock(hRPL);
                    GlobalFree(hRPL);     
                }
            }
            else
            {
                GlobalUnlock(hRPL);
                GlobalFree(hRPL);     
            }
        }
        else
        {
            GlobalFree(hRPL);
        }

   }
   
   if (!fAllocMemory)
   {
       return (HRE_ERROR);
   }


   lpFrame = lpFrameArrayDup;
   for(uiLoopCount=0; uiLoopCount<uiCount; uiLoopCount++)
   {
      *lpFrame++ = *lpFrameArray++;
   }

   lpRPL->uiCount = uiCount;
   lpRPL->lpFrame = lpFrameArrayDup;
   lpRPL->lpNextRPL = NULL;
   if(lpHREState->lpRPLHead == NULL)
   {
      // first RPL
      lpHREState->lpRPLHead = lpHREState->lpRPLTail = lpRPL;
   }
   else
   {
      lpHREState->lpRPLTail->lpNextRPL = lpRPL;
      lpHREState->lpRPLTail = lpRPL;
   }
   return(HRE_SUCCESS);
}

// ------------------------------------------------------------------------
static
UINT                            // HRE_SUCCESS if allocate memory OK
                                // HRE_ERROR if allocate memory failure
FreeRPL
(
   LPRPLLIST lpRPL
)
// PURPOSE
//                               Free a RPL entry and its frame array
//
// ------------------------------------------------------------------------
{
    GlobalFreePtr (lpRPL->lpFrame);
    GlobalFreePtr (lpRPL);
    return HRE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\stllnent.h ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/

/*============================================================================
// FILE                     STLLNENT.H
//
// MODULE                   Jumbo Cartridge Public Information
//
// PURPOSE                  This file contains the function to draw styled
//
// DESCRIBED IN             This module has not been documented at this time.
//
// EXTERNAL INTERFACES      StyleLineDraw
//
// MNEMONICS                Standard Hungarian
//
// HISTORY
//
// 04/02/92  Rodneyk     WPG Coding Conventions.
//
//==========================================================================*/



BYTE StyleLineDraw
(
	 LPRESTATE lpREState,    // resource executor context
   RP_SLICE_DESC FAR *s,       /* Line Slice descriptor */
   UBYTE ubLineStyle,         /* Line style pointer    */
   SHORT sRop,             /* Current Raster operation number */
   SHORT wColor             /* Pen color to use White = 0, Black = 0xffff */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\genfile.hpp ===
/*==============================================================================
This C++ object provides a generic layer over various stream types.

	#define		Stream
	WINFILE   Windows file 
	SECFILE   IFAX secure file
  OLEFILE   OLE2 IStream

01-Nov-93   RajeevD    Created.
03-Mar-94   RajeevD    Added IStream support.
==============================================================================*/
#ifndef _INC_GENFILE
#define _INC_GENFILE

#include <ifaxos.h>

#ifdef SECFILE
#include <awfile.h>
#endif

#ifdef OLEFILE
#ifdef WIN32
#include <objerror.h>
#endif
#include <memory.h>
#include <objbase.h>
#endif

// seek origins
#define SEEK_BEG 0
#define SEEK_CUR 1 
#define SEEK_END 2

typedef struct FAR GENFILE
{
	GENFILE (void) {fOpen = FALSE;}

#ifdef WINFILE

	HFILE hf;
	
	BOOL Open  (LPVOID lpFilePath, WORD wMode)
		{ return (fOpen = (hf = _lopen ((LPSTR) lpFilePath, wMode)) != HFILE_ERROR); }
	
 	BOOL Read  (LPVOID lpRead, UINT cbRead)
		{ return _lread  (hf, (char FAR*) lpRead,  cbRead) == cbRead; }

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
		{ return _lwrite (hf, (char FAR*) lpWrite, cbWrite) == cbWrite; }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
		{ return _llseek (hf, lOffset, wOrigin) != -1L; }

	DWORD Tell (void)
		{ return _llseek (hf, 0, SEEK_CUR); }

	~GENFILE ()
		{ if (fOpen) _lclose (hf); }

#endif // WINFILE

#ifdef SECFILE

	hOpenSecureFile hosf;

	BOOL Open  (LPVOID lpFilePath, WORD wMode)
		{ return (fOpen = !SecOpenFile ((LPhSecureFile) lpFilePath, &hosf, wMode)); }

 	BOOL Read  (LPVOID lpRead, UINT cbRead)
		{ return SecReadFile  (&hosf, lpRead, cbRead) == cbRead; }

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
		{ return SecWriteFile (&hosf, lpWrite, cbWrite) == cbWrite; }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
		{ return SecSeekFile  (&hosf, lOffset, wOrigin) != -1L; }

	DWORD Tell (void)
		{ return SecSeekFile (&hosf, 0, SEEK_CUR);}

	~GENFILE ()
		{ if (fOpen) SecCloseFile (&hosf); }

#endif // SECFILE

#ifdef OLEFILE

	LPSTREAM lpStream;
	
	BOOL Open  (LPVOID lpFilePath, WORD wMode)
	{
		lpStream = (LPSTREAM) lpFilePath;
		Seek (0, STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET
		return TRUE;
	}
	
 	BOOL Read  (LPVOID lpRead, UINT cbRead)
	{ 
		DWORD cbActual;
		lpStream->Read (lpRead, cbRead, &cbActual);
		return (cbRead == cbActual);
	}

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
	  { return (lpStream->Write (lpWrite, cbWrite, NULL) == S_OK); }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
	{
		LARGE_INTEGER dlOffset;		
		ULARGE_INTEGER dlNewOffset;

		LISet32 (dlOffset, lOffset);
		return (lpStream->Seek (dlOffset, wOrigin, &dlNewOffset) == S_OK);
	}

	DWORD Tell (void)
	{
		LARGE_INTEGER dlOffset;
		ULARGE_INTEGER dlNewOffset;

		LISet32 (dlOffset, 0);
		lpStream->Seek (dlOffset, SEEK_CUR, &dlNewOffset);
		return dlNewOffset.LowPart;
	}
		
	~GENFILE () { }
  
#endif // OLEFILE

	BOOL fOpen;
}
	FAR *LPGENFILE;

#endif // _INC_GENFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\mmrview.cpp ===
/*==============================================================================
This module provides MMR rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#ifdef VIEWMMR

#include <memory.h>
#include "viewrend.hpp"

//==============================================================================
MMRVIEW::MMRVIEW (DWORD nType)
{
	_fmemset ((LPBYTE) this + sizeof(LPVOID), 0, sizeof(MMRVIEW) - sizeof(LPVOID));

	DEBUGCHK (lpSpool == NULL);
	DEBUGCHK (lpCodec == NULL);
	DEBUGCHK (lpbufIn == NULL);
	nTypeOut = nType;
}

//==============================================================================
MMRVIEW::~MMRVIEW ()
{
	if (lpSpool) SpoolReadClose (lpSpool);
	if (lpCodec) GlobalFreePtr (lpCodec);
	if (lpbufIn) SpoolFreeBuf (lpbufIn);
}
		
//==============================================================================
BOOL MMRVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	UINT cbCodec;
	
	if (!this)
		return_error (("VIEWREND could not allocate context!\r\n"));

	// Open spool file.
	lpSpool = SpoolReadOpen (lpFilePath, &sh);
	if (!lpSpool)
		return_error (("VIEWREND could not open spool file!\r\n"));

	// Fill VIEWINFO.
	lpvi->cPage = SpoolReadCountPages (lpSpool);
	lpvi->xRes = sh.xRes;
	lpvi->yRes = sh.yRes;
	lpvi->yMax = 0;

	// Set band size.
	DEBUGCHK (lpwBandSize);
	cbBand = *lpwBandSize;
  if (cbBand < 2 * sh.cbLine)
 	{
		cbBand = 2 * sh.cbLine;
		*lpwBandSize = cbBand;
	}
	
	// Set up codec.
	fcp.nTypeIn  = MMR_DATA;
	fcp.nTypeOut = LRAW_DATA;
	fcp.cbLine = sh.cbLine;
	DEBUGCHK (fcp.nKFactor == 0);

	// Query codec.
	cbCodec = FaxCodecInit (NULL, &fcp);
	if (!cbCodec)
		return_error (("VIEWREND could not init codec!\r\n"));

	// Initialize codec.
	lpCodec = GlobalAllocPtr (0, cbCodec);
	if (!lpCodec)
		return_error (("VIEWREND could not allocate codec!\r\n"));

	return SetPage (0);
}

//==============================================================================
BOOL MMRVIEW::SetPage (UINT iPage)
{
	if (!SpoolReadSetPage (lpSpool, iPage))
		return FALSE;
	fEOP = FALSE;
	if (lpbufIn)
	{
		SpoolFreeBuf (lpbufIn);
		lpbufIn = NULL;
	}
	FaxCodecInit (lpCodec, &fcp);
	return TRUE;
}
	
//==============================================================================
BOOL MMRVIEW::GetBand (LPBITMAP lpbmBand)
{
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);

	// Fill descriptor.
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = 8 * fcp.cbLine;
	lpbmBand->bmWidthBytes = fcp.cbLine;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	// Trap end of page.
	if (fEOP)
	{
		lpbmBand->bmHeight = 0;
		return TRUE;
	}
	
	// Set up output buffer.
	bufOut.lpbBegBuf  = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf = cbBand;
	bufOut.Reset();
	bufOut.dwMetaData = LRAW_DATA;
	
	while (1)
	{
		// Fetch input buffer?
		if (!lpbufIn)
		{
			if (!(lpbufIn = SpoolReadGetBuf (lpSpool)))
				return_error (("VIEWREND could not fetch input buffer.\r\n"));

			switch (lpbufIn->dwMetaData)
			{
				case END_OF_PAGE:
				case END_OF_JOB:
				  // metabuffers will be freed in SetPage or destructor.
					fEOP = TRUE;
					goto done;
			
				case MMR_DATA:
					break;

				default:
					continue;
			}
		}

		switch (FaxCodecConvert (lpCodec, lpbufIn, &bufOut))
		{
			case FC_DECODE_ERR:	
				return_error (("VIEWREND fatal MMR decode error!\r\n"));

			case FC_INPUT_EMPTY:
				SpoolFreeBuf (lpbufIn);
				lpbufIn = NULL;
				continue;			

			case FC_OUTPUT_FULL:
				goto done;
		}

	} // while (1)

done:

	if (nTypeOut == HRAW_DATA)	
		BitReverseBuf (&bufOut);
	lpbmBand->bmHeight = bufOut.wLengthData / fcp.cbLine;
	return TRUE;
}

#endif // VIEWMMR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\viewrend.cpp ===
/*==============================================================================
This module provides MMR rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#include <ifaxos.h>
#include <viewrend.h>
#include <dcxcodec.h>
#include "viewrend.hpp"

#ifdef DEBUG
DBGPARAM dpCurSettings = {"VIEWREND"};
#endif

// file signatures
#define MMR_SIG 0x53465542 // "BUFS"
#define RBA_SIG 0x53505741 // "AWPS"

//==============================================================================
// C Export Wrappers
//==============================================================================

#ifndef WIN32

EXPORT_DLL BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
LPVOID
WINAPI
ViewerOpen
(
	LPVOID     lpFile,      // IFAX key or Win3.1 path or OLE2 IStream
	DWORD      nType,       // data type: HRAW_DATA or LRAW_DATA
	LPWORD     lpwResoln,   // output pointer to x, y dpi array
	LPWORD     lpwBandSize, // input/output pointer to output band size
	LPVIEWINFO lpViewInfo   // output pointer to VIEWINFO struct
)
{
	GENFILE gf;
	DWORD dwSig;
	LPVIEWREND lpvr;
	VIEWINFO ViewInfo;
	
 	DEBUGMSG (1, ("VIEWREND ViewerOpen entry\r\n"));
 	 
  // Read DWORD signature.
  if (!(gf.Open (lpFile, 0)))
  	return_error (("VIEWREND could not open spool file!\r\n"));

#ifdef VIEWDCX
	if (!gf.Read (&dwSig, sizeof(dwSig)))
  	return_error (("VIEWREND could not read signature!\r\n"));
#else
	dwSig = 0;  	
#endif

	if (dwSig != DCX_SIG)
	{
   	if (!gf.Seek (2, 0) || !gf.Read (&dwSig, sizeof(dwSig)))
  		return_error (("VIEWREND could not read signature!\r\n"));
  }
	
	// Determine file type.
  switch (dwSig)
  {

#ifdef VIEWMMR
  	case MMR_SIG:
  	  lpvr = new MMRVIEW (nType);
 		  break;
#endif

#ifdef VIEWDCX
		case DCX_SIG:
			lpvr = new DCXVIEW (nType);
			break;
#endif		

#ifdef VIEWRBA
 		case RBA_SIG:
	 	case ID_BEGJOB:
			lpvr = new RBAVIEW (nType);
			break;
#endif
			
  	default:
  		return_error (("VIEWREND could not recognize signature!\r\n"));
  }

	if (!lpViewInfo)
		lpViewInfo = &ViewInfo;
	
	// Initialize context.
	if (!lpvr->Init (lpFile, lpViewInfo, lpwBandSize))
		{ delete lpvr; lpvr = NULL;}

	if (lpwResoln)
	{
		lpwResoln[0] = lpViewInfo->xRes;
		lpwResoln[1] = lpViewInfo->yRes;
	}
	
	return lpvr;
}

//==============================================================================
BOOL WINAPI ViewerSetPage (LPVOID lpContext, UINT iPage)
{
	return ((LPVIEWREND) lpContext)->SetPage (iPage);
}

//==============================================================================
BOOL WINAPI ViewerGetBand (LPVOID lpContext, LPBITMAP lpbmBand)
{
	return ((LPVIEWREND) lpContext)->GetBand (lpbmBand);
}

//==============================================================================
BOOL WINAPI ViewerClose (LPVOID lpContext)
{
	delete (LPVIEWREND) lpContext;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\viewrend.hpp ===
#ifndef _VIEWHPP_
#define _VIEWHPP_

#include <ifaxos.h>
#include <viewrend.h>
#include <rambo.h>
#include <faxspool.h>
#include <faxcodec.h>
#include "genfile.hpp"

#define return_error(mesg) do {DEBUGMSG (1, mesg); return FALSE;} while(0)

// global memory
#ifdef IFBGPROC
#define GlobalAllocPtr(f,cb) IFMemAlloc(f,cb,NULL)
#define GlobalFreePtr(lp) IFMemFree(lp)
#else
#include <windowsx.h>
#endif

// base viewer context
typedef struct FAR VIEWREND : public GENFILE
{
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD) = 0;
  virtual BOOL SetPage (UINT iPage) = 0;
  virtual BOOL GetBand (LPBITMAP) = 0;
  virtual ~VIEWREND() {}
}
	FAR* LPVIEWREND;

// MMR viewer context
typedef struct FAR MMRVIEW : public VIEWREND
{
	LPVOID lpSpool;
	SPOOL_HEADER sh;
	BOOL fEOP;
	
	LPVOID lpCodec;
	FC_PARAM fcp;
		
	LPBUFFER lpbufIn;
	BUFFER bufOut;
	DWORD nTypeOut;
	WORD  cbBand;

  MMRVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~MMRVIEW();
}
	FAR *LPMMRVIEW;

#define MAX_PAGE 1024

// RBA viewer context
typedef struct FAR RBAVIEW : public VIEWREND
{
	DWORD    dwOffset[MAX_PAGE];
	BEGJOB   BegJob;
	LPVOID   ResDir[256];
	LPVOID   lpCodec;
	BUFFER   bufIn;
	DWORD    nTypeOut;
	UINT     iMaxPage;
	HANDLE   hHRE;
	
  RBAVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~RBAVIEW();

  BOOL ExecuteRPL  (LPBITMAP, LPRESHDR);
  BOOL ExecuteBand (LPBITMAP, LPRESHDR);
}
	FAR *LPRBAVIEW;

// DCX viewer context
typedef struct FAR DCXVIEW : public VIEWREND
{
	LPVOID   lpCodec;
	FC_PARAM fcp;
	DWORD    nTypeOut;
	BUFFER   bufIn;
	DWORD    cbPage;
	BOOL     fEndPage;
	WORD     cbBand;
			
  DCXVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~DCXVIEW();
}
	FAR *LPDCXVIEW;
		
#endif // _VIEWHPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\rpgen.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         RPGEN.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Rendering primitives, generic,
//
// DESCRIBED IN                 Resource Executor design spec.
//
//
// MNEMONICS                    n/a
//
// HISTORY                      Bert Douglas  5/1/91 Initial coding started
//                              mslin/dstseng 01/17/92 revise for HRE
//                              dstseng       03/06/92 <1> RP_FillScanRow 
//															 ->RP_FILLSCANROW for asm. version.
//										  dstseng		 03/19/92 <2> comment out unnecessary code.
//															 which was implemented for frac. version of
//															 slicing algorithm.
//
//===========================================================================
#include <windows.h>
#include "constant.h"
#include "jtypes.h"
#include "jres.h"
#include "frame.h"      // driver header file, resource block format
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

//---------------------------------------------------------------------------
void RP_SliceLine
(
   SHORT s_x1, SHORT s_y1,  // endpoint 1
   SHORT s_x2, SHORT s_y2,  // endpoint 2
   RP_SLICE_DESC FAR* psd, // output slice form of line
   UBYTE fb_keep_order      // keep drawing order on styled lines/
)

// PURPOSE
//    Convert a line from endpoint form to slice form
//
//    Slices will run from left to right
//
//    The generated slices are of maximal length and are in a horizontal,
//    vertical or diagonal direction.  Most frame buffer hardware can be
//    accessed with particular efficiency in these directions.  All slices
//    of a line are in the same direction.
//
//    Clipping must be performed by caller.  All coordinates will be non-negative.
//
//    Basic algorithm is taken from :
//      Bresenham, J. E. Run length slice algorithms for incremental lines.
//      In "Fundamental Algorithms for Computer Graphics", R. A. Earnshaw, Ed.
//      NATO ASI Series, Springer Verlag, New York, 1985, 59-104.
//
//    Modifications have been made to the above algorithm for:
//      - sub-pixel endpoint coordinates
//      - equal error rounding rules
//      - GIQ (grid intersect quantization) rules
//      - first/last pixel exclusion
//
//    The line is sliced in four steps:
//
//    STEP 1:  Find the pixel center cooridnates of the first and
//    last pixels in the line.  This is done according to the GIQ conventions.
//
//    STEP 2:  Use these integer pixel center endpoint coordinates
//    to produce the Bresenham slices for the line.  The equal error rounding
//    rule is used, when the first and last slices are not of equal length, to
//    decide which end gets the short slice.
//
//    STEP 3:  Adjust the length of the first and last slices for the
//    effect of the sub-pixel endpoint coordinates.  Note that the sub-pixel
//    part of the coordinates can only effect the first and last slices and
//    has no effect on the intermediate slices.
//
//    STEP 4:  Perform the conditional exclusion of the first and
//    last pixels from the line.
//
//
// ASSUMPTIONS & ASSERTIONS     none.
//
// INTERNAL STRUCTURES          none.
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
   SHORT  s_q,s_r;               /* defined in Bresenhams paper            */
   SHORT  s_m,s_n;               /* "                                      */
   SHORT  s_dx,s_dy;             /* "                                      */
   SHORT  s_da,s_db;             /* "                                      */
   SHORT  s_del_b;               /* "                                      */
   SHORT  s_abs_dy;              /* absolute value of s_dy                 */

   SHORT  s_sy;                  /* 1 or -1 , sign of s_dy                 */
   SHORT  s_dx_oct,s_dy_oct;     /* octant dir  xy= 0/1 1/1 1/0 1/-1 0/-1  */
   SHORT  s_dx_axial,s_dy_axial; /* 1/2 octant axial dir xy= 0/1 1/0 -1/0  */
   SHORT  s_dx_diag, s_dy_diag;  /* 1/2 octant diagonal dir xy= 1/1 1/-1   */
   SHORT  s_t;                   /* temporary                              */
   FBYTE  fb_short_end_last;     /* 0=first end short, 1=last end short    */
   UBYTE  fb_unswap;             /* need to un-swap endpoints at return    */

   fb_unswap = FALSE;


   /*------------------------------------------------------------*/
   /* STEP 1: Find pixel center coordinates of first/last pixels */
   /*------------------------------------------------------------*/

   /* always draw left to right, normalize to semicircle with x >= 0 */
   s_dx = s_x2 - s_x1;
   if ( s_dx < 0 )
   {
      fb_unswap = fb_keep_order;
      s_dx  = -s_dx;
      s_t     = s_x2;
      s_x2 = s_x1;
      s_x1 = s_t;
      s_t     = s_y2;
      s_y2 = s_y1;
      s_y1 = s_t;
   }
   s_dy = s_y2 - s_y1;


   /*------------------------------------------------------------*/
   /* STEP 2: Produce slices using the Bresenham algorithm       */
   /*------------------------------------------------------------*/

   if ( s_dy < 0 )
   {
      s_abs_dy = -s_dy;
      s_sy = -1;
      fb_short_end_last = 1;
    }
   else
   {
      s_abs_dy = s_dy;
      s_sy = 1;
      fb_short_end_last = 0;
   }

   /* normalize to octant */
   if ( s_dx >= s_abs_dy )
   {
      s_da = s_dx;
      s_db = s_abs_dy;
      s_dx_oct = 1;
      s_dy_oct = 0;
   }
   else
   {
      s_da = s_abs_dy;
      s_db = s_dx;
      s_dx_oct = 0;
      s_dy_oct = s_sy;
      fb_short_end_last = 1;
   }

   /* normalize to half octant */
   s_del_b = s_db;
   s_t = s_da - s_db;
   if ( s_del_b > s_t )
   {
      s_del_b = s_t;
      fb_short_end_last ^= 1;
   }

   /* handle special case of slope of 2 */
   s_dx_axial = s_dx_oct;
   s_dy_axial = s_dy_oct;
   s_dx_diag = 1;
   s_dy_diag = s_sy;
   if (  ( s_da == (2 * s_del_b) )
      && ( s_dy < 0 )
      )
   {  s_dx_axial = 1;
      s_dy_axial = s_sy;
      s_dx_diag = s_dx_oct;
      s_dy_diag = s_dy_oct;
      fb_short_end_last ^= 1;
   }

   /* determine slice movement and skip directions */
   if ( s_db == s_del_b )
   {
      /* slice direction is axial, skip direction is diagonal */
      psd->s_dx_draw = s_dx_axial;
      psd->s_dy_draw = s_dy_axial;
      psd->s_dx_skip = s_dx_diag - s_dx_axial;
      psd->s_dy_skip = s_dy_diag - s_dy_axial;
   }
   else
   {
      /* slice direction is diagonal, skip direction is axial */
      psd->s_dx_draw = s_dx_diag;
      psd->s_dy_draw = s_dy_diag;
      psd->s_dx_skip = s_dx_axial - s_dx_diag;
      psd->s_dy_skip = s_dy_axial - s_dy_diag;
   }

   /* handle zero slope lines with special case */
   if ( s_del_b == 0 )
   {
      psd->us_first = s_da + 1;
      psd->us_n_slices = 0;
      psd->us_last = 0;
   }
   else
   /* general case, non-zero slope lines */
   {
      /* basic Bresenham parameters */
      s_q = s_da / s_del_b;
      s_r = s_da % s_del_b;
      s_m = s_q / 2;
      s_n = s_r;
      if ( s_q & 1 ) s_n += s_del_b;

      /* first and last slice length */
      psd->us_first = psd->us_last = s_m + 1;
      if ( s_n == 0 )
      {
         if ( fb_short_end_last )
            psd->us_last -= 1;
         else
            psd->us_first -= 1;
      }

      /* remaining line slice parameters */
      psd->us_small = s_q;
      psd->s_dis_sm = 2*s_r;
      psd->s_dis_lg = psd->s_dis_sm - (2*s_del_b);
      psd->s_dis = s_n + psd->s_dis_lg;
      if ( s_dy < 0 ) psd->s_dis -= 1;
      psd->us_n_slices = s_del_b - 1;

   }

   /* output endpoints */
   psd->us_x1 = s_x1;
   psd->us_y1 = s_y1;
   psd->us_x2 = s_x2;
   psd->us_y2 = s_y2;

   if ( fb_unswap )
   {
      psd->us_x1 = s_x2;
      psd->us_y1 = s_y2;
      psd->us_x2 = s_x1;
      psd->us_y2 = s_y1;
      psd->s_dx_draw = -psd->s_dx_draw;
      psd->s_dy_draw = -psd->s_dy_draw;
      psd->s_dx_skip = -psd->s_dx_skip;
      psd->s_dy_skip = -psd->s_dy_skip;
      s_t = psd->us_first;
      psd->us_first = psd->us_last;
      psd->us_last = s_t;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\rplnee.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         RPLNEE.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Using Bresenham run slice algorithm to
//                              draw single pixel line.
//
// DESCRIBED IN                 Resource Executor design spec.
//
// The drawing sectors are also described in the following diagram.
// Y is shown increasing down the page as do the printer physical
// coordinates.  The program code handles separately sectors 0/7, 6/1, 5/2
// and 4/3.
//
//
//             |        x         x
//             |                 x
//             |       x        x
//             |               x
//             |  0   x   1   x
//             |             x
//             |     x      x
//             |           x
//             |    x     x
//             |         x   2
//             |   x    x         x
//             |       x        x
//             |  x   x       x
//             |     x      x
//             | x  x     x
//             |   x    x
//             |x x   x      3
//             | x  x
//             |x x
//             |-------------------            --> X
//             |x x
//             | x  x
//             |x x   x      4
//             |   x    x
//             | x  x     x
//             |     x      x
//             |  x   x       x
//             |       x        x
//             |   x    x         x
//             |         x   5
//             |    x     x
//             |           x
//             |     x      x
//             |             x
//             |  7   x   6   x
//             |               x
//             |       x        x
//             |                 x
//             |        x         x
//
//
//             |
//             |
//            \|/
//
//             Y
//
//
// MNEMONICS                    n/a
//
// HISTORY  1/17/92 dstseng     created
//
//===========================================================================

// include file
#include <windows.h>

#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c
#include "rplnee.h"

static
void ShortSlice07(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void ShortSlice16(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void ShortSlice25(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void DisplaySlice34(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);

//---------------------------------------------------------------------------
UINT                            //always return 0 to upper level
RP_LineEE_Draw
(
    RP_SLICE_DESC FAR FAR* line,        /* output slice form of line */
    LPBITMAP      lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              according to different sector (0-7),
//                              this routine will call different functions
//                              to draw the slices with the length recorded
//                              in FAR* line.
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;

    /* Get function address according to drawing & skipping direction */
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;

    /* Call corresponding function to render line */
    (*sector_function[func])(line, lpbm);
    return(0);
}

//---------------------------------------------------------------------------
static void
Sector07
(
    RP_SLICE_DESC FAR* line,        /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice07()
//                              to draw the line located in sector 0/7
//                              dy/dx > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR0)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 0 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 7 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice07(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice07(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice07(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector16
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice16()
//                              to draw the line located in sector 1/6
//                              2 > dy/dx > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR1)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 1 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 6 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice16(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice16(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice16(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector25
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice25()
//                              to draw the line located in sector 2/5
//                              1 < dx/dy < 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR2)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 2 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 5 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice25(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice25(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice25(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector34
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call DisplaySlice34()
//                              to draw the line located in sector 3/4
//                              dx/dy > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR3)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 3 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 4 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
        DisplaySlice34(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
        DisplaySlice34(line, &drawInfo, 0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
        DisplaySlice34(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
ShortSlice07
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 0/7
//                              dy/dx > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16 i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition +=  drawInfo->nextY >> 1;
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition +=  drawInfo->nextY >> 1;
            }
            if ((drawInfo->bitPosition >>= 1) == 0) {
                drawInfo->bytePosition++;
                drawInfo->bitPosition = 0x8000;
            }
        }
        loop2nd = 4;
    }
    return;
}


//---------------------------------------------------------------------------
static void
ShortSlice16
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 1/6
//                              2> dy/dx > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16  i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            /* Adjust skip direction by backword 1 bit */
            if ((drawInfo->bitPosition <<= 1) == 0) {
                drawInfo->bytePosition--;
                drawInfo->bitPosition = 0x0001;
            }
        }
        loop2nd = 4;
    }
    return;
}


//---------------------------------------------------------------------------
static void
ShortSlice25
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 2/5
//                              2> dx/dy > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16 i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            /* Adjust skip direction by backword 1 column */
            drawInfo->bytePosition -= drawInfo->nextY >> 1;
        }
        loop2nd = 4;
    }
    return;
}

//---------------------------------------------------------------------------
static void
DisplaySlice34
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 3/4
//                              dx/dy > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 nSlice, sliceLength;
uint16 wordNumber, lShiftInLastWord;
int32  ddaValue, ddaDiff;
uint16  i;
uint16 tmp;

    if (firstOrLast) {
        nSlice = 1;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        nSlice = line->us_n_slices;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = (line->s_dis_lg - line->s_dis_sm);
    }
    while (nSlice--) {
        if (!firstOrLast) {
            sliceLength = line->us_small;
            ddaValue += line->s_dis_sm;
        } else if (firstOrLast == FIRST) {
            sliceLength = line->us_first;
            ddaValue += 0;
        } else {
            sliceLength = line->us_last;
            ddaValue += 0;
        }
        if (ddaValue >= 0) {
            ddaValue  += ddaDiff;
            sliceLength += 1;
        }
        wordNumber = (drawInfo->bitPosition + sliceLength) >> 4;
        lShiftInLastWord = 16 -
                         ((drawInfo->bitPosition + sliceLength) & 0x0F);
        if (!wordNumber) { /* slice < 16 bits */
            /*
            *drawInfo->bytePosition |=
                ((uint16)ALLONE >> drawInfo->bitPosition) << lShiftInLastWord;
             */
            tmp = (uint16)ALLONE >> (16 - sliceLength);
            tmp <<= lShiftInLastWord;
            *drawInfo->bytePosition |= (tmp >> 8) | (tmp << 8);
        } else {
            tmp = (uint16)ALLONE >> drawInfo->bitPosition;
            *drawInfo->bytePosition++ |= (tmp >> 8) | (tmp << 8);
            for (i = 1; i < wordNumber; i++) {
                *drawInfo->bytePosition++ = (uint16)ALLONE;
            }
            if (lShiftInLastWord != 16) {
                tmp =  (uint16)ALLONE << lShiftInLastWord;
                *drawInfo->bytePosition |= (tmp >> 8) | (tmp << 8);
            }

        }
        /* Adjust skip direction by backword 1 column */
        drawInfo->bytePosition += drawInfo->nextY >> 1;
        drawInfo->bitPosition += sliceLength;
        wordNumber = drawInfo->bitPosition >> 4;
        if (wordNumber) {
            drawInfo->bitPosition &= 0x0F;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\roptable.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPTABLE.BLT
;
; Raster operation code templates for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file defines the code templates for all raster operations which
; BitBLT supports.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

if	MASMFLAGS and PUBDEFS
	public	Sn
	public	DDx
	public	DPna
	public	Pn
	public	PDSanon
	public	PSnon
	public	DPSona
	public	PSon
	public	PDSnaon
	public	PDSaon
	public	DPon
	public	PDSonon
	public	DPSnoon
	public	DPSoon
	public	DSon
	public	PDSona
	public	SDPxnon
	public	SSPxDSxaxn
	public	SPxDSxa
	public	PSDPSanaxx
	public	SDPSanaxn
	public	DSna
	public	PDSPanaxn
	public	DPSana
	public	PDSnaxn
	public	DPSaon
	public	PDSPaox
	public	PDSox
	public	SDPSxaxn
	public	DPSxa
	public	DSPDxaxn
	public	DPSnaa
	public	PSna
	public	DPSaan
	public	PSDnaon
	public	SPDnaon
	public	PDSPxaxn
	public	SDPSaox
	public	PSDPSaoxxn
	public	SSPxPDxaxn
	public	SPxPDxa
	public	DSPDSoaxxn
	public	SPDSoax
	public	PDSoan
	public	PSDPxox
	public	SDPxon
	public	PSDnoan
	public	PSan
	public	SDPnaon
	public	SDPaon
	public	PSDPaox
	public	SDPSoox
	public	SPDSaox
	public	DPSDxaxn
	public	SDPox
	public	PSDPoax
	public	SDPoan
	public	PSx
	public	SPDnox
	public	SPDSxox
	public	PDSxon
	public	SPDnoan
	public	SPDSonox
	public	DPSxnan
	public	SPDSnaox
	public	SPDSanaxn
	public	PDSana
	public	DSan
	public	PSDPxaxn
	public	SDPxa
	public	DSPDaox
	public	PDSPDaoxxn
	public	DPSDoax
	public	DPSanon
	public	PDSnox
	public	DSnon
	public	SDPana
	public	SSPxDSxoxn
	public	SPxDSxo
	public	PDSPxox
	public	DPSxon
	public	PDna
	public	Dn
	public	DPSDaox
	public	SPDSxaxn
	public	PDSxa
	public	DPx
	public	PDSxnon
	public	DPSnoan
	public	PDSPoax
	public	DPSoan
	public	PDSax
	public	DPSnox
	public	DPSox
	public	PDSxnan
	public	DPSDonox
	public	DPSDxox
	public	DSPnaon
	public	PDSPnaox
	public	DPan
	public	DSPDSaoxxn
	public	SDPnox
	public	DPSnaxn
	public	DPSax
	public	DSx
	public	PDSxxn
	public	SDPSonox
	public	PSDPSonoxxn
	public	DPSonon
	public	SDPSoax
	public	PSDPSoaxxn
	public	SDPax
	public	DSPDoax
	public	PDSPDoaxxn
	public	SDPSnoax
	public	SSDxPDxaxn
	public	SDxPDxa
	public	SDPSxox
	public	SDPnoan
	public	DSPDxox
	public	SDPSnaox
	public	DPSnaon
	public	DSPnoan
	public	PDSPnoax
	public	DPSxnon
	public	PDSnoan
	public	SPDSnoax
	public	SDPxnan
endif

ROPDEF macro lbl,ne,whocares
if1
if MASMFLAGS and DEBUG
public lbl
endif
ROP&ne=(offset lbl)-(offset roptable)	;;Start with offset
irpc x,lbl
ROP&ne = ROP&ne AND (NOT NEGATE_NEEDED)
ifidn <n>,<&&x>
ROP&ne = ROP&ne OR NEGATE_NEEDED 	;;Show negate needed
endif
ifidn <P>,<&&x>
ROP&ne = ROP&ne OR PATTERN_PRESENT	;;Show pattern present
endif
ifidn <S>,<&&x>
ROP&ne = ROP&ne OR SOURCE_PRESENT	;;Show source needed
endif
endm
ROPDEF1 ROP&ne,%((offset $)-(offset lbl))
endif
endm


ROPDEF1 macro lbl,len
if len					;;Skip 0
lbl = lbl OR (ROPLen&len SHL 10)	;;Set size index
endif
endm



	public	roptable
roptable	label	word

	errn$	roptable			;Must be at offset 0
Sn:
	ROPDEF	Sn,0033,0008


	errn$	roptable			;Must be at offset 0

	dw	ROP0000,ROP0001,ROP0002,ROP0003
	dw	ROP0004,ROP0005,ROP0006,ROP0007
	dw	ROP0008,ROP0009,ROP000A,ROP000B
	dw	ROP000C,ROP000D,ROP000E,ROP000F
	dw	ROP0010,ROP0011,ROP0012,ROP0013
	dw	ROP0014,ROP0015,ROP0016,ROP0017
	dw	ROP0018,ROP0019,ROP001A,ROP001B
	dw	ROP001C,ROP001D,ROP001E,ROP001F
	dw	ROP0020,ROP0021,ROP0022,ROP0023
	dw	ROP0024,ROP0025,ROP0026,ROP0027
	dw	ROP0028,ROP0029,ROP002A,ROP002B
	dw	ROP002C,ROP002D,ROP002E,ROP002F
	dw	ROP0030,ROP0031,ROP0032,ROP0033
	dw	ROP0034,ROP0035,ROP0036,ROP0037
	dw	ROP0038,ROP0039,ROP003A,ROP003B
	dw	ROP003C,ROP003D,ROP003E,ROP003F
	dw	ROP0040,ROP0041,ROP0042,ROP0043
	dw	ROP0044,ROP0045,ROP0046,ROP0047
	dw	ROP0048,ROP0049,ROP004A,ROP004B
	dw	ROP004C,ROP004D,ROP004E,ROP004F
	dw	ROP0050,ROP0051,ROP0052,ROP0053
	dw	ROP0054,ROP0055,ROP0056,ROP0057
	dw	ROP0058,ROP0059,ROP005A,ROP005B
	dw	ROP005C,ROP005D,ROP005E,ROP005F
	dw	ROP0060,ROP0061,ROP0062,ROP0063
	dw	ROP0064,ROP0065,ROP0066,ROP0067
	dw	ROP0068,ROP0069,ROP006A,ROP006B
	dw	ROP006C,ROP006D,ROP006E,ROP006F
	dw	ROP0070,ROP0071,ROP0072,ROP0073
	dw	ROP0074,ROP0075,ROP0076,ROP0077
	dw	ROP0078,ROP0079,ROP007A,ROP007B
	dw	ROP007C,ROP007D,ROP007E,ROP007F



	errn$	roptable,-256			;Must be 256 bytes afterwards
	db	2,3,4,5,7,9,11,13





;	The actual raster operation templates follow.
;
;	Entry:	AL     =  Source byte
;		DH     =  Pattern Bytes
;		ES:DI --> Destination byte
;
;	Exit:	AL     =  Result
;		DH     =  Pattern Bytes
;		ES:DI --> Destination byte
;		AH	  IS possibly the destination byte
;
;	Uses:	AL,AH,DH,DL


;-----------------------------------------------------------------
; In Wes' World:
;	The actual raster operation templates follow.
;
;	Entry:	AX     =  Source word
;		DX     =  Pattern Word
;		ES:DI --> Destination word
;
;	Exit:	AX     =  Result
;		DX     =  Pattern Word
;		ES:DI --> Destination word
;		BP,BX??	  IS possibly the destination word
;
;	Uses:	AL,AH,DH,DL
;-----------------------------------------------------------------


DDx:
	xor	al,al
	ROPDEF	DDx,0000,0042


DPna:
Pn:
	mov	al,dh
	ROPDEF	Pn,000F,0001
	not	al
PDSanon:
	and	al,es:[di]
	ROPDEF	DPna,000A,0329
PSnon:
	not	al
DPSona:
PSon:
	or	al,dh
	ROPDEF	PDSanon,0008,0F08
	ROPDEF	PSon,0003,00AA
	ROPDEF	PSnon,000C,0324
PDSnaon:
	not	al
PDSaon:
	and	al,es:[di]
	ROPDEF	DPSona,0002,0C89
	or	al,dh
	ROPDEF	PDSnaon,000D,0B25
	ROPDEF	PDSaon,0007,02C5


DPon:
	mov	al,dh
PDSonon:
	or	al,es:[di]
	ROPDEF	DPon,0005,00A9
DPSnoon:
	not	al
DPSoon:
	or	al,dh
	ROPDEF	PDSonon,000E,08A5
DSon:
PDSona:
	or	al,es:[di]
	ROPDEF	DPSnoon,0004,0C88
	ROPDEF	DPSoon,0001,0289
	ROPDEF	DSon,0011,00A6
	not	al
	and	al,dh
	ROPDEF	PDSona,0010,0C85


SDPxnon:
	mov	ah,es:[di]
	xor	ah,dh
	not	ah
	or	al,ah
	ROPDEF	SDPxnon,0012,0868


SSPxDSxaxn:
	mov	dl,al
SPxDSxa:
	mov	ah,dh
	xor	ah,al
	xor	al,es:[di]
	and	al,ah
	ROPDEF	SPxDSxa,0024,0D55
	xor	al,dl
	ROPDEF	SSPxDSxaxn,0017,1D54


PSDPSanaxx:
SDPSanaxn:
	mov	dl,al
	and	al,dh
DSna:
	not	al
	and	al,es:[di]
	ROPDEF	DSna,0022,0326
	xor	al,dl
	ROPDEF	SDPSanaxn,0019,1CC8
	xor	al,dh
	ROPDEF	PSDPSanaxx,0016,5CCA


PDSPanaxn:
DPSana:
	and	al,dh
PDSnaxn:
	not	al
	and	al,es:[di]
	ROPDEF	DPSana,002A,0CC9
	xor	al,dh
	ROPDEF	PDSnaxn,002D,060A
	ROPDEF	PDSPanaxn,0025,1CC5




DPSaon:
PDSPaox:
	and	al,dh
PDSox:
	or	al,es:[di]
	ROPDEF	DPSaon,0015,02C9
	xor	al,dh
	ROPDEF	PDSox,001E,01A5
	ROPDEF	PDSPaox,001A,06C5


SDPSxaxn:
	mov	dl,al
DPSxa:
	xor	al,dh
	and	al,es:[di]
	ROPDEF	DPSxa,0028,0369
	xor	al,dl
	ROPDEF	SDPSxaxn,001B,0768


DSPDxaxn:
	mov	ah,es:[di]
	mov	dl,ah
	xor	dl,dh
	and	al,dl
	xor	al,ah
	ROPDEF	DSPDxaxn,001D,0766


DPSnaa:
PSna:
	not	al
DPSaan:
	and	al,dh
	ROPDEF	PSna,0030,032A
	and	al,es:[di]
	ROPDEF	DPSnaa,0020,0F09
	ROPDEF	DPSaan,007F,03C9


PSDnaon:
	mov	ah,es:[di]
	not	ah
	and	al,ah
	or	al,dh
	ROPDEF	PSDnaon,000B,0B2A


SPDnaon:
	mov	ah,es:[di]
	not	ah
	and	ah,dh
	or	al,ah
	ROPDEF	SPDnaon,0023,0B24


PDSPxaxn:
	xor	al,dh
	and	al,es:[di]
	xor	al,dh
	ROPDEF	PDSPxaxn,0027,1868


SDPSaox:
PSDPSaoxxn:
	mov	dl,al
	and	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSaox,0026,06C8
	xor	al,dh
	ROPDEF	PSDPSaoxxn,0029,16CA


SSPxPDxaxn:
	mov	dl,al
SPxPDxa:
	mov	ah,es:[di]
	xor	ah,dh
	xor	al,dh
	and	al,ah
	ROPDEF	SPxPDxa,0018,0D59
	xor	al,dl
	ROPDEF	SSPxPDxaxn,002B,1D58


DSPDSoaxxn:
SPDSoax:
	mov	dl,al
PDSoan:
	mov	ah,es:[di]
	or	al,ah
	and	al,dh
	ROPDEF	PDSoan,001F,0385
	xor	al,dl
	ROPDEF	SPDSoax,002C,0784
	xor	al,ah
	ROPDEF	DSPDSoaxxn,0079,1786




PSDPxox:
SDPxon:
	mov	ah,es:[di]
	xor	ah,dh
	or	al,ah
	ROPDEF	SDPxon,0021,0248
	xor	al,dh
	ROPDEF	PSDPxox,002E,064A


PSDnoan:
	mov	ah,es:[di]
	not	ah
	or	al,ah
PSan:
	and	al,dh
	ROPDEF	PSan,003F,00EA
	ROPDEF	PSDnoan,002F,0E2A


SDPnaon:
	mov	ah,dh
	not	ah
	and	ah,es:[di]
	or	al,ah
	ROPDEF	SDPnaon,0031,0B28


SDPaon:
PSDPaox:
	mov	ah,es:[di]
	and	ah,dh
	or	al,ah
	ROPDEF	SDPaon,0013,02C8
	xor	al,dh
	ROPDEF	PSDPaox,001C,06CA



SDPSoox:
	mov	dl,al
	or	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSoox,0032,0688


SPDSaox:
	mov	dl,al
	and	al,es:[di]
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSaox,0034,06C4


DPSDxaxn:
	mov	ah,es:[di]
	xor	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDxaxn,0035,1864


SDPox:
	mov	ah,es:[di]
	or	ah,dh
	xor	al,ah
	ROPDEF	SDPox,0036,01A8


PSDPoax:
SDPoan:
	mov	ah,es:[di]
	or	ah,dh
	and	al,ah
	ROPDEF	SDPoan,0037,0388
PSx:
	xor	al,dh
	ROPDEF	PSx,003C,004A
	ROPDEF	PSDPoax,0038,078A


SPDnox:
	mov	ah,es:[di]
	not	ah
	or	ah,dh
	xor	al,ah
	ROPDEF	SPDnox,0039,0604


SPDSxox:
	mov	dl,al
PDSxon:
	xor	al,es:[di]
	or	al,dh
	ROPDEF	PDSxon,0009,0245
	xor	al,dl
	ROPDEF	SPDSxox,003A,0644


SPDnoan:
	mov	ah,es:[di]
	not	ah
	or	ah,dh
	and	al,ah
	ROPDEF	SPDnoan,003B,0E24


SPDSonox:
	mov	dl,al
	or	al,es:[di]
	not	al
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSonox,003D,18A4


DPSxnan:
	xor	al,dh
SPDSnaox:
	mov	dl,al			;(wasted for DPSxnan)
	not	al
	and	al,es:[di]
	ROPDEF	DPSxnan,007D,0C69
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSnaox,003E,1B24


SPDSanaxn:
	mov	dl,al
PDSana:
DSan:
	and	al,es:[di]
	ROPDEF	DSan,0077,00E6
	not	al
	and	al,dh
	ROPDEF	PDSana,0070,0CC5
	xor	al,dl
	ROPDEF	SPDSanaxn,0043,1CC4


PSDPxaxn:
SDPxa:
	mov	ah,es:[di]
	xor	ah,dh
	and	al,ah
	ROPDEF	SDPxa,0048,0368
	xor	al,dh
	ROPDEF	PSDPxaxn,0047,076A


DSPDaox:
PDSPDaoxxn:
	mov	ah,es:[di]
	mov	dl,ah
	and	dl,dh
	or	al,dl
	xor	al,ah
	ROPDEF	DSPDaox,0046,06C6
	xor	al,dh
	ROPDEF	PDSPDaoxxn,0049,16C5

DPSDoax:
	mov	ah,es:[di]
	or	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDoax,004A,0789


DPSanon:
	and	al,dh
PDSnox:
DSnon:
	not	al
	or	al,es:[di]
	ROPDEF	DPSanon,0040,0F0A
	ROPDEF	DSnon,0044,0328
	xor	al,dh
	ROPDEF	PDSnox,004B,0605


SDPana:
	mov	ah,es:[di]
	and	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPana,004C,0CC8


SSPxDSxoxn:
	mov	dl,al
SPxDSxo:
	mov	ah,al
	xor	ah,dh
	xor	al,es:[di]
	or	al,ah
	ROPDEF	SPxDSxo,007E,0955
	xor	al,dl
	ROPDEF	SSPxDSxoxn,004D,1954


PDSPxox:
DPSxon:
	xor	al,dh
	or	al,es:[di]
	ROPDEF	DPSxon,0041,0249
	xor	al,dh
	ROPDEF	PDSPxox,004E,0645


PDna:
Dn:
	mov	al,es:[di]
	ROPDEF	Dn,0055,0009
	not	al
	and	al,dh
	ROPDEF	PDna,0050,0325


DPSDaox:
	mov	ah,es:[di]
	and	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDaox,0052,06C9


SPDSxaxn:
	mov	dl,al
PDSxa:
	xor	al,es:[di]
	and	al,dh
	ROPDEF	PDSxa,0060,0365
	xor	al,dl
	ROPDEF	SPDSxaxn,0053,0764


DPx:
	mov	al,dh
PDSxnon:
	xor	al,es:[di]
	ROPDEF	DPx,005A,0049
DPSnoan:
	not	al
PDSPoax:
DPSoan:
	or	al,dh
	ROPDEF	PDSxnon,0006,0865
PDSax:
	and	al,es:[di]
	ROPDEF	DPSnoan,005D,0E29
	ROPDEF	DPSoan,0057,0389
	xor	al,dh
	ROPDEF	PDSPoax,0058,0785
	ROPDEF	PDSax,0078,01E5


DPSnox:
	not	al
DPSox:
	or	al,dh
PDSxnan:
	xor	al,es:[di]
	ROPDEF	DPSox,0056,01A9
	ROPDEF	DPSnox,0059,0609
	not	al
	and	al,dh
	ROPDEF	PDSxnan,006F,0C65


DPSDonox:
	mov	ah,es:[di]
	or	al,ah
	not	al
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDonox,005B,18A9


DPSDxox:
	mov	ah,es:[di]
	xor	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDxox,005C,0649


DSPnaon:
PDSPnaox:
	mov	ah,dh
	not	ah
	and	al,ah
	or	al,es:[di]
	ROPDEF	DSPnaon,0051,0B26
	xor	al,dh
	ROPDEF	PDSPnaox,005E,1B29


DPan:
	mov	al,dh
	and	al,es:[di]
	ROPDEF	DPan,005F,00E9


DSPDSaoxxn:
	mov	dl,al
	mov	ah,es:[di]
	and	al,ah
	or	al,dh
	xor	al,dl
	xor	al,ah
	ROPDEF	DSPDSaoxxn,0061,16C6


SDPnox:
	mov	ah,dh
	not	ah
	or	ah,es:[di]
	xor	al,ah
	ROPDEF	SDPnox,0063,0608


DPSnaxn:
	not	al
DPSax:
	and	al,dh
DSx:
PDSxxn:
	xor	al,es:[di]
	ROPDEF	DSx,0066,0046
	ROPDEF	DPSax,006A,01E9
	ROPDEF	DPSnaxn,0065,0606
	xor	al,dh
	ROPDEF	PDSxxn,0069,0145


SDPSonox:
PSDPSonoxxn:
	mov	dl,al
DPSonon:
	or	al,dh
	not	al
	or	al,es:[di]
	ROPDEF	DPSonon,0054,08A9
	xor	al,dl
	ROPDEF	SDPSonox,0067,18A8
	xor	al,dh
	ROPDEF	PSDPSonoxxn,0068,58A6


SDPSoax:
PSDPSoaxxn:
	mov	dl,al
	or	al,dh
	and	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSoax,0064,0788
	xor	al,dh
	ROPDEF	PSDPSoaxxn,006B,178A


SDPax:
	mov	ah,es:[di]
	and	ah,dh
	xor	al,ah
	ROPDEF	SDPax,006C,01E8


DSPDoax:
PDSPDoaxxn:
	mov	ah,es:[di]
	mov	dl,ah
	or	ah,dh
	and	al,ah
	xor	al,dl
	ROPDEF	DSPDoax,0062,0786
	xor	al,dh
	ROPDEF	PDSPDoaxxn,006D,1785


SDPSnoax:
	mov	dl,al
	not	al
	or	al,dh
	and	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSnoax,006E,1E28


SSDxPDxaxn:
	mov	dl,al
SDxPDxa:
	mov	ah,es:[di]
	xor	al,ah
	xor	ah,dh
	and	al,ah
	ROPDEF	SDxPDxa,0042,0D5D
	xor	al,dl
	ROPDEF	SSDxPDxaxn,0071,1D5C


SDPSxox:
	mov	dl,al
	xor	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSxox,0072,0648


SDPnoan:
	mov	ah,dh
	not	ah
	or	ah,es:[di]
	and	al,ah
	ROPDEF	SDPnoan,0073,0E28


DSPDxox:
	mov	ah,es:[di]
	mov	dl,ah
	xor	ah,dh
	or	al,ah
	xor	al,dl
	ROPDEF	DSPDxox,0074,0646


SDPSnaox:
	mov	dl,al
DPSnaon:
	not	al
	and	al,dh
	or	al,es:[di]
	ROPDEF	DPSnaon,0045,0B29
	xor	al,dl
	ROPDEF	SDPSnaox,0076,1B28


DSPnoan:
PDSPnoax:
	mov	ah,dh
	not	ah
	or	al,ah
	and	al,es:[di]
	ROPDEF	DSPnoan,0075,0E26
DPSxnon:
	xor	al,dh
	ROPDEF	PDSPnoax,007A,1E29
PDSnoan:
SPDSnoax:
	mov	dl,al			;(wasted for DPSxnon)
	not	al
	or	al,es:[di]
	ROPDEF	DPSxnon,0014,0869
	and	al,dh
	ROPDEF	PDSnoan,004F,0E25
	xor	al,dl
	ROPDEF	SPDSnoax,007C,1E24

SDPxnan:
	mov	ah,es:[di]
	xor	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPxnan,007B,0C68



foobar	macro	y
if @Version LT 600
if2
  %out	Size of the table is y.
endif
else
  %out	Size of the table is y.
endif
endm

foobar	%(offset $)-(offset roptable)-256-8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\dcxcodec.h ===
// Copyright (C) Microsoft Corp. 1994
/*==============================================================================
The prototypes in this header file define an API for the Dcx Codec DLL.

DATE				NAME			COMMENTS
13-Jan-94   RajeevD   Parallel to faxcodec.h
==============================================================================*/
#ifndef _INC_DCXCODEC
#define _INC_DCXCODEC

#include <faxcodec.h>

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
DcxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // returns size of context (0 on failure)
WINAPI DcxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

/*==============================================================================
DcxCodecConvert() executes the conversion specified in DcxCodecInit().

In the input buffer, lpbBegData is advanced and uLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.

In the output buffer, uLengthData is incremented as data is appended.  If the
output type is HRAW_DATA, an integral number of scan lines are produced.

To flush any output data at the end of apage, pass a NULL input buffer.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // returns status
WINAPI DcxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);


#ifdef __cplusplus
} // extern "C" {
#endif

// DCX file header
typedef struct
{
	DWORD   dwSignature;    // always set to DCX_SIG
	DWORD   dwOffset[1024]; // array of page offsets
}
	DCX_HDR;

#define DCX_SIG 987654321L

// PCX file header
typedef struct
{
	BYTE    bSig;          // signature: always  0Ah
	BYTE    bVer;          // version: at least 2 
	BYTE    bEnc;          // encoding: always 1
	BYTE    bBPP;          // color depth [bpp]
	short   xMin;          // x minimum, inclusive
	short   yMin;          // y minimum, inclusive
	short   xMax;          // x maximum, inclusive
	short   yMax;          // y maximum, inclusive
	WORD    xRes;          // x resolution [dpi]
	WORD    yRes;          // y resolution [dpi]
	BYTE    bPalette[48];  // color palette
	BYTE    bReserved;
	BYTE    bPlanes;       // number of color planes
	WORD    wHoriz; 
  WORD    wPalInfo;      // palette info: always 1
	char    bFill[58];
}
	PCX_HDR;

#endif // _INC_DCXCODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\faxcodec.h ===
// Copyright (c) Microsoft Corp. 1992-94
/*==============================================================================
The prototypes in this header file define an API for the Fax Codec DLL.

DATE				NAME			COMMENTS
25-Nov-92		RajeevD   Created.
13-Apr-93		RajeevD		Changed to Bring Your Own Memory (BYOM :=) API.
01-Nov-93   RajeevD   Defined structure for initialization parameters.
21-Jan-94   RajeevD   Split FaxCodecRevBuf into BitReverseBuf and InvertBuf.
19-Jul-94   RajeevD   Added nTypeOut=NULL_DATA and FaxCodecCount.
==============================================================================*/
#ifndef _FAXCODEC_
#define _FAXCODEC_

#include <windows.h>
#include <buffers.h>

/*==============================================================================
The FC_PARAM structure specifies the conversion to be initialized.
This matrix indicates the valid combinations of nTypeIn and nTypeOut.

                             nTypeOut
                             
                 MH     MR     MMR    LRAW    NULL
                 
        MH               *      *       *      *

        MR       *              *       *      *
nTypeIn
        MMR      *       *              *

        LRAW     *       *      * 
        
==============================================================================*/
typedef struct
#ifdef __cplusplus
  FAR FC_PARAM
#endif
{
	DWORD nTypeIn;      // input data type:  {MH|MR|MMR|LRAW}_DATA
	DWORD nTypeOut;     // output type type: {MH|MR|MMR|LRAW|NULL}_DATA
	UINT  cbLine;       // scan line byte width (must be multiple of 4)
	UINT  nKFactor;     // K factor (significant for nTypeOut==MR_DATA)
}
	FC_PARAM, FAR *LPFC_PARAM;

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
FaxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // size of context (0 on failure)
WINAPI FaxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

typedef UINT (WINAPI *LPFN_FAXCODECINIT)
	(LPVOID, LPFC_PARAM);

// Return codes for FaxCodecConvert
typedef UINT FC_STATUS;
#define FC_INPUT_EMPTY 0
#define FC_OUTPUT_FULL 1
#define FC_DECODE_ERR  4 // only for nTypeIn==MMR_DATA

/*==============================================================================
FaxCodecConvert() executes the conversion specified in FaxCodecInit().

In the input buffer, lpbBegData is advanced and wLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.  If the input type is LRAW_DATA, wLengthData must be a
multiple of 4.

In the output buffer, wLengthData is incremented as data is appended.  If the
output type is LRAW_DATA, an whole number of scan lines are produced.

To flush any output data at the end of a page, pass a NULL input buffer or a
zero length buffer with dwMetaData set to END_OF_PAGE.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // status
WINAPI FaxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);

typedef UINT (WINAPI *LPFN_FAXCODECCONVERT)
	(LPVOID, LPBUFFER, LPBUFFER);

/*==============================================================================
The FC_COUNT structure accumulates various counters during FaxCodecConvert.
==============================================================================*/
typedef struct
{
	DWORD cTotalGood;    // total good scan lines
	DWORD cTotalBad;     // total bad scan lines
	DWORD cMaxRunBad;    // maximum consecutive bad
}
	FC_COUNT, FAR *LPFC_COUNT;

/*==============================================================================
FaxCodecCount() reports and resets the internal counters.
==============================================================================*/
void WINAPI FaxCodecCount
(
	LPVOID     lpContext,
	LPFC_COUNT lpCount
);

typedef void (WINAPI *LPFN_FAXCODECCOUNT)
	(LPVOID, LPFC_COUNT);

/*==============================================================================
BitReverseBuf() performs a bit reversal of buffer data.  The dwMetaData field is
toggled between LRAW_DATA and HRAW_DATA.  As with all scan lines, the length 
of data (wLengthData) must be a 32-bit multiple.  For best performance the start
of the data (lpbBegData) should be 32-bit aligned and the data predominantly 0.
==============================================================================*/
void WINAPI BitReverseBuf (LPBUFFER lpbuf);

/*==============================================================================
InvertBuf() inverts buffer data.  As with all scan lines, the length of data 
(wLengthData) must be a 32-bit multiple.  For best performance, the start of 
data (lpbBegData) should be 32-bit aligned.
==============================================================================*/
void WINAPI InvertBuf (LPBUFFER lpbuf);

/*==============================================================================
FaxCodecChange() produces a change vector for an LRAW scan line.
==============================================================================*/
typedef short FAR* LPSHORT;

// Slack Parameters.
#define RAWBUF_SLACK 2
#define CHANGE_SLACK 12
#define OUTBUF_SLACK 16

extern void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,  // LRAW scan line
	UINT    cbLine,   // scan line width
  LPSHORT lpsChange // change vector
);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // _FAXCODEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\faxspool.h ===
// Copyright (c) Microsoft Corp. 1993-94
/*==============================================================================
The Spool API is a file layer for buffers which supports random access to pages.
This module is compiled to use secure files on IFAX and plain files on Windows.

27-Oct-93    RajeevD    Created.
06-Dec-93    RajeevD    Integrated with render server.
22-Dec-93    RajeevD    Added SpoolReadSetPage.
06-Sep-94    RajeevD    Added SpoolRepairFile.
09-Sep-94    RajeevD    Added SpoolReadCountPages
==============================================================================*/
#ifndef _FAXSPOOL_
#define _FAXSPOOL_

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct      // spool file header
{
	WORD  xRes;       // X resolution [dpi]
	WORD  yRes;       // Y resolution [dpi]
	WORD  cbLine;     // X extent [bytes]
}
	SPOOL_HEADER, FAR *LPSPOOL_HEADER;

/*==============================================================================
SpoolWriteOpen creates a context for writing buffers to a spool file.
==============================================================================*/
LPVOID                       // context pointer (NULL on failure)
WINAPI
SpoolWriteOpen
(
	LPVOID lpFilePath,         // IFAX file key or Windows file name
	LPSPOOL_HEADER lpHeader    // image attributes to record in file
);

/*==============================================================================
SpoolWriteBuf dumps buffers to the spool file.  The buffers are not freed or
modified.  Each page is terminated by passing a buffer with dwMetaData set to
END_OF_PAGE, except the last page, which is terminated by END_OF_JOB.  IFAX
files are flushed at the end of each page.  This call may fail if the disk
becomes full, in which case the caller is responsible for deleting the file and
destroying the context.
==============================================================================*/
BOOL                         // TRUE (success) or FALSE (failure)
WINAPI
SpoolWritePutBuf
(
	LPVOID lpContext,          // context returned from SpoolWriteOpen
	LPBUFFER lpbuf             // buffer to be written to spool file
);

/*==============================================================================
SpoolWriteClose destroys a context returned from SpoolWriteOpen.
==============================================================================*/
void
WINAPI
SpoolWriteClose
(
	LPVOID lpContext           // context returned from SpoolWriteOpen
);

/*==============================================================================
SpoolRepairFile repairs a truncated file created by SpoolWriteOpen but not
flushed by SpoolWriteClose due to a system failure.
==============================================================================*/
WORD                         // number of complete pages recovered
WINAPI
SpoolRepairFile
(
	LPVOID lpFileIn,           // damaged file 
	LPVOID lpFileOut           // repaired file
);

/*==============================================================================
SpoolReadOpen creates a context for reading buffers from a completed spool file.
==============================================================================*/
LPVOID                       // context pointer (NULL on failure)
WINAPI
SpoolReadOpen
(
	LPVOID lpFilePath,         // IFAX file key or Windows file name
	LPSPOOL_HEADER lpHeader    // image attributes to fill (or NULL)
);

/*==============================================================================
SpoolReadCountPage returns the number of pages in a spool file.
==============================================================================*/
WORD                         // number of pages
WINAPI
SpoolReadCountPages
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);

/*==============================================================================
SpoolReadSetPage sets the spool file to the start of the specified page.
==============================================================================*/
BOOL                         // TRUE (success) or FALSE (failure)
WINAPI
SpoolReadSetPage
(
	LPVOID lpContext,          // context returned from SpoolReadOpen
	WORD   iPage               // page index (first page has index 0)
);

/*==============================================================================
SpoolReadGetBuf to retrieves the next buffer from the spool file.  Each page is
terminated by an END_OF_PAGE buffer, except the last page, which is terminated
by END_OF_JOB.  The call may fail if a buffer cannot be allocated.
==============================================================================*/
LPBUFFER                     // returns filled buffer (NULL on failure)
WINAPI
SpoolReadGetBuf
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);

/*==============================================================================
SpoolFreeBuf can free buffers returned from SpoolReadGetBuf.
==============================================================================*/
BOOL                         // TRUE  (success) or FALSE (failure)
WINAPI
SpoolFreeBuf
(
	LPBUFFER lpbuf             // buffer returned from SpoolReadGetBuf
);

/*==============================================================================
SpoolReadClose destroys a context returned from SpoolReadOpen.
==============================================================================*/
void
WINAPI
SpoolReadClose 
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FAXSPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\dcxview.cpp ===
/*==============================================================================
This module provides DCX rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#ifdef VIEWDCX

#include <memory.h>
#include "viewrend.hpp"
#include "dcxcodec.h"

//==============================================================================
DCXVIEW::DCXVIEW (DWORD nType)
{
	nTypeOut = nType;
	lpCodec = NULL;
	bufIn.wLengthBuf = 8000;
	bufIn.lpbBegBuf = (LPBYTE) GlobalAllocPtr (0, bufIn.wLengthBuf);
}

//==============================================================================
DCXVIEW::~DCXVIEW ()
{
	if (lpCodec)
		GlobalFreePtr (lpCodec);
	if (bufIn.lpbBegBuf)
		GlobalFreePtr (bufIn.lpbBegBuf);
}
		
//==============================================================================
BOOL DCXVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	DWORD dwOffset;
	PCX_HDR pcx;
	UINT cbCodec;

	if (!this || !bufIn.lpbBegBuf)
		return_error (("VIEWREND could not allocate context!\r\n"));

	if (!Open (lpFilePath, 0))
		return_error (("VIEWREND could not open spool file!\r\n"));

	if (!Seek (sizeof(DWORD), SEEK_BEG))
		return_error (("VIEWREND could not seek to first page offset!\r\n"));

	if (!Read (&dwOffset, sizeof(dwOffset)))
		return_error (("VIEWREND could not read first page offset\r\n"));
		
	if (!Seek (dwOffset, SEEK_BEG))
		return_error (("VIEWREND could not seek to first page!\r\n"));

	if (!Read (&pcx, sizeof(pcx)))
		return_error (("VIEWREND could read header of first page!\r\n"));


	// Fill VIEWINFO.
	lpvi->cPage = 0;
	while (SetPage(lpvi->cPage))
		lpvi->cPage++;
	switch (pcx.xRes)
	{
		case 640:
			// Assume square aspect ratio for bonehead apps.
			lpvi->xRes = 200;
			lpvi->yRes = 200;
			break;

		default:
			lpvi->xRes = pcx.xRes;
			lpvi->yRes = pcx.yRes;
			break;
	}		
	lpvi->yMax = pcx.yMax - pcx.yMin;
	
	// Set up codec.
	fcp.nTypeIn  = DCX_DATA;
	fcp.nTypeOut = HRAW_DATA;
	fcp.cbLine = (pcx.xMax - pcx.xMin + 1) / 8;
	
	// Query codec.
	cbCodec = DcxCodecInit (NULL, &fcp);
	if (!cbCodec)
		return_error (("VIEWREND could not init codec!\r\n"));

	// Initialize codec.
	lpCodec = GlobalAllocPtr (0, cbCodec);
	if (!lpCodec)
		return_error (("VIEWREND could not allocate codec!\r\n"));

	cbBand = *lpwBandSize;
	return SetPage (0);
}

//==============================================================================
BOOL DCXVIEW::SetPage (UINT iPage)
{
	DWORD dwOffset[2];
	DEBUGCHK (iPage < 1024);

  // Get offset of current and next page.
	Seek (sizeof(DWORD) * (iPage + 1), SEEK_BEG);
	Read (dwOffset, sizeof(dwOffset));
	if (!dwOffset[0])
		return FALSE;
	if (!dwOffset[1])
	{	
		Seek (0, SEEK_END);
		dwOffset[1] = Tell();
	}

  // Seek to page.
	dwOffset[0] += sizeof(PCX_HDR);
	if (!Seek (dwOffset[0], SEEK_BEG))
		return_error (("VIEWREND could not seek to page %d!",iPage));
	cbPage = dwOffset[1] - dwOffset[0];

  // Initialize codec.
	DcxCodecInit (lpCodec, &fcp);
	bufIn.Reset();

	fEndPage = FALSE;
	return TRUE;
}
	
//==============================================================================
BOOL DCXVIEW::GetBand (LPBITMAP lpbmBand)
{
	FC_STATUS fcs;
	BUFFER bufOut;
	
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);

	// Fill descriptor.
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = 8 * fcp.cbLine;
	lpbmBand->bmWidthBytes = fcp.cbLine;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	// Trap end of page.
	if (fEndPage)
	{
		lpbmBand->bmHeight = 0;
		return TRUE;
	}
	
	// Set up output buffer.
	bufOut.lpbBegBuf  = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf = cbBand;
	bufOut.Reset();
	bufOut.dwMetaData = LRAW_DATA;
	
	do
	{
	  // Fetch input buffer?
		if (!bufIn.wLengthData)
		{
			// Reset buffer.
			bufIn.lpbBegData = bufIn.lpbBegBuf;
			if ((DWORD) bufIn.wLengthBuf < cbPage)
				bufIn.wLengthData = bufIn.wLengthBuf;
			else
				bufIn.wLengthData = (WORD) cbPage;
				
      // Read DCX data.
			if (!Read (bufIn.lpbBegData, bufIn.wLengthData))
				return_error (("VIEWREND could not read DCX buffer!\r\n"));
			cbPage -= bufIn.wLengthData;
		}

	  // Decode the DCX data.
		fcs = DcxCodecConvert (lpCodec, &bufIn, &bufOut);

		// Check for end of page.
		if (!cbPage)
		{
			fEndPage = TRUE;
			break;
		}
	}
		while (fcs == FC_INPUT_EMPTY);

  // Bit reverse if needed.
	if (nTypeOut == LRAW_DATA)
		BitReverseBuf (&bufOut);

  // Calculate output height.
	lpbmBand->bmHeight = bufOut.wLengthData / fcp.cbLine;
	return TRUE;
}

#endif // VIEWDCX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\resexec\stllnent.c ===
// Copyright (c) 1992-1993 Microsoft Corporation

/*============================================================================
This code module implements styled lines in the NT format.

05/29/81  v-BertD    Initial code (used in RP_LineEE_Draw)
02/20/92  RodneyK    Converted to Styled line code.
02/21/92  RodneyK    Each bit in the Mask is used for two pixels.
03/20/92  RodneyK    Converted to NT style format.
06/01/93  RajeevD    Collapsed ROP handling from StyleLine* to Draw*.
                     (Reduces code size by 8K with no loss in speed.)
============================================================================*/
#include <windows.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"         /* Jumbo type definitions.                */
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"          /* Slice Descriptor defs.                 */

// Table data for the predefined pen styles
ULONG ulWinStyles[] =
{
   0x00000002, 0x00ffffff, 0x00000000, /* solid */
   0x00000002, 0x00000028, 0x00000010, /* dash  */ /* 28 */
   0x00000002, 0x00000008, 0x00000008, /* dot   */
   0x00000004, 0x0000001c, 0x0000000f, 0x00000008, 0x0000000f, /* dash dot */
   0x00000006, 0x0000001c, 0x0000000f, 0x00000008, 0x00000008,0x00000008, 0x0000000f,
   0x00000002, 0x00000000, 0x00ffffff, /* NULL  */
   0x00000002, 0x00ffffff, 0x00000000  /* Inside border */
};

const BYTE ulStyleLookUp[7] =
	{ 0x00, 0x03, 0x06, 0x09, 0x0e, 0x15, 0x18};

const USHORT usStyleSize[7] =
	{0x0000, 0x0038, 0x0010, 0x0042, 0x0052, 0x0000, 0x0000 };

typedef void (*ROPPROC)(LPBYTE, WORD, BYTE);

//==============================================================================
void DrawANDDNR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (~(*lpbFrame & wColor) & bPos)
		*lpbFrame |=  bPos;
	else
		*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawANDDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawANDNDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (((~*lpbFrame) & wColor) & bPos)
		*lpbFrame |=  bPos;
	else
		*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawCOPY0 (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawCOPY1 (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
  *lpbFrame |= bPos;
}

//==============================================================================
void DrawORDNR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if ((~(*lpbFrame | wColor)) & bPos)
  	*lpbFrame |=  bPos;
	else 
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawORDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame |= bPos;
}

//==============================================================================
void DrawORNDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (((~*lpbFrame) | wColor) & bPos)
  	*lpbFrame |=  bPos;
  else
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawXOR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if ((~*lpbFrame) & bPos)
		*lpbFrame |=  bPos;
	else
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void StyleLine
(
	LPRESTATE lpREState,         // resource executor context
	RP_SLICE_DESC FAR*psdSlice,     /* Line Slice descriptor */
	ULONG *pulStyle,             /* Line style pointer    */
	WORD wColor,
	ROPPROC RopProc
)
/*==============================================================================
 PURPOSE               This function handle the OR Raster operations for
                       the styled line code.  It draws a line based on the
                       Slice descriptor, current color, current ROP, and
                       the current linestyle.

                       The function runs through the slice and determine
                       whether a point is to drawn or not.  The raster
                       operation is applied only the points which need to
                       be drawn.

ASSUMPTIONS &          This code assumes that the slice descriptor and the
ASSERTIONS             pointer to the style table are valid and correct.
                       No checks are performed to validate this data.
==============================================================================*/
{
   LPBITMAP lpbm;
   register UBYTE FAR *pbFrame;                       /* frame pointer               */
   SLONG lSlice_x, lSlice_y;            /* Slice Run variables         */
   SLONG lSkip_x, lSkip_y;              /* Slice skip variables        */
   register UBYTE usfPos;                        /* Bit in frame to modify      */
   register SHORT i;                             /* Slice variable              */
   ULONG *pulStyleTmp;                  /* Pointer to style data       */
   register ULONG ulDrawCount;                   /* Number of pixels to draw on */
   ULONG ulStyleCount;                  /* Count of data in line style */
   register BYTE bDraw;                         /* To draw or Not to draw      */

   pulStyleTmp = pulStyle + 1;          /* Point to style data         */
   ulDrawCount = *pulStyleTmp++;        /* Get the first count         */
   ulStyleCount = *(pulStyle) - 1;      /* Pattern longs remaining     */
   bDraw = 0xFF;                        /* Start by drawing            */

   for ( i = 0 ; i < (SHORT)lpREState->usPenPhase; i++)
   {
      if(!ulDrawCount)                  /* Flip draw mask */
      {
         bDraw = (BYTE)~bDraw;
         if (!ulStyleCount--)           /* recycle the pattern? */
         {
            ulStyleCount = *(pulStyle) - 1;
            pulStyleTmp = pulStyle + 1;
         }
         ulDrawCount = *pulStyleTmp++;  /* Get next style count */
      }
      ulDrawCount--;
   }

   lpbm = lpREState->lpBandBuffer;
   pbFrame = (UBYTE FAR*) lpbm->bmBits;
   pbFrame += psdSlice->us_y1 * lpbm->bmWidthBytes;
   pbFrame += psdSlice->us_x1 >> 3;
   usfPos = (UBYTE)(0x80 >> (psdSlice->us_x1 & 0x7));     /* Calculate the bit mask */

   lSlice_x = psdSlice->s_dx_draw;
   lSlice_y = psdSlice->s_dy_draw * lpbm->bmWidthBytes;
   lSkip_x = psdSlice->s_dx_skip;
   lSkip_y = psdSlice->s_dy_skip * lpbm->bmWidthBytes;

   // Do the first slice...

   if (psdSlice->us_first)
   {
      for ( i = psdSlice->us_first ; i > 0 ; --i )
      {
         if(!ulDrawCount)                  /* Flip draw mask */
         {
            bDraw = (BYTE)~bDraw;
            if (!ulStyleCount--)           /* recycle the pattern? */
            {
               ulStyleCount = *(pulStyle) - 1;
               pulStyleTmp = pulStyle + 1;
            }
            ulDrawCount = *pulStyleTmp++;  /* Get next style count */
         }
         ulDrawCount--;

         if (bDraw)
					(*RopProc)(pbFrame, wColor, usfPos);

         if (lSlice_x < 0)
         {
            usfPos <<= 1;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x01;                /* Reset the bit mask */
               pbFrame -= 1;                  /* move to next UBYTE */
            }
         }
         else
         {
            usfPos >>= lSlice_x;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x80;                /* Reset the bit mask */
               pbFrame += 1;                  /* move to next UBYTE */
            }
         }
         pbFrame += lSlice_y;              /* advance to next row */
      }

      if ( lSkip_x < 0 )                   /* going to the left? */
      {
         usfPos <<= 1;                      /* shift the mask */
         if ( usfPos == 0 )                 /* Check for over/under flow */
         {
            usfPos = 0x01;                /* Reset Mask */
            pbFrame -= 1;                  /* point to the next UBYTE */
         }
      }
      else                                 /* moving to the right */
      {
         usfPos >>= lSkip_x;
         if ( usfPos == 0 )
         {
            usfPos = 0x80;
            pbFrame += 1;
         }
      }
      pbFrame += lSkip_y;
   }

   // Do the intermediate slices...
   
   for ( ; psdSlice->us_n_slices > 0 ; --psdSlice->us_n_slices )
   {
      if ( psdSlice->s_dis < 0 )
      {
         i = psdSlice->us_small;
         psdSlice->s_dis += psdSlice->s_dis_sm;
      }
      else
      {
         i = psdSlice->us_small + 1;
         psdSlice->s_dis += psdSlice->s_dis_lg;
      }

      for ( ; i > 0 ; --i )
      {
         if(!ulDrawCount)               /* Is it time to flip the draw state */
         {
            bDraw = (BYTE)~bDraw;             /* Yes, Change it   */
            if (!ulStyleCount--)        /* Recycle pattern? */
            {
               ulStyleCount = *(pulStyle) - 1;
               pulStyleTmp = pulStyle + 1;
            }
            ulDrawCount = *pulStyleTmp++;   /* Advance the pattern */
         }
         ulDrawCount--;

         if (bDraw)
					(*RopProc)(pbFrame, wColor, usfPos);
         	
         if (lSlice_x < 0)
         {
            usfPos <<= 1;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x01;                /* Reset the bit mask */
               pbFrame -= 1;                  /* move to next UBYTE */
            }
         }
         else
         {
            usfPos >>= lSlice_x;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x80;                /* Reset the bit mask */
               pbFrame += 1;                  /* move to next UBYTE */
            }
         }
         pbFrame += lSlice_y;
      }

      if ( lSkip_x < 0 )                /* Check for negative movement */
      {
         usfPos <<= 1;
         if ( usfPos == 0 )
         {
            usfPos = 0x01;
            pbFrame -= 1;
         }
      }
      else
      {
         usfPos >>= lSkip_x;             /* Do positive case */
         if ( usfPos == 0 )
         {
            usfPos = 0x80;
            pbFrame += 1;
         }
      }
      pbFrame += lSkip_y;
   }

   // Do the last slice...

   for ( i = psdSlice->us_last ; i > 0 ; --i )
   {
      if(!ulDrawCount)                  /* Check to see if draw status needs */
      {                                 /* to be changed                     */
         bDraw = (BYTE)~bDraw;
         if (!ulStyleCount--)
         {                              /* update the style pointer */
            ulStyleCount = *(pulStyle) - 1;
            pulStyleTmp = pulStyle + 1;
         }
         ulDrawCount = *pulStyleTmp++;
      }
      ulDrawCount--;                    /* count down the style count */

      if (bDraw)
      	(*RopProc)(pbFrame, wColor, usfPos);

      if (lSlice_x < 0)
      {
         usfPos <<= 1;
         if ( usfPos == 0 )                 /* Check mask underflow and adjust */
         {
            usfPos = 0x01;                /* Reset the bit mask */
            pbFrame -= 1;                  /* move to next UBYTE */
         }
      }
      else
      {
         usfPos >>= lSlice_x;
         if ( usfPos == 0 )                 /* Check mask underflow and adjust */
         {
            usfPos = 0x80;                /* Reset the bit mask */
            pbFrame += 1;                  /* move to next UBYTE */
         }
      }
      pbFrame += lSlice_y;
   }

  // AdjustPhase(psdSlice);
	{
		SHORT    sDx, sDy;
		USHORT   usLength;

		sDx = psdSlice->us_x2 - psdSlice->us_x1;
		sDy = psdSlice->us_y2 - psdSlice->us_y1;
		if (sDx < 0) sDx = -sDx;
		if (sDy < 0) sDy = -sDy;

		usLength = usStyleSize[lpREState->ubPenStyle];
		if (usLength != 0)
		{
		  if (sDx < sDy)
		     lpREState->usPenPhase += (USHORT)sDy + 1;
		  else
		     lpREState->usPenPhase += (USHORT)sDx + 1;
		  lpREState->usPenPhase %= usLength;
		}
  }
}

//==============================================================================
void GetTotalPixels
(
   RP_SLICE_DESC FAR *psdSlice    /* Line Slice descriptor */
)
//
//  PURPOSE               Caculate how many pixel are going to be drawn.
//                        Put the result in us_y2 = us_y1 + Total Pixels
//                        This function is called only in JG_RP_LineSlice
//
// ASSUMPTIONS &          This code assumes that the slice descriptor and the
// ASSERTIONS             pointer to the style table are valid and correct.
//                        No checks are performed to validate this data.
//                        If an unsupported ROP is sent ROP(0) BLACKNESS is
//                        used.
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
//--------------------------------------------------------------------------*/
{
   USHORT usTotalPixels;
   SHORT  sDis;
   SHORT  i;

   usTotalPixels = psdSlice->us_first + psdSlice->us_last;
   sDis = psdSlice->s_dis;
   for (i = 0; i <  (SHORT)psdSlice->us_n_slices; i++) {
      if ( sDis < 0 )
      {
         usTotalPixels += psdSlice->us_small;
         sDis += psdSlice->s_dis_sm;
      }
      else
      {
         usTotalPixels += psdSlice->us_small + 1;
         sDis += psdSlice->s_dis_lg;
      }
   }
   psdSlice->us_y2 = psdSlice->us_y1 + usTotalPixels - 1;
   return;
}

//==============================================================================
BYTE StyleLineDraw
(
	 LPRESTATE lpREState,        // resource executor context
   RP_SLICE_DESC FAR *psdSlice,    /* Line Slice descriptor */
   UBYTE ubLineStyle, /* Line style pointer    */
   SHORT sRop,
   SHORT usColor
)

/*
//
//  PURPOSE               This function calls the correct function to draw
//                        a single pixel styled line using the correct
//                        ROP, Linestyle, and color (pen).
//
// ASSUMPTIONS &          This code assumes that the slice descriptor and the
// ASSERTIONS             pointer to the style table are valid and correct.
//                        No checks are performed to validate this data.
//                        If an unsupported ROP is sent ROP(0) BLACKNESS is
//                        used.
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
// UNRESOLVED ISSUES      Banding problems???
//
// RETURNS                0 - use fast line, 1 - don't draw, 2 - style drawn
//
//--------------------------------------------------------------------------*/
{
   BYTE bRetVal;    /* Return value for optimizing certain cases             */
   ULONG *pulStyle; /* Line style pointer    */
   BYTE bSolid;

   if (!ubLineStyle && ((psdSlice->s_dx_draw < 0) || (psdSlice->s_dx_skip <0)))
      {
        // JG_WARNING("Neg X with Solid Line");
        ubLineStyle = 6; /* for style line code to do it */
      }
   if (ubLineStyle == 5)
      bRetVal = 1;
   else
   {
      /* Note style 6 will not be considered solid to simplify things */
      bSolid = (BYTE)(ubLineStyle == 0);
      pulStyle = &ulWinStyles[ulStyleLookUp[ubLineStyle]];
      bRetVal = 2;

      if (usStyleSize[ubLineStyle])
         lpREState->usPenPhase %= usStyleSize[ubLineStyle];

      switch (sRop)
      {
         case  0x00 :                                        /* ROP BLACK */
            if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            break;
         case  0x05 :                                             /* DPon */
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORDNR);
            break;
         case  0x0a :                                             /* DPna */
            if(!usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawANDDR);
            break;
         case  0x0f :                                             /* Pn */
            if(bSolid && !usColor)
               bRetVal = 0;
            else
               if (usColor)
               	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
               else
               	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            break;
         case  0x50 :                                             /* PDna */
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawANDNDR);
            break;
         case  0x55 :                                            /* Dn */
            usColor   = 0x0000;
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORNDR);
            break;
         case  0x5a :                                           /* DPx */
            if(!usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawXOR);
            break;
         case  0x5f :                                           /* DPan */
            if(bSolid && !usColor) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawANDDNR);
            break;
         case  0xa0 :                                           /* DPa */
            if(usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawANDDR);
            break;
         case  0xa5 :                                           /* PDxn */
            if(usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawXOR);
            break;
         case  0xaa :                                           /* D */
            bRetVal = 1;
            break;
         case  0xaf :                                           /* DPno */
            if (usColor) bRetVal = 1;
            else if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawORDR);
            break;
         case  0xf0 :                                           /* P */
            if(bSolid && usColor) bRetVal = 0;
            else if (usColor)
            	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            else
            	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
            break;
         case  0xf5 :                                           /* PDno */
            if(bSolid && usColor) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORNDR);
            break;
         case  0xfa :                                           /* PDo */
            if (!usColor) bRetVal = 1;
            else if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawORDR);
            break;
         case  0xFF :                                           /* WHITENESS */
            StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
            break;
         default:                                               /* BLACKNESS */
            if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
      }
   }
   return (bRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\buffers.h ===
/*==============================================================================
This file includes the BUFFER typedef and standard meta-data values.

23-Feb-93    RajeevD    Moved from ifaxos.h
17-Jul-93    KGallo     Added STORED_BUF_DATA metadata type for buffers containing 
                        the stored info for another buffer.
28-Sep-93    ArulM      Added RES_ ENCODE_ WIDTH_ and LENGTH_ typedefs
==============================================================================*/
#ifndef _INC_BUFFERS
#define _INC_BUFFERS

//----------------------------- BUFFERS -------------------------
/****
	@doc    EXTERNAL        IFAXOS    DATATYPES

	@types  BUFFER  |   The Buffer structure defines the buffer header
			structures which processes manipulate.

	@field  WORD	|   fReadOnly   | Specifies whether the buffer
			is readonly or not. It is the applications responsibility to
			check this flag and not violate it. <f IFBufMakeWritable> should
			be used if a process needs to write on a buffer which is
			marked readonly. This field should not be modified by the
			process itself.

	@field  LPBYTE  |   lpbBegBuf   | A far ptr pointing to the physical
			start of the buffer. This ptr has meaning only in the calling
			process's address space and should not be stored for any
			reason. It should not be modified either.

	@field  WORD    |   wLengthBuf  | Physical length of the buffer. Should
			not be modified by the process. Should be used in conjunction
			with <e BUFFER.lpbBegBuf> to know the physical boundaries of the buffer.

	@field  DWORD    |   dwMetaData   | Indicates the kind of data stored in
			the buffer. See <t STD_DATA_TYPES> for all the possible values
	    of this field.

	@field  LPBYTE  |   lpbBegData  | Far ptr to the start of valid data in the
			buffer. The process is responsible for maintaining the integrity
			of this as it consumes or produces data in the buffer. The ptr should
			not be passed to any other process as it will not be valid. At buffer
			allocation time this field is initialized to point to the physical
			beginning of the buffer.

	@field  LPBYTE  |   lpbCurPtr   | One of the fields of a union containing
	    lpbfNext and dwTemp as its other members.
	    A general purpose far ptr which can be
			used to mark an interesting place in the buffer. Should be used as
			a temporary variable while processing the buffer. Should not be directly
	    passed to any other process. Initialized
			to point to the beginning of the buffer at allocation time.
	    Remember that this is a UNION !!

	@field  LPBUFFER  |   lpbfNext | One of the fields of a union containing
	    lpbCurPtr and dwTemp as its other members. This should be used
	    when a module wants to internally link a list of buffers together.
	    Remember that this is a UNION !!

	@field  DWORD |   dwTemp | One of the fields of a union containing
	    lpbfNext and lpbCurPtr as its other members. This should be used when
	    the module wants to store some random information in the header.
	    Remember that this is a UNION !!

	@field  WORD    |   wLengthData | Gives the length of valid contiguous data
			present in the buffer starting at <e BUFFER.lpbBegData>. The process is
			responsible for maintaining the integrity of this. Initialized to
			zero at allocation time.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname _BUFFER

	@xref   <f IFBufAlloc>
****/

typedef struct _BUFFER
{       
	// Private portion
	struct _BUFFERDATA  FAR *lpbdBufData;
	struct _BUFFER FAR *lpbfNextBuf;
    WORD    wResFlags;

	// Read Only portion
	WORD	fReadOnly;      // Is the buffer readonly ??
	LPBYTE  lpbBegBuf;      // Physical start of buffer
	WORD    wLengthBuf;     // Length of buffer

	// Read write public portion
	WORD    wLengthData;    // length of valid data
	DWORD   dwMetaData;      // Used to store metadata information
	LPBYTE  lpbBegData;     // Ptr to start of data
	union
	{
		struct _BUFFER FAR*     lpbfNext;       // for linking buffers
		LPBYTE  lpbCurPtr;      // for local current position use
		DWORD   dwTemp;    // for general use
	};

#ifdef VALIDATE
	// Dont touch this !!
	WORD    sentinel;       // debug sentinel
#endif

// C++ Extensions
#ifdef __cplusplus

	LPBYTE EndBuf  (void) FAR {return lpbBegBuf  + wLengthBuf; }
	LPBYTE EndData (void) FAR {return lpbBegData + wLengthData;}
	void   Reset   (void) FAR {lpbBegData = lpbBegBuf; wLengthData = 0;}
  
#endif // __cplusplus

} BUFFER, FAR *LPBUFFER , FAR * FAR * LPLPBUFFER ;

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_DATA_TYPES | Standard data types used for
	    specifying the format of data in the system.

    @emem   MH_DATA     | Modified Huffman (T.4 1-dimensional).
    @emem   MR_DATA     | Modified READ (T.4 2-dimensional).
    @emem   MMR_DATA| Modified Modified READ (T.6).
    @emem   LRAW_DATA | Raw bitmap data, Least Significant Bit to the left.
    @emem   HRAW_DATA | Raw Bitmap data, Most Significant Bit to the left.
    @emem   DCX_DATA | Industry standard DCX specification (collection of PCX pages).
    @emem   ENCRYPTED_DATA | Data encrypted - original format unspecified.
    @emem   SIGNED_DATA | Data along with a digital signature. 
    @emem   BINFILE_DATA | Arbitrary binary data.
    @emem   STORED_BUF_DATA | Contains a BUFFER header & data.
    @emem   DCP_TEMPLATE_DATA | Digital Cover Page template data.
    @emem   DCP_DATA | Digital Cover Page processed template data.
    @emem   SPOOL_DATA | Spool data type - same as MMR for now.
    @emem   PRINTMODE_DATA | Printer Mode structure.
    @emem   ASCII_DATA | Ascii text.
    @emem   OLE_DATA   | Ole object.
    @emem   OLE_PICTURE | Ole Rendering Data.
    @emem   END_OF_PAGE | End of page marker.
    @emem   END_OF_JOB  | End of job marker.
    @emem   CUSTOM_METADATA_TYPE  | Beyond this value custom data types can be
	    defined.

    @comm   This should be used to specify data type of any data stream in the
	    system - from BUFFERS to Linearized Messages.  All data types which 
	    need to be used in bit fields (i.e. the Format Resolution) must have
	    a value which is a power of 2.  Other data types which do not need to used
	    in a bit field context may be assigned the other values.
********/

#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L
#define LRAW_DATA         0x00000008L
#define HRAW_DATA         0x00000010L
#define DCX_DATA          0x00000020L
#define ENCRYPTED_DATA    0x00000040L
#define BINFILE_DATA      0x00000080L
#define DCP_TEMPLATE_DATA 0x00000100L
#define ASCII_DATA        0x00000200L
#define RAMBO_DATA        0x00000400L
#define LINEARIZED_DATA   0x00000800L
#define DCP_DATA          0x00001000L
#define PCL_DATA          0x00002000L
#define ADDR_BOOK_DATA    0x00004000L
#define OLE_BIT_DATA      0x00008000L    // So we can use fmtres on OLE_DATA
#define OLE_BIT_PICTURE   0x00010000L    // So we can use fntres on OLE_BIT_PICTURE

// Make spool data be MMR
#define SPOOL_DATA        MMR_DATA

// Standard Non-Bit Valued MetaData values
#define NULL_DATA         0x00000000L
#define SIGNED_DATA       0x00000003L
#define STORED_BUF_DATA   0x00000005L
#define PRINTMODE_DATA    0x00000006L
#define OLE_DATA          0x0000001EL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define OLE_PICTURE       0x0000001FL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define END_OF_PAGE       0x00000021L
#define END_OF_JOB        0x00000022L
#define PARADEV_DATA      0x00000031L    // parallel device data
#define PARADEV_EOF       0x00000032L    // parallel device end of file


#define ISVIEWATT(e)  (((e) == MMR_DATA) || ((e) == RAMBO_DATA))
#define ISOLEATT(e)   (((e) == OLE_DATA) || ((e) == OLE_PICTURE))
#define ISPAGEDATT(e) (((e)==MMR_DATA) || ((e)==MR_DATA) || \
                        ((e)==MH_DATA)|| ((e)==LRAW_DATA)|| ((e)==HRAW_DATA))


// Allow for 24 standard bit valued MetaData values
#define CUSTOM_METADATA_TYPE  0x00800001L

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_RESOLUTIONS | Standard Page Resolutions

    @emem   AWRES_UNUSED      | Resolution is unused or irrelevant
    @emem   AWRES_UNKNOWN     | Resolution is unknown
    @emem   AWRES_CUSTOM      | Custom resolution
    @emem   AWRES_mm080_038   | 8 lines/mm x 3.85 lines/mm
    @emem   AWRES_mm080_077   | 8 lines/mm x 7.7 lines/mm
    @emem   AWRES_mm080_154   | 8 lines/mm x 15.4 lines/mm
    @emem   AWRES_mm160_154   | 16 lines/mm x 15.4 lines/mm
    @emem   AWRES_200_100     | 200 dpi x 100 dpi
    @emem   AWRES_200_200     | 200 dpi x 200 dpi
    @emem   AWRES_200_400     | 200 dpi x 400 dpi
    @emem   AWRES_300_300     | 300 dpi x 300 dpi
    @emem   AWRES_400_400     | 400 dpi x 400 dpi
********/   

#define AWRES_UNUSED            0xFFFFFFFFL
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_600_300           0x00000800L

// Keep old names for a while
#define AWRES_NORMAL            AWRES_mm080_038
#define AWRES_FINE              AWRES_mm080_077
#define AWRES_SUPER             AWRES_mm080_154
#define AWRES_SUPER_SUPER       AWRES_mm160_154
#define AWRES_SUPER_FINE        AWRES_SUPER_SUPER

/********
    @doc    EXTERNAL    IFAXOS  DATATYPES  SRVRDLL

    @type   DWORD |  STD_PAGE_LENLIMITS | Standard Page Length Limits

    @emem   AWLENLIMIT_UNUSED    | Page Length Limit unused
    @emem   AWLENLIMIT_STD       | Page Length Limit defined by Standard Paper Size
    @emem   AWLENLIMIT_UNLIMITED | unlimited page length
********/

#define AWLENLIMIT_UNUSED    0xFFFFFFFFL
#define AWLENLIMIT_STD       0x00000001L
#define AWLENLIMIT_UNLIMITED 0x00000002L


/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL 

    @typee  STD_PAGE_SIZES | Standard Page Sizes

    @emem   AWPAPER_UNUSED         |  Paper size is unused
    @emem   AWPAPER_UNKNOWN         |  Unknown size
    @emem   AWPAPER_CUSTOM          |  Custom Paper size
    @emem   AWPAPER_A3_PORTRAIT     |  A3 Portrait
    @emem   AWPAPER_A3_LANDSCAPE    | A3 landscape
    @emem	AWPAPER_B4_PORTRAIT     | B4 portrait
	@emem	AWPAPER_B4_LANDSCAPE    | B4 landscape
	@emem	AWPAPER_A4_PORTRAIT     | A4 portrait
	@emem	AWPAPER_A4_LANDSCAPE    | A4 landscape
	@emem	AWPAPER_B5_PORTRAIT     | B5 portrait
	@emem	AWPAPER_B5_LANDSCAPE    | B5 landscape
	@emem	AWPAPER_A5_PORTRAIT     | A5 portrait
	@emem	AWPAPER_A5_LANDSCAPE    | A5 landscape
	@emem	AWPAPER_A6_PORTRAIT     | A6 portrait
	@emem	AWPAPER_A6_LANDSCAPE    | A6 landscape
	@emem	AWPAPER_LETTER_PORTRAIT | Letter portrait
	@emem	AWPAPER_LETTER_LANDSCAPE | Letter landscape
	@emem	AWPAPER_LEGAL_PORTRAIT   | Legal portrait
	@emem	AWPAPER_LEGAL_LANDSCAPE  | Legal landscape
	@emem	AWPAPER_WIN31_DEFAULT   | ????


	@comm   Page width in pixels must be exactly correct for MH/MR/MMR
			decoding and to interoperate with Group-3 fax machines.
			The table in the example below gives the bits/bytes required at each width
			and resolution combination

    @ex     Table for Page Width vs Resolution  |

                         A4        B4        A3        A5        A6
    200dpi / 8li/mm   1728/216  2048/256  2432/304  1216/152   864/108
    300               2592/324  3072/384  3648/456  1824/228  1296/162
    400dpi / 16li/mm  3456/432  4096/512  4864/608  2432/304  1728/216

********/

#define         AWPAPER_UNUSED                  0xFFFFFFFFL
#define         AWPAPER_UNKNOWN                 0x00000000L
#define         AWPAPER_CUSTOM                  0x00000001L
#define         AWPAPER_A3_PORTRAIT             0x00000002L
#define         AWPAPER_A3_LANDSCAPE            0x00000004L
#define         AWPAPER_B4_PORTRAIT             0x00000008L
#define         AWPAPER_B4_LANDSCAPE            0x00000010L
#define         AWPAPER_A4_PORTRAIT             0x00000020L
#define         AWPAPER_A4_LANDSCAPE            0x00000040L
#define         AWPAPER_B5_PORTRAIT             0x00000080L
#define         AWPAPER_B5_LANDSCAPE            0x00000100L
#define         AWPAPER_A5_PORTRAIT             0x00000200L
#define         AWPAPER_A5_LANDSCAPE            0x00000400L
#define         AWPAPER_A6_PORTRAIT             0x00000800L
#define         AWPAPER_A6_LANDSCAPE            0x00001000L
#define         AWPAPER_LETTER_PORTRAIT         0x00002000L
#define         AWPAPER_LETTER_LANDSCAPE        0x00004000L
#define         AWPAPER_LEGAL_PORTRAIT          0x00008000L
#define         AWPAPER_LEGAL_LANDSCAPE         0x00010000L
#define         AWPAPER_WIN31_DEFAULT           0x00020000L





#endif // _INC_BUFFERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\awdlib.h ===
#ifndef _AWDLIB_H
#define _AWDLIB_H
/*++
  awdlib.h

  header file for the AWD library.

  Copyright (c) 1997  Microsoft Corporation

  Author:
       Brian Dewey (t-briand)  1997-7-2

--*/

// needed includes for the AWD file format
#include <ole2.h>		// AWD is an OLE compound document.

// ------------------------------------------------------------
// Defines
#define MAX_AWD_NAME	(32)

// ------------------------------------------------------------
// Data types

// This structure holds the primary storages used in an AWD file.
typedef struct awd_file {
    IStorage *psAWDFile;	// The root storage of the file.
    IStorage *psDocuments;	// Storage holding the document data.
    IStorage *psPersistInfo;	// Persistent information storage.
    IStorage *psDocInfo;	// Document information stream.
    IStorage *psPageInfo;	// Page information storage.
    IStorage *psGlobalInfo;	// Global information storage.
} AWD_FILE;

// An AWD_DOC_PROCESSOR is a function that does something with an document
// contained in an AWD file.  Used in the EnumDocuments() function.  The
// function should return TRUE on success and FALSE on an error that requires
// the enumeration process to abort.
typedef BOOL (*AWD_DOC_PROCESSOR)(AWD_FILE *psStorages, const WCHAR *pwcsDocName);

#include "oleutils.h"		// Use the elliott fax viewer definitions.


// ------------------------------------------------------------
// Prototypes
BOOL      ConvertAWDToTiff(const WCHAR *pwcsAwdFile, WCHAR *pwcsTiffFile);
BOOL      OpenAWDFile(const WCHAR *pwcsFilename, AWD_FILE *psStorages);
BOOL      CloseAWDFile(AWD_FILE *psStorages);
IStorage *OpenAWDSubStorage(IStorage *psParent, const WCHAR *pwcsStorageName);
IStream  *OpenAWDStream(IStorage *psStorage, const WCHAR *pwcsStreamName);
BOOL      AWDViewed(AWD_FILE *psStorages);
void      DumpAWDDocuments(AWD_FILE *psStorages);
BOOL      EnumDocuments(AWD_FILE *psStorages, AWD_DOC_PROCESSOR pfnDocProc);
BOOL      DisplayDocNames(AWD_FILE *psStorages, const WCHAR *pwcsDocName);
BOOL      DetailedDocDump(AWD_FILE *psStorages, const WCHAR *pwcsDocName);
void      PrintPageInfo(PAGE_INFORMATION *psPageInfo);
void      DumpData(LPTSTR pszFileName, LPBYTE pbData, DWORD cbCount);



#endif // _AWDLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\viewrend\rbaview.cpp ===
/*==============================================================================
This module provides RBA rendering support for viewing faxes.

03-Mar-94   RajeevD    Created.
==============================================================================*/
#ifdef VIEWRBA

#include <memory.h>
#include "viewrend.hpp"
#include "resexec.h"


#define COMMON_SIZE 6

//==============================================================================
RBAVIEW::RBAVIEW (DWORD nType)
{
	_fmemset ((LPBYTE) this + sizeof(LPVOID), 0, sizeof(RBAVIEW) - sizeof(LPVOID));
	nTypeOut = nType;
}

//==============================================================================
RBAVIEW::~RBAVIEW ()
{
	if (hHRE)
		uiHREClose (hHRE);
		
	for (UINT iRes = 0; iRes < 256; iRes++)
		if (ResDir[iRes])
			GlobalFreePtr (ResDir[iRes]);

	if (lpCodec)
		GlobalFreePtr (lpCodec);

	if (bufIn.lpbBegBuf)
		GlobalFreePtr (bufIn.lpbBegBuf);
}
		
//==============================================================================
BOOL RBAVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	ENDJOB EndJob;
	
	if (!Open (lpFilePath, 0))
		return_error (("VIEWREND could not reopen spool file!\r\n"));

	if (!Read((LPBYTE) &BegJob, sizeof(BegJob)))
		return_error (("VIEWREND could not read spool header!\r\n"));

	dwOffset[0] = Tell();

	DEBUGCHK (lpwBandSize);
	*lpwBandSize = (WORD) BegJob.xBand/8 * (WORD) BegJob.yBand + OUTBUF_SLACK;

  if (BegJob.cResDir)
  {
		hHRE = hHREOpen (NULL, (UINT) BegJob.xBand/8, (UINT) BegJob.cResDir);
		if (!hHRE)
			return_error (("VIEWREND could not initialize resource executor!\r\n"));
	}
	
	if (1)
	{
		FC_PARAM fcp;
		UINT cbCodec;
		
		// Query for codec size.
		fcp.nTypeIn  = MMR_DATA;
		fcp.nTypeOut = LRAW_DATA;
		fcp.cbLine   = (UINT) BegJob.xBand / 8;
		cbCodec = FaxCodecInit (NULL, &fcp);
		DEBUGCHK (cbCodec);

    // Allocate codec context.
		lpCodec = GlobalAllocPtr (0, cbCodec);
		if (!lpCodec)
			return_error (("VIEWREND could allocate codec context!\r\n"));
		FaxCodecInit (lpCodec, &fcp);

		bufIn.wLengthBuf = 2000;
		bufIn.lpbBegBuf  = (LPBYTE) GlobalAllocPtr (0, bufIn.wLengthBuf);
		if (!bufIn.lpbBegBuf)
			return_error (("VIEWREND could not allocate input buffer!\r\n"));
	}

	// Fill VIEWINFO.
	lpvi->xRes = BegJob.xRes;
	lpvi->yRes = BegJob.yRes;

	if
	(    Seek (- (long) sizeof(ENDJOB), SEEK_END)
		&& Read (&EndJob, sizeof(ENDJOB))
		&& EndJob.dwID == ID_ENDJOB
	)
	{
		lpvi->cPage = EndJob.cPage;
		lpvi->yMax  = EndJob.yMax;
	}
	else
	{
		lpvi->cPage = 0;
		while (SetPage (lpvi->cPage))
			lpvi->cPage++;
		lpvi->yMax = 0;
	}
			 
	return SetPage (0);
}

//==============================================================================
BOOL RBAVIEW::SetPage (UINT iPage)
{
	if (iPage < iMaxPage)
	{
		Seek (dwOffset[iPage], STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET
		return TRUE;
	}

  Seek (dwOffset[iMaxPage], STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET

	while (1)
	{
		RESHDR Header;
		FRAME Frame;
		
		if (!Read ((LPBYTE) &Header, sizeof(Header)))
			return_error (("VIEWREND could not read RBA resource header!"));

		switch (Header.wClass)
		{
			case ID_GLYPH:			
			case ID_BRUSH:
			{
				UINT cbRaw;

				// Allocate mmeory from cache.
				Frame.lpData = (LPBYTE) GlobalAllocPtr (0, Header.cbRest);
				if (!Frame.lpData)
					return_error (("VIEWREND could not allocate memory!\r\n"));

				// Read resource from stream.
				if (!Read (Frame.lpData + COMMON_SIZE, Header.cbRest - COMMON_SIZE))
					return_error (("VIEWREND could not read resource!\r\n"));

				// Trap chaingon compressed glyph sets.
				cbRaw = HIWORD (Header.dwID);
				if (cbRaw)
				{
					LPVOID lpRaw;
					
					DEBUGCHK (Header.wClass == ID_GLYPH);
					if (!(lpRaw = GlobalAllocPtr (0, cbRaw)))
						return_error (("VIEWREND could not allocate decompression buffer!\r\n"));
					UnpackGlyphSet (Frame.lpData, lpRaw);
					GlobalFreePtr (Frame.lpData);

					Header.cbRest = (USHORT)cbRaw;
					Header.dwID   = LOWORD (Header.dwID);

					Frame.lpData = (LPBYTE) lpRaw;
				}

				// Past common header.
				_fmemcpy (Frame.lpData, &Header.dwID, COMMON_SIZE);
				Frame.wSize = Header.cbRest;

        // Add resource to directory.
				uiHREWrite (hHRE, &Frame, 1);
			  ResDir[Header.dwID] = Frame.lpData;
			  break;
			}
			  
			case ID_CONTROL:
			
				if (Header.dwID == ID_ENDPAGE)
				{
					iMaxPage++;
					dwOffset [iMaxPage] = Tell ();
					if (iPage < iMaxPage)
					{
					    // BKD: changed to STREAM_SEEK_SET
						Seek (dwOffset[iPage], STREAM_SEEK_SET); 
						return TRUE;
					}
				}

      // Yes, fall through to default case!
      
			default:

				// Skip everything else.
				if (!Seek (Header.cbRest - COMMON_SIZE, SEEK_CUR))
					return_error (("VIEWREND could not skip unknown RBA resource"));

		} // switch (Header.wClass)

	} // while (1)

}
	
//==============================================================================
BOOL RBAVIEW::GetBand (LPBITMAP lpbmBand)
{
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);
	
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = (WORD) BegJob.xBand;
	lpbmBand->bmWidthBytes = lpbmBand->bmWidth / 8;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	while (1)
	{
		RESHDR Header;

		if (!Read ((LPBYTE) &Header, sizeof(Header)))
			return FALSE;

  	switch (Header.wClass)
  	{
  		case ID_RPL:
  			return ExecuteRPL  (lpbmBand, &Header);

  		case ID_BAND:
  		  return ExecuteBand (lpbmBand, &Header);
	  
  		case ID_CONTROL:

				// Trap page breaks.
  			if (Header.dwID == ID_ENDPAGE)
  			{
					Seek (-8, SEEK_CUR);
					lpbmBand->bmHeight = 0;
					return TRUE;
  			}

  			// Yes, fall through to default case!

  		default:

  			// Skip everything else.
				if (!Seek (Header.cbRest - COMMON_SIZE, SEEK_CUR))
					return FALSE;
  	} // switch (Header.wClass)
		
	} // while (1)
	
}

//==============================================================================
BOOL RBAVIEW::ExecuteRPL (LPBITMAP lpbmBand, LPRESHDR lpHeader)
{
 	FRAME Frame;

  // Clear band.
	lpbmBand->bmHeight = (WORD) BegJob.yBand;
	_fmemset (lpbmBand->bmBits, 0, lpbmBand->bmHeight * lpbmBand->bmWidthBytes);

  // Trap blank bands.
	if (lpHeader->cbRest == COMMON_SIZE)
		return TRUE;

  // Allocate RPL.
	Frame.lpData = (LPBYTE) GlobalAllocPtr (0, lpHeader->cbRest);
	if (!Frame.lpData)
		return_error (("VIEWREND could not allocate RPL!\r\n"));

  // Load RPL.
	Frame.wSize = lpHeader->cbRest;
	_fmemcpy (Frame.lpData, &lpHeader->dwID, COMMON_SIZE);
	Read (Frame.lpData + COMMON_SIZE, Frame.wSize - COMMON_SIZE);

  // Execute RPL.
	uiHREWrite (hHRE, &Frame, 1);
	uiHREExecute (hHRE, lpbmBand, NULL);

	// Free RPL.
	GlobalFreePtr (Frame.lpData);
	return TRUE;
}

//==============================================================================
BOOL RBAVIEW::ExecuteBand (LPBITMAP lpbmBand, LPRESHDR lpHeader)
{
	BMPHDR bmh;
	UINT cbIn;
	FC_PARAM fcp;
	BUFFER bufOut;

	// Read bitmap header.
	if (!Read ((LPBYTE) &bmh, sizeof(bmh)))
		return FALSE;
	lpbmBand->bmHeight = bmh.wHeight;
	cbIn = lpHeader->cbRest - COMMON_SIZE - sizeof(bmh);
	
  // Trap uncompressed bands.
	if (!bmh.bComp)
	{
		if (!Read (lpbmBand->bmBits, cbIn))
			return FALSE;
		if (nTypeOut == LRAW_DATA)
		{
			BUFFER bufOut;
			bufOut.lpbBegData  = (LPBYTE) lpbmBand->bmBits;
			bufOut.wLengthData = (USHORT)cbIn;
			bufOut.dwMetaData  = HRAW_DATA;
			BitReverseBuf (&bufOut);
		}

		return TRUE;
	}
		
	// Initialize codec.
	fcp.nTypeIn  = bmh.bComp >> 2;
	fcp.nTypeOut = LRAW_DATA;
	fcp.cbLine   = (WORD) BegJob.xBand / 8;
	FaxCodecInit (lpCodec, &fcp);

	// Initialize input.
	bufIn.dwMetaData = fcp.nTypeIn;

	// Initialize output.
	bufOut.lpbBegBuf   = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf  = fcp.cbLine * bmh.wHeight;
	bufOut.lpbBegData  = bufOut.lpbBegBuf;
	bufOut.wLengthData = 0;
	bufOut.dwMetaData  = fcp.nTypeOut;

  // Convert.
	while (cbIn)
	{
		bufIn.lpbBegData = bufIn.lpbBegBuf;
		bufIn.wLengthData = min (cbIn, bufIn.wLengthBuf);
				
		if (!Read (bufIn.lpbBegData, bufIn.wLengthData))
			return FALSE;
		cbIn -= bufIn.wLengthData;

	 	if (FaxCodecConvert (lpCodec, &bufIn, &bufOut) == FC_DECODE_ERR)
	 		return_error (("VIEWREND MMR decode error!\r\n"));
	
	} // while (cbIn)

	if (nTypeOut == HRAW_DATA)
		BitReverseBuf (&bufOut);

	return TRUE;
}

#endif // VIEWRBA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\errormod.h ===
#ifndef _ERRORMOD_H
#define _ERRORMOD_H


// IFKERNEL API's
#define API_IFK_ALLOCBUF	         0x0040
#define API_IFK_FREEBUF	            0x0080
#define API_IFK_MAKEBUFWRITABLE	   0x00c0
#define API_IFK_SHAREBUF	         0x0100
#define API_IFK_SPLITBUF	         0x0140

#define API_IFK_IFGLOBALALLOC       0x1000
#define API_IFK_IFGLOBALFREE        0x1040

#define API_IFK_CREATEIFPIPE	      0x2000
#define API_IFK_DELETEIFPIPE	      0x2040
#define API_IFK_OPENIFPIPE	         0x2080
#define API_IFK_CLOSEIFPIPE	      0x20c0
#define API_IFK_REQREADFROMIFPIPE	0x2100
#define API_IFK_REQWRITETOIFPIPE	   0x2140

#define API_IFK_NEWMEMUNIT	         0x3040

#define API_IFK_POSTMESSAGE	      0x4000
#define API_IFK_GETMESSAGE		      0x4040
#define API_IFK_PEEKMESSAGE	      0x4080
#define API_IFK_BROADCASTMESSAGE	   0x40c0

#define API_IFK_CREATEPROCESS       0x5000
#define API_IFK_TERMINATEAPP            0x5040
#define API_IFK_GETIFPROCWINDOW         0x5080
#define API_IFK_SETIFPROCPRIORITY       0x50C0
#define API_IFK_GETIFPROCPRIORITY       0x5100

#define API_IFK_CREATEMUTEX	            0x6000
#define API_IFK_RELEASEMUTEX	        0x6040
#define API_IFK_CREATEEVENT	            0x6080
#define API_IFK_SETEVENT		        0x60c0   
#define API_IFK_WAITFORSINGLEOBJECT	    0x6100
#define API_IFK_FREESYNCOBJECT	        0x6140
#define API_IFK_GETSETEVENTPARAM        0x6180

#define API_IFK_IFSETTIMER             0x7000


//IFSCAN APIs (High level scanner driver: error codes in prnscn.h)
#define	API_OPENSCANNER				0x0040
#define	API_CLOSESCANNER			0x0080
#define	API_STARTSCANJOB			0x00c0
#define	API_ENDSCANJOB				0x0100
#define	API_CONTINUESCANJOB			0x0200
#define	API_ABORTSCANJOB			0x0300
#define	API_GETSCANNERSTATUS		0x0400
#define API_GETSCANNERPAPERINFO	  	0x0500
#define	API_GETSCANIMAGEINFO		0x0600
#define	API_GETSCANNERCAPS			0x0700
#define	API_GETSCANNERCUSTOMCAPS	0x0800
#define	API_COMPLETESCANPAGE		0x0900
#define	API_GETSCANDEVICEINFO		0x0a00
#define	API_SELECTSCANDEVICE		0x0b00
#define	API_SCANDEVICEMODE			0x0c00
#define	API_INITIFSCAN				0x0d00
#define	API_SCANDIAGNOSTICJOB		0x0e00
#define	API_GETDEVINFOFROMID		0x0f00
#define	API_GETDEVINFOFROMSTR		0x1000
#define	API_GETDEVDEFAULTMODE		0x1100
#define API_SCANNERPREFEED			0x1200
#define API_STARTCOPYJOB			0x1300
#define API_ENDCOPYJOB				0x1400

//IFPRINT (high level printer drivers api: error codes in prnscn.h)
#define	API_SELECTPRINTDEVICE		0x0a00
#define	API_GETPRINTDEVICEINFO		0x0900
#define	API_PRINTDEVICEMODE			0x0b00
#define	API_PRINTDIAGNOSTICJOB		0x0c00
#define API_CHECKPRINTERSTATUS		0x0d00

//Awreport(the report engine)
#define	API_AWREPORTMESSAGE			0x0a00


//Remote Access APIs (Remote Access Apis)
//IPX
#define	API_PSINIT				0x0040
#define	API_INITIATEBIND		0x0080

//MAC
#define	API_MACINIT				0x0040


//Renderer APIs

#define	API_RENDEROPEN				0x0040
#define	API_RENDEREXECUTE			0x0080
#define	API_RENDERCLOSE				0x00c0


//  Message pump events disguised as APIs

                                       // APICODE BITS | ERRCODE BITS
#define API_JOBMESSAGE        0x0040   // 0000 0000 01 | 00 0000
#define API_JOBCOMPLETE       0x0080   // 0000 0000 10 | 00 0000
#define API_JOBERRCOMPLETE    0x00C0   // 0000 0000 11 | 00 0000

#define API_MPJOBCANCEL       0x0100   
#define API_MPREJECTMSG       0x0140   
#define API_MPANSWER          0x0180   
#define API_MPTRANSPORT       0x01C0   
#define API_MPPOLLRETRIEVE    0x0200   
#define API_MPDEST            0x0240   




// WINDOWS MODULE API's 
#define WERR_OK  0x0
#define WERR_GETVERSION 0x40
#define WERR_GETFREESPACE 0x80
#define WERR_GETCURRENTPDB 0xC0
#define WERR_GETWINDOWSDIRECTORY 0x100
#define WERR_GETSYSTEMDIRECTORY 0x140
#define WERR_GETFREESYSTEMRESOURCES 0x180
#define WERR_GETWINFLAGS 0x1C0
#define WERR_GETDOSENVIRONMENT 0x200
#define WERR_GETCURRENTTIME 0x240
#define WERR_GETTICKCOUNT 0x280
#define WERR_GETTIMERRESOLUTION 0x2C0
#define WERR_LOGERROR 0x300
#define WERR_LOGPARAMERROR 0x340
#define WERR_GETWINDEBUGINFO 0x380
#define WERR_SETWINDEBUGINFO 0x3C0
#define WERR_FATALEXIT 0x400
#define WERR_FATALAPPEXIT 0x440
#define WERR_EXITWINDOWS 0x480
#define WERR_EXITWINDOWSEXEC 0x4C0
#define WERR_DEBUGBREAK 0x500
#define WERR_OUTPUTDEBUGSTRING 0x540
#define WERR_SETERRORMODE 0x580
#define WERR_ISBADREADPTR 0x5C0
#define WERR_ISBADWRITEPTR 0x600
#define WERR_ISBADHUGEREADPTR 0x640
#define WERR_ISBADHUGEWRITEPTR 0x680
#define WERR_ISBADCODEPTR 0x6C0
#define WERR_ISBADSTRINGPTR 0x700
#define WERR_PROFINSCHK 0x740
#define WERR_PROFSETUP 0x780
#define WERR_PROFSAMPRATE 0x7C0
#define WERR_PROFSTART 0x800
#define WERR_PROFSTOP 0x840
#define WERR_PROFCLEAR 0x880
#define WERR_PROFFLUSH 0x8C0
#define WERR_PROFFINISH 0x900
#define WERR_CATCH 0x940
#define WERR_THROW 0x980
#define WERR_SWITCHSTACKBACK 0x9C0
#define WERR_SWITCHSTACKTO 0xA00
#define WERR_LOADMODULE 0xA40
#define WERR_FREEMODULE 0xA80
#define WERR_LOADLIBRARY 0xAC0
#define WERR_FREELIBRARY 0xB00
#define WERR_WINEXEC 0xB40
#define WERR_GETMODULEHANDLE 0xB80
#define WERR_GETMODULEUSAGE 0xBC0
#define WERR_GETMODULEFILENAME 0xC00
#define WERR_GETPROCADDRESS 0xC40
#define WERR_GETINSTANCEDATA 0xC80
#define WERR_GETCODEHANDLE 0xCC0
#define WERR_GETCODEINFO 0xD00
#define WERR_MAKEPROCINSTANCE 0xD40
#define WERR_FREEPROCINSTANCE 0xD80
#define WERR_SETSWAPAREASIZE 0xDC0
#define WERR_SWAPRECORDING 0xE00
#define WERR_VALIDATECODESEGMENTS 0xE40
#define WERR_GETNUMTASKS 0xE80
#define WERR_ISTASK 0xEC0
#define WERR_GETCURRENTTASK 0xF00
#define WERR_YIELD 0xF40
#define WERR_DIRECTEDYIELD 0xF80
#define WERR_GLOBALALLOC 0xFC0
#define WERR_GLOBALREALLOC 0x1000
#define WERR_GLOBALFREE 0x1040
#define WERR_GLOBALDOSALLOC 0x1080
#define WERR_GLOBALDOSFREE 0x10C0
#define WERR_GLOBALLOCK 0x1100
//#define WERR_GLOBALLOCK 0x1140
#define WERR_GLOBALUNLOCK 0x1180
#define WERR_GLOBALSIZE 0x11C0
#define WERR_GLOBALHANDLE 0x1200
#define WERR_GLOBALFLAGS 0x1240
#define WERR_GLOBALWIRE 0x1280
//#define WERR_GLOBALWIRE 0x12C0
#define WERR_GLOBALUNWIRE 0x1300
#define WERR_GLOBALPAGELOCK 0x1340
#define WERR_GLOBALPAGEUNLOCK 0x1380
#define WERR_GLOBALFIX 0x13C0
#define WERR_GLOBALUNFIX 0x1400
#define WERR_GLOBALLRUNEWEST 0x1440
#define WERR_GLOBALLRUOLDEST 0x1480
#define WERR_GLOBALCOMPACT 0x14C0
#define WERR_GLOBALNOTIFY 0x1500
#define WERR_LOCKSEGMENT 0x1540
#define WERR_UNLOCKSEGMENT 0x1580
#define WERR_ALLOCSELECTOR 0x15C0
#define WERR_FREESELECTOR 0x1600
#define WERR_ALLOCDSTOCSALIAS 0x1640
#define WERR_PRESTOCHANGOSELECTOR 0x1680
#define WERR_GETSELECTORBASE 0x16C0
#define WERR_SETSELECTORBASE 0x1700
#define WERR_GETSELECTORLIMIT 0x1740
#define WERR_SETSELECTORLIMIT 0x1780
#define WERR_LIMITEMSPAGES 0x17C0
#define WERR_VALIDATEFREESPACES 0x1800
#define WERR_LOCALALLOC 0x1840
#define WERR_LOCALREALLOC 0x1880
#define WERR_LOCALFREE 0x18C0
#define WERR_LOCALLOCK 0x1900
//#define WERR_LOCALLOCK 0x1940
#define WERR_LOCALUNLOCK 0x1980
#define WERR_LOCALSIZE 0x19C0
#define WERR_LOCALHANDLE 0x1A00
//#define WERR_LOCALHANDLE 0x1A40
#define WERR_LOCALFLAGS 0x1A80
#define WERR_LOCALINIT 0x1AC0
#define WERR_LOCALCOMPACT 0x1B00
#define WERR_LOCALSHRINK 0x1B40
#define WERR_OPENFILE 0x1B80
#define WERR__LOPEN 0x1BC0
#define WERR__LCREAT 0x1C00
#define WERR__LCLOSE 0x1C40
#define WERR__LLSEEK 0x1C80
#define WERR__LREAD 0x1CC0
#define WERR__LWRITE 0x1D00
#define WERR__HREAD 0x1D40
#define WERR__HWRITE 0x1D80
#define WERR_GETTEMPFILENAME 0x1DC0
#define WERR_GETTEMPDRIVE 0x1E00
#define WERR_GETDRIVETYPE 0x1E40
#define WERR_SETHANDLECOUNT 0x1E80
#define WERR_WNETADDCONNECTION 0x1EC0
#define WERR_WNETGETCONNECTION 0x1F00
#define WERR_WNETCANCELCONNECTION 0x1F40
#define WERR_FINDRESOURCE 0x1F80
#define WERR_LOADRESOURCE 0x1FC0
#define WERR_FREERESOURCE 0x2000
#define WERR_LOCKRESOURCE 0x2040
//#define WERR_LOCKRESOURCE 0x2080
#define WERR_SIZEOFRESOURCE 0x20C0
#define WERR_ACCESSRESOURCE 0x2100
#define WERR_ALLOCRESOURCE 0x2140
#define WERR_SETRESOURCEHANDLER 0x2180
#define WERR_INITATOMTABLE 0x21C0
#define WERR_ADDATOM 0x2200
#define WERR_DELETEATOM 0x2240
#define WERR_FINDATOM 0x2280
#define WERR_GETATOMNAME 0x22C0
#define WERR_GLOBALADDATOM 0x2300
#define WERR_GLOBALDELETEATOM 0x2340
#define WERR_GLOBALFINDATOM 0x2380
#define WERR_GLOBALGETATOMNAME 0x23C0
#define WERR_GETATOMHANDLE 0x2400
#define WERR_GETPROFILEINT 0x2440
#define WERR_GETPROFILESTRING 0x2480
#define WERR_WRITEPROFILESTRING 0x24C0
#define WERR_GETPRIVATEPROFILEINT 0x2500
#define WERR_GETPRIVATEPROFILESTRING 0x2540
#define WERR_WRITEPRIVATEPROFILESTRING 0x2580
#define WERR_ANSITOOEM 0x25C0
#define WERR_OEMTOANSI 0x2600
#define WERR_ANSITOOEMBUFF 0x2640
#define WERR_OEMTOANSIBUFF 0x2680
#define WERR_ANSINEXT 0x26C0
#define WERR_ANSIPREV 0x2700
#define WERR_ANSIUPPER 0x2740
#define WERR_ANSILOWER 0x2780
#define WERR_ANSIUPPERBUFF 0x27C0
#define WERR_ANSILOWERBUFF 0x2800
#define WERR_ISCHARALPHA 0x2840
#define WERR_ISCHARALPHANUMERIC 0x2880
#define WERR_ISCHARUPPER 0x28C0
#define WERR_ISCHARLOWER 0x2900
#define WERR_LSTRCMP 0x2940
#define WERR_LSTRCMPI 0x2980
#define WERR_LSTRCPY 0x29C0
#define WERR_LSTRCAT 0x2A00
#define WERR_LSTRLEN 0x2A40
#define WERR_LSTRCPYN 0x2A80
#define WERR_HMEMCPY 0x2AC0
#define WERR_ISDBCSLEADBYTE 0x2B00
#define WERR_LOADSTRING 0x2B40
#define WERR_OEMKEYSCAN 0x2B80
#define WERR_VKKEYSCAN 0x2BC0
#define WERR_GETKEYBOARDTYPE 0x2C00
#define WERR_MAPVIRTUALKEY 0x2C40
#define WERR_GETKBCODEPAGE 0x2C80
#define WERR_GETKEYNAMETEXT 0x2CC0
#define WERR_TOASCII 0x2D00
#define WERR_CREATEDC 0x2D40
#define WERR_CREATEIC 0x2D80
#define WERR_CREATECOMPATIBLEDC 0x2DC0
#define WERR_DELETEDC 0x2E00
#define WERR_GETDCORG 0x2E40
#define WERR_SAVEDC 0x2E80
#define WERR_RESTOREDC 0x2EC0
#define WERR_SETENVIRONMENT 0x2F00
#define WERR_GETENVIRONMENT 0x2F40
#define WERR_MULDIV 0x2F80
#define WERR_SETBOUNDSRECT 0x2FC0
#define WERR_GETBOUNDSRECT 0x3000
#define WERR_GETDEVICECAPS 0x3040
#define WERR_SETMAPMODE 0x3080
#define WERR_GETMAPMODE 0x30C0
#define WERR_SETWINDOWORG 0x3100
#define WERR_GETWINDOWORG 0x3140
#define WERR_SETWINDOWEXT 0x3180
#define WERR_GETWINDOWEXT 0x31C0
#define WERR_OFFSETWINDOWORG 0x3200
#define WERR_SCALEWINDOWEXT 0x3240
#define WERR_SETVIEWPORTORG 0x3280
#define WERR_GETVIEWPORTORG 0x32C0
#define WERR_SETVIEWPORTEXT 0x3300
#define WERR_GETVIEWPORTEXT 0x3340
#define WERR_OFFSETVIEWPORTORG 0x3380
#define WERR_SCALEVIEWPORTEXT 0x33C0
#define WERR_SETWINDOWORGEX 0x3400
#define WERR_GETWINDOWORGEX 0x3440
#define WERR_SETWINDOWEXTEX 0x3480
#define WERR_GETWINDOWEXTEX 0x34C0
#define WERR_OFFSETWINDOWORGEX 0x3500
#define WERR_SCALEWINDOWEXTEX 0x3540
#define WERR_SETVIEWPORTEXTEX 0x3580
#define WERR_GETVIEWPORTEXTEX 0x35C0
#define WERR_SETVIEWPORTORGEX 0x3600
#define WERR_GETVIEWPORTORGEX 0x3640
#define WERR_OFFSETVIEWPORTORGEX 0x3680
#define WERR_SCALEVIEWPORTEXTEX 0x36C0
#define WERR_DPTOLP 0x3700
#define WERR_LPTODP 0x3740
#define WERR_GETNEARESTCOLOR 0x3780
#define WERR_GETSYSCOLOR 0x37C0
#define WERR_SETSYSCOLORS 0x3800
#define WERR_GETSTOCKOBJECT 0x3840
#define WERR_ISGDIOBJECT 0x3880
#define WERR_DELETEOBJECT 0x38C0
#define WERR_SELECTOBJECT 0x3900
#define WERR_GETOBJECT 0x3940
#define WERR_UNREALIZEOBJECT 0x3980
#define WERR_ENUMOBJECTS 0x39C0
//#define WERR_ENUMOBJECTS 0x3A00
#define WERR_CREATEPEN 0x3A40
#define WERR_CREATEPENINDIRECT 0x3A80
#define WERR_CREATESOLIDBRUSH 0x3AC0
#define WERR_CREATEHATCHBRUSH 0x3B00
#define WERR_CREATEPATTERNBRUSH 0x3B40
#define WERR_CREATEDIBPATTERNBRUSH 0x3B80
#define WERR_CREATEBRUSHINDIRECT 0x3BC0
#define WERR_SETBRUSHORG 0x3C00
#define WERR_GETBRUSHORG 0x3C40
#define WERR_GETBRUSHORGEX 0x3C80
#define WERR_CREATERECTRGN 0x3CC0
#define WERR_CREATERECTRGNINDIRECT 0x3D00
#define WERR_CREATEELLIPTICRGNINDIRECT 0x3D40
#define WERR_CREATEELLIPTICRGN 0x3D80
#define WERR_CREATEPOLYGONRGN 0x3DC0
#define WERR_CREATEPOLYPOLYGONRGN 0x3E00
#define WERR_CREATEROUNDRECTRGN 0x3E40
#define WERR_SETRECTRGN 0x3E80
#define WERR_COMBINERGN 0x3EC0
#define WERR_EQUALRGN 0x3F00
#define WERR_OFFSETRGN 0x3F40
#define WERR_GETRGNBOX 0x3F80
#define WERR_RECTINREGION 0x3FC0
#define WERR_PTINREGION 0x4000
#define WERR_CREATEPALETTE 0x4040
#define WERR_SELECTPALETTE 0x4080
#define WERR_REALIZEPALETTE 0x40C0
#define WERR_UPDATECOLORS 0x4100
#define WERR_ANIMATEPALETTE 0x4140
#define WERR_SETPALETTEENTRIES 0x4180
#define WERR_GETPALETTEENTRIES 0x41C0
#define WERR_GETNEARESTPALETTEINDEX 0x4200
#define WERR_RESIZEPALETTE 0x4240
#define WERR_GETSYSTEMPALETTEENTRIES 0x4280
#define WERR_GETSYSTEMPALETTEUSE 0x42C0
#define WERR_SETSYSTEMPALETTEUSE 0x4300
#define WERR_SELECTCLIPRGN 0x4340
#define WERR_GETCLIPBOX 0x4380
#define WERR_INTERSECTCLIPRECT 0x43C0
#define WERR_OFFSETCLIPRGN 0x4400
#define WERR_EXCLUDECLIPRECT 0x4440
#define WERR_PTVISIBLE 0x4480
#define WERR_RECTVISIBLE 0x44C0
#define WERR_MOVETO 0x4500
#define WERR_GETCURRENTPOSITION 0x4540
#define WERR_MOVETOEX 0x4580
#define WERR_GETCURRENTPOSITIONEX 0x45C0
#define WERR_LINETO 0x4600
#define WERR_POLYLINE 0x4640
#define WERR_LINEDDA 0x4680
#define WERR_RECTANGLE 0x46C0
#define WERR_ROUNDRECT 0x4700
#define WERR_ELLIPSE 0x4740
#define WERR_ARC 0x4780
#define WERR_CHORD 0x47C0
#define WERR_PIE 0x4800
#define WERR_POLYGON 0x4840
#define WERR_POLYPOLYGON 0x4880
#define WERR_SETPOLYFILLMODE 0x48C0
#define WERR_GETPOLYFILLMODE 0x4900
#define WERR_FLOODFILL 0x4940
#define WERR_EXTFLOODFILL 0x4980
#define WERR_FILLRGN 0x49C0
#define WERR_FRAMERGN 0x4A00
#define WERR_INVERTRGN 0x4A40
#define WERR_PAINTRGN 0x4A80
#define WERR_FILLRECT 0x4AC0
#define WERR_FRAMERECT 0x4B00
#define WERR_INVERTRECT 0x4B40
#define WERR_DRAWFOCUSRECT 0x4B80
#define WERR_TEXTOUT 0x4BC0
#define WERR_TABBEDTEXTOUT 0x4C00
#define WERR_EXTTEXTOUT 0x4C40
#define WERR_GETTEXTEXTENT 0x4C80
#define WERR_GETTABBEDTEXTEXTENT 0x4CC0
#define WERR_GETTEXTEXTENTPOINT 0x4D00
#define WERR_DRAWTEXT 0x4D40
#define WERR_GRAYSTRING 0x4D80
#define WERR_GETCHARWIDTH 0x4DC0
#define WERR_SETTEXTCOLOR 0x4E00
#define WERR_GETTEXTCOLOR 0x4E40
#define WERR_SETBKCOLOR 0x4E80
#define WERR_GETBKCOLOR 0x4EC0
#define WERR_SETBKMODE 0x4F00
#define WERR_GETBKMODE 0x4F40
#define WERR_SETTEXTALIGN 0x4F80
#define WERR_GETTEXTALIGN 0x4FC0
#define WERR_SETTEXTCHARACTEREXTRA 0x5000
#define WERR_GETTEXTCHARACTEREXTRA 0x5040
#define WERR_SETTEXTJUSTIFICATION 0x5080
#define WERR_CREATEFONT 0x50C0
#define WERR_CREATEFONTINDIRECT 0x5100
#define WERR_SETMAPPERFLAGS 0x5140
#define WERR_ADDFONTRESOURCE 0x5180
#define WERR_REMOVEFONTRESOURCE 0x51C0
#define WERR_GETTEXTFACE 0x5200
#define WERR_GETASPECTRATIOFILTER 0x5240
#define WERR_GETASPECTRATIOFILTEREX 0x5280
#define WERR_GETTEXTMETRICS 0x52C0
#define WERR_GETOUTLINETEXTMETRICS 0x5300
#define WERR_ENUMFONTFAMILIES 0x5340
#define WERR_ENUMFONTS 0x5380
//#define WERR_ENUMFONTS 0x53C0
//#define WERR_ENUMFONTFAMILIES 0x5400
#define WERR_GETFONTDATA 0x5440
#define WERR_CREATESCALABLEFONTRESOURCE 0x5480
#define WERR_GETGLYPHOUTLINE 0x54C0
#define WERR_GETCHARABCWIDTHS 0x5500
#define WERR_GETKERNINGPAIRS 0x5540
#define WERR_GETRASTERIZERCAPS 0x5580
#define WERR_CREATEBITMAP 0x55C0
#define WERR_CREATEBITMAPINDIRECT 0x5600
#define WERR_CREATECOMPATIBLEBITMAP 0x5640
#define WERR_CREATEDISCARDABLEBITMAP 0x5680
#define WERR_CREATEDIBITMAP 0x56C0
#define WERR_LOADBITMAP 0x5700
#define WERR_BITBLT 0x5740
#define WERR_PATBLT 0x5780
#define WERR_STRETCHBLT 0x57C0
#define WERR_STRETCHDIBITS 0x5800
#define WERR_SETPIXEL 0x5840
#define WERR_GETPIXEL 0x5880
#define WERR_SETSTRETCHBLTMODE 0x58C0
#define WERR_GETSTRETCHBLTMODE 0x5900
#define WERR_SETBITMAPDIMENSION 0x5940
#define WERR_GETBITMAPDIMENSION 0x5980
#define WERR_SETBITMAPDIMENSIONEX 0x59C0
#define WERR_GETBITMAPDIMENSIONEX 0x5A00
#define WERR_SETROP2 0x5A40
#define WERR_GETROP2 0x5A80
#define WERR_SETBITMAPBITS 0x5AC0
#define WERR_GETBITMAPBITS 0x5B00
#define WERR_SETDIBITS 0x5B40
#define WERR_GETDIBITS 0x5B80
#define WERR_SETDIBITSTODEVICE 0x5BC0
#define WERR_CREATEMETAFILE 0x5C00
#define WERR_CLOSEMETAFILE 0x5C40
#define WERR_GETMETAFILE 0x5C80
#define WERR_DELETEMETAFILE 0x5CC0
#define WERR_COPYMETAFILE 0x5D00
#define WERR_PLAYMETAFILE 0x5D40
#define WERR_GETMETAFILEBITS 0x5D80
#define WERR_SETMETAFILEBITS 0x5DC0
#define WERR_SETMETAFILEBITSBETTER 0x5E00
#define WERR_PLAYMETAFILERECORD 0x5E40
#define WERR_ENUMMETAFILE 0x5E80
#define WERR_STARTDOC 0x5EC0
#define WERR_STARTPAGE 0x5F00
#define WERR_ENDPAGE 0x5F40
#define WERR_ENDDOC 0x5F80
#define WERR_ABORTDOC 0x5FC0
#define WERR_SETABORTPROC 0x6000
#define WERR_SPOOLFILE 0x6040
#define WERR_QUERYABORT 0x6080
#define WERR_ESCAPE 0x60C0
#define WERR_GETSYSTEMMETRICS 0x6100
#define WERR_GETDOUBLECLICKTIME 0x6140
#define WERR_SETDOUBLECLICKTIME 0x6180
#define WERR_SYSTEMPARAMETERSINFO 0x61C0
#define WERR_SETRECT 0x6200
#define WERR_SETRECTEMPTY 0x6240
#define WERR_COPYRECT 0x6280
#define WERR_ISRECTEMPTY 0x62C0
#define WERR_EQUALRECT 0x6300
#define WERR_INTERSECTRECT 0x6340
#define WERR_UNIONRECT 0x6380
#define WERR_SUBTRACTRECT 0x63C0
#define WERR_OFFSETRECT 0x6400
#define WERR_INFLATERECT 0x6440
#define WERR_PTINRECT 0x6480
#define WERR_REGISTERWINDOWMESSAGE 0x64C0
#define WERR_GETMESSAGE 0x6500
#define WERR_PEEKMESSAGE 0x6540
#define WERR_WAITMESSAGE 0x6580
#define WERR_GETMESSAGEPOS 0x65C0
#define WERR_GETMESSAGETIME 0x6600
#define WERR_GETMESSAGEEXTRAINFO 0x6640
#define WERR_TRANSLATEMESSAGE 0x6680
#define WERR_DISPATCHMESSAGE 0x66C0
#define WERR_SETMESSAGEQUEUE 0x6700
#define WERR_GETINPUTSTATE 0x6740
#define WERR_GETQUEUESTATUS 0x6780
#define WERR_POSTMESSAGE 0x67C0
#define WERR_SENDMESSAGE 0x6800
#define WERR_POSTAPPMESSAGE 0x6840
#define WERR_REPLYMESSAGE 0x6880
#define WERR_INSENDMESSAGE 0x68C0
#define WERR_CALLMSGFILTER 0x6900
#define WERR_POSTQUITMESSAGE 0x6940
#define WERR_REGISTERCLASS 0x6980
#define WERR_UNREGISTERCLASS 0x69C0
#define WERR_GETCLASSINFO 0x6A00
#define WERR_GETCLASSNAME 0x6A40
#define WERR_GETCLASSWORD 0x6A80
#define WERR_SETCLASSWORD 0x6AC0
#define WERR_GETCLASSLONG 0x6B00
#define WERR_SETCLASSLONG 0x6B40
#define WERR_ISWINDOW 0x6B80
#define WERR_CREATEWINDOWEX 0x6BC0
#define WERR_CREATEWINDOW 0x6C00
#define WERR_DESTROYWINDOW 0x6C40
#define WERR_GETWINDOWTASK 0x6C80
#define WERR_ISCHILD 0x6CC0
#define WERR_GETPARENT 0x6D00
#define WERR_SETPARENT 0x6D40
#define WERR_ISWINDOWVISIBLE 0x6D80
#define WERR_SHOWWINDOW 0x6DC0
#define WERR_ENABLEWINDOW 0x6E00
#define WERR_ISWINDOWENABLED 0x6E40
#define WERR_SETWINDOWTEXT 0x6E80
#define WERR_GETWINDOWTEXT 0x6EC0
#define WERR_GETWINDOWTEXTLENGTH 0x6F00
#define WERR_GETWINDOWWORD 0x6F40
#define WERR_SETWINDOWWORD 0x6F80
#define WERR_GETWINDOWLONG 0x6FC0
#define WERR_SETWINDOWLONG 0x7000
#define WERR_GETCLIENTRECT 0x7040
#define WERR_GETWINDOWRECT 0x7080
#define WERR_GETWINDOWPLACEMENT 0x70C0
#define WERR_SETWINDOWPLACEMENT 0x7100
#define WERR_SETWINDOWPOS 0x7140
#define WERR_BEGINDEFERWINDOWPOS 0x7180
#define WERR_DEFERWINDOWPOS 0x71C0
#define WERR_ENDDEFERWINDOWPOS 0x7200
#define WERR_MOVEWINDOW 0x7240
#define WERR_BRINGWINDOWTOTOP 0x7280
#define WERR_DEFWINDOWPROC 0x72C0
#define WERR_CALLWINDOWPROC 0x7300
//#define WERR_CALLWINDOWPROC 0x7340
#define WERR_ADJUSTWINDOWRECT 0x7380
#define WERR_ADJUSTWINDOWRECTEX 0x73C0
#define WERR_FLASHWINDOW 0x7400
#define WERR_SHOWOWNEDPOPUPS 0x7440
#define WERR_OPENICON 0x7480
#define WERR_CLOSEWINDOW 0x74C0
#define WERR_ANYPOPUP 0x7500
#define WERR_ISICONIC 0x7540
#define WERR_ISZOOMED 0x7580
#define WERR_CLIENTTOSCREEN 0x75C0
#define WERR_SCREENTOCLIENT 0x7600
#define WERR_MAPWINDOWPOINTS 0x7640
#define WERR_WINDOWFROMPOINT 0x7680
#define WERR_CHILDWINDOWFROMPOINT 0x76C0
#define WERR_GETDESKTOPWINDOW 0x7700
#define WERR_FINDWINDOW 0x7740
#define WERR_ENUMWINDOWS 0x7780
#define WERR_ENUMCHILDWINDOWS 0x77C0
#define WERR_ENUMTASKWINDOWS 0x7800
#define WERR_GETTOPWINDOW 0x7840
#define WERR_GETWINDOW 0x7880
#define WERR_GETNEXTWINDOW 0x78C0
#define WERR_SETPROP 0x7900
#define WERR_GETPROP 0x7940
#define WERR_REMOVEPROP 0x7980
#define WERR_ENUMPROPS 0x79C0
#define WERR_GETDC 0x7A00
#define WERR_RELEASEDC 0x7A40
#define WERR_GETWINDOWDC 0x7A80
#define WERR_GETDCEX 0x7AC0
#define WERR_BEGINPAINT 0x7B00
#define WERR_ENDPAINT 0x7B40
#define WERR_UPDATEWINDOW 0x7B80
#define WERR_EXCLUDEUPDATERGN 0x7BC0
#define WERR_LOCKWINDOWUPDATE 0x7C00
#define WERR_GETUPDATERECT 0x7C40
#define WERR_GETUPDATERGN 0x7C80
#define WERR_INVALIDATERECT 0x7CC0
#define WERR_VALIDATERECT 0x7D00
#define WERR_INVALIDATERGN 0x7D40
#define WERR_VALIDATERGN 0x7D80
#define WERR_REDRAWWINDOW 0x7DC0
#define WERR_SCROLLWINDOW 0x7E00
#define WERR_SCROLLDC 0x7E40
#define WERR_SCROLLWINDOWEX 0x7E80
#define WERR_SETACTIVEWINDOW 0x7EC0
#define WERR_GETACTIVEWINDOW 0x7F00
#define WERR_GETLASTACTIVEPOPUP 0x7F40
#define WERR_SETFOCUS 0x7F80
#define WERR_GETFOCUS 0x7FC0
#define WERR_GETKEYSTATE 0x8000
#define WERR_GETASYNCKEYSTATE 0x8040
#define WERR_GETKEYBOARDSTATE 0x8080
#define WERR_SETKEYBOARDSTATE 0x80C0
#define WERR_SETCAPTURE 0x8100
#define WERR_RELEASECAPTURE 0x8140
#define WERR_GETCAPTURE 0x8180
#define WERR_SWAPMOUSEBUTTON 0x81C0
#define WERR_GETSYSMODALWINDOW 0x8200
#define WERR_SETSYSMODALWINDOW 0x8240
#define WERR_SETTIMER 0x8280
#define WERR_KILLTIMER 0x82C0
#define WERR_LOADACCELERATORS 0x8300
#define WERR_TRANSLATEACCELERATOR 0x8340
#define WERR_ISMENU 0x8380
#define WERR_CREATEMENU 0x83C0
#define WERR_CREATEPOPUPMENU 0x8400
#define WERR_LOADMENU 0x8440
#define WERR_LOADMENUINDIRECT 0x8480
#define WERR_DESTROYMENU 0x84C0
#define WERR_GETMENU 0x8500
#define WERR_SETMENU 0x8540
#define WERR_GETSYSTEMMENU 0x8580
#define WERR_DRAWMENUBAR 0x85C0
#define WERR_HILITEMENUITEM 0x8600
#define WERR_INSERTMENU 0x8640
#define WERR_APPENDMENU 0x8680
#define WERR_MODIFYMENU 0x86C0
#define WERR_REMOVEMENU 0x8700
#define WERR_DELETEMENU 0x8740
#define WERR_CHANGEMENU 0x8780
#define WERR_ENABLEMENUITEM 0x87C0
#define WERR_CHECKMENUITEM 0x8800
#define WERR_GETSUBMENU 0x8840
#define WERR_GETMENUITEMCOUNT 0x8880
#define WERR_GETMENUITEMID 0x88C0
#define WERR_GETMENUSTRING 0x8900
#define WERR_GETMENUSTATE 0x8940
#define WERR_SETMENUITEMBITMAPS 0x8980
#define WERR_GETMENUCHECKMARKDIMENSIONS 0x89C0
#define WERR_TRACKPOPUPMENU 0x8A00
#define WERR_SETSCROLLPOS 0x8A40
#define WERR_GETSCROLLPOS 0x8A80
#define WERR_SETSCROLLRANGE 0x8AC0
#define WERR_GETSCROLLRANGE 0x8B00
#define WERR_SHOWSCROLLBAR 0x8B40
#define WERR_ENABLESCROLLBAR 0x8B80
#define WERR_OPENCLIPBOARD 0x8BC0
#define WERR_CLOSECLIPBOARD 0x8C00
#define WERR_EMPTYCLIPBOARD 0x8C40
#define WERR_GETOPENCLIPBOARDWINDOW 0x8C80
#define WERR_GETCLIPBOARDOWNER 0x8CC0
#define WERR_SETCLIPBOARDVIEWER 0x8D00
#define WERR_GETCLIPBOARDVIEWER 0x8D40
#define WERR_SETCLIPBOARDDATA 0x8D80
#define WERR_GETCLIPBOARDDATA 0x8DC0
#define WERR_ISCLIPBOARDFORMATAVAILABLE 0x8E00
#define WERR_GETPRIORITYCLIPBOARDFORMAT 0x8E40
#define WERR_REGISTERCLIPBOARDFORMAT 0x8E80
#define WERR_COUNTCLIPBOARDFORMATS 0x8EC0
#define WERR_ENUMCLIPBOARDFORMATS 0x8F00
#define WERR_GETCLIPBOARDFORMATNAME 0x8F40
#define WERR_CHANGECLIPBOARDCHAIN 0x8F80
#define WERR_LOADCURSOR 0x8FC0
#define WERR_CREATECURSOR 0x9000
#define WERR_DESTROYCURSOR 0x9040
#define WERR_COPYCURSOR 0x9080
#define WERR_SHOWCURSOR 0x90C0
#define WERR_SETCURSORPOS 0x9100
#define WERR_GETCURSORPOS 0x9140
#define WERR_SETCURSOR 0x9180
#define WERR_GETCURSOR 0x91C0
#define WERR_CLIPCURSOR 0x9200
#define WERR_GETCLIPCURSOR 0x9240
#define WERR_LOADICON 0x9280
#define WERR_CREATEICON 0x92C0
#define WERR_DESTROYICON 0x9300
#define WERR_COPYICON 0x9340
#define WERR_DRAWICON 0x9380
#define WERR_MESSAGEBOX 0x93C0
#define WERR_MESSAGEBEEP 0x9400
#define WERR_CREATECARET 0x9440
#define WERR_DESTROYCARET 0x9480
#define WERR_SETCARETPOS 0x94C0
#define WERR_GETCARETPOS 0x9500
#define WERR_HIDECARET 0x9540
#define WERR_SHOWCARET 0x9580
#define WERR_GETCARETBLINKTIME 0x95C0
#define WERR_SETCARETBLINKTIME 0x9600
#define WERR_DEFFRAMEPROC 0x9640
#define WERR_DEFMDICHILDPROC 0x9680
#define WERR_TRANSLATEMDISYSACCEL 0x96C0
#define WERR_ARRANGEICONICWINDOWS 0x9700
#define WERR_ISDIALOGMESSAGE 0x9740
#define WERR_DEFDLGPROC 0x9780
#define WERR_CREATEDIALOG 0x97C0
#define WERR_CREATEDIALOGINDIRECT 0x9800
#define WERR_CREATEDIALOGPARAM 0x9840
#define WERR_CREATEDIALOGINDIRECTPARAM 0x9880
#define WERR_DIALOGBOX 0x98C0
#define WERR_DIALOGBOXINDIRECT 0x9900
#define WERR_DIALOGBOXPARAM 0x9940
#define WERR_DIALOGBOXINDIRECTPARAM 0x9980
#define WERR_ENDDIALOG 0x99C0
#define WERR_GETDLGCTRLID 0x9A00
#define WERR_GETDLGITEM 0x9A40
#define WERR_SENDDLGITEMMESSAGE 0x9A80
#define WERR_SETDLGITEMINT 0x9AC0
#define WERR_GETDLGITEMINT 0x9B00
#define WERR_SETDLGITEMTEXT 0x9B40
#define WERR_GETDLGITEMTEXT 0x9B80
#define WERR_CHECKDLGBUTTON 0x9BC0
#define WERR_CHECKRADIOBUTTON 0x9C00
#define WERR_ISDLGBUTTONCHECKED 0x9C40
#define WERR_GETNEXTDLGGROUPITEM 0x9C80
#define WERR_GETNEXTDLGTABITEM 0x9CC0
#define WERR_MAPDIALOGRECT 0x9D00
#define WERR_GETDIALOGBASEUNITS 0x9D40
#define WERR_DLGDIRLIST 0x9D80
#define WERR_DLGDIRSELECT 0x9DC0
#define WERR_DLGDIRLISTCOMBOBOX 0x9E00
#define WERR_DLGDIRSELECTCOMBOBOX 0x9E40
#define WERR_DLGDIRSELECTEX 0x9E80
#define WERR_DLGDIRSELECTCOMBOBOXEX 0x9EC0
#define WERR_SETWINDOWSHOOK 0x9F00
#define WERR_DEFHOOKPROC 0x9F40
//#define WERR_SETWINDOWSHOOK 0x9F80
//#define WERR_DEFHOOKPROC 0x9FC0
#define WERR_UNHOOKWINDOWSHOOK 0xA000
#define WERR_SETWINDOWSHOOKEX 0xA040
#define WERR_UNHOOKWINDOWSHOOKEX 0xA080
#define WERR_CALLNEXTHOOKEX 0xA0C0
#define WERR_ENABLEHARDWAREINPUT 0xA100
#define WERR_QUERYSENDMESSAGE 0xA140
#define WERR_LOCKINPUT 0xA180
#define WERR_GETSYSTEMDEBUGSTATE 0xA1C0
#define WERR_WINHELP 0xA200
#define WERR_OPENSOUND 0xA240
#define WERR_CLOSESOUND 0xA280
#define WERR_STARTSOUND 0xA2C0
#define WERR_STOPSOUND 0xA300
#define WERR_SETVOICEQUEUESIZE 0xA340
#define WERR_SETVOICENOTE 0xA380
#define WERR_SETVOICEACCENT 0xA3C0
#define WERR_SETVOICEENVELOPE 0xA400
#define WERR_SETVOICESOUND 0xA440
#define WERR_SETVOICETHRESHOLD 0xA480
#define WERR_GETTHRESHOLDEVENT 0xA4C0
#define WERR_GETTHRESHOLDSTATUS 0xA500
#define WERR_SETSOUNDNOISE 0xA540
#define WERR_WAITSOUNDSTATE 0xA580
#define WERR_SYNCALLVOICES 0xA5C0
#define WERR_COUNTVOICENOTES 0xA600
#define WERR_BUILDCOMMDCB 0xA640
#define WERR_OPENCOMM 0xA680
#define WERR_CLOSECOMM 0xA6C0
#define WERR_READCOMM 0xA700
#define WERR_WRITECOMM 0xA740
#define WERR_UNGETCOMMCHAR 0xA780
#define WERR_FLUSHCOMM 0xA7C0
#define WERR_TRANSMITCOMMCHAR 0xA800
#define WERR_SETCOMMSTATE 0xA840
#define WERR_GETCOMMSTATE 0xA880
#define WERR_GETCOMMERROR 0xA8C0
#define WERR_SETCOMMBREAK 0xA900
#define WERR_CLEARCOMMBREAK 0xA940
#define WERR_SETCOMMEVENTMASK 0xA980
#define WERR_GETCOMMEVENTMASK 0xA9C0
#define WERR_ESCAPECOMMFUNCTION 0xAA00
#define WERR_ENABLECOMMNOTIFICATION 0xAA40
#define WERR_WVSPRINTF 0xAA80
#define WERR_DEFDRIVERPROC 0xAAC0
#define WERR_OPENDRIVER 0xAB00
#define WERR_CLOSEDRIVER 0xAB40
#define WERR_SENDDRIVERMESSAGE 0xAB80
#define WERR_GETDRIVERMODULEHANDLE 0xABC0
#define WERR_GETNEXTDRIVER 0xAC00
#define WERR_GETDRIVERINFO 0xAC40

#endif // _ERRORMOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\rambo.h ===
// Copyright (c) Microsoft Corp. 1994-95

#ifndef _RAMBO_
#define _RAMBO_

#include <windows.h>
#include <pshpack2.h>		// The structures in this file need to be word-aligned.

// common header
typedef struct
{
	WORD  cbRest;
	DWORD dwID;
	WORD  wClass;
}
	RESHDR, FAR *LPRESHDR;

// resource classes
#define ID_GLYPH   1
#define ID_BRUSH   2
#define ID_BITMAP  3
#define ID_RPL     4
#define ID_CONTROL 8
#define ID_BAND   10

// control IDs
#define ID_BEGJOB  0x49505741 // "AWPI"
#define ID_ENDPAGE 0x45474150 // "PAGE"
#define ID_ENDJOB  0x4a444e45 // "ENDJ"

// job header
typedef struct BEGJOB
{ 
	// common header
	WORD  cbRest;     // sizeof(BEGJOB) - sizeof(WORD)
	DWORD dwID;       // ID_BEGJOB
	WORD  wClass;     // ID_CONTROL

	// image attributes
	DWORD xBand;      // page width  [pixels]
	DWORD yBand;      // band height [pixels]
	WORD  xRes;       // horizontal resolution [dpi]
	WORD  yRes;       // vertical resolution [dpi]

	// memory attributes
	DWORD cbCache;    // cache size [KB]
	WORD  cResDir;    // directory size
	BYTE  bBitmap;    // bitmap compression
	BYTE  bGlyph;     // glyph compression
	BYTE  bBrush;     // stock brush set
	BYTE  bPad[3];    // reserved, must be 0
}
	BEGJOB, FAR *LPBEGJOB;

// job tailer
typedef struct ENDJOB
{
	// common header
	WORD  cbRest;      // sizeof(ENDJOB) - sizeof(WORD)
	DWORD dwID;        // ID_ENDJOB
	WORD  wClass;      // ID_CONTROL

	// job attributes
	WORD  cPage;       // number of pages
	WORD  yMax;        // maximum height
}
	ENDJOB, FAR *LPENDJOB;

// bitmap header
typedef	struct
{
	BYTE  bComp;
	BYTE  bLeftPad;
	WORD  wHeight;
	WORD  wWidth;
}
	BMPHDR, FAR* LPBMPHDR;

#include <poppack.h>

#endif // _RAMBO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\resexec.h ===
// Copyright (c) Microsoft Corp. 1994

// Resource Executor API

#ifndef _RESEXEC_
#define _RESEXEC_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC

typedef struct
{
	WORD wReserved;
	WORD wSize;             // size of this block
	LPBYTE lpData;          // pointer to frame data
}
	FRAME, FAR *LPFRAME;

HANDLE                 // context handle (NULL on failure)
WINAPI hHREOpen
(
	LPVOID lpReserved,   // reserved: set to NULL
	UINT   cbLine,       // maximum page width in bytes
	UINT   cResDir       // entries in resource directory
);

UINT   WINAPI uiHREWrite (HANDLE, LPFRAME, UINT);

UINT   WINAPI uiHREExecute
(
	HANDLE   hRE,        // resource executor context
  LPBITMAP lpbmBand,   // output band buffer
  LPVOID   lpBrushPat  // array of 32x32 brush patterns
);

UINT   WINAPI uiHREClose (HANDLE);

void   WINAPI UnpackGlyphSet (LPVOID, LPVOID);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _RESEXEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\viewrend.h ===
// Copyright (c) Microsoft Corp. 1993-94
/*==============================================================================
This header file defines the viewer rendering support API.

17-Oct-93    RajeevD    Created.
25-Oct-93    RajeevD    Updated to support random access to bands.
==============================================================================*/
#ifndef _INC_VIEWREND
#define _INC_VIEWREND

#include <ifaxos.h>

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC
	
#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
	WORD cPage;  // number of pages
	WORD xRes;   // horizontal resolution [dpi]
	WORD yRes;   // vertical resolution [dpi]
	WORD yMax;   // maximum page height [pixels]
}
	VIEWINFO, FAR* LPVIEWINFO;
	
/*==============================================================================
This initialization procedure creates a context for use in all subsequent calls.
Upon call, the lpwBandSize parameter point to the preferred output band buffer 
size.  Upon return, it may be filled with a larger value if required.
==============================================================================*/
LPVOID                // returns context (NULL on failure)
WINAPI
ViewerOpen
(
	LPVOID     lpFile,      // IFAX key or Win3.1 path or OLE2 IStream
	DWORD      nType,       // data type: HRAW_DATA or LRAW_DATA
	LPWORD     lpwResoln,   // output pointer to x, y dpi array
	LPWORD     lpwBandSize, // input/output pointer to output band size
	LPVIEWINFO lpViewInfo   // output pointer to VIEWINFO struct
);

/*==============================================================================
This procedure sets the current page.  The first page has index 0.
==============================================================================*/
BOOL                   // returns success/failure
WINAPI      
ViewerSetPage
(
	LPVOID lpContext,    // context pointer
	UINT   iPage         // page index
);

/*==============================================================================
This procedure may be called repeatedly to fetch successive bands of a page.  
Upon call, lpbmBand->bmBits must point to an output band buffer.  Upon return, 
the remaining fields of lpbmBand will be filled.  The lpbmBand->bmHeight will 
be set to 0 to indicate end of page.
==============================================================================*/
BOOL                  // returns success/failure
WINAPI
ViewerGetBand
(
	LPVOID   lpContext, // context pointer
	LPBITMAP lpbmBand 
);

/*==============================================================================
This termination call releases the context.
==============================================================================*/
BOOL WINAPI ViewerClose
(
	LPVOID lpContext
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _INC_VIEWREND
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\migrate.h ===
#ifndef __MIGRATE_H
#define __MIGRATE_H
/*++
  migrate.h

  Copyright (c) 1997  Microsoft Corporation


  This file contains prototypes & definitions for the Win95->XP Fax
  migration DLL.

  Author:

  Brian Dewey (t-briand) 1997-7-14

--*/


//
//  Vendor Info Stucture
//
typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;


// ------------------------------------------------------------
// Prototypes

// All of these functions are required in a migration DLL.
LONG
CALLBACK 
QueryVersion (
	OUT LPCSTR  *ProductID,	    // Unique identifier string.
	OUT LPUINT  DllVersion,	    // Version number.  Cannot be zero.
	OUT LPINT   *CodePageArray, // OPTIONAL.  Language dependencies.
	OUT LPCSTR  *ExeNamesBuf,   // OPTIONAL.  Executables to look for.
	PVENDORINFO  *VendorInfo    //  Vendor Info
	);

LONG
CALLBACK
Initialize9x(
    IN  LPCSTR WorkingDirectory,  // Place to store files.
    IN  LPCSTR SourceDirectories, // Location of the Windows XP source. MULTI-SZ.
    IN  LPCSTR MediaDirectory     // Path to the original media directory
    );

LONG
CALLBACK
MigrateUser9x(
    IN  HWND ParentWnd,		  // Parent (if need a UI)
    IN  LPCSTR UnattendFile,	  // Name of unattend file
    IN  HKEY UserRegKey,	  // Key to this user's registry settings.
    IN  LPCSTR UserName,	  // Account name of user.
    LPVOID Reserved
    );

LONG
CALLBACK
MigrateSystem9x(
    IN  HWND ParentWnd,		  // Parent for UI.
    IN  LPCSTR UnattendFile,	  // Name of unattend file
    LPVOID Reserved
    );

LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR WorkingDirectory, // Working directory for temporary files.
    IN  LPCWSTR SourceDirectory,  // Directory of winNT source.
    LPVOID Reserved		  // It's reserved.
    );

LONG
CALLBACK
MigrateUserNT(
    IN  HINF UnattendInfHandle,	  // Access to the unattend.txt file.
    IN  HKEY UserRegHandle,	  // Handle to registry settings for user.
    IN  LPCWSTR UserName,	  // Name of the user.
    LPVOID Reserved
    );

LONG
CALLBACK
MigrateSystemNT(
    IN  HINF UnattendInfHandle,	  // Access to the unattend.txt file.
    LPVOID Reserved
    );

// ------------------------------------------------------------
// defines
#define FAX_MIGRATION_VERSION	(1)

// ------------------------------------------------------------
// global data
extern LPCTSTR lpLogonUser;	  // Holds the logon user name for faxuser.ini
extern TCHAR   szInfFileName[];	  // Name of the generated INF file.
extern HINSTANCE hinstMigDll;	  // Handle to the migration DLL instance.

#define INF_RULE_LOCAL_ID           _T("LocalID")
#define INF_RULE_NUM_RINGS          _T("NumRings")
#define INF_RULE_ANSWER_MODE        _T("AnswerMode")


#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\oleutils.h ===
/*
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

        name:   Elliot Viewer - Chicago Viewer Utility
        						Cloned from the IFAX Message Viewing Utility

        file:   oleutils.h

    comments:   Functions to support OLE2 interactions
            
        
		NOTE: This header must be used with the LARGE memory model
		
----------------------------------------------------------------------------
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
*/
       
#ifndef OLEUTILS_H
#define OLEUTILS_H
    
    
#include <ole2.h>


/*
	Version constants
 */
#define AWD_SIGNATURE		0
#define AWD_SIGNATURE_STR  "0"

/*
	This has the "current" version. As new ones come along shift this
	down to a new AWD_VERxx... set and add a check to 
	CViewer::get_awd_version. Add a new version check and any code
	needed to handle whatever is different with the new version to 
	appropriate places in oleutils.cpp, etc...
 */
#define AWD_VERSION			1
#define AWD_VERSION_STR	   "1"

// this is same as AWD_VERSION, used by the transport
#define AWD_VER1A			1
#define AWD_VER1A_STR	   "1.0 (pages = docs)"


/*
	Recognized extensions
 */
#define BMP_EXT			_T("bmp")
#define DIB_EXT			_T("dib")
#define DCX_EXT			_T("dcx")
#define RBA_EXT			_T("rba")
#define RMF_EXT			_T("rmf")
#define AWD_EXT			_T("awd")


/*
	AWD flags
 */
#define AWD_FIT_WIDTH	0x00000001
#define AWD_FIT_HEIGHT	0x00000002
#define AWD_INVERT		0x00000010
#define AWD_WASINVERTED	0x40000000
#define AWD_IGNORE		0x80000000

       
/*
	AWD file structures
 */
#pragma pack( 1 ) // THESE STRUCTS MUST BE BYTE ALIGNED
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Rotation;
	WORD  ScaleX;
	WORD  ScaleY;
	}
	PAGE_INFORMATION;
	
	
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	PAGE_INFORMATION PageInformation;
	}
	DOCUMENT_INFORMATION;
		
	
	
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Author_bufferlen; // includes the UNICODE '\0' terminator
	WCHAR Author[1];		// UNICODE !!!
	}
	OVERLAY_INFORMATION;



// defs for summary stream- must be 32bit aligned
#pragma pack( 4 )


#define SUMMARY_FMTID( fmtid )                                          \
	CLSID fmtid =														\
	{0xF29F85E0, 0x4FF9, 0x1068, {0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9}}
				 
				 

#define PID_TITLE	        0x00000002
#define PID_SUBJECT         0x00000003
#define PID_AUTHOR          0x00000004
#define PID_KEYWORDS        0x00000005
#define PID_COMMENTS        0x00000006
#define PID_TEMPLATE        0x00000007
#define PID_LASTAUTHOR      0x00000008
#define PID_REVNUMBER       0x00000009
#define PID_EDITTIME        0x0000000a
#define PID_LASTPRINTED     0x0000000b
#define PID_CREATE_DTM      0x0000000c
#define PID_LASTSAVE_DTM	0x0000000d
#define PID_PAGECOUNT       0x0000000e
#define PID_WORDCOUNT       0x0000000f
#define PID_CHARCOUNT       0x00000010
#define PID_THUMBNAIL       0x00000011
#define PID_APPNAME         0x00000012

// BKD 1997-7-9: done to disable warning message.  This is probably bad that the oleutils
// uses a macro that's now been reserved and probably should be changed.
// FIXBKD
#ifdef PID_SECURITY
#undef PID_SECURITY
#endif // PID_SECURITY

#define PID_SECURITY        0x00000013


typedef struct
	{
	DWORD dwType;
	DATE  date;
	}
	date_prop_t;
	

typedef struct
	{
	DWORD dwType;
	DWORD wval;
	}
	wval_prop_t;


typedef struct
	{
	DWORD dwType;
	DWORD numbytes;
	char  string[80]; 
	}
	string_prop_t;
	

typedef struct
	{
	DWORD PropertyID;
	DWORD dwOffset;
	}
	PROPERTYIDOFFSET;


typedef struct
	{
	DWORD cbSection;
	DWORD cProperties;
	
	PROPERTYIDOFFSET revnum_pair;
	PROPERTYIDOFFSET lastprt_pair;
	PROPERTYIDOFFSET create_dtm_pair;
	PROPERTYIDOFFSET lastsaved_dtm_pair;
	PROPERTYIDOFFSET numpages_pair;
	PROPERTYIDOFFSET appname_pair;
	PROPERTYIDOFFSET security_pair;
	PROPERTYIDOFFSET author_pair;

	string_prop_t 	 revnum;
	date_prop_t 	 lastprt;
	date_prop_t 	 create_dtm;
	date_prop_t 	 lastsaved_dtm;
	wval_prop_t 	 numpages;
	string_prop_t 	 appname;
	wval_prop_t 	 security;
	string_prop_t 	 author;
	}
	summaryPROPERTYSECTION;	
	

typedef struct
	{
	GUID FormatID;
	DWORD dwOffset;
	}
	FORMATIDOFFSET;
	
           
// quick and dirty summary stream. Not all properties are used           
typedef struct
	{
	WORD  wByteOrder;
	WORD  wFormat;
	DWORD dwOSVer;
	CLSID clsID;
	DWORD cSections;
	FORMATIDOFFSET section1_pair;
	summaryPROPERTYSECTION section1;
	}
	summaryPROPERTYSET;



#define NUM_USED_PROPS  8

/*
	The def for summary_info_t was moved to viewerob.h so that 
	every module doesn't have to pull in oleutils.h because of the
	summary_info_t variable that is in CViewer.
 */
//typedef struct
//	{
//	:
//	:
//	}
//	summary_info_t;


// structs for reading summary stream
typedef struct
	{
	WORD  wByteOrder;
	WORD  wFormat;
	DWORD dwOSVer;
	CLSID clsID;
	DWORD cSections;
	}
	summary_header_t;


typedef struct
	{
	DWORD cbSection;
	DWORD cProperties;
	}
	summary_section_t;
	

#pragma pack() // go back to default packing
	
// BKD:  I snipped the prototypes, since they're not used
// in the awd converter.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\property.h ===
//
// MAPI Properties
//
//
// Mail user generic properties =                       0x3a00 - 0x3aff

//  4000    57FF    Transport-defined envelope property
//  5800    5FFF    Transport-defined per-recipient property
//  6000    65FF    User-defined non-transmittable property
//  6600    67FF    Provider-defined internal non-transmittable property
//  6800    7BFF    Message class-defined content property
//  7C00    7FFF    Message class-defined non-transmittable
//                  property


// Transport-defined message envelope properties =      0x4000 - 0x57ff
// Transport-defined recipient properties =             0x5800 - 0x5fff
// User-defined non-transmittable message props =       0x6000 - 0x65ff
// Provider-defined internal non-transmittable props =  0x6600 - 0x67ff
// Message class-defined message content properties =   0x6800 - 0x7bff
// Message class-defined non-transmittable message
//  props =                                             0x7c00 - 0x7fff
// User-defined properties identified only by name,
//  through the property name to ID mapping facility
//  of the IMAPIProp interface =                        0x8000 - 0xfffe
//

#define TRANSPORT_ENVELOPE_BASE             0x4000
#define TRANSPORT_RECIP_BASE                0x5800
#define USER_NON_TRANSMIT_BASE              0x6000
#define PROVIDER_INTERNAL_NON_TRANSMIT_BASE 0x6600
#define MESSAGE_CLASS_CONTENT_BASE          0x6800
#define MESSAGE_CLASS_NON_TRANSMIT_BASE     0x7C00

#define EFAX_MESSAGE_BASE                   TRANSPORT_ENVELOPE_BASE + 0x500
#define EFAX_RECIPIENT_BASE                 TRANSPORT_RECIP_BASE + 0x100
#define EFAX_PR_OPTIONS_BASE                PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x100

#define EFAX_ADDR_TYPE                      "FAX"

//
// LOGON Properties
//
// Properties we store in the Profile.
//
// The following is used to access the properties in the logon array.
// If you add a property to the profile, you should increment this number!
#define MAX_LOGON_PROPERTIES                10

// Other logon properties:
//  PR_SENDER_NAME                          - in mapitags.h
//  PR_SENDER_EMAIL_ADDRESS                 - in mapitags.h (this file)
// Fax Product name
#define PR_FAX_PRODUCT_NAME                 PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x0))

// Active fax device name
#define PR_FAX_ACTIVE_MODEM_NAME            PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x1))

// If value is TRUE, work offline
#define PR_FAX_WORK_OFF_LINE                PROP_TAG(PT_BOOLEAN, (EFAX_PR_OPTIONS_BASE + 0x2))

// If true, you want to share the active fax device
#define PR_FAX_SHARE_DEVICE                 PROP_TAG(PT_BOOLEAN, (EFAX_PR_OPTIONS_BASE + 0x3))

// The share name
#define PR_FAX_SHARE_NAME                   PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x4))

// Sender Country code ID - used internally by fax config
#define PR_FAX_SENDER_COUNTRY_ID            PROP_TAG(PT_LONG,    (EFAX_PR_OPTIONS_BASE + 0x5))

// multi-value proerty to hold the names of the netfax devices the user added
#define PR_FAX_NETFAX_DEVICES               PROP_TAG(PT_MV_STRING8, (EFAX_PR_OPTIONS_BASE + 0x6))

// The share pathname on the sharing machine
#define PR_FAX_SHARE_PATHNAME               PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x7))

// Profile section version
#define PR_FAX_PROFILE_VERSION              PROP_TAG(PT_LONG, (EFAX_PR_OPTIONS_BASE + 0x8))

//
// Non-Transmittable message properties
//

#define PR_FAX_CHEAP_BEGIN_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1))
#define PR_FAX_CHEAP_BEGIN_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x2))
#define PR_FAX_CHEAP_END_HOUR               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x3))
#define PR_FAX_CHEAP_END_MINUTE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x4))
#define PR_FAX_NOT_EARLIER_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x5))
#define PR_FAX_NOT_EARLIER_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x6))
#define PR_FAX_NOT_EARLIER_DATE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x7))
#define PR_FAX_NUMBER_RETRIES               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x8))
#define PR_FAX_MINUTES_BETWEEN_RETRIES      PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x9))
// Should a cover page be sent with this message
#define PR_FAX_INCLUDE_COVER_PAGE           PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0xA))
#define PR_FAX_COVER_PAGE_BODY              PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xB))
#define PR_FAX_LOGO_STRING                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0xC))
// Should this message be send as text, in printed format, or best available
#define PR_FAX_DELIVERY_FORMAT              PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0xD))
#define PR_FAX_PRINT_ORIENTATION            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xE))
#define PR_FAX_PAPER_SIZE                   PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xF))
#define PR_FAX_IMAGE_QUALITY                PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x10))
// These should be set by transport so Linearizer can see them.
#define PR_FAX_SENDER_NAME                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x11))
#define PR_FAX_SENDER_EMAIL_ADDRESS         PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x12))
#define PR_FAX_LMI_CUSTOM_OPTION            PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x13))
#define PR_FAX_PREVIOUS_STATE               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x14))
#define PR_FAX_FAXJOB                       PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x15))
// The billing code to bill for the transmission of this message
#define PR_FAX_BILLING_CODE                 PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x16))
// Previous billing codes used
#define PR_FAX_PREV_BILLING_CODES           PROP_TAG(PT_MV_STRING8, (EFAX_MESSAGE_BASE + 0x17))
// Is Fax message to begin (or fully included, if short) on the cover page
#define PR_FAX_BGN_MSG_ON_COVER             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x18))
// Should the message be sent immediately, at cheap rates or at a specific time
#define PR_FAX_SEND_WHEN_TYPE               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x19))
// Absolute pathname of default coverpage file
#define PR_FAX_DEFAULT_COVER_PAGE           PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x1A))
// Maximum Time to wait for connection (seconds)
#define PR_FAX_MAX_TIME_TO_WAIT             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1B))
// Enable/Disable logging calls
#define PR_FAX_LOG_ENABLE                   PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1C))
// Number of calls to keep log of
#define PR_FAX_LOG_NUM_OF_CALLS             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1D))
// Display call progress
#define PR_FAX_DISPLAY_PROGRESS             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1E))
// Embed Linked objects before sending
#define PR_FAX_EMBED_LINKED_OBJECTS         PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1F))
// TAPI Location ID
#define PR_FAX_TAPI_LOC_ID                  PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x20))
// Must render ALL attachments before sending
#define PR_FAX_MUST_RENDER_ALL_ATTACH       PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x21))
// Enable per-recipient options
#define PR_FAX_ENABLE_RECIPIENT_OPTIONS     PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x22))
// Calling Card Name
#define PR_FAX_CALL_CARD_NAME               PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x24))
// Print to fax rba stream filename
#define PR_FAX_PRINT_TO_NAME                PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x25))
#define PR_FAX_SECURITY_SEND                PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x26))
#define PR_FAX_SECURITY_RECEIVED            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x27))
// RBA data property (print-to-fax)
#define PR_FAX_RBA_DATA                     PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x28))

// Poll retrieval
#define PR_POLL_RETRIEVE_SENDME             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x29))
#define PR_POLL_RETRIEVE_TITLE              PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x30))
#define PR_POLL_RETRIEVE_PASSWORD           PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x31))
#define PR_POLLTYPE                         PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x32))

// Poll server
#define PR_MESSAGE_TYPE                     PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x33))

// Digital signature for an attachment
#define PR_ATTACH_SIGNATURE                 PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x34))

// (print-to-fax # of pages)
#define PR_FAX_PRINT_TO_PAGES               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x35))

// On incoming message attachment, this contains image data requiring render conversion.
#define PR_FAX_IMAGE                        PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x36))

// Print a header line on the top of every G3 fax page (branding)
#define PR_FAX_PRINT_HEADER                 PROP_TAG(PT_BOOLEAN,  (EFAX_MESSAGE_BASE + 0x37))

// Billing code DWORD representation
#define PR_FAX_BILLING_CODE_DWORD           PROP_TAG(PT_LONG, (EFAX_MESSAGE_BASE + 0x38))


//
// Non-Transmittable mail-user properties
//
#define PR_FAX_RECIP_CAPABILITIES           PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x0))
// Name of the recipient to put on the cover page
#define PR_FAX_CP_NAME                      PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_W                    PROP_TAG(PT_UNICODE, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_A                    PROP_TAG(PT_STRING8, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_RECIP_INDEX                      PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x2))
#define PR_HOP_INDEX                        PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x3))

// Moved here from chicago\ui\faxab\faxab.h
#define PR_COUNTRY_ID                       PROP_TAG(PT_LONG,0x6607)
#define PR_AREA_CODE                        PROP_TAG(PT_STRING8,0x6608)
#define PR_TEL_NUMBER                       PROP_TAG(PT_STRING8,0x6609)
#define PR_MAILBOX                          PROP_TAG(PT_STRING8,0x660a)


#define ArrayIndex(PROP, ARRAY)(ARRAY)[(PROP_ID(PROP) - EFAX_XP_MESSAGE_BASE - 1)]


/**********************************************************************************

   Property Values Section

***********************************************************************************/

#define NUM_SENDER_PROPS            3       // How many sender ID properties?

// Send As
// PR_FAX_DELIVERY_FORMAT
#define SEND_BEST                  0
#define SEND_EDITABLE              1
#define SEND_PRINTED               2
#define DEFAULT_SEND_AS                SEND_BEST

// Send At
// PR_FAX_SEND_WHEN_TYPE
#define SEND_ASAP                  0
#define SEND_CHEAP                 1
#define SEND_AT_TIME               2
#define DEFAULT_SEND_AT            SEND_ASAP

// Paper Size
// PR_FAX_PAPER_SIZE
#define PAPER_US_LETTER            0       // US Letter page size
#define PAPER_US_LEGAL             1
#define PAPER_A4                   2
#define PAPER_B4                   3
#define PAPER_A3                   4
// "real" default page size is in a resource string depending on U.S. vs metric
#define DEFAULT_PAPER_SIZE      PAPER_US_LETTER     // Default page size

// Print Orientation
// PR_FAX_PRINT_ORIENTATION
#define PRINT_PORTRAIT             0       // Protrait printing
#define PRINT_LANDSCAPE            1
#define DEFAULT_PRINT_ORIENTATION  PRINT_PORTRAIT

// Image Quality
// PR_FAX_IMAGE_QUALITY
#define IMAGE_QUALITY_BEST         0
#define IMAGE_QUALITY_STANDARD     1
#define IMAGE_QUALITY_FINE         2
#define IMAGE_QUALITY_300DPI       3
#define IMAGE_QUALITY_400DPI       4
#define DEFAULT_IMAGE_QUALITY      IMAGE_QUALITY_BEST

// Speaker
// PR_FAX_SPEAKER_VOLUME
#define NUM_OF_SPEAKER_VOL_LEVELS  4   // Number of speaker volume levels
#define DEFAULT_SPEAKER_VOLUME     2   // Default speaker volume level
#define SPEAKER_ALWAYS_ON          2   // Speaker mode: always on
#define SPEAKER_ON_UNTIL_CONNECT   1   // speaker on unitl connected
#define SPEAKER_ALWAYS_OFF         0   // Speaker off
#define DEFAULT_SPEAKER_MODE       SPEAKER_ON_UNTIL_CONNECT   // Default speaker mode

// Answer
// PR_FAX_ANSWER_MODE
#define NUM_OF_RINGS                3
#define ANSWER_NO                  0
#define ANSWER_MANUAL               1
#define ANSWER_AUTO                 2
#define DEFAULT_ANSWER_MODE         ANSWER_NO

// Blind Dial
#define DEFAULT_BLIND_DIAL         3
// Comma Delay
#define DEFAULT_COMMA_DELAY            2
// Dial Tone Wait
#define DEFAULT_DIAL_TONE_WAIT     30
// Hangup Delay
#define DEFAULT_HANGUP_DELAY       60

// Poll retrieval
// PR_POLL_RETRIEVE_SENDME
#define SENDME_DEFAULT              0
#define SENDME_DOCUMENT             1

// PR_POLLTYPE
#define POLLTYPE_REQUEST            1
#define POLLTYPE_STORE              2

// Type of fax devices (line IDs)
// PR_FAX_ACTIVE_MODEM_TYPE
/*
   defined in ifaxdev\h\filet30.h

#define LINEID_NONE        (0x0)
#define LINEID_COMM_PORTNUM        (0x1)
#define LINEID_COMM_HANDLE     (0x2)
#define LINEID_TAPI_DEVICEID       (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID (0x4)
#define LINEID_NETFAX_DEVICE   (0x10)

*/

// Line ID (depends on the value in PR_FAX_ACTIVE_MODEM_TYPE)
// PR_FAX_ACTIVE_MODEM
#define    NO_MODEM                    0xffffffff  // To show no modem is selected

// PR_FAX_TAPI_LOC_ID
#define    NO_LOCATION                 0xffffffff  // No TAPI location

// Values for PR_FAX_FLAGS
// #define EFAX_FLAG_PEER_TO_PEER              ((ULONG)0x00000001)
#define EFAX_FLAG_UI_ALWAYS                 ((ULONG)0x00000002)
// #define EFAX_FLAG_LOG_EVENTS                ((ULONG)0x00000004)
#define EFAX_FLAG_SAVE_DATA                 ((ULONG)0x00000008)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\ifaxos.h ===
#ifndef _INC_IFAXOS
#define _INC_IFAXOS

#ifdef __cplusplus
extern "C" {
#endif

// add SHIP_BUILD from Win95fax retail builds
#ifndef DEBUG
#ifdef WIN32
#define SHIP_BUILD
#endif
#endif

// -------------------------- Include Files ------------------------------------

#ifdef IFBGPROC
// Remove appropriate parts of windows.h
// #define NOKERNEL
#ifndef WANTGDI
#define NOGDI
#endif
// #define  NOUSER
#define NOSOUND
// #define  NOCOMM
// #define  NODRIVERS
// #define  NOMINMAX
// #define  NOLOGERROR
// #define  NOPROFILER
// #define  NOMEMMGR
// #define  NOLFILEIO
// #define  NOOPENFILE
// #define  NORESOURCE
// #define  NOATOM
// #define  NOLANGUAGE
// #define  NOLSTRING
// #define  NODBCS
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#ifndef WANTGDI
#define NOGDIOBJ
#define NOBITMAP
#endif
#define NODRAWTEXT
#define NOTEXTMETRIC
#define NOSCALABLEFONT
#define NORASTEROPS
#define NOMETAFILE
#define NOSYSMETRICS
#define NOSYSTEMPARAMSINFO
// #define NOMSG
#define NOWINSTYLES
#define NOWINOFFSETS
// #define  NOSHOWWINDOW
#define NODEFERWINDOWPOS
#define NOVIRTUALKEYCODES
#define NOKEYSTATES
#define NOWH
#define NOMENUS
#define NOSCROLL
#define NOCLIPBOARD
#define NOICONS
#define NOMB
#define NOSYSCOMMANDS
#define NOMDI
#define NOCTLMGR
#define NOWINMESSAGES
#define NOHELP
#endif

// put strict type checking on ... and get rid of multiple define warnings
#ifndef STRICT
#define STRICT
#endif

#ifndef WINDRV
#   ifdef WIN32
#       define _INC_OLE
#   endif
#   include <windows.h>
#  ifdef   WIN32
#      include <windowsx.h>
#  endif
#endif

#ifdef WIN32
#define DECLSPEC_IMPORT __declspec(dllimport)
#endif

#ifndef WIN32
// Define WINBASE to avoid mapi including some duplicate definitions
#define _WINBASE_
#endif

//-------------------------- General Defines ---------------------

#ifndef WIN32
#define STATIC  static
#define CONST   const
#define CHAR    char
#define UCHAR   BYTE
#define INT     int

typedef short    SHORT;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef CHAR    *PCHAR;
typedef VOID    *PVOID;
#endif

typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;

#define CARRAIGE_RETURN 0x0D
#define LINEFEED 0x0A
#define BACKSPACE 0x08
#define CNULL   0x00

#ifndef WIN32
#ifndef MAKEWORD
#  define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif
#  define EXPORT_DLL
#  define IMPORT_DLL
#else
#  ifndef HTASK
#     define HTASK HANDLE
#  endif
#  define __export __declspec( dllexport )
#  define _export  __declspec( dllexport )
#  define IMPORT_DLL __declspec( dllimport )
#  define EXPORT_DLL __declspec( dllexport )
#endif

// --------------- RESOURCE management -------------------------------

// Always define this for now ...
#ifndef SHIP_BUILD
// #if defined(VALIDATE) || defined(DEBUGAPI) || defined(DEBUG)

/********
    @doc    EXTERNAL    RESOURCE IFAXOS

    @type   VOID |  RESOURCE_ALLOC_FLAGS | Lists the resource management options
            for OS resource accounting.

    @emem   RES_ALLOC_TASK  |  This flag indicates that the resource in question
            is being allocated on behalf of the current process. The resource
            should not be directly passed on to any other process context. It
            should be freed by this process before termination - else the kernel
            will free it when the process dies (if running in debug).
            Ownership automatically gets transferred between tasks when standard
            IPC methods like pipes are used to transfer resources like Buffers.

    @emem   RES_ALLOC_NONE  | This flag is used to allocate resources which should
            not be accounted to any system module. The calling party essentially
            undertakes full responsibility for freeing this object. This is mainly
            to be used for resource allocated on behalf of messages in the store
            since their ownership is transferred to the current process which has
            the message open.

    @emem   HINSTANCE_DLL   | If the allocated resource is to be assigned to the
            calling DLL, the hinstance of the DLL should be passed in as the value
            of the ResourceFlags Word. These resources will be freed (in the debug
            version) when the DLL terminates. They will not be assigned to any
            particular process context.

    @xref   <f IFBufAlloc> <f IFMemAlloc> <f CreateMutex> <f CreateEvent>
            <f IFPipeCreate> <f IFProcSetResFlags>
********/

#define RES_ALLOC_TASK  0x0000
#define RES_ALLOC_NONE  0x0001
#define RES_ALLOC_INTERNAL  0x0002
#define RES_ALLOC_CRITSEC  0x0003

#if defined(WFW) || defined(WIN32)

#define IFProcSetResFlags(wResFlags)  (0)

#else

extern EXPORT_DLL VOID WINAPI IFProcSetResFlags(WORD wResFlags);

#endif

#else

#define IFProcSetResFlags(p1) (0)

#endif

// --------------- ERROR Handling ------------------------------------

#include <errormod.h>

/********
    @doc    EXTERNAL    ERROR   IFAXOS

    @api    DWORD    | IFErrAssemble   | Forms an IFAX Error dword out of its components.

    @parm   BYTE    | bProcessID    | Identifies the process in whose context the error
            occured. Must be one of the predefined system process ID's - see <t SYSTEM_PROCESSES>
            for the list. This field does not need to be filled in until an error is
            propagated across a process boundary. If not being set to a valid PROCID, this
            should be initilialized to one of the following values:
            @flag  PROCID_WIN32 | if <p bModuleID> is set to MODID_WIN32.
            @flag  PROCID_NONE | for all other cases.

    @parm   BYTE    | bModuleID | Identifies the module reporting the error. MUST be
            one of the predefined system module ID's - see <t SYSTEM_MODULES> for the
            list.

    @parm   WORD    | wApiCode  | Identifies the API code for the error in the module indicated
            by <p bModuleID>. All Api codes should be defined in the file errormod.h. Api codes should
            be defined so that the low 6 bits are zero. This allows both the <p wApiCode> and the
            <p wErrorCode> to be logical OR'ed together and stored as a single word.

    @parm   WORD    | wErrorCode    | Identifies the error code. The format
            of this is module dependent. For uniformity however, it is highly
            encouraged that all IFAX modules use a standard format for this error word.
            This standard format reserves the first 6 bits for an error code,
            and the high 10 bits for an API identifier.

            If the IFAX format is being used, the <p wApiCode>
            parameter should be used to pass in the high 10 bits, and the <p wErrorCode> (This
            parameter!) should be used to pass in the 6 bit error code. Values upto ERR_FUNCTION_START
            are reserved for standard system errors - see <t SYSTEM_ERROR_VALUES> for the list.
            Error values should be positive and less than 64.

            Other modules like the filesystem conform completely to the Win32 Error space. These
            should set <p wErrorCode> to standard Win32 errors (use all 16 bits) and leave
            the <p wApiCode> as API_WIN32.

            Still others need to use all 16 bits in a custom manner - like the Printer Drivers.
            These *must* set the <p bModuleID> correctly so that the error can be interpreted
            appropriately. Standard processes like the UI have to understand these error codes,
            so only inbuilt system modules which they have knowledge about can use custom codes.
            These should set the wApiCode to API_NONE.

    @rdesc  Returns the DWORD representation for this error. This allows this to be directly
            passed in as input to <f SetLastError>.

    @ex     Example usage |

            SetLastError(IFErrAssemble(PROCID_NONE,MODID_IFKERNEL,API_IFK_POSTMESSAGE,ERR_INVALID_PARAM));

    @xref   <f IFErrGetModule> <f IFErrGetProcess> <f GetIFErrorErrcode> <f SetLastError>
            <f GetIFErrorApicode> <t SYSTEM_MODULES> <t SYSTEM_PROCESSES> <t SYSTEM_ERROR_VALUES>
            <f GetLastError> <f IFNVRamSetError> <f GetIFErrorCustomErrcode>
********/

#define IFErrAssemble(process,module,call,error) \
    MAKELONG((WORD)call|(WORD)error, MAKEWORD((BYTE)module, (BYTE)process))

/*********
    @doc    EXTERNAL ERROR  IFAXOS

    @api    BYTE    | IFErrGetModule  | Retrieves the module ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the module ID. This will be from the list specified in <t SYSTEM_MODULES>.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrSetModule>

    @api    BYTE    | IFErrGetProcess  | Retrieves the process ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the process ID. This will be from the list specified in <t SYSTEM_PROCESSES>.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrSetProcess>

    @api    WORD    | GetIFErrorErrcode  | Retrieves the error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. If less than ERR_FUNCTION_START, this is from the list
            in <t SYSTEM_ERROR_VALUES>.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorCustomErrcode  | Retrieves a custom 16 bit error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. This might be a Win32 error code if the module ID was
            MODID_WIN32, or a custom error code.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorApicode  | Retrieves the API code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the API code. API codes for all the system modules are documented in
            the file errormod.h

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES>

    @api    DWORD    | IFErrSetModule  | Sets the module ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. It's value is not changed by the call.

    @parm   BYTE    | bModule   | The module ID to be set from the list in <t SYSTEM_MODULES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrGetModule>

    @api    DWORD    | IFErrSetProcess  | Sets the Process ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. Its value is not changed by the call.

    @parm   BYTE    | bProcess   | The Process ID to be set from the list in <t SYSTEM_PROCESSES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrGetProcess>

********/
#define IFErrSetModule(errvar,module)  \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD((BYTE)module, HIBYTE(HIWORD((DWORD)errvar))))
#define IFErrSetProcess(errvar,process)    \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD(LOBYTE(HIWORD((DWORD)errvar)), (BYTE)process))
#define IFErrGetModule(errvar)    LOBYTE(HIWORD((DWORD)errvar))
#define IFErrGetProcess(errvar)   HIBYTE(HIWORD((DWORD)errvar))
#define GetIFErrorErrcode(errvar)   (LOWORD((DWORD)errvar) & 0x003F)
#define GetIFErrorApicode(errvar)   (LOWORD((DWORD)errvar) & 0xFFC0)
#define GetIFErrorCustomErrcode(errvar) LOWORD((DWORD)errvar)

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULES  | Identifiers for all the standard system modules.

    @emem   MODID_NONE          | Use this if you are not setting the module ID. DONT USE ZERO !!
    @emem   MODID_WIN32         | Set for modules returning standard Win32 system error codes
    @emem   MODID_BOSS          | ID = 1    Error in BOSS
    @emem   MODID_WINMODULE     | ID = 2    All windows modules including UER/GDI/KERNEL
    @emem   MODID_IFKERNEL      | ID = 3
    @emem   MODID_IFFILESYS     | ID = 4
    @emem   MODID_MSGSTORE      | ID = 5
    @emem   MODID_LINEARIZER    | ID = 6
    @emem   MODID_SECURITY      | ID = 7
    @emem   MODID_IFPRINT       | ID = 8    High level Printer Driver
    @emem   MODID_IFSCAN        | ID = 9    High level Scanner Driver
    @emem   MODID_IFSIPX        | ID = 10   SPX/IPX Stack
    @emem   MODID_REND_SERVER   | ID = 11   Rendering Server
    @emem   MODID_FORMAT_RES    | ID = 12   Format Resolution
    @emem   MODID_IFFILE        | ID = 13   IFFiles
    @emem   MODID_TEXTRENDERER  | ID = 14   Ascii Renderer
    @emem   MODID_DIGCOVPAGE    | ID = 15   Digital Coverpage
    @emem   MODID_AWBRANDER     | ID = 16   Fax Brander
    @emem   MODID_MSGSVR        | ID = 17   Message Server
    @emem   MODID_MSGHNDLR      | ID = 18  Per-Connection message handler
    @emem   MODID_MODEMDRV      | ID = 19  Modem driver
    @emem   MODID_PSIFAX       | ID = 20   PSI Fax protocol
    @emem   MODID_AWT30            | ID = 21   
    @emem   MODID_PSIFAXBG     | ID = 22
    @emem   MODID_AWNSF            | ID = 23
    @emem   MODID_FAXCODEC      | ID = 24
    @emem   MODID_MSGPUMP       | ID = 25
    @emem   MODID_AWREPORT      | ID = 26
    @emem   MODID_MSGSVRD		| ID = 27


    @emem   MODID_CUSTOM        | ID = 160  Beyond this are custom/installable modules

    @xref   <f IFErrAssemble> <f IFErrGetModule>
********/
// System Module IDs
#define MODID_WIN32         0
#define MODID_BOSS          1
#define MODID_WINMODULE     2
#define MODID_IFKERNEL      3
#define MODID_IFFILESYS     4
#define MODID_MSGSTORE      5
#define MODID_LINEARIZER    6
#define MODID_SECURITY      7
#define MODID_IFPRINT       8
#define MODID_IFSCAN        9
#define MODID_IFSIPX        10
#define MODID_REND_SERVER   11
#define MODID_FORMAT_RES    12
#define MODID_IFFILE        13
#define MODID_TEXTRENDERER  14
#define MODID_DIGCOVPAGE    15
#define MODID_AWBRANDER     16
#define MODID_MSGSVR        17
#define MODID_MSGHNDLR      18
#define MODID_MODEMDRV     19
#define MODID_PSIFAX       20
#define MODID_AWT30            21  
#define MODID_PSIFAXBG     22
#define MODID_AWNSF            23
#define MODID_FAXCODEC      24
#define MODID_MSGPUMP       25
#define MODID_AWREPORT      26
#define MODID_MSGSVRD		27

#define MAXMODID              26

#define MODID_NONE          159

// Special module ID's
#define MODID_CUSTOM        160

// Strings used in debug version for friendly display
#define SYSMODULESTRINGS   \
    { "Win32", "Boss", "Windows", "IFKernel", "FileSystem", "Msg Store", "Linearizer",    \
      "Security", "HLPrintDriver", "HLScanDriver", "IPX/SPX", "RendServer", \
      "Format Res", "IFFile", "AsciiRenderer","DigCovPage","AWBrander", \
      "Msg Server", "Msg Handler", "Modem Driver", "PSIFAX", "AWT30",  \
     "PSIFAXBG", "AWNSF", "Fax Codec", "Msg Pump" , "Awreport" \
    }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_PROCESSES  | Identifiers for all the standard system processes.

    @emem   PROCID_WIN32        | Used to initialize for Win32 modules.
    @emem   PROCID_NONE         | Used when process context does not need to be set.
    @emem   PROCID_MSGSCHED     | ID = 0x21
    @emem   PROCID_JOBPROCESS   | ID = 0x22
    @emem   PROCID_UI           | ID = 0x23
    @emem   PROCID_PRINTER      | ID = 0x24
    @emem   PROCID_SCANNER      | ID = 0x25
    @emem   PROCID_MSGSVR       | ID = 0x26
    @emem   PROCID_GRRENDER     | ID = 0x27
    @emem   PROCID_MSGHNDLR     | ID = 0x28
    @emem   PROCID_PARADEV 		| ID = 0x29
    @emem   PROCID_UIBGPROC 	| ID = 0x30

    @comm   All Process ID's need to have the 6th bit set to be compatible with the
            standard Win32 error definitions.

    @xref   <f IFErrAssemble> <f IFErrGetProcess>
********/
// System Process IDs
#define PROCID_WIN32           0x00
#define PROCID_NONE            0x20
#define PROCID_MSGSCHED        0x21
#define PROCID_JOBPROCESS      0x22
#define PROCID_UI              0x23
#define PROCID_PRINTER         0x24
#define PROCID_SCANNER         0x25
#define PROCID_MSGSVR          0x26
#define PROCID_GRRENDER        0x27
#define PROCID_MSGHNDLR        0x28
#define PROCID_PARADEV         0x29
#define PROCID_UIBGPROC		   0x30	

// Strings used in debug version for friendly display
#define MAXPROCID  11
#define SYSPROCESSSTRINGS       \
    {"None", "Msg Scheduler", "Job Process", "UI Process", "Printer", "Scanner", \
     "Msg Transport", "GR Renderer", "Msg Handler", "Para Dev", "UIBGProc"  }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

   @type   VOID | SYSTEM_ERROR_VALUES | This defines all the standard
           system error values.

   @emem   ERR_NOT_ENOUGH_MEM | Value = 0x0001 : Indicates an out of memory
           condition.

   @emem   ERR_INVALID_PARAM | Value = 0x0002 : Indicates that any one of
           the parameters passed to the function was invalid.

   @emem   ERR_FUNCTION_START | Value = 0x0010 : Any error value above this
           had been custom defined by the called function. If you need
           a custom error value, you can define it starting from this
           value.

   @xref   <f IFErrAssemble>
********/

// System Error values
#define ERR_NOT_ENOUGH_MEM  0x0001
#define ERR_INVALID_PARAM   0x0002
#define ERR_FUNCTION_START  0x0010

// Strings used in debug version for friendly display
#define SYSERRORSTRINGS \
    {"None", "Out Of Memory", "Invalid Param", "Unused", "Unused", "Unused",  \
    "Unused", "Unused", "Unused", "Unused", "Unused", "Unused", \
    "Unused", "Unused", "Unused", "Unused" }

// Functions

#if !defined(SHIP_BUILD) && !defined(WIN32)
VOID WINAPI RestoreLastError (DWORD dwErrVal);
#else
#define RestoreLastError(dw) SetLastError(dw)
#endif

#ifndef WIN32
VOID WINAPI SetLastError (DWORD dwErrVal);
DWORD WINAPI GetLastError (VOID);
#endif


//----------------------------- MESSAGING -------------------------

// Message type definitions  - below 0x0400 is reserved by windows,
// between 0x0400 and 0x0800 is reserved by the IFAX OS

#define IF_START        WM_USER+0x0300

#define IF_TASK_START   IF_START+0x0001
#define IF_TASK_END     IF_START+0x0020
#define IF_DEBUG_START  IF_START+0x0021
#define IF_DEBUG_END    IF_START+0x0040
#define IF_PIPES_START  IF_START+0x0041
#define IF_PIPES_END    IF_START+0x0060
#define IF_TIMER_START  IF_START+0x0081
#define IF_TIMER_END    IF_START+0x0090
#define IF_USER         IF_START+0x0400
//messages for printer and scanner
#define IF_SCANNER_START IF_START+0x0200
#define IF_SCANNER_END   IF_START+0x0220
//messages for the graphics renderer
#define    IF_GRRENDER_START   IF_START+0x0221
#define    IF_GRRENDER_END     IF_START+0x0230
//messages for the faxcodec renderer
#define    IF_FAXREND_START    IF_START+0x0231
#define    IF_FAXREND_END      IF_START+0x0235
//messages for the message pump
#define IF_MSGPUMP_START (IF_START+0x0250)
#define IF_MSGPUMP_END   (IF_START+0x029F)
//messages for devices
#define IF_DEVICE_START (IF_START+0x02B0)
#define IF_DEVICE_END   (IF_START+0x02CF)
// Message for UI Init
#define IF_UI_START        (IF_START+0x2F0)
#define IF_UI_END      (IF_START+0x300)
// Status
#define IF_STATUS_START    (IF_START+0x301)
#define IF_STATUS_END   (IF_START+0x310)
// Config
#define IF_CONFIG_START    (IF_START+0x311)
#define IF_CONFIG_END   (IF_START+0x320)
// Modem
#define IF_MODEM_START (IF_START+0x321)
#define IF_MODEM_END   (IF_START+0x325)
// PSIBG
#define IF_PSIBG_START (IF_START+0x330)
#define IF_PSIBG_END   (IF_START+0x339)
// PSIFAX
#define IF_PSIFAX_START    (IF_START+0x340)
#define IF_PSIFAX_END      (IF_START+0x349)
// MSGSVR
#define IF_MSGSVR_START  (IF_START+0x350)
#define IF_MSGSVR_END    (IF_START+0x369)
// OEM
#define IF_OEM_START    (IF_START+0x370)
#define IF_OEM_END      (IF_START+0x379)
// SOS
#define IF_SOS_START    (IF_START+0x380)
#define IF_SOS_END      (IF_START+0x38F)
// uiutil
#define IF_UU_START     (IF_START+0x390)
#define IF_UU_END       (IF_START+0x39F)
// parallel device
#define IF_PD_START     (IF_START+0x3A0)
#define IF_PD_END       (IF_START+0x3BF)
// RPC layer
#define IF_RPC_START     (IF_START+0x3C0)
#define IF_RPC_END       (IF_START+0x3CF)
//UIBGProc
#define IF_UIBGPROC_START (IF_START+0x3D0)
#define IF_UIBGPROC_END	  (IF_START+0x3DF)	
// services
#define IF_SERVICE_START  (IF_START+0x3E0)
#define IF_SERVICE_END    (IF_START+0x3EF)


/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_INIT_STATUS |   This message should be posted by all devices
           after initialization is complete to indicate success/failure.
           Typically, the device process will send an IF_INIT_STATUS
          message for every device it initializes and one for its own
          initilization. This message should be posted to the UISHELL
          process. Use <f IFProcGetInfo> to obtain the appropriate window handle.

   @parm   WPARAM  | wParam    | 16 bit device error.
   @parm   LPARAM  | lParam    | Is formed as MAKELPARAM(MAKEWORD
       (ucInitStatus,ucMinorDevId),MAKEWORD(ucMajorDevId,ucProcId))    
   @flag   INIT_NO_ERROR   |   There was no error.
   @flag   INIT_FATAL_ERROR|   There was a fatal error. System should reboot.
   @flag   INIT_WARNING_ERROR  | There were some errors, but the system doesnt need
           to reboot.

   @parm   LPARAM  | lParam    | Contains a standard IFAX Error code. See
           <f IFErrAssemble> for details.

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/
#define INIT_NO_ERROR      0x00
#define INIT_FATAL_ERROR   0x01
#define INIT_WARNING_ERROR 0x02

#define IF_INIT_STATUS     IF_UI_START
/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS
   @msg    IF_DEVREINIT |   This message will be posted by the uishell to
           device process that handle user errors if the initialization
           fails due to user errors.

   @parm   WPARAM  | wParam    | MAKEWORD(ucMinorDevId,ucMajorDevId)

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/

#define    IF_DEVREINIT    IF_UI_START+1

// Functions --------
BOOL WINAPI BroadcastMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI BroadcastMessageEx (UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dispatch message for BG Procs
/********
   @doc    EXTERNAL    MESSAGE     MACROS  IFAXOS

   @api    VOID    |   DispatchMessage | Dispatches a message to your
           windows procedure.

   @parm   LPMSG   | lpMsg |   Ptr to a message struct which is to be
           dispatched. This parameter *must* be &msg for all IFAX
           background processes - i.e you must have a declared variable
           called "msg" into which you have previsouly retrieved the
           message using <f GetMessage>.

   @comm   This function dispatches a message to your windows procedure.
           For foreground processes this works exactly the way the standard
           Windows DispatchMessage works. For background processes
           (which dont have any explicit windows) the message is sent to
           a procedure called BGWindowProc. You *must* have a callback
           defined as this - see BGWindowProc for details.

   @cb     LRESULT  BGCALLBACK |   BGWindowProc    | This is the window procedure
           for all IFAX background processes. The functions *must* be called
           by this exact name. This callback is not relevant for foreground
           processes.

   @parm   HWND    | hwnd  | contains the handle of the window to which the
           message is being dispatched. For Background processes this will always
           be the same as that returned from <f IFProcGetInfo>.

   @parm   UINT    | message | the message id

   @parm   WPARAM  | wParam | the first parameter associated with the message

   @parm   LPARAM  | lParam    | The second parameter associated with the message

   @rdesc  The return value depends on the message being processed.

   @comm   A protoype for this is already declared in ifaxos.h. You should
           process all your messages inside this window procedure. Your
           main application loop should thus look like

           while (GetMessage(&msg,NULL,0,0))
           {
               DispatchMessage(&msg);
           }
           return;

           You should *not* export this procedure in your .def file.

   @xref   <f GetMessage>
********/

#ifdef IFBGPROC
#define DispatchMessage(pmsg)   BGWindowProc((pmsg)->hwnd,(pmsg)->message,(pmsg)->wParam,(pmsg)->lParam)
#define BGCALLBACK PASCAL
LRESULT BGCALLBACK BGWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

//----------------------------- TASK MANAGEMENT--------------------
/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   ENTER_INT_CRIT_SECTION  | Macro to enter
           an interrupt critical section.

   @comm   This is an inline assembly macro which turns interrupts
           off. Needless to say, this must be used with extreme
           caution. There must be a matching call to
           <f EXIT_INT_CRIT_SECTION>. Nested pairs of calls
           to these are permitted as long as they are not within the
          same invocation of the function. The function relies on
          being able to save the previous state of the flags in a
          unique local variable called __wIntFlags.
           This might affect some optimization options in your
           function due to being inline assembly. You might want to
           declare a local function which calls this macro internally.
           This way you can get global optimzations in the calling
           functions.

   @xref   <f EXIT_INT_CRIT_SECTION>  <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/


// Macros --------
#define ENTER_INT_CRIT_SECTION  \
   {   \
   _asm pushf  \
   _asm cli    \
   _asm pop __wIntFlags    \
   }

/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   EXIT_INT_CRIT_SECTION   | Macro to exit
           an interrupt critical section.

   @comm   This is an inline assembly macro which sets the interrupt
           flag state back to its state before the last call to
           <f ENTER_INT_CRIT_SECTION>. This function relies    on the
          appropriate flags to have been saved in a local variable
          with the name __wIntFlags.

   @xref   <f ENTER_INT_CRIT_SECTION> <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/

// defined this way so that it works with windows enhanced mode
// refer guide to programming pg 14-15
#define EXIT_INT_CRIT_SECTION   \
   {   \
   _asm mov ax, __wIntFlags    \
   _asm test ah,2      \
   _asm jz $+3     \
   _asm sti            \
   _asm NOP            \
   }

/********
    @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | PRIORITY DEFINES  | System defined priority levels
    @emem   PROC_PRIORITY_CRITICALRT | This should be used very sparingly
            for tasks which have very critical real time constraints (less
            than 200ms). These processes should typically be very low bandwidth
            since they can easily starve other processes. 
    @emem   PROC_PRIORITY_HIGHRT | Tasks with latency requirements of less than
            a second. Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_MEDRT | Tasks with latency requirements of 1-3 secs.
            Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_LOWRT | Tasks with latencies of 3-30secs. Should not
            be high bandwidth. 
    @emem   PROC_PRIORITY_DEFAULT | The default priority tasks start out at. These
            processes have none or very low real time requirements. They should
            in general not have high bandwidth. 
    @emem   PROC_PRIORITY_NONRT_USERVISIBLE | Non real time tasks which have visibility
            at the user level. Can be high bandwidth. An example on a fax machine is
            a copy job.
    @emem   PROC_PRIORITY_NONRT_USERHIDDEN | Non real time tasks which have very little
            visibility at the user level. Examples on a fax machine are local jobs 
            not involving devices. Can be high bandwidth.
    @comm   Processes should be VERY careful in setting their priorities. The way the 
            current scheduling works it is very easy to cause starvation of low 
            priority processes. In particular, processes which are "high bandwidth" - ie
            those which can consume huge amounts of CPU time if given, should be very
            careful - and should in general be at a priority level lower than the default.
            Processes higher than the default should have some sontrols on how much cpu
            time they can use up. On the fax machine, such controls are mostly in the form
            of device througputs - like the phone line.
    @xref   <f IFProcSetPriority> <f IFProcGetPriority>
********/
#define PROC_PRIORITY_MIN               31
#define PROC_PRIORITY_MAX               1
#define PROC_PRIORITY_CRITICALRT        3
#define PROC_PRIORITY_HIGHRT            6
#define PROC_PRIORITY_MEDRT             9
#define PROC_PRIORITY_LOWRT             12
#define PROC_PRIORITY_DEFAULT           15
#define PROC_PRIORITY_NONRT_USERVISIBLE   18
#define PROC_PRIORITY_NONRT_USERHIDDEN    21

#define UAE_BOX                 0
#define NO_UAE_BOX              1

///// Specific priorities used by standard processes 	   ////
//
// We want the following relations to hold
// 	PSIFAXBG > everything else, cause it's low-latency, low-bandwidth
//	ModemJob related (med bandwidth) > all other high/med bandwith jobs
//  DeviceJob related (high bandwidth, NO latency reqs) < all other jobs except Spool jobs
//  SpoolJobs (high bandwidth NO latency reqs, not user-visible) < everything
//  MSCHED is as high as ModemJob prio when it is on critical path, otherwise
//		it stays at default. Higher than Dev & Spool jobs, lower than all else
//  COMMSRV (pretty low latency reqs, high bandwidth) is slightly higher than
//		default (Higher than MSCHED & Dev/Spool jobs, lower than modem jobs)
//  RPCHNDLR (pretty lax latency reqs, high bandwidth) dynamic
//		Same prio as MSCHED while working, same as COMMSRV during accept
//  MSGSVR & RPCSRV (lowish latency reqs, very low bandwidth) roundrobin
//		with ModemJob, higher than all else
//  REPORT bg proc slightly lower than default.

// PSIFAXBG prio is highest
#define PRIO_PSIFAXBG_ACTIVE    PROC_PRIORITY_CRITICALRT
#define PRIO_PSIFAXBG_IDLE      PROC_PRIORITY_DEFAULT
// ModemJob is 2nd highest
#define PRIO_MODEMJOB           PROC_PRIORITY_MEDRT
// Spooljob is LOWEST, Device jobs are second lowest 
#define PRIO_SPOOLJOB           PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_DEVICEJOB          PROC_PRIORITY_NONRT_USERVISIBLE
// PSINET jobs are same prio as SPOOL jobs
#define PRIO_PSINETJOB          PRIO_SPOOLJOB
// MSCHED's prio when it is NOT on a MODEMJOB critical path
#define PRIO_MSCHED         	PROC_PRIORITY_DEFAULT
// COMMSRV is between MODEMJOB & MSCHED
#define PRIO_COMMSRV            PROC_PRIORITY_LOWRT
// RPCHNDLR is same as MSCHED while working
#define PRIO_RPCHNDLR_ACCEPT    PROC_PRIORITY_LOWRT
#define PRIO_RPCHNDLR_WORKING   PROC_PRIORITY_DEFAULT
// RPCSRV is same as MODEMJOB. It should NOT consume much CPU at this level!
#define PRIO_RPCSRV             PROC_PRIORITY_MEDRT
// MSGSVR is same as MODEMJOB, except when processing recovery msgs
#define PRIO_MSGSVR_WAITMSG     PROC_PRIORITY_MEDRT
#define PRIO_MSGSVR_RECOVERY    PROC_PRIORITY_NONRT_USERVISIBLE
// Report process is real low prio when doing background info assimilation
// slightly higher when doing work on user request.
#define PRIO_UIBGPROC			PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_UIBGPROC_USERREQUEST PROC_PRIORITY_NONRT_USERVISIBLE

/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_QUIT |   This is the message which forces <f GetMessage>
           to return FALSE causing the process to exit its main message
           processing loop and terminate. Typically a process should
           post itself this message in response to a <m IF_EXIT> message.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_EXIT>

   @msg    IF_EXIT | This message is sent to a process to request it
           to terminate. An application should clean up any resources
           it has allocated and then post itself a <m IF_QUIT> message
           directly.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_QUIT>
********/

// Messages
#define IF_QUIT     IF_TASK_START
#define IF_EXIT     IF_TASK_START+1

// Functions -----------
#ifndef WIN32
HTASK   WINAPI GetWindowTask(HWND hwnd);
#ifndef SHIP_BUILD
DWORD   WINAPI IFProcProfile(HTASK hTask, BOOL fStart);
#else
#define IFProcProfile(HTASK,FSTART) (0)
#endif
#else
// Remove calls to Profile ..
#define IFProcProfile(x,y)    (DWORD)(0)
#endif

HTASK WINAPI IFProcCreate (LPSTR lpszAppName, UINT fuCmdShow);
VOID WINAPI IFProcTerminate (HTASK hTask, WORD wFlags);
VOID WINAPI IFProcEnterCritSec(VOID);
VOID WINAPI IFProcExitCritSec(VOID);
BOOL WINAPI IFProcChangeToFG(VOID);
BOOL WINAPI IFProcChangeToBG(VOID);
HWND    WINAPI IFProcGetInfo (HTASK FAR *lphTask, LPSTR lpszModule, HINSTANCE FAR *lphInst);
BOOL    WINAPI IFProcRegisterWindow (HWND hwnd);
WORD    WINAPI IFProcGetPriority (HTASK hTask);
BOOL    WINAPI IFProcSetPriority (HTASK hTask, WORD wPriority);

#ifndef NOBUFFERS
//----------------------------- BUFFERS -------------------------

// Moved BUFFER typedef and standard meta-data values to buffers.h! -RajeevD
#include <buffers.h>

#ifdef VALIDATE
#define BUF_SENTINELPOS 30
#endif

// Error values
#define ERR_DATA_SMALL      ERR_FUNCTION_START

// Functions
extern EXPORT_DLL LPBUFFER WINAPI IFBufAlloc (LONG lBufSize);
extern EXPORT_DLL BOOL WINAPI IFBufFree (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufMakeWritable (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufShare (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufSplit (LPBUFFER lpbf, LPBYTE lpb);


//----------------------------- PIPES ----------------------------

#ifndef WIN32

// types
typedef  struct _PIPE NEAR *HPIPE;

// Parameter
#define IFPIPE_READ_MODE    0x0001
#define IFPIPE_WRITE_MODE   0x0002
#define REQREAD_REMOVE_DATA 0x0003
#define REQREAD_NOREMOVE_DATA   0x0004

// Error values
#define ERR_TOO_MANY_OPENS          ERR_FUNCTION_START
#define ERR_TOO_MANY_PENDING_WRITES ERR_FUNCTION_START+1
#define ERR_PIPE_STILL_OPEN         ERR_FUNCTION_START+2

/********
   @doc    EXTERNAL    MESSAGES    IFPIPES IFAXOS

   @msg    IF_PIPE_DATA_WRITTEN | This message is sent to notify a process
           that a previous write request using <f IFPipeReqWrite> has
           been successfully concluded. On reciept of this message the
           process can issue another write request on the same pipe.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <f IFPipeReqWrite>

   @msg    IF_PIPE_DATA_ARRIVED | This message is sent to a process which
           previsouly issued a read request to a pipe, intimating it that
           the buffer it requested is now available.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | Contains a far ptr to a <t BUFFER> structure
           which has the requested data. On receipt of this message the process
           can issue another read request on the same pipe.

   @rdesc  none

   @xref   <f IFPipeReqRead>
********/

// Messages
#define IF_PIPE_DATA_WRITTEN    IF_PIPES_START
#define IF_PIPE_DATA_ARRIVED    IF_PIPES_START+1

// Functions
HPIPE WINAPI IFPipeCreate (WORD wSize);
BOOL WINAPI IFPipeDelete (HPIPE hpipe);
BOOL WINAPI IFPipeOpen (HPIPE hPipe, HWND hwnd, WORD wMode, WPARAM wContext);
BOOL WINAPI IFPipeClose (HPIPE hPipe, WORD wMode);
BOOL WINAPI IFPipeReqRead (HPIPE hPipe, WORD fwRemove);
BOOL WINAPI IFPipeReqWrite (HPIPE hPipe, LPBUFFER lpbf);
BOOL WINAPI IFPipeGetInfo (HPIPE hPipe, LPWORD lpwSize, LPWORD lpwcBufs);

#else // !WIN32

DECLARE_HANDLE32(HPIPE);

#endif // !WIN32

#endif // NOBUFFERS

//----------------------------- DEBUG SERVICES -------------------------

// Debug typedefs. These dont do any harm to anyone. Define them if there is
// anyone who might need them.

#if defined(DEBUG) || defined(IFKINTERNAL)

/********
   @doc    EXTERNAL    DATATYPES   DEBUG   IFAXOS

   @types  DBGPARAM    |   Structure containing the debug
           settings for any module in the system.

   @field  CHAR[32]    |   lpszName    | Specifies the name of the module.
           This is how your module will appear in the IFAX controller. Must
           be less than 32 characters long, and NULL terminated.

   @field  HWND    |   hwnd    | Specifies the primary window handle associated with
           this module IF the module is a process. For DLL's this value should
           always be NULL. Background processes should set it to their own ID using
           <f IFProcGetInfo> and <f GetCurrentTask> at initialization time.
           Foreground processes should set it to the window handle of their client
           window.

   @field  CHAR[16][32]    | rglpszZones   |   Stores a list of 16 strings
           which describe the zones associated with the lower 16 bits of
           zone mask. The module must decide and define its own zones for these
           bits - any bits not used should be left as "Not Used". These strings
           will be displayed by the IFAX controller to assist users in choosing
           the zones to be set for your module. Each string should not be more
           than 32 characters long, and should be NULL terminated.

   @field  ULONG   |   ulZoneMask  |   This is the mask which stores the
           current zone settings for the module. The IFAX controller will
           set this field according to what the user specifies. This field
           should be initialized to something which makes sense for your module
           - as that will be the default till the user changes it.

   @comm   This structure should be passed to <f IFDbgSetParams> at
           intialization time to enable the user to control the trace options.

           **VERY IMPORTANT NOTE** This structure MUST be declared with a
           variable  name of dpCurSettings to allow the system zones to
           function correctly.

   @tagname _DBGPARAM

   @xref   <f IFDbgSetParams>

********/

typedef struct _DBGPARAM {
   CHAR    lpszName[32];           // name of module
   HWND    hwnd;                   // Primary window Handle if task, NULL otherwise
   CHAR    rglpszZones[16][32];    // names of zones for first 16 bits
   ULONG   ulZoneMask;             // Zone Mask
}   DBGPARAM, FAR *LPDBGPARAM;

// Debug functions
BOOL WINAPI IFDbgOut (LPSTR lpszStatus);
WORD WINAPI IFDbgIn (LPSTR lpszPrompt, LPSTR lpszReply, WORD wBufSize);
extern EXPORT_DLL VOID WINAPI IFDbgSetParams (LPDBGPARAM lpdpParam, BOOL fEntry);
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

// Encourage people to use the correct variable
extern EXPORT_DLL DBGPARAM dpCurSettings;


// Special UI communication stuff

// Functions
DWORD WINAPI DebugUIMessage (UINT wMsg, WPARAM wParam, DWORD lParam);

// Messages to the UI proc
#define IF_DISP_STRING  IF_DEBUG_START
#define IF_INP_REQUEST  IF_DEBUG_START+1
#define IF_NEW_SETTING  IF_DEBUG_START+2
#define IF_DEL_SETTING  IF_DEBUG_START+3
#define IF_NEW_TASK     IF_DEBUG_START+4
#define IF_DEL_TASK     IF_DEBUG_START+5
#define IF_FILELOG_POLL IF_DEBUG_START+6

// Messages from the UI proc
#define REGISTER_UI_TASK    1
#define SET_LOG_MODE       2
#define DEBUG_OUT_DONE      3
#define DEBUG_IN_DONE       4
#define DEREGISTER_UI_TASK  5


#endif

// Debug Macros. These should be defined only if the module is being compiled
// in debug

#ifdef DEBUG

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGMSG    |   Prints a trace message on the debug
           console depending on enable flags set by the user.

   @parm   <lt>c_expression<gt>    |   cond    |   Boolean condition which is
           evaluated to decide whether or not to print the message.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @rdesc  TRUE if the message is printed, and FALSE if it is not.

   @comm   The condition should consist of a boolean expression testing whether
           the relevant zones are on or off.  Each module has a current zone
           mask which identifies which of the possible 32 zones is currently on.
           The top 16 bits of these are reserved for use for system defined
           zones - like ZONE_FUNC_ENTRY which is defined as

           #define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)

            Modules should take care to see
           that they print out trace messages which are meaningful and conform
           to some pattern - remember that other people than you have to see
           and make sense of your messages. The general format I have been
           following is :

           <lt>Task ID<gt> :
           <lt>ModuleName<gt>:<lt>SubModule<gt>:<lt>Function<gt>:<lt>msg<gt>

           The task ID is useful to sort out the output of multiple tasks
           running in the system.  The example call above yields this kind of
           output.

           The various predefined system zones are:
               ZONE_FUNC_ENTRY : To be used for all function entry and exit
                   messages. By convention, the parameters should be printed
                   on entry, and the return value should be printed on exit.
                   Any values printed in hexadecimal should be preceded by a 0x
               ZONE_INT_FUNC : To be used for any other traces at interesting
                   points within a function.

           All trace messages are disabled in a non debug build.

   @ex     Example Definition & Use |

           #define ZONE_CUSTOM (0x00000001&dpCurSettings.ulZoneMask)

           DEBUGMSG (ZONE_FUNC_ENTRY && ZONE_CUSTOM,
                       ("0x%04X:IFK:Buffers:GenericFunction:Entry\r\n",
                       GetCurrentTask()));

           This will print a trace message only if the user has turned the
           function entry zone and the custom zone on.

   @xref   <f IFDbgPrintf>
********/

#define DEBUGMSG(cond,printf_exp)   
//#define DEBUGMSG(cond,printf_exp)   \
//  ((cond)?(IFDbgPrintf printf_exp),1:0)

// Standard Debug zones
#define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)
#define ZONE_INT_FUNC   (0x00020000&dpCurSettings.ulZoneMask)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   ERRORMSG    |   Prints an error message on the debug
           console.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display Error messages.

   @ex     Example Definition & Use |

           ERRORMSG (("0x%04X:JOB Failed !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           ERROR: Job Process: 0x2346: JOB Failed !!

   @xref   <f IFDbgPrintf>
********/
#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define ERRORMSG(printf_exp)   \
   (IFDbgPrintf("ERROR:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   RETAILMSG    |   Prints a message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           RETAILMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf>
********/
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   WARNINGMSG    |   Prints a warning message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           WARNINGMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           WARNING: 0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf> <f ERRORMSG>
********/
#ifndef WIN32
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define WARNINGMSG(printf_exp)   \
   (IFDbgPrintf("WARNING:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif


/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGCHK    |   Macro implementing an assert.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be checked.

   @rdesc  Returns TRUE if the expression was non zero, and FALSE if not.

   @comm   This is a macro which implements functionality similar to the assert
           statement in C.  The expression argument is evaluated, and no action
           is taken if it evaluates to true. If false, a debug message is
           printed out  giving the  File name and line number where the check
           failed, along with the module name which was registered
           in the <t DBGPARAM> structure. Because of this, you *must* register
           your debug settings using <f IFDbgSetParams> before you can use the 
           DEBUGCHK macro.  After this the function <f IFDbgCheck> is called
           to generate an assert.

           This statement disappears when the DEBUG option is turned off.

    @xref   <f IFDbgCheck>           
********/

#define BG_CHK(exp)    \
   ((exp)?1:(              \
       IFDbgPrintf ("DEBUGCHK failed in file %s at line %d \r\n",  \
                 (LPSTR) __FILE__ , __LINE__ ), 1  \
            ))

#ifndef DEBUGCHK_UNSAFE_IN_WFWBG

#define DBGCHK(module,exp) 
/*
#define DBGCHK(module,exp) \
   ((exp)?1:(          \
       IFDbgPrintf ("%s: DEBUGCHK failed in file %s at line %d \r\n", \
                 (LPSTR) module, (LPSTR) __FILE__ , __LINE__ ),    \
       IFDbgCheck() \
            ))*/

#define DEBUGCHK(exp) DBGCHK(dpCurSettings.lpszName, exp)

#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGSTMT   |   Evaluates the expression in debug mode.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be evaluated.

   @rdesc  Returns the value returned by the expression.

   @comm   This macro is provided for convenience and code readability purposes
           to replace a construct of the form

               #ifdef DEBUG
               exp;
               #endif

           It evaluates to zero in a non debug build.

********/

#define DEBUGSTMT(exp) exp

#else // NOT DEBUG

// Let debugmsg's through currently
#ifndef SHIP_BUILD
//#ifndef FOOBAR

// Non DEBUG MODE
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)
#else  //Win32 -- NO MESSAGES OF ANY SORT IN NON-DEBUG WIN32

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)
 
#endif


#else

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif

// These are to macro out all debug stuff in retail/ship builds
#define DEBUGMSG(cond,expr)  (0)
#define DBGCHK(module,exp) (0)
#define DEBUGCHK(exp) (0)
#define BG_CHK(exp) (0)
#define DEBUGSTMT(exp) (0)

// Macros for direct function calls made ..
#ifndef IFKINTERNAL
#define IFDbgOut(lpszStatus) (0)
#define IFDbgIn(lpszPrompt,lpszReply,wBufSize) (0)
#define IFDbgSetParams(lpdpParam,fEntry) (0)
#define DebugUIMessage(wMsg,wParam,lParam) (0)
#endif

#endif

/********
   @doc    EXTERNAL    IFAXOS    MACROS

   @api    BOOL    |   UIEVENT |   Prints a status string in the UI

   @parm   LPSTR | string |  String to be printed.

   @comm   This macro is provided in both the retail & debug builds to
            allow some limited set of status strings to be printed in
            the UI. You must format a string yourself - you can
            use wsprintf() to create a complex one if desired. The
            maximum string length allowed is 64 bytes.
********/
#define IF_SYS_EVENT     IF_UI_START+1
// UI Event messages
#define UIEVENT(string)   \
{       \
    CHAR    szUIShell[] = "UISHELL";  \
    DEBUGCHK(lstrlen(string) < 64); \
    PostMessage (IFProcGetInfo(NULL, szUIShell, NULL), IF_SYS_EVENT,   \
                 NULL, MAKELPARAM(GlobalAddAtom(string),0));    \
}

// --------------- Synchronization services --------------------------------------
// Dont provide any for win32.
#ifndef WIN32

typedef  struct _SYNC NEAR *HSYNC;

// Error returns
#define ERR_MUTEX_NOT_FREE  ERR_FUNCTION_START
#define ERR_EVENT_NOT_FREE  ERR_FUNCTION_START+1
#define ERR_TOO_MANY_EVENTWAITS ERR_FUNCTION_START+2

// generic functions
DWORD WINAPI WaitForSingleObject (HSYNC hsc, DWORD dwTime);

// Mutex functions
HSYNC WINAPI CreateMutex (LPVOID lpvAttribs, BOOL fInitial,LPSTR lpszName);
BOOL WINAPI ReleaseMutex (HSYNC hsc);

// Event Functions
HSYNC   WINAPI  CreateEvent (LPVOID lpvAttribs, BOOL bManualReset,
                            BOOL bInitialState, LPSTR lpszName);

BOOL    WINAPI  SetEvent (HSYNC hsc);
BOOL    WINAPI  ResetEvent (HSYNC hsc);
BOOL WINAPI FreeSyncObject (HSYNC hsc);
BOOL WINAPI  GetSetEventParam (HSYNC hsc, BOOL fSetParam, LPDWORD lpdwParam);

#else // !WIN32

DECLARE_HANDLE32(HSYNC);

#endif // !WIN32

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULE_NAMES  | Strings to be passed to IFProcGetInfo to get handles to standard IFAX modules

    @emem   MODNAME_UISHELL  | UI Shell
    @emem   MODNAME_MSCHED   | Message Scheduler
    @emem   MODNAME_MSGSVR   | Message Server a.k.a. Message Transport

    @xref   <f IFProcGetInfo>
********/

// IFAX Module names
#define MODNAME_UISHELL        "UISHELL"
#define MODNAME_MSCHED     "MSCHED"
#define MODNAME_MSGSVR     "MSGSVR"


// --------------- Timer Services -----------------------------------------

#ifndef WIN32

/********
   @doc    EXTERNAL    IFAXOS    MESSAGES    TIMER

   @msg    IF_TIMER | This message is sent to notify a process
           of the expiration of a timer set using <f IFTimerSet>.

   @parm   WPARAM  | wParam    | Contains the timer id set int he
           <f IFTimerSet> call.

   @parm   LPARAM  | lParam    | Contains the lParam passed into
           the IFTimerSet call.

   @rdesc  none

   @xref   <f IFTimerSet>
********/

// messages
#define IF_TIMER    IF_TIMER_START

// flags
#define TIME_ONESHOT    0
#define TIME_PERIODIC   1

// functions
VOID WINAPI IFProcSleep (WORD wSleepPeriod);
WORD WINAPI IFTimerSet (HWND hwnd, WORD idTimer, WORD wTimeout,
                         TIMERPROC tmprc, WORD wFlags, LPARAM lContext);
BOOL WINAPI    IFTimerKill (HWND hwnd, UINT idTimer);

#endif

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc> <f IFBufAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

//
#define RAW_DATA_SIZE       -3      // 8Kb

// Special size for modem ECM frame
#define BYTE_265_SIZE       -4      // 265 bytes
#define BYTE_265_ACTUALSIZE 265

// Number of sizes
#define MAX_POOL_INDEX  -4          // For parameter validation

// Not available yet!
#define BAND_BUFFER_SIZE    30720      // 64Kb

// Flag to force global alloc. Uses a windows flag which is ignored/defunct in
// the 3.1 kernel (and the boss kernel)
#define IFMEM_USEGLOBALALLOC GMEM_NOT_BANKED

// Functions
extern EXPORT_DLL LPVOID  WINAPI  IFMemAlloc (UINT fuAlloc, LONG lAllocSize,
                                  LPWORD lpwActualSize);
extern EXPORT_DLL BOOL WINAPI IFMemFree (LPVOID lpvMem);


/********
    @doc    EXTERNAL   IFAXOS

    @api    HIPCMEM | IFMemGetIPCHandle | Returns an opaque 32 bit handle
            which is portable across process contexts.

    @parm   LPVOID  | lpvMem    | A ptr to global memory allocated using
            <f IFMemAlloc>.

    @rdesc  Opaque 32 bit none zero handle if succesfull. 0 if the memory
            ptr passed in is invalid.

    @comm   This function should be used by any DLL or process before trying
            to pass this memory to another process context. Only handles
            returned by this API should cross context boundaries, and the
            receiving context should call <f IFMemMapIPCHandle> to get back
            a valid memory ptr in its new context.

            This applies even for DLL's which might allocate a piece of
            global memory and access it in different process contexts. They
            should use these functions to map them so that they are portable.

            For Win16/IFAX implementations, this is essentially a NOP.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>

    @type   DWORD | HIPCMEM | Opaque 32 bit handle to global memory block.

    @xref   <f IFMemMapIPCHandle> <f IFMemGetIPCHandle>
*********/
typedef DWORD HIPCMEM;
#define IFMemGetIPCHandle(par1) ((HIPCMEM)par1)

/********
    @doc    EXTERNAL   IFAXOS

    @api    DWORD | IFMemMapIPCHandle | Maps a piece of memory into the
            current tasks address space.

    @parm   HIPCMEM | hMemHandle    | A memory handle returned from a call
            to <f IFMemGetIPCHandle> previously.

    @rdesc  Valid ptr to memory in the context of the calling process if
            succesful. NULL if it fails.

    @comm   See comments in <f IFMemMapIPCHandle>.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>
*********/
#define IFMemMapIPCHandle(par1) ((LPVOID)par1)


// --------------- Time API's ----------------------------------------------

/********
    @doc    EXTERNAL IFAXOS SRVRDLL

    @types  SYSTEMTIME  | Structure describing the time in terms of roman
            calendar.

    @field  WORD    | wYear | The year
    @field  WORD    | wMonth | The month from 1-12
    @field  WORD    | wDayOfWeek | Day of week with Sunday = 0
    @field  WORD    | wDay | The day of the month, from 1-31
    @field  WORD    | wHour | The hour from 0-23
    @field  WORD    | wMinute | Minutes from 0-59
    @field  WORD    | wSecond | Seconds from 0-50
    @field  WORD    | wMilliseconds | Milliseconds from 0-99

    @comm   This is the format used for dislaying time to the user etc.

    @xref   <f SystemTimeToFileTime> <t FILETIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32

typedef struct _SYSTEMTIME {
   WORD wYear;
   WORD wMonth;
   WORD wDayOfWeek;
   WORD wDay;
   WORD wHour;
   WORD wMinute;
   WORD wSecond;
   WORD wMilliseconds;
} SYSTEMTIME, FAR *LPSYSTEMTIME;

#endif

/********
    @doc    EXTERNAL  IFAXOS

    @types  FILETIME    | Structure used to store time internally and for
            mathematical operations.

    @field  DWORD   | dwLowDateTime | Low 32 bits of the time.

    @field  DWORD   | dwHighDateTime | High 32 bits of the time.

    @comm   Absolute time in IFAX is represented by a 64-bit large integer accurate
            to 100ns resolution.  The smallest time resolution used by this package
            is One millisecond.  The basis for this time is the start of 1601 which
            was chosen because it is the start of a new quadricentury.  Some facts
            to note are:

            o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

            o At 100ns resolution a large integer (i.e., 63 bits) is good for
            about 29,247 years, or around 10,682,247 days.

            o At 1 second resolution 31 bits is good for about 68 years

            o At 1 second resolution 32 bits is good for about 136 years

            o 100ns Time (ignoring time less than a millisecond) can be expressed
            as two values, Days and Milliseconds.  Where Days is the number of
            whole days and Milliseconds is the number of milliseconds for the
            partial day.  Both of these values are ULONG.

    @xref   <f SystemTimeToFileTime> <t SYSTEMTIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32
// If sos property.h has been included this will cause a redefinition
#ifndef PROPERTY_H

#ifndef _FILETIME_
#define _FILETIME_

typedef struct _FILETIME {
   DWORD dwLowDateTime;
   DWORD dwHighDateTime;
} FILETIME, FAR *LPFILETIME;

#endif // _FILETIME_

#endif // Property_H

BOOL WINAPI FileTimeToSystemTime(LPFILETIME lpTime,LPSYSTEMTIME lpTimeFields);

BOOL WINAPI SystemTimeToFileTime(LPSYSTEMTIME lpTimeFields,LPFILETIME lpTime);

BOOL WINAPI FileTimeToLocalFileTime(LPFILETIME lpft, LPFILETIME lpftLocal);

BOOL WINAPI LocalFileTimeToFileTime(LPFILETIME lpftLocal, LPFILETIME lpft);

BOOL WINAPI SetLocalTime(LPSYSTEMTIME lpstLocal);

VOID WINAPI GetLocalTime(LPSYSTEMTIME lpstLocal);
#endif // Win32

// --------------- NVRAM  API's ----------------------------------------------

typedef struct ERRORLOGPOINTER {
    WORD wNextEntryPtr ;
    WORD wNumEntries ;
} ERRORLOGPOINTER , FAR * LPERRORLOGPOINTER ;

#define MAX_ERRORLOG_ENTRIES       30
#define MAX_OEMERRBUF_SIZE         16

/********
    @doc    EXTERNAL  IFAXOS

    @types  ERRORLOGENTRY    | Used to store Log Entries.

    @field  DWORD   | dwErrorCode | This is the IFAX error code
           corresponding to the error being retrieved. See <f IFErrAssemble>
           for details of the format of this dword.

    @field  DWORD   | dwTimeStamp | The time at which this error was
           logged into NVRam. The various fields are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from COUNTER_YEAR_OFFSET (add COUNTER_YEAR_OFFSET to get actual year)

    @field CHAR    | oemErrBuf  | The buffer in which the application
           specific custom data/extended error corresponding to this
           error is retrieved.

    @comm   Used as a parameter to IFNvramGetError. This will typically be
           used for diagnostic functions.

    @xref   <f IFNvramGetError>
********/

#define COUNTER_YEAR_OFFSET  (1970)

typedef struct tagERRORLOGENTRY {
   DWORD dwErrorCode;
   DWORD dwTimeStamp;
   char oemErrBuf[MAX_OEMERRBUF_SIZE];
} ERRORLOGENTRY, FAR *LPERRORLOGENTRY;

typedef DWORD ERRORLOGSENTINEL , FAR * LPERRORLOGSENTINEL ;

// Set to the current version number (12.19)
#define SENTINEL_SET              0x00000C13UL

#define MAX_COUNTERS 30
#define OEM_NVRAM_COUNTER_START 12

// Special system counter which indicates the # of times the machine has rebooted
// It is a 4 byte counter with a timestamp
// If this value is 1 then this is the first time the machine has ever been rebooted.
// - This value cannot be set by any user application!

#define BOOT_COUNTER           0

// specific counter numbers assigned for various logical counters

#define TXCALL_COUNTER         1
#define RXCALL_COUNTER         2

// ****************************************************************************
//
// An HHSOS owned counter.
// This is the number of bad boots we have suffered (meaning the HHSOS could not
// successfully init).  When this number gets too big, we stop trying to init.  
// This will cause AWCHKSOS to alert the user of the problem.
//

#define BAD_BOOTS_COUNTER      3

//
// ****************************************************************************


// These values for wFlags (in IFSetCounterValue) - some are mutually exclusive

// If CLEARSET is set the value is cleared before being added - otherwise it is just added
// Currently you cannot request a double long and a timestamp

// For now the interrupt has no context but in the future it might be useful

#define COUNTER_CLEARSET          0x0001
#define COUNTER_DOUBLE_LONG       0x0002
#define COUNTER_UPDATE_TIMESTAMP  0x0004
#define COUNTER_INTERRUPT_CONTEXT 0x1000

// Only here temporarily until everything gets moved to new values

#define COUNTER_VALUESET     (COUNTER_CLEARSET | COUNTER_UPDATE_TIMESTAMP)
#define COUNTER_ADDVALUE     0x0100
#define COUNTER_TIMESTAMP    0x0200
#define COUNTER_NOTIMESTAMP  COUNTER_DOUBLE_LONG
#define PROCESS_CONTEXT      0x0300
#define INTERRUPT_CONTEXT    COUNTER_INTERRUPT_CONTEXT

/********
    @doc    EXTERNAL  IFAXOS

    @types  COUNTERENTRY    | Used to store 4 and 8 byte Counters.

    @field  DWORD   | dwCounterVal1 | For a 4 byte counter, the value of the
           counter. For an 8 byte counter, the low order
           4 bytes of the value of the counter.

    @field  DWORD   | dwTimeStamp | For a 4 byte counter, the time at
           which the counter was last reset. The fields in the timestamp are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from 1980 (add 1980 to get actual year)

           For an 8 byte counter, dwTimeStamp is the high order 4 bytes of the
           counter value.

    @comm   Used by the IFNvramGetCounterValue function.

    @xref   <f IFNvramGetCounterValue>
********/
typedef struct tagCOUNTERENTRY {
   DWORD dwCounterVal1;
   DWORD dwTimeStamp;
} COUNTERENTRY, FAR *LPCOUNTERENTRY;

//-------------------------- Prototypes ----------------------------------

#if defined(WFW) || defined(WIN32)

#define IFNvramSetError(dw,lpb,w)              (0)
#define IFNvramSetErrorInterrupt(dw,lpb,w)         (0)
#define IFNvramGetError(lperrlog,lpwMaxEntries) (0)
#define IFNvramSetCounterValue(p1,p2,p3,p4)    (0)
#define IFNvramGetCounterValue(w1,lpentry)         (0)
#define IFNvramAllocScratchBuf(wSize)          (NULL)

#else

BOOL WINAPI     IFNvramSetError(DWORD, LPBYTE, WORD);
BOOL WINAPI     IFNvramSetErrorInterrupt(DWORD, LPBYTE, WORD);
BOOL FAR CDECL  IFNvramvSetError(DWORD dwError,WORD nErrs,...) ;
BOOL WINAPI     IFNvramGetError(LPERRORLOGENTRY lperrlog,LPWORD lpwMaxEntries) ;
BOOL WINAPI     IFNvramSetCounterValue(WORD, DWORD, DWORD, WORD);
BOOL WINAPI     IFNvramGetCounterValue(WORD, LPCOUNTERENTRY);
BOOL WINAPI     IFNvramFlushToFileLog(VOID) ;
BOOL WINAPI     IFNvramInitFileLog(VOID) ;
LPBYTE WINAPI   IFNvramAllocScratchBuf(WORD wSize);

#endif

/********
    @doc    EXTERNAL   IFAXOS

    @api    BOOL | _lflush | Flushes all pending writes to a file handle.

    @parm   HFILE  | hf    | A file handle obtained from _lopen or OpenFile

    @rdesc  Returns TRUE for success, FALSE for failure.

    @comm   This function will flush all pending writes to disk.

            For Win16 implementations, this currently always fails.
*********/

BOOL WINAPI _lflush(HFILE hf);


// the following is for service messages
#define IF_ST_END_SOSBK        (IF_SERVICE_START+0)
#define IF_ST_END_SOSRST       (IF_SERVICE_START+1)


#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // _INC_IFAXOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\viewerob.h ===
/*
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

        name:   Elliot Viewer - Chicago Viewer Utility
        						Cloned from the IFAX Message Viewing Utility

	 	file:	viewerob.h

    comments:	Class definitions for Viewer and ViewPage Objects.
    
	These objects are interface wrappers for the original IFAX viewer
	C code. All of the viewer's static variables and whatnot are collected
	here so that multiple independant viewers can be created to support 
	multiple open documents/pages. The innards of the viewer objects are 
	essentially the same as the original except for necessary fiddles to 
	allow functions to get at things that used to be static but are now
	private object data. The original innards just scream to be converted
	to C++ but time constraints didn't allow that...
 			
 	If a struct or occasional whatnot seems a bit clumsy it is probably
 	a relic leftover from the above original clone code. It works...
     	
		NOTE: This header must be used with the LARGE memory model
		
----------------------------------------------------------------------------
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
*/



#ifndef VIEWEROB_H
#define VIEWEROB_H


//#include <ole2.h>

/*
	Specials for WIN32 and WIN16 coexistance
 */
#ifdef WIN32
#define huge
#endif
   

/*
	Unicode spasms
 */
#ifndef WIN32
#ifndef TCHAR
typedef char TCHAR;
#endif
 
#ifndef _T
#define _T(x)	x
#endif

#ifndef LPTSTR
typedef TCHAR FAR *LPTSTR;
#endif

#ifndef LPTCH
typedef TCHAR FAR *LPTCH;
#endif
#endif   
   
   

/*
	Constants and defs
 */

#define OK		0
#define FAIL   -1

#define TRUE	1
#define FALSE	0

#define RESET   2
#define RESET2  3

                

#define MAX_INI_STR			256
#define MAX_STR_LEN			80
#define MAX_MEDIUMSTR_LEN	40
#define MAX_SHORTSTR_LEN	20
#define MAX_EXTSTR_LEN		3
#define MAX_COORD			32767
#define MIN_COORD  		   -32768


#define BORDER_SCROLL_SCALE	2
#define MAX_FILENAME_LEN 	13      

#ifdef WIN32
#define MAX_PATHNAME_LEN	MAX_PATH
#else
#define MAX_PATHNAME_LEN	256
#endif

#define MAX_BANDBUFFER		65536
#define MAX_VOPENBUF		65000
#define MAX_STREAM_BUF		32000
#define PAGESIZE_GUESS		(4*MAX_BANDBUFFER)


#define TEXT_FOREGROUND		RGB( 255,255,255 )
#define TEXT_BACKGROUND		RGB( 128,128,128 )



/*
	Zoom factors
 */
#define MAX_ZOOM					  100
#define INITIAL_ZOOM				  100
#define THUMBNAIL_ZOOM					5										  
#define DEFAULT_DPI					   80 // 800 pixels, 10 inch screen, used 
										  //  for demo bitmaps.


/*
	Rotation "angles"
 */
#define RA_0				0
#define RA_90               90
#define RA_180              180
#define RA_270              270
#define RA_360              360




// BKD 1997-7-9: commented out.  Already defined in buffers.h
// Standard Bit Valued MetaData values
//#define LRAW_DATA         0x00000008
//#define HRAW_DATA         0x00000010
#ifndef LRAW_DATA
#include "buffers.h"
#endif

          
          
/*
	BitBlt display defaults
 */
#define PRIMARY_BLTOP	  SRCCOPY
#define ALTERNATE_BLTOP	  NOTSRCCOPY


/*
	Timer ids
 */
#define DELAYED_OPEN_TIMER 1          
#define DRAG_TIMER		   2          
#define THUMB_FLAME_TIMER  3
          


/*
	Misc types
 */ 
typedef unsigned char 	uchar;
typedef unsigned int 	uint;
typedef unsigned short 	ushort;
typedef unsigned long 	ulong;

   
/*  
	My version of RECT
 */
typedef struct
	{
	int x_ul, y_ul;		// Upper left xy loc
	int x_lr, y_lr;		// Lower left xy loc
	int width, height;
	}
	winrect_type;
	

/*
	The "attachment" table. This is used to save the header info in a
	Chicago style viewer-message file, slightly processed.
 */	
typedef struct 
	{
	char	 *atchname;	// stream name for attachment (document)
	LONG	  numpages; // number of pages in atchname
	short     binfile;  // TRUE -> something we can't look at.
	short	  isademo;	// TRUE -> use demo version of viewrend (vrdemo)
	
	// document state (this section is 32bit aligned at this point)
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Rotation;
	WORD  ScaleX;
	WORD  ScaleY;
	} 
	attachment_table_type;


/*
	Struct for keeping track of whats in the attachment table,
	whats viewable and what isn't, etc.
 */
typedef struct
	{              
	short				  is_displayable;   // TRUE -> viewable
	HBITMAP				  hbmp;				// "icon" for non viewable attachments
	uint    			  page_offset; 		// From first displayable attachment.
	attachment_table_type *at;				// ptr to attachment table.
	}
	attachment_type;
	


/*
	Struct for keeping track of viewrend bands
 */	
typedef struct
	{
	long height_bytes;
	long first_scanline;
	}
	band_height_type;	


/*	
	Struct defining a "viewdata" object. This should be a converted to be
	a real c++ object but time constaints dictated I use it as is.
 */
typedef struct
	{
	BITMAP		 bmp;			// Raw bitmap data (NOT a GDI bitmap)
								//	NOTE: This data is NEVER rotated
								//		  (always RA_0) but can be
								//		  scaled.
								
	HBITMAP 	 hbmp;			// Handle for in memory bitmap
	HDC			 mem_hdc;		// DC for blting it to a window
	RECT 		 isa_edge;		// Flags for bitmap/file edge correspondance
	winrect_type bmp_wrc;		// Loc and size of bitmap rel to file bitmap
	
	short		 dragging;		// Bitmap is being dragged if TRUE
	
	short		 copying;		// Bitmap is being select/copied to clipboard
	RECT 		 copy_rect;		// Area to copy
	short		 copy_rect_valid; // copy_rect has valid data
	short        first_copy_rect; // flag to init focus rect
	POINT		 copyanchor_pt;
	POINT		 viewanchor_pt;
	
	winrect_type viewwin_wrc;	// Loc and size of window to drag in	                 
	winrect_type view_wrc;		// Loc and size of view window rel to bitmap
	POINT		 last_file_wrc_offset; // used for adjusting view_wrc before
									   //  rotations 
	POINT		 last_cursor;	// Last cursor loc during a drag
	int			 bdrscrl_scale;	// Scale factor for border scroll increments
	
	RECT		 left_erase;	// Rects for erasing the bitmap's
	RECT		 top_erase;		//   previous position during a drag.
	RECT		 right_erase;	
	RECT		 bottom_erase;	
	
	short		 left_iserased; // Draw corespnding erase rect if TRUE
	short		 top_iserased;	//	 during a drag.
	short		 right_iserased;
	short		 bottom_iserased;
	

	/*
		If hfile != HFILE_ERROR then the band parameters are undefined. Otherwise
		they are defined only if hbmp does not contain the entire page bmp
	 */	                                                              
	HFILE 		 hfile;			// Handle for file bitmap   
	band_height_type *band_heights;  // Array of Rajeev band heights
	short		 num_bands;		// Number of bands
	short		 current_band;	// Currently selected band
	TCHAR		 filename[MAX_FILENAME_LEN+1];
	winrect_type file_wrc;		// Loc (always=0) and size of file bitmap;
	winrect_type prescale_file_wrc;	// file_wrc / x,y_prescale
	int		 	 x_dpi;			// x dots per inch
	int		 	 y_dpi;			// y dots per inch
    uint		 linebytes;  	// Total bytes per scanline
    uint		 num_planes;	// Number of planes
    uint		 bits_per_pix;  // Bits per pixel in a plane
    
    short		 has_data;		// Bitmap and/or bmBits contains data.
    short		 in_mem; 		// All data fits in memory.
	}
	viewdata_type;



typedef int
	(WINAPI *IFMESSPROC)( char *, int );
 
 

	
/*
	This struct is for reading/writing SummaryStreams. It was
	in oleutils.h but I moved it here so every module in the 
	Viewer doesn't have to pull in oleutils.h because of the 
	summary_info_t variable in CViewer.
 */
typedef struct
	{
	LPSTR revnum;
	DATE  last_printed;
	DATE  when_created;
	DATE  last_saved;
	DWORD num_pages;
	LPSTR appname;
	DWORD security;
	LPSTR author;
	}
	summary_info_t;






/*
	Macros
 */		
#define WIDTHSHORTS( width, bits_per_pix )									\
		((((long)width)*bits_per_pix + 15)/16)



#define V_WIDTHBYTES( width, bits_per_pix )									\
		(WIDTHSHORTS( width, bits_per_pix )*2)


#define BITMAPSTRIDE( widthbytes, height )									\
		(((long)widthbytes) * height)



#define BITMAPWIDTHBYTES( widthbytes, height, planes )						\
		(BITMAPSTRIDE( widthbytes, height )*planes)


#define BITMAPBYTES( width, bits_per_pix, height, planes )					\
		(BITMAPWIDTHBYTES( V_WIDTHBYTES( width, bits_per_pix ), 				\
						   height, 											\
						   planes ))



#define SWAP_SHORT_BYTES( short_to_swap )									\
		__asm                                                               \
		{                                                                   \
		__asm mov	ax, short_to_swap                                       \
		__asm xchg	ah, al                                                  \
		__asm mov	short_to_swap, ax                                       \
		}



#define SWAP_LONG_BYTES( long_to_swap )										\
		__asm																\
		{                                                                   \
		__asm mov	ax, word ptr long_to_swap[2]                            \
		__asm xchg	ah, al                                                  \
		__asm xchg	word ptr long_to_swap[0], ax                            \
		__asm xchg	ah, al                                                  \
		__asm mov	word ptr long_to_swap[2], ax                            \
		}





















/*
	Global data
 */
extern /*IFMSGBOXPROC*/IFMESSPROC IfMessageBox_lpfn;
extern TCHAR    viewer_homedir[MAX_PATHNAME_LEN+1];
extern short    ra360_bugfix;
extern DWORD	cshelp_map[];


/*
	Non object viewer functions
 */
extern short
	InitializeViewer( void );


/* WARNING * WARNING * WARNING * HACKHACKHACKHACKHACKHACKHACKHACK */
/*   hack so CViewerPage::print_viewdata can call AbortProc       */
typedef BOOL (CALLBACK *utils_prtabortproc_type)(HDC, int);
extern utils_prtabortproc_type utils_prtabortproc;
/******************************************************************/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\migrate\makefile.inc ===
$(NTTARGETFILE0): msg00001.bin

msg.mc: $(BASEDIR)\private\genx\setup\win95upg\vendinfo.mc
        copy $(BASEDIR)\private\genx\setup\win95upg\vendinfo.mc msg.mc

msg.h msg00001.bin msg.rc:msg.mc
        mc -v msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\migrate\resource.h ===
// resource.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// Resource IDs for the fax migration DLL.
//
// Author:
// 	Brian Dewey (t-briand)	1997-8-19

#define MSG_VI_COMPANY_NAME     203
#define MSG_VI_SUPPORT_NUMBER   204
#define MSG_VI_SUPPORT_URL      205
#define MSG_VI_INSTRUCTIONS     206
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\migrate\migrate.c ===
/*++
  migrate.c

  Copyright (c) 1997  Microsoft Corporation


  This module performs Windows 95 to Windows XP fax migration.
  Specifically, this file contains the Windows XP side of migration...

  Author:

  Brian Dewey (t-briand) 1997-7-14
  Mooly Beery (moolyb)   2000-12-20

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wchar.h>
#include <tchar.h>
#include "migrate.h"              // Contains prototypes & version information.
#include "resource.h"             // Resources.
#include <faxutil.h>
#include <faxreg.h>

// ------------------------------------------------------------
// Global data

// Wide names of the working & source directories.
static WCHAR lpWorkingDir[MAX_PATH];
HINSTANCE hinstMigDll;

static LPCTSTR REG_KEY_AWF = TEXT("SOFTWARE\\Microsoft\\At Work Fax");
// ------------------------------------------------------------
// Prototypes
static DWORD MigrateDevicesNT(IN HINF UnattendFile);
static DWORD CopyCoverPageFilesNT();

#define prv_DEBUG_FILE_NAME         _T("%windir%\\FaxSetup.log")

extern "C"
BOOL WINAPI
DllEntryPoint(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpReserved)
{
    SET_DEBUG_PROPERTIES(DEBUG_ALL_MSG,DBG_PRNT_ALL_TO_FILE,DEBUG_CONTEXT_ALL);
    OPEN_DEBUG_FILE(prv_DEBUG_FILE_NAME);
    {
        DEBUG_FUNCTION_NAME(_T("DllEntryPoint"));
        if (dwReason == DLL_PROCESS_ATTACH) 
        {
            DebugPrintEx(DEBUG_MSG,"Migration DLL attached.");
            if (!DisableThreadLibraryCalls(hinstDll))
            {
                DebugPrintEx(DEBUG_ERR,"DisableThreadLibraryCalls failed (ec=%d)",GetLastError());
            }
            hinstMigDll = hinstDll;
        }
        return TRUE;
    }
}

// InitializeNT
//
// This routine performs NT-side initialization.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
InitializeNT
(
    IN  LPCWSTR WorkingDirectory, // Working directory for temporary files.
    IN  LPCWSTR SourceDirectory,  // Directory of winNT source.
    LPVOID Reserved               // It's reserved.
)
{
    int iErr = 0;

    DEBUG_FUNCTION_NAME(_T("InitializeNT"));

    DebugPrintEx(DEBUG_MSG,"Working directory is %s",WorkingDirectory);
    DebugPrintEx(DEBUG_MSG,"Source directory is %s",SourceDirectory);

    wcscpy(lpWorkingDir, WorkingDirectory);
    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateUserNT
//
// Sets up user information.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateUserNT
(
    IN  HINF UnattendInfHandle,   // Access to the unattend.txt file.
    IN  HKEY UserRegHandle,       // Handle to registry settings for user.
    IN  LPCWSTR UserName,         // Name of the user.
    LPVOID Reserved
)
{
        // our task:  copy entries from szInfFileName to the registry.
    LPTSTR lpNTOptions = TEXT("Software\\Microsoft\\Fax\\UserInfo");
    HKEY   hReg;                  // Registry key for user.
    LPCTSTR alpKeys[] = 
    {                               // This array defines what keys will be
        TEXT("Address"),            // copied from faxuser.ini into the registry.
        TEXT("Company"),
        TEXT("Department"),
        TEXT("FaxNumber"),
        TEXT("FullName"),
        TEXT("HomePhone"),
        TEXT("Mailbox"),
        TEXT("Office"),
        TEXT("OfficePhone"),
        TEXT("Title")
    };
    INT iErr = 0;
    UINT iCount, iMax;            // used for looping through all the sections.
    UINT i;                       // Used for converting doubled ';' to CR/LF pairs.
    TCHAR szValue[MAX_PATH];
    TCHAR szInfFileNameRes[MAX_PATH];
    TCHAR szWorkingDirectory[MAX_PATH];
    TCHAR szUser[MAX_PATH];       // TCHAR representation of the user name.
    LONG  lError;                 // Holds a returned error code.

    DEBUG_FUNCTION_NAME(_T("MigrateUserNT"));

    if(UserName == NULL) 
    {
            // NULL means the logon user.
        _tcscpy(szUser, lpLogonUser);// Get the logon user name for faxuser.ini
    } 
    else 
    {
    // We need to convert the wide UserName to the narrow szUser.
    WideCharToMultiByte(
        CP_ACP,         // Convert to ANSI.
        0,              // No flags.
        UserName,       // The wide char set.
        -1,             // Null-terminated string.
        szUser,         // Holds the converted string.
        sizeof(szUser), // Size of this buffer...
        NULL,           // Use default unmappable character.
        NULL            // I don't need to know if I used the default.
        );
    }

    DebugPrintEx(DEBUG_MSG,"Migrating user '%s'.",szUser);

    if (RegCreateKeyEx( UserRegHandle,
                        lpNTOptions,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hReg,
                        NULL)!=ERROR_SUCCESS)
    {
       // All I'm allowed to do is return obscure error codes...
        // However, unless there's a hardware failure, I'm supposed to say
        // everything's OK.
        DebugPrintEx(DEBUG_ERR,"RegCreateKeyEx %s failed (ec=%d)",lpNTOptions,GetLastError());
        return ERROR_SUCCESS;
    }

    iMax = sizeof(alpKeys) / sizeof(LPCTSTR);

    iErr = WideCharToMultiByte( CP_ACP,                     // Convert to ANSI.
                                0,                          // No flags.
                                lpWorkingDir,               // The wide char set.
                                -1,                         // Null-terminated string.
                                szWorkingDirectory,         // Holds the converted string.
                                sizeof(szWorkingDirectory), //  Size of this buffer...
                                NULL,                       // Use default unmappable character.
                                NULL);                      // I don't need to know if I used the default.
    if (iErr==0)
    {
        DebugPrintEx(DEBUG_ERR,"WideCharToMultiByte failed (ec=%d)",iErr);
    }
    _stprintf(szInfFileNameRes, TEXT("%s\\migrate.inf"), szWorkingDirectory);
    
    ExpandEnvironmentStrings(szInfFileNameRes, szInfFileName, MAX_PATH);

    DebugPrintEx(DEBUG_MSG,"Reading from file %s.",szInfFileName);
    for (iCount = 0; iCount < iMax; iCount++) 
    {
        GetPrivateProfileString(szUser,
                                alpKeys[iCount],
                                TEXT(""),
                                szValue,
                                sizeof(szValue),
                                szInfFileName);
        // If there was a CR/LF pair, the w95 side of things converted it
        // to a doubled semicolon.  So I'm going to look for doubled semicolons
        // and convert them to CR/LF pairs.
        i = 0;
        while (szValue[i] != _T('\0')) 
        {
            if ((szValue[i] == _T(';')) && (szValue[i+1] == _T(';'))) 
            {
                // Found a doubled semicolon.
                szValue[i] = '\r';
                szValue[i+1] = '\n';
                DebugPrintEx(DEBUG_MSG,"Doing newline translation.");
            }
            i++;
        }
        lError = RegSetValueEx(hReg,
                               alpKeys[iCount],
                               0,
                               REG_SZ,
                               LPBYTE(szValue),
                               _tcslen(szValue)+1);
        if (lError!=ERROR_SUCCESS) 
        {
            DebugPrintEx(DEBUG_ERR,"RegSetValueEx %s failed (ec=%d)",alpKeys[iCount],GetLastError());
            return lError;
        }
        DebugPrintEx(DEBUG_MSG,"%s = %s", alpKeys[iCount], szValue);
    }
    RegCloseKey(hReg);

    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateSystemNT
//
// Updates the system registry to associate 'awdvstub.exe' with the
// AWD extension.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateSystemNT
(
    IN  HINF UnattendInfHandle,   // Access to the unattend.txt file.
    LPVOID Reserved
)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szExeFileName[MAX_PATH];
    WCHAR szWindowsDir[MAX_PATH];
    WCHAR szDestFile[MAX_PATH];

    DEBUG_FUNCTION_NAME(_T("MigrateSystemNT"));

    // first, copy 'awdvstub.exe' to %SystemRoot%\system32.
    GetWindowsDirectoryW(szWindowsDir, MAX_PATH);
    swprintf(szExeFileName, L"%s\\%s", lpWorkingDir, L"awdvstub.exe");
    swprintf(szDestFile, L"%s\\system32\\%s", szWindowsDir, L"awdvstub.exe");
    if (!CopyFileW( szExeFileName,
                    szDestFile,
                    FALSE)) 
    {
        DebugPrintEx(DEBUG_ERR,"CopyFileW failed (ec=%d)",GetLastError());
    } 
    else 
    {
        DebugPrintEx(DEBUG_MSG,"CopyFileW success");
    }

    if (MigrateDevicesNT(UnattendInfHandle)!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"MigrateDevicesNT failed (ec=%d)",GetLastError());
    }

    if (CopyCoverPageFilesNT()!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"CopyCoverPageFilesNT failed (ec=%d)",GetLastError());
    }

    return ERROR_SUCCESS;         // A very confused return value.
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  MigrateDevicesNT
//
//  Purpose:        Get the active device's settings from the INF
//                  Set the device info into the FAX key under HKLM
//                  verify there's only one device, otherwise do not migrate settings
//
//  Params:
//                  IN HINF UnattendFile - handle to the answer file
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXCONNECTFAXSERVERW)      (LPCWSTR MachineName,LPHANDLE FaxHandle);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXENUMPORTSEXW)           (HANDLE hFaxHandle,PFAX_PORT_INFO_EXW* ppPorts,PDWORD lpdwNumPorts);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETPORTEXW)             (HANDLE hFaxHandle,DWORD dwDeviceId,PFAX_PORT_INFO_EXW pPortInfo);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXCLOSE)                  (HANDLE FaxHandle);
typedef WINFAXAPI VOID (WINAPI *FUNC_FAXFREEBUFFER)             (LPVOID Buffer);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXGETOUTBOXCONFIGURATION) (HANDLE hFaxHandle,PFAX_OUTBOX_CONFIG *ppOutboxCfg);
typedef WINFAXAPI BOOL (WINAPI *FUNC_FAXSETOUTBOXCONFIGURATION) (HANDLE hFaxHandle,CONST PFAX_OUTBOX_CONFIG pOutboxCfg);



static DWORD MigrateDevicesNT(IN HINF UnattendFile)
{
    DWORD                           dwErr                           = ERROR_SUCCESS;
    HMODULE                         hModule                         = 0;
    HANDLE                          hFaxHandle                      = NULL;
    CHAR                            szLocalID[MAX_PATH]             = {0};
    WCHAR                           wszLocalID[MAX_PATH]            = {0};
    CHAR                            szAnswerMode[32]                = {0};
    CHAR                            szRetries[32]                   = {0};
    CHAR                            szRetriesDelay[32]              = {0};
    CHAR                            szNumRings[32]                  = {0};
    FUNC_FAXCONNECTFAXSERVERW       pfFaxConnectFaxServerW          = NULL;
    FUNC_FAXENUMPORTSEXW            pfFaxEnumPortsExW               = NULL;
    FUNC_FAXSETPORTEXW              pfFaxSetPortExW                 = NULL;
    FUNC_FAXCLOSE                   pfFaxClose                      = NULL;
    FUNC_FAXFREEBUFFER              pfFaxFreeBuffer                 = NULL;
    FUNC_FAXGETOUTBOXCONFIGURATION  pfFaxGetOutboxConfiguration     = NULL;
    FUNC_FAXSETOUTBOXCONFIGURATION  pfFaxSetOutboxConfiguration     = NULL;
    PFAX_PORT_INFO_EXW              pFaxPortInfoExW                 = NULL;
    PFAX_OUTBOX_CONFIG              pFaxOutboxConfig                = NULL;
    DWORD                           dwNumPorts                      = 0;
    INT                             iNumRings                       = 0;
    INT                             iAnswerMode                     = 0;

    DEBUG_FUNCTION_NAME(_T("MigrateDevicesNT"));

    // load the FXSAPI.DLL
    hModule = LoadLibrary(FAX_API_MODULE_NAME);
    if (hModule==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"LoadLibrary failed (ec=%d)",GetLastError());
        goto exit;
    }
    // get the following functions:
    // 1. FaxConnectFaxServer
    // 2. FaxEnumPortsEx
    // 3. FaxSetPortEx
    // 4. FaxClose
    // 5. FaxFreeBuffer
    // 6. FaxGetOutboxConfiguration
    // 7. FaxSetOutboxConfiguration
    pfFaxConnectFaxServerW = (FUNC_FAXCONNECTFAXSERVERW)GetProcAddress(hModule,"FaxConnectFaxServerW");
    if (pfFaxConnectFaxServerW==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxConnectFaxServerW failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxEnumPortsExW = (FUNC_FAXENUMPORTSEXW)GetProcAddress(hModule,"FaxEnumPortsExW");
    if (pfFaxEnumPortsExW==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxEnumPortsExW failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxSetPortExW = (FUNC_FAXSETPORTEXW)GetProcAddress(hModule,"FaxSetPortExW");
    if (pfFaxSetPortExW==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxSetPortExW failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxClose = (FUNC_FAXCLOSE)GetProcAddress(hModule,"FaxClose");
    if (pfFaxClose==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxClose failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxFreeBuffer = (FUNC_FAXFREEBUFFER)GetProcAddress(hModule,"FaxFreeBuffer");
    if (pfFaxFreeBuffer==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxFreeBuffer failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxGetOutboxConfiguration = (FUNC_FAXGETOUTBOXCONFIGURATION)GetProcAddress(hModule,"FaxGetOutboxConfiguration");
    if (pfFaxGetOutboxConfiguration==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxGetOutboxConfiguration failed (ec=%d)",GetLastError());
        goto exit;
    }
    pfFaxSetOutboxConfiguration = (FUNC_FAXSETOUTBOXCONFIGURATION)GetProcAddress(hModule,"FaxSetOutboxConfiguration");
    if (pfFaxSetOutboxConfiguration==NULL)
    {
        DebugPrintEx(DEBUG_ERR,"GetProcAddress FaxSetOutboxConfiguration failed (ec=%d)",GetLastError());
        goto exit;
    }

    // try to connect to the fax server
    if (!(*pfFaxConnectFaxServerW)(NULL,&hFaxHandle))
    {
        DebugPrintEx(DEBUG_ERR,"pfFaxConnectFaxServerW failed (ec=%d)",GetLastError());
        goto exit;
    }

    // call EnumPortsEx
    if (!(*pfFaxEnumPortsExW)(hFaxHandle,&pFaxPortInfoExW,&dwNumPorts))
    {
        DebugPrintEx(DEBUG_ERR,"pfFaxConnectFaxServerW failed (ec=%d)",GetLastError());
        goto exit;
    }

    if (dwNumPorts==0)
    {
        DebugPrintEx(DEBUG_MSG,"No devices are installed, no migration");
        goto next;
    } 
    else if (dwNumPorts>1)
    {
        DebugPrintEx(DEBUG_MSG,"%d devices are installed, no migration",dwNumPorts);
        goto next;
    }

    // we have one device, get its FAX_PORT_INFOW, modify it and call FaxSetPortW
    // TSID
    if (SetupGetLineText(   NULL,
                            UnattendFile,
                            "FAX",
                            INF_RULE_LOCAL_ID,
                            szLocalID,
                            sizeof(szLocalID),
                            NULL))
    {
        if (MultiByteToWideChar(CP_ACP,
                                MB_PRECOMPOSED,
                                szLocalID,
                                -1,
                                wszLocalID,
                                sizeof(wszLocalID)/sizeof(WCHAR)
                                ))
        {
            pFaxPortInfoExW[0].lptstrTsid = wszLocalID;
            pFaxPortInfoExW[0].lptstrCsid = wszLocalID;
            DebugPrintEx(DEBUG_MSG,"new TSID & CSID is %s",szLocalID);
        }
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"SetupGetLineText TSID failed (ec=%d)",GetLastError());
    }
    // Rings
    if (SetupGetLineText(   NULL,
                            UnattendFile,
                            "FAX",
                            INF_RULE_NUM_RINGS,
                            szNumRings,
                            sizeof(szNumRings),
                            NULL))
    {
        iNumRings = atoi(szNumRings);
        if (iNumRings)
        {
            pFaxPortInfoExW[0].dwRings = iNumRings;
            DebugPrintEx(DEBUG_MSG,"new Rings is %d",iNumRings);
        }
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"GetPrivateProfileString NumRings failed (ec=%d)",GetLastError());
    }

    // Answer mode
    pFaxPortInfoExW[0].bSend = TRUE;
    if (SetupGetLineText(   NULL,
                            UnattendFile,
                            "FAX",
                            INF_RULE_ANSWER_MODE,
                            szAnswerMode,
                            sizeof(szAnswerMode),
                            NULL))
    {
        iAnswerMode = atoi(szAnswerMode);
        switch (iAnswerMode)
        {
        case 0:     break;
        case 1:     pFaxPortInfoExW[0].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
                    DebugPrintEx(DEBUG_MSG,"setting flags to manual Receive");
                    break;
        case 2:     pFaxPortInfoExW[0].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
                    DebugPrintEx(DEBUG_MSG,"setting flags to auto Receive");
                    break;
        default:    pFaxPortInfoExW[0].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                    DebugPrintEx(DEBUG_MSG,"strange AnswerMode, just send enabled");
                    break;
        }
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"GetPrivateProfileString AnswerMode failed (ec=%d)",GetLastError());
    }

    // call FaxSetPort
    if (!(*pfFaxSetPortExW)(hFaxHandle,pFaxPortInfoExW[0].dwDeviceID,&(pFaxPortInfoExW[0])))
    {
        DebugPrintEx(DEBUG_ERR,"pfFaxSetPortExW failed (ec=%d)",GetLastError());
        goto exit;
    }

next:
    // get the Outbox configuration
    if (!(*pfFaxGetOutboxConfiguration)(hFaxHandle,&pFaxOutboxConfig))
    {
        DebugPrintEx(DEBUG_ERR,"pfFaxGetOutboxConfiguration failed (ec=%d)",GetLastError());
        goto exit;
    }

    // get the retries and retry delay from INF
    if (SetupGetLineText(   NULL,
                            UnattendFile,
                            "FAX",
                            "NumberOfRetries",
                            szRetries,
                            sizeof(szRetries),
                            NULL))
    {
        pFaxOutboxConfig->dwRetries = atoi(szRetries);
    }

    if (SetupGetLineText(   NULL,
                            UnattendFile,
                            "FAX",
                            "TimeBetweenRetries",
                            szRetriesDelay,
                            sizeof(szRetriesDelay),
                            NULL))
    {
        pFaxOutboxConfig->dwRetryDelay = atoi(szRetriesDelay);
    }

    // now set the outbox configuration 
    if (!(*pfFaxSetOutboxConfiguration)(hFaxHandle,pFaxOutboxConfig))
    {
        DebugPrintEx(DEBUG_ERR,"pfFaxSetOutboxConfiguration failed (ec=%d)",GetLastError());
        goto exit;
    }

exit:
    if (hFaxHandle)
    {
        if (pfFaxClose)
        {
            (*pfFaxClose)(hFaxHandle);
        }
        if (pFaxPortInfoExW)
        {
            if(pfFaxFreeBuffer)
            {
                (*pfFaxFreeBuffer)(pFaxPortInfoExW);
            }
        }
        if (pFaxOutboxConfig)
        {
            if(pfFaxFreeBuffer)
            {
                (*pfFaxFreeBuffer)(pFaxOutboxConfig);
            }
        }
    }
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  CopyCoverPageFilesNT
//
//  Purpose:        Copy all of the *.CPE files from the temporary 
//                  directory to the server cover pages dir
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
DWORD CopyCoverPageFilesNT()
{
    DWORD           dwErr                           = ERROR_SUCCESS;
    INT             iErr                            = 0;
    CHAR            szServerCpDir[MAX_PATH]         = {0};
    CHAR            szWorkingDirectory[MAX_PATH]    = {0};
    SHFILEOPSTRUCT  fileOpStruct;

    DEBUG_FUNCTION_NAME(_T("CopyCoverPageFiles9X"));

    ZeroMemory(&fileOpStruct, sizeof(SHFILEOPSTRUCT));

    // Get the server cover pages directory
    if (!GetServerCpDir(NULL,szServerCpDir,sizeof(szServerCpDir)))
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,"GetServerCpDir failed (ec=%d)",dwErr);
        goto exit;
    }

    iErr = WideCharToMultiByte( CP_ACP,                     // Convert to ANSI.
                            0,                          // No flags.
                            lpWorkingDir,               // The wide char set.
                            -1,                         // Null-terminated string.
                            szWorkingDirectory,         // Holds the converted string.
                            sizeof(szWorkingDirectory), // Size of this buffer...
                            NULL,                       // Use default unmappable character.
                            NULL);                      // I don't need to know if I used the default.
    if (iErr==0)
    {
        DebugPrintEx(DEBUG_ERR,"WideCharToMultiByte failed (ec=%d)",iErr);
        goto exit;
    }

    strcat(szWorkingDirectory,"\\*.cpe");

    fileOpStruct.hwnd =                     NULL; 
    fileOpStruct.wFunc =                    FO_MOVE;
    fileOpStruct.pFrom =                    szWorkingDirectory; 
    fileOpStruct.pTo =                      szServerCpDir;
    fileOpStruct.fFlags =                   

        FOF_FILESONLY       |   // Perform the operation on files only if a wildcard file name (*.*) is specified. 
        FOF_NOCONFIRMMKDIR  |   // Do not confirm the creation of a new directory if the operation requires one to be created. 
        FOF_NOCONFIRMATION  |   // Respond with "Yes to All" for any dialog box that is displayed. 
        FOF_NORECURSION     |   // Only operate in the local directory. Don't operate recursively into subdirectories.
        FOF_SILENT          |   // Do not display a progress dialog box. 
        FOF_NOERRORUI;          // Do not display a user interface if an error occurs. 

    fileOpStruct.fAnyOperationsAborted =    FALSE;
    fileOpStruct.hNameMappings =            NULL;
    fileOpStruct.lpszProgressTitle =        NULL; 

    DebugPrintEx(DEBUG_MSG, 
             TEXT("Calling to SHFileOperation from %s to %s."),
             fileOpStruct.pFrom,
             fileOpStruct.pTo);
    if (SHFileOperation(&fileOpStruct))
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,"SHFileOperation failed (ec: %ld)",dwErr);
        goto exit;
    }


exit:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\inc\tiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff.h

Abstract:

    This file the data structures and constant
    definitions for the TIFF file format.
    See the TIFF specification Revision 6.0,
    dated 6-3-92, from Adobe for specific details.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFF_
#define _TIFF_

#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

#pragma pack(1)

typedef struct _TIFF_HEADER {
    WORD        Identifier;
    WORD        Version;
    DWORD       IFDOffset;
} TIFF_HEADER, *PTIFF_HEADER;

//
// TIFF Image File Directories are comprised of
// a table of field descriptors of the form shown
// below.  The table is sorted in ascending order
// by tag.  The values associated with each entry
// are disjoint and may appear anywhere in the file
// (so long as they are placed on a word boundary).
//
// If the value is 4 bytes or less, then it is placed
// in the offset field to save space.  If the value
// is less than 4 bytes, it is left-justified in the
// offset field.
//
typedef struct _TIFF_TAG {
    WORD        TagId;
    WORD        DataType;
    DWORD       DataCount;
    DWORD       DataOffset;
} TIFF_TAG, *PTIFF_TAG;

#pragma pack()


//
// NB: In the comments below,
//  - items marked with a + are obsoleted by revision 5.0,
//  - items marked with a ! are introduced in revision 6.0.
//  - items marked with a % are introduced post revision 6.0.
//  - items marked with a $ are obsoleted by revision 6.0.
//

//
// Tag data type information.
//
#define TIFF_NOTYPE                     0       // placeholder
#define TIFF_BYTE                       1       // 8-bit unsigned integer
#define TIFF_ASCII                      2       // 8-bit bytes w/ last byte null
#define TIFF_SHORT                      3       // 16-bit unsigned integer
#define TIFF_LONG                       4       // 32-bit unsigned integer
#define TIFF_RATIONAL                   5       // 64-bit unsigned fraction
#define TIFF_SBYTE                      6       // !8-bit signed integer
#define TIFF_UNDEFINED                  7       // !8-bit untyped data
#define TIFF_SSHORT                     8       // !16-bit signed integer
#define TIFF_SLONG                      9       // !32-bit signed integer
#define TIFF_SRATIONAL                  10      // !64-bit signed fraction
#define TIFF_FLOAT                      11      // !32-bit IEEE floating point
#define TIFF_DOUBLE                     12      // !64-bit IEEE floating point

//
// TIFF Tag Definitions.
//
#define TIFFTAG_SUBFILETYPE             254     // subfile data descriptor
#define     FILETYPE_REDUCEDIMAGE       0x1     // reduced resolution version
#define     FILETYPE_PAGE               0x2     // one page of many
#define     FILETYPE_MASK               0x4     // transparency mask
#define TIFFTAG_OSUBFILETYPE            255     // +kind of data in subfile
#define     OFILETYPE_IMAGE             1       // full resolution image data
#define     OFILETYPE_REDUCEDIMAGE      2       // reduced size image data
#define     OFILETYPE_PAGE              3       // one page of many
#define TIFFTAG_IMAGEWIDTH              256     // image width in pixels
#define TIFFTAG_IMAGELENGTH             257     // image height in pixels
#define TIFFTAG_BITSPERSAMPLE           258     // bits per channel (sample)
#define TIFFTAG_COMPRESSION             259     // data compression technique
#define     COMPRESSION_NONE            1       // dump mode
#define     COMPRESSION_CCITTRLE        2       // CCITT modified Huffman RLE
#define     COMPRESSION_CCITTFAX3       3       // CCITT Group 3 fax encoding
#define     COMPRESSION_CCITTFAX4       4       // CCITT Group 4 fax encoding
#define     COMPRESSION_LZW             5       // Lempel-Ziv  & Welch
#define     COMPRESSION_OJPEG           6       // !6.0 JPEG
#define     COMPRESSION_JPEG            7       // %JPEG DCT compression
#define     COMPRESSION_NEXT            32766   // NeXT 2-bit RLE
#define     COMPRESSION_CCITTRLEW       32771   // #1 w/ word alignment
#define     COMPRESSION_PACKBITS        32773   // Macintosh RLE
#define     COMPRESSION_THUNDERSCAN     32809   // ThunderScan RLE
//
// compression codes 32908-32911 are reserved for Pixar
//
#define     COMPRESSION_PIXARFILM       32908   // Pixar companded 10bit LZW
#define     COMPRESSION_DEFLATE         32946   // Deflate compression
#define     COMPRESSION_JBIG            34661   // ISO JBIG
#define TIFFTAG_PHOTOMETRIC             262     // photometric interpretation
#define     PHOTOMETRIC_MINISWHITE      0       // min value is white
#define     PHOTOMETRIC_MINISBLACK      1       // min value is black
#define     PHOTOMETRIC_RGB             2       // RGB color model
#define     PHOTOMETRIC_PALETTE         3       // color map indexed
#define     PHOTOMETRIC_MASK            4       // $holdout mask
#define     PHOTOMETRIC_SEPARATED       5       // !color separations
#define     PHOTOMETRIC_YCBCR           6       // !CCIR 601
#define     PHOTOMETRIC_CIELAB          8       // !1976 CIE L*a*b*
#define TIFFTAG_THRESHHOLDING           263     // +thresholding used on data
#define     THRESHHOLD_BILEVEL          1       // b&w art scan
#define     THRESHHOLD_HALFTONE         2       // or dithered scan
#define     THRESHHOLD_ERRORDIFFUSE     3       // usually floyd-steinberg
#define TIFFTAG_CELLWIDTH               264     // +dithering matrix width
#define TIFFTAG_CELLLENGTH              265     // +dithering matrix height
#define TIFFTAG_FILLORDER               266     // data order within a byte
#define     FILLORDER_MSB2LSB           1       // most significant -> least
#define     FILLORDER_LSB2MSB           2       // least significant -> most
#define TIFFTAG_DOCUMENTNAME            269     // name of doc. image is from
#define TIFFTAG_IMAGEDESCRIPTION        270     // info about image
#define TIFFTAG_MAKE                    271     // scanner manufacturer name
#define TIFFTAG_MODEL                   272     // scanner model name/number
#define TIFFTAG_STRIPOFFSETS            273     // offsets to data strips
#define TIFFTAG_ORIENTATION             274     // +image orientation
#define     ORIENTATION_TOPLEFT         1       // row 0 top, col 0 lhs
#define     ORIENTATION_TOPRIGHT        2       // row 0 top, col 0 rhs
#define     ORIENTATION_BOTRIGHT        3       // row 0 bottom, col 0 rhs
#define     ORIENTATION_BOTLEFT         4       // row 0 bottom, col 0 lhs
#define     ORIENTATION_LEFTTOP         5       // row 0 lhs, col 0 top
#define     ORIENTATION_RIGHTTOP        6       // row 0 rhs, col 0 top
#define     ORIENTATION_RIGHTBOT        7       // row 0 rhs, col 0 bottom
#define     ORIENTATION_LEFTBOT         8       // row 0 lhs, col 0 bottom
#define TIFFTAG_SAMPLESPERPIXEL         277     // samples per pixel
#define TIFFTAG_ROWSPERSTRIP            278     // rows per strip of data
#define TIFFTAG_STRIPBYTECOUNTS         279     // bytes counts for strips
#define TIFFTAG_MINSAMPLEVALUE          280     // +minimum sample value
#define TIFFTAG_MAXSAMPLEVALUE          281     // +maximum sample value
#define TIFFTAG_XRESOLUTION             282     // pixels/resolution in x
#define TIFFTAG_YRESOLUTION             283     // pixels/resolution in y
#define TIFFTAG_PLANARCONFIG            284     // storage organization
#define     PLANARCONFIG_CONTIG         1       // single image plane
#define     PLANARCONFIG_SEPARATE       2       // separate planes of data
#define TIFFTAG_PAGENAME                285     // page name image is from
#define TIFFTAG_XPOSITION               286     // x page offset of image lhs
#define TIFFTAG_YPOSITION               287     // y page offset of image lhs
#define TIFFTAG_FREEOFFSETS             288     // +byte offset to free block
#define TIFFTAG_FREEBYTECOUNTS          289     // +sizes of free blocks
#define TIFFTAG_GRAYRESPONSEUNIT        290     // $gray scale curve accuracy
#define     GRAYRESPONSEUNIT_10S        1       // tenths of a unit
#define     GRAYRESPONSEUNIT_100S       2       // hundredths of a unit
#define     GRAYRESPONSEUNIT_1000S      3       // thousandths of a unit
#define     GRAYRESPONSEUNIT_10000S     4       // ten-thousandths of a unit
#define     GRAYRESPONSEUNIT_100000S    5       // hundred-thousandths
#define TIFFTAG_GRAYRESPONSECURVE       291     // $gray scale response curve
#define TIFFTAG_GROUP3OPTIONS           292     // 32 flag bits
#define     GROUP3OPT_2DENCODING        0x1     // 2-dimensional coding
#define     GROUP3OPT_UNCOMPRESSED      0x2     // data not compressed
#define     GROUP3OPT_FILLBITS          0x4     // fill to byte boundary
#define TIFFTAG_GROUP4OPTIONS           293     // 32 flag bits
#define     GROUP4OPT_UNCOMPRESSED      0x2     // data not compressed
#define TIFFTAG_RESOLUTIONUNIT          296     // units of resolutions
#define     RESUNIT_NONE                1       // no meaningful units
#define     RESUNIT_INCH                2       // english
#define     RESUNIT_CENTIMETER          3       // metric
#define TIFFTAG_PAGENUMBER              297     // page numbers of multi-page
#define TIFFTAG_COLORRESPONSEUNIT       300     // $color curve accuracy
#define     COLORRESPONSEUNIT_10S       1       // tenths of a unit
#define     COLORRESPONSEUNIT_100S      2       // hundredths of a unit
#define     COLORRESPONSEUNIT_1000S     3       // thousandths of a unit
#define     COLORRESPONSEUNIT_10000S    4       // ten-thousandths of a unit
#define     COLORRESPONSEUNIT_100000S   5       // hundred-thousandths
#define TIFFTAG_TRANSFERFUNCTION        301     // !colorimetry info
#define TIFFTAG_SOFTWARE                305     // name & release
#define TIFFTAG_DATETIME                306     // creation date and time
#define TIFFTAG_ARTIST                  315     // creator of image
#define TIFFTAG_HOSTCOMPUTER            316     // machine where created
#define TIFFTAG_PREDICTOR               317     // prediction scheme w/ LZW
#define TIFFTAG_WHITEPOINT              318     // image white point
#define TIFFTAG_PRIMARYCHROMATICITIES   319     // !primary chromaticities
#define TIFFTAG_COLORMAP                320     // RGB map for pallette image
#define TIFFTAG_HALFTONEHINTS           321     // !highlight+shadow info
#define TIFFTAG_TILEWIDTH               322     // !rows/data tile
#define TIFFTAG_TILELENGTH              323     // !cols/data tile
#define TIFFTAG_TILEOFFSETS             324     // !offsets to data tiles
#define TIFFTAG_TILEBYTECOUNTS          325     // !byte counts for tiles
#define TIFFTAG_BADFAXLINES             326     // lines w/ wrong pixel count
#define TIFFTAG_CLEANFAXDATA            327     // regenerated line info
#define     CLEANFAXDATA_CLEAN          0       // no errors detected
#define     CLEANFAXDATA_REGENERATED    1       // receiver regenerated lines
#define     CLEANFAXDATA_UNCLEAN        2       // uncorrected errors exist
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     // max consecutive bad lines
#define TIFFTAG_SUBIFD                  330     // subimage descriptors
#define TIFFTAG_INKSET                  332     // !inks in separated image
#define     INKSET_CMYK                 1       // !cyan-magenta-yellow-black
#define TIFFTAG_INKNAMES                333     // !ascii names of inks
#define TIFFTAG_DOTRANGE                336     // !0% and 100% dot codes
#define TIFFTAG_TARGETPRINTER           337     // !separation target
#define TIFFTAG_EXTRASAMPLES            338     // !info about extra samples
#define     EXTRASAMPLE_UNSPECIFIED     0       // !unspecified data
#define     EXTRASAMPLE_ASSOCALPHA      1       // !associated alpha data
#define     EXTRASAMPLE_UNASSALPHA      2       // !unassociated alpha data
#define TIFFTAG_SAMPLEFORMAT            339     // !data sample format
#define     SAMPLEFORMAT_UINT           1       // !unsigned integer data
#define     SAMPLEFORMAT_INT            2       // !signed integer data
#define     SAMPLEFORMAT_IEEEFP         3       // !IEEE floating point data
#define     SAMPLEFORMAT_VOID           4       // !untyped data
#define TIFFTAG_SMINSAMPLEVALUE         340     // !variable MinSampleValue
#define TIFFTAG_SMAXSAMPLEVALUE         341     // !variable MaxSampleValue
#define TIFFTAG_JPEGTABLES              347     // %JPEG table stream
//
// Tags 512-521 are obsoleted by Technical Note #2
// which specifies a revised JPEG-in-TIFF scheme.
//
#define TIFFTAG_JPEGPROC                512     // !JPEG processing algorithm
#define     JPEGPROC_BASELINE           1       // !baseline sequential
#define     JPEGPROC_LOSSLESS           14      // !Huffman coded lossless
#define TIFFTAG_JPEGIFOFFSET            513     // !pointer to SOI marker
#define TIFFTAG_JPEGIFBYTECOUNT         514     // !JFIF stream length
#define TIFFTAG_JPEGRESTARTINTERVAL     515     // !restart interval length
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     // !lossless proc predictor
#define TIFFTAG_JPEGPOINTTRANSFORM      518     // !lossless point transform
#define TIFFTAG_JPEGQTABLES             519     // !Q matrice offsets
#define TIFFTAG_JPEGDCTABLES            520     // !DCT table offsets
#define TIFFTAG_JPEGACTABLES            521     // !AC coefficient offsets
#define TIFFTAG_YCBCRCOEFFICIENTS       529     // !RGB -> YCbCr transform
#define TIFFTAG_YCBCRSUBSAMPLING        530     // !YCbCr subsampling factors
#define TIFFTAG_YCBCRPOSITIONING        531     // !subsample positioning
#define     YCBCRPOSITION_CENTERED      1       // !as in PostScript Level 2
#define     YCBCRPOSITION_COSITED       2       // !as in CCIR 601-1
#define TIFFTAG_REFERENCEBLACKWHITE     532     // !colorimetry info
//
// tags 32952-32956 are private tags registered to Island Graphics
//
#define TIFFTAG_REFPTS                  32953   // image reference points
#define TIFFTAG_REGIONTACKPOINT         32954   // region-xform tack point
#define TIFFTAG_REGIONWARPCORNERS       32955   // warp quadrilateral
#define TIFFTAG_REGIONAFFINE            32956   // affine transformation mat
//
// tags 32995-32999 are private tags registered to SGI
//
#define TIFFTAG_MATTEING                32995   // $use ExtraSamples
#define TIFFTAG_DATATYPE                32996   // $use SampleFormat
#define TIFFTAG_IMAGEDEPTH              32997   // z depth of image
#define TIFFTAG_TILEDEPTH               32998   // z depth/data tile
//
// tags 33300-33309 are private tags registered to Pixar
//
// TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
// are set when an image has been cropped out of a larger image.
// They reflect the size of the original uncropped image.
// The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
// to determine the position of the smaller image in the larger one.
//
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   // full image size in x
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   // full image size in y
//
// tag 33432 is listed in the 6.0 spec w/ unknown ownership
//
#define TIFFTAG_COPYRIGHT               33432   // copyright string
//
// tags 34232-34236 are private tags registered to Texas Instruments
//
#define TIFFTAG_FRAMECOUNT              34232   // Sequence Frame Count
//
// tag 34750 is a private tag registered to Pixel Magic
//
#define TIFFTAG_JBIGOPTIONS             34750   // JBIG options
//
// tags 34908-34914 are private tags registered to SGI
//
#define TIFFTAG_FAXRECVPARAMS           34908   // encoded Class 2 ses. parms
#define TIFFTAG_FAXSUBADDRESS           34909   // received SubAddr string
#define TIFFTAG_FAXRECVTIME             34910   // receive time (secs)
//
// tags 40001-40100 are private tags registered to ms
//
#define TIFFTAG_RECIP_NAME              40001
#define TIFFTAG_RECIP_NUMBER            40002
#define TIFFTAG_SENDER_NAME             40003
#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005
#define TIFFTAG_TSID                    40006
#define TIFFTAG_CSID                    40007
#define TIFFTAG_FAX_TIME                40008
//
// The following are ``pseudo tags'' that can be
// used to control codec-specific functionality.
// These tags are not written to file.  Note that
// these values start at 0xffff+1 so that they'll
// never collide with Aldus-assigned tags.
//
// If you want your private pseudo tags ``registered''
// (i.e. added to this file), send mail to sam@sgi.com
// with the appropriate C definitions to add.
//
#define TIFFTAG_FAXMODE                 65536   // Group 3/4 format control
#define     FAXMODE_CLASSIC     0x0000          // default, include RTC
#define     FAXMODE_NORTC       0x0001          // no RTC at end of data
#define     FAXMODE_NOEOL       0x0002          // no EOL code at end of row
#define     FAXMODE_BYTEALIGN   0x0004          // byte align row
#define     FAXMODE_WORDALIGN   0x0008          // word align row
#define     FAXMODE_CLASSF      FAXMODE_NORTC   // TIFF Class F
#define TIFFTAG_JPEGQUALITY             65537   // Compression quality level
//
// Note: quality level is on the IJG 0-100 scale.  Default value is 75
//
#define TIFFTAG_JPEGCOLORMODE           65538   // Auto RGB<=>YCbCr convert?
#define     JPEGCOLORMODE_RAW   0x0000          // no conversion (default)
#define     JPEGCOLORMODE_RGB   0x0001          // do auto conversion
#define TIFFTAG_JPEGTABLESMODE          65539   // What to put in JPEGTables
#define     JPEGTABLESMODE_QUANT 0x0001         // include quantization tbls
#define     JPEGTABLESMODE_HUFF 0x0002          // include Huffman tbls
//
// Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF
//
#define TIFFTAG_FAXFILLFUNC             65540   // G3/G4 fill function
#define TIFFTAG_PIXARLOGDATAFMT         65549   // PixarLogCodec I/O data sz
#define     PIXARLOGDATAFMT_8BIT        0       // regular u_char samples
#define     PIXARLOGDATAFMT_8BITABGR    1       // ABGR-order u_chars
#define     PIXARLOGDATAFMT_10BITLOG    2       // 10-bit log-encoded (raw)
#define     PIXARLOGDATAFMT_12BITPICIO  3       // as per PICIO (1.0==2048)
#define     PIXARLOGDATAFMT_16BIT       4       // signed short samples
#define     PIXARLOGDATAFMT_FLOAT       5       // IEEE float samples

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\migrate\w95mig.c ===
/*++
  w95mig.c

  Copyright (c) 1997  Microsoft Corporation


  This module contains the win95 side of the migration code.

  Author:

  Brian Dewey (t-briand) 1997-7-18
  Mooly Beery (moolyb)   2000-12-20

--*/

#include <windows.h>
#include <setupapi.h>
#include <shellapi.h>
#include <mapidefs.h>
#include <mapitags.h>           // To get the property definitions.
#include <stdio.h>
#include <tchar.h>
#include "migrate.h"            // Contains prototypes & version information.
#include "property.h"           // Stolen from Elliott -- contains their fax properties
#include "resource.h"           // Migration resources.
#include "faxutil.h"
#include "FaxSetup.h"
#include "FaxReg.h"


// ------------------------------------------------------------
// Defines & macros
#define     SWAPWORD(x)                 (((x) << 16) | ((x) >> 16))


//
//  Fax Applications will be blocked by the Upgrade and required to be removed.
//  Save them in the Registry before that.
//
#define     REGKEYUPG_INSTALLEDFAX      _T("Software\\Microsoft\\FaxUpgrade")


// ------------------------------------------------------------
// Internal data

// First, this is the name of the INF file that we generate.
static TCHAR szInfFileBase[]    = TEXT("migrate.inf");
TCHAR szInfFileName[MAX_PATH];  // This will be the fully qualified path of the above.

static char  lpWorkingDir[MAX_PATH];     // This is our working directory.
static TCHAR szDoInstall[4];             // Will be either "No" or "Yes".
static TCHAR szFaxAreaCode[16];          // Contains the fax modem area code.
static TCHAR szFaxNumber[9];             // Fax # w/o area or country code.
static TCHAR szNTProfileName[MAX_PATH];  // Profile to use for routing.
static TCHAR szFaxStoreDir[MAX_PATH];    // Folder to use for routing.
static TCHAR szUserName[MAX_PATH];       // This will be the user's name who owns the fax service.
static TCHAR szUserID[MAX_PATH];         // This is the login name of the user who owns the fax.

static LPCTSTR REG_KEY_AWF_LOCAL_MODEMS     = TEXT("SOFTWARE\\Microsoft\\At Work Fax\\Local Modems");
static LPCTSTR REG_KEY_AWF_INSTALLED        = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSAWFax");

// The following are section names from the Microsoft registry.
// They're used to find the fax profile for a user.
static const LPTSTR LPUSERPROF  = TEXT("Software\\Microsoft\\Windows Messaging Subsystem\\Profiles");
static const LPTSTR LPPROFNAME  = TEXT("DefaultProfile");

// The following's part of the path to the Exchange profile in question.
static const LPTSTR LPPROFILES  = TEXT("Software\\Microsoft\\Windows Messaging Subsystem\\Profiles");

// This is how we get the root UID.
static const LPTSTR LPPROFUID   = TEXT("Profile UID");

// This is the name we use for the logon user section of 'faxuser.ini'
LPCTSTR lpLogonUser             = TEXT("Logon User");

// This keeps track of the number of users migrated.  Used to make annotations
// in the INF file.
static DWORD dwUserCount = 0;

// ------------------------------------------------------------
// Internal function prototypes
static BOOL GetUserProfileName(HKEY hUser, LPTSTR lpProfName, DWORD cbSize);
static BOOL GetRegProfileKey(HKEY hUser, LPTSTR lpProfName, PHKEY phRegProfileKey);
static void DumpUserInfo(HKEY hUserInfo, LPCSTR UserName, LPTSTR szProfileName,IN LPCSTR UnattendFile);
static void SetGlobalFaxNumberInfo(LPCTSTR szPhone);
static BOOL InitializeInfFile(LPCTSTR WorkingDirectory);
static BOOL IsAWFInstalled();
static DWORD MigrateDevices9X(IN LPCSTR UnattendFile);
static DWORD CopyCoverPageFiles9X();
static DWORD RememberInstalledFax(IN bool bSBSClient, IN bool bXPDLClient);
static DWORD MigrateUninstalledFax(IN LPCTSTR lpctstrUnattendFile, OUT bool *pbFaxWasInstalled);

VENDORINFO VendorInfo;

// QueryVersion
//
// This routine returns version information about the migration DLL.
//
// Parameters:
//      Commented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-23
LONG
CALLBACK 
QueryVersion 
(
    OUT LPCSTR  *ProductID,   // Unique identifier string.
    OUT LPUINT DllVersion,    // Version number.  Cannot be zero.
    OUT LPINT *CodePageArray, // OPTIONAL.  Language dependencies.
    OUT LPCSTR  *ExeNamesBuf, // OPTIONAL.  Executables to look for.
    OUT PVENDORINFO *ppVendorInfo
)
{
    int     iRes    = 0;
    DWORD   dwErr   = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(_T("QueryVersion"));

    if (ProductID)
    {
        *ProductID = "Microsoft Fax";
    }
    if (DllVersion)
    {
        *DllVersion = FAX_MIGRATION_VERSION;
    }
    if (CodePageArray)
    {
        *CodePageArray = NULL;        // No language dependencies
    }
    if (ExeNamesBuf)
    {
        *ExeNamesBuf = NULL;
    }
    if (ppVendorInfo)
    {
        *ppVendorInfo = &VendorInfo;
    }

    iRes = LoadString(  hinstMigDll,
                        MSG_VI_COMPANY_NAME,
                        &VendorInfo.CompanyName[0],
                        sizeof(VendorInfo.CompanyName));
    if ((iRes==0) && (dwErr=GetLastError()))
    {
        DebugPrintEx(DEBUG_ERR,"LoadString MSG_VI_COMPANY_NAME failed (ec=%d)",dwErr);
    }
    
    iRes = LoadString(  hinstMigDll,
                        MSG_VI_SUPPORT_NUMBER,
                        &VendorInfo.SupportNumber[0],
                        sizeof(VendorInfo.SupportNumber));
    if ((iRes==0) && (dwErr=GetLastError()))
    {
        DebugPrintEx(DEBUG_ERR,"LoadString MSG_VI_SUPPORT_NUMBER failed (ec=%d)",dwErr);
    }
    
    iRes = LoadString(  hinstMigDll,
                        MSG_VI_SUPPORT_URL,
                        &VendorInfo.SupportUrl[0],
                        sizeof(VendorInfo.SupportUrl));
    if ((iRes==0) && (dwErr=GetLastError()))
    {
        DebugPrintEx(DEBUG_ERR,"LoadString MSG_VI_SUPPORT_URL failed (ec=%d)",dwErr);
    }
    
    iRes = LoadString(  hinstMigDll,
                        MSG_VI_INSTRUCTIONS,
                        &VendorInfo.InstructionsToUser[0],
                        sizeof(VendorInfo.InstructionsToUser));
    if ((iRes==0) && (dwErr=GetLastError()))
    {
        DebugPrintEx(DEBUG_ERR,"LoadString MSG_VI_INSTRUCTIONS failed (ec=%d)",dwErr);
    }
    
    return ERROR_SUCCESS;
}

// Initialize9x
//
// This is called to initialize the migration process.  See the migration dll
// spec for more details.
//
// Parameters:
//      Commented below.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
Initialize9x
(
    IN  LPCSTR WorkingDirectory,    // Place to store files.
    IN  LPCSTR SourceDirectories,   // Location of the Windows NT source.
    IN  LPCSTR MediaDirectory       // Path to the original media directory
)
{
    DEBUG_FUNCTION_NAME(_T("Initialize9x"));

    DebugPrintEx(DEBUG_MSG, "Working directory is %s", WorkingDirectory);
    DebugPrintEx(DEBUG_MSG, "Source directories is %s", SourceDirectories); //  will show only first ?
    DebugPrintEx(DEBUG_MSG, "Media directory is %s", MediaDirectory);

    InitializeInfFile(WorkingDirectory);
    strncpy(lpWorkingDir, WorkingDirectory, MAX_PATH);
    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateUser9x
//
// This routine records the fax information specific to a user.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateUser9x
(
    IN  HWND ParentWnd,           // Parent (if need a UI)
    IN  LPCSTR UnattendFile,      // Name of unattend file
    IN  HKEY UserRegKey,          // Key to this user's registry settings.
    IN  LPCSTR UserName,          // Account name of user.
    LPVOID Reserved
)
{
    TCHAR szProfileName[MAX_PATH]; // Holds the name of this user's profile.
    HKEY  hRegProfileKey;       // The fax profile key in the registry.
    DWORD dwExceptCode;         // Exception error code
    
    DEBUG_FUNCTION_NAME(_T("MigrateUser9x"));

    DebugPrintEx(DEBUG_MSG,"Unattend File is %s",UnattendFile);
    DebugPrintEx(DEBUG_MSG,"User Name is %s",UserName);

    __try 
    {
        // @@@ This function gets the name of the default MAPI profile for a user.
        if (GetUserProfileName(UserRegKey, szProfileName, sizeof(szProfileName))) 
        {
            DebugPrintEx(DEBUG_MSG,"Profile name = %s",szProfileName);
            // @@@ Given a key to a user, and the name of that user's MAPI profile
            // @@@ it will get a key to FAX service section of the MAPI profile in the registry
            if (GetRegProfileKey(UserRegKey, szProfileName, &hRegProfileKey)) 
            {
                // We now know we want to do an installation.
                DebugPrintEx(DEBUG_MSG,"Successfully got profile information.");
                _tcscpy(szNTProfileName, szProfileName); // Remember this name for NT.
                
                // NULL means the logon user...
                if (UserName != NULL)
                {
                    _tcscpy(szUserID, UserName); // Remember the ID for the unattend.txt file.
                }
                else
                {
                    _tcscpy(szUserID, lpLogonUser); // Use the logon user name.
                }
                
                // @@@ Writes user information out to the INF
                DumpUserInfo(hRegProfileKey, szUserID, szProfileName,UnattendFile);
                RegCloseKey(hRegProfileKey);
            } 
            else 
            {
                DebugPrintEx(DEBUG_WRN,"Could not get profile information.");
                return ERROR_NOT_INSTALLED;
            }
        } 
        else 
        {
            DebugPrintEx(DEBUG_WRN,"Could not find profile name.");
            return ERROR_NOT_INSTALLED;
        }
        return ERROR_SUCCESS;     // A very confused return value.
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        dwExceptCode = GetExceptionCode();
        switch(dwExceptCode) 
        {
          case EXCEPTION_ACCESS_VIOLATION:      DebugPrintEx(DEBUG_ERR,"Access violation.");
                                                break;
          case EXCEPTION_INT_DIVIDE_BY_ZERO:
          case EXCEPTION_FLT_DIVIDE_BY_ZERO:    DebugPrintEx(DEBUG_ERR,"Divide by zero.");
                                                break;
          default:                              DebugPrintEx(DEBUG_ERR,"Unhandled exception.");
                                                break;
        }
        return ERROR_SUCCESS;
    }
}


// MigrateSystem9x
//
// This routine copies system-wide settings.
// It also takes care of writing the [Fax] section of the unattend file.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateSystem9x
(
    IN  HWND ParentWnd,           // Parent for UI.
    IN  LPCSTR UnattendFile,      // Name of unattend file
    LPVOID Reserved
)
{
    DWORD   dwReturn        = NO_ERROR;
    bool    bSBS50Client    = false;
    bool    bXPDLClient     = false;

    DEBUG_FUNCTION_NAME(_T("MigrateSystem9x"));

    //
    //  Check if SBS 5.0 Client / Windows XP Down Level Client are present
    //
    dwReturn = CheckInstalledFax(&bSBS50Client, &bXPDLClient, NULL);
    if (dwReturn != NO_ERROR)
    {
        DebugPrintEx(DEBUG_WRN, _T("CheckSBS50Install() failed, ec=%ld. Suppose that nothing is installed."), dwReturn);
    }

    //
    //  if any of these applications are found on the machine, 
    //      the upgrade will be blocked through MigDB.inf
    //      and the user will be required to uninstall them.
    //
    //  but we want to remember the fact that they were present on the machine.
    //      we do it by writting to the registry.
    //      after the upgrade will be restarted, we put this data into the unattended file,
    //      and by this FaxOcm gets this data.
    //
    if (bSBS50Client || bXPDLClient)
    {
        dwReturn = RememberInstalledFax(bSBS50Client, bXPDLClient);
        if (dwReturn != NO_ERROR)
        {
            DebugPrintEx(DEBUG_WRN, _T("RememberInstalledFax() failed, ec=%ld."), dwReturn);
        }
        else
        {
            DebugPrintEx(DEBUG_MSG, _T("RememberInstalledFax() succeded."));
        }

        //
        //  we can go out ==> Upgrade will be blocked anyway.
        //
        return ERROR_SUCCESS;
    }

    //
    //  Any of the applications is not installed. 
    //  Check if they were here before. If yes, then write this fact to the unattended file.
    //
    bool    bFaxWasInstalled = false;
    dwReturn = MigrateUninstalledFax(UnattendFile, &bFaxWasInstalled);
    if (dwReturn != NO_ERROR)
    {
        DebugPrintEx(DEBUG_WRN, _T("MigrateUninstalledFax() failed, ec=%ld."), dwReturn);
    }

    //
    // If SBS 5.0 Client or AWF is installed, we need to set FAX=ON in Unattended.txt
    //
    BOOL    bAWFInstalled = IsAWFInstalled();

    if (bFaxWasInstalled || bAWFInstalled)
    {
        //
        // force installation of the Fax component in Whistler.
        //
        if (!WritePrivateProfileString("Components", UNATTEND_FAX_SECTION, "ON", UnattendFile))
        {
            DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString Components failed (ec=%d)",GetLastError());
        }
        else
        {
            DebugPrintEx(DEBUG_MSG, _T("Set FAX=ON in UnattendFile."));
        }
    }
    else
    {
        DebugPrintEx(DEBUG_WRN, _T("Neither AWF not SBS 50 or XP DL Client is installed."));
        return ERROR_NOT_INSTALLED;
    }

    if (bAWFInstalled)
    {
        //
        //  Continue Migration of AWF
        //
        if (MigrateDevices9X(UnattendFile)!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,"MigrateDevices9X failed (ec=%d)",GetLastError());
        }

        if (CopyCoverPageFiles9X()!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,"CopyCoverPageFiles9X failed (ec=%d)",GetLastError());
        }
    }

    return ERROR_SUCCESS;         // A very confused return value.
}


// ------------------------------------------------------------
// Auxiliary functions

// GetUserProfileName
//
// This function gets the name of the default MAPI profile for a user.
//
// Parameters:
//      hUser                   Pointer to the HKCU equivalent in setup.
//      lpProfName              Pointer to buffer that will hold the profile name.
//      cbSize                  Size of said buffer.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static
BOOL
GetUserProfileName(HKEY hUser, LPTSTR lpProfName, DWORD cbSize)
{
    LONG lResult;               // Result of API calls.
    HKEY hUserProf;             // Key to the user profile section.
    DWORD dwType;               // Holds the type of the data.

    DEBUG_FUNCTION_NAME(_T("GetUserProfileName"));

    lResult = RegOpenKeyEx( hUser,                  // Opening a user key...
                            LPUSERPROF,             // This section of the registry...
                            0,                      // Reserved; must be 0.
                            KEY_READ,               // Read permission,
                            &hUserProf);            // Store the key here.
    if (lResult!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",LPUSERPROF,GetLastError());
        return FALSE; // We failed.
    }
    lResult = RegQueryValueEx(  hUserProf,              // The key to the registry.
                                LPPROFNAME,             // Name of the value I want.
                                NULL,                   // Reserved.
                                &dwType,                // Holds the type.
                                LPBYTE(lpProfName),     // Holds the profile name.
                                &cbSize);               // Size of the buffer.
    if (lResult!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegQueryValueEx %s failed (ec=%d)",LPPROFNAME,GetLastError());
    }
                                
    RegCloseKey(hUserProf);     // Remember to close the key!!
    return (lResult==ERROR_SUCCESS);
}


// GetRegProfileKey
//
// OK, this is a horrible routine.  Given a key to a user, and the name of
// that user's MAPI profile, it will get a key to FAX service section of the
// MAPI profile in the registry.  The advantage of this is I can get MAPI properties
// (such as user name, fax number, etc.) without using MAPI routines --
// they come straight from the registry.  But still, it seems like an awful
// hack.  I cringe.  You can see me cringe in the comments below.
//
// Parameters:
//      hUser                   The HKCU equivalent for setup.
//      lpProfName              Name of the user's default profile.
//      phRegProfileKey         (OUT) Pointer to the FAX section of the MAPI profile.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static BOOL
GetRegProfileKey(HKEY hUser, LPTSTR lpProfName, PHKEY phRegProfileKey)
{
    HKEY    hProfiles                   = NULL;
    HKEY    hUserProf                   = NULL;
    UINT    iIndex                      = 0;           
    DWORD   dwErr                       = ERROR_SUCCESS;
    TCHAR   szProfileName[MAX_PATH+1]   = {0};
    DWORD   dwType                      = 0;
    BYTE    abData[MAX_PATH]            = {0};
    DWORD   cbData                      = 0;     

    DEBUG_FUNCTION_NAME(_T("GetRegProfileKey"));

    dwErr = RegOpenKeyEx(   hUser,                  // Opening a user key...
                            LPPROFILES,             // This section of the registry...
                            0,                      // Reserved; must be 0.
                            KEY_READ,               // Read permission,
                            &hProfiles);
    if (dwErr!=ERROR_SUCCESS) 
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",LPPROFILES,dwErr);
        goto exit;
    }

    dwErr = RegOpenKeyEx(   hProfiles,              // Opening a user key...
                            lpProfName,             // This section of the registry...
                            0,                      // Reserved; must be 0.
                            KEY_READ,               // Read permission,
                            &hUserProf);
    if (dwErr!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",lpProfName,dwErr);
        goto exit;
    }

    // enumerate all subkeys and find the one that belongs to our transport provider
    while (dwErr!=ERROR_NO_MORE_ITEMS)
    {
        // get one subkey
        dwErr = RegEnumKey(hUserProf,iIndex++,szProfileName,MAX_PATH+1);
        if (dwErr!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,"RegEnumKey failed (ec=%d)",dwErr);
            goto exit;
        }
        // open it
        dwErr = RegOpenKeyEx(hUserProf,szProfileName,0,KEY_READ,phRegProfileKey);
        if (dwErr!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",szProfileName,dwErr);
            goto exit;
        }

        cbData = sizeof(abData); // Reset the size.
        dwErr = RegQueryValueEx((*phRegProfileKey),            
                                "001E300A",          
                                NULL,               
                                &dwType,            
                                abData,             
                                &cbData);           

        if (dwErr==ERROR_SUCCESS)
        {
            if (strcmp((char*)abData,"awfaxp.dll")==0)
            {
                // found it
                DebugPrintEx(DEBUG_MSG,"Found our Transport provider");
                goto exit;
            }
        }
        else if (dwErr!=ERROR_FILE_NOT_FOUND)
        {
            DebugPrintEx(DEBUG_ERR,"RegQueryValueEx failed (ec=%d)",dwErr);
            RegCloseKey((*phRegProfileKey));
            goto exit;
        }

        dwErr = ERROR_SUCCESS;

        RegCloseKey((*phRegProfileKey));
    }

exit:
    if (hUserProf)
    {
        RegCloseKey(hUserProf);
    }
    if (hProfiles)
    {
        RegCloseKey(hProfiles); 
    }
    return (dwErr==ERROR_SUCCESS);
}

#define PR_NUMBER_OF_RETRIES        0x45080002
#define PR_TIME_BETWEEN_RETRIES     0x45090002

// DumpUserInfo
//
// Writes user information out to 'faxuser.ini'.
//
// Parameters:
//      hUserInfo               Pointer to the fax section of the user's profile.
//      UserName                the user ID of this user.
//      szProfileName           The MAPI profile name the user uses.
//
// Returns:
//      Nothing.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static void
DumpUserInfo(HKEY hUserInfo, LPCSTR UserName, LPTSTR szProfileName,IN LPCSTR UnattendFile)
{
        // Types
    typedef struct tagUSERINFO {
        DWORD dwPropID;         // Property ID
        LPTSTR szDescription;
    } USERINFO;

        // Data
    USERINFO auiProperties[] = 
    {
        { PR_POSTAL_ADDRESS,            TEXT("Address")             },
        { PR_COMPANY_NAME,              TEXT("Company")             },
        { PR_DEPARTMENT_NAME,           TEXT("Department")          },
        { PR_SENDER_EMAIL_ADDRESS,      TEXT("FaxNumber")           },
        { PR_SENDER_NAME,               TEXT("FullName")            },
        { PR_HOME_TELEPHONE_NUMBER,     TEXT("HomePhone")           },
        { PR_OFFICE_LOCATION,           TEXT("Office")              },
        { PR_OFFICE_TELEPHONE_NUMBER,   TEXT("OfficePhone")         },
        { PR_TITLE,                     TEXT("Title")               },
        { PR_NUMBER_OF_RETRIES,         TEXT("NumberOfRetries")     },
        { PR_TIME_BETWEEN_RETRIES,      TEXT("TimeBetweenRetries")  },
    };
    TCHAR szPropStr[9];         // DWORD == 32 bits == 4 bytes == 8 hex digits + 1 null
    UINT  iCount;               // Loop counter.
    UINT  iMax;                 // Largest property number.
    DWORD dwType;               // Type of registry data
    DWORD dwCount;
    BYTE  abData[256];          // Data buffer.
    DWORD cbData;               // Size of the data buffer.
    LONG  lResult;              // Result of API call.
    INT  i;                     // Loop counter.
    TCHAR szUserBuf[9];         // used for annotating INF file.
    TCHAR szBinaryBuf[MAX_PATH];
    TCHAR* pszSeperator = NULL;

    DEBUG_FUNCTION_NAME(_T("DumpUserInfo"));

    // Note that we're dumping this user's information.
    _stprintf(szUserBuf, "USER%04d", dwUserCount++);
    if (!WritePrivateProfileString( TEXT("Users"),
                                    szUserBuf,
                                    UserName,
                                    szInfFileName))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
    }

        // Write the MAPI profile name.
    if (!WritePrivateProfileString( TEXT(UserName),         // this works???
                                    TEXT("MAPI"),
                                    szProfileName,
                                    szInfFileName))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
    }
        
    iMax = sizeof(auiProperties) / sizeof(USERINFO);
    DebugPrintEx(DEBUG_MSG,"There are %d properties.",iMax);
    for (iCount = 0; iCount < iMax; iCount++) 
    {
        _stprintf(szPropStr, TEXT("%0*x"), 8, SWAPWORD(auiProperties[iCount].dwPropID));
        cbData = sizeof(abData); // Reset the size.
        lResult = RegQueryValueEx(  hUserInfo,          // Get info from this key...
                                    szPropStr,          // using this name.
                                    NULL,               // reserved.
                                    &dwType,            // Will store the data type.
                                    abData,             // Data buffer.
                                    &cbData);           // Size of data buffer.
        if (lResult==ERROR_SUCCESS) 
        {
            // TODO: handle more data types!
            if (_tcscmp(auiProperties[iCount].szDescription, TEXT("FullName")) == 0) 
            {
                // We've got the full name.  Remember this for the unattend.txt
                // file.
                _tcscpy(szUserName, LPTSTR(abData));
            }
            switch(dwType) 
            {
              case REG_SZ:
                if (_tcscmp(auiProperties[iCount].szDescription, TEXT("FaxNumber")) == 0) 
                {
                    if (pszSeperator = _tcsrchr(LPTSTR(abData),_T('@')))
                    {
                        // found a '@', treat everything after it as the phone number
                        // everything before it is the mailbox.
                        *pszSeperator = _T('\0');
                        if (!WritePrivateProfileString( TEXT(UserName),
                                                        TEXT("Mailbox"),
                                                        LPCSTR(abData),
                                                        szInfFileName)) 
                        {
                            DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
                        }
                        if (!WritePrivateProfileString( TEXT(UserName),
                                                        TEXT("FaxNumber"),
                                                        _tcsinc(pszSeperator), // Print what was after the '@'.
                                                        szInfFileName
                                                        )) 
                        {
                            DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
                        }
                        break;
                    }
                    else
                    {
                        // no '@' found, which means everything is the phone number.
                        DebugPrintEx(DEBUG_MSG,"No mailbox was found in this profile");
                        // fallthrough will write the fax number to the INF...
                    }
                }// if
                // Replace '\n' characters in the string with semicolons.
                i = 0;
                while(abData[i] != _T('\0')) 
                {
                    if((abData[i] == _T('\n')) || (abData[i] == _T('\r')))
                    {
                        abData[i] = _T(';');
                    }
                    i++;
                }
                if (!WritePrivateProfileString( TEXT(UserName),
                                                auiProperties[iCount].szDescription,
                                                LPCSTR(abData),
                                                szInfFileName
                                                )) 
                {
                    DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
                }
                DebugPrintEx(DEBUG_MSG,"%s = %s",auiProperties[iCount].szDescription,abData);
                break;

              case REG_BINARY:
                // The data is just free-form binary.  Print it one byte at a time.
                DebugPrintEx(DEBUG_MSG,"%s = ",auiProperties[iCount].szDescription);
                memset(szBinaryBuf,0,sizeof(szBinaryBuf));
                dwCount = 0;
                for (i=cbData-1;i>=0;i--)
                {
                    DebugPrintEx(DEBUG_MSG,"%0*d",2,abData[i]);
                    dwCount += sprintf(szBinaryBuf+dwCount,"%0*d",2,abData[i]);
                }
                // write to INF
                if (!WritePrivateProfileString( UNATTEND_FAX_SECTION,
                                                auiProperties[iCount].szDescription,
                                                szBinaryBuf,
                                                UnattendFile
                                                )) 
                {
                    DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
                }
                break;

              default:
                DebugPrintEx(   DEBUG_WRN,
                                "Unknown data type (%d) for property '%s'.",
                                 dwType,
                                 auiProperties[iCount].szDescription);
            }
        } 
        else 
        {
            DebugPrintEx(DEBUG_ERR,"Could not get property '%s'.",auiProperties[iCount].szDescription);
        }
    }
}

// SetGlobalFaxNumberInfo
//
// This routine sets the global variables 'szFaxAreaCode' and 'szFaxNumber' based on
// the value in szPhone.  It expects szPhone to be in the following format:
//
//      [[<country code>] '(' <area code> ')'] <phone number>
//
// (Brackets denote something optional.  Literals are in single quotes, non-terminals are
// in angle brackets.  Note that if there's a country code, there must be an area code.)
//
// Parameters:
//      szPhone                 Described above.
//
// Returns:
//      Nothing.
//
// Side effects:
//      Sets the values of szFaxAreaCode and szFaxNumber.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-24
static void
SetGlobalFaxNumberInfo(LPCTSTR szPhone)
{
    UINT i;                     // Loop index.
    UINT j;                     // Loop index.

    // First, look through the string for an area code.
    i = 0;
    while ((szPhone[i] != _T('\0')) && (szPhone[i] != _T('(')))
    {
        i++;
    }
    if(szPhone[i] == _T('(')) 
    {
            // We've found an area code!
            // are all area codes at most 3 digits??  I sized the buffer to 16, but this will
            // still AV on a badly-formed #.
        i++;
        j=0;
        while(szPhone[i] != _T(')')) 
        {
            szFaxAreaCode[j] = szPhone[i];
            i++;
            j++;
        }
        i++;
            // szPhone[i] should now immediately after the ')' at the end
            // of the area code.  Everything from here on out is a phone number.
        while(_istspace(szPhone[i])) 
        {
            i++;
        }
    } 
    else 
    {
            // If we're here, there was no area code.  We need to rewind either to
            // the beginning of the string or to the first whitespace.
        while(!_istspace(szPhone[i]))
        {
            i--;
        }
        i++;                    // The loop always rewinds one too far.
    }

    // ASSERT:  We're now ready to begin copying from szPhone to
    // szFaxNumber.
    j = 0;
    while(szPhone[i] != '\0') 
    {
        szFaxNumber[j] = szPhone[i];
        i++;
        j++;
    }
}


// InitializeInfFile
//
// This routine writes out the [Version] section of the inf file.
//
// Parameters:
//      None.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Side effects:
//      Generates a fully-qualified file name in szInfFileName.  Currently, that's
//      given by <windows dir>\<base file name>.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-5
static BOOL
InitializeInfFile(LPCTSTR WorkingDirectory)
{
    TCHAR szWindowsPath[MAX_PATH]; // This will hold the path to the windows directory.
    DWORD cbPathSize = sizeof(szWindowsPath);
    TCHAR szDriveLetter[2];      // Will hold the drive letter.
    
    DEBUG_FUNCTION_NAME(_T("InitializeInfFile"));

    // First, fully qualify the file name.
    if (!GetWindowsDirectory(szWindowsPath, cbPathSize)) 
    {
        DebugPrintEx(DEBUG_ERR,"GetWindowsDirectory failed (ec=%d)",GetLastError());
        return FALSE;           // It must be serious if that system call failed.
    }
    szDriveLetter[0] = szWindowsPath[0];
    szDriveLetter[1] = 0;
    _stprintf(szInfFileName, TEXT("%s\\%s"), WorkingDirectory, szInfFileBase);

    DebugPrintEx(DEBUG_MSG,"Will store all information in INF file = '%s'",szInfFileName);

        // Now, put the version header on the inf file.
    if (!WritePrivateProfileString( TEXT("Version"),
                                    TEXT("Signature"),
                                    TEXT("\"$WINDOWS NT$\""),
                                    szInfFileName))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
    }
       // now, write out the amount of space we'll need.  Currently, we
       // just put the awdvstub.exe program in the SystemRoot directory.
       // Even w/ symbols, that's under 500K.  Report that.
    if (!WritePrivateProfileString( TEXT("NT Disk Space Requirements"),
                                    szDriveLetter,
                                    TEXT("500000"),
                                    szInfFileName))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString failed (ec=%d)",GetLastError());
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  MigrateDevices9X
//
//  Purpose:        Save the active device's settings in the INF
//                  Get the device info from the AWF key under HKLM
//
//  Params:
//                  IN LPCSTR UnattendFile - name of the answer file
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
static DWORD MigrateDevices9X(IN LPCSTR UnattendFile)
{
    DWORD       dwErr                           = ERROR_SUCCESS;
    HKEY        hKeyLocalModems                 = NULL;
    HKEY        hKeyGeneral                     = NULL;
    HKEY        hKeyActiveDevice                = NULL;
    CHAR        szActiveDeviceSection[MAX_PATH] = {0};
    CHAR        szLocalID[MAX_PATH]             = {0};
    CHAR        szAnswerMode[32]                = {0};
    CHAR        szNumRings[32]                  = {0};
    DWORD       cbSize                          = 0;
    DWORD       dwType                          = 0;

    DEBUG_FUNCTION_NAME(_T("MigrateDevices9X"));

    // get the active device's settings
    // open HLKM\Software\Microsoft\At Work Fax\Local Modems
    dwErr = RegOpenKeyEx(   HKEY_LOCAL_MACHINE,
                            REG_KEY_AWF_LOCAL_MODEMS,
                            0,
                            KEY_READ,
                            &hKeyLocalModems);
    if (dwErr!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",REG_KEY_AWF_LOCAL_MODEMS,dwErr);
        goto exit;
    }
    // open the 'general' sub key
    dwErr = RegOpenKeyEx(   hKeyLocalModems,
                            "General",
                            0,
                            KEY_READ,
                            &hKeyGeneral);
    if (dwErr!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx General failed (ec=%d)",dwErr);
        goto exit;
    }
    // get the LocalID REG_SZ, this will be used as the TSID and CSID
    cbSize = sizeof(szLocalID);
    dwErr = RegQueryValueEx(    hKeyGeneral,              
                                INF_RULE_LOCAL_ID, 
                                NULL,                  
                                &dwType,               
                                LPBYTE(szLocalID),            
                                &cbSize);              
    if (dwErr==ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,"RegQueryValueEx LocalID returned %s",szLocalID);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"RegQueryValueEx LocalID failed (ec=%d)",dwErr);
        goto exit;
    }
    // write the TSID & CSID entry in the Fax section of unattended.txt
    if (!WritePrivateProfileString( UNATTEND_FAX_SECTION,
                                    INF_RULE_LOCAL_ID,
                                    szLocalID,
                                    UnattendFile))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString TSID failed (ec=%d)",GetLastError());
    }
    // get the ActiveDeviceSection REG_SZ
    cbSize = sizeof(szActiveDeviceSection);
    dwErr = RegQueryValueEx(    hKeyGeneral,              
                                "ActiveDeviceSection", 
                                NULL,                  
                                &dwType,               
                                LPBYTE(szActiveDeviceSection),            
                                &cbSize);              
    if (dwErr==ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,"RegQueryValueEx ActiveDeviceSection returned %s",szActiveDeviceSection);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"RegQueryValueEx ActiveDeviceSection failed (ec=%d)",dwErr);
        goto exit;
    }
    // open HLKM\Software\Microsoft\At Work Fax\Local Modems\ "ActiveDeviceSection"
    dwErr = RegOpenKeyEx(   hKeyLocalModems,
                            szActiveDeviceSection,
                            0,
                            KEY_READ,
                            &hKeyActiveDevice);
    if (dwErr!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,"RegOpenKeyEx %s failed (ec=%d)",szActiveDeviceSection,dwErr);
        goto exit;
    }
    // get the AnswerMode REG_SZ value,
    // 0 - Don't answer
    // 1 - Manual
    // 2 - Answer after x rings.
    cbSize = sizeof(szAnswerMode);
    dwErr = RegQueryValueEx(    hKeyActiveDevice,              
                                INF_RULE_ANSWER_MODE, 
                                NULL,                  
                                &dwType,               
                                LPBYTE(szAnswerMode),            
                                &cbSize);              
    if (dwErr==ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,"RegQueryValueEx AnswerMode returned %s",szAnswerMode);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"RegQueryValueEx AnswerMode failed (ec=%d)",dwErr);
        goto exit;
    }
    if (!WritePrivateProfileString( UNATTEND_FAX_SECTION,
                                    INF_RULE_ANSWER_MODE,
                                    szAnswerMode,
                                    UnattendFile))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString Receive failed (ec=%d)",GetLastError());
    }
    // get the NumRings REG_SZ value,
    cbSize = sizeof(szNumRings);
    dwErr = RegQueryValueEx(    hKeyActiveDevice,              
                                INF_RULE_NUM_RINGS, 
                                NULL,                  
                                &dwType,               
                                LPBYTE(szNumRings),            
                                &cbSize);              
    if (dwErr==ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,"RegQueryValueEx NumRings returned %s",szNumRings);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"RegQueryValueEx NumRings failed (ec=%d)",dwErr);
        goto exit;
    }
    if (!WritePrivateProfileString( UNATTEND_FAX_SECTION,
                                    INF_RULE_NUM_RINGS,
                                    szNumRings,
                                    UnattendFile))
    {
        DebugPrintEx(DEBUG_ERR,"WritePrivateProfileString NumRings failed (ec=%d)",GetLastError());
    }

exit:
    if (hKeyLocalModems)
    {
        RegCloseKey(hKeyLocalModems);
    }
    if (hKeyActiveDevice)
    {
        RegCloseKey(hKeyActiveDevice);
    }
    if (hKeyGeneral)
    {
        RegCloseKey(hKeyGeneral);
    }

    return dwErr;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  CopyCoverPageFiles9X
//
//  Purpose:        Copy all of the *.CPE files from %windir% to the temporary 
//                  directory for our migration
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
DWORD CopyCoverPageFiles9X()
{
    DWORD           dwErr                   = ERROR_SUCCESS;
    CHAR            szWindowsDir[MAX_PATH]  = {0};
    SHFILEOPSTRUCT  fileOpStruct;

    DEBUG_FUNCTION_NAME(_T("CopyCoverPageFiles9X"));

    ZeroMemory(&fileOpStruct, sizeof(SHFILEOPSTRUCT));

    // Get the windows directory
    if (!GetWindowsDirectory(szWindowsDir, MAX_PATH))
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,"GetWindowsDirectory failed (ec=%d)",dwErr);
        goto exit;
    }

    //
    // Copy *.cpe from windows-dir to temp-dir
    //
    strcat(szWindowsDir,"\\*.cpe");

    fileOpStruct.hwnd =                     NULL; 
    fileOpStruct.wFunc =                    FO_COPY;
    fileOpStruct.pFrom =                    szWindowsDir; 
    fileOpStruct.pTo =                      lpWorkingDir;
    fileOpStruct.fFlags =                   

        FOF_FILESONLY       |   // Perform the operation on files only if a wildcard file name (*.*) is specified. 
        FOF_NOCONFIRMMKDIR  |   // Do not confirm the creation of a new directory if the operation requires one to be created. 
        FOF_NOCONFIRMATION  |   // Respond with "Yes to All" for any dialog box that is displayed. 
        FOF_NORECURSION     |   // Only operate in the local directory. Don't operate recursively into subdirectories.
        FOF_SILENT          |   // Do not display a progress dialog box. 
        FOF_NOERRORUI;          // Do not display a user interface if an error occurs. 

    fileOpStruct.fAnyOperationsAborted =    FALSE;
    fileOpStruct.hNameMappings =            NULL;
    fileOpStruct.lpszProgressTitle =        NULL; 

    DebugPrintEx(DEBUG_MSG, 
             TEXT("Calling to SHFileOperation from %s to %s."),
             fileOpStruct.pFrom,
             fileOpStruct.pTo);
    if (SHFileOperation(&fileOpStruct))
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,"SHFileOperation failed (ec: %ld)",dwErr);
        goto exit;
    }


exit:
    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsAWFInstalled
//
//  Purpose:        
//                  Check if AWF is installed
//
//  Params:
//                  None
//
//  Return Value:
//                  TRUE    - AWF is installed
//                  FALSE   - AWF not installed or an error occured error
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
static BOOL IsAWFInstalled()
{
    HKEY    hKey    = NULL;
    DWORD   dwErr   = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(_T("IsAWFInstalled"));

    dwErr = RegOpenKeyEx(   HKEY_LOCAL_MACHINE,
                            REG_KEY_AWF_INSTALLED,
                            0,
                            KEY_READ,
                            &hKey);
    if (dwErr!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,"RegOpenKeyEx %s failed (ec=%d), assume AWF is not installed",REG_KEY_AWF_LOCAL_MODEMS,dwErr);
        return FALSE;
    }

    RegCloseKey(hKey);
    DebugPrintEx(DEBUG_MSG,"AWF is installed");

    return TRUE;
}

static DWORD RememberInstalledFax(
    bool bSBSClient, 
    bool bXPDLClient
)
/*++

Routine name : RememberInstalledFax

Routine description:

    for each parameter that is True, write to the registry that this app is installed.

Author:

	Iv Garber (IvG),	May, 2001

Return Value:

    Success or Failure code.

--*/
{
    DWORD   dwReturn    = NO_ERROR;
    DWORD   dwValue     = FXSTATE_UPGRADE_APP_NONE;
    HKEY    hKey        = NULL;        

    DEBUG_FUNCTION_NAME(_T("RememberInstalledFax"));

    //
    //  check parameters 
    //
    if (!bSBSClient && !bXPDLClient)
    {
        DebugPrintEx(DEBUG_MSG, _T("No Fax application is installed -> Upgrade will not be blocked."));
        return dwReturn;
    }

    //
    //  create value to store
    //
    if (bSBSClient)
    {
        dwValue |= FXSTATE_UPGRADE_APP_SBS50_CLIENT;
    }
    if (bXPDLClient)
    {
        dwValue |= FXSTATE_UPGRADE_APP_XP_CLIENT;
    }

    //
    //  Create Registry Key
    //
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEYUPG_INSTALLEDFAX, TRUE, KEY_SET_VALUE);
    if (!hKey)
    {
        dwReturn = GetLastError();
        DebugPrintEx(
            DEBUG_WRN, 
            _T("OpenRegistryKey( ' %s ' ) failed, ec = %ld. Cannot remember installed fax apps."), 
            REGKEYUPG_INSTALLEDFAX, 
            dwReturn);
        return dwReturn;
    }

    //
    //  store the value in the Registry
    //
    if (!SetRegistryDword(hKey, NULL, dwValue))
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("SetRegistryDword( ' %ld ' ) failed, ec = %ld."), dwValue, dwReturn);
    }

    RegCloseKey(hKey);
    return dwReturn;

}

static DWORD MigrateUninstalledFax(
    IN  LPCTSTR lpctstrUnattendFile,
    OUT bool    *pbFaxWasInstalled
)
/*++

Routine name : MigrateUninstalledFax

Routine description:

    Put the data about Fax Applications that were installed on the machine before upgrade,
        from the Registry to the Unattended file, to be used by FaxOCM.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

	lpctstrUnattendFile [in]    - name of the answer file to write the data to
    pbFaxWasInstalled   [out]   - address of a bool variable to receive True if SBS 5.0 /XPDL Client was installed
                                        on the machine before the upgrade, otherwise False.

Return Value:

    Success or Failure code.

--*/
{
    DWORD   dwReturn    = NO_ERROR;
    HKEY    hKey        = NULL;
    DWORD   dwValue     = FXSTATE_UPGRADE_APP_NONE;
    TCHAR   szValue[10] = {0};

    DEBUG_FUNCTION_NAME(_T("MigrateUninstalledFax"));

    if (pbFaxWasInstalled)
    {
        *pbFaxWasInstalled = false;
    }

    //
    //  Open a key
    //
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEYUPG_INSTALLEDFAX, FALSE, KEY_QUERY_VALUE);
    if (!hKey)
    {
        dwReturn = GetLastError();
        DebugPrintEx(
            DEBUG_MSG, 
            _T("OpenRegistryKey( ' %s ' ) failed, ec = %ld. No Fax was installed before the upgrade."),
            REGKEYUPG_INSTALLEDFAX, 
            dwReturn);

        if (dwReturn == ERROR_FILE_NOT_FOUND)
        {
            //
            //  This is not real error
            //
            dwReturn = NO_ERROR;
        }
        return dwReturn;
    }

    //
    //  Read the data 
    //
    dwReturn = GetRegistryDwordEx(hKey, NULL, &dwValue);
    if (dwReturn != ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_WRN, _T("GetRegistryDwordEx() failed, ec = %ld."), dwReturn);
        goto CloseRegistry;
    }

    if (pbFaxWasInstalled)
    {
        *pbFaxWasInstalled = true;
    }

    DebugPrintEx(DEBUG_MSG, _T("Found uninstalled fax apps : %ld"), dwValue);

    //
    //  Convert dwValue to String
    //
    _itot(dwValue, szValue, 10);

    //
    //  write szValue to the unattended file
    //
    if (!WritePrivateProfileString(
        UNATTEND_FAX_SECTION, 
        UNINSTALLEDFAX_INFKEY,
        szValue,
        lpctstrUnattendFile))
    {
        dwReturn = GetLastError();
        DebugPrintEx(
            DEBUG_ERR, 
            _T("WritePrivateProfileString(FaxApps = ' %s ') failed (ec=%d)"), 
            szValue,
            dwReturn);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR, 
            _T("WritePrivateProfileString(FaxApps = ' %s ') OK."), 
            szValue);
    }

CloseRegistry:

    RegCloseKey(hKey);
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\autorel.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    autorel.h

Abstract:

    Some classes for automatically releasing resources.

Author:

    Boaz Feldbaum (BoazF) 26-Jun-1997

Revision History:

--*/

#ifndef __AUTOREL_H
#define __AUTOREL_H

class CAutoCloseFileHandle
{
public:
    CAutoCloseFileHandle(HANDLE h =INVALID_HANDLE_VALUE) { m_h = h; };
    ~CAutoCloseFileHandle() { if (m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); };

public:
    CAutoCloseFileHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseHandle
{
public:
    CAutoCloseHandle(HANDLE h =NULL) { m_h = h; };
    ~CAutoCloseHandle() { if (m_h) CloseHandle(m_h); };

public:
    CAutoCloseHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseRegHandle
{
public:
    CAutoCloseRegHandle(HKEY h =NULL) { m_h = h; };
    ~CAutoCloseRegHandle() { if (m_h) RegCloseKey(m_h); };

public:
    CAutoCloseRegHandle & operator =(HKEY h) { m_h = h; return(*this); };
    HKEY * operator &() { return &m_h; };
    operator HKEY() { return m_h; };

private:
    HKEY m_h;
};

class CAutoFreeLibrary
{
public:
    CAutoFreeLibrary(HINSTANCE hLib =NULL) { m_hLib = hLib; };
    ~CAutoFreeLibrary() { if (m_hLib) FreeLibrary(m_hLib); };

public:
    CAutoFreeLibrary & operator =(HINSTANCE hLib) { m_hLib = hLib; return(*this); };
    HINSTANCE * operator &() { return &m_hLib; };
    operator HINSTANCE() { return m_hLib; };

private:
    HINSTANCE m_hLib;
};

#endif // __AUTOREL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\autoptrs.h ===
//
//	Auto Pointers
//

#ifndef _AUTO_PTR_H
#define _AUTO_PTR_H

#include <tchar.h>
#include <testruntimeerr.h>

///////////////////////////event //////////////////////////////

class Event_t
{
 public:
 Event_t(LPSECURITY_ATTRIBUTES lpEventAttributes, 
         BOOL fManualReset,
         BOOL fInitialState,
         LPCTSTR lpName );

   
 virtual ~Event_t();
 HANDLE get()const {return  m_hEvent;}

private:
HANDLE m_hEvent;
};

inline Event_t::Event_t(LPSECURITY_ATTRIBUTES lpEventAttributes, 
                        BOOL fManualReset,
                        BOOL fInitialState,
                        LPCTSTR lpName )

{
	m_hEvent = CreateEvent(lpEventAttributes,fManualReset,fInitialState,lpName);
	if(m_hEvent  == NULL)
	{
		THROW_TEST_RUN_TIME_WIN32(GetLastError(),TEXT("could not create event"));   
	}
}

inline Event_t::~Event_t()
{
	m_hEvent ? CloseHandle(m_hEvent) : NULL;
}

#endif // _AUTO_PTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\cbstr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cbstr.h

Abstract:
    Useful template for CBSTR

Author:
    Erez Haba (erezh) 11-Mar-96

Revision History:
    Stolen for CRM test

--*/

#ifndef _CBSTR_H
#define _CBSTR_H

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//

class CBSTR {
private:
    BSTR m_s;

public:
    CBSTR() : m_s(0)        {}
    CBSTR(BSTR s) : m_s(s)  {}
    ~CBSTR()                { if (m_s) SysFreeString(m_s); }
    operator BSTR() const   { return m_s; }
    BSTR * operator&()      { return &m_s;}
    CBSTR &operator=(BSTR s){ m_s = s; return *this; }
    BSTR detach()           { BSTR t = m_s; m_s = NULL; return t; }
};


#endif // _CBSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxcompport.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxCompPort.h
// Author:		Sigalit Bar (sigalitb)
// Date:		16-Aug-98
//

//
// Description:
//		This file contains the description of 
//		class CFaxCompletionPort which is designed 
//		to represent the I\O Completion Port used
//		by the NT5.0 Fax Service Queue.
//
//		The class calls the NT5.0 Fax Service API
//		FaxInitializeEventQueue() with the local
//		server and a completion port, thus causing
//		the server to post every FAX_EVENT that is
//		generated to the completion port.
//		To examine the FAX_EVENTs posted use
//		GetQueuedCompletionStatus with the port HANDLE
//		returned from CFaxCompletionPort::GetCompletionPortHandle()
//

#ifndef _FAX_COMP_PORT_H_
#define _FAX_COMP_PORT_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>
#include "streamEx.h"
#include "CometFax.h"



class CFaxCompletionPort
{
public:
	CFaxCompletionPort();
	~CFaxCompletionPort(void);


	//
	// GetCompletionPortHandle:
	//	Creates an I\O completion port and "connects" it
	//	to the local NT5.0 Fax Server.
	//
	// Arguments:
	//	szMachineName		IN parameter.
	//						The machine on which the Fax Server is located.
	//
	//  hComPortHandle		OUT parameter
	//						If the function returned TRUE then this
	//						parameter holds the I\O completion port
	//						handle.
	//						If the function returned FALSE this 
	//						parameter is NULL.
	//
	//  dwLastError			OUT parameter.
	//						If the function returned TRUE then this
	//						parameter is ERROR_SUCCESS (0).
	//						If the function returned FALSE then this
	//						parameter holds the last error.
	//
	// Return Value:
	//	TRUE if successful otherwise FALSE.
	//
	// Note:
	//	Only one I\O completion port can be "connected" to
	//	the Fax Server Queue (due to a limitation of the
	//	API FaxInitializeEventQueue), so the first time this
	//	function is called, a completion port is created and
	//	FaxInitializedEventQueue is called. The created port 
	//	is stored in the private member m_hCompletionPort.
	//	Subsequent calls to this function return m_hCompletionPort.
	//
	BOOL GetCompletionPortHandle(
			LPCTSTR		/* IN */	szMachineName,
			HANDLE&		/* OUT */	hComPortHandle, 
			DWORD&		/* OUT */	dwLastError
			);

private:

	//The I\O Completion Port "connected" to the Fax Server Queue.
	HANDLE	m_hCompletionPort;
	HANDLE	m_hServerEvents;

};


#endif //_FAX_COMP_PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxeventex.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEventEx.h
// Author:	Sigalit Bar (sigalitb)
// Date:		30-Jan-2000
//

//
// Description:
//	This file contains FAX_EVENT_EX (winfax.h) related functions.
//	These methods allow for easier printing of FAX_EVENT_EXs.
//


#ifndef _FAX_EVENT_EX_H_
#define _FAX_EVENT_EX_H_

#include <crtdbg.h>
#include <math.h>

#include <fxsapip.h>
#include "streamEx.h"


//
// CopyFaxExtendedEvent:
//	Creates a copy of SrcFaxEventEx in *pDstFaxEventEx
//	Note- this func allocates the memory for the copy, and the caller should free.
//
BOOL CopyFaxExtendedEvent(
	OUT	FAX_EVENT_EX**	pDstFaxEventEx, 
	IN	FAX_EVENT_EX	SrcFaxEventEx
	);

//
// FreeFaxExtendedEvent:
//	Frees all memory associated with pFaxEventEx
//
void FreeFaxExtendedEvent(
	IN	FAX_EVENT_EX*	pFaxEventEx
	);

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
// Parameters:
//	FaxEventEx	The FAX_EVENT_EX which the generated string will represent.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT_EX& /* IN */ FaxEventEx);
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT_EX& /* IN */ FaxEventEx);


///
//
// GetQueueStatusStr:
//	This func returns the ANSI string representation of dwQueueStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCSTR
GetQueueStatusStr(
	IN	const DWORD	dwQueueStatus
);

///
//
// GetQueueStatusTStr:
//	This func returns the TSTR string representation of dwQueueStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCTSTR
GetQueueStatusTStr(
	IN	const DWORD	dwQueueStatus
);

///
//
// GetExtendedStatusStr:
//	This func returns the ANSI string representation of dwExtendedStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCSTR
GetExtendedStatusStr(
	IN	const DWORD	dwExtendedStatus
);

///
//
// GetExtendedStatusTStr:
//	This func returns the TSTR string representation of dwExtendedStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCTSTR
GetExtendedStatusTStr(
	IN	const DWORD	dwExtendedStatus
);


//
//
// LogExtendedEvent:
//	Logs the extended event *pFaxEventEx using the Elle logger,
//	with severity=dwSeverity and log level=dwLevel
//
void
LogExtendedEvent(
	PFAX_EVENT_EX	/* IN */ pFaxEventEx,
	const DWORD		/* IN */ dwSeverity = LOG_X, 
	const DWORD		/* IN */ dwLevel = 9
);

#endif //_FAX_EVENT_EX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\cometfax.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		CometFax.h
// Author:			Sigalit Bar (sigalitb)
// Date:			28-Jul-98
//


//
// Description:
//	Using the NT5.0 Fax Service API this module exports some
//	tailored Fax related actions.
//
//	This module exports the ability to:
//	* Send a fax and collect FAX_EVENT information relating
//    to the Fax Service job that is executing the send.
//	* Abort a fax.
//	* Initialize the Fax Service queue in a way that allows
//	  "monitoring" any FAX_EVENTs generated.
//
//
//	The module uses the elle logger wraper implemented
//	in LogElle.c to log any fax related errors. 
//	Therefor the logger must be initialized before 
//	calling any of its methods.
//



#ifndef _COMET_FAX_H_
#define _COMET_FAX_H_


#include <stdio.h>
#include <windows.h>
#include <assert.h>
#include <crtdbg.h>
#include <math.h>
#include <log.h>
#include "SendInfo.h"
#include "FaxBroadcast.h"

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST

typedef struct _FAX_INFO {
    DWORD		dwFaxId;				// Fax session job id
    DWORDLONG   dwlMessageId;			// Extended Fax msg id (parent msg id for broadcast)
	DWORDLONG*	pdwlRecipientMessageIds;// recipient msg ids (for broadcast)
	DWORD		dwNumOfRecipients;		// number of recipients (for broadcast)
	DWORD		dwNumOfCompletedRecipients;		// number of recipients that completed successfully (for broadcast)
    DWORD		dwDeviceId;				// Current device of the fax job
    BOOL		bComplete;				// Indicates the fax job is complete
    BOOL		bPass;					// Indicates the fax job was successful
} FAX_INFO, *PFAX_INFO;

//
// Maximum time to wait on completion ports for a packet.
//
#define MAX_COMP_PORT_WAIT_TIME (60*60*1000)

//
// InitFaxQueue:
//	Initializes the Fax Service queue so that it will post
//	all FAX_EVENTs to an I\O completion port.
//
// Arguments:
//	szMachineName		IN parameter
//						Specifies the name of the machine on which
//						the Fax Service is located.
//						To specify local machine, pass NULL.
//
//  hComPortHandle		OUT parameter
//						If the function returned TRUE then this
//						parameter holds the I\O completion port
//						handle.
//						If the function returned FALSE this 
//						parameter is NULL.
//
//  dwLastError			OUT parameter.
//						If the function returned TRUE then this
//						parameter is ERROR_SUCCESS (0).
//						If the function returned FALSE then this
//						parameter holds the last error.
//
// Return Value:
//	TRUE if successful otherwise FALSE.
//
// Note:
//	The function creates the completion port and it is
//	the caller's responsibility to close it.
//
BOOL InitFaxQueue(
	/* IN  */ LPCTSTR	szMachineName,
	/* OUT */ HANDLE&	hComPortHandle, 
	/* OUT */ DWORD&	dwLastError,
	/* OUT */ HANDLE&	hServerEvents
	);

BOOL
fnFaxPrint(
    HANDLE    /* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR   /* IN */	szFaxNumber,	//fax number to call
    LPCTSTR   /* IN */	szDocumentName,	//name of document to fax
    LPCTSTR   /* IN */	szCPName,		//name of cover page to fax
    LPDWORD  /* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlMessageId = NULL	//pointer to set to the fax msg id of the fax
);

//
// fnFaxPrintBroadcast_OLD	(using old NT5 Fax winfax.dll)
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_OLD(
    IN	HANDLE    	hFaxSvcHandle,	//handle to the fax service
    IN	LPCTSTR   	szDocumentName,	//name of document to fax
    IN	LPVOID    	pContext,		//pointer to a CFaxBroadcastObj 
    OUT	LPDWORD  	pdwFaxId,		//pointer to set to the fax job id of the fax
	OUT	LPDWORD	 	pdwLastError	//pointer to set to last error encountered during send
);

//
// fnFaxPrintBroadcast_NEW	(using new Bos Fax fxsapi.dll)
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_NEW(
    HANDLE    /* IN */	hFaxSvcHandle,					//handle to the fax service
    LPCTSTR   /* IN */	szDocumentName,					//name of document to fax
    LPVOID    /* IN */	pContext,						//pointer to a CFaxBroadcastObj 
    LPDWORD  /* OUT */	pdwFaxId,						//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,					//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlParentMessageId = NULL,	//pointer to set to the parent msg id of the fax
	DWORDLONG**	/* OUT */	ppdwlRecipientIds = NULL,	//pointer to an array of recipient ids (allocated by fnFaxPrintBroadcast)
	DWORD*		/* OUT */	pdwNumOfRecipients = NULL	//number of recipient ids in pdwlRecipientIds	
);

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)
#define fnFaxPrintBroadcast fnFaxPrintBroadcast_OLD
#else
// Testing Bos Fax (with new fxsapi.dll)
#define fnFaxPrintBroadcast fnFaxPrintBroadcast_NEW
#endif

//
// SendFax:
//	Sends a fax containing the document szDocumentName to fax number
//	szFaxNumber and collects all the FAX_EVENTs from hCompletionPort
//	into SendInfo. The fax job id is returned via pdwFaxId and the
//	last error encountered is returned via pdwLastError.
//
// IMPORTANT:
//	This is a SYNCHRONOUS send.
//	The function waits until the fax session has completed, accumulating
//	all the FAX_EVENTs generated by the send job into the OUT parameter
//	SendInfo.
//
// Parameters:
//	szFaxNumber			IN parameter.
//						A string representing the fax number to send the fax to.
//	szDocumentName		IN parameter.
//						A string containing the name of the document to fax.
//	szMachineName		IN parameter.
//						A string containing the name of the machine on which the
//						Fax Service is located.
//	hCompletionPort		IN parameter.
//						The I\O Completion port used by the Fax Service Queue to
//						post all FAX_EVENTs. This is the port we get the events from.
//	pContext			IN parameter.
//						If this parameter is NULL it is ignored.
//						IF it is not NULL then it must be a pointer to a CFaxBroadcastObj
//						which will be used to send a broadcast.
//	pdwFaxId			OUT parameter.
//						The JobId corresponding to the Fax Service send job that
//						was created (and queued) to handle the fax sending.
//	pdwlMessageId		OUT parameter.
//						The MessageId corresponding to the Fax Service send job that
//						was created (and queued) to handle the fax sending.
//	SendInfo			OUT parameter.
//						An instance of class CSendInfo in which all relevant 
//						FAX_EVENTs are stored.
//	pdwLastError		OUT parameter.
//						The last error we encountered while sending the desired fax.
//
// ReturnValue:
//	This function returnes TRUE if the fax sending was completed successfully. 
//	That includes -
//	1. The hCompletionPort parameter is a valid opened port returned from
//	   a call to InitFaxQueue().
//	2. pdwFaxId and pdwLastError are both not NULL.
//	3. The fax send job was successfully queued to the Fax Service Queue,
//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
//	   and that szFaxNumber is a valid telephone number.
//	4. The job was successfully executed by the Fax Service, that is the fax
//	   session took place and completed successfully.
//	Otherwise returns FALSE.
//
BOOL SendFax(
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocumentName,
	LPCTSTR		/* IN */	szCPName,
	LPCTSTR		/* IN */	szMachineName,
	HANDLE		/* IN */	hCompletionPort,
	LPVOID		/* IN */	pContext,		
	LPDWORD		/* OUT */	pdwFaxId,
    DWORDLONG*	/* OUT */	pdwlMessageId,
	CSendInfo&	/* OUT */	SendInfo,
	LPDWORD		/* OUT */	pdwLastError
	);

#ifdef _NT5FAXTEST
#define WatchFaxEvents WatchFaxLegacyEvents
//
// WatchFaxLegacyEvents:
//	collects all the FAX_EVENTs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxLegacyEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
	);
#else // ! _NT5FAXTEST
#define WatchFaxEvents WatchFaxExtendedEvents
///
//
// WatchFaxExtendedEvents:
//	collects all the FAX_EVENT_EXs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxExtendedEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
);
#endif // #ifdef _NT5FAXTEST

//
// AbortFax
//	Aborts the fax job with dwJobId on the local Fax Server,
//	and returns the last error encountered via pdwLastError.
//
// IMPORTANT:
//	This is an ASYNCHRONOUS abort.
//	It delivers the abort request to the local Fax Server 
//	and returns.
//
// Parameters:
//	szMachineName	IN parameter.
//					The machine on which the Fax Server is located.
//	dwJobId			IN parameter.
//					The JobId of the job to abort.
//	pdwLastError	OUT parameter.
//					Set to the last error encountered while  
//					requesting the abort from the server.
// Return Value:
//	TRUE if the abort request succeeded and pdwLastError is not NULL.
//	FALSE otherwise.
//
// Note:
//	This function is designed with the thought that since send()
//	is synchrouneos, only a separate thread (having knowledge
//	of the send JobId) will be able to perform a successful
//	abort() on it.
//	
// Another Note:
//	This function does not receive an OUT parameter of type
//	CSendInfo&, which means that it does not accumulate the
//	FAX_EVENTs caused by the request to abort.
//
BOOL AbortFax(
	LPCTSTR			/* IN */	szMachineName,
	const DWORD		/* IN */	dwJobId,
	LPDWORD			/* OUT */	pdwLastError
	);


#endif //_COMET_FAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\cs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cs.h

Abstract:

    Declaration of Critical Section class

Author:

    Ronit Hartmann (ronith) ??-???-??

--*/

#ifndef __CS_H
#define __CS_H

//------------------------
//
//  class CCriticalSection
//
class CCriticalSection
{
    friend class CS;
    friend class ConditionalCS;

public:
    CCriticalSection(){InitializeCriticalSection(&_cs);}
    ~CCriticalSection(){DeleteCriticalSection(&_cs);}
    void Enter() {EnterCriticalSection(&_cs);}
    void Leave() {LeaveCriticalSection(&_cs);}

private:
    void Lock()     { Enter(); }
    void Unlock()   { Leave(); }

private:
    CRITICAL_SECTION _cs;
};


//------------------------
//
//  class CS
//
class CS {
    CCriticalSection* m_lock;

public:
    CS(CCriticalSection& lock);
   ~CS();
};

//- implementation -------
//
//  class CS
//
inline CS::CS(CCriticalSection& lock) :
    m_lock(&lock)
{
    m_lock->Lock();
}

inline CS::~CS()
{
    m_lock->Unlock();
}


//-----------------------------
//
//  ConditionalCS class
//
class ConditionalCS
{
public:
    ConditionalCS( CCriticalSection & cs) : m_cs(&cs),
                                         m_fLocked(FALSE)
    {}
    void Lock();
    ~ConditionalCS();
    
private:
    CCriticalSection *      m_cs;
    BOOL                    m_fLocked;


};

inline ConditionalCS::~ConditionalCS()
{
    if ( m_fLocked)
    {
        m_cs->Unlock();
    }
}

inline void ConditionalCS::Lock()
{
     m_fLocked = TRUE;
     m_cs->Lock();
}


#endif // __CS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\cthread.h ===
/*
 * ThreadBase_t class
 * implemets basic functionality of thread class
 * the user should drive from this class. The derived class used as argument for
 * ThreadUser_t template class.
 * 
 *  example :
 *  class mythread:public gutil::ThreadBase_t
 *  {
 *    public:
 *     void ThreadMain();      //  the functioin that run as thread
 *     void StopThreadMain();  // the function that stop the thread 
 *  };
 *  gutil::ThreadUser_t<mythread> thread(new(mythread)); //create thread object
 *  thread->StartThread(); //start it ! all the cleanup is done in the base class !! dont call delete (mythread) !!
 *  
 *   
 */
#ifndef _THREAD_BASE_H
#define _THREAD_BASE_H

#include <windows.h>
#include <process.h>
#include <comdef.h>
#include <assert.h>

//utilities
#include <testruntimeerr.h>

class ThreadBase_t
{
public:
	ThreadBase_t();
	virtual ~ThreadBase_t();  
	DWORD StartThread();
	virtual DWORD Suspend();
	virtual DWORD Resume();
	HANDLE GetHandle()const;
	DWORD GetID()const;
private:
	virtual unsigned int ThreadMain()=0;
	virtual void StopThreadMain()=0;
	static DWORD WINAPI ThreadFunc(void* params);
	HANDLE m_hThread;
	DWORD m_Threadid;
};


//constructor
//
inline ThreadBase_t::ThreadBase_t():
	m_hThread(NULL),
	m_Threadid(0)
{
  
}

//destructor
//
inline ThreadBase_t::~ThreadBase_t()
{
	if(m_hThread != NULL)
	{
		BOOL b = CloseHandle(m_hThread);
		assert(b);
	}
}


// return the thread handle
//
inline HANDLE ThreadBase_t::GetHandle ()const
{
	return m_hThread;
}
 
// return the thread id
//
inline DWORD ThreadBase_t::GetID()const
{
	return m_Threadid;
}

// create the actual thread- must be called first
//
inline DWORD ThreadBase_t::StartThread()
{

	m_hThread = (HANDLE)CreateThread(NULL,
									8192, //TODO?
									ThreadBase_t::ThreadFunc,
									this,
									0,
									&m_Threadid);

	if(m_hThread == NULL)
	{
		return GetLastError();
	}
	return 0;
}


// thread function - calls to the drived class Run method
//
inline  DWORD WINAPI ThreadBase_t::ThreadFunc(void* params)
{
  
	ThreadBase_t* thread = static_cast<ThreadBase_t*>(params);
	unsigned int ret = thread->ThreadMain();
	return ret;
}


// suspend the thread
//
inline DWORD ThreadBase_t::Suspend()
{
	if( SuspendThread(m_hThread) == 0xFFFFFFFF)
	{
		return GetLastError();
	}
	return 0;
}


// resume the thread
//
inline DWORD ThreadBase_t::Resume()
{
	if(ResumeThread(m_hThread) == 0xFFFFFFFF)
	{
		return GetLastError();
	}
	return 0;
}



#endif // _THREAD_BASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxtestname.h ===
#ifndef AAA
#define AAA

#define FAX_FULL_NAME_MICROSOFT       "Microsoft"
#define FAX_SPACE                     " "
#define FAX_TEST_NAME                 "Fax Test Tool:"
#define FAX_TEST_FULL_NAME            FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_TEST_NAME

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\exception.h ===
#ifndef _ACTEXCPT_H
#define _ACTEXCPT_H
/*
  
*/

#include <stdio.h>
#include <tchar.h>

class CException
{
public:
	CException(
		const TCHAR * const szExceptionDescription,
		...
		)
	{
		m_szExceptionDescription[1023] = TEXT('\0');

		if (szExceptionDescription)
		{
			va_list argList;
			va_start(argList, szExceptionDescription);
			_vsntprintf(m_szExceptionDescription, 1023, szExceptionDescription, argList);
			va_end(argList);
		}
		else
		{
			m_szExceptionDescription[0] = TEXT('\0');
		}
	}

	~CException()
	{
	}

	operator const TCHAR*() const {return m_szExceptionDescription;}
private:
	TCHAR m_szExceptionDescription[1024];
};

#endif //#ifndef _ACTEXCPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\elle.h ===
/*
 -  ELLE.H
 -
 *  Purpose:
 *      Header file for the Mac version of the ELLE Logging system.
 *
 *
 */

#ifndef _ELLE_
#define _ELLE_


#include <windows.h>

typedef unsigned long   ULONG;

#ifdef WIN32
#define _export
#endif


// Other defines
#define MAXERRMSG      256


// ELLE CallBack type needs to include void* parameter so compiler
// knows how to properly clean the stack after the call.
typedef void (_export CALLBACK *ELLECALLBACK)(void *);


/*
 -  LSQL
 -
 *  Purpose:
 *      The contents of this data structure describe an SQL logging
 *      session in the ELLE sub-system.
 */

typedef struct _lsql
{
    BOOL    fSQLParse;                // specifies write to SQL parse file
    BOOL    fSQLDirect;               // specifies write to SQL parse file
    char    szSQLFileName[64];        // SQL parse file name
    char    szServerName[32];         // SQL server name
    char    szDataBase[32];           // SQL database name
    char    szTableName[32];          // SQL table name (results)
    char    szUserID[16];             // user account ID on SQL server
    char    szPassword[16];           // password for user account
    WORD    wErrorRpt;                // error reporting method
} LSQL, FAR * LPLSQL;

#define fmSQLParse          ((ULONG)   1)
#define fmSQLDirect         ((ULONG)   2)
#define fmSQLFileName       ((ULONG)   4)
#define fmSQLServerName     ((ULONG)   8)
#define fmSQLDataBase       ((ULONG)  16)
#define fmSQLTableName      ((ULONG)  32)
#define fmSQLUserID         ((ULONG)  64)
#define fmSQLPassword       ((ULONG) 128)
#define fmSQLErrorRpt       ((ULONG) 256)
#define fmSQLAll            ((ULONG) 0xffffffff)


/*
 -  LFILE
 -
 *  Purpose:
 *      Defines the attributes of the local file logging in the
 *      ELLE sub-system.
 */

typedef struct _lfile
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to file
    char    szFileName[64];           // local log file name
    BOOL    fAppendMode;              // 1 = append, 0 = overwrite
    BOOL    fWritten;                 // indicates if we've written yet
    WORD    wErrorRpt;                // error reporting method
} LFILE, FAR * LPLFILE;

#define fmFILELogLevel      ((ULONG)  1)
#define fmFILEDetailLevel   ((ULONG)  2)
#define fmFILEFileName      ((ULONG)  4)
#define fmFILEAppendMode    ((ULONG)  8)
#define fmFILEErrorRpt      ((ULONG) 16)
#define fmFILEAll           ((ULONG) 0xffffffff)


/*
 -  LCOMM
 -
 *  Purpose:
 *      Defines the attributes of the comm port logging in the
 *      ELLE sub-system.
 */

typedef struct _lcomm
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wCommPort;                // which port: 0 = "com1", 1 = "com2", or 2 = "com3"
    WORD    wErrorRpt;                // error reporting method
    char    szSpeed[7];               // com port speed (EX: "1200", "9600", "19200")
} LCOMM, FAR * LPLCOMM;

#define fmCOMMLogLevel      ((ULONG)  1)
#define fmCOMMDetailLevel   ((ULONG)  2)
#define fmCOMMPort          ((ULONG)  4)
#define fmCOMMErrorRpt      ((ULONG)  8)
#define fmCOMMAll           ((ULONG) 0xffffffff)


/*
 -  LVIEWPORT
 -
 *  Purpose:
 *      Defines the attributes of the MS Test Viewport logging in the
 *      ELLE sub-system.
 */

typedef struct _viewport
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wErrorRpt;                // error reporting method
    BOOL    fHideWhenDone;            // flag for having the viewport be hidden
                                      // when last copy of elle is de-inited.
    BOOL    fClearEachSuite;          // flag for having the viewport be cleared
                                      // before each suite begins.
} LVIEWPORT, FAR * LPLVIEWPORT;

#define fmVIEWPORTLogLevel       ((ULONG)  1)
#define fmVIEWPORTDetailLevel    ((ULONG)  2)
#define fmVIEWPORTErrorRpt       ((ULONG)  4)
#define fmVIEWPORTHideWhenDone   ((ULONG)  8)
#define fmVIEWPORTClearEachSuite ((ULONG) 16)
#define fmVIEWPORTAll            ((ULONG) 0xffffffff)


/*
 -  EcMSTViewport() flags
 -
 * Purpose:
 *        Flags for indicating which operation should be done.
 *        Used with the EcMSTViewport() API. Normally Elle will
 *        handle everything here, but if you want to manipulate
 *        the viewer yourself, use these EcMSTViewport() with
 *        these flags.
 */
#define fmCREATE_MST_VIEWPORT     ((int) 0x0001)   // indicates the MSTest Viewport should be created and used.
#define fmCONNECT_MST_VIEWPORT    ((int) 0x0002)   // indicates that Elle should connect to the MSTest Viewport
#define fmDISCONNECT_MST_VIEWPORT ((int) 0x0004)   // indicates that Elle should disconnect from the MSTest Viewport
#define fmCLEAR_MST_VIEWPORT      ((int) 0x0010)   // indicates the MSTest Viewport should be Cleared
#define fmSHOW_MST_VIEWPORT       ((int) 0x0020)   // indicates the MSTest Viewport should be Shown
#define fmHIDE_MST_VIEWPORT       ((int) 0x0040)   // indicates the MSTest Viewport should be Hidden


/*
 -  LDBGOUT
 -
 *  Purpose:
 *      Defines the attributes of the MS Test Viewport logging in the
 *      ELLE sub-system.
 */

typedef struct _ldbgout
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wErrorRpt;                // error reporting method
} LDBGOUT, FAR * LPLDBGOUT;

#define fmDBGOUTLogLevel       ((ULONG)  1)
#define fmDBGOUTDetailLevel    ((ULONG)  2)
#define fmDBGOUTErrorRpt       ((ULONG)  4)
#define fmDBGOUTAll            ((ULONG) 0xffffffff)


/*
 -  LOG
 -
 *  Purpose:
 *      Defines information that is global to the ELLE
 *      logging sub-system.
 */

#define cbSuiteNameMax  512

typedef struct _logsys
{
    char    szSuiteName[cbSuiteNameMax];         // defined by tester
    char    szTestCase[cbSuiteNameMax];          // verbose test case identifier
    WORD    wTestType;                // SL_CLASS, SL_STRESS, etc.

    WORD    fwCaseStatus;             // global status of current test case
    WORD    fwSuiteStatus;            // global status of current test suite
    WORD    fwSysStatus;              // global status of ELLE sub-system
    char    szErrMsg[MAXERRMSG];      // error message for ELLE sub-system

    BOOL    fVersion;                 // 1 = ship, 2 = debug, 3 = test

    BOOL    fFile;                    // are we logging to a file?
    BOOL    fComm;                    // are we logging to the comm port?
    BOOL    fSQL;                     // are we logging to SQL database?
    BOOL    fViewport;                // are we logging to the Viewport?
    BOOL    fDbgOut;                  // are we logging to the Debug Output?
    WORD    wErrorRpt;                // error reporting method
    BOOL    fDetailBuffer;            // are we using the Detail Buffer?
    BOOL    fBeginEndChecking;        // check for incorrect nesting of Begin/EndSuite and Begin/EndCase calls. Defaults to FALSE.
} LOGSYS, FAR * LPLOGSYS;

#define fmLOGSuiteName      ((ULONG) 0x00000001)
#define fmLOGTestCase       ((ULONG) 0x00000002)
#define fmLOGTestType       ((ULONG) 0x00000004)
#define fmLOGCaseStatus     ((ULONG) 0x00000008)
#define fmLOGSuiteStatus    ((ULONG) 0x00000010)
#define fmLOGSysStatus      ((ULONG) 0x00000020)
#define fmLOGErrMsg         ((ULONG) 0x00000040)
#define fmLOGVersion        ((ULONG) 0x00000080)
#define fmLOGFile           ((ULONG) 0x00000100)
#define fmLOGComm           ((ULONG) 0x00000200)
#define fmLOGSql            ((ULONG) 0x00000400)
#define fmLOGViewport       ((ULONG) 0x00000800)
#define fmLOGDbgOut         ((ULONG) 0x00001000)
#define fmLOGDetailBuf      ((ULONG) 0x00002000)
#define fmLOGErrorRpt       ((ULONG) 0x00004000)
#define fmLOGAll            ((ULONG) 0xffffffff)


/*
 -  Constants used by the ELLE logging system
 -
 */

#define     L_ERRORRPT1 ((WORD) 0)    // don't report errors
#define     L_ERRORRPT2 ((WORD) 1)    // report errors to a message box (default)
#define     L_ERRORRPT3 ((WORD) 2)    // log errors to event logger

#define     L_ADHOC     ((WORD) 0)    // defines an adhoc test (catch-all)
#define     L_CLASS     ((WORD) 1)    // defines a "class" test case
#define     L_STRESS    ((WORD) 2)    // defines a "stress" test case
#define     L_BOUNDARY  ((WORD) 3)    // defines a "boundary" test case
#define     L_MEMORY    ((WORD) 4)    // defines a "memory" test case
#define     L_RES_FAIL  ((WORD) 5)    // defines a "resource failure" case
#define     L_STD_DLG   ((WORD) 6)    // defines a "standard dialog" case

#define     L_FAIL      ((WORD) 0)
#define     L_PASS      ((WORD) 1)
#define     L_ABORT     ((WORD) 2)
#define     L_DONT_CARE ((WORD) 3)
#define     L_X         ((WORD) 3)

#define     L_SHIP      ((WORD) 1)
#define     L_DEBUG     ((WORD) 2)
#define     L_TEST      ((WORD) 3)

#define     L_COM1      ((WORD) 0)
#define     L_COM2      ((WORD) 1)
#define     L_COM3      ((WORD) 2)

#define     L_CASE      ((WORD) 1)
#define     L_STEP      ((WORD) 2)
#define     L_DETAIL    ((WORD) 3)

#define     L_MODEMPORT     0
#define     L_PRINTERPORT   1


/* Define the Elle interface to the outside world */

#ifdef __cplusplus
extern "C" {
#endif

#ifdef NT

// wide/unicode versions on functions that involve strings
VOID FAR PASCAL LogStepW(WORD, LPWSTR);
VOID FAR PASCAL LogDetailW(WORD, WORD, LPWSTR);
VOID FAR CDECL  LogStepFW(WORD, LPWSTR, ...);
VOID FAR CDECL  LogDetailFW(WORD, WORD, LPWSTR, ...);
VOID FAR PASCAL BeginCaseW(ULONG, LPWSTR);
VOID FAR PASCAL AbortCaseW(LPWSTR);
VOID FAR PASCAL BeginSuiteW(LPWSTR);
VOID FAR PASCAL SetHeaderW(LPWSTR, LPWSTR);
VOID FAR PASCAL GetHeaderW(LPWSTR, LPWSTR);
BOOL FAR PASCAL VerifyManualW(LPWSTR);
VOID FAR PASCAL LogNoteW(LPWSTR);
VOID FAR CDECL  LogNoteFW(LPWSTR, ...);

//Define a generic unicode calling APIs. Note, they are not exported, so if
//you want to use it in VB or MS Test, you need to define it yourself
#ifdef UNICODE // If UNICODE, then route generic calls into wide functions.

#define ULogStep      LogStepW
#define ULogDetail    LogDetailW
#define ULogStepF     LogStepFW
#define ULogDetailF   LogDetailFW
#define UBeginCase    BeginCaseW
#define UAbortCase    AbortCaseW
#define UBeginSuite   BeginSuiteW
#define USetHeader    SetHeaderW
#define UGetHeader    GetHeaderW
#define UVerifyManual VerifyManualW
#define ULogNote      LogNoteW
#define ULogNoteF     LogNoteFW

#endif //#ifdef UNICODE
#endif // #ifdef NT


//even if you are not using UNICODE, you can still use the U... APIs.
#ifndef UNICODE

#define ULogStep      LogStep
#define ULogDetail    LogDetailA
#define ULogStepF     LogStepF
#define ULogDetailF   LogDetailF
#define UBeginCase    BeginCase
#define UAbortCase    AbortCase
#define UBeginSuite   BeginSuite
#define USetHeader    SetHeader
#define UGetHeader    GetHeader
#define UVerifyManual VerifyManual
#define ULogNote      LogNote
#define ULogNoteF     LogNoteF

#endif // #ifndef UNICODE

//avoid to export LogDetail(), MS Test 4.0 has a function with the same name, so 
//we will have a problem to run MS Test. If you are using C/C++, you are OK since
//we #define it and the preprocess will take care of it, but if you are using VB,
// use LogDetailA() or LogDetailF() instead. 
#define LogDetail    LogDetailA	



// ASCII versions on functions that involve strings
VOID FAR PASCAL LogStep(WORD, LPSTR);
VOID FAR PASCAL LogDetailA(WORD, WORD, LPSTR);
VOID FAR CDECL  LogStepF(WORD, LPSTR, ...);
VOID FAR CDECL  LogDetailF(WORD, WORD, LPSTR, ...);
VOID FAR PASCAL BeginCase(ULONG, LPSTR);
VOID FAR PASCAL AbortCase(LPSTR);
VOID FAR PASCAL BeginSuite(LPSTR);
VOID FAR PASCAL SetHeader(LPSTR, LPSTR);
VOID FAR PASCAL GetHeader(LPSTR, LPSTR);
BOOL FAR PASCAL VerifyManual(LPSTR);
VOID FAR PASCAL LogNote(LPSTR);
VOID FAR CDECL  LogNoteF(LPSTR, ...);

// All non-unicode dependant functions
BOOL FAR PASCAL EcInitElle();
BOOL FAR PASCAL EcDeInitElle();
VOID FAR PASCAL EndCase();
VOID FAR PASCAL EndSuite();
VOID FAR PASCAL SetFileLevel(WORD);
VOID FAR PASCAL SetCommLevel(WORD);
VOID FAR PASCAL SetViewportLevel(WORD);
VOID FAR PASCAL SetDbgOutLevel(WORD);
VOID FAR PASCAL SetStatus(WORD);
WORD FAR PASCAL GetStatus();
VOID FAR PASCAL SetLogSys(BOOL, LPLOGSYS, ULONG);
BOOL FAR PASCAL GetLogSys(LPLOGSYS, ULONG);
BOOL FAR PASCAL LogMenu(HWND);
VOID FAR PASCAL SetSQLSys(BOOL, LPLSQL, ULONG);
BOOL FAR PASCAL GetSQLSys(LPLSQL, ULONG);
VOID FAR PASCAL SetFileSys(BOOL, LPLFILE, ULONG);
BOOL FAR PASCAL GetFileSys(LPLFILE, ULONG);
VOID FAR PASCAL SetCommSys(BOOL, LPLCOMM, ULONG);
BOOL FAR PASCAL GetCommSys(LPLCOMM, ULONG);
VOID FAR PASCAL SetViewportSys(BOOL, LPLVIEWPORT, ULONG);
BOOL FAR PASCAL GetViewportSys(LPLVIEWPORT, ULONG);
VOID FAR PASCAL SetDbgOutSys(BOOL, LPLDBGOUT, ULONG);
BOOL FAR PASCAL GetDbgOutSys(LPLDBGOUT, ULONG);
HWND FAR PASCAL SetViewport(HWND);
VOID FAR PASCAL SetCallback(ELLECALLBACK);
VOID FAR PASCAL SaveChanges();
BOOL FAR PASCAL EcMSTViewport(HWND, ULONG);

#ifdef __cplusplus
}
#endif

#endif // _ELLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxsender.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		FaxSender.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CFaxSender. This class was designed
//		to allow for tailored fax related actions
//		using the NT5.0 Fax Service API (winfax.h).
//
//		The class has methods that enable it to:
//		* Get a const reference to private members
//		  m_SendInfo, m_dwSendJobId and m_SendStatus.
//		* Output instance information to the logger.
//		* Output instance information to a stream (CotstrstreamEx).
//		* Return a string description of the instance.
//		* Send a fax synchronouslly and accumulate
//		  every FAX_EVENT relevant to it.
//		* Abort a fax asynchronouslly.
//
//		The class uses the elle logger wraper implemented
//		in LogElle.c to log any fax related errors.
//
//		Streams are used for i/o handling (streamEx.cpp).
//


#ifndef _FAX_SENDER_H_
#define _FAX_SENDER_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>
#include "streamEx.h"
#include "SendInfo.h"
#include "FaxBroadcast.h"

#include "FaxCompPort.h"
#include "wcsutil.h"

//
// FAX_SENDER_STATUS
//
typedef struct _FAX_SENDER_STATUS
{
	MY_FAX_EVENT	*pLastEventFromFaxQueue;	
	DWORD			LastErrorFromFaxService;
} FAX_SENDER_STATUS, *PFAX_SENDER_STATUS;

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CostrstreamEx& operator<<(
	IN OUT	CostrstreamEx&				os, 
	IN		const FAX_SENDER_STATUS&	SenderStatus);

CotstrstreamEx& operator<<(
	CotstrstreamEx&				/* IN OUT */	os, 
	const FAX_SENDER_STATUS&	/* IN */		SenderStatus);


//
// CFaxSender
//
class CFaxSender
{
public:

	//
	// CFaxSender:
	//	Constructor.
	//
	// Parameters:
	//	szMachineName	IN Parameter.
	//					Default value of parameter is NULL.
	//					A string representing the name of the Fax Server we want to
	//					use. 
	//					This parameter may be the name of a machine (without the \\)
	//					on which a Fax Service is installed, or NULL to indicate the
	//					local Fax Service.
	//
	CFaxSender(LPCTSTR /* IN */ szMachineName = NULL);

	//
	// ~CFaxSender:
	//
	~CFaxSender( void );

	//
	// send:
	//	Sends a fax synchronouslly and accumulates
	//	every FAX_EVENT relevant to it. 
	//	This implies that an I\O Completion Port 
	//  is created and the Fax Service Queue is set
	//	to post all FAX_EVENTs to it (see class
	//	CFaxCompletionPort for details).
	//
	// Parameters:
	//	szFileName			IN parameter.
	//						Name of file to send in fax.
	//	szRecipientNumber	IN parameter.
	//						Number of fax to send fax to.
	//
	// Return Value:
	//	This function returnes TRUE if the fax sending was completed successfully. 
	//	That includes -
	//	1. The fax send job was successfully queued to the Fax Service Queue,
	//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
	//	   and that szFaxNumber is a valid telephone number.
	//	2. The job was successfully executed by the Fax Service, that is, the fax
	//	   session took place and completed successfully.
	//	Otherwise returns FALSE.
	//
	BOOL send(
		LPCTSTR /* IN */ szFileName, 
		LPCTSTR /* IN */ szCPFileName, 
		LPCTSTR /* IN */ szRecipientNumber
		);

	
	//
	// send_broadcast:
	//	Sends a broadcast fax synchronouslly and accumulates
	//	every FAX_EVENT relevant to it. 
	//	This implies that an I\O Completion Port 
	//  is created and the Fax Service Queue is set
	//	to post all FAX_EVENTs to it (see class
	//	CFaxCompletionPort for details).
	//
	// Parameters:
	//	szFileName			IN parameter.
	//						Name of file to send in fax.
	//	myFaxBroadcastObj	IN parameter.
	//						The broadcast object. Contains the numbers
	//						of all recipients and the cover page.
	//
	// Return Value:
	//	This function returnes TRUE if the fax sending was completed successfully. 
	//	That includes -
	//	1. The fax send job was successfully queued to the Fax Service Queue,
	//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
	//	   and that szFaxNumber is a valid telephone number.
	//	2. The job was successfully executed by the Fax Service, that is, the fax
	//	   session took place and completed successfully.
	//	Otherwise returns FALSE.
	//
	BOOL send_broadcast(
		LPCTSTR				/* IN */ szFileName, 
		CFaxBroadcast*		/* IN */ pmyFaxBroadcastObj
		);

	
	//
	// abort:
	//	Asynchronouslly aborts the send fax job with JobId equal to m_dwSendJobId.
	//
	// Note:
	//	Since send() is synchronous, any synchronous abort() will fail.
	//	Thus it only makes sense to call this method from a separate
	//	thread (which has a reference to the instance).
	//
	// IMPORTANT:
	//	Since the implementation of class CFaxSender is NOT thread safe
	//	(the class members are not protected to prevent simultaneous access)
	//	we choose that abort() will not change any of the instance's
	//	members.
	//	Thus the only way to tell whether the abort succeeded or failed 
	//	is via the function's return value.
	//
	// Return Value:
	//	TRUE if the request to abort succeeded.
	//	Otherwise FALSE.
	//
	BOOL abort(void);


	//
	// GetSendInfo:
	//	Returns a const reference to instance member m_SendInfo.
	//
	const CSendInfo& GetSendInfo( void ) const;


	//
	// GetJobId:
	//	Returns a const copy of instance member m_dwSendJobId.
	//
	const DWORD GetJobId(void) const;

	
	//
	// GetMessageId:
	//	Returns a const copy of instance member m_dwlSendJobMessageId.
	//
	const DWORDLONG GetMessageId(void) const;

	
	//
	// GetLastStatus:
	//	Returns a const reference to instance member m_SendStatus.
	//
	const FAX_SENDER_STATUS& GetLastStatus( void ) const;


	//
	// cstr:
	//	Returns a string which contains all the instance's information.
	//	
	// Return Value:
	//	The formated string describing every one of the instance's 
	//	members.
	//	This string is allocated by the function and should be freed by
	//	the caller.
	//
	LPCTSTR cstr(void) const;


	//
	// outputAllToLog:
	//	Outputs a description of every one of the instance's 
	//	members to the logger. Including ALL the events 
	//	accumulated in the instance's m_SendInfo member.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD /* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD /* IN */	dwLevel = 1
		) const;


	//
	// outputJobToLog:
	//	Outputs a description of every one of the instance's 
	//	members to the logger.
	//	ONLY the fax events with JobId equal to the instance's
	//	m_dwSendJobId member are outputed to the logger (NOT ALL 
	//	events).
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputJobToLog(
		const DWORD /* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD /* IN */	dwLevel = 1
		) const;


	//
	// operator<<
	//	Outputs a description of every one of the instance's 
	//	members to the given stream.
	//
	// Parameters:
	//	os		IN OUT parameter.
	//			Stream to append the descriptive string to.
	//	Sender	A const reference to the CFaxSender instance whose
	//			descriptive string we want to append to the stream.
	//
	// Return Value:
	//	A reference to the updated stream (os).
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&		/* IN OUT */	os, 
		const CFaxSender&	/* IN */		Sender);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&		/* IN OUT */	os, 
		const CFaxSender&	/* IN */		Sender);

private:

	// The machine name on which the Fax Server is located.
	// This member is set during creation and cannot be changed.
	LPTSTR				m_szMachineName;

	// The I\O Completion Port used to "communicate" with
	// the Fax Service Queue.
#ifndef _NT5FAXTEST
	// Testing Bos Fax (with new fxsapi.dll)
	CFaxCompletionPort	m_TheFaxCompletionPort;
#else
	// Testing NT5 Fax (with old winfax.dll)
	static CFaxCompletionPort	m_TheFaxCompletionPort;
#endif

	// A CSendInfo instance used to accumulate all the
	// FAX_EVENT@s received via the Queue completion port.
	CSendInfo			m_SendInfo;

	// The Fax Service JobId of the job corresponding to
	// the last call to the instance's send() method.
	DWORD				m_dwSendJobId;

#ifndef _NT5FAXTEST
	// The Fax Service Msg Id of the message corresponding to
	// the last call to the instance's send() method.
	// Availlable in extended private API only
	DWORDLONG			m_dwlSendJobMessageId;
#endif

	// The filename corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szSendFileName;

	// The filename corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szCPFileName;

	// The fax number corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szSendRecipientNumber;

	// An indication of whether the last call to
	// the instance's send() method succeeded or failed.
	// TRUE for success and FALSE for failure.
	BOOL				m_fSendSuccess;

	// The last fax related error and the eventId of the
	// last FAX_EVENT, corresponding to the last call to
	// the instance's send() method.
	FAX_SENDER_STATUS	m_SendStatus;


	//
	// SetSendFileName:
	//	Sets the instance's m_szSendFileName to szStr.
	//	A copy of szStr is created and m_szSendFileName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szSendFileName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetSendFileName(LPCTSTR szStr);

	//
	// SetCPFileName:
	//	Sets the instance's m_szCPFileName to szStr.
	//	A copy of szStr is created and m_szCPFileName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szCPFileName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetCPFileName(LPCTSTR szStr);

	//
	// SetMachineName:
	//	Sets the instance's m_szMachineName to szStr.
	//	A copy of szStr is created and m_szMachineName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szMachineName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetMachineName(LPCTSTR szStr);
	
	//
	// SetSendRecipientNumber:
	//	Sets the instance's m_szSendRecipientNumber to szStr.
	//	A copy of szStr is created and m_szSendRecipientNumber
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szSendRecipientNumber to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetSendRecipientNumber(LPCTSTR szStr);


	//
	// InsertAllButEventsIntoOs:
	//	Appends a string description of all the instance's members
	//	except for m_SendInfo.
	//
	// Parameters:
	//	os		IN OUT parameter.
	//			Stream to append the instance's descriptive string to.
	//
	// Return Value:
	//	The updated stream (os).
	//
	CostrstreamEx& InsertAllButEventsIntoOs(CostrstreamEx&  /* IN OUT */ os) const;
	CotstrstreamEx& InsertAllButEventsIntoOs(CotstrstreamEx&  /* IN OUT */ os) const;

};



#endif  //_FAX_SENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\log.h ===
#ifndef __LOG_WRAPPER_H__
#define __LOG_WRAPPER_H__

#ifdef __cplusplus
extern "C"
{
#endif

BOOL __cdecl lgInitializeLogger();

BOOL __cdecl lgCloseLogger();


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite);
BOOL __cdecl lgEndSuite();

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase);
BOOL __cdecl lgEndCase();

int __cdecl lgSetLogLevel(const int nLogLevel);

/*
#define LOG_TYPE_FILE 0x01
#define LOG_TYPE_VIEWPORT 0x02
#define LOG_TYPE_COMM 0x04
#define LOG_TYPE_DEBUG 0x08

DWORD __cdecl lgSetLogType(DWORD dwLogTo);
*/

BOOL __cdecl lgDisableLogging();

BOOL __cdecl lgEnableLogging();

//
// severity values
//
#define LOG_PASS -1

#define LOG_X 0
#define LOG_SEVERITY_DONT_CARE 0

#define LOG_SEV_1 1
#define LOG_SEV_2 2
#define LOG_SEV_3 3
#define LOG_SEV_4 4

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...);
void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...);

BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer);

#ifdef __cplusplus
}
#endif


#endif //__LOG_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxtestutils.h ===
#ifndef __FAX_TEST_UTIL_H__
#define __FAX_TEST_UTIL_H__

#include <windows.h>
#include <assert.h>
#include <fxsapip.h>
#include <testruntimeerr.h>
#include <tstring.h>
#include <security.h>

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************
                        Security
******************************************************************************/

/*++
    Modifies access rights to Fax service for the specified user.
    The function adds new information to existing DACL.
    Access rights that are not included in dwAllow or dwDeny are not affected.

    [IN]    lpctstrServer   Server name (NULL for local server)
    [IN]    lptstrTrustee   User or group name. If it's NULL, access is set for currently logged on user.
    [IN]    dwAllow         Specifies access rights to be allowed
    [IN]    dwDeny          Specifies access rights to be denied
    [IN]    bReset          Specifies whether old access rights should be completeley discarded or
                            merged with new

    "Deny" is stronger than "Allow". Meaning, if the same right is specified in both dwAllow and dwDeny,
    the right will be denied.
  
    Calling the function with both dwAllow = 0 and dwDeny = 0 and bReset = TRUE has an affect of removing
    all ACEs for the specified user or group.

    Return value:           If the function succeeds, the return value is nonzero.
                            If the function fails, the return value is zero.
                            To get extended error information, call GetLastError. 
--*/

BOOL FaxModifyAccess(
                     LPCTSTR        lpctstrServer,
                     LPTSTR         lptstrTrustee,
                     const DWORD    dwAllow,
                     const DWORD    dwDeny,
                     const BOOL     bReset
                     );



#ifdef __cplusplus
}
#endif

#endif // #ifndef __FAX_TEST_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\directoryutilities.h ===
//
// Map directory file names
//

#ifndef _DIRECTORY_UTILITIES_H
#define _DIRECTORY_UTILITIES_H

#pragma warning(disable :4786)
#include <vector>
#include <tstring.h>
#include <testruntimeerr.h>
#include <stldatastructdefs.h>
#include <stringutils.h>


//
// File filters.
//


class CFileFilter {

public:

    virtual bool Filter(const WIN32_FIND_DATA &FileData) const = 0;

    virtual ~CFileFilter() {};
};


class CFileFilterNoFilter : public CFileFilter {

public:

    virtual bool Filter(const WIN32_FIND_DATA &FileData) const
    {
        UNREFERENCED_PARAMETER(FileData);
        return true;
    }
};


class CFileFilterExtension : public CFileFilter {

public:

    CFileFilterExtension(const tstring &tstrExtension = _T(".*")) : m_tstrExtension(tstrExtension) {}

    virtual bool Filter(const WIN32_FIND_DATA &FileData) const
    {
        if (!FileData.cFileName)
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER,  TEXT("CFileFilterExtension::CFileFilterExtension - invalid filename"));
        }

        //
        // Find the file extension.
        //
        LPCTSTR lpctstrExtension = _tcsrchr(FileData.cFileName, _T('.'));

        if (!lpctstrExtension && m_tstrExtension.empty())
        {
            //
            // No extension is required and the file doesn't have one.
            //
            return true;
        }

        if (lpctstrExtension && !m_tstrExtension.empty())
        {
            //
            // An extension is required and the file has one - compare.
            //
            return (_T(".*") == m_tstrExtension || !_tcsicmp(lpctstrExtension, m_tstrExtension.c_str()));
        }

        //
        // An extension is required but the file doesn't have one or vice versa.
        //
        return false;
    }

private:

    tstring m_tstrExtension;
};


class CFileFilterNewerThan : public CFileFilter {

public:

    CFileFilterNewerThan(const FILETIME &OldestAcceptable) : m_OldestAcceptable(OldestAcceptable) {}

    virtual bool Filter(const WIN32_FIND_DATA &FileData) const
    {
        if (!FileData.cFileName)
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER,  TEXT("CFileFilterNewerThan::CFileFilterNewerThan - invalid filename"));
        }

        return CompareFileTime(&FileData.ftCreationTime, &m_OldestAcceptable) > 0;
    }

private:

    FILETIME m_OldestAcceptable;
};




//
// Declarations
//
TSTRINGVector GetDirectoryFileNames(const tstring& tstrFileRepositoryDir, const CFileFilter &Filter);
TSTRINGVector GetDirectoryFileNames(const tstring& tstrFileRepositoryDir);
TSTRINGVector EmptyDirectory(const tstring& tstrFileRepositoryDir, const CFileFilter &Filter);
TSTRINGVector EmptyDirectory(const tstring& tstrFileRepositoryDir);


//
// GetDirectoryFileNames
//

inline TSTRINGVector
GetDirectoryFileNames(const tstring& tstrFileRepositoryDir, const CFileFilter &Filter)
{

    WIN32_FIND_DATA FindFileData; 
    HANDLE hFileHandle = INVALID_HANDLE_VALUE;
    DWORD dwFindFileStatus, dwFileAttrStatus;

    tstring tstrFileFullPath;
    TSTRINGVector FileNameVector;
    tstring tstrFileRepositoryDirWithBackslash = ForceLastCharacter(tstrFileRepositoryDir, _T('\\'));
    tstring tstrAllFileRepository              = tstrFileRepositoryDirWithBackslash + TEXT("*.*");

    try
    {
        dwFileAttrStatus = GetFileAttributes(tstrFileRepositoryDir.c_str());
        if(dwFileAttrStatus == 0xFFFFFFFF)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(),  TEXT("GetDirectoryFileName - GetFileAttributes"));
        }

        if(dwFileAttrStatus & FILE_ATTRIBUTE_DIRECTORY)
        {
            hFileHandle = FindFirstFile( tstrAllFileRepository.c_str(), &FindFileData);
                
            if ( hFileHandle != INVALID_HANDLE_VALUE)
            {
                do
                {
                    tstrFileFullPath =  tstrFileRepositoryDirWithBackslash + FindFileData.cFileName;
                    
                    dwFileAttrStatus = GetFileAttributes(tstrFileFullPath.c_str());
                    if(dwFileAttrStatus == 0xFFFFFFFF)
                    {
                        THROW_TEST_RUN_TIME_WIN32(GetLastError(),  TEXT("GetDirectoryFileName - GetFileAttributes"));
                    }

                    if( !(dwFileAttrStatus & FILE_ATTRIBUTE_DIRECTORY) && Filter.Filter(FindFileData))
                    {
                        FileNameVector.push_back(tstrFileFullPath);
                    }
                    
                    dwFindFileStatus = FindNextFile( hFileHandle, &FindFileData);
                                    
                } while ( dwFindFileStatus);

                if( GetLastError() != ERROR_NO_MORE_FILES)
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(),  TEXT("GetDirectoryFileName - FindNextFile"));
                }
            }
            else
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("GetDirectoryFileName - FindFirstFile"));
            }
        }
        // Not a directory, a file path
        else
        {
            hFileHandle = FindFirstFile( tstrFileRepositoryDir.c_str(), &FindFileData);
            if(hFileHandle == INVALID_HANDLE_VALUE)
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(),  TEXT("GetDirectoryFileName - FindFirstFile"));
            }

            if (Filter.Filter(FindFileData))
            {
                FileNameVector.push_back(tstrFileRepositoryDir);
            }
        }
    }
    catch(Win32Err&)
    {
        if ( hFileHandle != INVALID_HANDLE_VALUE)
        {
            FindClose(hFileHandle);
        }
        throw;
    }
    
    if ( hFileHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFileHandle);
    }

    return FileNameVector;
}


inline TSTRINGVector
GetDirectoryFileNames(const tstring& tstrFileRepositoryDir)
{
    return GetDirectoryFileNames(tstrFileRepositoryDir, CFileFilterNoFilter());
}



//
// EmptyDirectory
//

inline TSTRINGVector
EmptyDirectory(const tstring &tstrDirectory, const CFileFilter &Filter) throw (Win32Err)
{
    TSTRINGVector vecFiles = GetDirectoryFileNames(tstrDirectory, Filter);
    
    TSTRINGVector::iterator itFilesIterator = vecFiles.begin();

    while (itFilesIterator != vecFiles.end())
    {
        if (DeleteFile(itFilesIterator->c_str()))
        {
            itFilesIterator = vecFiles.erase(itFilesIterator);
        }
        else
        {
            ++itFilesIterator;
        }
    }

    return vecFiles;
}


inline TSTRINGVector
EmptyDirectory(const tstring &tstrDirectory) throw (Win32Err)
{
    return EmptyDirectory(tstrDirectory, CFileFilterNoFilter());
}


#endif // _DIRECTORY_UTILITIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\ptrs.h ===
/*
 * Pointers classes
 *
 * Counter - A thread safe counter class
 * SPTR - Smart pointer with, a pointer class with reference count
 * aptr - Auto pointer
 * aaptr - Array Auto pointer
 */

#ifndef __PTRS_H
#define __PTRS_H


#include <windows.h>
#include <testruntimeerr.h>

#pragma warning( disable: 4284)

/*
 * A thread safe counter class
 */
class Counter
{
public:
	typedef LONG value_type;

	Counter(value_type v = 0) : value(v) {};

	operator value_type() const {return value;}

	value_type operator++() { return InterlockedIncrement(&value); }
	value_type operator++(int) { return InterlockedIncrement(&value)-1;}
	value_type operator--() { return InterlockedDecrement(&value);}
	value_type operator--(int)  { return InterlockedDecrement(&value)+1;} 
	value_type operator=(value_type v) {return InterlockedExchange(&value, v);}

private:
	value_type value;
};

/*
 * Smart pointer - pointer with reference count.
 *                 When the reference count reaches 0, the pointer is deleted.
 *
 * Usage directions:
 * SPTR<C> pi(new int);
 * SPTR<C> p2 = pi;
...
 * NOTES:
 *   - operator=(T*) is not supported on purpose.
 */

class SPTR_ANY;

/*
 * Base class for Smart Pointer, for implementation of SPTR_ANY.
 */
class SPTR_base
{
public:
	virtual ~SPTR_base() {}
	bool operator==(const SPTR_base& ptr) { return eq(ptr); }
	bool operator< (const SPTR_base& ptr) { return lt(ptr); }

protected:
	virtual bool eq(const SPTR_base& ptr) const = 0;
	virtual bool lt(const SPTR_base& ptr) const = 0;
	virtual SPTR_base* clone() const = 0;

	friend class SPTR_ANY;
};

/*
 * SPTR
 */
template<class T>
class SPTR : public SPTR_base
{
public:
	SPTR(T* ptr = NULL): 
		p(ptr)
	{
		new_counter();
	}

	template<class T2> SPTR(const SPTR<T2>& ptr) :
	counter(ptr.get_counter()),
	/*
	 * If you want to be able to copy a base class to a
	 * derived class, you should change the following line
	 * to something like:
	 *    p(dynamic_cast<T*>(ptr.get()))
	 * NOTES: dynamic_cast returns 0 if the cast had failed.
	 */
	p(ptr.get())
	{
		++*counter;
	}

	SPTR(const SPTR& ptr) : 
	counter(ptr.counter),
	p(ptr.p)
	{
		++*counter;
	}

	~SPTR() { unlink(); }

	bool operator==(const SPTR& ptr) const { return p == ptr.p; }
	bool operator< (const SPTR& ptr) const { return p < ptr.p; }

	template <class T2> SPTR& operator=(const SPTR<T2>& ptr)
	{
		if (static_cast<const SPTR_base*>(this) != static_cast<const SPTR_base*>(&ptr))
		{
			  unlink();
			/*
			 * If you want to be able to copy a base class to a
			 * derived class, you should change the following line
			 * to something line:
			 *    p = dynamic_cast<T*>(ptr.get());
			 * NOTE: dynamic_cast returns 0 if the cast had failed.
			 */
			  p = ptr.get();
			  counter = ptr.get_counter();
			  ++*counter;
		}
		return *this;
	}

	SPTR& operator=(const SPTR& ptr)
	{
		if (this != &ptr)
		{
		  unlink();
		  p = ptr.p;
		  counter = ptr.counter;
		  ++*counter;
		}
		return *this;
	}

	SPTR& operator=(const T* pt)
	{
		unlink();
		p = const_cast<T*>(pt);
		new_counter();
		return *this;
	}

	T* get() const  {return p;}
	T** getaddress(){return &p;} //TODO: const?
	T* release()
	{
		if (!--(*counter)) 
		{
		  delete counter;
		}
		T* retval = p;
		p = NULL;
		return retval;
	}
  
	T* operator-> () {return get();}
	T& operator*() { return *get(); }
	//  T** operator&(); // Don't remember why I don't like this operator.
	operator T*() { return get(); }

	Counter* get_counter() const {return counter;}

protected:

	void unlink()
	{
		if (!--(*counter))
		{
		  delete p;
		  p = NULL;
		  delete counter;
		  counter = NULL;
		}
	}

	bool eq(const SPTR_base& ptr) const
	{
		const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
		return *this == sptr_ptr;
	}

	bool lt(const SPTR_base& ptr) const
	{
		const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
		return *this < sptr_ptr;
	}

	SPTR_base* clone() const { return new SPTR(*this); }

	void new_counter()
	{
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" sptr, new"));
		}
	}

	T* p;
	Counter *counter;
};


/*
 * SPTR_ANY: A class that can hold any type of smart pointer.
 */

class SPTR_ANY
{
public:
	SPTR_ANY(const SPTR_base& ptr) { p = ptr.clone(); }
	SPTR_ANY(const SPTR_ANY& ptr) { p = ptr.p->clone(); }
	~SPTR_ANY() { delete p; }
	SPTR_ANY& operator=(const SPTR_ANY& ptr) {delete p; p = ptr.p->clone(); return *this;}
	bool operator==(const SPTR_ANY& ptr) { return *p == *ptr.p; }
	bool operator< (const SPTR_ANY& ptr) { return *p < *ptr.p; }

protected:
	SPTR_base* p;
};

/*
 * Smart pointer for storage of data in STL sets, etc
 * The difference is in the < and == operators, so that find will work
 * on the value and no on the pointers.
 *
 * Never tested, probably does not work....
 */
template<class T>
class SPSTL : public SPTR<T>
{
	SPSTL(T* ptr = NULL) : SPTR<T>(ptr) {}
	SPSTL(const SPSTL& ptr) : SPTR<T>(ptr) {}
	bool operator==(const SPSTL& a2) {return *this == *a2;}
	bool operator<(const SPSTL& a2) {return *this < *a2;}
};

/*------------------------- Auto pointer class -------------------------*/

template<class T>
class aptr
{
protected:
	T* p;
	void cleanup() { delete p; }
public:
	aptr(T* value = NULL) : p(value) {}
	~aptr() { cleanup(); }
	T* operator=(T* value) { cleanup(); p = value; return p; }
	T* operator->() { return p; }
	T& operator*() { return *p; }
	T** operator&() { return &p; }
	operator T*() { return p;}
	T* get() {return p;}
	T* release() { T* t = p; p = NULL; return t; }
};

/*----------------------- Array Auto pointer class ---------------------*/

template<class T>
class aaptr
{
protected:
	T* p;
	Counter *counter;
	void cleanup()
	{ 
		if (!--(*counter))
		{
		  delete[] p;
		  p = NULL;
		  delete counter;
		  counter = NULL;
		}
	}

public:
	aaptr(T* value = NULL) : p(value)
	{
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" aaptr, new"));
		}
	}
	~aaptr() 
	{ 
		cleanup();
	}
	T* operator=(T* value) 
	{
		cleanup(); 
		p = value;
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" aaptr, new"));
		}
		return p; 
	}
	T* operator->() { return p; }
	T& operator*() { return *p; }
	T** operator&() { return &p; }
	operator T*() { return p;}
	T* get() {return p;}
	T* release() 
	{ 
		if (!--(*counter)) 
		{
		  delete counter;
		  counter = NULL;
		}
		
		T* t = p;
		p = NULL;
		return t;
	}

	aaptr(const aaptr& ptr) : 
	counter(ptr.counter),
	p(ptr.p)
	{
		++*counter;
	}

	aaptr& operator=(const aaptr& ptr)
	{
		if (this != &ptr)
		{
			cleanup();
			p = ptr.p;
			counter = ptr.counter;
		    ++*counter;
		}
		return *this;
	}
};
#endif // __PTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\faxbroadcast.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
//
// Filename:	FaxBroadcast.h
// Author:		Sigalit Bar (sigalitb)
// Date:		31-Dec-98
//
//


//
// Description:
//		This file contains the description of 
//		class CFaxBroadcast. This class was designed
//		to allow for broadcast fax sending
//		using the NT5.0 Fax Service API (winfax.h).
//
//		The class has methods that enable it to:
//		* Add a recipient to a broadcast.
//		* Clear the broadcast recipient list, that is remove all
//		  recipients from the broadcast.
//		* Set the Cover Page to use with broadcast.
//		* Output instance information to a stream (CotstrstreamEx).
//		* Return a string description of the instance.
//		
//		
// Usage:
//		An instance of this class can be given to the
//		CFaxSender::send_broadcast() and a broadcast fax sending will be performed.
//		That is, CFaxSender::send_broadcast() will extract the needed parameters for
//      FaxSendDocumentEx from the CFaxBroadcast instance, and will invoke 
//      FaxSendDocumentEx with these parameters.
//
// Comments:
//		The class uses the elle logger wraper implemented
//		in LogElle.c to log any errors.
//
//		Streams are used for i/o handling (streamEx.cpp).
//

#ifndef _FAX_BROADCAST_H_
#define _FAX_BROADCAST_H_


#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <vector>

#include <windows.h>
#include <crtdbg.h>

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST

#include <log.h>
#include "streamEx.h"
#include "wcsutil.h"

using namespace std ;

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)

//
// DefaultFaxRecipientCallback:
//	A default implementation of the required FAX_RECIPIENT_CALLBACK.
//  This function is used by CFaxSender::send_broadcast(), to send a broadcast
//  fax. 
//  That is, CFaxSender::send_broadcast() will invoke FaxSendDocumentForBroadcast
//	giving it a CFaxBroadcast instance as its Context parameter and the
//	exported DefaultFaxRecipientCallback function as its final parameter.
//  The FaxSendDocumentForBroadcast function calls this callback function to 
//  retrieve user-specific information for the transmission. 
//  FaxSendDocumentForBroadcast calls FAX_RECIPIENT_CALLBACK multiple times, 
//  once for each designated fax recipient, passing it the Context parameter.
//
// Parameters:
//	FaxHandle			IN parameter.
//						A handle to the Fax Service that will be used to broadcast
//						fax.
//	RecipientNumber		IN parameter.
//						Indicates the number of times the FaxSendDocumentForBroadcast 
//						function has called the FAX_RECIPIENT_CALLBACK function. 
//						Each function call corresponds to one designated fax recipient, 
//						and the index is relative to 1. 
//
//  Context				IN parameter.
//						A pointer to a CFaxBroadcast instance.
//
//  PFAX_JOB_PARAM		IN OUT parameter.
//						Pointer to a FAX_JOB_PARAM structure that contains the information
//						necessary for the fax server to send the fax transmission to the 
//						designated recipient. 
//						The structure includes, among other items, the recipient's fax 
//						number, sender and recipient data, an optional billing code, and 
//						job scheduling information. 
//						The fax server queues the fax transmission according to the details 
//						specified by the FAX_JOB_PARAM structure.
//						Note - The Fax Service allocates and frees this structure.
//
//	PFAX_COVERPAGE_INFO	IN OUT parameter.
//						Pointer to a FAX_COVERPAGE_INFO structure that contains cover 
//						page data to display on the cover page of the fax document for the 
//						designated recipient. This parameter must be NULL if a cover page 
//						is not required. 
//						Note - The Fax Service allocates and frees this structure.
//
// Return Value:
//	The function returns TRUE to indicate that the FaxSendDocumentForBroadcast function 
//	should queue an outbound fax transmission, using the data pointed to by the 
//	JobParams and CoverpageInfo parameters. 
//	The function returns FALSE to indicate that there are no more fax transmission jobs 
//	to queue, and calls to FAX_RECIPIENT_CALLBACK should be terminated. 
//
BOOL CALLBACK DefaultFaxRecipientCallback(
	HANDLE				/* IN */		FaxHandle,
	DWORD				/* IN */		RecipientNumber,
	LPVOID				/* IN */		Context,
	PFAX_JOB_PARAM		/* IN OUT */	JobParams,
	PFAX_COVERPAGE_INFO	/* IN OUT */	CoverpageInfo OPTIONAL
);
#endif //_NT5FAXTEST



//
// CFaxRecipientVector:
//	An STL list of LPCFAX_PERSONAL_PROFILEs.
//	Intended to contain the personal profiles of the broadcast recipients.
//
#ifdef _C_FAX_RECIPIENT_LIST_
#error "redefinition of _C_FAX_RECIPIENT_LIST_"
#else
#define _C_FAX_RECIPIENT_LIST_
typedef vector< LPCFAX_PERSONAL_PROFILE > CFaxRecipientVector;
#endif //_C_FAX_RECIPIENT_LIST_


//
// CFaxBroadcast:
//	This class was designed to allow for broadcast fax sending
//	using the NT5.0 Fax Service API (winfax.h).
class CFaxBroadcast{

public:

	//
	// CFaxBroadcast:
	//
	CFaxBroadcast(void);

	//
	// ~CFaxBroadcast:
	//
	~CFaxBroadcast(void);

	//
	// AddRecipient:
	//	Adds a recipient's number (as string) to the broadcast.
	//
	// Parameters:
	//	pRecipientProfile	IN parameter.
	//						The recipient profile to add to the broadcast.
	//
	// Return Value:
	//	The function returns TRUE if the profile was successfully added to
	//	the broadcast and FALSE otherwise.
	//
	// Note:
	//	pRecipientProfile and all its fields are duplicated by AddRecipient.
	//
	BOOL AddRecipient(LPCFAX_PERSONAL_PROFILE /* IN */ pRecipientProfile);

	//
	// ClearAllRecipients:
	//	Removes all the recipient profiles from instance.
	//	=> empties vector.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	None.
	//
	void ClearAllRecipients(void);


	// FreeAllRecipients:
	//	Frees all recipient profiles (and their string fields) in vector and empties vector.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	None.
	//
	void FreeAllRecipients(void);

	//
	// SetCPFileName:
	//	Sets the Cover Page file that will be used for the broadcast.
	//
	// Parameters:
	//	szCPFileName	IN parameter.
	//					The Cover Page filename.
	//
	// Return Value:
	//	The function returns TRUE upon success and FALSE otherwise.
	//
	BOOL SetCPFileName(
		LPCTSTR	/* IN */	szCPFileName
		);

	//
	// GetNumberOfRecipients:
	//	Returns the number of recipients in the broadcast.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	The number of recipients currently in the broadcast.
	//
	DWORD GetNumberOfRecipients(void) const;

	//
	// GetRecipient:
	//	Retreives the number (as string) of a recipient in the broadcast.
	//	
	// Parameters:
	//	dwRecipientIndex	IN parameter.
	//						The index of the recipient for which we want to retreive
	//						the number.
	//						This is a 1 based index.
	//	ppRecipientProfile	OUT parameter.
	//						An all level copy of the requested recipient's profile.
	//						The function allocates the memory for the profile and its fields
	//						and the caller must free it.
	//
	// NOTE: dwRecipientIndex is 1 based and the vector is 0 based.
	//
	// Return Value:
	//	The function returns TRUE upon success and FALSE otherwise.
	//
	BOOL GetRecipient(
		DWORD	                /* IN */	dwRecipientIndex,
		PFAX_PERSONAL_PROFILE*	/* OUT */	ppRecipientProfile
		) const;

	//
	// GetCPFileName:
	//	Retreives the Cover Page filename.
	//
	// Parameters:
	//	pszCPFileName	OUT parameter.
	//					A copy of the Cover Page filename.
	//					The function allocates the memory for this string and
	//					the caller must free it.
	//
	// Return Value:
	//	The function return TRUE upon success and FALSE otherwise.
	//
	BOOL GetCPFileName(
		LPTSTR*	/* OUT */	pszCPFileName
		) const;

    //
    // GetBroadcastParams:
    //  Retreives params for all recipients
    //
    //    It will alloc and set OUT params, since caller doesn't know num of recipients
    BOOL GetBroadcastParams(
        PFAX_COVERPAGE_INFO_EX*    /* OUT */	ppCoverPageInfo,
        PDWORD                      /* OUT */	pdwNumRecipients,
        PFAX_PERSONAL_PROFILE*	    /* OUT */	ppRecipientList
        ) const;

	//
	// outputAllToLog:
	//	Outputs a description of all the number strings in the instance
	//	to the elle logger.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD /* IN */ dwSeverity, 
		const DWORD /* IN */ dwLevel
		) const;

	//
	// operator<<:
	//	Appends a string representation of all the fields of a given CFaxBroadcast
	//	instance.
	//
	// Parameters:
	//	os					IN OUT parameter.
	//						The output stream to which the string will be appended.
	//	FaxBroadcastObj		IN parameter.
	//						The CFaxBroadcast instance which the generated string 
	//						will represent.
	//
	// Return Value:
	//	The updated stream.
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&			/* IN OUT */	os, 
		const CFaxBroadcast&	/* IN */		FaxBroadcastObj
		);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&			/* IN OUT */	os, 
		const CFaxBroadcast&	/* IN */		FaxBroadcastObj
		);

private:

	// The Cover Page filename that will be used with the broadcast.
	LPTSTR								m_szCPFileName;

	// An STL vector of strings.
	// Each string represents a recipient's phone number.
	CFaxRecipientVector					m_FaxRecipientVector;

};




#endif //_FAX_BROADCAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\hashitem.h ===
#ifndef __HASH_ITEM_H
#define __HASH_ITEM_H
/*
  An item for the CStrHash class.
  The key is m_Key.
  The Data, however, is not copied, and is deleted by this class.
*/

#define __HASH_ITEM_STAMP 0x18273645

template <class Data, class Key> class CHashItem
{
public:
	CHashItem(
		Key key, 
		CHashItem<Data, Key> *pNext, 
		Data *pData
		):
		m_Key(key),
		m_pData(pData),
		m_pNext(pNext),
		m_dwStamp(__HASH_ITEM_STAMP)
	{
	}

	~CHashItem()
	{
		_ASSERTE(__HASH_ITEM_STAMP == m_dwStamp);
		m_dwStamp = 0x00000000;
		delete m_pData;
	}

	DWORD m_dwStamp;
	Key m_Key;
	Data* m_pData;
	CHashItem<Data, Key> *m_pNext;
};

#endif //__HASH_ITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\randomutilities.h ===
//
// Random Select Subsets.
//
//
//
#ifndef _UTILITIES_H
#define _UTILITIES_H

#include <windows.h>

// Declarations
//
DWORD RandomSelectSizedSubset(DWORD* pdwSubsetArray,
							  const DWORD dwArraySize,
							  const DWORD dwSubsetSize = 0);
DWORD RandomSelectSubset(DWORD* pdwSubsetArray,
						 const DWORD dwArraySize, 
						 const DWORD dwSelectionPercent = 50);


// RandomSelectSizedSubset
// randomly select a subset of dwSubsetSize size. 
//
// [out] dwSubsetArray - an array alocated(!) of dwArraySize size.
//                       The index of a selected element will be marked by 1.
//                       The index of a non selected element will be marked by 0.
//
// [in] dwArraySize - size of dwSubsetArray array.
// [in] dwSubsetSize - size of the subset to select
// 
// returns number of elements selected.
//
inline DWORD RandomSelectSizedSubset(DWORD* pdwSubsetArray,
									 const DWORD dwArraySize,
									 const DWORD dwSubsetSize)
{

	if(!dwArraySize || !pdwSubsetArray || !dwSubsetSize)
	{
		return 0;
	}
	if(dwSubsetSize > dwArraySize)
	{
		return 0;
	}

	srand( GetTickCount() * dwArraySize);
	DWORD dwSubsetCount = 0;
	DWORD dwSubsetProbability = (DWORD)((DOUBLE)( (dwArraySize / dwSubsetSize) + 0.5 )); 
											
	for(DWORD index = 0; index < dwArraySize; index++)
	{
		if( !(rand() % dwSubsetProbability) && (dwSubsetCount < dwSubsetSize))
		{
			pdwSubsetArray[index] = 1;
			++dwSubsetCount;
		}
		else
		{
			if((dwArraySize - index) <= (dwSubsetSize - dwSubsetCount))
			{
				pdwSubsetArray[index] = 1;
				++dwSubsetCount;
			}
			else
			{
				pdwSubsetArray[index] = 0;
			}
		}
	}
	
	return dwSubsetCount;
}


// RandomSelectSubset
// randomly select a subset. Each element has 100/dwSelectionPercent probability to be selcted
//
// [out] dwSubsetArray - an array alocated(!) of dwArraySize size.
//                       The index of a selected element will be marked by 1.
//                       The index of a non selected element will be marked by 0.
//
// [in] dwArraySize - size of dwSubsetArray array.
// [in] dwSelectionPercent - percentage of elements to select. The probability to select
//							 an element is: 100 / dwSelectionPercent
//
// returns number of elements selected.
//
inline DWORD RandomSelectSubset(DWORD* pdwSubsetArray, 
								const DWORD dwArraySize,
								const DWORD dwSelectionPercent)
{

	if(!dwArraySize || !pdwSubsetArray)
	{
		return 0;
	}

	srand( GetTickCount() * dwArraySize);
	DWORD dwSubsetCount = 0;
	DWORD dwComputedPercent = dwSelectionPercent;
	BOOL fMarkSelected = TRUE;
	if(dwSelectionPercent > 50)
	{
		fMarkSelected = FALSE;
		dwComputedPercent = (100 - dwSelectionPercent);
	}
	
	DWORD dwRandomProbability = dwComputedPercent ? (DWORD)(100 / dwComputedPercent) : 1;

	for(DWORD index = 0; index < dwArraySize; index++)
	{
		
		if( !( rand() % dwRandomProbability))
		{
			pdwSubsetArray[index] = fMarkSelected ? 1 : 0;
			++dwSubsetCount;
		}
		else
		{
			pdwSubsetArray[index] = fMarkSelected ? 0 : 1;
		}
	}

	return dwSubsetCount;
}

#endif //_UTILITIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\hash.h ===
#ifndef __INT_HASH
#define __INT_HASH

#include  <crtdbg.h> 
#include "HashItem.h"
#include "..\exception\Exception.h"

/*
  Implements a thread-safe hash table, where the key is a template and the data
  is the template Data.
  A new Data item MUST BE DYNAMICALLY ALLOCATED (with new), it is not copied
  into the hash table.
  The Data item is freed (by delete) by the hash table, so if you need it,
  you must copy it explicitly before destroying the hash table.
  You cannot remove items from the table - i did not need this feature , so
  i did not implement it.
  The hash table is an array of uiARRAY_SIZE items, and uiARRAY_SIZE 
  CRITOCAL_SECTIONs (1 per hash entry). 
  I chose a critical section per entry for maximum liveliness of the program.
  There's no rehash mechanizm.
*/


typedef bool (*FUNCTION_FOREACH)(void *pVoid);

template <class Data, class Key, UINT uiARRAY_SIZE = 256> 
class CHash
{
public:
	CHash();
	~CHash();
	void RemoveAll();
	bool Get(const Key& key, Data ** const ppData) const;
	bool Add(const Key& key, Data * const pData);
	bool OverWrite(const Key& key, Data * const pData);
	bool Remove(const Key& key);
	void Lock(const Key& key) const;
	void UnLock(const Key& key) const;
	bool ForEach(FUNCTION_FOREACH fn);
	unsigned int Hash(const char * const szStr) const;
	unsigned int Hash(int nKey) const;
	unsigned int Hash(const WCHAR * const szStr) const;
private:
	//
	// this is the hash table
	//
	CHashItem<Data, Key>* m_apHashItem[uiARRAY_SIZE];

	//
	// for debug purposes
	//
#ifdef _DEBUG
	int m_nNumOfItems;
#endif

private:
	//
	// protection per hash entry
	//
	mutable CRITICAL_SECTION m_acs[uiARRAY_SIZE];
};


template <class Data, class Key, UINT uiARRAY_SIZE> 
inline CHash<Data,Key,uiARRAY_SIZE>::CHash()
{
	//
	// initialize an array of NULL pointers.
	//
	memset(m_apHashItem, NULL, uiARRAY_SIZE*sizeof(CHashItem<Data, Key>*));

	//
	// initialize the critical sections (1 per hash entry)
	//
	for (int iHashEntry = 0; iHashEntry < (int)uiARRAY_SIZE; iHashEntry++)
	{
		InitializeCriticalSection(&m_acs[iHashEntry]);
	}

#ifdef _DEBUG
		m_nNumOfItems = 0;
#endif
}

template <class Data, class Key, UINT uiARRAY_SIZE> 
inline CHash<Data,Key,uiARRAY_SIZE>::~CHash()
{
	RemoveAll();

	//
	// uninitialize the critical sections (1 per hash entry)
	//
	for (int iHashEntry = 0; iHashEntry < (int)uiARRAY_SIZE; iHashEntry++)
	{
		 DeleteCriticalSection(&m_acs[iHashEntry]);
	}
}


//  RemoveAll
// 
//  removes all the entries and deletes the data they point to.
//  each key is locked and then released.
//  the hash is empty after calling this method.
//
template <class Data, class Key, UINT uiARRAY_SIZE> 
inline void CHash<Data,Key,uiARRAY_SIZE>::RemoveAll()
{
	//
	// delete the list for each entry.
	//
	for (int iCurrentKey = 0; iCurrentKey < (int)uiARRAY_SIZE; iCurrentKey++)
	{
		Lock(iCurrentKey);
		//
		// delete the list for the current entry.
		// hold a pointer to the next item,
		// so that we will safely delete the current item
		//
		CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[iCurrentKey];
		while(pNextItemWithSameKey)
		{
			_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);
			pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
			delete m_apHashItem[iCurrentKey];

#ifdef _DEBUG
			m_nNumOfItems--;
			_ASSERTE(0 <= m_nNumOfItems);
#endif

			//
			// point to next item, or to NULL
			//
			m_apHashItem[iCurrentKey] = pNextItemWithSameKey;
		}//while(pNextItemWithSameKey)

		UnLock(iCurrentKey);
	}//for (int iCurrentKey; iCurrentKey < (int)uiARRAY_SIZE; iCurrentKey++)

	_ASSERTE(0 == m_nNumOfItems);
}


//  Get
//
//  This function searches for an item by its key.
//  If found, sets *ppData to point to the data, so it also can be manipulated,
//  and returns true.
//  If not, returns false.
//
template <class Data, class Key, UINT uiARRAY_SIZE> 
inline bool CHash<Data,Key,uiARRAY_SIZE>::Get(const Key& key, Data ** const ppData) const
{
	if (!ppData)
	{
		_ASSERTE(ppData);
		throw CException(
			TEXT("%s(%d): CHash::Get() ppData = NULL."), TEXT(__FILE__), __LINE__
			);
	}

	int nHashEntry = Hash(key);
	_ASSERTE(0 <= nHashEntry);

	CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[nHashEntry];

	while(pNextItemWithSameKey)
	{
		_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);
		if (key == pNextItemWithSameKey->m_Key)
		{
			//
			// found the key, return the Data.
			//
			*ppData = pNextItemWithSameKey->m_pData;

			return true;
		}
		
		pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
	}//while(pNextItemWithSameKey)

	//
	// The item was not found.
	//

	return false;
}


//	Add
//
//  This function adds an item by its key.
//  If already exists, returns false without doing anything.
//  Else inserts the Item and returns true.
//  Note: the Data is not copied, but it is being freed at destruction.
//
template <class Data, class Key, UINT uiARRAY_SIZE> 
inline bool CHash<Data,Key,uiARRAY_SIZE>::Add(const Key& key, Data * const pData)
{
	if (!pData)
	{
		_ASSERTE(pData);
		throw CException(
			TEXT("%s(%d): CHash::Add() pData = NULL."), TEXT(__FILE__), __LINE__
			);
	}

	int nHashEntry = Hash(key);
	_ASSERTE(0 <= nHashEntry);
	_ASSERTE(uiARRAY_SIZE > nHashEntry);

	CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[nHashEntry];

	while(pNextItemWithSameKey)
	{
		_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);
		//printf("HASHHASHHASH::::!!!!!!!!!!!!!!!!!!!\n");
		if (key == pNextItemWithSameKey->m_Key)
		{
			//
			// found the key, return false
			//
			_ASSERTE(false);
			return false;
		}
		
		pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
	}//while(pNextItemWithSameKey)

	//
	// The item was not found, so add it at the head of the list.
	//
	m_apHashItem[nHashEntry] = 
		new (CHashItem<Data, Key>) (key, m_apHashItem[nHashEntry], pData);
	_ASSERTE(m_apHashItem[nHashEntry]);
	_ASSERTE(__HASH_ITEM_STAMP == m_apHashItem[nHashEntry]->m_dwStamp);

#ifdef _DEBUG
	m_nNumOfItems++;
	//
	// we would not want more that 3 times elements of the hash size,
	// for performance reasons.
	// we may want to rehash here.
	//
	//_ASSERTE(uiARRAY_SIZE*3 > m_nNumOfItems);
#endif

	return true;
}


//	OverWrite
//
//  This function overwrites an exising item by its key.
//  If key wasn't found , returns false without doing anything.
//  Else overwrites the Item and returns true.
//  Note: the Data is not copied, but it is being freed at destruction.
//
template <class Data, class Key, UINT uiARRAY_SIZE> 
inline bool CHash<Data,Key,uiARRAY_SIZE>::OverWrite(const Key& key, Data * const pData)
{
	if (!pData)
	{
		_ASSERTE(pData);
		throw CException(TEXT("%s(%d): CHash::OverWrite() pData = NULL."), 
						 TEXT(__FILE__),
						 __LINE__);
	}

	int nHashEntry = Hash(key);
	_ASSERTE(0 <= nHashEntry);
	_ASSERTE(uiARRAY_SIZE > nHashEntry);


	CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[nHashEntry];
	CHashItem<Data, Key>* pPrevItemWithSameKey = m_apHashItem[nHashEntry];

	while(pNextItemWithSameKey)
	{
		_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);

		if (key == pNextItemWithSameKey->m_Key)
		{
			//
			// found the key, overwrite it.
			// 
			CHashItem<Data, Key>* pNewItem = 
			 new (CHashItem<Data, Key>) (key, pNextItemWithSameKey->m_pNext, pData);
			_ASSERTE(pNewItem);
			_ASSERTE(__HASH_ITEM_STAMP == pNewItem->m_dwStamp);	

			if (m_apHashItem[nHashEntry] == pNextItemWithSameKey)
			{
				m_apHashItem[nHashEntry] = pNewItem;
			}
			else
			{
				//pPrevItemWithSameKey takes 1 iteration to be behind.
				pPrevItemWithSameKey->m_pNext = pNewItem;
			}
			delete pNextItemWithSameKey;

			return true;
		}
		
		if (m_apHashItem[nHashEntry] == pNextItemWithSameKey)
		{
			//continue pointing to m_apHashItem[nHashEntry], because we need pPrevItemWithSameKey
			//to point one item backward
		}
		else
		{
			pPrevItemWithSameKey = pPrevItemWithSameKey->m_pNext;
		}
		pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
	}//while(pNextItemWithSameKey)

	//
	// The item was not found, so return false
	//
	return false;
}


//  Remove
//
//  This function removes an item by its key.
//  If not exists, returns false without doing anything.
//  Else removes the Item and returns true.
//
template <class Data, class Key, UINT uiARRAY_SIZE> 
inline bool CHash<Data,Key,uiARRAY_SIZE>::Remove(const Key& key)
{
	int nHashEntry = Hash(key);
	_ASSERTE(0 <= nHashEntry);
	_ASSERTE(uiARRAY_SIZE > nHashEntry);

	CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[nHashEntry];
	CHashItem<Data, Key>* pPrevItemWithSameKey = m_apHashItem[nHashEntry];

	while(pNextItemWithSameKey)
	{
		_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);

		if (key == pNextItemWithSameKey->m_Key)
		{
			//
			// found the key, remove it.
			// pPrevItemWithSameKey takes 1 iteration to be behind.
			//
			if (m_apHashItem[nHashEntry] == pNextItemWithSameKey)
			{
				m_apHashItem[nHashEntry] = m_apHashItem[nHashEntry]->m_pNext;
			}
			else
			{
				pPrevItemWithSameKey->m_pNext = pNextItemWithSameKey->m_pNext;
			}
			delete pNextItemWithSameKey;

#ifdef _DEBUG
			m_nNumOfItems--;
			_ASSERTE(0 <= m_nNumOfItems);
#endif

			return true;
		}
		
		if (m_apHashItem[nHashEntry] == pNextItemWithSameKey)
		{
			//continue pointing to m_apHashItem[nHashEntry], because we need pPrevItemWithSameKey
			//to point one item backward
		}
		else
		{
			pPrevItemWithSameKey = pPrevItemWithSameKey->m_pNext;
		}
		pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
	}//while(pNextItemWithSameKey)

	//
	// The item was not found, so return false
	//
	return false;
}


template <class Data, class Key, UINT uiARRAY_SIZE> 
inline void CHash<Data,Key,uiARRAY_SIZE>::Lock(const Key& key) const
{
	EnterCriticalSection(&m_acs[Hash(key)]);
}

template <class Data, class Key, UINT uiARRAY_SIZE> 
inline void CHash<Data,Key,uiARRAY_SIZE>::UnLock(const Key& key) const
{
	LeaveCriticalSection(&m_acs[Hash(key)]);
}


template <class Data, class Key, UINT uiARRAY_SIZE> 
inline bool CHash<Data,Key,uiARRAY_SIZE>::ForEach(FUNCTION_FOREACH fn)
{
	bool fRetval = true;

	//
	// lock all the entries
	//
	for(int iHashEntry = 0; iHashEntry < (int)uiARRAY_SIZE; iHashEntry++)
	{
		EnterCriticalSection(&m_acs[iHashEntry]);
	}

	//
	// for each item in the hash, call the function
	//
	for(iHashEntry = 0; iHashEntry < (int)uiARRAY_SIZE; iHashEntry++)
	{
		//
		// for each item in this hash entry, call the function
		//
		CHashItem<Data, Key>* pNextItemWithSameKey = m_apHashItem[iHashEntry];

		while(pNextItemWithSameKey)
		{
			_ASSERTE(__HASH_ITEM_STAMP == pNextItemWithSameKey->m_dwStamp);
			fRetval = fRetval && fn(pNextItemWithSameKey->m_pData);
			pNextItemWithSameKey = pNextItemWithSameKey->m_pNext;
		}//while(pNextItemWithSameKey)

	}

	//
	// release all the entries
	//
	for(iHashEntry = 0; iHashEntry < (int)uiARRAY_SIZE; iHashEntry++)
	{
		LeaveCriticalSection(&m_acs[iHashEntry]);
	}


	return fRetval;
}


template <class Data, class Key, UINT uiARRAY_SIZE> 
inline unsigned int CHash<Data,Key,uiARRAY_SIZE>::Hash(const char * const szStr) const
{
	//
	// return the sum of all the characters modulu uiARRAY_SIZE
	//

	_ASSERTE(szStr);

	const char * szCharIter = szStr;

	unsigned int uiRetval = 0;

	while(*szCharIter)
	{
		uiRetval += _toupper(*szCharIter++);
	}

	uiRetval = uiRetval % uiARRAY_SIZE;

	_ASSERTE(uiRetval < uiARRAY_SIZE);

	return uiRetval;
}

template <class Data, class Key, UINT uiARRAY_SIZE> 
inline unsigned int CHash<Data,Key,uiARRAY_SIZE>::Hash(int nKey) const
{
	return (unsigned int)nKey % uiARRAY_SIZE;
}

template <class Data, class Key, UINT uiARRAY_SIZE> 
inline unsigned int CHash<Data,Key>::Hash(const WCHAR * const szStr) const
{
	//
	// return the sum of all the characters modulu uiARRAY_SIZE
	//

	_ASSERTE(szStr);

	const WCHAR * szCharIter = szStr;

	unsigned int uiRetval = 0;

	while(*szCharIter)
	{
		uiRetval += towupper(*szCharIter++);
	}

	uiRetval = uiRetval % uiARRAY_SIZE;

	_ASSERTE(uiRetval < uiARRAY_SIZE);

	return uiRetval;
}


#endif //#ifndef __INT_HASH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\iniutils.h ===
//
// Ini File Utilities
//
//
#ifndef _INI_UTILS
#define _INI_UTILS

#include <StlDataStructDefs.h>
#include <ptrs.h>
#include <testruntimeerr.h>
#include <tstring.h>
#include <StringUtils.h>

// Defines
//
#define SEPARATOR_CHAR  TEXT("=")

// Declarations
//
TSTRINGMap 
INI_GetSectionEntries        ( const tstring& FileName,
							   const tstring& SectionName,
							   const BOOL fExpandValue = FALSE,
							   const BOOL fExpandKey = FALSE);

TSTRINGVector 
INI_GetSectionList           ( const tstring& FileName,
							   const tstring& SectionName,
							   const BOOL fExpandKey = FALSE);

std::map<tstring, DWORD> 
INI_GetSectionNames          ( const tstring& FileName);

TSTRINGSet INI_GetSectionSet ( const tstring& FileName,
							   const tstring& SectionName,
							   const BOOL fExpandKey = FALSE);

std::vector<TSTRINGPair>
INI_GetOrderedSectionEntries ( const tstring& FileName, 
							   const tstring& SectionName,
							   const BOOL fExpandValue = FALSE,
							   const BOOL fExpandKey = FALSE);

// Static
//
static SPTR<TCHAR> 
GetSectionData               ( const tstring& FileName, 
							   const tstring& SectionName);


/*------------------------------------------------------------------------------------
   function: INI_GetSectionEntries
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - map of section entries, pairs of key and value( display format)
   ------------------------------------------------------------------------------------*/
inline TSTRINGMap 
INI_GetSectionEntries( const tstring& FileName,
					   const tstring& SectionName,
					   const BOOL fExpandValue,
					   const BOOL fExpandKey)
{
	TSTRINGMap SectionEntries;

	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionEntries;
	}
	
	SPTR<TCHAR> tchDataString = GetSectionData( FileName, SectionName);

	tstring Key, Value;
	int Proplen = 0, Separindex = 0;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		DWORD dwRetVal = ERROR_SUCCESS;
		tstring EntryStr = tstring(Propstr, Proplen); 
		Separindex =  EntryStr.find_first_of(SEPARATOR_CHAR);
		
		tstring tstrKeySource = EntryStr.substr(0, Separindex);
		
		if(fExpandKey)
		{
		   dwRetVal= ExpandEnvString(tstrKeySource.c_str(), Key);
		}
		if(!fExpandKey || (dwRetVal != ERROR_SUCCESS))
		{
			Key = tstrKeySource;
		}

		if(Separindex != tstring::npos)
		{
			dwRetVal = ERROR_SUCCESS;
			tstring tstrValueSource = EntryStr.substr(Separindex + 1);
	
			if(fExpandValue)
			{
				dwRetVal= ExpandEnvString(tstrValueSource.c_str(), Value);
			
			}
			if(!fExpandValue || (dwRetVal != ERROR_SUCCESS))
			{
				Value = tstrValueSource;
			}

		}
		else
		{
			Value = TEXT("");
		}
		
		SectionEntries.insert(TSTRINGMap::value_type(Key, Value));
		Propstr = Propstr + Proplen + 1;
	}

	return SectionEntries;

}

/*------------------------------------------------------------------------------------
   function: INI_GetSectionList
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - vector of section entries
   ------------------------------------------------------------------------------------*/
inline TSTRINGVector
INI_GetSectionList( const tstring& FileName,
				    const tstring& SectionName,
				    const BOOL fExpandKey)
{
	TSTRINGVector SectionList;
	
	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionList;
	}

	SPTR<TCHAR> tchDataString = GetSectionData( FileName, SectionName);

	tstring Key, Value;
	int Proplen = 0;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		DWORD 	dwRetVal = ERROR_SUCCESS;
		tstring EntryStr = tstring(Propstr, Proplen); 
		
		if(fExpandKey)
		{
		   dwRetVal= ExpandEnvString(EntryStr.c_str(), Key);
		}
		if(!fExpandKey || (dwRetVal != ERROR_SUCCESS))
		{
			Key = EntryStr;
		}

		SectionList.push_back( Key);
		Propstr = Propstr + Proplen + 1;
	}

	return SectionList;

}


/*------------------------------------------------------------------------------------
   function: INI_GetSectionNames
 
   [in]  tstring& FileName - INI file path.
   return - vector of section names in ini file.
   ------------------------------------------------------------------------------------*/
inline std::map<tstring, DWORD> 
INI_GetSectionNames( const tstring& FileName)
{
	const SECTION_NAMES_SIZE = 4*1024;
	
	std::map<tstring, DWORD> SectionNames;
	SPTR<TCHAR> tchNamesString( new TCHAR[SECTION_NAMES_SIZE]); // for section names

	DWORD res = GetPrivateProfileSectionNames( tchNamesString.get(), SECTION_NAMES_SIZE,
											   FileName.c_str());

	if( res == (SECTION_NAMES_SIZE - 2)) // suspect - buffer is too small
	{
		tchNamesString =  (new TCHAR[ 2*SECTION_NAMES_SIZE]);
		res = GetPrivateProfileSectionNames( tchNamesString.get(), 2*SECTION_NAMES_SIZE,
											 FileName.c_str());
			
		if( res == ( 2*SECTION_NAMES_SIZE - 2 )) // buffer is too small
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_INSUFFICIENT_BUFFER, TEXT(""));
		}
	}

	tstring Namestr;
	int Proplen = 0;

	LPTSTR Propstr = tchNamesString.get();
	while( Proplen = _tcslen(Propstr)) // walk on names buffer
	{
		Namestr = Propstr;
		SectionNames.insert(std::map<tstring, DWORD>::value_type(Namestr, 0));;
	
		Propstr = Propstr + Proplen + 1;
	}

	return SectionNames;
}


/*------------------------------------------------------------------------------------
   function: INI_GetSectionSet
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - Set of section entries
   ------------------------------------------------------------------------------------*/
inline TSTRINGSet 
INI_GetSectionSet( const tstring& FileName,
				   const tstring& SectionName,
 				   const BOOL fExpandKey)
{
	TSTRINGSet SectionSet;

	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionSet;
	}

	SPTR<TCHAR> tchDataString = GetSectionData( FileName, SectionName);

	tstring Key, Value;
	int Proplen = 0;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		DWORD 	dwRetVal = ERROR_SUCCESS;
		tstring EntryStr = tstring(Propstr, Proplen); 
			
		if(fExpandKey)
		{
		   dwRetVal= ExpandEnvString(EntryStr.c_str(), Key);
		}
		if(!fExpandKey || (dwRetVal != ERROR_SUCCESS))
		{
			Key = EntryStr;
		}
		
		SectionSet.insert( Key);
		Propstr = Propstr + Proplen + 1;
	}

	return SectionSet;

}

/*------------------------------------------------------------------------------------
   function: INI_GetOrderedSectionEntries
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - vector of pairs of key and value in the same order they appear in the section
   ------------------------------------------------------------------------------------*/

inline std::vector<TSTRINGPair> 
INI_GetOrderedSectionEntries( const tstring& FileName, 
							  const tstring& SectionName,
							  const BOOL fExpandValue,
							  const BOOL fExpandKey)
{
	std::vector<TSTRINGPair> SectionEntries;

	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionEntries;
	}

	SPTR<TCHAR> tchDataString = GetSectionData( FileName, SectionName);

	tstring Key, Value;
	int Proplen = 0, Separindex = 0;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		DWORD dwRetVal = ERROR_SUCCESS;
		tstring EntryStr = tstring(Propstr, Proplen); 
		Separindex =  EntryStr.find_first_of(SEPARATOR_CHAR);
		
		tstring tstrKeySource = EntryStr.substr(0, Separindex);
		
		if(fExpandKey)
		{
		   dwRetVal= ExpandEnvString(tstrKeySource.c_str(), Key);
		}
		if(!fExpandKey || (dwRetVal != ERROR_SUCCESS))
		{
			Key = tstrKeySource;
		}

		if(Separindex != tstring::npos)
		{
		    dwRetVal = ERROR_SUCCESS;
			tstring tstrValueSource = EntryStr.substr(Separindex + 1);
			
			if(fExpandValue)
			{
				dwRetVal= ExpandEnvString(tstrValueSource.c_str(), Value);
			
			}
			if(!fExpandValue || (dwRetVal != ERROR_SUCCESS))
			{
				Value = tstrValueSource;
			}
			
		}
		else
		{
			Value = TEXT("");
		}
			
		SectionEntries.push_back(std::vector<TSTRINGPair>::value_type(Key, Value));
		Propstr = Propstr + Proplen + 1;
	}

	return SectionEntries;

}


// GetSectionData
//
static SPTR<TCHAR> 
GetSectionData( const tstring& FileName,
                const tstring& SectionName)
{
	const SECTION_DATA_SIZE = 4*1024;
	
	SPTR<TCHAR> tchDataString( new TCHAR[SECTION_DATA_SIZE]); // for section data

	DWORD res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                    SECTION_DATA_SIZE, FileName.c_str());
			
	if( res == (SECTION_DATA_SIZE - 2)) // suspect - buffer is too small
	{
		tchDataString = ( new TCHAR[ 2*SECTION_DATA_SIZE]);
		res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                2*SECTION_DATA_SIZE, FileName.c_str());
	
		if( res == ( 2*SECTION_DATA_SIZE -2 )) // buffer is too small
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_INSUFFICIENT_BUFFER, TEXT(""));
		}
	}

	return tchDataString;
}



#endif // _INI_UTILS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\mtqueue.h ===
#ifndef _MT_QUEUE_H
#define _MT_QUEUE_H

#include <windows.h>
#include <crtdbg.h>
#include "exception.h"
//
// this is a list that enters items to the head and removes from the tail.
// this is done because i need the most efficient thread safe Q of items.
// if i keep the policy of adding on one side and removing from the other side,
// and i do not allow the removal of an item if it is the last one,
// the the adding and removing can be done without lock protection against
// each other, but only against themselves.
//
template <class T, int nINITIAL_Q_SIZE=64>
class CMtQueue
{
public:
    CMtQueue():
        m_lListHead(0),
        m_lListTail(0),
        m_lMaxArrIndex(nINITIAL_Q_SIZE),
		m_hSemaphore(NULL)
	{
		if (0 >= m_lMaxArrIndex)
		{
			throw CException(TEXT("CMtQueue::CMtQueue(), (0 >= m_lMaxArrIndex(%d))"), m_lMaxArrIndex);
		}

        ::InitializeCriticalSection(&m_csInsertOrRemove);

        m_atObject = new T[m_lMaxArrIndex+1];
        if (NULL == m_atObject)
		{
			::DeleteCriticalSection(&m_csInsertOrRemove);
			throw CException(TEXT("CMtQueue::CMtQueue(), new failed with %d"), GetLastError());
		}
		
		m_hSemaphore = ::CreateSemaphore(
			NULL,		// pointer to security attributes
			0,			// initial count
			MAXLONG,	// maximum count
			NULL		// pointer to semaphore-object name
			);
		if (!m_hSemaphore)
		{
			::DeleteCriticalSection(&m_csInsertOrRemove);
			throw CException(TEXT("CMtQueue::CMtQueue(), ::CreateSemaphore() failed with %d"), GetLastError());
		}
	}

		
	~CMtQueue()
	{
        delete[] m_atObject;
		
		::DeleteCriticalSection(&m_csInsertOrRemove);
		if (!::CloseHandle(m_hSemaphore))
		{
			throw CException(TEXT("CMtQueue::~CMtQueue(), ::CloseHandle() failed with %d"), GetLastError());
		}
        
	}

    //
    // adds the item to the head
    //
    bool Queue(T tItem)
    {
        ::EnterCriticalSection(&m_csInsertOrRemove);

        if (FullQueue())
        {
            EnlargeQueue();
        }

        //
        // wraparound
        //
		m_lListHead++;
        if (m_lListHead > m_lMaxArrIndex)
        {
            m_lListHead = 0;
        }

        m_atObject[m_lListHead] = tItem;

		if (!::ReleaseSemaphore(
			m_hSemaphore,		// handle to the semaphore object
			1,					// amount to add to current count
			NULL				// address of previous count
			))
		{
			::LeaveCriticalSection(&m_csInsertOrRemove);
			throw CException(TEXT("CMtQueue::~Queue(), ::ReleaseSemaphore() failed with %d"), GetLastError());
		}

        ::LeaveCriticalSection(&m_csInsertOrRemove);

        return true;
    }

    //
    // remove from end of list.
    // if the list has only 1 item, return a new object
    // please note that the default constructor will be used.
    //
    bool DeQueue(T& tItem)
    {
		return (SyncDeQueue(tItem,0));
	}

	bool SyncDeQueue(T& tItem, DWORD dwTimeout)
    {

		//
        // remove an item from the end of the list
        //
        
		DWORD dwWaitForSingleObjectStatus = ::WaitForSingleObject(
			m_hSemaphore,		// handle to object to wait for
			dwTimeout			// time-out interval in milliseconds
			);
		
		if (WAIT_TIMEOUT == dwWaitForSingleObjectStatus)
		{
			::SetLastError(WAIT_TIMEOUT);
			return false;
		}
		
		if (WAIT_OBJECT_0 != dwWaitForSingleObjectStatus)
		{
			throw CException(TEXT("CMtQueue::SyncDeQueue(), ::WaitForSingleObject(m_hSemaphore, %d) didn't return WAIT_OBJECT_0 or WAIT_TIMEOUT"), dwTimeout); 
		}

		::EnterCriticalSection(&m_csInsertOrRemove);
        //
        // wraparound
        //
		m_lListTail++;
        if (m_lListTail > m_lMaxArrIndex)
        {
            m_lListTail = 0;
        }

        tItem = m_atObject[m_lListTail];

        ::LeaveCriticalSection(&m_csInsertOrRemove);

        return true;
	}


    T& operator[](int index)
    {
		if ( (0 > index) || (m_lMaxArrIndex > index) )
		{
			throw CException(
				TEXT("CMtQueue::operator[], index %d is out of bounds. m_lMaxArrIndex=%d."),
				index, 
				m_lMaxArrIndex
				);
		}

        return m_atObject[index];
    }

	bool IsEmpty()
    {
		bool bIsEmpty;

		::EnterCriticalSection(&m_csInsertOrRemove);

		bIsEmpty = (m_lListHead == m_lListTail);

		::LeaveCriticalSection(&m_csInsertOrRemove);

        return (bIsEmpty);
    }

private:
    T *m_atObject;

    long m_lMaxArrIndex;


    CRITICAL_SECTION m_csInsertOrRemove;

	HANDLE m_hSemaphore;

    long m_lListHead;
    long m_lListTail;

	//
	// assumes that the Q is locked!
	//
    long NumOfObjects()
    {
        return ((m_lListHead >= m_lListTail) ? 
            (m_lListHead - m_lListTail) :
            (m_lMaxArrIndex - m_lListTail + m_lListHead));
    }
            
	//
	// assumes that the Q is locked!
	//
    bool FullQueue()
    {
        return (m_lListHead >= m_lListTail) ? 
            ((m_lListHead - m_lListTail) == m_lMaxArrIndex) :
            ((m_lListTail - m_lListHead) == 1);
    }

	//
	// assumes that the Q is locked!
	//
    void EnlargeQueue()
    {
        T *m_apLargerArray = new T[2*m_lMaxArrIndex+1];
        if (NULL == m_atObject)
		{
			throw CException(TEXT("CMtQueue::EnlargeQueue(), new failed with %d"), GetLastError());
		}

        //
        // copy the old array to the new and bigger one,
        // while starting the new tail as index 0.
        //
        long iOldTail;
        long iObj;
        for (   iOldTail = m_lListTail, iObj = 0;
                iOldTail != m_lListHead;
                iObj++
                )
        {
            m_apLargerArray[iObj] = m_atObject[iOldTail++];

            //
            // lOldHeadIter wraparound
            //
            if (iOldTail > m_lMaxArrIndex)
            {
                iOldTail = 0;
            }
        }

        m_lListTail = 0;
        m_lListHead = iObj;

        delete[] m_atObject;

        m_lMaxArrIndex = m_lMaxArrIndex*2 + 1;
        m_atObject = m_apLargerArray;
    }

	

};

#endif //#ifndef _MT_QUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\reghackutils.h ===
#ifndef _REG_HACK_UTILS_H
#define _REG_HACK_UTILS_H

// standard
#include <windows.h>
#ifndef WIN__95
#include <ntsecapi.h>
#endif
#include <tchar.h>
#include <assert.h>


inline BOOL GetTextualSid( const PSID pSid, LPTSTR tstrTextualSid, LPDWORD cchSidSize);

inline DWORD FormatUserKeyPath( const PSID pSid, const PTCHAR tstrRegRoot, PTCHAR* ptstrCurrentUserKeyPath);

inline DWORD GetCurrentUserSid(PBYTE* pSidUser);

inline BOOL IsNTSystemVersion();

#ifndef WIN__95
//
// Concatenates tstrRegRoot path and a the string representation of the current user's SID.
//
// [in]   tstrRegRoot - Registry root prefix.
// [out]  ptstrCurrentUserKeyPath - Returns a string that represents the current
//        user's root key in the Registry.  Caller must call MemFree
//		  to free the buffer when done with it.
//
// Returns win32 error.

inline DWORD FormatUserKeyPath( const PSID pSid,
								const PTCHAR tstrRegRoot, 
								PTCHAR* ptstrCurrentUserKeyPath)
{
    HANDLE hToken = NULL;
	BYTE* bTokenInfo = NULL;
	TCHAR* tstrTextualSid = NULL;
 	DWORD cchSidSize = 0;
	DWORD dwFuncRetStatus = ERROR_SUCCESS;

	
	assert(pSid);

	if(!GetTextualSid( pSid, NULL, &cchSidSize))
	{
		dwFuncRetStatus = GetLastError();
		if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
		{
			goto Exit;
		}
		dwFuncRetStatus = ERROR_SUCCESS;
	}

	tstrTextualSid = new TCHAR[cchSidSize];
	if(!tstrTextualSid)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	if(!GetTextualSid( pSid, tstrTextualSid, &cchSidSize))
	{
		dwFuncRetStatus = GetLastError();
		goto Exit;
	}

	// allocate an extra char for '\'
	*ptstrCurrentUserKeyPath = new TCHAR[_tcslen(tstrRegRoot) + cchSidSize + 2];
	if(!tstrTextualSid)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	*ptstrCurrentUserKeyPath[0] = TEXT('\0');
	if(tstrRegRoot[0] != TEXT('\0'))
	{
		_tcscat(*ptstrCurrentUserKeyPath,tstrRegRoot);
		if(tstrRegRoot[_tcslen(tstrRegRoot) - 1] != TEXT('\\'))
		{
			_tcscat(*ptstrCurrentUserKeyPath,TEXT("\\"));
		}
	}

	_tcscat(*ptstrCurrentUserKeyPath,tstrTextualSid);

Exit:
	if(hToken)
	{
		CloseHandle(hToken);
	}
	if(bTokenInfo)
	{
		delete bTokenInfo;
	}
	if(tstrTextualSid)
	{
		delete tstrTextualSid;
	}

	return dwFuncRetStatus;

}

//
// return current user SID
//
DWORD GetCurrentUserSid(PBYTE* pSidUser)
{
	
	HANDLE hToken = NULL;
	DWORD dwFuncRetStatus = ERROR_SUCCESS;
	BYTE* bTokenInfo = NULL;
	PSID pReturnedUseSid;

	assert(pSidUser);

	// Open impersonated token
    if(!OpenThreadToken( GetCurrentThread(),
						 TOKEN_READ,
						 TRUE,
						 &hToken))
	{
		dwFuncRetStatus = GetLastError();
	}

	if(dwFuncRetStatus != ERROR_SUCCESS)
	{
		if(dwFuncRetStatus != ERROR_NO_TOKEN)
		{
			return dwFuncRetStatus;
		}
		
		// Thread is not impersonating a user, get the process token
		if(!OpenProcessToken( GetCurrentProcess(),
                              TOKEN_READ,
                              &hToken))
		{
			return GetLastError();
		}
    }

   	DWORD cbBuffer;

	// Get user's token information
	if(!GetTokenInformation( hToken,
							 TokenUser,
							 NULL,
							 0,
							 &cbBuffer))
	{
		dwFuncRetStatus = GetLastError();
		if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
		{
			goto Exit;
		}

		dwFuncRetStatus = ERROR_SUCCESS;
	}

	bTokenInfo = new BYTE[cbBuffer];
	if(!bTokenInfo)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}
	
	if(!GetTokenInformation( hToken,
							 TokenUser,
							 bTokenInfo,
							 cbBuffer,
							 &cbBuffer))
	{
		
		dwFuncRetStatus = GetLastError();
		goto Exit;
	}

	pReturnedUseSid = ( ((TOKEN_USER*)bTokenInfo)->User).Sid; 
	if(!IsValidSid(pReturnedUseSid)) 
	{
		dwFuncRetStatus = E_FAIL;
	}

	*pSidUser = new BYTE[GetLengthSid(pReturnedUseSid)];
 	if(!*pSidUser)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	memcpy(*pSidUser, pReturnedUseSid, GetLengthSid(pReturnedUseSid));

Exit:
	if(hToken)
	{
		CloseHandle(hToken);
	}

	if(bTokenInfo)
	{
		delete bTokenInfo;
	}
	
	return dwFuncRetStatus;	
}

// ------------------------------------------
// This function was copied from SDK samples
// ------------------------------------------
/*
	This function obtain the textual representation
    of a binary Sid.  
  
    A standardized shorthand notation for SIDs makes it simpler to
    visualize their components:

    S-R-I-S-S...

    In the notation shown above,

    S identifies the series of digits as an SID,
    R is the revision level,
    I is the identifier-authority value,
    S is subauthority value(s).

    An SID could be written in this notation as follows:
    S-1-5-32-544

    In this example,
    the SID has a revision level of 1,
    an identifier-authority value of 5,
    first subauthority value of 32,
    second subauthority value of 544.
    (Note that the above Sid represents the local Administrators group)

    The GetTextualSid() function will convert a binary Sid to a textual
    string.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then the SID
    will be in the form:

    S-1-5-21-2127521184-1604012920-1887927527-19009
      ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      | | |      |          |          |        |
      +-+-+------+----------+----------+--------+--- Decimal

    Otherwise it will take the form:

    S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
      ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      |       |        |      |          |          |        |
      |   Hexidecimal  |      |          |          |        |
      +----------------+------+----------+----------+--------+--- Decimal

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended
    error information, call the Win32 API GetLastError().
*/


inline BOOL GetTextualSid( const PSID pSid,          // binary Sid
						   LPTSTR tstrTextualSid,    // buffer for Textual representaion of Sid
						   LPDWORD cchSidSize        // required/provided TextualSid buffersize
						   )
{
    PSID_IDENTIFIER_AUTHORITY pSia;
    DWORD dwSubAuthorities;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) 
	{
		return FALSE;
	}

   	SetLastError(0);
    
	// obtain SidIdentifierAuthority
	//
	pSia = GetSidIdentifierAuthority(pSid);

	if(GetLastError())
	{
		return FALSE;
	}

    // obtain sidsubauthority count
    //
	dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

	if(GetLastError())
	{
		return FALSE;
	}

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
	{
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(tstrTextualSid, TEXT("S-%lu-"), SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (pSia->Value[0] != 0) || (pSia->Value[1] != 0) )
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
							   TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
							   (USHORT)pSia->Value[0],
							   (USHORT)pSia->Value[1],
							   (USHORT)pSia->Value[2],
							   (USHORT)pSia->Value[3],
							   (USHORT)pSia->Value[4],
							   (USHORT)pSia->Value[5]);
    } 
	else
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
							   TEXT("%lu"),
							   (ULONG)(pSia->Value[5])       +
							   (ULONG)(pSia->Value[4] <<  8) +
							   (ULONG)(pSia->Value[3] << 16) +
							   (ULONG)(pSia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    //
    for(DWORD dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy, TEXT("-%lu"),
							  *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}
#endif // #ifndef WIN__95

/*
	Function returns TRUE if the current runing OS is NT platform
*/
BOOL IsNTSystemVersion()
{
	OSVERSIONINFO osvi;

   	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (! GetVersionEx( &osvi)) 
	{
		 return FALSE;
	}

	switch (osvi.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
	// NT platforms
		return TRUE;
		break;

	case VER_PLATFORM_WIN32_WINDOWS:
	// Win95, Win98
		return FALSE;
		break;
	}

	return FALSE;
}

#endif //_REG_HACK_UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\loggerclasses.h ===
#ifndef __C_LOGGER_CLASSES_H__
#define __C_LOGGER_CLASSES_H__



#include <tstring.h>
#include <cs.h>



typedef enum {SEV_MSG = 1, SEV_WRN, SEV_ERR} ENUM_SEV;



//-----------------------------------------------------------------------------------------------------------------------------------------
class CLogger {

public:

    CLogger();

    void OpenLogger();
    
    void CloseLogger();

    void BeginSuite(const tstring &tstrSuiteName);

    void EndSuite();

    void BeginCase(int iCaseCounter, const tstring &tstrCaseName);

    void EndCase();

    void Detail(ENUM_SEV Severity, DWORD dwLevel, LPCTSTR lpctstrFormat, ...);

protected:

    bool IsInitialized() const;

    void SetInitialized(bool bInitialized);

    void ValidateInitialization() const;

private:

    // Avoid usage of copy constructor.
    CLogger(const &CLogger){};
    
    // Avoid usage of assignment operator.
    CLogger operator=(const &CLogger){};
    
    virtual void OpenLogger_Internal() = 0;
    virtual void CloseLogger_Internal() = 0;
    virtual void BeginSuite_Internal(const tstring &tstrSuiteName) = 0;
    virtual void EndSuite_Internal() = 0;
    virtual void BeginCase_Internal(int iCaseCounter, const tstring &tstrCaseName) = 0;
    virtual void EndCase_Internal() = 0;
    virtual void Detail_Internal(ENUM_SEV Severity, DWORD dwLevel, LPTSTR lptstrText) = 0;

    bool             m_bLoggerInitialized;
    CCriticalSection m_CriticalSection;
};



//-----------------------------------------------------------------------------------------------------------------------------------------
class CElleLogger : public CLogger {

public:

    CElleLogger(TCHAR tchDetailsSeparator = _T('\0'));
        
    void OpenLogger_Internal();

    void CloseLogger_Internal();

    void BeginSuite_Internal(const tstring &tstrSuiteName);

    void EndSuite_Internal();
    
    void BeginCase_Internal(int iCaseCounter, const tstring &tstrCaseName);

    void EndCase_Internal();

    void Detail_Internal(ENUM_SEV Severity, DWORD dwLevel, LPTSTR lptstrText);

private:

    DWORD ConvertSeverity(ENUM_SEV Severity);

    TCHAR m_tchDetailsSeparator;
};



//-----------------------------------------------------------------------------------------------------------------------------------------
class CScopeTracer {

public:

    CScopeTracer(CLogger &Logger, DWORD dwLevel, const tstring &tstrScope);

    ~CScopeTracer();

private:

    CLogger  &m_Logger;
    tstring  m_tstrScope;
    DWORD    m_dwLevel;
};



#endif /*__C_LOGGER_CLASSES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\streamex.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename: streamEx.h
// Author:   Sigalit Bar
// Date:     22-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CostrstreamEx which is designed  
//		to make handling of string streams easier. 
//		This class adds two more methods over its
//		base class (the STL ostrstream). 
//
//		The class has methods that enable it to:
//		* Do whatever an ostrstream instance can do.
//		* Return the stream's string representation.
//		* Reset the stream.
//
//
//	The class uses the elle logger wraper implemented
//	in LogElle.c to log errors. Therefor the logger
//	must be initialized before calling any of its methods.
//
//
//
//  Modified on 19-Dec-99 by Miris: 
//	Added declaration of class CotstrstreamEx derived from otstringstream.
//  The class allows tstring manipulation and does not convert unicode strings
//  to multibytes strings
//  
//  	The class has methods that enable it to:
//		* Do whatever an otstringstream instance can do.
//		* Return the stream's string representation.

//	The class uses the elle logger wraper implemented
//	in LogElle.c to log errors. Therefor the logger
//	must be initialized before calling any of its methods.
//
//  This class supports the functionality of CostrstreamEx, however we do
//  keep CostrstreamEx declarations since othere tests use it.
//
//


#ifndef _STREAM_EX_H_
#define _STREAM_EX_H_

#include <tstring.h>

using namespace std;

#include <log.h>


class CostrstreamEx : public ostrstream
{
public:
	CostrstreamEx(void) {};
	~CostrstreamEx(void) {};

	//
	// cstr:
	//	Returns a const string representation of the stream
	//	and resets the stream's insertion point to the start
	//	of the stream's buffer.
	//
	// Note:
	//  This function returns a COPY of the stream's buffer
	//	and resets the stream's buffer.
	//	This has two implications-
	//	A. This function allocates memory for the string it
	//     returns, and the caller is responsible to free it.
	//	B. After a call to this function the stream's buffer
	//	   is reset, that is the insertion point of the stream
	//	   is reset to the start of the stream's buffer
	//	   (overwriting the buffer's contents).
	//
	// Another Note:
	//	cstr automatically appends an "ends" (end string) 
	//	to the stream before converting the buffer to a 
	//	string (ostrstream.str() does not).
	//
	// Example:
	//	The following code -
	//		CstrstreamEx os;
	//		LPCTSTR str;
	//		os<<"ABC";
	//		os<<"123"<<endl;
	//		str = os.cstr();
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//		os<<"ZXW";
	//		os<<"987"<<endl;
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//	Will produce the output-
	//		str=ABC123
	//		str=ZXW987
	//
	LPCTSTR cstr(void);


	//
	// reset:
	//	Unfreezes the stream's buffer (if it is frozen) and
	//	resets the stream's buffer.
	//	That is, the insertion point of the stream is reset
	//	to the start of the stream's buffer (overwriting 
	//	the buffer's contents), and the stream
	//	is made submissive to changes.
	//
	void reset(void);

};

class CotstrstreamEx : public otstringstream
{
public:
	CotstrstreamEx(void) {};
	~CotstrstreamEx(void) {};

	//
	// cstr:
	//	Returns a const tstring representation of the stream
	//	and resets the stream's insertion point to the start
	//	of the stream's buffer.
	//
	// Note:
	//  This function returns a COPY of the stream's buffer
	//	and resets the stream's buffer.
	//	This has two implications-
	//	A. This function allocates memory for the string it
	//     returns, and the caller is responsible to free it.
	//	B. After a call to this function the stream's buffer
	//	   is reset, that is the insertion point of the stream
	//	   is reset to the start of the stream's buffer
	//	   (overwriting the buffer's contents).
	//
	// Another Note:
	//	cstr automatically appends an "ends" (end string) 
	//	to the stream before converting the buffer to a 
	//	string (ostrstream.str() does not).
	//
	// Example:
	//	The following code -
	//		CtstrstreamEx os;
	//		LPCTSTR str;
	//		os<<TEXT("ABC");
	//		os<<TEXT("123")<<endl;
	//		str = os.cstr();
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//		os<<TEXT("ZXW");
	//		os<<TEXT("987")<<endl;
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//	Will produce the output-
	//		str=ABC123
	//		str=ZXW987
	//
	LPCTSTR cstr(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\securityutils.h ===
#ifndef __SECURITY_H__
#define __SECURITY_H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif



/*++
    Retrieves an ACL size in bytes.

    [IN]    pAcl                            Pointer to an ACL.
    [OUT]   pdwSize                         Pointer to a DWORD variable that receives the size.
    [IN]    bActuallyAllocated (optional)   Specifies whether the return value will be the number of bytes,
                                            actually allocated for the ACL or only number of bytes used
                                            to store information (which may be less).

    Return value:                           If the function succeeds, the return value is nonzero.
                                            If the function fails, the return value is zero.
                                            To get extended error information, call GetLastError.
--*/

BOOL GetAclSize(
                PACL    pAcl,
                DWORD   *pdwSize,
                BOOL    bActuallyAllocated = FALSE
                );



/*++
    Retrieves a SID size in bytes.

    [IN]    pSid        Pointer to a SID.
    [OUT]   pdwSize     Pointer to a DWORD variable that receives the size.

    Return value:       If the function succeeds, the return value is nonzero.
                        If the function fails, the return value is zero.
                        To get extended error information, call GetLastError.
--*/

BOOL GetSidSize(
                PSID    pSid,
                DWORD   *pdwSize
                );



/*++
    Creates a copy of a security descriptor.
    
    [IN]    pOriginalSecDesc    Pointer to original security descriptor (in either absolute or self-relative form).
    [IN]    bSelfRelative       Specifies whether a copy of the  security descriptor should be in self-relative form
                                (absolute otherwise).
    [OUT]   ppNewSecDesc        Pointer to a variable that receives pointer to a copy of security descriptor.
                                Memory is allocated by the function. The memory is always allocated as contiguous block.
                                The caller's responsibility is to free it by a call to LocalFree().

    Return value:               If the function succeeds, the return value is nonzero.
                                If the function fails, the return value is zero.
                                To get extended error information, call GetLastError.
--*/

BOOL CopySecDesc(
                 PSECURITY_DESCRIPTOR pOriginalSecDesc,
                 BOOL bSelfRelative,
                 PSECURITY_DESCRIPTOR *ppNewSecDesc
                 );



/*++
    Frees a security descriptor.

    [IN]    pSecDesc    Pointer to a security descriptor (in either absolute or self-relative form).
                        Assumed that the memory pointed to by pSecDesc (and all related ACL and SID structures
                        in case of absolute form) was allocated by LocalAlloc.

    Return value:       If the function succeeds, the return value is nonzero.
                        If the function fails, the return value is zero.
                        To get extended error information, call GetLastError.

                        The function fails if pSecDesc is NULL or points to invalid SD, or if it cannot retrieve
                        the SD form.
--*/

BOOL FreeSecDesc(
                 PSECURITY_DESCRIPTOR pSecDesc
                 );



/*++
    Creates new security descriptor with modified DACL.

    [IN]    pCurrSecDesc    Pointer to current security descriptor (in either absolute or self-relative form).
    [IN]    lptstrTrustee   User or group name. If it's NULL, access is set for currently logged on user.
    [IN]    dwAllow         Specifies access rights to be allowed.
    [IN]    dwDeny          Specifies access rights to be denied.
    [IN]    bReset          Specifies whether old ACL information should be completeley discarded or
                            merged with new informaton.
    [IN]    bSelfRelative   Specifies whether new security descriptor should be in self-relative form
                            (absolute otherwise).
    [OUT]   ppNewSecDesc    Pointer to a variable that receives pointer to modified security descriptor.
                            Memory is allocated by the function. The caller's responsibility is to free it
                            by a call to LocalFree().

    "Deny" is stronger than "Allow". Meaning, if the same right is specified in both dwAllow and dwDeny,
    the right will be denied.

    Calling the function with both dwAllow = 0 and dwDeny = 0 and bReset = TRUE has an affect of removing
    all ACEs for the specified user or group.

    Return value:           If the function succeeds, the return value is nonzero.
                            If the function fails, the return value is zero.
                            To get extended error information, call GetLastError. 
--*/

BOOL CreateSecDescWithModifiedDacl(
                                   PSECURITY_DESCRIPTOR pCurrSecDesc,
                                   LPTSTR lptstrTrustee,
                                   DWORD dwAllow,
                                   DWORD dwDeny,
                                   BOOL bReset,
                                   BOOL bSelfRelative,
                                   PSECURITY_DESCRIPTOR *ppNewSecDesc
                                   );




#ifdef __cplusplus
}
#endif

#endif // #ifndef __SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\params.h ===
/*++

Class Description:
    This class takes the arguments from the command line
    and puts them into a container. You can get each
    argument by calling GetPrm. You can find if argument 
    exists by calling IsExists.
 
--*/
#ifndef _PARAMINPUT_H
#define _PARAMINPUT_H
 
#pragma warning(disable :4786)
#include <iostream>
#include <map>
#include <tstring.h>

class CInput     
{    
public:  
	CInput(const CInput& in);
    CInput(const tstring& tstrinput);
    virtual ~CInput(){};
    bool IsExists(const tstring& tstrinput)const;
    tstring operator[](const tstring& tstrinput)const ;
	long CInput::GetNumber(const tstring& tstrinput)const ;
	CInput& operator=(const const CInput& in);
    
private:
    mutable std::map<tstring,tstring> m_map;
    void ParseToken(const tstring& tstrinput,
                    tstring::size_type tokenstart,
					tstring::size_type tokenfinish);
};    

// constructor
//
inline CInput::CInput(const CInput& in):m_map(in.m_map)
{

}

/*++
Routine Description:
    This routine takes the string from the command line,
    then takes the tokens ("/command:value") from it and
    puts them into a container. 

Arguments:
    tstrinput (IN) - all the arguments contained in one string.

Return Value: none.
--*/
inline CInput::CInput(const tstring& tstrinput)
{
    tstring::size_type tokenstart = 0;
    tstring::size_type tokenfinish = 0;
	tstring tstrtoken;
    while ((tokenstart != tstring::npos) && (tokenfinish != tstring::npos))
    {
        tokenstart = tstrinput.find_first_of(TEXT('/'),tokenfinish);
        if (tokenstart != tstring::npos)
		{
			if( tokenstart + 1 < tstrinput.size())
			{
				tokenfinish = tstrinput.find_first_of(TEXT('/'),tokenstart + 1);
				ParseToken(tstrinput, tokenstart, tokenfinish - 1);
			}
			else
			{
				tokenfinish = tstring::npos;
			}
            
        }
    }
}

// operator=
//
inline CInput& CInput::operator=(const const CInput& in)
{
  if( static_cast<const void*>(this) != static_cast<const void*>(&in))
  {
    m_map = in.m_map;
  }

  return *this;
}

/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    str (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/
inline void CInput::ParseToken(const tstring& tstrinput,
                               tstring::size_type tokenstart,
                               tstring::size_type tokenfinish)
{
    tstring tstrcommand;
    tstring tstrvalue;
    tstring::size_type commandstart;
    tstring::size_type valuestart;
    
	commandstart = tstrinput.find(TEXT('/'), tokenstart) + 1;
    valuestart = tstrinput.find(TEXT(':'),tokenstart) + 1;
    if ((commandstart != tstring::npos) &&
        (valuestart != tstring::npos) &&
        (commandstart < valuestart) &&
        (commandstart <= tokenfinish) &&
        (valuestart <= tokenfinish))
    {
        tstrcommand = tstrinput.substr(commandstart,valuestart - 1 - commandstart);
       	
		tstring::size_type lastchar = tstrinput.find_last_not_of( TEXT(" "), tokenfinish); 
		if(lastchar != tstring::npos)
		{
			tstrvalue = tstrinput.substr(valuestart, (lastchar - valuestart) + 1);
		}
		else
		{
			tstrvalue = tstrinput.substr(valuestart);
		}
		
	    m_map[tstrcommand] = tstrvalue;
    }

    if ((commandstart != tstring::npos) &&
        ((valuestart == tstring::npos) || (valuestart > tokenfinish)) &&
         (commandstart <= tokenfinish))
    {
		tstrcommand = tstrinput.substr(commandstart,valuestart - 1 - commandstart);
		m_map[tstrcommand] = TEXT("");
    }
}


/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    str (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/
inline bool CInput::IsExists(const tstring& tstrinput)const
{
    std::map<tstring,tstring>::const_iterator itermap = m_map.find(tstrinput);
    if (itermap == m_map.end())
    { 
        return false;
    }
    else
    {
        return true;
    }
}

/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    str (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/
inline tstring CInput::operator[](const tstring& tstr)const
{
    if (IsExists(tstr))
    {
        return m_map[tstr];
    }
    else
    {    
       return TEXT("");
    }
}
 

/*++
Routine Description:
  return numeric value for given
  key

Arguments:
    str (IN) - the key.


--*/
inline long CInput::GetNumber(const tstring& tstrinput)const
{
	tstring tstrtemp = operator[](tstrinput);
	return _ttol(tstrtemp.c_str());
}

 
#endif //_PARAMINPUT_H


//
// TODO: For Future Implementation
//
/*++
Routine Description:
    This routine takes the arguments from the command line
    and puts them into a container. Each token 
    ("/command:value") is already apart from the other tokens.

Arguments:
    argc(IN) - number of arguments in the command line.
    argv(IN) - the arguments in the command line.
        
Return Value: none.

Note:
    When you are creating this object using THIS constructor
    the first argument is THE NAME OF THE PROGRAM so this 
    argument is not included in the container. 
--*/
/*
inline CInput::CInput(int argc, char *argv[])
{
    int i;
    for (i=1;i<argc;i++)
    {
        ParseToken(argv[i],0,tstring::npos);
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\smrtptrs.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    smrtptrs.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba (erezh) 11-Mar-96

Revision History:
    Stolen for CRM

--*/

#ifndef _SMRTPTRS_H_
#define _SMRTPTRS_H_

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)
#pragma warning(disable: 4786)

//-----------------------------
//
//  Auto delete pointer
//
template<class T>
class P {
private:
    T* m_p;

public:
    P() : m_p(0)            {}
    P(T* p) : m_p(p)        {}
   ~P()                     { delete m_p; }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    P<T>& operator=(T* p)   { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//-----------------------------
//
//  Auto delete[] pointer, used for arrays
//
template<class T>
class AP {
private:
    T* m_p;

public:
    AP() : m_p(0)           {}
    AP(T* p) : m_p(p)       {}
   ~AP()                    { delete[] m_p; }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    AP<T>& operator=(T* p)  { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//-----------------------------
//
//  Auto relese pointer
//
template<class T>
class R {
private:
    T* m_p;

public:
    R() : m_p(0)            {}
    R(T* p) : m_p(p)        {}
   ~R()                     { if(m_p) m_p->Release(); }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    R<T>& operator=(T* p)   { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};


#endif // _SMRTPTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\stldatastructdefs.h ===
#ifndef STL_DATA_STRUCTURES_DEFINES_H
#define STL_DATA_STRUCTURES_DEFINES_H

#pragma warning(disable :4786)

#include <vector>
#include <map>
#include <set>
#include <comdef.h>
#include <tstring.h>

typedef std::pair<tstring, tstring> TSTRINGPair;
typedef std::vector<TSTRINGPair>    TSTRINGPairsVector;
typedef std::vector<DWORD>			DWORDVector;
typedef std::vector<tstring>		TSTRINGVector;
typedef set<tstring>		        TSTRINGSet;
typedef std::map<tstring, tstring>	TSTRINGMap;
typedef std::map<DWORD, DWORD>      DWORDMap;

#endif //STL_DATA_STRUCTURES_DEFINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\stlauxiliaryfunctions.h ===
#ifndef __STL_AUXILIARY_FUNCTIONS_H__
#define __STL_AUXILIARY_FUNCTIONS_H__


#include <tstring.h>
#include <stldatastructdefs.h>
#include <testruntimeerr.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
// Looks up for the specified key in the map and returns a constant reference to the associated value.
//
// Parameters   [IN]    Map     The map.
//              [IN]    Key     The key.
//
// Return value:        Value, corresponding to the key.
//
// If error occurs, Win32Err exception is thrown.
//
template <class T>
inline const T::referent_type &GetValueFromMap(T &Map, const T::key_type &Key) throw (Win32Err)
{
    T::const_iterator citIterator = Map.find(Key);

    if (citIterator == Map.end())
    {
        tstringstream Stream;
        Stream << _T("GetValueFromMap - key ") << Key << _T(" not found in map");
        THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, Stream.str().c_str());
    }

    return citIterator->second;
}



#endif // #ifndef __STL_AUXILIARY_FUNCTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\sendinfo.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		SendInfo.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CSendInfo which is designed to 
//		contain FAX_EVENT structures received 
//		from the NT5.0 Fax Service (winfax.h). 
//		Each instance of this class contains a
//		private list of FAX_EVENTs.
//
//		The class has methods that enable it to:
//		* Add a FAX_EVENT to a class instance.
//		* Remove All events from a class instance.
//		* Get the last event (related to a specific
//		  NT5.0 Fax Service job ID) from a class
//		  instance.
//		* Return all instance information in a string.
//		* Output instance information to logger.
//
//
//	The class uses the elle logger wraper implemented
//	in LogElle.c to log any fax related errors.
//	Streams are used for i/o handling (streamEx.cpp).
//
// Note:
//		This class uses logging functions (log.h)
//		therefor the logger must be initialized before
//		any call to these functions is made.
//		The functions using the logger are -
//			AddItem()
//			OutpoutAllToLog()
//			OutputJobToLog()
//

#ifndef _SEND_INFO_H_
#define _SEND_INFO_H_

#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <list>

#include <windows.h>


#include <log.h>
#include "streamEx.h"


// Following are summary of definitions of some "function-like" macros:
//
//
//  Macro             _NT5FAXTEST defined                       _NT5FAXTEST not defined
//  ----------------  ---------------------------------------   -----------------------------------------------
//
//  MyGetJobId        receives FAX_JOB_ENTRY, returns JobId     receives FAX_JOB_ENTRY_EX, returns dwJobId
//
//  MyGetMsgId        receives FAX_JOB_ENTRY, returns JobId     receives FAX_JOB_ENTRY_EX, returns dwlMessageId
//
//  MyGetJobType      receives FAX_JOB_ENTRY, returns JobType   receives FAX_JOB_ENTRY_EX, returns dwJobType
//
//  MyGetEventMsgId   receives FAX_EVENT, returns JobId         receives FAX_EVENT_EX, returns dwlMessageId
//
//  MyGetEventType    receives FAX_EVENT, returns EventId       receives FAX_EVENT_EX, returns EventType


#ifdef _NT5FAXTEST
//
// Use legacy API
//

#include <WinFax.h>

// FAX_PERSONAL_PROFILE is defined in fxsapip.h and hence is unaccessible in _NT5FAXTEST mode.
// Since it's used all over FaxSender and CometBVT projects, we #include the definition here.
// Note, that this definition is local for FaxSender and ComentBVT and exists in _NT5FAXTEST mode
// only, when extended APIs are not used. In ! _NT5FAXTEST mode the original version of definition
// from fxsapip.h is used.
#include "PersonalProfile.h"

#include "FaxEvent.h"

typedef FAX_EVENT MY_FAX_EVENT;
typedef DWORD MY_MSG_ID;
#define MyGetEventMsgId(Event)	((Event).JobId)
#define MyGetEventType(Event)	((Event).EventId)

typedef PFAX_JOB_ENTRY PMY_FAX_JOB_ENTRY;
#define MyGetJobId(Job)								((Job).JobId)
#define MyGetMsgId(Job)								((Job).JobId)
#define MyGetJobType(Job)							((Job).JobType)
#define MyFaxEnumJobs(hServer, pBuffer, pCount) 	FaxEnumJobs((hServer), (pBuffer), (pCount))

#else // ! _NT5FAXTEST
//
// Use extended private API
//

#include <fxsapip.h>
#include "FaxEventEx.h"

typedef FAX_EVENT_EX MY_FAX_EVENT;
typedef DWORDLONG MY_MSG_ID;
#define MyGetEventMsgId(Event)	((Event).EventInfo.JobInfo.dwlMessageId)
#define MyGetEventType(Event)	((Event).EventType)

typedef PFAX_JOB_ENTRY_EX PMY_FAX_JOB_ENTRY;
#define MyGetJobId(Job)								((Job).pStatus->dwJobID)
#define MyGetMsgId(Job)								((Job).dwlMessageId)
#define MyGetJobType(Job)							((Job).pStatus->dwJobType)
#define MyFaxEnumJobs(hServer, pBuffer, pCount) 	FaxEnumJobsEx((hServer), JT_UNKNOWN | JT_SEND | JT_RECEIVE, (pBuffer), (pCount))

#endif // #ifdef _NT5FAXTEST


using namespace std ;

// CFaxEventList
// an STL list of FAX_EVENTs
#ifdef _C_FAX_EVENT_LIST_
#error "redefinition of _C_FAX_EVENT_LIST_"
#else
#define _C_FAX_EVENT_LIST_
typedef list< MY_FAX_EVENT > CFaxEventList;
#endif

//
// The "event id" returned for a non-existent event
// Used in function GetLastJobEvent()
// 
#define NO_FAX_EVENTS 0

class CSendInfo 
{
public:
	CSendInfo(void);
	~CSendInfo(void);

	//
	// AddItem:
	//	Creates a deep level copy of NewFaxEvent and places it at the end of the
	//	instance's private list of FAX_EVENT@s.
	//	The description of the added item is also logged with logging 
	//	level 9 to the logger in use.
	//
	// Parameters:
	//	NewFaxEvent		IN parameter.
	//					the FAX_EVENT@ that will be copied and 
	//					added to the list.
	// Return Value:
	//	TRUE if succeeded, FALSE otherwise.
	//
	BOOL AddItem(const MY_FAX_EVENT /* IN */ NewFaxEvent);

	//
	// RemoveAll:
	//	Removes all items from the instance's private list of
	//	FAX_EVENT@s and deallocates them.
	//
	void RemoveAll(void);

	//
	// GetLastJobEvent:
	//	Returns the last event in the instance's private list of
	//	FAX_EVENT@s, that is associated with Fax Service job ID,
	//	and its event ID.
	//
	// Parameters:
	//	dwJobId		IN parameter.
	//				the Fax Service job ID to look for in the instance's
	//				FAX_EVENTs list.
	//	LastEvent	OUT parameter.
	//				the last event in the instance's FAX_EVENT list that
	//				has a job ID equal to dwJobId.
	// Return Value:
	//	The LastEvent's EventId value.
	//	If there are no FAX_EVENT@s with desired JobId,
	//	then the function returns NO_FAX_EVENTS.
	//
	DWORD GetLastJobEvent(
		MY_FAX_EVENT**	/* OUT */	ppLastEvent, 
		MY_MSG_ID		/* IN  */	MsgId
		) const;

	//
	// cstr:
	//	Returns a string which contains all the instance's information.
	//	
	// Return Value:
	//	The formated string describing every FAX_EVENT@ in the instance's 
	//	list.
	//	This string is allocated by the function and should be freed by
	//	the caller.
	//
	LPCTSTR cstr(void) const;

	//
	// outputAllToLog:
	//	Outputs a description of all the FAX_EVENT@s in the instance's
	//	list to the logger in use.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD		/* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD		/* IN */	dwLevel = 1
		) const;

	//
	// outputJobToLog:
	//	Outputs a description of those FAX_EVENT@s in the instance's
	//	list that have JobId field equal to dwJobId, to the logger in use.
	//
	// Parameters:
	//	dwJobId			IN parameter.
	//					the job ID whose FAX_EVENT@s are to be outputed 
	//					to the logger.
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputJobToLog(
		MY_MSG_ID		/* IN */	MsgId, 
		const DWORD		/* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD		/* IN */	dwLevel = 1
		) const;

	//
	// operator<<:
	//	Outputs a description of all the FAX_EVENTs in the instance's
	//	list to (the stream) os.
	//
	// Parameters:
	//	os			IN OUT parameter.
	//				the stream to which the description is appended.
	//	SendInfo	IN parameter.
	//				the CSendInfo instance whose description will be
	//				appended to the stream.
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&		/* IN OUT */	os, 
		const CSendInfo&	/* IN */		SendInfo
		);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&		/* IN OUT */	os, 
		const CSendInfo&	/* IN */		SendInfo
		);

private:

	// a list of FAX_EVENT@s
	CFaxEventList m_EventList;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\t4ctrl.h ===
//---------------------------------------------------------------------------
// T4CTRL.H
//
// Constants, structures, and API prototypes for C interaction with
// T4CTRL*.DLL components of Microsoft Test 4.0b.
//
// Copyright (c) 1991-1997, Microsoft Corporation. All rights reserved.
//---------------------------------------------------------------------------

#ifndef _WINDOWS_
#error This include file requires windows.h be included before this file!
#endif

#ifndef _T4CTRL_H_

#ifdef __cplusplus
extern "C" {
#endif

//#ifndef APIENTRY
//#define APIENTRY FAR PASCAL
//#endif

#ifndef WINAPIV
#define WINAPIV FAR CDECL
#endif

// T4CTRL Trapable Runtime errors
//-----------------------------------------------------------------------------
#define ERR_NO_ERROR                    0
#define ERR_MENU_NOT_FOUND              1
#define ERR_MENU_ITEM_NOT_FOUND         2
#define ERR_NOT_A_LISTBOX               3
#define ERR_LISTBOX_NOT_FOUND           4
#define ERR_ITEM_NOT_IN_LISTBOX         5
#define ERR_INVALID_LISTBOX_INDEX       6
#define ERR_LISTBOX_HAS_NO_STRINGS      7
#define ERR_LISTBOX_IS_NOT_MULTISELECT  8
#define ERR_NOT_A_COMBOBOX              9
#define ERR_COMBOBOX_NOT_FOUND         10
#define ERR_ITEM_NOT_IN_COMBOBOX       11
#define ERR_INVALID_COMBOBOX_INDEX     12
#define ERR_COMBOBOX_HAS_NO_EDITBOX    13
#define ERR_COMBOBOX_HAS_NO_STRINGS    14
#define ERR_NOT_AN_EDITBOX             15
#define ERR_EDITBOX_NOT_FOUND          16
#define ERR_BUTTON_NOT_FOUND           17
#define ERR_OPTION_BUTTON_NOT_FOUND    18
#define ERR_CHECKBOX_NOT_FOUND         19
#define ERR_INVALID_WINDOW_HANDLE      20
#define ERR_NO_SYSTEM_MENU             21
#define ERR_INVALID_MENU_INDEX         22
#define ERR_NOT_A_PUSHBUTTON           23
#define ERR_NOT_A_CHECKBOX             24
#define ERR_NOT_AN_OPTION_BUTTON       25
#define ERR_UNABLE_TO_ENTER_MENU_MODE  26
#define ERR_INVALID_SELECTION          27
#define ERR_CONTROL_IS_DISABLED        28
#define ERR_CANT_MOVE_WND              29
#define ERR_CANT_SIZE_WND              30
#define ERR_CANT_ADJ_SIZE_POS_WND      31
#define ERR_WINDOW_DOES_NOT_EXIST      32
#define ERR_WINDOW_STILL_EXISTS        33
#define ERR_CANT_FIND_LBBOX            34
#define ERR_NOT_OPERATOR_NOT_ALLOWED   35
#define ERR_CANT_ADD_NULL_ITEM         36
#define ERR_INVALID_LINE_INDEX         37
#define ERR_NOT_A_STATIC               38
#define ERR_STATIC_NOT_FOUND           39
#define ERR_NO_CUSTOM_CLASS_SET        40
#define ERR_NOT_A_CUSTOM               41
#define ERR_CUSTOM_NOT_FOUND           42
#define ERR_INVALID_X_Y                43
#define ERR_INVALID_MOUSE_BUTTON       44
#define ERR_NOT_A_SCROLLBAR            45
#define ERR_SCROLLBAR_NOT_FOUND        46
#define ERR_INVALID_SCROLL_POS         47
#define ERR_CANT_ENTER_MENU_MODE       48
#define ERR_DOKEYS_SYNTAX_ERROR        49
#define ERR_PLAYBACK_INTERRUPTION      50
#define ERR_DEADLOCK                   51
#define ERR_NT_CANT_START_PROCESS      52
#define ERR_NT_SYSTEM_ERROR            53
#define ERR_OUT_OF_SYSTEM_RESOURCES    54
#define ERR_VM_INVALID_VM              55
#define ERR_VM_NO_PIPES_OPEN           56
#define ERR_VM_PARAMETERS_OUT_OF_RANGE 57
#define ERR_VM_PIPE_ALREADY_OPEN       58
#define ERR_VM_PIPE_NOT_OPEN           59
#define ERR_VM_WIN32_API_NOT_SUPPORTED 60
#define ERR_VM_WIN31_API_NOT_SUPPORTED 61
#define ERR_VXD_NOT_LOADED             62
#define ERR_CANT_SCROLL_ITEM           63
#define ERR_CANT_GET_ITEM_RECT         64
#define ERR_OUT_OF_MEMORY              65
#define ERR_BAD_READ_STRING_POINTER    66
#define ERR_BAD_WRITE_STRING_POINTER   67
#define ERR_BAD_DEADLOCK_TIMEOUT       68
#define ERR_CANT_CLICK_ITEM_OR_CONTROL 69

#ifdef WIN16

#define ERR_NOT_A_DATAWINDOW           70
#define ERR_DATAWINDOW_NOT_FOUND       71
#define ERR_NOT_A_TABLE                72
#define ERR_TABLE_NOT_FOUND            73
#define ERR_GETTING_CELL_TEXT          74
#define ERR_SAVING_DATA                75

#else
// New 3.x Stuff
//-----------------------------------------------------------------------------
#define ERR_NOT_A_TAB_CTRL             70
#define ERR_TAB_CTRL_NOT_FOUND         71
#define ERR_TAB_ITEM_NOT_FOUND         72
#define ERR_NOT_A_VIEW_CTRL            73
#define ERR_VIEW_CTRL_NOT_FOUND        74
#define ERR_ITEM_NOT_IN_VIEW           75
#define ERR_VIEW_IS_NOT_MULTISELECT    76
#define ERR_HEADER_NOT_IN_VIEW         77
#define ERR_ITEM_NOT_IN_SELECTION      78
#define ERR_NOT_A_HEADER_CTRL          79
#define ERR_HEADER_CTRL_NOT_FOUND      80
#define ERR_HEADER_ITEM_NOT_FOUND      81
#define ERR_NOT_A_TOOLBAR              82
#define ERR_TOOLBAR_NOT_FOUND          83
#define ERR_TOOLBAR_BUTTON_NOT_FOUND   84
#define ERR_NOT_A_SLIDER               85
#define ERR_SLIDER_NOT_FOUND           86
#define ERR_NOT_A_SPIN_CTRL            87
#define ERR_SPIN_CTRL_NOT_FOUND        88
#define ERR_NOT_A_TREE_CTRL            89
#define ERR_TREE_CTRL_NOT_FOUND        90
#define ERR_TREE_ITEM_NOT_FOUND        91
#define ERR_NOT_A_STATUSBAR            92
#define ERR_STATUSBAR_NOT_FOUND        93
#define ERR_STATUSBAR_ITEM_NOT_FOUND   94
#define ERR_NOT_A_TOOLTIPS             95
#define ERR_TOOLTIPS_NOT_FOUND         96
#define ERR_TASKBAR_NOT_FOUND          97
#define ERR_TASKBAR_CLOCK_NOT_FOUND    98
#define ERR_TASKBAR_ICON_NOT_FOUND     99
#define ERR_CANT_FIND_SPACE            100
#define ERR_NOT_A_PROGRESS_CTRL        101
#define ERR_PROGRESS_CTRL_NOT_FOUND    102
#define ERR_CANT_ACCESS_SHARED_MEMORY  103
#endif

#ifndef RC_INVOKED

// wFlag supported by all WFndWndxxx() api
//-----------------------------------------------------------------------------
#ifndef FW_DEFAULT
#define FW_DEFAULT      0x0000  // default
#define FW_PREFIX       0x4000
#define FW_ERROR        0x2000  // default
#define FW_NOERROR      0x0000  // default
#define FW_DIALOG       0x1000
#define FW_DIALOGOK     0x0000  // default
#define FW_MAXIMIZE     0x0800
#define FW_MINIMIZE     0x0400
#define FW_IGNOREFILE   0x0200
#define FW_NOIGNOREFILE 0x0000  // default
#define FW_AMPERSANDOPT 0x0100
#define FW_AMPERSAND    0x0000  // default
#define FW_RESTORE      0x0080
#define FW_NOEXIST      0x0040
#define FW_EXIST        0x0000  // default
#define FW_CHILDNOTOK   0x0020
#define FW_CHILDOK      0x0000  // default
#define FW_HIDDENOK     0x0010
#define FW_HIDDENNOTOK  0x0000  // default
#define FW_ACTIVE       0x0008
#define FW_ALL          0x0000  // default
#define FW_CASE         0x0004
#define FW_NOCASE       0x0000  // default
#define FW_PART         0x0002
#define FW_FULL         0x0000  // default
#define FW_FOCUS        0x0001
#define FW_NOFOCUS      0x0000  // default
#define FW_RESTOREICON  (FW_FOCUS | FW_RESTORE)
#define FW_ACTIVE_ONLY  (FW_ACTIVE | FW_CHILDNOTOK)

//-----------------------------------------------------------------------------
#define FW_CHECKCHAR    0x8000  // INTERNAL USE ONLY
//-----------------------------------------------------------------------------
#endif

// Special Coordinate values to specify center of control, or for some controls
// Unoccuppied "Space"
//---------------------------------------------------------------------------
#ifdef WIN32
    #define W_SPACE       (0x7FFFFFFFL)
    #define W_CENTER      (0x7FFFFFFEL)  // W_SPACE - 1
#else
    #define W_SPACE       (0x7FFF)
    #define W_CENTER      (0x7FFE)       // W_SPACE - 1
#endif

// Miscelaneous routines
//---------------------------------------------------------------------------
LONG WINAPI   WMessage              (HWND hWnd, UINT wMsg);
LONG WINAPI   WMessageW             (HWND hWnd, UINT wMsg, WPARAM wp);
LONG WINAPI   WMessageL             (HWND hWnd, UINT wMsg, LPARAM lp);
LONG WINAPI   WMessageWL            (HWND hWnd, UINT wMsg, WPARAM wp, LPARAM lp);
HWND WINAPI   WGetFocus             (void);
void WINAPI   WResetClasses         (void);
BOOL WINAPI   WIsVisible            (HWND hWnd);
LONG WINAPI   WTextLen              (HWND hWnd);
void WINAPI   WGetText              (HWND hWnd, LPSTR lpszBuffer);
void WINAPI   WSetText              (HWND hWnd, LPSTR lpszText);
int  WINAPI   WNumAltKeys           (void);
void WINAPI   WGetAltKeys           (LPSTR lpszBuff);
int  WINAPI   WNumDupAltKeys        (void);
void WINAPI   WGetDupAltKeys        (LPSTR lpszBuff);
void WINAPI   WDisplayInfo          (HWND, UINT);
//void WINAPI   WEnableOptionalParam  (void);

DWORD WINAPI  SetDefaultWaitTimeout (DWORD dwDefWait);
DWORD WINAPI  SetRetryInterval      (DWORD dwRetryInterval);

#ifdef WIN32
DWORD WINAPI  SetSuspendedTimeout   (DWORD dwMillis);
#endif


// Display Options for WDisplayInfo()
//-----------------------------------
#ifndef DI_DIALOG
#define DI_DIALOG     0x0001
#define DI_DEBUG      0x0002
#define DI_BOTH       0x0003
#endif

//---------------------------------------------------------------------------
// General Window routines and structs
//---------------------------------------------------------------------------

#ifndef _MYSTRUCTS_INCLUDED
typedef struct tagWNDPOS
{
    int left;
    int top;
} WNDPOS;

typedef struct tagWNDSIZ
{
    int width;
    int height;
} WNDSIZ;

typedef struct tagWNDPOSSIZ
{
    int left;
    int top;
    int width;
    int height;
} WNDPOSSIZ;
#endif

typedef WNDPOS    FAR *LPWNDPOS;
typedef WNDSIZ    FAR *LPWNDSIZ;
typedef WNDPOSSIZ FAR *LPWNDPOSSIZ;

#ifndef CTRL_USE_DEF_WAIT
#define CTRL_WAIT_FOREVER  (DWORD)(-1)
// Use this value for timeout parameters to use the default
#define CTRL_USE_DEF_WAIT  (DWORD)(-2)
#define CTRL_ONE_SECOND             1000    // Milliseconds
#define CTRL_DEF_TIMEOUT            5       // Seconds.  Default is no waiting
#define CTRL_DEF_RETRY_INTERVAL     250     // 250 milliseconds
#define CTRL_MIN_RETRY_INTERVAL     55      // 55 milliseconds
#define DEF_SUSPENDED_TIMEOUT       1000    // One second
#define DEF_ACTIVE_TIMEOUT          55      // 55 milliseconds
#endif

HWND WINAPI   WFndWnd       (LPSTR lpszCaption, UINT uFlags, DWORD dwTimeout);
HWND WINAPI   WFndWndC      (LPSTR lpszCaption, LPSTR lpszClass, UINT uFlags, DWORD dwTimeout);
//HWND WINAPI   WFndWndWait   (LPSTR lpszCaption, UINT uFlags, UINT uSeconds);
//HWND WINAPI   WFndWndWaitC  (LPSTR lpszCaption, LPSTR lpszClass,UINT uFlags, UINT uSeconds);
void WINAPI   WMinWnd       (HWND hWnd);
void WINAPI   WMaxWnd       (HWND hWnd);
void WINAPI   WResWnd       (HWND hWnd);
void WINAPI   WSetWndPosSiz (HWND hWnd, int x,  int y, int w, int h);
void WINAPI   WSetWndPos    (HWND hWnd, int x,  int y);
void WINAPI   WSetWndSiz    (HWND hWnd, int w,  int h);
void WINAPI   WAdjWndPosSiz (HWND hWnd, int dx, int dy, int dw, int dh);
void WINAPI   WAdjWndPos    (HWND hWnd, int dx, int dy);
void WINAPI   WAdjWndSiz    (HWND hWnd, int dw, int dh);
void WINAPI   WGetWndPosSiz (HWND hWnd, LPWNDPOSSIZ lpWndPosSiz, BOOL fRelative);
void WINAPI   WGetWndPos    (HWND hWnd, LPWNDPOS    lpWndPos,    BOOL fRelative);
void WINAPI   WGetWndSiz    (HWND hWnd, LPWNDSIZ    lpWndSiz);
void WINAPI   WSetActWnd    (HWND hWnd);
HWND WINAPI   WGetActWnd    (HWND hWnd);
BOOL WINAPI   WIsMaximized  (HWND hWnd);
BOOL WINAPI   WIsMinimized  (HWND hWnd);
void WINAPI   WClkWnd       (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WCtrlClkWnd   (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WShftClkWnd   (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WDblClkWnd    (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WMoveToWnd    (HWND hwnd, int x, int y);
void WINAPI   WDragToWnd    (HWND hwnd, int x, int y, int nBtn); // 0 = VK_LBUTTONb

//---------------------------------------------------------------------------
// Menu routines
//---------------------------------------------------------------------------
void  WINAPI     WMenuSelect        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuExists        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuGrayed        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuChecked       (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuEnabled       (LPSTR lpszItem, DWORD dwTimeout);
int   WINAPI     WMenuCount         (DWORD dwTimeout);
void  WINAPI     WMenuText          (LPSTR lpszItem, LPSTR lpszBuffer, DWORD dwTimeout);
int   WINAPI     WMenuLen           (LPSTR lpszItem, DWORD dwTimeout);
void  WINAPI     WMenuFullText      (LPSTR lpszItem, LPSTR lpszBuffer, DWORD dwTimeout);
int   WINAPI     WMenuFullLen       (LPSTR lpszItem, DWORD dwTimeout);
void  WINAPI     WMenuEnd           (void);
BOOL  WINAPI     WSysMenuExists     (HWND hWnd);
void  WINAPI     WSysMenu           (HWND hWnd);
int   WINAPI     WMenuNumAltKeys    (DWORD dwTimeout);
void  WINAPI     WMenuGetAltKeys    (LPSTR lpszBuff, DWORD dwTimeout);
int   WINAPI     WMenuNumDupAltKeys (DWORD dwTimeout);
void  WINAPI     WMenuGetDupAltKeys (LPSTR lpszBuff, DWORD dwTimeout);
BOOL  WINAPI     WMenuSeparator     (int iIndex, DWORD dwTimeout);
BOOL  WINAPI     WMenuHasPopup      (LPSTR lpszItem, DWORD dwTimeout);

// Obsolete.
//-----------------------------------------------------------------------------
//void  WINAPI   WMenuX             (int iIndex);
//BOOL  WINAPI   WMenuGrayedX       (int iIndex);
//BOOL  WINAPI   WMenuCheckedX      (int iIndex);
//BOOL  WINAPI   WMenuEnabledX      (int iIndex);

//---------------------------------------------------------------------------
// Command button routines.
//---------------------------------------------------------------------------
void WINAPI   WButtonSetClass (LPSTR lpszClassName);
void WINAPI   WButtonGetClass (LPSTR lpszBuffer);
int  WINAPI   WButtonClassLen (void);
BOOL WINAPI   WButtonExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WButtonFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WButtonClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonDefault  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WButtonDefaults (void);
void WINAPI   WButtonSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WButtonMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// CheckBox routines
//---------------------------------------------------------------------------
void WINAPI   WCheckSetClass (LPSTR lpszClassName);
void WINAPI   WCheckGetClass (LPSTR lpszBuffer);
int  WINAPI   WCheckClassLen (void);
BOOL WINAPI   WCheckExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WCheckFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCheckEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCheckFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WCheckState    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckCheck    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckUnCheck  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Option Button routines
//---------------------------------------------------------------------------
void WINAPI   WOptionSetClass (LPSTR lpszClassName);
void WINAPI   WOptionGetClass (LPSTR lpszBuffer);
int  WINAPI   WOptionClassLen (void);
BOOL WINAPI   WOptionExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WOptionFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WOptionEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WOptionFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WOptionState    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionSelect   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Listbox routines
//---------------------------------------------------------------------------
void WINAPI   WListSetClass      (LPSTR lpszClassName);
void WINAPI   WListGetClass      (LPSTR lpszBuffer);
int  WINAPI   WListClassLen      (void);
BOOL WINAPI   WListExists        (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WListFind          (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListCount         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListText          (LPSTR lpszCtrl, LPSTR lpszBuffer, DWORD dwTimeout);
int  WINAPI   WListLen           (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListIndex         (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListTopIndex      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListItemText      (LPSTR lpszCtrl, int iIndex, LPSTR lpszBuffer, DWORD dwTimeout);
int  WINAPI   WListItemLen       (LPSTR lpszCtrl, int iIndex, DWORD dwTimeout);
int  WINAPI   WListItemExists    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemClk       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemCtrlClk   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemShftClk   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemDblClk    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemClkEx     (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemCtrlClkEx (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemShftClkEx (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemDblClkEx  (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
int  WINAPI   WListSelCount      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListSelItems      (LPSTR lpszCtrl, LPINT lpIntArray, DWORD dwTimeout);
//void WINAPI   WListClear         (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WListAddItem       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
//void WINAPI   WListDelItem       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WListEnabled       (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WListFocus         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListSetFocus      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListMoveTo        (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WListItemMoveTo    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListDragTo        (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WListItemDragTo    (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Combobox routines
//---------------------------------------------------------------------------
void WINAPI   WComboSetClass   (LPSTR lpszClass);
void WINAPI   WComboGetClass   (LPSTR lpszBuffer);
int  WINAPI   WComboClassLen   (void);
void WINAPI   WComboSetLBClass (LPSTR lpszClass);
void WINAPI   WComboGetLBClass (LPSTR lpszBuffer);
int  WINAPI   WComboLBClassLen (void);
BOOL WINAPI   WComboExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WComboFind       (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WComboCount      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboText       (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboLen        (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WComboIndex      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetText    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WComboSelText    (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboSelLen     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WComboSelStart   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetSel     (LPSTR lpszCtrl, LONG lSelStart, LONG lSelLength, DWORD dwTimeout);
void WINAPI   WComboItemText   (LPSTR lpszCtrl, int iIndex, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboItemLen    (LPSTR lpszCtrl, int iIndex, DWORD dwTimeout);
int  WINAPI   WComboItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboItemClk    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboItemDblClk (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
//void WINAPI   WComboClear      (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WComboAddItem    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
//void WINAPI   WComboDelItem    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
BOOL WINAPI   WComboEnabled    (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WComboFocus      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetFocus   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WComboItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboDragTo     (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WComboItemDragTo (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Editbox routines
//---------------------------------------------------------------------------
void WINAPI   WEditSetClass (LPSTR lpszClassName);
void WINAPI   WEditGetClass (LPSTR lpszBuffer);
int  WINAPI   WEditClassLen (void);
BOOL WINAPI   WEditExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WEditFind     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLen      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditText     (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
void WINAPI   WEditSetText  (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WEditSelText  (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WEditSelLen   (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditSelStart (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditSetSel   (LPSTR lpszCtrl, LONG lSelStart, LONG lSelLength, DWORD dwTimeout);
void WINAPI   WEditLineText (LPSTR lpszCtrl, LONG lIndex, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WEditLineLen  (LPSTR lpszCtrl, LONG lIndex, DWORD dwTimeout);
LONG WINAPI   WEditPos      (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLine     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditChar     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditFirst    (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLines    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditClick    (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WEditEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WEditFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WEditDragTo   (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Static Control  routines
//---------------------------------------------------------------------------
//void WINAPI   WStaticSetClass (LPSTR);
//void WINAPI   WStaticGetClass (LPSTR lpszBuffer);
//int  WINAPI   WStaticClassLen (void);
//BOOL WINAPIV  WStaticExists   (LPSTR lpszText, ...);
//HWND WINAPIV  WStaticFind     (LPSTR lpszCtrl, ...);
//int  WINAPIV  WStaticLen      (LPSTR lpszText, ...);
//void WINAPIV  WStaticText     (LPSTR lpszText, LPSTR lpszBuffer, ...);
//void WINAPIV  WStaticMoveTo   (LPSTR lpszCtrl, int x, int y, ...);
//void WINAPI   WLabelText      (HWND hwnd, LPSTR lpszBuffer);
//int  WINAPI   WLabelLen       (HWND hwnd);

//---------------------------------------------------------------------------
// Scrollbar routines.
//---------------------------------------------------------------------------
void WINAPI   WScrollSetClass (LPSTR lpszClass);
void WINAPI   WScrollGetClass (LPSTR lpszBuffer);
int  WINAPI   WScrollClassLen (void);
BOOL WINAPI   WScrollExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WScrollFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WScrollEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WScrollFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollMin      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollMax      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollPos      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollSetPos   (LPSTR lpszCtrl, int iPos, DWORD dwTimeout);
void WINAPI   WScrollPage     (LPSTR lpszCtrl, int iPages, DWORD dwTimeout);
void WINAPI   WScrollLine     (LPSTR lpszCtrl, int iLines, DWORD dwTimeout);
void WINAPI   WScrollHome     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollEnd      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Custom Control routines.
//---------------------------------------------------------------------------
void WINAPI   WCustomSetClass (LPSTR lpszClassName);
void WINAPI   WCustomGetClass (LPSTR lpszBuffer);
int  WINAPI   WCustomClassLen (void);
BOOL WINAPI   WCustomExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WCustomFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCustomEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCustomFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomSetText  (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WCustomGetText  (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WCustomTextLen  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomClick    (LPSTR lpszCtrl, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomDblClk   (LPSTR lpszCtrl, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomClickAt  (LPSTR lpszCtrl, int x, int y, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomDblClkAt (LPSTR lpszCtrl, int x, int y, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WCustomDragTo   (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

#ifdef WIN32
//*****************************************************************************
//*****************************************************************************
//                               New 3.x API
//*****************************************************************************
//*****************************************************************************
//---------------------------------------------------------------------------
// TabView Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTabSetClass     (LPSTR lpszClassName);
void WINAPI   WTabGetClass     (LPSTR lpszBuffer);
int  WINAPI   WTabClassLen     (void);
BOOL WINAPI   WTabExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTabFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTabFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTabSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WTabCount        (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTabItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTabItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTabItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WTabItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);

//---------------------------------------------------------------------------
// ListView Control routines.
//---------------------------------------------------------------------------
void WINAPI   WViewSetClass     (LPSTR lpszClassName);
void WINAPI   WViewGetClass     (LPSTR lpszBuffer);
int  WINAPI   WViewClassLen     (void);
BOOL WINAPI   WViewExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WViewFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WViewFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WViewEnabled      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewCount        (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewSelCount     (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewSelItem      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WViewItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszSubItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WViewItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszSubItem, DWORD dwTimeout);
void WINAPI   WViewItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemDblClk   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemCtrlClk  (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemShftClk  (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemLabelClk (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
BOOL WINAPI   WViewHeaderExists (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
int  WINAPI   WViewHeaderCount  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewHeaderText   (LPSTR lpszCtrl, LPSTR lpszHdr, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WViewHeaderLen    (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
void WINAPI   WViewHeaderClk    (LPSTR lpszCtrl, LPSTR lpszHdr, int nBtn, DWORD dwTimeout);
int  WINAPI   WViewMode         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewMoveTo       (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WViewItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewHeaderMoveTo (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
void WINAPI   WViewDragTo       (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemDragTo   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
int  WINAPI   WViewItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WViewItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewClk          (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Tree Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTreeSetClass     (LPSTR lpszClassName);
void WINAPI   WTreeGetClass     (LPSTR lpszBuffer);
int  WINAPI   WTreeClassLen     (void);
BOOL WINAPI   WTreeExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTreeFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTreeSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeEnabled      (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTreeItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeItemDblClk   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
BOOL WINAPI   WTreeItemExpanded (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemExpand   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemCollapse (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeMoveTo       (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WTreeItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeDragTo       (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeItemDragTo   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeSetPathChar  (LPSTR lpszChar);
void WINAPI   WTreeGetPathChar  (LPSTR lpszBuff);
void WINAPI   WTreeItemPath     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTreeItemPathLen  (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemCount    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeClk          (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Header Control routines.
//---------------------------------------------------------------------------
void WINAPI   WHeaderSetClass   (LPSTR lpszClassName);
void WINAPI   WHeaderGetClass   (LPSTR lpszBuffer);
int  WINAPI   WHeaderClassLen   (void);
BOOL WINAPI   WHeaderExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WHeaderFind       (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WHeaderEnabled    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WHeaderCount      (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WHeaderItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WHeaderItemText   (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WHeaderItemLen    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WHeaderItemClk    (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WHeaderMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WHeaderItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Toolbar Control routines.
//---------------------------------------------------------------------------
void WINAPI   WToolbarSetClass      (LPSTR lpszClassName);
void WINAPI   WToolbarGetClass      (LPSTR lpszBuffer);
int  WINAPI   WToolbarClassLen      (void);
BOOL WINAPI   WToolbarExists        (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WToolbarFind          (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WToolbarCount         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonExists  (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonEnabled (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonPressed (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonChecked (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
int  WINAPI   WToolbarButtonIndex   (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
int  WINAPI   WToolbarButtonCmdId   (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonText    (LPSTR lpszCtrl, LPSTR lpszBtn, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WToolbarButtonLen     (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonClk     (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonMoveTo  (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarMoveTo        (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Slider Control routines.
//---------------------------------------------------------------------------
void WINAPI   WSliderSetClass (LPSTR lpszClassName);
void WINAPI   WSliderGetClass (LPSTR lpszBuffer);
int  WINAPI   WSliderClassLen (void);
BOOL WINAPI   WSliderExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WSliderFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSliderFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSliderSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSliderEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderMin      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderMax      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderSelMin   (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderSelMax   (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderPos      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderLine     (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderPage     (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToMin    (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToMax    (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToSelMin (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToSelMax (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToPos    (LPSTR pszCtrl, int nPos, DWORD dwTimeout);
void WINAPI   WSliderBy       (LPSTR pszCtrl, int nTicks, DWORD dwTimeout);
void WINAPI   WSliderByLine   (LPSTR pszCtrl, int nLines, DWORD dwTimeout);
void WINAPI   WSliderByPage   (LPSTR pszCtrl, int nPages, DWORD dwTimeout);
void WINAPI   WSliderMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Spin Control routines.
//---------------------------------------------------------------------------
void WINAPI   WSpinSetClass (LPSTR lpszClassName);
void WINAPI   WSpinGetClass (LPSTR lpszBuffer);
int  WINAPI   WSpinClassLen (void);
BOOL WINAPI   WSpinExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WSpinFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSpinFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSpinEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinMin      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinMax      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinPos      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToMin    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToMax    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToPos    (LPSTR lpszCtrl, int nPos, DWORD dwTimeout);
void WINAPI   WSpinBy       (LPSTR lpszCtrl, int nTicks, DWORD dwTimeout);
void WINAPI   WSpinMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Statusbar Control routines.
//---------------------------------------------------------------------------
void WINAPI   WStatusSetClass   (LPSTR lpszClassName);
void WINAPI   WStatusGetClass   (LPSTR lpszBuffer);
int  WINAPI   WStatusClassLen   (void);
BOOL WINAPI   WStatusExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WStatusFind       (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WStatusCount      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WStatusItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusItemText   (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WStatusItemLen    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WStatusItemIndex  (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Tooltips Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTipsSetClass (LPSTR lpszClassName);
void WINAPI   WTipsGetClass (LPSTR lpszBuffer);
int  WINAPI   WTipsClassLen (void);
BOOL WINAPI   WTipsExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTipsFind     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTipsText     (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTipsLen      (LPSTR lpszCtrl, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Progress Control routines.
//---------------------------------------------------------------------------
void WINAPI   WProgressSetClass (LPSTR lpszClassName);
void WINAPI   WProgressGetClass (LPSTR lpszBuffer);
int  WINAPI   WProgressClassLen (void);
BOOL WINAPI   WProgressExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WProgressFind     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WProgressMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Desktop Control routines.
//---------------------------------------------------------------------------
HWND WINAPI WDesktopFind         (void);
int  WINAPI WDesktopCount        (void);
int  WINAPI WDesktopSelCount     (void);
int  WINAPI WDesktopSelItem      (LPSTR lpszItem);
BOOL WINAPI WDesktopItemExists   (LPSTR lpszItem);
void WINAPI WDesktopItemText     (LPSTR lpszItem, LPSTR lpszBuff);
int  WINAPI WDesktopItemLen      (LPSTR lpszItem);
void WINAPI WDesktopClk          (int x, int y, int nBtn);
void WINAPI WDesktopItemClk      (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemDblClk   (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemCtrlClk  (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemShftClk  (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemLabelClk (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopMoveTo       (int x, int y);
void WINAPI WDesktopItemMoveTo   (LPSTR lpszItem);
void WINAPI WDesktopDragTo       (int x, int y, int nBtn);
void WINAPI WDesktopItemDragTo   (LPSTR lpszItem, int nBtn);

//---------------------------------------------------------------------------
// Taskbar routines.
//---------------------------------------------------------------------------
HWND WINAPI WTaskbarFind         (void);
BOOL WINAPI WTaskbarFocus        (void);
void WINAPI WTaskbarSetFocus     (void);
int  WINAPI WTaskbarCount        (void);
BOOL WINAPI WTaskbarItemExists   (LPSTR lpszItem);
void WINAPI WTaskbarItemClk      (LPSTR lpszItem, int nBtn);
//void WINAPI WTaskbarItemText     (LPSTR lpszItem, LPSTR lpszBuff);
//int  WINAPI WTaskbarItemLen      (LPSTR lpszItem);
int  WINAPI WTaskbarItemIndex    (LPSTR lpszItem);
BOOL WINAPI WTaskbarItemSelected (LPSTR lpszItem);
void WINAPI WTaskbarItemMoveTo   (LPSTR lpszItem);
void WINAPI WTaskbarStartClk     (int nBtn);
void WINAPI WTaskbarStartMoveTo  (void);
void WINAPI WTaskbarClk          (int nBtn);
void WINAPI WTaskbarClockClk     (int nBtn);
void WINAPI WTaskbarClockDblClk  (int nBtn);
void WINAPI WTaskbarClockMoveTo  (void);
void WINAPI WTaskbarAppClk       (int nApp, int nBtn);
void WINAPI WTaskbarAppDblClk    (int nApp, int nBtn);
void WINAPI WTaskbarAppMoveTo    (int nApp);
int  WINAPI WTaskbarAppCount     (void);

//*****************************************************************************
//*****************************************************************************
//                          END of New 3.x API
//*****************************************************************************
//*****************************************************************************
#endif // WIN32

//---------------------------------------------------------------------------
// Event queueing API.
//---------------------------------------------------------------------------
int  WINAPI   QueKeys (LPSTR);
int  WINAPI   QueKeyDn (LPSTR);
int  WINAPI   QueKeyUp (LPSTR);
int  WINAPI   DoKeys (LPSTR);
int  WINAPI   DoKeyshWnd (HWND, LPSTR);

void WINAPI   QuePause (DWORD);
UINT WINAPI   QueSetSpeed (UINT);
int  WINAPI   QueSetFocus (HWND);
int  WINAPI   QueSetRelativeWindow (HWND);

int  WINAPI   QueMouseMove (UINT, UINT);
int  WINAPI   QueMouseDn (int, UINT, UINT);
int  WINAPI   QueMouseUp (int, UINT, UINT);
int  WINAPI   QueMouseClick (int, UINT, UINT);
int  WINAPI   QueMouseDblClk (int, UINT, UINT);
int  WINAPI   QueMouseDblDn (int, UINT, UINT);

int  WINAPI   QueFlush (BOOL);
void WINAPI   QueEmpty (void);

//---------------------------------------------------------------------------
// System idle time detection API.
//---------------------------------------------------------------------------
BOOL WINAPI   WaitUntilIdle (DWORD dwTimeout);
void WINAPI   SetNotIdle (void);

#endif

#ifdef __cplusplus
}
#endif

#endif // _T4CTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\testruntimeerr.h ===
//
//  Run Time Exception Classes
//
#ifndef _TEST_RUN_TIME_ERR_H
#define _TEST_RUN_TIME_ERR_H

#include <windows.h>

//stl
#include <exception>
#include <stdexcept>

#include <tstring.h>

// Declarations
//
static const TCHAR* no_error_str = TEXT("could not construct error string");
#define THROW_TEST_RUN_TIME_WIN32(errorcode,details) throw Win32Err(errorcode,__LINE__,TEXT(__FILE__),details);



////////////////////////// base class for all test run time classes ////////////////////////
class TestRunTimeErr_Base : public std::runtime_error
{
public:
	TestRunTimeErr_Base(DWORD dwErrorcode,DWORD dwLine,const TCHAR* tstrModule,const TCHAR* tstrDetails):std::runtime_error("")
	{
     try
	 { 
        m_tstrModule =   tstrModule;
        m_dwLine = dwLine;
	    m_tstrDetails = tstrDetails;
	    m_dwErrorcode = dwErrorcode;
        if(m_tstrDetails == TEXT(""))
		{
         m_tstrDetails = TEXT("NONE");
		}
	  }
	  catch(...)
	  {

	  }	   
   	}
	// Was preferable using virtual what() of runtime_error class, but this one
	// returns char*
	virtual const TCHAR* description()const{return m_tstrDescription.c_str();}
	virtual const TCHAR* module()const{return m_tstrModule.c_str();}
	virtual const TCHAR* details()const{return m_tstrDetails.c_str();}
	virtual DWORD line()const{return m_dwLine;}
	virtual DWORD error()const{return m_dwErrorcode;}

protected:
	tstring m_tstrDescription;
private:
    tstring m_tstrModule;
	tstring m_tstrDetails;
	DWORD m_dwLine;
	DWORD m_dwErrorcode;
};


/////////////////////////////class for win32 exceptions /////////////////////////////////////////////
class Win32Err : public TestRunTimeErr_Base
{
public: 
	Win32Err(DWORD dwErrorcode,DWORD dwLine,const TCHAR* tstrModule,const TCHAR* tstrDetails)throw():
		TestRunTimeErr_Base(dwErrorcode,dwLine,tstrModule,tstrDetails)
	{
		try
		{
       		otstringstream otstrtmp;
			tstring tstrwin32errstr = SystemErrorDescription( error());
			otstrtmp << TEXT("Got win32 error - ") << error() << TEXT("(") << tstrwin32errstr 
					 << TEXT(")") << TEXT(" Line ") << line() << TEXT(", module ") << module()
					 << TEXT(".") << TEXT(" Details: ") << details() << TEXT(".");
			m_tstrDescription = otstrtmp.str();
		}
		catch(...)
		{
			m_tstrDescription = no_error_str;
		}
	  
    }

	static tstring Win32Err::SystemErrorDescription (DWORD dwErrorCode) 
	{
	   LCID locale =  GetUserDefaultLCID();
	   TCHAR* tstrErrorDescription;	
	   tstring  tstrReturnString;
	   bool fSuccess  = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
									   NULL,
									   dwErrorCode,
									   locale,
									   (LPTSTR)&tstrErrorDescription,
									   0,
									   NULL )!=0;


	  if(fSuccess == true)
	  {
		tstrReturnString = tstrErrorDescription;
	  } 
	  else
	  {
		 tstrReturnString = TEXT("No error description");
	  }

	  return tstrReturnString;
	}

};



#endif //#ifndef _TEST_RUN_TIME_ERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\wcsutil.h ===
//
//
// Filename:	wcsutil.h
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//



#ifndef _WCS_UTIL_H_
#define _WCS_UTIL_H_


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>

//
// DupTStrAsStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
// Parameters:
//	str		The string to be duplicated
//
// Return Value:
//	A new allocation containing the required convertion.
//	If an error occured the return value is NULL.
//
// Note:
//	Even if no actual convertion took place, new memory is allocated.
//
LPCSTR DupTStrAsStr(LPCTSTR /* IN */ str);


//
// DupTStrAsWStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CWSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
// Parameters:
//	str		The string to be duplicated
//
// Return Value:
//	A new allocation containing the required convertion.
//	If an error occured the return value is NULL.
//
// Note:
//	Even if no actual convertion took place, new memory is allocated.
//
LPCWSTR DupTStrAsWStr(LPCTSTR /* IN */ str);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\service.h ===
#ifndef __SERVICE_H__
#define __SERVICE_H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef enum {
	SERVICE_REQUEST_START = 1,
	SERVICE_REQUEST_STOP
} SERVICE_REQUEST;

#define SERVICE_REQUEST_TIMEOUT     1000*60


/*++
    Queries the service for its state until desired state is achieved or until timeout.
  
    [IN]            hService        The service handle.
    [IN]            dwState         The desired state.
    [IN]            dwTimeout       Timeout in milliseconds
    [IN] (optional) dwSleep         Number of milliseconds to sleep between calls to QueryServiceStatus().
                                    If not specified, the default value is used.

    Return value:                   If the function succeeds, the return value is nonzero.
                                    If the function fails, the return value is zero.
                                    To get extended error information, call GetLastError. 
--*/
BOOL WaitForServiceState(
                         const SC_HANDLE    hService,
                         const DWORD        dwState,
                         const DWORD        dwTimeout,
                         const DWORD        dwSleep = 500
                         );



/*++
    Sends a request to a service. The function is synchronous: it returns after required
    operation completes or afer a timeout.
  
    [IN]                lpctstrMachineName  The machine name (NULL for local machine)
    [IN]                lpctstrServiceName  The service name
    [IN]                RequiredAction      Requered action. Supported actions are defined in SERVICE_REQUEST enumeration.
    [OUT] (optional)    pdwDisposition      Pointer to a variable that receives additional information (win32 error code)
                                            about the action request result.
                                            For example, if the request is SERVICE_REQUEST_START and the specified
                                            service is already running, the function will return TRUE and *pdwDisposition
                                            will be set to ERROR_SERVICE_ALREADY_RUNNING.
                                            If pdwDisposition argument is not passed or it is NULL, no additional
                                            information will be supplied.

    Return value:                           If the function succeeds, the return value is nonzero.
                                            If the function fails, the return value is zero.
                                            To get extended error information, call GetLastError. 
--*/
BOOL ServiceRequest(
                    LPCTSTR                 lpctstrMachineName,
                    LPCTSTR                 lpctstrServiceName,
                    const SERVICE_REQUEST   RequiredAction,
                    DWORD                   *pdwDisposition = NULL
                    );



/*++
    Returns the account name under which the specified service runs.
  
    [IN]    lpctstrMachineName      The machine name (NULL for local machine)
    [IN]    lpctstrServiceName      Service name
    [OUT]   lplpctstrAccountName    Pointer to pointer to a buffer, that receives the account name.
                                    The buffer is allocated by the function and caller's responsibility
                                    is to free it with delete operator.

    Return value:                   If the function succeeds, the return value is nonzero.
                                    If the function fails, the return value is zero.
                                    To get extended error information, call GetLastError. 
--*/
BOOL ServiceAccout(
                   LPCTSTR lpctstrMachineName,
                   LPCTSTR lpctstrServiceName,
                   LPTSTR *lplptstrAccountName
                   );


#ifdef __cplusplus
}
#endif

#endif // #ifndef __SERVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\stringutils.h ===
#ifndef   _STRING_UTILS_H
#define   _STRING_UTILS_H

#include <windows.h>
#include <tstring.h>
#include <testruntimeerr.h>

//
// Declarations
//
DWORD AnsiStringToUnicodeString( const char* strAnsi, PWCHAR* wstrUnicode);
DWORD ExpandEnvString(LPCTSTR tstrSource, tstring& ExpandedTstring);


// AnsiStringToUnicodeString
//
// [in] - pointer to ANSI string.
// [out] - pointer to an alocated unicode string. use delete operator to release the string.
//
inline DWORD AnsiStringToUnicodeString( const char* strAnsi,
                                        PWCHAR* wstrUnicode)
{
    DWORD dwBuffSize;
    *wstrUnicode = NULL;

    if(!strAnsi)
    {
        return ERROR_SUCCESS;
    }

    //
    // Get buffer size
    //
    dwBuffSize = MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      strAnsi,
                                      -1,
                                      NULL,
                                      0);

    if (!dwBuffSize) 
    {
        return GetLastError();
    }

    *wstrUnicode = (WCHAR*) new WCHAR[dwBuffSize];
    if(!wstrUnicode)
    {
        return ERROR_OUTOFMEMORY;
    }

    //
    // convert the string
    //
    dwBuffSize = MultiByteToWideChar( CP_ACP,
                                     MB_PRECOMPOSED,
                                     strAnsi,
                                     -1,
                                     *wstrUnicode,
                                     dwBuffSize);

    //
    // the conversion failed
    //
    if (!dwBuffSize) 
    {
        
        delete *wstrUnicode;
        *wstrUnicode = NULL;
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


//
// Expand an enviroment string
//
// [in] - pointer to the string to expand.
// [out] - tstring class with expanded string.
// Return value - win32 error code.

inline DWORD ExpandEnvString(LPCTSTR tstrSource, 
                             tstring& ExpandedTstring)
{
    DWORD dwRetVal = 0;
    DWORD dwBuffSize;
    LPTSTR tstrExpandedString = NULL;

    ExpandedTstring = TEXT("");
    dwRetVal = ExpandEnvironmentStrings( tstrSource, tstrExpandedString, 0);
    if(dwRetVal)
    {
        dwBuffSize = dwRetVal;
        tstrExpandedString = new TCHAR[dwBuffSize];
        if(tstrExpandedString)
        {
            dwRetVal = ExpandEnvironmentStrings( tstrSource, tstrExpandedString, dwBuffSize);
            if(dwRetVal != dwBuffSize)
            {
                dwRetVal = GetLastError();
                if(dwRetVal == ERROR_SUCCESS)
                {
                    ExpandedTstring = tstrExpandedString;
                }
            }
            else
            {
                ExpandedTstring = tstrExpandedString;
                dwRetVal = ERROR_SUCCESS;
            }
        }
        else
        {
            dwRetVal = ERROR_OUTOFMEMORY;
        }
    }

    if(tstrExpandedString)
    {
        delete tstrExpandedString;
    }
    return dwRetVal;
    
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Converts a value of type T to its string representation.
//
// Parameters   [IN]    Input       The value to convert.
//
// Return value:        The string representation of Input.
//
// If error occurs, Win32Err exception is thrown.
//
template <class T>
inline tstring ToString(T Input) throw(Win32Err)
{
    tstringstream Stream;

    if (!(Stream << Input))
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("Cannot convert to string."));
    }

    return Stream.str();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Converts a string to a value of type T.
//
// Parameters   [IN]    The string to be converted.
//
// Return value:        A value of type T.
//
// If error occurs, Win32Err exception is thrown.
//
template <class T>
inline T FromString(const tstring &tstr) throw(Win32Err)
{
    tstringstream Stream(tstr);

    T Output;
    
    if (!(Stream >> Output))
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("Cannot convert to requested type."));
    }

    return Output;
}




//-----------------------------------------------------------------------------------------------------------------------------------------
// Creates a copy of the specified string. The memory is allocated by the function.
// The caller is responsible to free the memory, using delete operator.
//
// Parameters:      [IN]  lpctstrSrc  The string to duplicate.
//
// Return value:    Pointer to the buffer, containing the copy of the source string.
//
// If error occurs, Win32Err exception is thrown.
//
// Note, that if the source string is NULL, the function doesn't treat this as an error
// and doesn't throw exception. Instead it returns NULL.
// This allows the caller not to check that the source is valid.
//
inline LPTSTR DupString(LPCTSTR lpctstrSrc) throw(Win32Err)
{
    if (!lpctstrSrc)
    {
        return NULL;
    }

    LPTSTR lptstrDest = NULL;

    try
    {
        lptstrDest = new TCHAR[_tcslen(lpctstrSrc) + 1];
    }
    catch (Win32Err)
    {
        throw;
    }
    catch (...)
    {
    }

    if (!lptstrDest)
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_ENOUGH_MEMORY, _T("DupString"));
    }

    _tcscpy(lptstrDest, lpctstrSrc);

    return lptstrDest;
}




//-----------------------------------------------------------------------------------------------------------------------------------------
// Ensures that the last character of the specified string is the specified character.
// The function appends the character if needed.
//
// Parameters:      [IN]  tstrString    The string to be checked/modified.
//                  [IN]  tchCharacter  The character.
//
// Return value:    The checked/modified string.
//
// If error occurs, Win32Err exception is thrown.
//
inline tstring ForceLastCharacter(const tstring &tstrString, TCHAR tchCharacter) throw(Win32Err)
{
    tstring::const_reverse_iterator citReverseIterator = tstrString.rbegin();
    return (*citReverseIterator == tchCharacter) ? tstrString : tstrString + tchCharacter;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Ensures that the last character of the specified string is not the specified character.
// The function removes one or more characters if needed.
//
// Parameters:      [IN]  tstrString    The string to be checked/modified.
//                  [IN]  tchCharacter  The character.
//
// Return value:    The checked/modified string.
//
// If error occurs, Win32Err exception is thrown.
//
inline tstring EliminateLastCharacter(const tstring &tstrString, TCHAR tchCharacter) throw(Win32Err)
{
    for (int iEnd = tstrString.size() - 1; iEnd >= 0; --iEnd)
    {
        if (tstrString[iEnd]  != tchCharacter)
        {
            return tstrString.substr(0, iEnd + 1);
        }
    }

    return _T("");
}



#endif //_STRING_UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\tiffutils.h ===
#ifndef __TIFF_UTILS_H__
#define __TIFF_UTILS_H__



/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    TiffUtils.h

Abstract:

    This file is the public header file for the TiffUtils.dll.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/



#include <windows.h>
#include <tchar.h>



#ifndef TIFFUTILS_EXPORTS
#define TIFFUTILSAPI __declspec(dllimport)
#else
#define TIFFUTILSAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif



TIFFUTILSAPI
DWORD
WINAPI
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    );

TIFFUTILSAPI
DWORD
WINAPI
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    );

TIFFUTILSAPI
BOOL
WINAPI
TiffCompare(
    LPTSTR  lpctstrFirstTiffFile,
    LPTSTR  lpctstrSecondTiffFile,
    BOOL    fSkipFirstLineOfSecondFile,
    int     *piDifferentBits
    );

//
// func compares *.tif files in directory szDir1 to *.tif files in directory szDir2
// returns true iff for every *.tif file in szDir1 there exists a *.tif 
// file in szDir2 whose image is identical, and vice versa.
// 
// dwExpectedNumberOfFiles specifies the expected number of files in both directories.
// if number of files is unknown, this parameter must be -1 (0xFFFFFFFF).
//
TIFFUTILSAPI
BOOL
WINAPI
DirToDirTiffCompare(
    LPTSTR  /* IN */    szDir1,
    LPTSTR  /* IN */    szDir2,
    BOOL    /* IN */    fSkipFirstLine,
    DWORD   /* IN */    dwExpectedNumberOfFiles
    );


#ifdef __cplusplus
}
#endif



#endif // #ifndef __TIFF_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\dummyfilenamevec.cpp ===
#include <FilenameVec.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\testsuite.h ===
#ifndef __TEST_SUITE_H__
#define __TEST_SUITE_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This file contains definition of Test Suite Manager.

    Author: Yury Berezansky (YuryB)

    10-May-2001

-----------------------------------------------------------------------------------------------------------------------------------------*/



#pragma warning(disable :4786)
#include <vector>
#include <map>
#include <windows.h>
#include <new.h>
#include <stldatastructdefs.h>
#include <LoggerClasses.h>
#include <tstring.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
//
// Test factory hierarchy.
//



//
// Forward declaration.
//
class CTest;



//
// The base class for "test factory hierarchy".
//
class CTestFactory {

public:

    virtual CTest *CreateTest(
                              const tstring &tstrName,
                              const tstring &tstrDescription,
                              CLogger       &Logger,
                              int           iRunsCount,
                              int           iDeepness
                              ) = 0;
};



typedef std::map<tstring, CTestFactory *> TEST_FACTORY_MAP;
typedef TEST_FACTORY_MAP::const_iterator  TEST_FACTORY_MAP_CONST_ITERATOR;
typedef TEST_FACTORY_MAP::value_type      TEST_FACTORY_MAP_ENTRY;



//
// Defines a test factory for specified test class.
//
#define DEFINE_TEST_FACTORY(Test)                                                      \
    class Test##Factory : public CTestFactory {                                        \
        virtual CTest *CreateTest(                                                     \
                                  const tstring &tstrName,                             \
                                  const tstring &tstrDescription,                      \
                                  CLogger       &Logger,                               \
                                  int           iRunsCount,                            \
                                  int           iDeepness                              \
                                  )                                                    \
        {                                                                              \
            return new Test(tstrName, tstrDescription, Logger, iRunsCount, iDeepness); \
        }                                                                              \
    };



//-----------------------------------------------------------------------------------------------------------------------------------------
//
// Test suite hierarchy.
//



//
// Forward declaration.
//
class CTestContainer;



//
// The base class of the "test suite hierarchy".
//
class CTest {

public:

    virtual ~CTest();
    
    virtual void Init(const CTestContainer *pContainer) = 0;

    CLogger &GetLogger() const;

    const tstring &GetName() const;

    const tstring &GetDescription() const;

    int GetRunsCount() const;

    virtual int GetReportedCasesCountPerRun() const = 0;
    
    int GetDeepness() const;

    bool IsInitialized() const;
    
    const CTestContainer &GetContainer() const;
    
    virtual bool Run() = 0;

    virtual void BeginLog(int iRun, int iCasesCounter);

    virtual void EndLog(bool bPassed, int iRun);

protected:

    CTest(
          const tstring &tstrName,
          const tstring &tstrDescription,
          CLogger       &Logger,
          int           iRunsCount,
          int           iDeepness
          );

    void SetInitialized(bool bInitialized);

    void SetContainer(const CTestContainer *pContainer);
    
    static bool IsCommonEntry(const tstring &tstrEntry);

private:

    tstring              m_tstrName;
    tstring              m_tstrDescription;
    CLogger              &m_Logger;
    int                  m_iRunsCount;
    int                  m_iDeepness;
    bool                 m_bInitialized;
    const CTestContainer *m_pContainer;
};



//
// The base class for all test cases.
//
class CTestCase : public CTest {

public:

    virtual void Init(const CTestContainer *pContainer);
    
    virtual int GetReportedCasesCountPerRun() const;
    
    virtual void BeginLog(int iRun, int iCasesCounter);
    
    virtual void EndLog(bool bPassed, int iRun);

protected:

    CTestCase(
              const tstring &tstrName,
              const tstring &tstrDescription,
              CLogger       &Logger,
              int           iRunsCount,
              int           iDeepness
              );
private:

    virtual void ParseParams(const TSTRINGMap &mapParams) = 0;
};



//
// Extension of CTestCase class which allows to define not reported test cases, like delays, pauses etc.
//
class CNotReportedTestCase : public CTestCase {

public:

    CNotReportedTestCase(
                         const tstring &tstrName,
                         const tstring &tstrDescription,
                         CLogger       &Logger,
                         int           iRunsCount,
                         int           iDeepness
                         );

    virtual int GetReportedCasesCountPerRun() const;
    
    virtual void BeginLog(int iRun, int iCasesCounter);
    
    virtual void EndLog(bool bPassed, int iRun);
};



//
// Fully implemented test case that allows to execute shell commands.
//
class CShellExecute : public CTestCase {

public:

    CShellExecute(
                  const tstring &tstrName,
                  const tstring &tstrDescription,
                  CLogger       &Logger,
                  int           iRunsCount,
                  int           iDeepness
                  );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    tstring m_tstrVerb;
    tstring m_tstrFile;
    tstring m_tstrParameters;
    bool    m_bResultMatters;
};



DEFINE_TEST_FACTORY(CShellExecute);



//
// Fully implemented test case that allows to insert sleeps between other tests.
//
class CDelay : public CNotReportedTestCase {

public:

    CDelay(
           const tstring &tstrName,
           const tstring &tstrDescription,
           CLogger       &Logger,
           int           iRunsCount,
           int           iDeepness
           );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    DWORD m_dwWaitDuration;
};



DEFINE_TEST_FACTORY(CDelay);



//
// Fully implemented test case that allows to insert pauses between other tests.
//
class CPause : public CNotReportedTestCase {

public:

    CPause(
           const tstring &tstrName,
           const tstring &tstrDescription,
           CLogger       &Logger,
           int           iRunsCount,
           int           iDeepness
           );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);
};



DEFINE_TEST_FACTORY(CPause);



//
// Fully implemented test case that allows to insert debug breaks between other tests.
//
class CDebugBreak : public CNotReportedTestCase {

public:

    CDebugBreak(
                const tstring &tstrName,
                const tstring &tstrDescription,
                CLogger       &Logger,
                int           iRunsCount,
                int           iDeepness
                );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);
};



DEFINE_TEST_FACTORY(CDebugBreak);



//
// Fully implemented test container. The functionality may be added/overridden to provide
// additional/different behavior.
//
class CTestContainer : public CTest {

public:

    CTestContainer(
                   const tstring &tstrName,
                   const tstring &tstrDescription,
                   CLogger       &Logger,
                   int           iRunsCount,
                   int           iDeepness
                   );

    ~CTestContainer();

    const tstring &GetIniFile() const;
    
    virtual void Init(const CTestContainer *pContainer);

    virtual int GetReportedCasesCountPerRun() const;
    
    virtual bool Run();

    const TSTRINGMap &GetParams(const tstring &tstrTestName) const;

    const std::vector<TSTRINGPair> &GetOrderedParams(const tstring &tstrTestName) const;

    const TEST_FACTORY_MAP &GetFactoryMap() const;

    const TSTRINGMap &GetMacrosMap() const;

    bool GetContinueOnFailure() const;

    virtual void BeginLog(int iRun, int iCasesCounter);

protected:

    void Init(
              const std::vector<TSTRINGPair> &vecParams,
              const tstring                  &tstrIniFile,
              const TEST_FACTORY_MAP         &mapFactoryMap,
              const TSTRINGMap               &mapMacrosMap,
              bool                           bContinueOnFailure
              );

private:

    void ReadCurrentTestSection() const;

    const TSTRINGMap &GetCommonEntries(const tstring &tstrTestName) const;

    tstring                          m_tstrIniFile;
    const TEST_FACTORY_MAP           *m_pFactoryMap;
    const TSTRINGMap                 *m_pMacrosMap;
    bool                             m_bContinueOnFailure;
    vector<CTest *>                  m_vecTests;
    int                              m_iBaseCasesCounter;
    int                              m_iReportedCasesCountPerRun;
    mutable tstring                  m_tstrCurrentTestSection;
    mutable TSTRINGMap               m_mapCurrentTestParamsMap;
    mutable std::vector<TSTRINGPair> m_vecCurrentTestParamsVector;
    mutable TSTRINGMap               m_mapCurrentTestCommonEntriesMap;
    bool                             m_bCurrentTestContinueOnFailure;
};



DEFINE_TEST_FACTORY(CTestContainer);



//
// Fully implemented test suite, an example of test container extension.
//
class CTestSuite : public CTestContainer {

public:

    CTestSuite(const tstring &tstrName, const tstring &tstrDescription, CLogger &Logger);

    ~CTestSuite();

    bool Do(const tstring &tstrIniFile, const TEST_FACTORY_MAP &mapFactoryMap);

    virtual void BeginLog(int iRun, int iCasesCounter);

    virtual void EndLog(bool bPassed, int iRun);

private:

    static int __cdecl OperatorNewFailureHandler(size_t size);

    TSTRINGMap        m_vecSuiteDefinition;
    _PNH              m_OldNewHandler;
};




#endif // #ifndef __TEST_SUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\inc\tstring.h ===
//---------------------------------------------------------------------------
//
//
// File:        TSTRING.H
//
// Contents:    tstring C++ type for TCHAR strings
//
//---------------------------------------------------------------------------

#ifndef _TSTRING_H
#define _TSTRING_H

#include <windows.h>
#include <Wtypes.h>
#include <tchar.h>

// stl
#include <string>
#include <iostream>
#include <sstream>
#include <strstream>

using namespace std;
typedef std::basic_string<TCHAR, char_traits<TCHAR>, allocator<TCHAR> > tstring;
typedef std::basic_string<OLECHAR, char_traits<OLECHAR>, allocator<OLECHAR> > olestring;
typedef std::basic_istringstream<TCHAR> itstringstream;
typedef std::basic_ostringstream<TCHAR> otstringstream;
typedef std::basic_stringstream<TCHAR>  tstringstream;
typedef std::basic_istringstream<TCHAR> itstringstream;
typedef std::basic_ostringstream<TCHAR> otstringstream;
typedef std::basic_stringstream<TCHAR>  tstringstream;



#endif //#ifndef _TSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\bvt.h ===
//
//
// Filename:    bvt.h
// Author:      Sigalit Bar (sigalitb)
// Date:        30-Dec-98
//
//

#ifndef _BVT_H_
#define _BVT_H_

#include <windows.h>
#include <TCHAR.H>

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST



//
// input/output files declarations
//
#define PARAMS_INI_FILE     TEXT("Params.ini")
#define PARAMS_SECTION      TEXT("General")
#define RECIPIENTS_SECTION  TEXT("Recipients")
#define TEST_SECTION        TEXT("Test")

#ifdef __cplusplus
extern "C" {
#endif

//
// Bvt files
//
extern LPTSTR  g_szBvtDir;
extern LPTSTR  g_szBvtDocFile;
extern LPTSTR  g_szBvtHtmFile;
extern LPTSTR  g_szBvtBmpFile;
extern LPTSTR  g_szBvtTxtFile;


// due to Ronen's FaxSendDocumentEx changes, full path needed (regression)
#define BVT_BACKSLASH   TEXT("\\")
#define BVT_DOC_FILE    TEXT("file.doc")
#define BVT_BMP_FILE    TEXT("file.bmp")
#define BVT_HTM_FILE    TEXT("file.htm")
#define BVT_TXT_FILE    TEXT("file.txt")

#define BVT_MIN_PORTS   2

#define DEV_TSID    TEXT("Comet dev")
#define DEV_CSID    TEXT("Comet dev")

#define MY_FPF_NONE         0

#define MAX_LOOP_COUNT      (60*60*1000)

// SendWizard registry hack
#define REGKEY_WZRDHACK         TEXT("Software\\Microsoft\\Fax\\UserInfo\\WzrdHack")
#define REGVAL_FAKECOVERPAGE    TEXT("FakeCoverPage")
#define REGVAL_FAKETESTSCOUNT   TEXT("FakeTestsCount")
#define REGVAL_FAKERECIPIENT    TEXT("FakeRecipient0")

typedef enum 
{
    LANGUAGE_ENG = 1,
    LANGUAGE_JPN,
    LANGUAGE_GER
}BVT_LANGUAGE;

extern FAX_PERSONAL_PROFILE g_RecipientProfile1;
extern FAX_PERSONAL_PROFILE g_RecipientProfile2;
extern FAX_PERSONAL_PROFILE g_RecipientProfile3;


// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
extern BOOL    g_fFaxServer;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
extern BOOL    g_fNT4OrLater;


//
// TestSuiteSetup:
//  Initializes logger and changes the Fax server configuration
//  for the tests.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber1    IN parameter
//                  Phone number of first device installed on server.
//                  Will be set up as sending device.
//
//  szFaxNumber2    IN parameter
//                  Phone number of second device installed on server.
//                  Will be set up as receiving device.
//
//  szDocument      IN parameter
//                  Filename of document to be used in tests.
//                  The function only prints this string to logger (for debugging).
//
//  szCoverPage     IN parameter
//                  Filename of cover page to be used in tests.
//                  The function only prints this string to logger (for debugging).
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
//  szSentDir       IN parameter.
//                  Name of "sent faxes" directory to be used in tests.
//
//  szInboxArchiveDir   IN parameter.
//                      Name of directory to store (archive) incoming faxes in.
//
//  szBvtDir        IN parameter.
//                  Name of directory containing bvt files.
//
//  szCompareTiffFiles      IN parameter.
//                          Specifies whether or not to compare the tiffs at the end of the test.
//
//  szUseSecondDeviceToSend     IN parameter.
//                              Specifies whether the second device should be used to send faxes.
//                              Otherwize, the first device is used.
//                              The order of devices is according to an enumeration, the Fax service returns.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestSuiteSetup(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber1,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage,
    LPCTSTR     /* IN */    szReceiveDir,
    LPCTSTR     /* IN */    szSentDir,
    LPCTSTR     /* IN */    szInboxArchiveDir,
    LPCTSTR     /* IN */    szBvtDir,
    LPCTSTR     /* IN */    szCompareTiffFiles,
    LPCTSTR     /* IN */    szUseSecondDeviceToSend
);

//
// TestCase1:
//  Send a fax + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase1(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase2:
//  Send just a CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase2(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase3:
//  Send a fax with no CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase3(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument
);

//
// TestCase4:
//  Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase4(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase5:
//  Send a broadcast of only CPs (3 times the same recipient).
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase5(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase6:
//  Send a broadcast without CPs (3 times the same recipient).
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase6(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument
);

//
// TestCase7:
//  Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase7(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase8:
//  Send a fax (*.bmp file = BVT_BMP_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase8(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase9:
//  Send a fax (*.htm file = BVT_HTM_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase9(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase10:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
// Parameters:
//  szPrinterName   IN parameter.
//                  Name of fax local printer or printer connection.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase10(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase11:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
// Parameters:
//  szPrinterName   IN parameter.
//                  Name of fax local printer or printer connection.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase11(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber2
);

//
// TestCase12:
//  Compare all sent faxes (*.tif files) in directory szSentDir 
//  with the received (*.tif) files in szReceive
//
// Parameters:
//  szSentDir           IN parameter.
//                      Name of directory at which all (BVT) sent faxes are stored.
//  szReceive           IN parameter.
//                      Name of directory at which all (BVT) received faxes are stored.
//  
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase12(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReceiveDir
    );

//
// TestCase13:
//  Compare all routed faxes (*.tif files) in directory szInboxArchiveDir 
//  with the received (*.tif) files in szReceive
//
// Parameters:
//  szInboxArchiveDir   IN parameter.
//                      Name of directory at which all (BVT) routed faxes are stored.
//  szReceive           IN parameter.
//                      Name of directory at which all (BVT) received faxes are stored.
//  
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase13(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReceiveDir
    );


//
// TestSuiteShutdown:
//  Perform test suite cleanup (close logger).
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
BOOL TestSuiteShutdown(void);


#ifdef __cplusplus
}
#endif 

#endif //_BVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxtest.inc ===
!ifndef FAXROOT
FAXROOT=$(BASEDIR)\printscan\faxsrv\src
!endif


BINPLACE_OVERRIDE_FLAGS=
C_DEFINES=$(C_DEFINES) -DBUILD_PRODUCT=$(BUILD_PRODUCT) -DWIN32_LEAN_AND_MEAN

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG 
!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
MSC_OPTIMIZATION=-Od
!endif
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
!else
C_DEFINES=$(C_DEFINES) -D_MBCS
!endif

FAXLIB=$(FAXROOT)\lib

INCLUDES=                                 \
   $(FAXROOT)\inc;                        \
   $(FAXROOT)\build;                      \
   $(FAXROOT)\Test\Inc;                      \
   $(BASEDIR)\public\sdk\inc\atl30

LINKLIBS=\
    $(LINKLIBS) \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib	\
    $(BASEDIR)\public\sdk\lib\*\user32.lib	\
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib	\
    $(BASEDIR)\public\sdk\lib\*\winspool.lib	\
    $(BASEDIR)\public\sdk\lib\*\comdlg32.lib	\
    $(BASEDIR)\public\sdk\lib\*\advapi32.lib	\
    $(BASEDIR)\public\sdk\lib\*\shell32.lib	\
    $(BASEDIR)\public\sdk\lib\*\Ole32.lib	\
    $(BASEDIR)\public\sdk\lib\*\oleaut32.lib	\
    $(BASEDIR)\public\sdk\lib\*\uuid.lib	\
    $(BASEDIR)\public\sdk\lib\*\odbc32.lib	\
    $(BASEDIR)\public\sdk\lib\*\odbccp32.lib	\



MSC_WARNING_LEVEL=/W3 /WX
LINKER_FLAGS=-IGNORE:4006,4088,4104

COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h -FI$(FAXROOT)\inc\warning.h

!if $(PPC)
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /W3 /WX
!endif

#
# force the build lab's checked
# build machines to have full symbolic
# debug info
#
!if "$(NTDEBUG)" == "cvp"
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -Z
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\bvt.cpp ===
//
//
// Filename:    bvt.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        30-Dec-98
//
//


#pragma warning(disable :4786)

#include "bvt.h"
#include <shellapi.h>
#include <iniutils.h>
#include <crtdbg.h>
#include <faxreg.h>
#include <log.h>
#include <FaxSender.h>
#include <TiffUtils.h>
#include <FilenameVec.h>

// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
BOOL    g_fFaxServer = FALSE;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
BOOL    g_fNT4OrLater = FALSE;

// szCompareTiffFiles:
//  indicates whether to comapre the tiffs at the end of the test
//
BOOL g_fCompareTiffFiles = FALSE;

// szUseSecondDeviceToSend:
//  specifies whether the second device should be used to send faxes
//
BOOL g_fUseSecondDeviceToSend = FALSE;

//
// Bvt files
//
LPTSTR  g_szBvtDir     = NULL; //TEXT("C:\\CometBVT\\FaxBvt");
LPTSTR  g_szBvtDocFile = NULL;
LPTSTR  g_szBvtHtmFile = NULL;
LPTSTR  g_szBvtBmpFile = NULL;
LPTSTR  g_szBvtTxtFile = NULL;


//
// global recipient profiles (used in test cases)
//
FAX_PERSONAL_PROFILE g_RecipientProfile[3] = {0,0,0};
std::map<tstring, tstring>  g_RecipientMap[3];
DWORD g_RecipientsCount = sizeof(g_RecipientProfile) / sizeof(FAX_PERSONAL_PROFILE);

//
// extern, input ini file path
//
extern TCHAR* g_InputIniFile;

#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR TEXT("true")

//
// counts the number of successfully sent faxes
//
static DWORD g_dwFaxesCount = 0;

//
//
//
BOOL GetIsThisNT4OrLater(void)
{
    DWORD dwOsVersion = ::GetVersion();
    _ASSERTE(dwOsVersion);

    //
    // check if OS is NT4 or later
    //

    if (dwOsVersion >= 0x80000000)
    {
        // Win32 with Windows 3.1 or Win9x
        // Fax Server invocation
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        return(FALSE);
    }

    // Windows NT/2000
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwOsVersion)));
    if (dwWindowsMajorVersion < 4)
    {
        // NT 3.??
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        return(FALSE);
    }

    // Windows NT4 or later
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax SERVER (NT4\\NT5) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
    return(TRUE);
}


//
// GetBoolFromStr:
//
static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("\n3rd param is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}

//
// static function, set recipient's default profile
//
static void SetDefaultRecipientProfile(const DWORD dwIndex)
{
    
    _ASSERTE( (dwIndex >= 0) && (dwIndex < g_RecipientsCount));
    
    g_RecipientProfile[dwIndex].lptstrName = TEXT("Default Recipient Number");
    g_RecipientProfile[dwIndex].lptstrFaxNumber = NULL;
    g_RecipientProfile[dwIndex].lptstrCompany = TEXT("Default Recipient Number Company");
    g_RecipientProfile[dwIndex].lptstrStreetAddress = TEXT("Default Recipient Number Company");
    g_RecipientProfile[dwIndex].lptstrCity = TEXT("Default Recipient Number City");
    g_RecipientProfile[dwIndex].lptstrState = TEXT("Default Recipient Number State");
    g_RecipientProfile[dwIndex].lptstrZip = TEXT("Default Recipient Number Zip");
    g_RecipientProfile[dwIndex].lptstrCountry = TEXT("Default Recipient Number Country");
    g_RecipientProfile[dwIndex].lptstrTitle = TEXT("Default Recipient Number Title");
    g_RecipientProfile[dwIndex].lptstrDepartment = TEXT("Default Recipient Number Department");
    g_RecipientProfile[dwIndex].lptstrOfficeLocation = TEXT("Default Recipient Number OfficeLocation");
    g_RecipientProfile[dwIndex].lptstrHomePhone = TEXT("Default Recipient Number HomePhone");
    g_RecipientProfile[dwIndex].lptstrEmail = TEXT("Default Recipient Number EMail");
    g_RecipientProfile[dwIndex].lptstrBillingCode = TEXT("Default Recipient Number BillingCode");
    g_RecipientProfile[dwIndex].lptstrTSID = TEXT("Default Recipient Number TSID");
}


// Forward declerations:

#ifdef _NT5FAXTEST
//
// Use legacy API
//

#define SetupPort SetupPort_OLD
//
// SetupPort_OLD:
//  Private module function used to set port configuration.
//  See end of file.
//
// _OLD because it uses old NT5Fax winfax.dll APIs
//
static BOOL SetupPort_OLD(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO       pPortInfo,
    IN DWORD                dwFlags,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    );

#else // !_NT5FAXTEST
//
// Use private extended API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
);

#define SetupPort SetupPort_NEW
//
// SetupPort_NEW:
//  Private module function used to set port configuration.
//  See end of file.
//
// _NEW because it uses new BosFax fxsapi.dll APIs
//
static BOOL SetupPort_NEW(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO_EX    pPortInfo,
    IN BOOL                 bSend,
    IN BOOL                 bReceive,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    );

#endif // #ifdef _NT5FAXTEST

//
// SendRegularFax:
//  Private module function used to send a fax
//  See end of file.
//
static BOOL SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Server_SendRegularFax:
//  Private module function used to send a fax from a Fax Server
//  See end of file.
//
static BOOL Server_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Client_SendRegularFax:
//  Private module function used to send a fax from a Fax Client
//  See end of file.
//
static BOOL Client_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Client_SendBroadcastFax:
//  Private module function used to send a broadcast (3 * same recipient)
//  See end of file.
//
static BOOL Client_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// PollJobAndVerify:
//  Private module function used to poll job status
//  See end of file.
//
static BOOL PollJobAndVerify(
    HANDLE /* IN */ hFaxSvc,
    MY_MSG_ID /* IN */ MsgId
);

//
// Server_SendBroadcastFax:
//  Private module function used to send a broadcast fax from a Fax Server.
//  See end of file.
//
static BOOL Server_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// SendFaxFromApp:
//  Private module function used to send a fax from application
//
//  See end of file.
//
static BOOL SendFaxFromApp(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);


//
// TurnOffCfgWzrd:
//  Turns off implicit invocation of Configuration Wizard.
//
//  See end of file.
//
static BOOL TurnOffCfgWzrd(void);


//
// EmptyFaxQueue:
//  Removes all jobs from the fax queue.
//
//  See end of file.
//
static BOOL EmptyFaxQueue(HANDLE hFaxServer);


//
// InitRecipientProfiles:
//  Initializes three recipients profiles with hard coded user info
//  according to
//
VOID InitRecipientProfiles()
{
    DWORD dwIndex;

    for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
    {
        g_RecipientProfile[dwIndex].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    }

    try
    {
        //
        // Read the list of recipients records from ini file.
        std::vector<tstring> RecipientsList =  INI_GetSectionList( g_InputIniFile,
                                                               RECIPIENTS_SECTION);

        for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
        {
            if(RecipientsList.size() > dwIndex )
            {
                tstring tstrRecipientEntry = RecipientsList[dwIndex];
                g_RecipientMap[dwIndex] = INI_GetSectionEntries(g_InputIniFile,
                                                                tstrRecipientEntry);

                if(!g_RecipientMap[dwIndex].empty())
                {
                    std::map<tstring, tstring>::iterator iterMap;

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Name"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrName = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("FaxNumber"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrFaxNumber = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Company"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCompany = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("StreetAddress"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrStreetAddress = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("City"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCity = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("State"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrState = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Zip"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrZip = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Country"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCountry = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Title"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrTitle = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Department"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrDepartment = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficeLocation"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrOfficeLocation = const_cast<TCHAR*>((iterMap->second).c_str());
                    }
                    
                    iterMap = g_RecipientMap[dwIndex].find(TEXT("HomePhone"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrHomePhone = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficePhone"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrOfficePhone = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Email"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrEmail = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("BillingCode"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrBillingCode = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("TSID"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrTSID = const_cast<TCHAR*>((iterMap->second).c_str());
                    }
                }
                else
                {
                    SetDefaultRecipientProfile(dwIndex);
                }

            }
            else
            {
                SetDefaultRecipientProfile(dwIndex);
            }

        }
    }
    catch(Win32Err& err)
    {
        ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nException in InitRecipientProfiles:\r\n%s\r\n"),
                TEXT(__FILE__),
                __LINE__,
                err.description()
                );

        // set default recipients profile
        for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
        {
            SetDefaultRecipientProfile(dwIndex);
        }
        
    }

}




static
BOOL
DeleteFilesInDir(
    LPCTSTR     szDir
    )
{
    BOOL                fRetVal = FALSE;
    DWORD               dwFileAttrib = -1;
    BOOL                fHasDirectoryAttrib = FALSE;
    CFilenameVector*    pDirFileVector = NULL;
    DWORD ec = 0;

    _ASSERTE(NULL != szDir);

    dwFileAttrib = ::GetFileAttributes(szDir);
    if ( -1 != dwFileAttrib)
    {
        // got file attributes for szDir
        fHasDirectoryAttrib = FILE_ATTRIBUTE_DIRECTORY & dwFileAttrib;
        if ( !fHasDirectoryAttrib )
        {
            // szDir is not a directory
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nGetFileAttributes returned %d => %s is not a directory\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwFileAttrib,
                szDir
                );
            goto ExitFunc;
        }
        if (FALSE == ::GetTiffFilesOfDir(szDir, &pDirFileVector))
        {
            goto ExitFunc;
        }
        if (FALSE == ::DeleteVectorFiles(pDirFileVector))
        {
            goto ExitFunc;
        }
    }
    else
    {
        // GetFileAttributes failed
        ec = ::GetLastError();
        if ((ERROR_PATH_NOT_FOUND != ec) && (ERROR_FILE_NOT_FOUND != ec))
        {
            // error
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nGetFileAttributes failed with GetLastError()=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                ec
                );
            goto ExitFunc;
        }
        // we do not consider ERROR_PATH_NOT_FOUND and ERROR_FILE_NOT_FOUND an error
    }
    fRetVal = TRUE;

ExitFunc:
    if (pDirFileVector)
    {
        ::FreeVector(pDirFileVector);
        delete(pDirFileVector);
    }
    return(fRetVal);
}

//
// SetBvtGlobalFileVars:
//  Sets BVT global variables (g_szBvtDir, g_szBvtDocFile, g_szBvtHtmFile, g_szBvtBmpFile)
//  according to szBvtDir command line parameter
//
static
BOOL
SetBvtGlobalFileVars(
    LPCTSTR     szBvtDir
    )
{
    BOOL fRetVal = FALSE;
    DWORD dwSize = 0;

    _ASSERTE(szBvtDir);

    //
    // setup Bvt files global parameters
    //
    g_szBvtDir = (LPTSTR)szBvtDir;
    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_DOC_FILE) + 1)*sizeof(TCHAR);
    g_szBvtDocFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtDocFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtDocFile, dwSize);
    _stprintf(g_szBvtDocFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_DOC_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_HTM_FILE) + 1)*sizeof(TCHAR);
    g_szBvtHtmFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtHtmFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtHtmFile, dwSize);
    _stprintf(g_szBvtHtmFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_HTM_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_BMP_FILE) + 1)*sizeof(TCHAR);
    g_szBvtBmpFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtBmpFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtBmpFile, dwSize);
    _stprintf(g_szBvtBmpFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_BMP_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_TXT_FILE) + 1)*sizeof(TCHAR);
    g_szBvtTxtFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtTxtFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtTxtFile, dwSize);
    _stprintf(g_szBvtTxtFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_TXT_FILE);

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Fax BVT files:\r\ng_szBvtDir=%s\r\ng_szBvtDocFile=%s\r\ng_szBvtHtmFile=%s\r\ng_szBvtBmpFile=%s\r\ng_szBvtTxtFile=%s\r\n"),
        g_szBvtDir,
        g_szBvtDocFile,
        g_szBvtHtmFile,
        g_szBvtBmpFile,
        g_szBvtTxtFile
        );

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(g_szBvtDocFile);
        g_szBvtDocFile = NULL;
        free(g_szBvtHtmFile);
        g_szBvtHtmFile = NULL;
        free(g_szBvtBmpFile);
        g_szBvtBmpFile = NULL;
        free(g_szBvtTxtFile);
        g_szBvtTxtFile = NULL;
        // we didn't alloc g_szBvtDir so we don't free
    }
    return(fRetVal);
}

//
// EmptyDirectories:
//  Deletes files in szReceiveDir, szSentDir and szInboxArchiveDir directories
//  if these directories exist.
//  Note - func does not consider it an error if the directories do not exist.
//
static
BOOL
EmptyDirectories(
    LPCTSTR     szReceiveDir,
    LPCTSTR     szSentDir,
    LPCTSTR     szInboxArchiveDir
    )
{
    BOOL                fRetVal = FALSE;

    _ASSERTE(NULL != szReceiveDir);
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szInboxArchiveDir);

    // empty the "received faxes" dir
    if (FALSE == ::DeleteFilesInDir(szReceiveDir))
    {
        goto ExitFunc;
    }

    // empty the "sent faxes" dir
    if (FALSE == ::DeleteFilesInDir(szSentDir))
    {
        goto ExitFunc;
    }

    // empty the "Inbox Archive" dir
    if (FALSE == ::DeleteFilesInDir(szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);

}

//
//
//
static
BOOL
GetIsThisServerBvt(
    LPCTSTR szServerName,
    BOOL*   pfServerBvt
    )
{
    BOOL fRetVal = FALSE;

    _ASSERTE(szServerName);
    _ASSERTE(pfServerBvt);

    TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPTSTR  szComputerNameUP = NULL;
    LPTSTR  szServerNameUP = NULL;
    ZeroMemory(szComputerName, (MAX_COMPUTERNAME_LENGTH+1)*sizeof(TCHAR));

    if (FALSE == ::GetComputerName(szComputerName, &dwComputerNameSize))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nGetComputerName returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // convert to upper case
    szServerNameUP = ::_tcsdup(szServerName);
    if (NULL == szServerNameUP)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n_tcsdup returned NULL with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // NOTE: upper case conversion is in place
    // no value reserved for error
    szServerNameUP = ::_tcsupr(szServerNameUP);
    szComputerNameUP = ::_tcsupr(szComputerName);

    if (0 == ::_tcscmp(szServerNameUP, szComputerNameUP))
    {
        // Fax Server invocation
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("\r\nRunning Fax SERVER Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
            );
        (*pfServerBvt) = TRUE;
    }
    else
    {
        // Fax Client invocation
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("\r\nRunning Fax CLIENT Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
            );
        (*pfServerBvt) = FALSE;
    }

    fRetVal = TRUE;

ExitFunc:
    free(szServerNameUP);
    return(fRetVal);
}


//
// TestSuiteSetup:
//  changes the Fax server configuration for the tests
//  Note: Logger is already running
//
BOOL TestSuiteSetup(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber1,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage,
    LPCTSTR     szReceiveDir,
    LPCTSTR     szSentDir,
    LPCTSTR     szInboxArchiveDir,
    LPCTSTR     szBvtDir,
    LPCTSTR     szCompareTiffFiles,
    LPCTSTR     szUseSecondDeviceToSend
    )
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber1);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);
    _ASSERTE(NULL != szReceiveDir);
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szInboxArchiveDir);
    _ASSERTE(NULL != szBvtDir);
    _ASSERTE(NULL != szCompareTiffFiles);
    _ASSERTE(NULL != szUseSecondDeviceToSend);

    BOOL                fRetVal                 = FALSE;
    HANDLE              hFaxSvc                 = NULL;
    int                 nPortIndex              = 0;
    DWORD               dwNumFaxPorts           = 0;


#ifdef _NT5FAXTEST
    // Testing NT5 Fax (with old winfax.dll)

    PFAX_CONFIGURATION  pFaxSvcConfig = NULL;
    PFAX_PORT_INFO      pFaxPortsConfig = NULL;

#else
    // Testing Bos Fax (with new fxsapi.dll)

    PFAX_OUTBOX_CONFIG      pOutboxConfig = NULL;
    PFAX_ARCHIVE_CONFIG     pArchiveConfig = NULL;
    PFAX_PORT_INFO_EX       pFaxPortsConfig = NULL;
#endif
    
    //
    // initialize global recipient profiles
    //
    InitRecipientProfiles();

    //
    // set g_fCompareTiffFiles according to szCompareTiffFiles
    //
    if (FALSE == GetBoolFromStr(szCompareTiffFiles, &g_fCompareTiffFiles))
    {
        goto ExitFunc;
    }

    // log command line params using elle logger
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Fax BVT params:\r\n\tszServerName=%s\r\n\tszFaxNumber1=%s\r\n\tszFaxNumber2=%s\r\n\tszDocument=%s\r\n\tszCoverPage=%s\r\n\tszReceiveDir=%s\r\n\tszSentDir=%s\r\n\tszInboxArchiveDir=%s\r\n\tszBvtDir=%s\r\n\tszCompareTiffFiles=%s\r\n\tszUseSecondDeviceToSend=%s\r\n"),
        szServerName,
        szFaxNumber1,
        szFaxNumber2,
        szDocument,
        szCoverPage,
        szReceiveDir,
        szSentDir,
        szInboxArchiveDir,
        szBvtDir,
        szCompareTiffFiles,
        szUseSecondDeviceToSend
        );

    //
    // set g_fUseSecondDeviceToSend according to szUseSecondDeviceToSend
    //
    if (FALSE == GetBoolFromStr(szUseSecondDeviceToSend, &g_fUseSecondDeviceToSend))
    {
        goto ExitFunc;
    }

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Faxes will be sent from %s to %s\r\n"),
        g_fUseSecondDeviceToSend ? szFaxNumber2 : szFaxNumber1,
        g_fUseSecondDeviceToSend ? szFaxNumber1 : szFaxNumber2
        );

    //
    // Empty fax file directories
    //
    if (FALSE == EmptyDirectories(szReceiveDir, szSentDir, szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    //
    // Set bvt global file variables
    //
    if (FALSE == SetBvtGlobalFileVars(szBvtDir))
    {
        goto ExitFunc;
    }

    //
    // Setup fax service
    //
    if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szServerName,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Empty fax queue
    //
    if (FALSE == EmptyFaxQueue(hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nEmptyFaxQueue failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#ifdef _NT5FAXTEST
    // NT5Fax Test using old winfax.dll APIs

    // Retrieve the fax service configuration
    if (!FaxGetConfiguration(hFaxSvc, &pFaxSvcConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    //check that FaxGetConfiguration allocated
    _ASSERTE(pFaxSvcConfig);

    pFaxSvcConfig->Retries = 0;
    pFaxSvcConfig->PauseServerQueue = FALSE;
    pFaxSvcConfig->ArchiveOutgoingFaxes = TRUE;
    pFaxSvcConfig->ArchiveDirectory = szSentDir;

    //
    //We now use bBranding because we don't compare to a refrence directory,
    // so we can use time stamps
    //
    pFaxSvcConfig->Branding = TRUE;

    // Set the fax service configuration
    if (!FaxSetConfiguration(hFaxSvc, pFaxSvcConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup the two ports
    //

    // Retrieve the fax ports configuration
    if (!FaxEnumPorts(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);

    // make sure we have at least TEST_MIN_PORTS ports for test
    if (BVT_MIN_PORTS > dwNumFaxPorts)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
        goto ExitFunc;
    }
    else
    {
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE:%s LINE:%d\ndwNumFaxPorts=%d\nTEST_MIN_PORTS=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
    }
    // we know there are at least 2 (==TEST_MIN_PORTS) devices


    // Set 1st device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[0],
                    g_fUseSecondDeviceToSend ? FPF_RECEIVE : FPF_SEND,
                    szFaxNumber1,
                    szFaxNumber1,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // Set 2nd device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[1],
                    g_fUseSecondDeviceToSend ? FPF_SEND : FPF_RECEIVE,
                    szFaxNumber2,
                    szFaxNumber2,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // set all other devices as Receive=No and Send=No
    // NOTE: nPortIndex is 0 based
    for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
    {
        if (FALSE == SetupPort(
                        hFaxSvc,
                        &pFaxPortsConfig[nPortIndex],
                        MY_FPF_NONE,
                        DEV_TSID,
                        DEV_CSID,
                        szReceiveDir
                        )
            )
        {
            goto ExitFunc;
        }
    }

#else
    // BosFax Test using new fxsapi.dll and "extended" APIs

    //
    // Setup Service Outbox configuration
    //

    if (!FaxGetOutboxConfiguration(hFaxSvc, &pOutboxConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pOutboxConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned:\r\ndwSizeOfStruct=%d\r\nbAllowPersonalCP=%d\r\nbUseDeviceTSID=%d\r\ndwRetries=%d\r\ndwRetryDelay=%d\r\r\ndtDiscountStart.Hour=%i\r\ndtDiscountStart.Minute=%i\r\ndtDiscountEnd.Hour=%i\r\ndtDiscountEnd.Minute=%i\r\ndwAgeLimit=%d\r\nbBranding=%d"),
        TEXT(__FILE__),
        __LINE__,
        pOutboxConfig->dwSizeOfStruct,
        pOutboxConfig->bAllowPersonalCP,
        pOutboxConfig->bUseDeviceTSID,
        pOutboxConfig->dwRetries,
        pOutboxConfig->dwRetryDelay,
        pOutboxConfig->dtDiscountStart.Hour,
        pOutboxConfig->dtDiscountStart.Minute,
        pOutboxConfig->dtDiscountEnd.Hour,
        pOutboxConfig->dtDiscountEnd.Minute,
        pOutboxConfig->dwAgeLimit,
        pOutboxConfig->bBranding
        );

    pOutboxConfig->bAllowPersonalCP = TRUE;
    pOutboxConfig->dwRetries = 0;

    //
    //We now use bBranding because we don't compare to a refrence directory,
    // so we can use time stamps
    //
    pOutboxConfig->bBranding = TRUE;


    if (!FaxSetOutboxConfiguration(hFaxSvc, pOutboxConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup Service Queue configuration
    //
    if (!FaxSetQueue(hFaxSvc, 0))  // inbox and outbox not blocked, outbox not paused
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetQueue returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup Service Inbox Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, &pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
        TEXT(__FILE__),
        __LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
        );

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szInboxArchiveDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


    // Workaround for EdgeBug#8969
    //pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);
    pArchiveConfig = NULL;

    //
    // Setup Service SentItems Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, &pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
        TEXT(__FILE__),
        __LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
        );

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szSentDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


    // Workaround for EdgeBug#8969
    //pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);

    pArchiveConfig = NULL;

    //
    // Setup the two ports
    //

    // Retrieve the fax ports configuration
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPortsEx returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);

    // make sure we have at least TEST_MIN_PORTS ports for test
    if (BVT_MIN_PORTS > dwNumFaxPorts)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
        goto ExitFunc;
    }
    else
    {
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE:%s LINE:%d\r\ndwNumFaxPorts=%d\r\nTEST_MIN_PORTS=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
    }
    // we know there are at least 2 (==TEST_MIN_PORTS) devices

    ::lgLogDetail(
        LOG_X,
        7,
        TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration BEFORE setting\r\n"),
        TEXT(__FILE__),
        __LINE__
        );
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);

    // Set 1st device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[0],
                    !g_fUseSecondDeviceToSend,   //bSend
                    g_fUseSecondDeviceToSend,    //bReceive
                    szFaxNumber1,
                    szFaxNumber1,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // Set 2nd device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[1],
                    g_fUseSecondDeviceToSend,    //bSend
                    !g_fUseSecondDeviceToSend,   //bReceive
                    szFaxNumber2,
                    szFaxNumber2,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // set all other devices as Receive=No and Send=No
    // NOTE: nPortIndex is 0 based
    for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
    {
        if (FALSE == SetupPort(
                        hFaxSvc,
                        &pFaxPortsConfig[nPortIndex],
                        FALSE,  //bSend
                        FALSE,  //bReceive
                        DEV_TSID,
                        DEV_CSID,
                        szReceiveDir
                        )
            )
        {
            goto ExitFunc;
        }
    }

    FaxFreeBuffer(pFaxPortsConfig);
    pFaxPortsConfig = NULL;

    // Retrieve the fax ports configuration (to print new settings)
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);
    ::lgLogDetail(
        LOG_X,
        7,
        TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration AFTER setting\r\n"),
        TEXT(__FILE__),
        __LINE__
        );
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);

#endif

    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    if (FALSE == GetIsThisServerBvt(szServerName, &g_fFaxServer))
    {
        // GetIsThisServerBvt failed
        goto ExitFunc;
    }

    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    g_fNT4OrLater = GetIsThisNT4OrLater();
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("FILE:%s LINE:%d\r\ng_fNT4OrLater=%d\r\n"),
        TEXT(__FILE__),
        __LINE__,
        g_fNT4OrLater
        );

    //
    // Turn off Configuration Wizard
    //
    if (FALSE == TurnOffCfgWzrd())
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d TurnOffCfgWzrd returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:

#ifndef _NT5FAXTEST
    // Testing Bos Fax (with new fxsapi.dll)
    ::FaxFreeBuffer(pOutboxConfig);
    ::FaxFreeBuffer(pArchiveConfig);
#endif

    ::FaxFreeBuffer(pFaxPortsConfig);
    if (FALSE == ::FaxClose(hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}


//
// TestCase1:
//  Send a fax + CP.
//
BOOL TestCase1(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        1,
        TEXT("TC#1: Send a fax + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase2:
//  Send just a CP.
//
BOOL TestCase2( 
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;
    LPCTSTR szDocumentNULL = NULL;

    ::lgBeginCase(
        2,
        TEXT("TC#2: Send just a CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocumentNULL, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase3:
//  Send a fax with no CP.
//
BOOL TestCase3(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);

    BOOL fRetVal = FALSE;
    LPCTSTR szCoverPageNULL = NULL;

    ::lgBeginCase(
        3,
        TEXT("TC#3: Send a fax with no CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPageNULL);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase4:
//  Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL TestCase4(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        4,
        TEXT("TC#4: Send a broadcast (doc + CP)")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s\r\n"),
        szServerName,
        szFaxNumber2,
        szDocument,
        szCoverPage
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                szDocument,
                                szCoverPage
                                );

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase5:
//  Send a broadcast of only CPs (3 times the same recipient).
//
BOOL TestCase5(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        5,
        TEXT("TC#5: Send a broadcast of only CPs")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=NULL\r\n\tCoverPage=%s\r\n"),
        szServerName,
        szFaxNumber2,
        szCoverPage
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                NULL,
                                szCoverPage
                                );

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase6:
//  Send a broadcast without CPs (3 times the same recipient).
//
BOOL TestCase6(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        6,
        TEXT("TC#6: Send a broadcast without CPs")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=NULL\r\n"),
        szServerName,
        szFaxNumber2,
        szDocument
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                szDocument,
                                NULL
                                );

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase7:
//  Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
BOOL TestCase7(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        7,
        TEXT("TC#7: Send a fax (*.doc file) + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtDocFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase8:
//  Send a fax (*.bmp file = BVT_BMP_FILE) + CP.
//
BOOL TestCase8(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        8,
        TEXT("TC#8: Send a fax (*.bmp file) + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtBmpFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase9:
//  Send a fax (*.htm file = BVT_HTM_FILE) + CP.
//
BOOL TestCase9(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        9,
        TEXT("TC#9: Send a fax (*.htm file) + CP")
        );

    //
    //Currently IExplorer has a bug in PrintTo Verb, so we skip this test
    //
    //fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtHtmFile, szCoverPage);
    fRetVal = TRUE;
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("Currently IExplorer has a bug in PrintTo Verb, so we skip this test")
        );


    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase10:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
BOOL TestCase10(
    LPCTSTR     szServerName,
    LPCTSTR     szPrinterName,
    LPCTSTR     szWzrdRegHackKey,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        10,
        TEXT("TC#10: Send a fax from Notepad (*.txt file) + CP")
        );

    fRetVal = SendFaxFromApp(szServerName, szPrinterName, szWzrdRegHackKey, szFaxNumber2, g_szBvtTxtFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase11:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) without CP.
//
BOOL TestCase11(
    LPCTSTR     szServerName,
    LPCTSTR     szPrinterName,
    LPCTSTR     szWzrdRegHackKey,
    LPCTSTR     szFaxNumber2
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        11,
        TEXT("TC#11: Send a fax from Notepad (*.txt file) without CP")
        );

    fRetVal = SendFaxFromApp(szServerName, szPrinterName, szWzrdRegHackKey, szFaxNumber2, g_szBvtTxtFile, NULL);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase12:
//  Compare all sent faxes (*.tif files) in directory szSentDir
//  with the received (*.tif) files in szReceiveDir
//
BOOL TestCase12(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReceiveDir
    )
{
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szReceiveDir);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        12,
        TEXT("TC#12: Compare SENT Files To RECEIVED Files")
        );

    // sleep a little - to allow for routing of last sent file.
    ::lgLogDetail(
        LOG_X,
        4,
        TEXT("Sleeping for 20 sec (to allow for routing of last received file)\r\n")
        );
    Sleep(20000);

    if (FALSE == DirToDirTiffCompare(szSentDir, szReceiveDir, TRUE, g_dwFaxesCount))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szSentDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    ::lgEndCase();
    return(fRetVal);
}



//
// TestCase13:
//  Compare all Inbox routed faxes (*.tif files) in directory szInboxArchiveDir
//  with the received (*.tif) files in szReceiveDir
//
BOOL TestCase13(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReceiveDir
    )
{
    _ASSERTE(NULL != szInboxArchiveDir);
    _ASSERTE(NULL != szReceiveDir);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        13,
        TEXT("TC#13: Compare ROUTED Files To RECEIVED Files")
        );

    if (FALSE == DirToDirTiffCompare(szInboxArchiveDir, szReceiveDir, FALSE, g_dwFaxesCount))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szInboxArchiveDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    ::lgEndCase();
    return(fRetVal);
}


//
// TestSuiteShutdown:
//  Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
    BOOL fRetVal = TRUE;

    //
    // End test suite (logger)
    //
    if (!::lgEndSuite())
    {
        //
        //this is not possible since API always returns TRUE
        //but to be on the safe side (we use printf() here since the logger is not active).
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgEndSuite returned FALSE\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        fRetVal = FALSE;
    }

    //
    // Close the Logger
    //
    if (!::lgCloseLogger())
    {
        //this is not possible since API always returns TRUE
        //but to be on the safe side (we use printf() here since the logger is not active).
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgCloseLogger returned FALSE\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        fRetVal = FALSE;
    }

    return(fRetVal);
}


#ifdef _NT5FAXTEST
//
// SetupPort_OLD:
//  Private module function, used to set port configuration.
//
// Parameters:
//  hFaxSvc         IN parameter.
//                  A handle to the Fax service.
//
//  pPortInfo       IN parameter.
//                  A pointer to the original port configuration, as returned
//                  from a call to FaxGetPort or FaxEnumPorts.
//
//  dwFlags         IN parameter.
//                  Bit flags that specify the new capabilities of the fax port.
//                  See FAX_PORT_INFO for more information.
//
//  szTsid          IN parameter.
//                  A string that specifies the new transmitting station identifier.
//
//  szCsid          IN parameter.
//                  A string that specifies the new called station identifier.
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort_OLD(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO       pPortInfo,
    IN DWORD                dwFlags,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    )
{
    BOOL    fRetVal = FALSE;
    HANDLE  hPort = NULL;
    DWORD   dwRoutingInfoSize = 0;
    BYTE*   pRoutingInfo = NULL;
    LPDWORD pdwRoutingInfoMask =NULL;
    LPWSTR  szRoutingDir = NULL;

    // check in params
    _ASSERTE(NULL != hFaxSvc);
    _ASSERTE(NULL != pPortInfo);
    _ASSERTE(NULL != szTsid);
    _ASSERTE(NULL != szCsid);
    _ASSERTE(NULL != szReceiveDir);

    // Set pPortInfo as required
    pPortInfo->Flags = dwFlags;
    pPortInfo->Tsid  = szTsid;
    pPortInfo->Csid  = szCsid;

    // get the device Id
    DWORD dwDeviceId = pPortInfo->DeviceId;

    // open the port for configuration
    if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // set the device configuration
    if(!FaxSetPort(hPort, pPortInfo))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetPort returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // set device inbound "StoreInFolder" routing
    //
    // this info is read as UNICODE on the server
    // so we take the TCHAR string szReceiveDir and "convert" it to unicode
    //
    dwRoutingInfoSize = sizeof(DWORD) + (sizeof(WCHAR)*(::_tcslen(szReceiveDir)+1)); // MS StoreInFolder routing method expects DWORD followed by UNICODE string
    pRoutingInfo = (BYTE*) malloc(dwRoutingInfoSize);
    if (NULL == pRoutingInfo)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pRoutingInfo, dwRoutingInfoSize);
    pdwRoutingInfoMask = (LPDWORD)pRoutingInfo;
    (*pdwRoutingInfoMask) = LR_STORE;  // to indicate StoreInFolder Routing Method is active
    szRoutingDir = (LPWSTR)(pRoutingInfo + sizeof(DWORD)); //szRoutingDir is UNICODE

#ifndef _UNICODE
    // ANSI //

    // need to "convert" szReceiveDir into UNICODE (szRoutingDir);
    if (!::MultiByteToWideChar(
                        CP_ACP,
                        0,
                        szReceiveDir,
                        -1,
                        szRoutingDir,
                        (dwRoutingInfoSize - sizeof(DWORD))
                        )
       )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#else
    // UNICODE //

    ::_tcscpy(szRoutingDir, szReceiveDir);
    if (0 != ::_tcscmp(szRoutingDir, szReceiveDir))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d tcscmp returned FALSE szRoutingDir=%s szReceiveDir=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szRoutingDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

#endif

    if(!FaxSetRoutingInfo(
        hPort,
        REGVAL_RM_FOLDER_GUID,
        pRoutingInfo,
        dwRoutingInfoSize
        )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxRouteSetRoutingInfo returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    free(pRoutingInfo);
    if (FALSE == ::FaxClose(hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}

#else // !_NT5FAXTEST

//
// SetupPort_NEW:
//  Private module function, used to set port configuration.
//
// Parameters:
//  hFaxSvc         IN parameter.
//                  A handle to the Fax service.
//
//  pPortInfo       IN parameter.
//                  A pointer to the original port configuration, as returned
//                  from a call to FaxGetPort or FaxEnumPorts.
//
//  dwFlags         IN parameter.
//                  Bit flags that specify the new capabilities of the fax port.
//                  See FAX_PORT_INFO for more information.
//
//  szTsid          IN parameter.
//                  A string that specifies the new transmitting station identifier.
//
//  szCsid          IN parameter.
//                  A string that specifies the new called station identifier.
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort_NEW(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO_EX    pPortInfo,
    IN BOOL                 bSend,
    IN BOOL                 bReceive,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    )
{
    BOOL    fRetVal = FALSE;
    HANDLE  hPort = NULL;
    DWORD   dwRoutingInfoSize = 0;
    BYTE*   pRoutingInfo = NULL;
    LPDWORD pdwRoutingInfoMask =NULL;
    LPWSTR  szRoutingDir = NULL;

    // check in params
    _ASSERTE(NULL != hFaxSvc);
    _ASSERTE(NULL != pPortInfo);
    _ASSERTE(NULL != szTsid);
    _ASSERTE(NULL != szCsid);
    _ASSERTE(NULL != szReceiveDir);

    // Set pPortInfo as required
    pPortInfo->bSend        = bSend;
    pPortInfo->ReceiveMode     = bReceive ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF;
    pPortInfo->lptstrTsid   = (LPTSTR)szTsid;
    pPortInfo->lptstrCsid   = (LPTSTR)szCsid;

    // get the device Id
    DWORD dwDeviceId = pPortInfo->dwDeviceID;

    // set the device configuration
    if(!FaxSetPortEx(hFaxSvc, dwDeviceId, pPortInfo))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetPortEx for dwDeviceId=%d returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwDeviceId,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // open the port for configuration (we need this for setting routing info)
    if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // set device inbound "StoreInFolder" routing
    //
    // this info is read as UNICODE on the server
    // so we take the TCHAR string szReceiveDir and "convert" it to unicode
    //
    dwRoutingInfoSize = sizeof(DWORD) + (sizeof(WCHAR)*(::_tcslen(szReceiveDir)+1)); // MS StoreInFolder routing method expects DWORD followed by UNICODE string
    pRoutingInfo = (BYTE*) malloc(dwRoutingInfoSize);
    if (NULL == pRoutingInfo)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pRoutingInfo, dwRoutingInfoSize);
    pdwRoutingInfoMask = (LPDWORD)pRoutingInfo;
    (*pdwRoutingInfoMask) = LR_STORE;  // to indicate StoreInFolder Routing Method is active
    szRoutingDir = (LPWSTR)(pRoutingInfo + sizeof(DWORD)); //szRoutingDir is UNICODE

#ifndef _UNICODE
    // ANSI //

    // need to "convert" szReceiveDir into UNICODE (szRoutingDir);
    if (!::MultiByteToWideChar(
                        CP_ACP,
                        0,
                        szReceiveDir,
                        -1,
                        szRoutingDir,
                        (dwRoutingInfoSize - sizeof(DWORD))
                        )
       )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#else
    // UNICODE //

    ::_tcscpy(szRoutingDir, szReceiveDir);
    if (0 != ::_tcscmp(szRoutingDir, szReceiveDir))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d tcscmp returned FALSE szRoutingDir=%s szReceiveDir=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szRoutingDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

#endif

    if(!FaxSetRoutingInfo(
            hPort,
            REGVAL_RM_FOLDER_GUID,
            pRoutingInfo,
            dwRoutingInfoSize
            )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxRouteSetRoutingInfo returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    if(!FaxEnableRoutingMethod(
            hPort,
            REGVAL_RM_FOLDER_GUID,
            TRUE
            )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnableRoutingMethod returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    free(pRoutingInfo);
    if (FALSE == ::FaxClose(hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}
#endif // #ifdef _NT5FAXTEST
//
// SendRegularFax:
//  Sends a fax (uses Server or Client according to computer name).
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    BOOL fRetVal = FALSE;

    if (TRUE == g_fNT4OrLater)
    {
        // use Fax Server Func
        fRetVal = Server_SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);
    }
    else
    {
        // use Fax Client Func
        fRetVal = Client_SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);
    }

    return(fRetVal);
}


//////////////////////////// Fax Server Functions ////////////////////////////


//
// Server_SendRegularFax:
//  Sends a fax from a Fax Server.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Server_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;
    FAX_SENDER_STATUS myFaxSenderStatus;

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Send a fax with the following parameters:\r\n\tServer=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s"),
        szServerName,
        szFaxNumber2,
        szDocument,
        szCoverPage
        );

    CFaxSender myFaxSender(szServerName);  //if constructor fail an assertion is raised
    fRetVal = myFaxSender.send( szDocument, szCoverPage, szFaxNumber2);
    myFaxSenderStatus = myFaxSender.GetLastStatus();
    if (FALSE == fRetVal)
    {
        // send failed
        ::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send returned FALSE"));
    }
    else
    {
        // send succeeded
        // update successfully sent faxes counter

        g_dwFaxesCount++;

        ::lgLogDetail(
            LOG_X,
            3,
            TEXT("myFaxSender.send returned TRUE, sucessfully sent faxes counter updated to %ld"),
            g_dwFaxesCount
            );
    }

    CotstrstreamEx os;
    os<<myFaxSenderStatus;
    LPCTSTR myStr = os.cstr();
    ::lgLogDetail(LOG_X,3,myStr);
    delete[]((LPTSTR)myStr);

    return(fRetVal);
}


//////////////////////////// Fax Client Functions ////////////////////////////


//
// Client_SendRegularFax:
//  Sends a fax from a Fax Client.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Client_SendRegularFax(
    IN LPCTSTR      szServerName,
    IN LPCTSTR      szFaxNumber,
    IN LPCTSTR      szDocument,
    IN LPCTSTR      szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber);

    BOOL                fRetVal = FALSE;
    HANDLE              hFaxSvc = NULL;
    FAX_JOB_PARAM       FaxJobParams;
    FAX_COVERPAGE_INFO  CPInfo;
    PFAX_COVERPAGE_INFO pCPInfo = NULL;
    DWORD               dwJobId = 0;
    DWORD               dwErr = 0;

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Send a fax with the following parameters:\r\n\tServer=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s"),
        szServerName,
        szFaxNumber,
        szDocument,
        szCoverPage
        );

    if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n FaxConnectFaxServer failed with err=%d"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // queue the send job
    //
    
    // Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;  //send fax immediately

    // Initialize the FAX_COVERPAGE_INFO struct
    ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
    if (NULL != szCoverPage)
    {
        // Set the FAX_COVERPAGE_INFO struct
        CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
        CPInfo.CoverPageName = szCoverPage;
        CPInfo.Note = TEXT("NOTE1\r\nNOTE2\r\nNOTE3\r\nNOTE4");
        CPInfo.Subject = TEXT("SUBJECT");   
        pCPInfo = &CPInfo;
    }

    if (FALSE == ::FaxSendDocument(hFaxSvc, szDocument, &FaxJobParams, pCPInfo, &dwJobId))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxSendDocument returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Poll the queued job status
    //  this is because we can't use the io comp port from the client machine
    //

    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwJobId))
    {
        goto ExitFunc;
    }

    fRetVal = TRUE;

    // update successfully sent faxes counter
    g_dwFaxesCount++;

    ::lgLogDetail(
        LOG_X,
        3,
        TEXT("sucessfully sent faxes counter updated to %ld"),
        g_dwFaxesCount
        );

ExitFunc:
    return(fRetVal);
}


#ifdef _NT5FAXTEST
//
// This version uses legacy API
//
BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORD /* IN */ dwJobId)
{
    // get job repeatedly and verify its states make sense
    // should be QUEUED-DIALING-SENDING*X-COMPLETED

    _ASSERTE(NULL != hFaxSvc);

    BOOL                fRetVal = FALSE;
    PFAX_JOB_ENTRY      pJobEntry = NULL;
    DWORD               dwStatus = 0;
    DWORD               dwLastStatus = 0; //there is no such status code
    DWORD               dwCurrentStatus = 0; //there is no such status code
    UINT                uLoopCount = 0;
    DWORD               dwErr = 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJob(hFaxSvc, dwJobId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (((FPS_COMPLETED == dwLastStatus) || (FPS_AVAILABLE == dwLastStatus)) &&
                (ERROR_INVALID_PARAMETER == dwErr))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxGetJob returned FALSE with GetLastError=%d dwLastStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwErr,
                dwLastStatus
                );
            goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);

        dwStatus = pJobEntry->Status;

        //TO DO: better documentation
        switch (dwStatus)
        {
        case FPS_INITIALIZING:
            if (0 == dwLastStatus)
            {
                //first time that we get FPS_INITIALIZING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_INITIALIZING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_INITIALIZING != dwLastStatus) &&
                (0 != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_INITIALIZING;
            break;

        case FPS_DIALING:
            if ((FPS_INITIALIZING == dwLastStatus) ||
                (0 == dwLastStatus))
            {
                //first time that we get FPS_DIALING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_DIALING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_INITIALIZING != dwLastStatus) &&
                (0!= dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_DIALING;
            break;

        case FPS_SENDING:
            if (FPS_DIALING == dwLastStatus)
            {
                //first time that we get FPS_SENDING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_SENDING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_SENDING != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_SENDING;
            break;

        case FPS_COMPLETED:
            if (FPS_SENDING == dwLastStatus)
            {
                //first time that we get FPS_COMPLETED
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_COMPLETED\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_SENDING != dwLastStatus) &&
                (FPS_COMPLETED != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_COMPLETED;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case FPS_AVAILABLE:
            if (FPS_COMPLETED == dwLastStatus)
            {
                //first time that we get FPS_AVAILABLE
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_AVAILABLE\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_COMPLETED != dwLastStatus) &&
                (FPS_AVAILABLE != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_AVAILABLE;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case 0:
            //WORKAROUND
            // since pJobEntry->Status is initialized to 0 and is set only
            // a bit after the job state is set to JS_INPROGRESS

            //remove JS_NOLINE modifier
            dwCurrentStatus = (pJobEntry->QueueStatus) & ~JS_NOLINE;
            switch (dwCurrentStatus)
            {
            case JS_INPROGRESS:
            case JS_PENDING:
                //ok
                /*
                ::lgLogDetail(
                    LOG_X,
                    9,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state %d (dwStatus=%d)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                 */
                break; // from inner switch

            case JS_COMPLETED:
                if (FPS_AVAILABLE == dwLastStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwJobId,
                dwStatus
                );
            goto ExitFunc;
            break; // from outer switch
        }

        if (pJobEntry)
        {
            FaxFreeBuffer(pJobEntry);
            pJobEntry = NULL;
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nMAX_LOOP_COUNT > uLoopCount\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:

    if (pJobEntry)
    {
        FaxFreeBuffer(pJobEntry);
    }

    return(fRetVal);
}

#else // ! _NT5FAXTEST
//
// This version uses extended private API
//

BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORDLONG /* IN */ dwlMsgId)
{
    // get job repeatedly and verify its states make sense
    // should be PENDING - INPROGRESS (DIALING) - INPROGRESS (TRANSMITTING) * X - COMPLETED

    _ASSERTE(NULL != hFaxSvc);

    BOOL                fRetVal                 = FALSE;
    PFAX_JOB_ENTRY_EX   pJobEntry               = NULL;
    DWORD               dwLastExtendedStatus    = 0; //there is no such status code
    UINT                uLoopCount              = 0;
    DWORD               dwErr                   = 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJobEx(hFaxSvc, dwlMsgId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (FAX_ERR_MESSAGE_NOT_FOUND == dwErr &&
                (JS_EX_TRANSMITTING == dwLastExtendedStatus ||
                 JS_EX_CALL_COMPLETED == dwLastExtendedStatus))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxGetJobEx returned FALSE with GetLastError=%d dwLastStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwErr,
                dwLastExtendedStatus
                );
            goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);


        //TO DO: better documentation
        switch (pJobEntry->pStatus->dwExtendedStatus)
        {
        case JS_EX_INITIALIZING:
            if (0 == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_INITIALIZING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_INITIALIZING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if(JS_EX_INITIALIZING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_INITIALIZING;
            break;

        case JS_EX_DIALING:
            if ((JS_EX_INITIALIZING == dwLastExtendedStatus) ||
                (0 == dwLastExtendedStatus))
            {
                //first time that we get JS_EX_DIALING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_DIALING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_DIALING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_DIALING;
            break;

        case JS_EX_TRANSMITTING:
            if (JS_EX_DIALING == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_TRANSMITTING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_TRANSMITTING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_TRANSMITTING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_TRANSMITTING;
            break;

        case JS_EX_CALL_COMPLETED            :
            if (JS_EX_TRANSMITTING == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_CALL_COMPLETED
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_TRANSMITTING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_CALL_COMPLETED != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_CALL_COMPLETED;
            break;

        case 0:
            // 1) JS_PENDING and JS_COMPLETED don't have extended status
            // 2) we can fail into time interval between pJobStatus->dwQueueStatus and
            //    pJobStatus->dwExtendedStatus updates

            //remove JS_NOLINE modifier
            switch (pJobEntry->pStatus->dwQueueStatus & ~JS_NOLINE)
            {
            case JS_PENDING:
            case JS_INPROGRESS:
                // ok
                break; // from inner switch

            case JS_COMPLETED:
                //
                // TODO: Should check the device is idle
                //

                if (JS_EX_TRANSMITTING == dwLastExtendedStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwlMsgId,
                pJobEntry->pStatus->dwExtendedStatus
                );
            goto ExitFunc;
            break; // from outer switch
        }

        if (pJobEntry)
        {
            FaxFreeBuffer(pJobEntry);
            pJobEntry = NULL;
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nMAX_LOOP_COUNT > uLoopCount\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:

    if (pJobEntry)
    {
        FaxFreeBuffer(pJobEntry);
    }

    return(fRetVal);
}

#endif // #ifdef _NT5FAXTEST


static BOOL Client_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    //for now NO SUPPORT
    _ASSERTE(FALSE);
    //TO DO: setlasterror
    return(FALSE);
}



#ifdef _NT5FAXTEST
//
// This version uses legacy API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO      pPortsConfig,
    const DWORD         dwNumOfPorts
)
{
    _ASSERTE(pPortsConfig);
    _ASSERTE(dwNumOfPorts);

    DWORD   dwLoopIndex = 0;
    for(dwLoopIndex = 0; dwLoopIndex < dwNumOfPorts; dwLoopIndex++)
    {
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d Port Number %d\r\nSizeOfStruct=%d\r\nDeviceID=%d\r\nState=%d\r\nFlags=%d\r\nRings=%d\r\nPriority=%d\r\nDeviceName=%s\r\nTsid=%s\r\nCsid=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwLoopIndex,
            pPortsConfig[dwLoopIndex].SizeOfStruct,
            pPortsConfig[dwLoopIndex].DeviceID,
            pPortsConfig[dwLoopIndex].State,
            pPortsConfig[dwLoopIndex].Flags,
            pPortsConfig[dwLoopIndex].Rings,
            pPortsConfig[dwLoopIndex].Priority,
            pPortsConfig[dwLoopIndex].DeviceName,
            pPortsConfig[dwLoopIndex].Tsid,
            pPortsConfig[dwLoopIndex].Csid
            );
    }
}

#else // !_NT5FAXTEST
//
// This version uses extended private API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
)
{
    _ASSERTE(pPortsConfig);
    _ASSERTE(dwNumOfPorts);

    DWORD   dwLoopIndex = 0;
    for(dwLoopIndex = 0; dwLoopIndex < dwNumOfPorts; dwLoopIndex++)
    {
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d Port Number %d\r\ndwSizeOfStruct=%d\r\ndwDeviceID=%d\r\nlpctstrDeviceName=%s\r\nlptstrDescription=%s\r\nlpctstrProviderName=%s\r\nlpctstrProviderGUID=%s\r\nbSend=%d\r\nbReceive=%d\r\ndwRings=%d\r\nlptstrCsid=%s\r\n\r\nlptstrTsid=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwLoopIndex,
            pPortsConfig[dwLoopIndex].dwSizeOfStruct,
            pPortsConfig[dwLoopIndex].dwDeviceID,
            pPortsConfig[dwLoopIndex].lpctstrDeviceName,
            pPortsConfig[dwLoopIndex].lptstrDescription,
            pPortsConfig[dwLoopIndex].lpctstrProviderName,
            pPortsConfig[dwLoopIndex].lpctstrProviderGUID,
            pPortsConfig[dwLoopIndex].bSend,
            pPortsConfig[dwLoopIndex].ReceiveMode,
            pPortsConfig[dwLoopIndex].dwRings,
            pPortsConfig[dwLoopIndex].lptstrCsid,
            pPortsConfig[dwLoopIndex].lptstrTsid
            );
    }
}
#endif // #ifdef _NT5FAXTEST

//
// Server_SendBroadcastFax:
//  Sends a fax broadcast from a Fax Server.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Server_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;
    FAX_SENDER_STATUS myFaxSenderStatus;
    CotstrstreamEx os;
    LPCTSTR myStr = NULL;

    // create the fax sending object
    CFaxSender myFaxSender(szServerName);  //if constructor fail an assertion is raised

    // create a broadcast object with 3 recipients
    CFaxBroadcast myFaxBroadcastObj;

    // set cover page
    if (FALSE == myFaxBroadcastObj.SetCPFileName(szCoverPage))
    {
        ::lgLogError(LOG_SEV_1,TEXT("myFaxBroadcastObj.SetCPFileName() failed"));
        goto ExitFunc;
    }

    // add 1st recipient to broadcast
    g_RecipientProfile[0].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[0]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("1st myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    // add 2nd recipient to broadcast
    g_RecipientProfile[1].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[1]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("2nd myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    // add 3rd recipient to broadcast
    g_RecipientProfile[2].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[2]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("3rd myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    fRetVal = myFaxSender.send_broadcast( szDocument, &myFaxBroadcastObj);
    myFaxSenderStatus = myFaxSender.GetLastStatus();
    if (FALSE == fRetVal)
    {
        // test case failed
        ::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send_broadcast returned FALSE"));
    }
    else
    {
        // test case succeeded
        // update successfully sent faxes counter

        g_dwFaxesCount += g_RecipientsCount;

        ::lgLogDetail(
            LOG_X,
            3,
            TEXT("myFaxSender.send_broadcast returned TRUE, sucessfully sent faxes counter updated to %ld"),
            g_dwFaxesCount
            );
    }

    os<<myFaxSenderStatus;
    myStr = os.cstr();
    ::lgLogDetail(LOG_X,3,myStr);
    delete[]((LPTSTR)myStr);
    
ExitFunc:
    return(fRetVal);
}


//
// SendFaxFromApp:
//  Sends a fax from application.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szPrinterName       IN parameter.
//                      Name of Fax server to use.
//
//  szRegHackKeyName    IN parameter.
//                      Name of registry hack key.
//
//  szFaxNumber2        IN parameter
//                      Phone number to send fax to.
//
//  szDocument          IN parameter
//                      Filename of document to send.
//
//  szCoverPage         IN parameter
//                      Filename of cover page to send (may be NULL).
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL SendFaxFromApp(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    SHELLEXECUTEINFO ShellExecInfo;

    HKEY               hkWzrdHack                 = NULL;
    DWORD              dwTestsCount               = 1;
    TCHAR              tszRecipientName[]         = TEXT("Recipient");
    LPTSTR             lptstrRecipientMultiString = NULL;
    HANDLE             hFaxServer                 = NULL;
    DWORD              dwJobsReturned             = 0;
    MY_MSG_ID          MsgId                      = 0;
    DWORD              dwMultiStringBytes         = 0;
    DWORD              dwEC                       = ERROR_SUCCESS;
    BOOL               fRetVal                    = FALSE;
    PMY_FAX_JOB_ENTRY  pJobs                      = NULL;
    int                i                          = 0;  //used as an index in a for loop

    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber);
    _ASSERTE(NULL != szDocument);

    if (!szCoverPage)
    {
        // no cover page should be used
        szCoverPage = TEXT("");
    }

    // Allocate memory for multistring: recipient name + '\0', fax number + '\0', '\0'
    dwMultiStringBytes = (_tcslen(tszRecipientName) + _tcslen(szFaxNumber) + 3) * sizeof(TCHAR);
    lptstrRecipientMultiString = (LPTSTR)malloc(dwMultiStringBytes);
    if (NULL == lptstrRecipientMultiString)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc() failed\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        dwEC = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitFunc;
    }

    // Combine recipient name and number into multistring
    _stprintf(lptstrRecipientMultiString, TEXT("%s%c%s%c"), tszRecipientName, (TCHAR)'\0', szFaxNumber, (TCHAR)'\0');

    // Create (or open if already exists) the SendWizard registry hack key
    dwEC = RegCreateKey(HKEY_LOCAL_MACHINE, szWzrdRegHackKey, &hkWzrdHack);
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegCreateKey() failed to open %s key (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szWzrdRegHackKey,
            dwEC
            );
        goto ExitFunc;
    }

    // Set desired cover page
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKECOVERPAGE,
        0,
        REG_SZ,
        (CONST BYTE *)szCoverPage,
        (_tcslen(szCoverPage) + 1) * sizeof(TCHAR)
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKECOVERPAGE,
            dwEC
            );
        goto ExitFunc;
    }

    // Set tests count to 1
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKETESTSCOUNT,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwTestsCount,
        sizeof(dwTestsCount)
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKETESTSCOUNT,
            dwEC
            );
        goto ExitFunc;
    }

    // Set desired recipient
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKERECIPIENT,
        0,
        REG_MULTI_SZ,
        (CONST BYTE *)lptstrRecipientMultiString,
        dwMultiStringBytes
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKERECIPIENT,
            dwEC
            );
        goto ExitFunc;
    }

    if (!FaxConnectFaxServer(szServerName, &hFaxServer))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxConnectFaxServer() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    

    //
    //Before we print this job, let's verify that the queue is empty like we expect it
    //
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    if (0 != dwJobsReturned)
    {
        //
        //We still have jobs in the queue, this is not what we expect,exit with failure
        //
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nThere're still %d jobs in the fax queue\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwJobsReturned
            );
        goto ExitFunc;
    }

    // Initialize ShellExecInfo structure
    ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
    ShellExecInfo.cbSize           = sizeof(ShellExecInfo);
    ShellExecInfo.fMask            = SEE_MASK_FLAG_NO_UI;
    ShellExecInfo.lpVerb           = TEXT("printto");
    ShellExecInfo.lpFile           = szDocument;
    ShellExecInfo.lpParameters     = szPrinterName;
    ShellExecInfo.nShow            = SW_SHOWNORMAL;

    // Print document, using "printto" verb
    if (FALSE == ShellExecuteEx(&ShellExecInfo))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nShellExecuteEx() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }

    for (i=0;i<10;i++)
    {
        if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
        {
            dwEC = GetLastError();
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs() failed (ec = %ld)\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
            goto ExitFunc;
        }
        if (0 != dwJobsReturned)
        {
            //
            //Great, the job is queued, exit this loop and proceed with the test
            //
            break;
        }

        //
        //Got not yet queued, sleep for a second and try again
        //
        Sleep(1000);
    }


    // only currently sent job is expected to be in the queue (sent and received)
    switch(dwJobsReturned)
    {
    case 1:
        MsgId = MyGetMsgId(pJobs[0]);
        break;
    case 2:
        if (MyGetJobType(pJobs[0]) == JT_SEND && MyGetJobType(pJobs[1]) == JT_RECEIVE)
        {
            MsgId = MyGetMsgId(pJobs[0]);
            break;
        }
        else if (MyGetJobType(pJobs[0]) == JT_RECEIVE && MyGetJobType(pJobs[1]) == JT_SEND)
        {
            MsgId = MyGetMsgId(pJobs[1]);
            break;
        }
        else
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nThere're 2 jobs in the queue, but we expect a sending job and a receiving job\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }
    default:
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nNo outgoing job in the queue\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

    if (!::PollJobAndVerify(hFaxServer, MsgId))
    {
        goto ExitFunc;
    }

    // update successfully sent faxes counter
    g_dwFaxesCount++;

    ::lgLogDetail(
        LOG_X,
        3,
        TEXT("sucessfully sent faxes counter updated to %ld"),
        g_dwFaxesCount
        );

    fRetVal = TRUE;

ExitFunc:


    if (lptstrRecipientMultiString)
    {
        free(lptstrRecipientMultiString);
    }
    if (hkWzrdHack)
    {
        RegCloseKey(hkWzrdHack);
    }
    if (hFaxServer)
    {
        FaxClose(hFaxServer);
    }
    if (pJobs)
    {
        FaxFreeBuffer(pJobs);
    }

    if (ERROR_SUCCESS != dwEC)
    {
        SetLastError(dwEC);
    }

    return fRetVal;
}


//
// TurnOffCfgWzrd:
//  Turns off implicit invocation of Configuration Wizard.
//
// NOTE: This function is private to this module, it is not exported.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL TurnOffCfgWzrd()
{
    DWORD           dwVersion       = 0;
    DWORD           dwMajorWinVer   = 0;
    DWORD           dwMinorWinVer   = 0;
    HKEY            hkService       = NULL;
    HKEY            hkUserInfo      = NULL;
    const DWORD     dwValue         = 1;
    DWORD           dwEC            = ERROR_SUCCESS;

    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));

    if (!(dwMajorWinVer == 5 && dwMinorWinVer >= 1))
    {
        // OS is not Windows XP - Configuration Wizard doesn't exist

        goto ExitFunc;
    }

    // set the flag responsible for service part
    dwEC = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAXSERVER,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkService,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegOpenKeyEx failed to open %s key (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAXSERVER,
            dwEC
            );
        goto ExitFunc;
    }
    dwEC = RegSetValueEx(
        hkService,
        REGVAL_CFGWZRD_DEVICE,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegSetValueEx failed to set %s value (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_DEVICE,
            dwEC
            );
        goto ExitFunc;
    }

    // set the flag responsible for user part
    dwEC = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkUserInfo,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n RegOpenKeyEx failed to open %s key (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAX_SETUP,
            dwEC
            );
        goto ExitFunc;
    }
    dwEC = RegSetValueEx(
        hkUserInfo,
        REGVAL_CFGWZRD_USER_INFO,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegSetValueEx failed to set %s value (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_USER_INFO,
            dwEC
            );
        goto ExitFunc;
    }

ExitFunc:

    if (hkService)
    {
        RegCloseKey(hkService);
    }
    if (hkUserInfo)
    {
        RegCloseKey(hkUserInfo);
    }

    if (ERROR_SUCCESS != dwEC)
    {
        SetLastError(dwEC);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}



//
// EmptyFaxQueue:
//  Removes all jobs from the fax queue.
//
static BOOL EmptyFaxQueue(HANDLE hFaxServer)
{
    PMY_FAX_JOB_ENTRY   pJobs           = NULL;
    DWORD               dwJobsReturned  = 0;
    DWORD               dwInd           = 0;
    DWORD               dwEC            = 0;

    if (!hFaxServer)
    {
        _ASSERTE(FALSE);
        dwEC = ERROR_INVALID_PARAMETER;
        goto ExitFunc;
    }

    // Get enumeration of all jobs in the server queue
    //
    // According to current definition of MyFaxEnumJobs macro in !_NT5FAXTEST mode,
    // this call will not return jobs of JT_ROUTING type. It means, these jobs will not be deleted.
    // This will not make a trouble, because these jobs will not be returnes by subsequent calls as well.
    //
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }

    _ASSERTE(pJobs);

    // Delete all the jobs
    for (dwInd = 0; dwInd < dwJobsReturned; dwInd++)
    {
        if (!FaxAbort(hFaxServer, MyGetJobId(pJobs[dwInd])))
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld FaxAbort failed for JobId = 0x%lx (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                MyGetJobId(pJobs[dwInd]),
                GetLastError()
                );
        }
    }

    // FaxAbort is asynchronous.
    // Sleep 30 sec to give all jobs to be actually deleted from the queue.
    Sleep(1000 * 30);

    FaxFreeBuffer(pJobs);
    pJobs = NULL;

    // Make sure the queue is empty
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    if (dwJobsReturned > 0)
    {
        dwEC = ERROR_CAN_NOT_COMPLETE;
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFailed to delete jobs from the queue\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

ExitFunc:

    if (pJobs)
    {
        FaxFreeBuffer(pJobs);
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\main.cpp ===
//
//
// Filename:    main.cpp
// Author:      Sigalit Bar
// Date:        30-dec-98
//
//

#pragma warning(disable :4786)

#include "bvt.h"
#include <winspool.h>
#include <crtdbg.h>
#include <faxreg.h>
#include <log.h>
#include <iniutils.h>
#include <RegHackUtils.h>

#define HELP_SWITCH_1        "/?"
#define HELP_SWITCH_2        "/H"
#define HELP_SWITCH_3        "-?"
#define HELP_SWITCH_4        "-H"

#define MAX_ARGS    12 //including exe name

#define ARGUMENT_IS_SERVER_NAME                 1
#define ARGUMENT_IS_FAX_NUMBER1                 2
#define ARGUMENT_IS_FAX_NUMBER2                 3
#define ARGUMENT_IS_DOC                         4
#define ARGUMENT_IS_CP                          5
#define ARGUMENT_IS_RECEIVE_DIR                 6
#define ARGUMENT_IS_SENT_DIR                    7
#define ARGUMENT_IS_INBOX_ARCHIVE_DIR           8
#define ARGUMENT_IS_BVT_DIR                     9
#define ARGUMENT_IS_TIFF_COMPARE_ENABLED        10
#define ARGUMENT_IS_USE_SECOND_DEVICE_TO_SEND   11

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;

//
// global input parameters file path
//
TCHAR* g_InputIniFile = NULL;


// szCompareTiffFiles:
//  indicates whether to comapre the tiffs at the end of the test
//
extern BOOL g_fCompareTiffFiles;

// szUseSecondDeviceToSend:
//  specifies whether the second device should be used to send faxes
//
extern BOOL g_fUseSecondDeviceToSend;

//
// UsageInfo:
//  Outputs application's proper usage
//
void
UsageInfo(void)
{
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("FaxBVT.exe - BVT for Windows XP builds (CHK and FRE)\n\n")
        TEXT("Usage:\n")
        TEXT("FaxBVT.exe \n\t - Start running the BVT\n")
        TEXT("FaxBVT.exe /? \n\t - Show help info for the BVT")
        );
        
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n\n\t Input ini file should be: \"")
        PARAMS_INI_FILE
        TEXT("\" and should have the following sections:\n")
        TEXT("[General]\n")
        TEXT("\t server_name fax_number1 fax_number2 document cover_page receive_dir sent_dir \n")
        TEXT("\t server_name ---------->the name of the fax server (without the \\\\)\n")
        TEXT("\t fax_number1 ---------->the fax number of the 1st device on server\n")
        TEXT("\t fax_number2 ---------->the fax number of the 2nd device on server\n")
        TEXT("\t document ------------->the full path of the document to send\n")
        TEXT("\t cover_page ----------->the full path to the cover page to send\n")
        TEXT("\t receive_dir ---------->the full path to the receive directory of receiving device\n")
        TEXT("\t sent_dir ------------->the full path to the sent archive directory\n")
        TEXT("\t inbox_dir ------------>the full path to the inbox archive directory\n")
        TEXT("\t bvt_dir -------------->the full path to the bvt directory\n")
        TEXT("\t CompareTiffFiles ----->flag indicating if to compared the tiff files at the end of the test")
        TEXT("\t UseSecondDeviceToSend->flag indicating if the second device (first device otherwise) should be used to send")
        );
    
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n[Recipients]\n")
        TEXT("\t This section should list Name of other sections which to include in a broadcast job")
        );
    
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n[RecipientX]\n")
        TEXT("\t This section should include the following details:\n")
        TEXT("\t Name\n")
        TEXT("\t FaxNumber\n")
        TEXT("\t Company\n")
        TEXT("\t StreetAddress\n")
        TEXT("\t City\n")
        TEXT("\t State\n")
        TEXT("\t Zip\n")
        TEXT("\t Country\n")
        TEXT("\t Title\n")
        TEXT("\t Department\n")
        TEXT("\t OfficeLocation\n")
        TEXT("\t HomePhone\n")
        TEXT("\t OfficePhone\n")
        TEXT("\t Email\n")
        TEXT("\t BillingCode\n")
        TEXT("\t TSID")
        );
}


//
// ParseCmdLineParams:
//  Parses the command line parameters, saves a copy of them,
//  and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//  argc                IN parameter.
//                      command line number of arguments.
//  argvA[]             IN parameter.
//                      command line args (in MBCS).
//  pszServerName       OUT parameter.
//                      Pointer to string to copy 1st argument to.
//                      Represents the name of fax server to use.
//  pszFaxNumber1       OUT parameter.
//                      Pointer to string to copy 2nd argument to.
//                      Represents the fax number of 1st device on the
//                      above fax server.
//  pszFaxNumber2       OUT parameter.
//                      Pointer to string to copy 3rd argument to.
//                      Represents the fax number of 2nd device on the
//                      above fax server.
//  pszDocument         OUT parameter.
//                      Pointer to string to copy 4th argument to.
//                      Represents the name of document to use with tests.
//  pszCoverPage        OUT parameter.
//                      Pointer to string to copy 5th argument to.
//                      Represents the name of the cover page to use
//                      with tests.
//  pszReceiveDir       OUT parameter.
//                      Pointer to string to copy 6th argument to.
//                      Represents the name of directory to route received 
//                      faxes to.
//  pszSentDir          OUT parameter.
//                      Pointer to string to copy 7th argument to.
//                      Represents the name of directory to store (archive)  
//                      sent faxes in.
//  pszInboxArchiveDir  OUT parameter.
//                      Pointer to string to copy 8th argument to.
//                      Represents the name of directory to store (archive)  
//                      incoming faxes in.
//  pszBvtDir           OUT parameter.
//                      Pointer to string to copy 9th argument to.
//                      Represents the name of directory containing bvt  
//                      files.
//  pszCompareTiffFiles     OUT parameter.
//                          Pointer to string to copy 10th argument to.
//                          Represents whether or not to compare the tiffs at the end of the test.
//
//  pszUseSecondDeviceToSend    OUT parameter.
//                              Pointer to string to copy 11th argument to.
//                              Specifies whether the second device should be used to send faxes.
//                              Otherwize, the first device is used.
//                              The order of devices is according to an enumeration, the Fax service returns.
//
// Return Value:
//  TRUE on success and FALSE on failure.
//
//
BOOL 
LoadTestParams(
    LPCTSTR      /* IN */   tstrIniFileName,
    LPTSTR*      /* OUT */  pszServerName,
    LPTSTR*      /* OUT */  pszFaxNumber1,
    LPTSTR*      /* OUT */  pszFaxNumber2,
    LPTSTR*      /* OUT */  pszDocument,
    LPTSTR*      /* OUT */  pszCoverPage,
    LPTSTR*      /* OUT */  pszReceiveDir,
    LPTSTR*      /* OUT */  pszSentDir,
    LPTSTR*      /* OUT */  pszInboxArchiveDir,
    LPTSTR*      /* OUT */  pszBvtDir,
    LPTSTR*      /* OUT */  pszCompareTiffFiles,
    LPTSTR*      /* OUT */  pszUseSecondDeviceToSend
    )
{
    _ASSERTE(pszServerName);
    _ASSERTE(pszDocument);
    _ASSERTE(pszFaxNumber1);
    _ASSERTE(pszFaxNumber2);
    _ASSERTE(pszCoverPage);
    _ASSERTE(pszReceiveDir);
    _ASSERTE(pszSentDir);
    _ASSERTE(pszInboxArchiveDir);
    _ASSERTE(pszBvtDir);
    _ASSERTE(pszCompareTiffFiles);
    _ASSERTE(pszUseSecondDeviceToSend);
    
    // Declarations
    //
    DWORD   dwArgLoopIndex;
    DWORD   dwArgSize;
    LPTSTR  aszParam[MAX_ARGS];

    //
    // Read the list of test parameters from ini file.
    std::vector<tstring> ParamsList;
    try
    {
        ParamsList =  INI_GetSectionList(tstrIniFileName,PARAMS_SECTION);
    }
    catch(Win32Err& err)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\n INI_GetSectionList failed with error = %d\n"),
            TEXT(__FILE__),
            __LINE__,
            err.error()
            );
        return FALSE;
    }

    std::vector<tstring>::iterator iterList;
    //
    // Check number of parameters
    //
    if ( ParamsList.size() != (MAX_ARGS - 1))  
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("\nInvalid invocation of FaxBVT.exe\n\nFaxBVT.exe Help:\n")
            );
        ::UsageInfo();
        return FALSE;
    }

    //
    // Initialize awcsParam[]
    //
    for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
    {
        aszParam[dwArgLoopIndex] = NULL;
    }

    //
    // Loop on arguments in list
    //
    for (iterList = ParamsList.begin(), dwArgLoopIndex = 1; iterList != ParamsList.end(); iterList++, dwArgLoopIndex++) 
    {
        //
        // Determine the memory required for the parameter
        //
        dwArgSize = (_tcsclen((*iterList).c_str()) + 1) * sizeof(TCHAR);

        //
        // Allocate the memory for the parameter
        //
        _ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
            g_hMainHeap, 
            HEAP_ZERO_MEMORY, 
            dwArgSize
            );
        if(NULL == aszParam[dwArgLoopIndex])
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFuncFail;
        }

    
        ::_tcscpy(aszParam[dwArgLoopIndex],(*iterList).c_str());
        if (_tcscmp(aszParam[dwArgLoopIndex],(*iterList).c_str()))
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFuncFail;
        }
    
        //
        // Treat each argument accordingly
        //
        switch (dwArgLoopIndex)
        {
        case ARGUMENT_IS_SERVER_NAME:
            //server_name param
            (*pszServerName) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_FAX_NUMBER1:
            //fax_number1 param
            (*pszFaxNumber1) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_FAX_NUMBER2:
            //fax_number2 param
            (*pszFaxNumber2) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_DOC:
            //document param
            (*pszDocument) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_CP:
            //cover_page param
            (*pszCoverPage) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_RECEIVE_DIR:
            //receive_dir param
            (*pszReceiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_SENT_DIR:
            //sent_dir param
            (*pszSentDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_INBOX_ARCHIVE_DIR:
            //inbox_dir param
            (*pszInboxArchiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_BVT_DIR:
            //bvt_dir param
            (*pszBvtDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_TIFF_COMPARE_ENABLED:
            //comapre the tiff files at the end of the test
            (*pszCompareTiffFiles) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_USE_SECOND_DEVICE_TO_SEND:
            //comapre the tiff files at the end of the test
            (*pszUseSecondDeviceToSend) = aszParam[dwArgLoopIndex];
            break;

        default:
            _ASSERTE(FALSE);
            return FALSE;
        }// switch (dwIndex)

    }//for (iterList = ParamsList.begin(); iterList != ParamsList.end(); iterList++) 


    //If all is well then we do NOT free 
    //pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
    //since these allocations were the purpose of the function.
    return(TRUE);

ExitFuncFail:

    //
    // Free allocations
    //
    DWORD i;
    //0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
    for (i=0; i<MAX_ARGS; i++) 
    {
        if (NULL == aszParam[i]) continue;
        if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
                TEXT(__FILE__),
                __LINE__,
                i,
                ::GetLastError()
                );
            return(FALSE);
        }
    }

    //
    //reset OUT parameters
    //
    (*pszServerName) = NULL;
    (*pszFaxNumber1) = NULL;
    (*pszFaxNumber2) = NULL;
    (*pszDocument) = NULL;
    (*pszCoverPage) = NULL;
    (*pszReceiveDir) = NULL;
    (*pszSentDir) = NULL;
    (*pszInboxArchiveDir) = NULL;
    (*pszBvtDir) = NULL;

    return(FALSE);
}


//

//
// main body of application.
//
int __cdecl
main(int argc, char* argv[])
{
    int nReturnValue = 0; //to indicate success

    LPTSTR szServerName = NULL;
    LPTSTR szFaxNumber1 = NULL;
    LPTSTR szFaxNumber2 = NULL;
    LPTSTR szDocument = NULL;
    LPTSTR szCoverPage = NULL;
    LPTSTR szReceiveDir = NULL;
    LPTSTR szSentDir = NULL;
    LPTSTR szInboxArchiveDir = NULL;
    LPTSTR szBvtDir = NULL;
    LPTSTR tstrCurrentDirectory = NULL;
    LPTSTR szCompareTiffFiles = NULL;
    LPTSTR szUseSecondDeviceToSend = NULL;
    LPTSTR tstrPrinterConnectionName = NULL;
    LPTSTR tstrWzrdRegHackKey = NULL;
    LPTSTR tstrDialTo = NULL;
    tstring tstrParamsFilePath;

    PSID pCurrentUserSid = NULL;

    DWORD dwFuncRetVal = 0;
    DWORD cbDir = 0;
    BOOL bRes = FALSE;


    //
    // Check for help switch
    //
    // If this is the second argument, it may be one of several help switches defined.
    // A help switch can appear only as the second argument.
    if (2 <= argc)
    {
        if (! (!::_strcmpi (HELP_SWITCH_1, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_2, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_3, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_4, argv[1]))
            ) 
        {
            //
            //We use printf here since the logger isn't invoked yet
            //
            ::_tprintf(TEXT("Invalid invokation of BVT.exe\n\n"));
        }
        ::_tprintf(TEXT("FaxBVT.exe - BVT for Windows XP builds (CHK and FRE)\n\n"));
        ::_tprintf(TEXT("Usage:\n"));
        ::_tprintf(TEXT("FaxBVT.exe \n\t - Start running the BVT\n"));
        ::_tprintf(TEXT("FaxBVT.exe /? \n\t - Show help info for the BVT\n"));
        exit(1);
    }


    //
    // Init logger
    //
    if (!::lgInitializeLogger())
    {
        //
        // we use printf() here since the logger is not active
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgInitializeLogger failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    //
    // Begin test suite (logger)
    //
    if(!::lgBeginSuite(TEXT("BVT suite")))
    {
        //
        // we use printf() here since the logger is not active
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgBeginSuite failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    
    
    //
    // Set g_hMainHeap to process heap
    //
    g_hMainHeap = NULL;
    g_hMainHeap = ::GetProcessHeap();
    if(NULL == g_hMainHeap)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    //
    // Get current directory path
    cbDir = GetCurrentDirectory(
        0,                      // size of directory buffer
        tstrCurrentDirectory    // directory buffer
        ); 
    
    if(!cbDir)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    
    tstrCurrentDirectory = (TCHAR*)::HeapAlloc( g_hMainHeap, 
                                                HEAP_ZERO_MEMORY, 
                                                cbDir * sizeof(TCHAR));
    if(NULL == tstrCurrentDirectory)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
            TEXT(__FILE__),
            __LINE__
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    dwFuncRetVal = GetCurrentDirectory(
        cbDir,                  // size of directory buffer
        tstrCurrentDirectory    // directory buffer
        ); 

    if((dwFuncRetVal + 1 != cbDir))
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    // Compose the test params ini file.
    tstrParamsFilePath = tstrCurrentDirectory;
    tstrParamsFilePath += TEXT("\\");
    tstrParamsFilePath += PARAMS_INI_FILE; 
    g_InputIniFile = const_cast<TCHAR*>(tstrParamsFilePath.c_str());
    //
    // Parse the command line
    //
    if(!::LoadTestParams(
            tstrParamsFilePath.c_str(),
            &szServerName,
            &szFaxNumber1,
            &szFaxNumber2,
            &szDocument,
            &szCoverPage,
            &szReceiveDir,
            &szSentDir,
            &szInboxArchiveDir,
            &szBvtDir,
            &szCompareTiffFiles,
            &szUseSecondDeviceToSend
            )
        )
    {
        nReturnValue = 1; // to indicate failure
        goto ExitFunc;
    }

    //
    //Test case0 is setting up the BVT params
    //
    ::lgBeginCase(
        0,
        TEXT("TC#0: Setup BVT params")
        );

    bRes = TestSuiteSetup(
        szServerName,
        szFaxNumber1,
        szFaxNumber2,
        szDocument,
        szCoverPage,
        szReceiveDir,
        szSentDir,
        szInboxArchiveDir,
        szBvtDir,
        szCompareTiffFiles,
        szUseSecondDeviceToSend
        );

    tstrDialTo = g_fUseSecondDeviceToSend ? szFaxNumber1 : szFaxNumber2;
    
    if (!g_fFaxServer)
    {
        // Use printer connection

        // Allocate memory for printer connecton name: "\\", server, "\", printer, '\0'
        tstrPrinterConnectionName = (TCHAR*)::HeapAlloc(
            g_hMainHeap, 
            HEAP_ZERO_MEMORY, 
            (_tcslen(szServerName) + _tcslen(FAX_PRINTER_NAME) + 4)* sizeof(TCHAR)
            );
        if(NULL == tstrPrinterConnectionName)
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
                TEXT(__FILE__),
                __LINE__
                );
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }

        // Combine server and printer into printer connection
        _stprintf(tstrPrinterConnectionName, TEXT("\\\\%s\\%s"), szServerName, FAX_PRINTER_NAME);

        // Add printer connection
        if (!AddPrinterConnection(tstrPrinterConnectionName))
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d Failed to add printer connection to %s (ec = %ld)\r\n"),
                TEXT(__FILE__),
                __LINE__,
                tstrPrinterConnectionName,
                ::GetLastError()
                );
            goto ExitFunc;
        }
    }

    dwFuncRetVal = GetCurrentUserSid((PBYTE*)&pCurrentUserSid);
    if (dwFuncRetVal != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\r\nGetCurrentUserSid() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwFuncRetVal
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    dwFuncRetVal = FormatUserKeyPath(pCurrentUserSid, REGKEY_WZRDHACK, &tstrWzrdRegHackKey);
    if (dwFuncRetVal != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\r\nFormatUserKeyPath() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwFuncRetVal
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    ::lgEndCase();
    if (FALSE == bRes)
    {
        nReturnValue = 1; // to indicate failure
        goto ExitFunc;
    }


    //Send a fax + CP
    ::_tprintf(TEXT("\nRunning TestCase1 (Send a fax + CP)...\n"));
    if (FALSE == TestCase1(         
                        szServerName,
                        tstrDialTo,
                        szDocument,
                        szCoverPage
                        )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase1 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase1 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send just a CP
    ::_tprintf(TEXT("\nRunning TestCase2 (Send just a CP)...\n"));
    if (FALSE == TestCase2(         
                    szServerName,
                    tstrDialTo,
                    szCoverPage
                    )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase2 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase2 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax with no CP
    ::_tprintf(TEXT("\nRunning TestCase3 (Send a fax with no CP)...\n"));
    if (FALSE == TestCase3(         
                    szServerName,
                    tstrDialTo,
                    szDocument
                    )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase3 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase3 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

//
// For now, no broadcast test cases for NT5 Fax
//
#ifndef _NT5FAXTEST
        // Testing BOS Fax (with new fxsapi.dll)

    //Send a broadcast of fax + CP (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase4 (Send a broadcast of fax + CP)...\n"));
         if (FALSE == TestCase4(            
                            szServerName,
                            tstrDialTo,
                            szDocument,
                            szCoverPage
                            )
            )
        {
            ::_tprintf(TEXT("\nTest TestCase4 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase4 PASSED\n"));
        }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    }


    //Send a broadcast of only CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase5 (Send a broadcast of only CP)...\n"));
        if (FALSE == TestCase5(         
                            szServerName,
                            tstrDialTo,
                            szCoverPage
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase5 FAILED\n"));
        nReturnValue = 1; //to indicate failure
            goto ExitFunc;

        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase5 PASSED\n"));
        }
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a broadcast without CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase6 (Send a broadcast without CP)...\n"));
        if (FALSE == TestCase6(         
                            szServerName,
                            tstrDialTo,
                            szDocument
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase6 FAILED\n"));
        nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase6 PASSED\n"));
        }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    }

#endif

    //Send a fax (*.doc file) + CP
    ::_tprintf(TEXT("\nRunning TestCase7 (Send a fax (*.doc file) + CP)...\n"));
    if (FALSE == TestCase7(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase7 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase7 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);
    
    //Send a fax (*.bmp file) + CP
    ::_tprintf(TEXT("\nRunning TestCase8 (Send a fax (*.bmp file) + CP)...\n"));
    if (FALSE == TestCase8(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase8 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase8 PASSED\n"));
    }

    

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax (*.htm file) + CP
    ::_tprintf(TEXT("\nRunning TestCase9 (Send a fax (*.htm file) + CP)...\n"));
    if (FALSE == TestCase9(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase9 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase9 PASSED\n"));
    }



    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP
    ::_tprintf(TEXT("\nRunning TestCase10 (Send a fax from Notepad (*.txt file) + CP)...\n"));
    if (FALSE == TestCase10(            
                        szServerName,
                        tstrPrinterConnectionName ? tstrPrinterConnectionName : FAX_PRINTER_NAME,
                        tstrWzrdRegHackKey,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase10 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase10 PASSED\n"));
    }



    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax from Notepad (*.txt file = BVT_TXT_FILE) without CP
    ::_tprintf(TEXT("\nRunning TestCase11 (Send a fax from Notepad (*.txt file) without CP)...\n"));
    if (FALSE == TestCase11(            
                        szServerName,
                        tstrPrinterConnectionName ? tstrPrinterConnectionName : FAX_PRINTER_NAME,
                        tstrWzrdRegHackKey,
                        tstrDialTo
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase11 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase11 PASSED\n"));
    }
    
    if (TRUE == g_fCompareTiffFiles)
    {
        //
        //We sent the faxes, now compare the archived directories
        //The compare will be:
        //Compare #1: SentArchive with ReceivedArchive
        //Compare #2: RouteArchive with ReceivedArchive
        //If both compares succeed, it means that all 3 directories are the same
        //
        ::lgLogDetail(
            LOG_X,
            0,
            TEXT("All faxes have been sent\n\tCompare the archived directories")
            );
        
        //
        //Compare all "received faxes" in directory szReceiveDir
        //with the files in szReceiveDir
        //
        ::_tprintf(TEXT("\nRunning TestCase12 (Compare szSentDir with szReceiveDir)...\n"));
        if (FALSE == TestCase12(
                szSentDir,
                szReceiveDir
                )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase12 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase12 PASSED\n"));
        }

    
        //
        //Compare all "Inbox Routed" in directory szInboxArchiveDir
        //with the files in szReceiveDir
        //
        ::_tprintf(TEXT("\nRunning TestCase13 (Compare szInboxArchiveDir with szReceiveDir)...\n"));
        if (FALSE == TestCase13(
                            szInboxArchiveDir,
                            szReceiveDir
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase13 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase13 PASSED\n"));
        }
    }

    //
    // Output suite results to console
    //
    if (nReturnValue)
    {
        ::_tprintf(TEXT("\nTest Suite FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\nTest Suite PASSED\n"));
    }

    //
    //If we reach here, all is good
    //
    _ASSERTE(0 == nReturnValue);

ExitFunc:
    TestSuiteShutdown();

    // free command line params
    if (szServerName) 
    {
        HeapFree(g_hMainHeap, 0, szServerName);
    }
    if (szFaxNumber1) 
    {
        HeapFree(g_hMainHeap, 0, szFaxNumber1);
    }
    if (szFaxNumber2) 
    {
        HeapFree(g_hMainHeap, 0, szFaxNumber2);
    }
    if (szDocument) 
    {
        HeapFree(g_hMainHeap, 0, szDocument);
    }
    if (szCoverPage) 
    {
        HeapFree(g_hMainHeap, 0, szCoverPage);
    }
    if (szReceiveDir) 
    {
        HeapFree(g_hMainHeap, 0, szReceiveDir);
    }
    if (szSentDir) 
    {
        HeapFree(g_hMainHeap, 0, szSentDir);
    }
    if (szInboxArchiveDir) 
    {
        HeapFree(g_hMainHeap, 0, szInboxArchiveDir);
    }
    if (szBvtDir) 
    {
        HeapFree(g_hMainHeap, 0, szBvtDir);
    }
    if (szCompareTiffFiles) 
    {
        HeapFree(g_hMainHeap, 0, szCompareTiffFiles);
    }
    if (szUseSecondDeviceToSend) 
    {
        HeapFree(g_hMainHeap, 0, szUseSecondDeviceToSend);
    }
    if (tstrCurrentDirectory) 
    {
        HeapFree(g_hMainHeap, 0, tstrCurrentDirectory);
    }
    if (tstrPrinterConnectionName) 
    {
        HeapFree(g_hMainHeap, 0, tstrPrinterConnectionName);
    }
    if (pCurrentUserSid)
    {
        delete pCurrentUserSid;
    }
    if (tstrWzrdRegHackKey)
    {
        // remove SendWizard registry hack
        dwFuncRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, tstrWzrdRegHackKey);
        if (ERROR_SUCCESS != dwFuncRetVal && ERROR_FILE_NOT_FOUND != dwFuncRetVal)
        {
            ::_tprintf(TEXT("\n\nFailed to remove SendWizard registry hack (ec=%ld)\n"), dwFuncRetVal);
        }

        delete tstrWzrdRegHackKey;
    }

    return(nReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ccoverpageinfo.h ===
#ifndef __C_COVER_PAGE_INFO_H__
#define __C_COVER_PAGE_INFO_H__



#include <fxsapip.h>
#include <tstring.h>



class CCoverPageInfo {

public:

    CCoverPageInfo(
                   const tstring &tstrCoverPage,
                   bool          bServerBasedCoverPage,
                   const tstring &tstrSubject,
                   const tstring &tstrNote
                   );

    bool IsEmpty() const;

    void FillCoverPageInfoEx(PFAX_COVERPAGE_INFO_EX pCoverPageInfo) const;

    PFAX_COVERPAGE_INFO_EX CreateCoverPageInfoEx() const;

    static void FreeCoverPageInfoEx(PFAX_COVERPAGE_INFO_EX pCoverPageInfo);

private:
    
    tstring m_tstrCoverPage;
    bool    m_bServerBasedCoverPage;
    tstring m_tstrSubject;
    tstring m_tstrNote;
};



#endif // #ifndef __C_COVER_PAGE_INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ccheckfiles.h ===
#ifndef __C_CHECK_FILES_H__
#define __C_CHECK_FILES_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CCheckFiles test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case allows to check existence of files (platform dependent) and
    other properites.


    **************************************
    Test case specific INI file parameters
    **************************************

    List of entries in the form <filename> = <properties>, where:

        <filename> is a full path (environment variables allowed) of a file to check

        <properties> is a bit mask (in the decimal format) that defines required
        file "properties"

        Currently supported properties:
            FILE_WANTED_NEVER         = 0x00000000
            FILE_WANTED_ON_WIN9X      = 0x00000001
            FILE_WANTED_ON_NT4        = 0x00000002
            FILE_WANTED_ON_WINME      = 0x00000004
            FILE_WANTED_ON_WIN2K      = 0x00000008
            FILE_WANTED_ON_XP_DESKTOP = 0x00000010
            FILE_WANTED_ON_XP_SERVER  = 0x00000020
            FILE_WANTED_ALWAYS        = 0x000000FF
            FILE_VERSION_IGNORE       = 0x00000000
            FILE_VERSION_BUILD        = 0x00000100
            FILE_VERSION_FULL         = 0x00000F00



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"
#include "CFileVersion.h"



//
// Used to specify required file "properties".
//
// Specified in ini file "by value". DON'T CHANGE THE VALUES ! ! !
//
#define FILE_WANTED_NEVER         0x00000000
#define FILE_WANTED_ON_WIN9X      0x00000001
#define FILE_WANTED_ON_NT4        0x00000002
#define FILE_WANTED_ON_WINME      0x00000004
#define FILE_WANTED_ON_WIN2K      0x00000008
#define FILE_WANTED_ON_XP_DESKTOP 0x00000010
#define FILE_WANTED_ON_XP_SERVER  0x00000020
#define FILE_WANTED_ALWAYS        0x000000FF
#define FILE_VERSION_IGNORE       0x00000000
#define FILE_VERSION_BUILD        0x00000100
#define FILE_VERSION_FULL         0x00000F00



typedef std::vector<std::pair<tstring, DWORD> > WANTED_FILES_VECTOR;
typedef WANTED_FILES_VECTOR::value_type WANTED_FILE;
typedef WANTED_FILES_VECTOR::const_iterator WANTED_FILES_VECTOR_CONST_ITERATOR;



class CCheckFiles : public CTestCase {

public:

    CCheckFiles(
                const tstring &tstrName,
                const tstring &tstrDescription,
                CLogger       &Logger,
                int           iRunsCount,
                int           iDeepness
                );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    bool IsFileWanted(DWORD FileWanted) const;

    bool IsVersionOk(const tstring &tstrFileName, DWORD dwVersionCheck, CFileVersion &ReferenceFileVersion);

    WANTED_FILES_VECTOR m_vecFilesToCheck;
};



DEFINE_TEST_FACTORY(CCheckFiles);



#endif // #ifndef  __C_CHECK_FILES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ccheckfiles.cpp ===
#include "CCheckFiles.h"
#include <shlwapi.h>
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CCheckFiles::CCheckFiles(
                         const tstring &tstrName,
                         const tstring &tstrDescription,
                         CLogger       &Logger,
                         int           iRunsCount,
                         int           iDeepness
                         )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CCheckFiles::CCheckFiles"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CCheckFiles::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CCheckFiles::Run"));

    bool bPassed = true;
    CFileVersion ReferenceFileVersion;

    //
    // Go over the files we need to check.
    //
    for (WANTED_FILES_VECTOR_CONST_ITERATOR citWantedFilesIterator = m_vecFilesToCheck.begin();
         citWantedFilesIterator != m_vecFilesToCheck.end();
         ++citWantedFilesIterator
         )
    {
        //
        // Expand all environment variables in the file name.
        //
        tstring tstrExpandedFileName;

        DWORD dwEC = ExpandEnvString(citWantedFilesIterator->first.c_str(), tstrExpandedFileName);
        if (ERROR_SUCCESS != dwEC)
        {
            GetLogger().Detail(SEV_ERR, 1, _T("ExpandEnvString failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CCheckFiles::Run - ExpandEnvString"));
        }

        GetLogger().Detail(
                           SEV_MSG,
                           1,
                           _T("Checking %s with bitmask 0x%08lx..."),
                           tstrExpandedFileName.c_str(),
                           citWantedFilesIterator->second
                           );
        
        //
        // Search for a file.
        //
        bool bFileFound = (TRUE == ::PathFileExists(tstrExpandedFileName.c_str()));
        GetLogger().Detail(SEV_MSG, 5, _T("File%s found."), bFileFound ? _T("") : _T(" not"));

        //
        // Check whether the file is wanted.
        //
        bool bFileWanted = IsFileWanted(citWantedFilesIterator->second & FILE_WANTED_ALWAYS);
        GetLogger().Detail(SEV_MSG, 5, _T("File%s wanted."), bFileWanted ? _T("") : _T(" not"));

        //
        // Check the version only if the file wanted and found.
        //

        bool bVersionOk = true;

        if (bFileFound && bFileWanted)
        {
            try
            {
               bVersionOk = IsVersionOk(
                                        tstrExpandedFileName,
                                        citWantedFilesIterator->second & FILE_VERSION_FULL,
                                        ReferenceFileVersion
                                        );
            }
            catch(Win32Err &e)
            {
                GetLogger().Detail(SEV_ERR, 1, _T("Failed to check file version (ec=%ld)"), e.error());
                bVersionOk = false;
            }
        }

        //
        // Check whether the file is Ok.
        //
        bool bFileOk = (bFileFound && bFileWanted && bVersionOk) || (!bFileFound && !bFileWanted);

        GetLogger().Detail(bFileOk ? SEV_MSG : SEV_ERR, 1, bFileOk ? _T("Ok") : _T("ERROR"));

        bPassed = bPassed && bFileOk;
    }

    return bPassed;
}

    

//-----------------------------------------------------------------------------------------------------------------------------------------
void CCheckFiles::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CCheckFiles::ParseParams"));

    for (TSTRINGMap::const_iterator citParamsIterator = mapParams.begin();
         citParamsIterator != mapParams.end();
         ++citParamsIterator
         )
    {
        //
        // Add a file name to the list.
        //
        m_vecFilesToCheck.push_back(WANTED_FILE(citParamsIterator->first, FromString<DWORD>(citParamsIterator->second)));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CCheckFiles::IsFileWanted(DWORD dwFileWanted) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CCheckFiles::IsFileWanted"));

    if (dwFileWanted & FILE_WANTED_ON_XP_DESKTOP && IsWindowsXP() && IsDesktop())
    {
        return true;
    }
    if (dwFileWanted & FILE_WANTED_ON_XP_SERVER && IsWindowsXP() && !IsDesktop())
    {
        return true;
    }

    return false;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CCheckFiles::IsVersionOk(const tstring &tstrFileName, DWORD dwVersionCheck, CFileVersion &ReferenceFileVersion)
{
    bool bVersionOk = false;

    if (FILE_VERSION_IGNORE == dwVersionCheck)
    {
        //
        // Should not check version. It's Ok "implicitly".
        //
        GetLogger().Detail(SEV_MSG, 5, _T("No file version check requested."));
        bVersionOk = true;
    }
    else
    {
        //
        // Some kind of version check requested.
        //

        CFileVersion FileVersion(tstrFileName);

        GetLogger().Detail(SEV_MSG, 5, _T("File version is %s."), FileVersion.Format().c_str());

        if (!ReferenceFileVersion.IsValid())
        {
            //
            // This is the first file with version we've found - store the version as a reference.
            //
            ReferenceFileVersion = FileVersion;
            GetLogger().Detail(SEV_MSG, 5, _T("The version is taken as reference."));
            bVersionOk = true;
        }
        else 
        {
            if (FILE_VERSION_BUILD == dwVersionCheck)
            {
                //
                // Check only build number.
                //
                GetLogger().Detail(SEV_MSG, 5, _T("Checking file build number..."));
                bVersionOk = FileVersion.GetMajorBuildNumber() == ReferenceFileVersion.GetMajorBuildNumber();
            }
            else if (FILE_VERSION_FULL == dwVersionCheck)
            {
                //
                // Check full version information.
                //
                GetLogger().Detail(SEV_MSG, 5, _T("Checking full file version information..."));
                bVersionOk = (FileVersion == ReferenceFileVersion);
            }
            else
            {
                GetLogger().Detail(SEV_ERR, 5, _T("Invalid version check request: %ld"), dwVersionCheck);
                THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CCheckFiles::IsVersionOk - Invalid version check request"));
            }

            if (bVersionOk)
            {
                GetLogger().Detail(SEV_MSG, 5, _T("The version corresponds to the reference."));
            }
            else
            {
                GetLogger().Detail(
                                   SEV_ERR,
                                   1,
                                   _T("The version doesn't correspond to the reference (%s)."),
                                   ReferenceFileVersion.Format().c_str()
                                   );
            }
        }
    }

    return bVersionOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ccoverpageinfo.cpp ===
#include <crtdbg.h>
#include <testruntimeerr.h>
#include <StringUtils.h>
#include "CCoverPageInfo.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CCoverPageInfo::CCoverPageInfo(
                               const tstring &tstrCoverPage,
                               bool          bServerBasedCoverPage,
                               const tstring &tstrSubject,
                               const tstring &tstrNote
                               )
: m_tstrCoverPage(tstrCoverPage),
  m_bServerBasedCoverPage(bServerBasedCoverPage),
  m_tstrSubject(tstrSubject),
  m_tstrNote(tstrNote)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CCoverPageInfo::IsEmpty() const
{
    return m_tstrCoverPage.empty();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline void CCoverPageInfo::FillCoverPageInfoEx(PFAX_COVERPAGE_INFO_EX pCoverPageInfo) const
{
    if (!pCoverPageInfo)
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CCoverPageInfo::FillCoverPageInfoEx - bad pCoverPageInfo"));
    }

    pCoverPageInfo->dwSizeOfStruct          = sizeof(FAX_COVERPAGE_INFO_EX);
    pCoverPageInfo->dwCoverPageFormat       = FAX_COVERPAGE_FMT_COV;
    pCoverPageInfo->lptstrCoverPageFileName = DupString(m_tstrCoverPage.c_str());
    pCoverPageInfo->bServerBased            = m_bServerBasedCoverPage;
    pCoverPageInfo->lptstrSubject           = DupString(m_tstrSubject.c_str());
    pCoverPageInfo->lptstrNote              = DupString(m_tstrNote.c_str());
}



//-----------------------------------------------------------------------------------------------------------------------------------------
PFAX_COVERPAGE_INFO_EX CCoverPageInfo::CreateCoverPageInfoEx() const
{
    PFAX_COVERPAGE_INFO_EX pCoverPageInfo = new FAX_COVERPAGE_INFO_EX;
    _ASSERT(pCoverPageInfo);

    try
    {
        FillCoverPageInfoEx(pCoverPageInfo);
    }
    catch(Win32Err &)
    {
        CCoverPageInfo::FreeCoverPageInfoEx(pCoverPageInfo);
        throw;
    }

    return pCoverPageInfo;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CCoverPageInfo::FreeCoverPageInfoEx(PFAX_COVERPAGE_INFO_EX pCoverPageInfo)
{
    if (pCoverPageInfo)
    {
        delete pCoverPageInfo->lptstrCoverPageFileName;
        delete pCoverPageInfo->lptstrSubject;
        delete pCoverPageInfo->lptstrNote;
        delete pCoverPageInfo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cemptybvtdirectories.cpp ===
#include "CEmptyBVTDirectories.h"
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CEmptyBVTDirectories::CEmptyBVTDirectories(
                                           const tstring &tstrName,
                                           const tstring &tstrDescription,
                                           CLogger       &Logger,
                                           int           iRunsCount,
                                           int           iDeepness
                                           )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CEmptyBVTDirectories::CEmptyBVTDirectories"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CEmptyBVTDirectories::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CEmptyBVTDirectories::Run"));
    
    EmptyDir(g_tstrBVTDir + g_tstrInboxDir);
    EmptyDir(g_tstrBVTDir + g_tstrSentItemsDir);
    EmptyDir(g_tstrBVTDir + g_tstrRoutingDir);

    return true;
}

    

//-----------------------------------------------------------------------------------------------------------------------------------------
void CEmptyBVTDirectories::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CEmptyBVTDirectories::ParseParams"));

    //
    // Read whether to delete only new or all files. If not specified, delete all.
    //
    try
    {
        m_bDeleteNewFilesOnly = FromString<bool>(GetValueFromMap(mapParams, _T("DeleteNewFilesOnly")));
    }
    catch (...)
    {
        m_bDeleteNewFilesOnly = false;
    }

    //
    // Read whether to delete only tiff or all files. If not specified, delete all.
    //
    try
    {
        m_bDeleteTiffFilesOnly = FromString<bool>(GetValueFromMap(mapParams, _T("DeleteTiffFilesOnly")));
    }
    catch (...)
    {
        m_bDeleteTiffFilesOnly = false;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CEmptyBVTDirectories::EmptyDir(const tstring &tstrDirectory)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CEmptyBVTDirectories::EmptyDir"));

    try
    {
        GetLogger().Detail(SEV_MSG, 1, _T("Emptying %s directory..."), tstrDirectory.c_str());

        FILETIME OldestFileToDelete = {0};
        if (m_bDeleteNewFilesOnly)
        {
            OldestFileToDelete = g_TheOldestFileOfInterest;
        }

        tstring tstrExtension = m_bDeleteTiffFilesOnly ? _T(".tif") : _T(".*");

        CFileFilterNewerThanAndExtension Filter(OldestFileToDelete, tstrExtension);
        
        TSTRINGVector vecOddment = ::EmptyDirectory(tstrDirectory, Filter);

        if (vecOddment.empty())
        {
            GetLogger().Detail(SEV_MSG, 1, _T("%s directory emptied."), tstrDirectory.c_str());
        }
        else
        {
            GetLogger().Detail(SEV_WRN, 1, _T("Failed to delete %ld files from %s directory."), vecOddment.size(), tstrDirectory.c_str());

            for (TSTRINGVector::const_iterator citFiles = vecOddment.begin();
                 citFiles != vecOddment.end();
                 ++citFiles
                 )
            {
                GetLogger().Detail(SEV_WRN, 5, citFiles->c_str());
            }
        }
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_WRN, 1, _T("Failed to empty %s directory (ec=%ld)."), tstrDirectory.c_str(), e.error());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cextendedbvtcleanup.h ===
#ifndef __C_EXTENDED_BVT_CLEANUP_H__
#define __C_EXTENDED_BVT_CLEANUP_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CExtendedBVTCleanup test case class.

    Author: Yury Berezansky (YuryB)

    26-June-2001


    *******
    General
    *******

    The class defines a test case, using the "Test Suite Manager" model.
    The test case restores the major changes, applied to the system during
    the ExtendedBVT suite.
   

    **************************************
    Test case specific INI file parameters
    **************************************

    No test case specific parameters.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"



class CExtendedBVTCleanup : public CTestCase {

public:

    CExtendedBVTCleanup(
                        const tstring &tstrName,
                        const tstring &tstrDescription,
                        CLogger       &Logger,
                        int           iRunsCount,
                        int           iDeepness
                        );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    void UnShareBVTDirectory() const;
};



DEFINE_TEST_FACTORY(CExtendedBVTCleanup);



#endif // #ifndef __C_EXTENDED_BVT_CLEANUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cextendedbvtsetup.h ===
#ifndef __C_EXTENDED_BVT_SETUP_H__
#define __C_EXTENDED_BVT_SETUP_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CExtendedBVTSetup test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case performs global configuration changes, needed to run
    the ExtendedBVT suite.


    **************************************
    Test case specific INI file parameters
    **************************************

    DocumentsDirectory = <directory>
      Mandatory.
      Defines the subdirectory of the BVT directory that contains all
      needed documents.
    
    InboxDirectory = <directory>
      Mandatory.
      Defines the subdirectory of the BVT directory to be used as the
      Inbox archive.
    
    SentItemsDirectory = <directory>
      Mandatory.
      Defines the subdirectory of the BVT directory to be used as the
      SentItems archive.
    
    RoutingDirectory = <directory>
      Mandatory.
      Defines the subdirectory of the BVT directory to be used by the
      "Store In Folder" routing method.
    



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"



class CExtendedBVTSetup : public CTestCase {

public:

    CExtendedBVTSetup(
                      const tstring &tstrName,
                      const tstring &tstrDescription,
                      CLogger       &Logger,
                      int           iRunsCount,
                      int           iDeepness
                      );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    void ShareBVTDirectory() const;

    void EnsureDirectoriesExistenceAndAccessRights(const tstring &tstrDirectory, PACL pDacl) const;
};



DEFINE_TEST_FACTORY(CExtendedBVTSetup);



#endif // #ifndef __C_EXTENDED_BVT_SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxconnection.h ===
#ifndef __C_FAX_CONNECTION_H__
#define __C_FAX_CONNECTION_H__



#include <windows.h>
#include <fxsapip.h>
#include <tstring.h>



class CFaxConnection {

public:

    CFaxConnection(const tstring &tstrFaxServer);

    ~CFaxConnection();

    HANDLE GetHandle() const;

    operator HANDLE () const;

    bool IsLocal() const;

private:

    // Avoid usage of copy consructor and assignment operator.
    CFaxConnection(const CFaxConnection &FaxConnection);
    CFaxConnection &operator=(const CFaxConnection &FaxConnection);

    void Connect(const tstring &tstrFaxServer);

    void Disconnect();
    
    HANDLE m_hFaxServer;
    bool   m_bLocal;
};



#endif // #ifndef __C_FAX_CONNECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxconnection.cpp ===
#include "CFaxConnection.h"
#include <testruntimeerr.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxConnection::CFaxConnection(const tstring &tstrFaxServer)
: m_hFaxServer(NULL)
{
    Connect(tstrFaxServer);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxConnection::~CFaxConnection()
{
    try
    {
        Disconnect();
    }
    catch (...)
    {
        if (!uncaught_exception())
        {
            throw;
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxConnection::Connect(const tstring &tstrFaxServer)
{
    //
    // Make sure there is no handle leak;
    //
    Disconnect();

    if (!FaxConnectFaxServer(tstrFaxServer.c_str(), &m_hFaxServer))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxConnection::Connect - FaxConnectFaxServer"));
    }

    m_bLocal = IsLocalServer(tstrFaxServer);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
HANDLE CFaxConnection::GetHandle() const
{
    return m_hFaxServer;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxConnection::operator HANDLE () const
{
    return m_hFaxServer;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFaxConnection::IsLocal() const
{
    return m_bLocal;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxConnection::Disconnect()
{
    if (m_hFaxServer && !FaxClose(m_hFaxServer))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxConnection::Disconnect - FaxClose"));
    }

    m_hFaxServer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cextendedbvtcleanup.cpp ===
// For lm.h
#ifndef FORCE_UNICODE
#define FORCE_UNICODE
#endif



#include "CExtendedBVTCleanup.h"
#include <lm.h>
#include <faxreg.h>
#include "CFaxListener.h"
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CExtendedBVTCleanup::CExtendedBVTCleanup(
                                         const tstring &tstrName,
                                         const tstring &tstrDescription,
                                         CLogger       &Logger,
                                         int           iRunsCount,
                                         int           iDeepness
                                         )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTCleanup::CExtendedBVTCleanup"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CExtendedBVTCleanup::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTCleanup::Run"));

    bool bPassed = true;
    
    try
    {
        //
        // Remove the share from the BVT directory.
        //
        GetLogger().Detail(SEV_MSG, 1, _T("Removing the share from the BVT directory..."));
        UnShareBVTDirectory();
        GetLogger().Detail(SEV_MSG, 1, _T("The share removed."));
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_ERR, 1, e.description());
        bPassed = false;
    }

    GetLogger().Detail(
                       bPassed ? SEV_MSG : SEV_ERR,
                       1,
                       _T("The ExtendedBVT cleanup has%s been completed successfully."),
                       bPassed ? _T("") : _T(" NOT")
                       );

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CExtendedBVTCleanup::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTCleanup::ParseParams"));
    UNREFERENCED_PARAMETER(mapParams);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CExtendedBVTCleanup::UnShareBVTDirectory() const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTCleanup::ShareBVTDirectory"));

    NET_API_STATUS NetApiRes = ::NetShareDel(NULL, BVT_DIRECTORY_SHARE_NAME, 0);
    if (NetApiRes != NERR_Success && NetApiRes != NERR_NetNameNotFound)
    {
        GetLogger().Detail(SEV_WRN, 1, _T("NetShareDel failed with ec=%ld."), NetApiRes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cemptybvtdirectories.h ===
#ifndef __C_EMPTY_BVT_DIRECTORIES_H__
#define __C_EMPTY_BVT_DIRECTORIES_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CEmptyBVTDirectories test case class.

    Author: Yury Berezansky (YuryB)

    28-June-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case allows to empty the BVT directories: Inbox, SentItems
    and Routing, as specified by the CExtendedBVTSetup test case.


    **************************************
    Test case specific INI file parameters
    **************************************

    DeleteNewFilesOnly = <1/0>
      Optional.
      Specifies whether only new or all files should be deleted.
      If not specified, all files deleted.

    DeleteTiffFilesOnly = <1/0>
      Optional.
      Specifies whether only tiff or all files should be deleted.
      If not specified, all files deleted.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"



class CEmptyBVTDirectories : public CTestCase {

public:

    CEmptyBVTDirectories(
                         const tstring &tstrName,
                         const tstring &tstrDescription,
                         CLogger       &Logger,
                         int           iRunsCount,
                         int           iDeepness
                         );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    void EmptyDir(const tstring &tstrDirectory);

    bool m_bDeleteNewFilesOnly;
    bool m_bDeleteTiffFilesOnly;
};



DEFINE_TEST_FACTORY(CEmptyBVTDirectories);



#endif // #ifndef  __C_EMPTY_BVT_DIRECTORIES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cextendedbvtsetup.cpp ===
#include "CExtendedBVTSetup.h"
#include <Shlobj.h>
#include <lm.h>
#include <Aclapi.h>
#include <faxreg.h>
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>
#include "CFaxListener.h"
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CExtendedBVTSetup::CExtendedBVTSetup(
                                     const tstring &tstrName,
                                     const tstring &tstrDescription,
                                     CLogger       &Logger,
                                     int           iRunsCount,
                                     int           iDeepness
                                     )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTSetup::CExtendedBVTSetup"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CExtendedBVTSetup::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTSetup::Run"));

    PACL pFullControlForEveryoneDacl = NULL;
    bool bPassed                     = true;

    try
    {
        //
        // Make sure archives and routing directories exist and have full control access to "Everyone".
        //

        GetLogger().Detail(
                           SEV_MSG,
                           1,
                           _T("Creating archives and routing directories and setting full control access to \"Everyone\"...")
                           );

        ACL EmptyAcl;

        if (!InitializeAcl(&EmptyAcl, sizeof(EmptyAcl), ACL_REVISION))
        {
            DWORD dwEC = GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("InitializeAcl failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CExtendedBVTSetup::Run - InitializeAcl"));
        }

        EXPLICIT_ACCESS FullControlForEveryoneExplicitAccess = {
                                                                   GENERIC_ALL,
                                                                   SET_ACCESS,
                                                                   OBJECT_INHERIT_ACE,
                                                                   {
                                                                       NULL,
                                                                       NO_MULTIPLE_TRUSTEE,
                                                                       TRUSTEE_IS_NAME,
                                                                       TRUSTEE_IS_WELL_KNOWN_GROUP,
                                                                       _T("Everyone")
                                                                   }
                                                               };

        DWORD dwEC = SetEntriesInAcl(1, &FullControlForEveryoneExplicitAccess, &EmptyAcl, &pFullControlForEveryoneDacl);
        if (ERROR_SUCCESS != dwEC)
        {
            GetLogger().Detail(SEV_ERR, 1, _T("SetEntriesInAcl failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CExtendedBVTSetup::Run - SetEntriesInAcl"));
        }

        EnsureDirectoriesExistenceAndAccessRights(
                                                  g_tstrBVTDir + g_tstrInboxDir,
                                                  pFullControlForEveryoneDacl
                                                  );
        EnsureDirectoriesExistenceAndAccessRights(
                                                  g_tstrBVTDir + g_tstrSentItemsDir,
                                                  pFullControlForEveryoneDacl
                                                  );

        EnsureDirectoriesExistenceAndAccessRights(
                                                  g_tstrBVTDir + g_tstrRoutingDir,
                                                  pFullControlForEveryoneDacl
                                                  );

        GetLogger().Detail(SEV_MSG, 1, _T("Directories created and access rights set..."));

        //
        // Create a share for the BVT directory with full controll access for "Everyone".
        //
        GetLogger().Detail(SEV_MSG, 1, _T("Creating a share for the BVT directory..."));
        ShareBVTDirectory();
        GetLogger().Detail(SEV_MSG, 1, _T("The share created."));
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_ERR, 1, e.description());
        bPassed = false;
    }

    if (pFullControlForEveryoneDacl)
    {
        if (NULL != LocalFree(pFullControlForEveryoneDacl))
        {
            GetLogger().Detail(SEV_WRN, 1, _T("LocalFree failed with ec=%ld."), GetLastError());
        }
    }
    
    GetLogger().Detail(
                       bPassed ? SEV_MSG : SEV_ERR,
                       1,
                       _T("The ExtendedBVT setup has%s been completed successfully."),
                       bPassed ? _T("") : _T(" NOT")
                       );

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CExtendedBVTSetup::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTSetup::ParseParams"));

    //
    // Get BVT directory.
    //
    TCHAR tszBuffer[MAX_PATH];
    if (!::GetCurrentDirectory(ARRAY_SIZE(tszBuffer), tszBuffer))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CExtendedBVTSetup::ParseParams - GetCurrentDirectory"));
    }
    g_tstrBVTDir = ForceLastCharacter(tszBuffer, _T('\\'));

    //
    // Combine BVT directory UNC path.
    //
    TCHAR tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwComputerNameSize = ARRAY_SIZE(tszComputerName);
    if (!::GetComputerName(tszComputerName, &dwComputerNameSize))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CExtendedBVTSetup::ParseParams - GetComputerName"));
    }
    g_tstrBVTDirUNC = (((tstring(_T("\\\\")) + tszComputerName) + _T("\\")) + BVT_DIRECTORY_SHARE_NAME) + _T("\\");

    g_tstrDocumentsDir = ForceLastCharacter(GetValueFromMap(mapParams, _T("DocumentsDirectory")), _T('\\'));
    g_tstrInboxDir     = ForceLastCharacter(GetValueFromMap(mapParams, _T("InboxDirectory")),     _T('\\'));
    g_tstrSentItemsDir = ForceLastCharacter(GetValueFromMap(mapParams, _T("SentItemsDirectory")), _T('\\'));
    g_tstrRoutingDir   = ForceLastCharacter(GetValueFromMap(mapParams, _T("RoutingDirectory")),   _T('\\'));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CExtendedBVTSetup::ShareBVTDirectory() const
{

    CScopeTracer Tracer(GetLogger(), 7, _T("CExtendedBVTSetup::ShareBVTDirectory"));

#ifdef _UNICODE

    NET_API_STATUS NetApiRes = NERR_Success;
    
    //
    // Delete existing share since it may point to different directory.
    //
    NetApiRes = NetShareDel(NULL, BVT_DIRECTORY_SHARE_NAME, 0);
    if (NetApiRes != NERR_Success && NetApiRes != NERR_NetNameNotFound)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("NetShareDel failed with ec=%ld."), NetApiRes);
        THROW_TEST_RUN_TIME_WIN32(NetApiRes, _T("CExtendedBVTSetup::ShareBVTDirectory - NetShareDel"));
    }
        
    //
    // Create new share with full control access for "Everyone".
    //

    tstring tstrPath = EliminateLastCharacter(g_tstrBVTDir, _T('\\'));

    SHARE_INFO_2 ShareInfo = {0};

    ShareInfo.shi2_netname  = BVT_DIRECTORY_SHARE_NAME;
    ShareInfo.shi2_type     = STYPE_DISKTREE;
    ShareInfo.shi2_max_uses = -1;
    ShareInfo.shi2_path     = const_cast<LPTSTR>(tstrPath.c_str());
    
    NetApiRes = NetShareAdd(NULL, 2, reinterpret_cast<LPBYTE>(&ShareInfo), NULL);
    if (NetApiRes != NERR_Success)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("NetShareAdd failed with ec=%ld."), NetApiRes);
        THROW_TEST_RUN_TIME_WIN32(NetApiRes, _T("CExtendedBVTSetup::ShareBVTDirectory - NetShareAdd"));
    }

#else

    _ASSERT(false);

#endif

}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CExtendedBVTSetup::EnsureDirectoriesExistenceAndAccessRights(const tstring &tstrDirectory, PACL pDacl) const
{
    DWORD dwEC;

    //
    // Create directory. If one or more of the intermediate directories do not exist, they will be created as well.
    //
    dwEC = SHCreateDirectoryEx(NULL, tstrDirectory.c_str(), NULL);
    if (ERROR_SUCCESS != dwEC && ERROR_FILE_EXISTS != dwEC && ERROR_ALREADY_EXISTS != dwEC)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to create %s directory (ec=%ld)."), tstrDirectory.c_str(), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CExtendedBVTSetup::EnsureDirectoriesExistenceAndAccessRights - SHCreateDirectoryEx"));
    }

    //
    // Set the access rights.
    //
    dwEC = SetNamedSecurityInfo(
                                const_cast<LPTSTR>(tstrDirectory.c_str()),
                                SE_FILE_OBJECT,
                                DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                NULL,
                                NULL,
                                pDacl,
                                NULL
                                );
    if (ERROR_SUCCESS != dwEC)
    {
        GetLogger().Detail(
                           SEV_ERR,
                           1,
                           _T("Failed to set full access rights for everyone to %s directory (ec=%ld)."),
                           tstrDirectory.c_str(),
                           dwEC
                           );
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CExtendedBVTSetup::EnsureDirectoriesExistenceAndAccessRights - SetNamedSecurityInfo"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxeventexptr.h ===
#ifndef __C_FAX_EVENT_EX_PTR_H__
#define __C_FAX_EVENT_EX_PTR_H__



#include <windows.h>
#include <tstring.h>
#include <fxsapip.h>



class CFaxEventExPtr {

public:

    CFaxEventExPtr(PFAX_EVENT_EX pFaxEventEx = NULL);

    ~CFaxEventExPtr();

    bool IsValid() const;
    
    PFAX_EVENT_EX operator->() const;

    const tstring &Format() const;

private:

    // Avoid usage of copy consructor and assignment operator.
    CFaxEventExPtr(const CFaxEventExPtr &FaxEventEx);
    CFaxEventExPtr &operator=(const CFaxEventExPtr &FaxEventEx);

    PFAX_EVENT_EX        m_pFaxEventEx;
    mutable tstring      m_tstrFormatedString;
    static const tstring m_tstrInvalidEvent;
};



#endif // #ifndef __C_FAX_EVENT_EX_PTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxeventexptr.cpp ===
#include "CFaxEventExPtr.h"
#include "Util.h"
#include "FaxConstantsNames.h"



#define FIELD_CAPTION_WIDTH 30


//-----------------------------------------------------------------------------------------------------------------------------------------
const tstring CFaxEventExPtr::m_tstrInvalidEvent = _T("Invalid Event");



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxEventExPtr::CFaxEventExPtr(PFAX_EVENT_EX pFaxEventEx)
: m_pFaxEventEx(pFaxEventEx)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxEventExPtr::~CFaxEventExPtr()
{
    FaxFreeBuffer(m_pFaxEventEx);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFaxEventExPtr::IsValid() const
{
    return m_pFaxEventEx != NULL;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
PFAX_EVENT_EX CFaxEventExPtr::operator->() const
{
    return m_pFaxEventEx;
}


    
//-----------------------------------------------------------------------------------------------------------------------------------------
const tstring &CFaxEventExPtr::Format() const
{
    if (!m_pFaxEventEx)
    {
        return CFaxEventExPtr::m_tstrInvalidEvent;
    }

    if (m_tstrFormatedString.empty())
    {
        //
        // The string is not combined yet - do it.
        //

        TCHAR     tszBuf[1024];
        int       iCurrPos     = 0;
        const int iBufSize     = ARRAY_SIZE(tszBuf);

        //
        // Format time stamp.
        //

        FILETIME LocalFileTime;
        if (!::FileTimeToLocalFileTime(&(m_pFaxEventEx->TimeStamp), &LocalFileTime))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxEventExPtr::Format - FileTimeToLocalFileTime"));
        }

        SYSTEMTIME SystemTime;
        if(!::FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxEventExPtr::Format - FileTimeToSystemTime"));
        }

        iCurrPos += _sntprintf(
                               tszBuf + iCurrPos,
                               iBufSize - iCurrPos,
                               _T("%-*s%ld/%ld/%ld  %ld:%02ld:%02ld\n"),
                               FIELD_CAPTION_WIDTH,
                               _T("TimeStamp:"),
                               SystemTime.wDay,
                               SystemTime.wMonth,
                               SystemTime.wYear,
                               SystemTime.wHour,
                               SystemTime.wMinute,
                               SystemTime.wSecond
                               );

        //
        // Format event type.
        //
        iCurrPos += _sntprintf(
                               tszBuf + iCurrPos,
                               iBufSize - iCurrPos,
                               _T("%-*s%s\n"),
                               FIELD_CAPTION_WIDTH,
                               _T("EventType:"),
                               EventTypeToString(m_pFaxEventEx->EventType).c_str()
                               );

        //
        // Format type specific information.
        //
        switch (m_pFaxEventEx->EventType)
        {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:

            iCurrPos += _sntprintf(
                                   tszBuf + iCurrPos,
                                   iBufSize - iCurrPos,
                                   _T("%-*s0x%I64x\n%-*s%s\n"),
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwlMessageId:"),
                                   m_pFaxEventEx->EventInfo.JobInfo.dwlMessageId,
                                   FIELD_CAPTION_WIDTH,
                                   _T("JobEventType:"),
                                   JobEventTypeToString(m_pFaxEventEx->EventInfo.JobInfo.Type).c_str()
                                   );
           
            if (m_pFaxEventEx->EventInfo.JobInfo.Type == FAX_JOB_EVENT_TYPE_STATUS)
            {
                _ASSERT(m_pFaxEventEx->EventInfo.JobInfo.pJobData);
                
                iCurrPos += _sntprintf(
                                       tszBuf + iCurrPos,
                                       iBufSize - iCurrPos,
                                       _T("%-*s%s\n%-*s%ld\n%-*s%s\n%-*s%s\n%-*s%s\n%-*s%ld\n%-*s%s\n"),
                                       FIELD_CAPTION_WIDTH,
                                       _T("lpctstrDeviceName:"),
                                       m_pFaxEventEx->EventInfo.JobInfo.pJobData->lpctstrDeviceName,
                                       FIELD_CAPTION_WIDTH,
                                       _T("dwDeviceId:"),
                                       m_pFaxEventEx->EventInfo.JobInfo.pJobData->dwDeviceID,
                                       FIELD_CAPTION_WIDTH,
                                       _T("QueueStatus:"),
                                       QueueStatusToString(m_pFaxEventEx->EventInfo.JobInfo.pJobData->dwQueueStatus).c_str(),
                                       FIELD_CAPTION_WIDTH,
                                       _T("ExtendedStatus:"),
                                       ExtendedStatusToString(m_pFaxEventEx->EventInfo.JobInfo.pJobData->dwExtendedStatus).c_str(),
                                       FIELD_CAPTION_WIDTH,
                                       _T("ProprietaryExtendedStatus:"),
                                       m_pFaxEventEx->EventInfo.JobInfo.pJobData->lpctstrExtendedStatus,
                                       FIELD_CAPTION_WIDTH,
                                       _T("dwCurrentPage:"),
                                       m_pFaxEventEx->EventInfo.JobInfo.pJobData->dwCurrentPage,
                                       FIELD_CAPTION_WIDTH,
                                       _T("lpctstrTsid:"),
                                       m_pFaxEventEx->EventInfo.JobInfo.pJobData->lpctstrTsid
                                       );
            }
            
            break;

        case FAX_EVENT_TYPE_CONFIG:

            iCurrPos += _sntprintf(
                                   tszBuf + iCurrPos,
                                   iBufSize - iCurrPos,
                                   _T("%-*s%s\n"),
                                   FIELD_CAPTION_WIDTH,
                                   _T("ConfigType:"),
                                   ConfigEventTypeToString(m_pFaxEventEx->EventInfo.ConfigType).c_str()
                                   );

            break;

        case FAX_EVENT_TYPE_ACTIVITY:

            iCurrPos += _sntprintf(
                                   tszBuf + iCurrPos,
                                   iBufSize - iCurrPos,
                                   _T("%-*s%ld\n%-*s%ld\n%-*s%ld\n%-*s%ld\n%-*s%ld\n"),
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwIncomingMessages:"),
                                   m_pFaxEventEx->EventInfo.ActivityInfo.dwIncomingMessages,
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwRoutingMessages:"),
                                   m_pFaxEventEx->EventInfo.ActivityInfo.dwRoutingMessages,
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwOutgoingMessages:"),
                                   m_pFaxEventEx->EventInfo.ActivityInfo.dwOutgoingMessages,
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwDelegatedOutgoingMessages:"),
                                   m_pFaxEventEx->EventInfo.ActivityInfo.dwDelegatedOutgoingMessages,
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwQueuedMessages:"),
                                   m_pFaxEventEx->EventInfo.ActivityInfo.dwQueuedMessages
                                   );

            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:

            iCurrPos += _sntprintf(
                                   tszBuf + iCurrPos,
                                   iBufSize - iCurrPos,
                                   _T("%-*s%ld\n"),
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwQueueStates:"),
                                   m_pFaxEventEx->EventInfo.dwQueueStates
                                   );

            break;

        case FAX_EVENT_TYPE_FXSSVC_ENDED:

            break;

        case FAX_EVENT_TYPE_DEVICE_STATUS:
            {
                FAX_ENUM_DEVICE_STATUS DeviceStatus = static_cast<FAX_ENUM_DEVICE_STATUS>(m_pFaxEventEx->EventInfo.DeviceStatus.dwNewStatus);

                iCurrPos += _sntprintf(
                                       tszBuf + iCurrPos,
                                       iBufSize - iCurrPos,
                                       _T("%-*s%ld\n%-*s%s\n"),
                                       FIELD_CAPTION_WIDTH,
                                       _T("dwDeviceId:"),
                                       m_pFaxEventEx->EventInfo.DeviceStatus.dwDeviceId,
                                       FIELD_CAPTION_WIDTH,
                                       _T("dwNewStatus:"),
                                       DeviceStatusToString(DeviceStatus).c_str()
                                       );

                break;
            }

        case FAX_EVENT_TYPE_NEW_CALL:

            iCurrPos += _sntprintf(
                                   tszBuf + iCurrPos,
                                   iBufSize - iCurrPos,
                                   _T("%-*s%ld\n%-*s%ld\n%-*s%s\n"),
                                   FIELD_CAPTION_WIDTH,
                                   _T("hCall:"),
                                   m_pFaxEventEx->EventInfo.NewCall.hCall,
                                   FIELD_CAPTION_WIDTH,
                                   _T("dwDeviceId:"),
                                   m_pFaxEventEx->EventInfo.NewCall.dwDeviceId,
                                   FIELD_CAPTION_WIDTH,
                                   _T("lptstrCallerId:"),
                                   m_pFaxEventEx->EventInfo.NewCall.lptstrCallerId
                                   );

            break;

        default:

            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxEventExPtr::Format - Invalid EventType"));
            break;
        }

        //
        // Remove trailing new line.
        //
        if (iCurrPos > 0 && tszBuf[iCurrPos - 1] == _T('\n'))
        {
            tszBuf[iCurrPos - 1] = _T('\0');
        }
        
        m_tstrFormatedString = tszBuf;
    }
    
    return m_tstrFormatedString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxmessage.h ===
#ifndef __C_FAX_MESSAGE_H__
#define __C_FAX_MESSAGE_H__



#include <windows.h>
#include <TCHAR.h>
#include <fxsapip.h>
#include <tstring.h>
#include <autorel.h>
#include <LoggerClasses.h>
#include "CFaxListener.h"
#include "CCoverPageInfo.h"
#include "CPersonalInfo.h"
#include "CMessageInfo.h"
#include "CTracker.h"



typedef enum {
    SEND_MECHANISM_API = 1,
    SEND_MECHANISM_SPOOLER,
    SEND_MECHANISM_COM,
    SEND_MECHANISM_OUTLOOK
} ENUM_SEND_MECHANISM;



//
// "Forward" declaration to resolve cyclic dependency of CTracker and CFaxMessage.
//
class CTracker;

class CFaxMessage {

public:

    CFaxMessage(
                const CCoverPageInfo *pCoverPage,
                const tstring        &tstrDocument, 
                const CPersonalInfo  *Recipients,
                DWORD                dwRecipientsCount,
                CLogger              &Logger
                );

    ~CFaxMessage();

    void Send(
              const tstring         &tstrSendingServer    = _T(""),
              const tstring         &tstrReceivingServer  = _T(""),
              ENUM_SEND_MECHANISM   SendMechanism         = SEND_MECHANISM_API,
              bool                  bTrackSend            = false,
              bool                  bTrackReceive         = false,
              ENUM_EVENTS_MECHANISM EventsMechanism       = EVENTS_MECHANISM_DEFAULT,
              DWORD                 dwNotificationTimeout = DEFAULT_NOTIFICATION_TIMEOUT
              );

    DWORDLONG GetSendMessageID(DWORD dwRecipient = 0) const;

    DWORDLONG GetBroadcastID() const;

    DWORD GetRecipientsCount() const;

    bool SetStateAndCheckWhetherItIsFinal(
                                          ENUM_MESSAGE_TYPE MessageType,
                                          DWORDLONG dwlMessageId,
                                          DWORD dwQueueStatus,
                                          DWORD dwExtendedStatus
                                          );

private:
    
    void Send_API(CTracker &Tracker);

    void Send_Spooler(CTracker &Tracker);

    void SetRegistryHack();

    void RemoveRegistryHack();

    void CalculateRegistryHackKeyName();

    PFAX_COVERPAGE_INFO_EX m_pCoverPageInfo;
    LPTSTR                 m_lptstrDocument;
    PFAX_PERSONAL_PROFILE  m_pSender;
    PFAX_PERSONAL_PROFILE  m_pRecipients;
    DWORD                  m_dwRecipientsCount;
    PFAX_JOB_PARAM_EX      m_pJobParams;
    DWORDLONG              m_dwlBroadcastID;
    CMessageInfo           *m_pSendMessages;
    CMessageInfo           *m_pReceiveMessages;
    CLogger                &m_Logger;
    tstring                m_tstrSendingServer;
    tstring                m_tstrReceivingServer;
    tstring                m_tstrRegistryHackKeyName;
    bool                   m_bTrackSend;
    bool                   m_bTrackReceive;
    ENUM_EVENTS_MECHANISM  m_EventsMechanism;
    DWORD                  m_dwNotificationTimeout;
};



#endif // #ifndef __C_FAX_MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxmessage.cpp ===
#include "CFaxMessage.h"
#include <shellapi.h>
#include <faxreg.h>
#include <RegHackUtils.h>
#include <ptrs.h>
#include <StringUtils.h>
#include "FaxConstantsNames.h"
#include "CFaxConnection.h"
#include "Util.h"

//
// @@@ Issue.
// What should we do with jobs if something went wrong?
// If we delete them - we will not be able to see them and investigate.
// If we leave them - the subsequent tests may fail (e.g. busy line).
//



#define FIELD_CAPTION_WIDTH 15



//
// The Send Wizard registry hack information is stored under
// HKLM\Software\Microsoft\Fax\UserInfo\WzrdHack\<textual user SID> key
// and has the following values: cover page name, server based or personal, recipients list and number of repetitions.
//
#define REGKEY_WZRDHACK        _T("Software\\Microsoft\\Fax\\UserInfo\\WzrdHack")
#define REGVAL_FAKECOVERPAGE   _T("FakeCoverPage")
#define REGVAL_FAKETESTSCOUNT  _T("FakeTestsCount")
#define REGVAL_FAKESERVERBASED _T("FakeServerBased")
#define REGVAL_FAKERECIPIENT   _T("FakeRecipient0")



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxMessage::CFaxMessage(
                         const CCoverPageInfo *pCoverPage,
                         const tstring        &tstrDocument, 
                         const CPersonalInfo  *pRecipients,
                         DWORD                dwRecipientsCount,
                         CLogger              &Logger
                         )
: m_pCoverPageInfo(NULL),
  m_lptstrDocument(NULL),
  m_pSender(NULL),
  m_pRecipients(NULL),
  m_dwRecipientsCount(dwRecipientsCount),
  m_pJobParams(NULL),
  m_dwlBroadcastID(0),
  m_pSendMessages(NULL),
  m_pReceiveMessages(NULL),
  m_Logger(Logger),
  m_EventsMechanism(EVENTS_MECHANISM_DEFAULT)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::CFaxMessage"));

    if (tstrDocument.empty() && (!pCoverPage || pCoverPage->IsEmpty()))
    {
        m_Logger.Detail(SEV_ERR, 1, _T("No document, no cover page."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFaxMessage::CFaxMessage - no document, no cover page"));
    }
    
    if (!pRecipients || dwRecipientsCount == 0)
    {
        m_Logger.Detail(SEV_ERR, 1, _T("No recipients."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFaxMessage::CFaxMessage - no recipients"));
    }

    //
    // Save document name.
    //
    if (!tstrDocument.empty())
    {
        m_lptstrDocument = DupString(tstrDocument.c_str());
        _ASSERT(m_lptstrDocument);
    }
    
    //
    // Save cover page info.
    //
    if (pCoverPage && !pCoverPage->IsEmpty())
    {
        m_pCoverPageInfo = pCoverPage->CreateCoverPageInfoEx();
        _ASSERT(m_pCoverPageInfo);
    }

    //
    // Save recipients.
    //
    m_pRecipients = new FAX_PERSONAL_PROFILE[m_dwRecipientsCount];
    _ASSERT(m_pRecipients);
    for (DWORD dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        pRecipients[dwInd].FillPersonalProfile(&m_pRecipients[dwInd]);
    }

    //
    // Create empty sender.
    //
    m_pSender = new FAX_PERSONAL_PROFILE;
    _ASSERT(m_pSender);
    m_pSender->dwSizeOfStruct       = sizeof(FAX_PERSONAL_PROFILE);
    m_pSender->lptstrName           = DupString(_T("Sender's Name"));
    m_pSender->lptstrFaxNumber      = DupString(_T("Sender's Fax Number"));
    m_pSender->lptstrCompany        = DupString(_T("Sender's Company"));
    m_pSender->lptstrStreetAddress  = DupString(_T("Sender's Address"));
    m_pSender->lptstrCity           = DupString(_T("Sender's City"));
    m_pSender->lptstrState          = DupString(_T("Sender's State"));
    m_pSender->lptstrZip            = DupString(_T("Sender's Zip Code"));
    m_pSender->lptstrCountry        = DupString(_T("Sender's Country"));
    m_pSender->lptstrTitle          = DupString(_T("Sender's Title"));
    m_pSender->lptstrDepartment     = DupString(_T("Sender's Department"));
    m_pSender->lptstrOfficeLocation = DupString(_T("Sender's Office Location"));
    m_pSender->lptstrHomePhone      = DupString(_T("Sender's Home Phone"));
    m_pSender->lptstrOfficePhone    = DupString(_T("Sender's Office Phone"));
    m_pSender->lptstrEmail          = DupString(_T("Sender's E-mail"));
    m_pSender->lptstrBillingCode    = DupString(_T("Sender's Billing Code"));
    m_pSender->lptstrTSID           = DupString(_T("Sender's TSID"));

    //
    // Create job params.
    //
    m_pJobParams = new FAX_JOB_PARAM_EX;
    _ASSERT(m_pJobParams);
    ZeroMemory(m_pJobParams, sizeof(FAX_JOB_PARAM_EX));
    m_pJobParams->dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
    m_pJobParams->dwScheduleAction = JSA_NOW;
    m_pJobParams->dwReceiptDeliveryType = DRT_NONE;
    m_pJobParams->Priority = FAX_PRIORITY_TYPE_NORMAL;
    
    //
    // Allocate memory for send and receive messages info.
    //
    m_pSendMessages    = new CMessageInfo[m_dwRecipientsCount];
    m_pReceiveMessages = new CMessageInfo[m_dwRecipientsCount];
    _ASSERT(m_pSendMessages);
    _ASSERT(m_pReceiveMessages);

    //
    // Set MessageType.
    //
    for (dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        m_pSendMessages[dwInd].SetMessageType(MESSAGE_TYPE_SEND);
        m_pReceiveMessages[dwInd].SetMessageType(MESSAGE_TYPE_RECEIVE);
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CFaxMessage::~CFaxMessage()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::~CFaxMessage"));

    //
    // Free allocated memory.
    //
    CCoverPageInfo::FreeCoverPageInfoEx(m_pCoverPageInfo);
    delete m_lptstrDocument;
    CPersonalInfo::FreePersonalProfile(m_pSender);
    CPersonalInfo::FreePersonalProfile(m_pRecipients, m_dwRecipientsCount);
    delete m_pJobParams;
    delete[] m_pSendMessages;
    delete[] m_pReceiveMessages;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline DWORDLONG CFaxMessage::GetSendMessageID(DWORD dwRecipient) const
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::GetSendMessageID"));

    if (dwRecipient > m_dwRecipientsCount - 1)
    {
        m_Logger.Detail(SEV_ERR, 1, _T("dwRecipient out of range."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFaxMessage::GetSendMessageID - invalid dwRecipient"));
    }
    
    return m_pSendMessages[dwRecipient].GetMessageID();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline DWORDLONG CFaxMessage::GetBroadcastID() const
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::GetBroadcastID"));
    return m_dwlBroadcastID;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD CFaxMessage::GetRecipientsCount() const
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::GetRecipientsCount"));
    return m_dwRecipientsCount;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFaxMessage::SetStateAndCheckWhetherItIsFinal(
                                                   ENUM_MESSAGE_TYPE MessageType,
                                                   DWORDLONG dwlMessageId,
                                                   DWORD dwQueueStatus,
                                                   DWORD dwExtendedStatus
                                                   )
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::SetStateAndCheckWhetherItIsFinal"));

    CMessageInfo *pMessages = NULL;

    switch (MessageType)
    {
    case MESSAGE_TYPE_SEND:
        pMessages = m_pSendMessages;
        break;

    case MESSAGE_TYPE_RECEIVE:
        pMessages = m_pReceiveMessages;
        break;

    default:
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFaxMessage::SetStateAndCheckWhetherItIsFinal - invalid MessageType"));
    }
    
    for (DWORD dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        if (pMessages[dwInd].GetMessageID() == dwlMessageId)
        {
            m_Logger.Detail(
                            SEV_MSG,
                            5,
                            _T("Updating state of message 0x%I64x from (%s, %s) to (%s, %s)..."),
                            dwlMessageId,
                            ::QueueStatusToString(pMessages[dwInd].GetMessageQueueStatus()).c_str(),
                            ::ExtendedStatusToString(pMessages[dwInd].GetMessageExtendedStatus()).c_str(),
                            ::QueueStatusToString(dwQueueStatus).c_str(),
                            ::ExtendedStatusToString(dwExtendedStatus).c_str()
                            );

            try
            {
                //
                // SetState() validates the transition and throws exception if it's invalid.
                //
                pMessages[dwInd].SetState(dwQueueStatus, dwExtendedStatus);
            }
            catch (Win32Err &e)
            {
                m_Logger.Detail(SEV_ERR, 1, _T("Failed to update the message state (ec=%ld)."), e.error());
                throw;
            }

            bool bInFinalState = pMessages[dwInd].IsInFinalState();

            m_Logger.Detail(SEV_MSG, 5, _T("Message state updated. New state is %sfinal."), bInFinalState ? _T("") : _T("NOT "));

            return bInFinalState;
        }
    }

    //
    // We get here if the requested message doesn't exist.
    //
    THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("CFaxMessage::SetStateAndCheckWhetherItIsFinal - message not found"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::Send(
                       const tstring         &tstrSendingServer,
                       const tstring         &tstrReceivingServer,
                       ENUM_SEND_MECHANISM   SendMechanism,
                       bool                  bTrackSend,
                       bool                  bTrackReceive,
                       ENUM_EVENTS_MECHANISM EventsMechanism,
                       DWORD                 dwNotificationTimeout
                       )
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::Send"));

    if (bTrackReceive && ((SendMechanism != SEND_MECHANISM_API) || (m_dwRecipientsCount > 1)))
    {
        //
        // Tracking of received job is implemented only for single recipient faxes sent using API.
        //
        m_Logger.Detail(SEV_ERR, 1, _T("Tracking of receive is not implemented."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_CALL_NOT_IMPLEMENTED, _T("CFaxMessage::Send - tracking of receive is not implemented"));
    }

    //
    // Set send parameters.
    //
    m_tstrSendingServer     = tstrSendingServer;
    m_tstrReceivingServer   = tstrReceivingServer;
    m_bTrackSend            = bTrackSend;
    m_bTrackReceive         = bTrackReceive;
    m_EventsMechanism       = EventsMechanism;
    m_dwNotificationTimeout = dwNotificationTimeout;   

    //
    // Reset broadcast ID.
    //
    m_dwlBroadcastID = 0;

    //
    // Reset send and receive messages info.
    //
    for (DWORD dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        m_pSendMessages[dwInd].ResetAll();
        m_pReceiveMessages[dwInd].ResetAll();
    }

    //
    // Create a tracker.
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Creating a tracker..."));
    
    CTracker Tracker(
                     *this,
                     m_Logger,
                     m_tstrSendingServer,
                     m_tstrReceivingServer,
                     m_bTrackSend,
                     m_bTrackReceive,
                     m_EventsMechanism,
                     m_dwNotificationTimeout
                     );
    
    //
    // Send the message.
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Sending the message..."));
    switch (SendMechanism)
    {
    case SEND_MECHANISM_API:
        Send_API(Tracker);
        break;
    case SEND_MECHANISM_SPOOLER:
        Send_Spooler(Tracker);
        break;
    case SEND_MECHANISM_COM:
    case SEND_MECHANISM_OUTLOOK:
        m_Logger.Detail(SEV_ERR, 1, _T("Sending using this mechanism is not implemented."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_CALL_NOT_IMPLEMENTED, _T("CFaxMessage::Send - sending using this mechanism is not implemented"));
        break;
    default:
        m_Logger.Detail(SEV_ERR, 1, _T("Invalid SendMechanism: %ld."), SendMechanism);
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFaxMessage::Send - invalid SendMechanism"));
    }

    //
    // Wait for tracking to complete and examine the results.
    //
    Tracker.ExamineTrackingResults();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::Send_API(CTracker &Tracker)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::Send_API"));

    //
    // If an exception will occur, it will be catched, stored and re-thrown.
    //
    Win32Err StoredException(ERROR_SUCCESS, 0, _T(""), _T(""));

    //
    // Save the original sender's TSID to restore it later.
    //
    LPTSTR lptstrOriginalTSID = m_pSender->lptstrTSID;

    try
    {
        //
        // Create a fax connection. Automatically disconnects when goes out of scope.
        //
        CFaxConnection FaxConnection(m_tstrSendingServer);

        //
        // Allocate temporary array for message IDs.
        // The memory is automatically released when aapdwlMessageIDs goes out of scope.
        //
        aaptr<DWORDLONG> aapdwlMessageIDs = new DWORDLONG[m_dwRecipientsCount];

        //
        // TSID is the only data field that is passed as part of T30 protocol and may serve
        // to associate a received job with a sent job.
        // Generate a "unique" TSID.
        //
        tstring tstrTSID = ToString(::GetTickCount());

        if (m_bTrackReceive)
        {
            //
            // Replace the original TSID with the "unique" one.
            //
            m_pSender->lptstrTSID = const_cast<LPTSTR>(tstrTSID.c_str());
        }
        
        //
        // Send the fax.
        //

        m_Logger.Detail(
                        SEV_MSG,
                        5,
                        _T("Calling FaxSendDocumentEx:\n%-*s%s\n%-*s%s\n%-*s%s"),
                        FIELD_CAPTION_WIDTH,
                        _T("Document:"),
                        m_lptstrDocument,
                        FIELD_CAPTION_WIDTH,
                        _T("CoverPage:"),
                        m_pCoverPageInfo ? m_pCoverPageInfo->lptstrCoverPageFileName : NULL,
                        FIELD_CAPTION_WIDTH,
                        _T("TSID:"),
                        m_pSender->lptstrTSID
                        );

        if (!::FaxSendDocumentEx(
                               FaxConnection,
                               m_lptstrDocument,
                               m_pCoverPageInfo,
                               m_pSender,
                               m_dwRecipientsCount,
                               m_pRecipients,
                               m_pJobParams,
                               &m_dwlBroadcastID,
                               aapdwlMessageIDs
                               ))
        {
            DWORD dwEC = ::GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("FaxSendDocumentEx failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::Send_API - FaxSendDocumentEx"));
        }

        //
        // Remember the moment, the fax has been sent.
        //
        DWORD dwTickCountWhenFaxSent = ::GetTickCount();

        if (m_bTrackSend)
        {
            //
            // Copy sent messages IDs.
            //
            for (DWORD dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
            {
                m_pSendMessages[dwInd].SetMessageID(aapdwlMessageIDs[dwInd]);
            }

            //
            // Release the send tracking thread.
            //
            Tracker.BeginTracking(MESSAGE_TYPE_SEND);
            m_Logger.Detail(SEV_MSG, 5, _T("Send tracking thread released."));
        }

        if (m_bTrackReceive)
        {
            _ASSERT(1 == m_dwRecipientsCount);

            m_Logger.Detail(SEV_MSG, 5, _T("Looking for a matching received job."));

            //
            // Register for notifications on receiving server.
            //
            CFaxListener Listener(
                                  m_tstrReceivingServer,
                                  FAX_EVENT_TYPE_IN_QUEUE,
                                  m_EventsMechanism,
                                  m_dwNotificationTimeout,
                                  false
                                  );

            m_Logger.Detail(SEV_MSG, 5, _T("Listener created and registered."));

            bool bMatchFound = false;

            for(;;)
            {
                m_Logger.Detail(SEV_MSG, 5, _T("Waiting for event..."));

                CFaxEventExPtr FaxEventExPtr(Listener.GetEvent());

                if (!FaxEventExPtr.IsValid())
                {
                    //
                    // Invalid event - either timeout or abort of tracking.
                    //
                    break;
                }

                m_Logger.Detail(SEV_MSG, 5, _T("Got a valid event...\n%s"), FaxEventExPtr.Format().c_str());

                //
                // We are registered only for IN_QUEUE events.
                //
                _ASSERT(FAX_EVENT_TYPE_IN_QUEUE == FaxEventExPtr->EventType);

                if (FAX_JOB_EVENT_TYPE_STATUS != FaxEventExPtr->EventInfo.JobInfo.Type)
                {
                    m_Logger.Detail(SEV_MSG, 5, _T("Not a status event - discarded."));
                    continue;
                }

                PFAX_JOB_STATUS pJobData = FaxEventExPtr->EventInfo.JobInfo.pJobData;

                _ASSERT(pJobData);

                //
                // Compare the job TSID with sender's TSID.
                //
                if (pJobData && pJobData->lpctstrTsid)
                {
                    m_Logger.Detail(SEV_MSG, 5, _T("The job TSID is %s."), pJobData->lpctstrTsid);

                    if (tstrTSID == pJobData->lpctstrTsid)
                    {
                        //
                        // TSIDs match - our job.
                        //
                        m_Logger.Detail(
                                        SEV_MSG,
                                        5,
                                        _T("TSIDs match. Receiving will be tracked for job 0x%I64x."),
                                        FaxEventExPtr->EventInfo.JobInfo.dwlMessageId
                                        );

                        m_pReceiveMessages[0].SetMessageID(FaxEventExPtr->EventInfo.JobInfo.dwlMessageId);

                        bMatchFound = true;

                        //
                        // Release the receive tracking thread.
                        //
                        Tracker.BeginTracking(MESSAGE_TYPE_RECEIVE);
                        m_Logger.Detail(SEV_MSG, 5, _T("Receive tracking thread released."));

                        break;
                    }
                    else
                    {
                        m_Logger.Detail(SEV_MSG, 5, _T("TSIDs don't match. Try again..."));
                    }
                }
                else
                {
                    m_Logger.Detail(SEV_MSG, 5, _T("Job TSID is unknown."));
                }

                //
                // The matching not found yet. 
                // Check whether we are still willing to wait.
                //
                DWORD dwCurrentTickCount = GetTickCount();
                if (dwCurrentTickCount - dwTickCountWhenFaxSent >= m_dwNotificationTimeout ||
                    dwCurrentTickCount <= dwTickCountWhenFaxSent
                    )
                {
                    break;
                }
                //
                // else, continue listening
                //
            }

            if (!bMatchFound)
            {
                m_Logger.Detail(SEV_ERR, 1, _T("Receive job was not detected during %ld msec."), m_dwNotificationTimeout);
                THROW_TEST_RUN_TIME_WIN32(ERROR_TIMEOUT, _T("CFaxMessage::Send_API - receive job was not detected"));
            }
        }
    }
    catch(Win32Err &e)
    {
        StoredException = e;
    }

    //
    // Restore the original TSID.
    //
    m_pSender->lptstrTSID = lptstrOriginalTSID;

    if (StoredException.error() != ERROR_SUCCESS)
    {
        //
        // Re-throw the exception, stored earlier.
        //
        throw StoredException;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::Send_Spooler(CTracker &Tracker)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::Send_Spooler"));

    PFAX_JOB_ENTRY_EX pJob = NULL;

    //
    // If an exception will occur, it will be catched, stored and re-thrown.
    //
    Win32Err StoredException(ERROR_SUCCESS, 0, _T(""), _T(""));

    try
    {
        //
        // Create a fax connection. Automatically disconnects when goes out of scope.
        //
        CFaxConnection FaxConnection(m_tstrSendingServer);

        //
        // Set the SendWizard registry hack.
        //
        SetRegistryHack();

        //
        // Get the fax printer name.
        // This may be "Fax" or its localized equivalent for a local fax printer or a UNC path for a remote fax printer.
        //
        tstring tstrFaxPrinter = ::GetFaxPrinterName(m_tstrSendingServer);

        //
        // Initialize ShellExecInfo structure:
        //  * in order to send a document, we should pass "printto", document name and printer name.
        //  * in order to send a cover page fax, we should pass send wizard command line and printer name.
        //
        SHELLEXECUTEINFO ShellExecInfo;
        ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
        ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
        ShellExecInfo.fMask         = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT;
        ShellExecInfo.lpVerb        = m_lptstrDocument ? TEXT("printto") : NULL;
        ShellExecInfo.lpFile        = m_lptstrDocument ? m_lptstrDocument : FAX_SEND_IMAGE_NAME;
        ShellExecInfo.lpParameters  = tstrFaxPrinter.c_str();
        ShellExecInfo.nShow         = SW_SHOWMINNOACTIVE;

        m_Logger.Detail(
                        SEV_MSG,
                        5,
                        _T("Invoking ShellExecuteEx:\n%-*s%s\n%-*s%s\n%-*s%s"),
                        FIELD_CAPTION_WIDTH,
                        _T("lpVerb:"),
                        ShellExecInfo.lpVerb,
                        FIELD_CAPTION_WIDTH,
                        _T("lpFile:"),
                        ShellExecInfo.lpFile,
                        FIELD_CAPTION_WIDTH,
                        _T("lpParameters:"),
                        ShellExecInfo.lpParameters
                        );


        if (!m_bTrackSend)
        {
            //
            // Print document, using "printto" verb. No tracking needed.
            //
            if (!ShellExecuteEx(&ShellExecInfo))
            {
                DWORD dwEC = GetLastError();
                m_Logger.Detail(SEV_ERR, 1, _T("ShellExecuteEx failed with ec=%ld."), dwEC);
                THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::Send_Spooler - ShellExecuteEx"));
            }
        }
        else
        {
            //
            // Register for notifications on sending server.
            //
            CFaxListener Listener(FaxConnection, FAX_EVENT_TYPE_OUT_QUEUE, m_EventsMechanism, m_dwNotificationTimeout);

            //
            // Print document, using "printto" verb.
            //
            if (!ShellExecuteEx(&ShellExecInfo))
            {
                DWORD dwEC = GetLastError();
                m_Logger.Detail(SEV_ERR, 1, _T("ShellExecuteEx failed with ec=%ld."), dwEC);
                THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::Send_Spooler - ShellExecuteEx"));
            }

            //
            // Remember the moment, the fax has been sent.
            //
            DWORD dwTickCountWhenFaxSent = GetTickCount();

            DWORD dwAlreadyAssociatedJobs = 0;

            for(;;)
            {
                CFaxEventExPtr FaxEventExPtr(Listener.GetEvent());

                m_Logger.Detail(SEV_MSG, 5, _T("Got an event...\n%s"), FaxEventExPtr.Format().c_str());

                if (!FaxEventExPtr.IsValid())
                {
                    //
                    // Invalid event.
                    //
                    break;
                }

                //
                // We are registered only for OUT_QUEUE events.
                //
                _ASSERT(FaxEventExPtr->EventType == FAX_EVENT_TYPE_OUT_QUEUE);

                if (FaxEventExPtr->EventInfo.JobInfo.Type != FAX_JOB_EVENT_TYPE_ADDED)
                {
                    //
                    // Useless event - skip.
                    //
                    m_Logger.Detail(SEV_MSG, 5, _T("Useless event - skip."));
                    continue;
                }

                DWORDLONG dwlMessageID = FaxEventExPtr->EventInfo.JobInfo.dwlMessageId;

                //
                // Get full job information.
                //
                if (!FaxGetJobEx(FaxConnection, dwlMessageID, &pJob))
                {
                    DWORD dwEC = GetLastError();
                    m_Logger.Detail(SEV_ERR, 1, _T("FaxGetJobEx failed with ec=%ld."), dwEC);
                    THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::Send_Spooler - FaxGetJobEx"));
                }

                if (dwAlreadyAssociatedJobs == 0)
                {
                    //
                    // This is potentially the first job of our broadcast.
                    //
                    // @@@ Verify this is indeed our job
                    //
                    m_Logger.Detail(
                                    SEV_MSG,
                                    5,
                                    _T("Assuming the job to be the first of our broadcast (BroadcastID is %I64x)."),
                                    pJob->dwlBroadcastId
                                    );
        
                    //
                    // Set the broadcast ID.
                    //
                    m_dwlBroadcastID = pJob->dwlBroadcastId;
                }
                else if (m_dwlBroadcastID != pJob->dwlBroadcastId)
                {
                    //
                    // This job doesn't belong to our broadcast.
                    //
                    continue;
                }

                //
                // Associate the job with a recipient and update m_pSendMessages array.
                // For this, pass through the the recipients and compare name and fax number.
                //
                for (DWORD dwRecipientInd = 0; dwRecipientInd < m_dwRecipientsCount; ++dwRecipientInd)
                {
                    if (
                        pJob->lpctstrRecipientNumber                                                          &&
                        m_pRecipients[dwRecipientInd].lptstrFaxNumber                                         &&
                        pJob->lpctstrRecipientName                                                            &&
                        m_pRecipients[dwRecipientInd].lptstrName                                              &&
                        !_tcscmp(pJob->lpctstrRecipientNumber, m_pRecipients[dwRecipientInd].lptstrFaxNumber) &&
                        !_tcscmp(pJob->lpctstrRecipientName, m_pRecipients[dwRecipientInd].lptstrName)
                        )
                    {
                        //
                        // Recipient's number and name match the job
                        //
                        // Several recipients in the broadcast may have the same name and number, but each of them
                        // is represented by separate element of the m_pRecipients array.
                        // Thus, matching the name and the number is not enough.
                        // Check, whether the current recipient already has an associated message ID.
                        //
                        if (m_pSendMessages[dwRecipientInd].GetMessageID() == 0)
                        {
                            //
                            // No message ID is associated with this recipient yet.
                            //
                            m_pSendMessages[dwRecipientInd].SetMessageID(dwlMessageID);
                            ++dwAlreadyAssociatedJobs;

                            m_Logger.Detail(
                                            SEV_MSG,
                                            5,
                                            _T("Job 0x%I64x associated with recipient %s@%s. Remains %ld more recipient(s)."),
                                            dwlMessageID,
                                            m_pRecipients[dwRecipientInd].lptstrName,
                                            m_pRecipients[dwRecipientInd].lptstrFaxNumber,
                                            m_dwRecipientsCount - dwAlreadyAssociatedJobs
                                            );

                            break;
                        }
                        //
                        // else, continue the search
                        //
                    }
                }

                if (dwRecipientInd == m_dwRecipientsCount)
                {
                    //
                    // We get here if we've failed to associate the job with a recipient.
                    //
                    if (dwAlreadyAssociatedJobs == 0)
                    {
                        //
                        // This may be Ok - the job just doesn't belong to our broadcast.
                        //
                        m_Logger.Detail(SEV_MSG, 5, _T("Wrong assumption. The job doesn't belong to our broadcast."));
                    }
                    else
                    {
                        //
                        // The job does belong to our broadcast but for some reason cannot be associated with a recipient.
                        //
                        m_Logger.Detail(
                                        SEV_ERR,
                                        1,
                                        _T("Cannot associate a job (0x%I64x) with a recipient."),
                                        dwlMessageID
                                        );

                        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxMessage::Send_Spooler - cannot associate a job with a recipient"));
                    }
                }

                FaxFreeBuffer(pJob);
                pJob = NULL;

                if (dwAlreadyAssociatedJobs == m_dwRecipientsCount)
                {
                    //
                    // All recipients have associated jobs.
                    // Release the send tracking thread.
                    //
                    m_Logger.Detail(SEV_MSG, 5, _T("All recipients have associated jobs."));
                    Tracker.BeginTracking(MESSAGE_TYPE_SEND);
                    break;
                }

                //
                // Not all recipients have associated jobs.
                // Check whether we are still willing to wait.
                //
                DWORD dwCurrentTickCount = GetTickCount();
                if (dwCurrentTickCount - dwTickCountWhenFaxSent >= m_dwNotificationTimeout ||
                    dwCurrentTickCount <= dwTickCountWhenFaxSent
                    )
                {
                    m_Logger.Detail(SEV_ERR, 1, _T("Job was not added to the queue during %ld msec."), m_dwNotificationTimeout);
                    THROW_TEST_RUN_TIME_WIN32(ERROR_TIMEOUT, _T("CFaxMessage::Send_Spooler - job was not added to the queue"));
                }
                //
                // else, continue watching
                //
            }

            if (dwAlreadyAssociatedJobs != m_dwRecipientsCount)
            {
                //
                // We get here when there are no more events, but not all recipients have associated message ID yet.
                //
                m_Logger.Detail(SEV_ERR, 1, _T("Not all recipients has associated jobs."));
                THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxMessage::Send_Spooler - not all recipients has associated jobs"));
            }
        }
    }
    catch(Win32Err &e)
    {
        StoredException = e;
    }

    FaxFreeBuffer(pJob);

    //
    // Remove registry hack.
    //
    try
    {
        RemoveRegistryHack();
    }
    catch(Win32Err &e)
    {
        m_Logger.Detail(SEV_WRN, 1, _T("RemoveRegistryHack failed with ec=%ld."), e.error());
    }

    if (StoredException.error() != ERROR_SUCCESS)
    {
        //
        // Re-throw the exception, stored earlier.
        //
        throw StoredException;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::SetRegistryHack()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::SetRegistryHack"));

    if (m_tstrRegistryHackKeyName.empty())
    {
        CalculateRegistryHackKeyName();
    }
    
    //
    // Create (or open if already exists) the SendWizard registry hack key.
    // The key is automatically closed when ahkWzrdHack goes out of scope.
    //

    CAutoCloseRegHandle ahkWzrdHack;

    DWORD dwEC = ERROR_SUCCESS;

    dwEC = RegCreateKey(HKEY_LOCAL_MACHINE, m_tstrRegistryHackKeyName.c_str(), &ahkWzrdHack);
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(
                        SEV_ERR,
                        1,
                        _T("Failed to create HKEY_LOCAL_MACHINE\\%s registry key (ec=%ld)."),
                        m_tstrRegistryHackKeyName.c_str(),
                        dwEC
                        );

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::SetRegistryHack - RegCreateKey"));
    }

    //
    // Set cover page name.
    //
    LPCTSTR lpctstrCoverPage = m_pCoverPageInfo ? m_pCoverPageInfo->lptstrCoverPageFileName : _T("");
    dwEC = RegSetValueEx(
                         ahkWzrdHack,
                         REGVAL_FAKECOVERPAGE,
                         0,
                         REG_SZ,
                         (CONST BYTE *)lpctstrCoverPage,
                         (_tcslen(lpctstrCoverPage) + 1) * sizeof(TCHAR) 
                         );
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(
                        SEV_ERR,
                        1,
                        _T("Failed to set %s registry value (ec=%ld)."),
                        REGVAL_FAKECOVERPAGE,
                        dwEC
                        );

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::SetRegistryHack - RegSetValueEx"));
    }

    //
    // Set whether the cover page is server based.
    //
    const DWORD dwServerBased = m_pCoverPageInfo ? m_pCoverPageInfo->bServerBased : 0;
    dwEC = RegSetValueEx(
                         ahkWzrdHack,
                         REGVAL_FAKESERVERBASED,
                         0,
                         REG_DWORD,
                         (CONST BYTE *)&dwServerBased,
                         sizeof(dwServerBased)
                         );
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(
                        SEV_ERR,
                        1,
                        _T("Failed to set %s registry value (ec=%ld)."),
                        REGVAL_FAKESERVERBASED,
                        dwEC
                        );

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::SetRegistryHack - RegSetValueEx"));
    }

    //
    // Set tests count to 1
    //
    const DWORD dwTestsCount = 1;
    dwEC = RegSetValueEx(
                         ahkWzrdHack,
                         REGVAL_FAKETESTSCOUNT,
                         0,
                         REG_DWORD,
                         (CONST BYTE *)&dwTestsCount,
                         sizeof(dwTestsCount)
                         );
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(
                        SEV_ERR,
                        1,
                        _T("Failed to set %s registry value (ec=%ld)."),
                        REGVAL_FAKETESTSCOUNT,
                        dwEC
                        );

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::SetRegistryHack - RegSetValueEx"));
    }

    //
    // Calculate the buffer size for recipients multistring.
    //
    DWORD dwMultiStringBufferSize = 0;
    for (DWORD dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        dwMultiStringBufferSize += _tcslen(m_pRecipients[dwInd].lptstrName) + 1;
        dwMultiStringBufferSize += _tcslen(m_pRecipients[dwInd].lptstrFaxNumber) + 1;
    }
    dwMultiStringBufferSize += 1;
    dwMultiStringBufferSize *= sizeof(TCHAR);

    //
    // Allocate memory for multistring.
    // The memory is released automatically when apVersionInfo goes out of scope.
    //
    aaptr<BYTE> aapMultiStringBuffer(new BYTE[dwMultiStringBufferSize]);
    _ASSERT(aapMultiStringBuffer);

    //
    // Combine recipients multistring.
    //
    LPTSTR lptstrMultiStringCurrPos = reinterpret_cast<LPTSTR>(aapMultiStringBuffer.get());
    for (dwInd = 0; dwInd < m_dwRecipientsCount; ++dwInd)
    {
        DWORD dwRet = _stprintf(
                                lptstrMultiStringCurrPos,
                                TEXT("%s%c%s%c"),
                                m_pRecipients[dwInd].lptstrName,
                                _T('\0'),
                                m_pRecipients[dwInd].lptstrFaxNumber,
                                _T('\0')
                                );

        lptstrMultiStringCurrPos += dwRet;
    }
    
    //
    // Set recipients.
    //
    dwEC = RegSetValueEx(
                         ahkWzrdHack,
                         REGVAL_FAKERECIPIENT,
                         0,
                         REG_MULTI_SZ,
                         aapMultiStringBuffer,
                         dwMultiStringBufferSize
                         );
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(
                        SEV_ERR,
                        1,
                        _T("Failed to set %s registry value (ec=%ld)."),
                        REGVAL_FAKERECIPIENT,
                        dwEC
                        );

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::SetRegistryHack - RegSetValueEx"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::RemoveRegistryHack()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::RemoveRegistryHack"));

    DWORD dwEC = RegDeleteKey(HKEY_LOCAL_MACHINE, m_tstrRegistryHackKeyName.c_str());
    if (dwEC != ERROR_SUCCESS && dwEC != ERROR_FILE_NOT_FOUND)
    {
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::RemoveRegistryHack - RegDeleteKey"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CFaxMessage::CalculateRegistryHackKeyName()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CFaxMessage::CalculateRegistryHackKeyName"));

    aptr<PSID> apCurrentUserSid;

    DWORD dwEC = ERROR_SUCCESS;

    //
    // Get SID of the current user.
    // The memory is allocated by the function and aoutomatically released when apCurrentUserSid goes out of scope.
    //
    dwEC = GetCurrentUserSid((PBYTE*)&apCurrentUserSid);
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(SEV_ERR, 1, _T("GetCurrentUserSid failed with ec=%ld"), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::CalculateRegistryHackKeyName - GetCurrentUserSid"));
    }

    aaptr<TCHAR> aapKeyName;
    //
    // Format the registry hack key name.
    // The memory is allocated by the function and automatically released when aapKeyName goes out of scope.
    //
    dwEC = FormatUserKeyPath(apCurrentUserSid, REGKEY_WZRDHACK, &aapKeyName);
    if (dwEC != ERROR_SUCCESS)
    {
        m_Logger.Detail(SEV_ERR, 1, _T("FormatUserKeyPath failed with ec=%ld"), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxMessage::CalculateRegistryHackKeyName - FormatUserKeyPath"));
    }
    
    //
    // Store the key name.
    //
    m_tstrRegistryHackKeyName = aapKeyName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxlistener.cpp ===
#include <windows.h>
#include <crtdbg.h>
#include <fxsapip.h>
#include <testruntimeerr.h>
#include "CFaxListener.h"
#include "CFaxConnection.h"
#include "Util.h"



#define FAX_LISTENER_WINDOW_NAME  _T("Fax Listener Hidden Window")
#define FAX_LISTENER_WINDOW_CLASS _T("FaxListenerWindowClass")
#define WM_FAX_EVENT              WM_USER
#define WM_STOP_WAITING           WM_USER + 1



//-----------------------------------------------------------------------------------------------------------------------------------------
//
// Initialize CFaxListener class.
//
const CFaxListener::CFaxListenerResources CFaxListener::Resources;



//-----------------------------------------------------------------------------------------------------------------------------------------
// Constructor.
//
// Parameters:      [IN]    tstrServerName      Specifies the name of the server, the listener should register on.
//                  [IN]    dwEventTypes        Specifies the event types, the listener should register for.
//                  [IN]    EventsMechanism     Specifies the notifications mechanism, the listener should use.
//                  [IN]    dwTimeout           Specifies the maximal amount of time, the listener should wait for new event.
//                  [IN]    bDelayRegistration  Specifies whether the listener should delay its registration for events.
//                                              The listener must be registered by the thread that uses it. This is because the
//                                              thread can only get messages to windows, it owns.
//                                              When the thread that uses the listener (calls GetEvent()) is not the same thread that
//                                              creates the listener, bDelayRegistration may be useful.
//
// If error occurs, Win32Err exception is thrown.
//
CFaxListener::CFaxListener(
                           const tstring         &tstrServerName,
                           DWORD                 dwEventTypes,
                           ENUM_EVENTS_MECHANISM EventsMechanism,
                           DWORD                 dwTimeout,
                           bool                  bDelayRegistration
                           )
: m_dwCreatingThreadID(0),
  m_tstrServerName(tstrServerName),
  m_dwEventTypes(dwEventTypes),
  m_EventsMechanism(EventsMechanism),
  m_dwTimeout(dwTimeout),
  m_hCompletionPort(NULL),
  m_hWindow(NULL),
  m_hServerEvents(NULL)
{
    if (m_EventsMechanism == EVENTS_MECHANISM_DEFAULT)
    {
        m_EventsMechanism = IsWindowsXP() ? EVENTS_MECHANISM_COMPLETION_PORT : EVENTS_MECHANISM_WINDOW_MESSAGES;
    }

    if (bDelayRegistration)
    {
        //
        // Store the creating thread ID. We need it to insure a proper use of bDelayRegistration flag.
        //
        m_dwCreatingThreadID = GetCurrentThreadId();
    }
    else
    {
        try
        {
            Register();
        }
        catch(Win32Err &)
        {
            Unregister();
            throw;
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Constructor.
//
// Parameters:      [IN]    hFaxServer          Specifies the handle of existing fax connection, the listener should use to register.
//                  [IN]    dwEventTypes        Specifies the event types, the listener should register for.
//                  [IN]    EventsMechanism     Specifies the notifications mechanism, the listener should use.
//                  [IN]    dwTimeout           Specifies the maximal amount of time, the listener should wait for new event.
//
// If error occurs, Win32Err exception is thrown.
//
CFaxListener::CFaxListener(
                           HANDLE                hFaxServer,
                           DWORD                 dwEventTypes,
                           ENUM_EVENTS_MECHANISM EventsMechanism,
                           DWORD                 dwTimeout
                           )
: m_dwCreatingThreadID(0),
  m_dwEventTypes(dwEventTypes),
  m_EventsMechanism(EventsMechanism),
  m_dwTimeout(dwTimeout),
  m_hCompletionPort(NULL),
  m_hWindow(NULL),
  m_hServerEvents(NULL)
{
    if (m_EventsMechanism == EVENTS_MECHANISM_DEFAULT)
    {
        m_EventsMechanism = IsWindowsXP() ? EVENTS_MECHANISM_COMPLETION_PORT : EVENTS_MECHANISM_WINDOW_MESSAGES;
    }

    try
    {
        Register(hFaxServer);
    }
    catch(Win32Err &)
    {
        Unregister();
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Destructor.
//
// If error occurs, Win32Err exception is thrown.
//
CFaxListener::~CFaxListener()
{
    try
    {
        Unregister();
    }
    catch (...)
    {
        if (!uncaught_exception())
        {
            throw;
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Registers the listener. Should only be called in the following situation:
// 1) One thread creates the listener, requesting delayed registration.
// 2) Another thread calls Register() and uses the listener.
//
// Parameters:      None.
//
// Return value:    None.
//
// If error occurs, Win32Err exception is thrown.
//
void CFaxListener::Register()
{
    CS CriticalSectionLock(m_CriticalSection);

    //
    // This function should be called only when the listener is create by one thread
    // and registered by another thread.
    //
    _ASSERT(m_dwCreatingThreadID != GetCurrentThreadId());

    if (m_hServerEvents)
    {
        _ASSERT(false);
        return;
    }

    //
    // Create a fax connection. Automatically disconnects when goes out of scope.
    //
    CFaxConnection FaxConnection(m_tstrServerName);

    //
    // Register.
    //
    Register(FaxConnection);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Registers the listener.
//
// Parameters:      [IN]    hFaxServer  Specifies the handle of existing fax connection that should be used to register.
//
// Return value:    None.
//
// If error occurs, Win32Err exception is thrown.
//
void CFaxListener::Register(HANDLE hFaxServer)
{
    CS CriticalSectionLock(m_CriticalSection);

    if (m_hServerEvents)
    {
        _ASSERT(false);
        return;
    }

    if (!hFaxServer)
    {
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_HANDLE, _T("CFaxListener::Register - invalid hFaxServer"));
    }
        
    _ASSERT(!m_hCompletionPort && !m_hWindow && !m_hServerEvents);
    
    switch (m_EventsMechanism)
    {
    case EVENTS_MECHANISM_COMPLETION_PORT:

        //
        // Create completion port.
        //
        m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
        if (!m_hCompletionPort) 
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::Register - CreateIoCompletionPort"));
        }

        break;

    case EVENTS_MECHANISM_WINDOW_MESSAGES:
    {
        //
        // Get the module handle.
        //
        HMODULE  hModule = GetModuleHandle(NULL);
        if (!hModule)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::Register - GetModuleHandle"));
        }

        //
        // Create a window.
        //
        m_hWindow = CreateWindow(
                                 FAX_LISTENER_WINDOW_CLASS,
                                 FAX_LISTENER_WINDOW_NAME,
                                 0,
                                 CW_USEDEFAULT,
                                 0,
                                 CW_USEDEFAULT,
                                 0,
                                 NULL,
                                 NULL,
                                 hModule,
                                 NULL
                                 );
        if(!m_hWindow)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::Register - CreateWindow"));
        }

        break;
    }

    default:

        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxListener::Register - Invalid m_EventsMechanism"));
    }

    //
    // Register for events.
    //
    if (!FaxRegisterForServerEvents(
                                    hFaxServer,
                                    m_dwEventTypes,
                                    m_hCompletionPort,
                                    WM_FAX_EVENT,
                                    m_hWindow,
                                    WM_FAX_EVENT,
                                    &m_hServerEvents
                                    ))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::Register - FaxRegisterForServerEvents"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Unregisters the listener.
//
// Parameters:      None.
//
// Return value:    None.
//
// If error occurs, Win32Err exception is thrown.
//
void CFaxListener::Unregister()
{
    CS CriticalSectionLock(m_CriticalSection);

    if (!m_hServerEvents)
    {
        return;
    }

    FaxUnregisterForServerEvents(m_hServerEvents);
    m_hServerEvents = NULL;

    if (m_hCompletionPort)
    {
        PFAX_EVENT_EX pFaxEventEx   = NULL;
        DWORD         dwBytes       = 0;
        ULONG_PTR     CompletionKey = 0;

        //
        // Deallocate events structures.
        //
        while(GetQueuedCompletionStatus(
                                        m_hCompletionPort, 
                                        &dwBytes, 
                                        &CompletionKey, 
                                        (LPOVERLAPPED *)&pFaxEventEx, 
                                        0
                                        ))
        {
            if (WM_FAX_EVENT == CompletionKey)
            {
                FaxFreeBuffer(pFaxEventEx);
            }
        }

        //
        // Destroy the completion port.
        //
        CloseHandle(m_hCompletionPort);
        m_hCompletionPort = NULL;
    }

    if (m_hWindow)
    {

        MSG Message = {0};

        //
        // Deallocate events structures.
        //
        while (PeekMessage(&Message, m_hWindow, WM_FAX_EVENT, WM_FAX_EVENT, PM_REMOVE))
        {
            FaxFreeBuffer(reinterpret_cast<PFAX_EVENT_EX>(Message.lParam));
        }

        //
        // Destroy the window.
        //
        DestroyWindow(m_hWindow);
        m_hWindow = NULL;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Checks whether the listener is registered.
//
// Parameters:      None.
//
// Return value:    true if the listener is registered, false otherwise.
//
// If error occurs, Win32Err exception is thrown.
//
bool CFaxListener::IsRegistered()
{
    CS CriticalSectionLock(m_CriticalSection);
    return NULL != m_hServerEvents;
}
    
//-----------------------------------------------------------------------------------------------------------------------------------------
// Waits for a notification.
//
// Parameters:      [IN]    hFaxServer  Specifies the handle of existing fax connection that should be used to register.
//
// Return value:    Pointer to FAX_EVENT_EX structure.
//                  If no new event arrived during specified timeout or the waiting aborted by calling StopWaitong(),
//                  the return value is NULL.        
//
// If error occurs, Win32Err exception is thrown.
//
PFAX_EVENT_EX CFaxListener::GetEvent()
{
    if (!m_hServerEvents)
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("CFaxListener::GetEvent - Not registered for events"));
    }
    
    PFAX_EVENT_EX pFaxEventEx = NULL;
    DWORD         dwKey       = 0;

    switch (m_EventsMechanism)
    {
    case EVENTS_MECHANISM_COMPLETION_PORT:

        {
            _ASSERT(m_hCompletionPort && !m_hWindow);

            DWORD     dwBytes       = 0;
            ULONG_PTR CompletionKey = 0;

            if (!GetQueuedCompletionStatus(
                                           m_hCompletionPort, 
                                           &dwBytes, 
                                           &CompletionKey, 
                                           (LPOVERLAPPED *)&pFaxEventEx, 
                                           m_dwTimeout
                                           ))
            {
                DWORD dwEC = GetLastError();
                if (dwEC == WAIT_TIMEOUT)
                {
                    return NULL;
                }
                else
                {
                    THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CFaxListener::GetEvent - GetQueuedCompletionStatus"));
                }
            }

            dwKey = static_cast<DWORD>(CompletionKey);
        }

        break;

    case EVENTS_MECHANISM_WINDOW_MESSAGES:

        {
            _ASSERT(!m_hCompletionPort && m_hWindow);

            MSG Message = {0};

            BOOL bRet = GetMessage(&Message, m_hWindow, WM_FAX_EVENT, WM_STOP_WAITING);

            //
            // We never should get WM_QUIT.
            //
            _ASSERT(bRet);

            if (bRet == -1)
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::GetEvent - GetMessage"));
            }

            pFaxEventEx = reinterpret_cast<PFAX_EVENT_EX>(Message.lParam);

            dwKey = static_cast<DWORD>(Message.message);
        }

        break;

    default:

        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxListener::GetEvent - Invalid m_EventsMechanism"));
    }

    switch (dwKey)
    {
        case WM_FAX_EVENT:
            //
            // Fax notification.
            // Check the completion packet validity.
            //
            _ASSERT(_CrtIsValidPointer(pFaxEventEx, sizeof(FAX_EVENT_EX), TRUE));
            break;

        case WM_STOP_WAITING:
            //
            // StopWaiting() called
            //
            _ASSERT(!pFaxEventEx);
            break;

        default:
            //
            // Unknown key.
            //
            _ASSERT(false);
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxListener::GetEvent - invalid completion key or window message."));
    }

    return pFaxEventEx;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Aborts waiting for events (causes GetEvent() to return immediately) and unregisters the listener.
//
// Parameters:      None.
//
// Return value:    None.
//
// If error occurs, Win32Err exception is thrown.
//
void CFaxListener::StopWaiting()
{
    CS CriticalSectionLock(m_CriticalSection);

    if (!m_hServerEvents)
    {
        return;
    }

    switch (m_EventsMechanism)
    {
    case EVENTS_MECHANISM_COMPLETION_PORT:

        _ASSERT(m_hCompletionPort && !m_hWindow);

        if (!PostQueuedCompletionStatus(
                                        m_hCompletionPort,
                                        0,
                                        WM_STOP_WAITING,
                                        (LPOVERLAPPED) NULL
                                        ))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::StopWaiting - PostQueuedCompletionStatus"));
        }

        break;

    case EVENTS_MECHANISM_WINDOW_MESSAGES:

        _ASSERT(!m_hCompletionPort && m_hWindow);

        if (!PostMessage(m_hWindow, WM_STOP_WAITING, 0 ,0))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::StopWaiting - PostMessage"));
        }

        break;

    default:

        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("CFaxListener::StopWaiting - invalid m_EventsMechanism"));
    }

    Unregister();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Constructor.
//
// Parameters:      None.
//
// If error occurs, Win32Err exception is thrown.
//
CFaxListener::CFaxListenerResources::CFaxListenerResources()
{
    //
    // Get the module handle;
    //
    HMODULE  hModule = GetModuleHandle(NULL);
    if (!hModule)
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::CFaxListenerResources::CFaxListenerResources - GetModuleHandle"));
    }

    //
    // Initialize WNDCLASS structure.
    //
    WNDCLASS WindowClass = {0};
    WindowClass.style         = CS_HREDRAW | CS_VREDRAW;
    WindowClass.lpfnWndProc   = DefWindowProc;
    WindowClass.hInstance     = hModule;
    WindowClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    WindowClass.hbrBackground = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    WindowClass.lpszClassName = FAX_LISTENER_WINDOW_CLASS;

    //
    // Register window class.
    //
    if(!RegisterClass(&WindowClass))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFaxListener::CFaxListenerResources::CFaxListenerResources - RegisterClass"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Destructor.
//
CFaxListener::CFaxListenerResources::~CFaxListenerResources()
{
    //
    // Get the module handle;
    //
    HMODULE  hModule = GetModuleHandle(NULL);

    if (hModule)
    {
        UnregisterClass(FAX_LISTENER_WINDOW_CLASS, hModule);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfileversion.cpp ===
#include "CFileVersion.h"
#include <testruntimeerr.h>
#include <ptrs.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CFileVersion::CFileVersion(const tstring &tstrFileName)
: m_wMajorVersion(0),
  m_wMinorVersion(0),
  m_wMajorBuildNumber(0),
  m_wMinorBuildNumber(0),
  m_bChecked(false),
  m_bValid(false)
{
    if (tstrFileName.empty())
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CFileVersion::CFileVersion - invalid tstrFileName"));
    }

    LPTSTR lptstrFileName = const_cast<LPTSTR>(tstrFileName.c_str());
    DWORD  dwHandle       = 0;

    //
    // Get required buffer size.
    //
    DWORD  dwVersionSize  = GetFileVersionInfoSize(lptstrFileName, &dwHandle);

    if (dwVersionSize == 0)
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFileVersion::CFileVersion - GetFileVersionInfoSize"));
    }
    
    //
    // Allocate memory.
    // The memory is released automatically when aapVersionInfo goes out of scope.
    //
    aaptr<BYTE> aapVersionInfo(new BYTE[dwVersionSize]);
    
    if (!GetFileVersionInfo(lptstrFileName, 0, dwVersionSize, aapVersionInfo))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFileVersion::CFileVersion - GetFileVersionInfo"));
    }

    VS_FIXEDFILEINFO *pFixedFileInfo;
    UINT              uVersionDataLength;

    //
    // Query the required version structure (VS_FIXEDFILEINFO).
    //
    if (!VerQueryValue (aapVersionInfo, _T("\\"), (LPVOID *)&pFixedFileInfo, &uVersionDataLength))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CFileVersion::CFileVersion - VerQueryValue"));
    }

    m_bChecked          = (pFixedFileInfo->dwFileFlags & VS_FF_DEBUG);
    m_wMajorVersion     = HIWORD(pFixedFileInfo->dwFileVersionMS);
    m_wMinorVersion     = LOWORD(pFixedFileInfo->dwFileVersionMS);
    m_wMajorBuildNumber = HIWORD(pFixedFileInfo->dwFileVersionLS);
    m_wMinorBuildNumber = LOWORD(pFixedFileInfo->dwFileVersionLS);
    
    m_bValid = true;
}
    
    

//-----------------------------------------------------------------------------------------------------------------------------------------
CFileVersion::CFileVersion()
: m_wMajorVersion(0),
  m_wMinorVersion(0),
  m_wMajorBuildNumber(0),
  m_wMinorBuildNumber(0),
  m_bChecked(false),
  m_bValid(false)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFileVersion::operator==(const CFileVersion &FileVersion) const
{
    return (m_bValid                                               &&
            FileVersion.m_bValid                                   &&
            m_wMajorVersion     == FileVersion.m_wMajorVersion     &&
            m_wMinorVersion     == FileVersion.m_wMinorVersion     &&
            m_wMajorBuildNumber == FileVersion.m_wMajorBuildNumber &&
            m_wMinorBuildNumber == FileVersion.m_wMinorBuildNumber &&
            m_bChecked          == FileVersion.m_bChecked
            );
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring CFileVersion::Format() const
{
    TCHAR tszBuffer[64];

    _sntprintf(
               tszBuffer,
               ARRAY_SIZE(tszBuffer),
               _T("%d.%d.%d.%d.%s"),
               m_wMajorVersion,
               m_wMinorVersion,
               m_wMajorBuildNumber,
               m_wMinorBuildNumber,
               m_bChecked ? _T("dbg") : _T("shp")
               );

    return tszBuffer;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFileVersion::IsValid() const
{
    return m_bValid;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
WORD CFileVersion::GetMajorBuildNumber() const
{
    return m_wMajorBuildNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfileversion.h ===
#ifndef __C_FILE_VERSION_H__
#define __C_FILE_VERSION_H__



#include <tstring.h>



class CFileVersion {

public:

    CFileVersion(const tstring &tstrFileName);

    CFileVersion();

    bool operator==(const CFileVersion &FileVersion) const;

    tstring Format() const;

    bool IsValid() const;

    WORD GetMajorBuildNumber() const;

private:

    WORD m_wMajorVersion;
    WORD m_wMinorVersion;
    WORD m_wMajorBuildNumber;
    WORD m_wMinorBuildNumber;
    bool m_bChecked;
    bool m_bValid;
};



#endif // #ifndef __C_FILE_VERSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cfaxlistener.h ===
#ifndef __C_FAX_LISTENER__
#define __C_FAX_LISTENER__



#include <windows.h>
#include <fxsapip.h>
#include <tstring.h>
#include <cs.h>



#define DEFAULT_NOTIFICATION_TIMEOUT (3 * 60 * 1000)



typedef enum {
    EVENTS_MECHANISM_COMPLETION_PORT = 1,
    EVENTS_MECHANISM_WINDOW_MESSAGES,
    EVENTS_MECHANISM_COM,
    EVENTS_MECHANISM_DEFAULT
} ENUM_EVENTS_MECHANISM;



class CFaxListener {

public:

    CFaxListener(
                 const tstring         &tstrServerName,
                 DWORD                 dwEventTypes,
                 ENUM_EVENTS_MECHANISM EventsMechanism,
                 DWORD                 dwTimeout = INFINITE,
                 bool                  bDelayRegistration = false
                 );

    CFaxListener(
                 HANDLE                hFaxServer,
                 DWORD                 dwEventTypes,
                 ENUM_EVENTS_MECHANISM EventsMechanism,
                 DWORD                 dwTimeout = INFINITE
                 );

    ~CFaxListener();

    void Register();

    bool IsRegistered();
    
    PFAX_EVENT_EX GetEvent();

    void StopWaiting();

private:

    void Unregister();

    void Register(HANDLE hFaxServer);

    class CFaxListenerResources {
    
    public:

        CFaxListenerResources();
        
        ~CFaxListenerResources();
    };

    static const CFaxListenerResources Resources;
    
    CCriticalSection      m_CriticalSection;
    DWORD                 m_dwCreatingThreadID;
    tstring               m_tstrServerName;
    DWORD                 m_dwEventTypes;
    ENUM_EVENTS_MECHANISM m_EventsMechanism;
    DWORD                 m_dwTimeout;
    HANDLE                m_hCompletionPort;
    HWND                  m_hWindow;
    HANDLE                m_hServerEvents;
};



#endif // #ifndef __C_FAX_LISTENER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cmessageinfo.cpp ===
#include "CMessageInfo.h"
#include <fxsapip.h>
#include "Util.h"




//-----------------------------------------------------------------------------------------------------------------------------------------
static const TRANSITION aSendTransitions[] = {
   TRANSITION(TWO_32_AS_64(0            , 0                   ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_DIALING       )),
   TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_DIALING       ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_TRANSMITTING  )),
   TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_TRANSMITTING  ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_TRANSMITTING  )),
   TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_TRANSMITTING  ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_CALL_COMPLETED)),
   TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_CALL_COMPLETED), TWO_32_AS_64(JS_COMPLETED , JS_EX_CALL_COMPLETED))
};



const CTransitionMap CMessageInfo::m_ValidSendTransitions(aSendTransitions, ARRAY_SIZE(aSendTransitions));



//-----------------------------------------------------------------------------------------------------------------------------------------
static const TRANSITION aReceiveTransitions[] = {
    TRANSITION(TWO_32_AS_64(0            , 0                   ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_ANSWERED      )),
    TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_ANSWERED      ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_RECEIVING     )),
    TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_RECEIVING     ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_RECEIVING     )),
    TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_RECEIVING     ), TWO_32_AS_64(JS_INPROGRESS, JS_EX_CALL_COMPLETED)),
    TRANSITION(TWO_32_AS_64(JS_INPROGRESS, JS_EX_CALL_COMPLETED), TWO_32_AS_64(JS_ROUTING,    JS_EX_CALL_COMPLETED))
};



const CTransitionMap CMessageInfo::m_ValidReceiveTransitions(aReceiveTransitions, ARRAY_SIZE(aReceiveTransitions));



//-----------------------------------------------------------------------------------------------------------------------------------------
CMessageInfo::CMessageInfo()
: m_dwlMessageID(0), m_MessageType(MESSAGE_TYPE_UNKNOWN), m_dwQueueStatus(0), m_dwExtendedStatus(0)
{
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
void CMessageInfo::ResetAll()
{
    m_dwlMessageID = 0;
    m_dwQueueStatus = 0;
    m_dwExtendedStatus = 0;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CMessageInfo::SetMessageID(DWORDLONG dwlMessageID)
{
    m_dwlMessageID = dwlMessageID;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORDLONG CMessageInfo::GetMessageID() const
{
    return m_dwlMessageID;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CMessageInfo::SetMessageType(ENUM_MESSAGE_TYPE MessageType)
{
    m_MessageType = MessageType;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD CMessageInfo::GetMessageQueueStatus() const
{
    return m_dwQueueStatus;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD CMessageInfo::GetMessageExtendedStatus() const
{
    return m_dwExtendedStatus;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CMessageInfo::SetState(DWORD dwQueueStatus, DWORD dwExtendedStatus)
{
    //
    // Combine dwQueueStatus and dwExtendedStatus into single 64 bit variable
    //
    DWORDLONG dwlCurrentState = TWO_32_AS_64(m_dwQueueStatus, m_dwExtendedStatus);
    DWORDLONG dwlNewState     = TWO_32_AS_64(dwQueueStatus, dwExtendedStatus);

    //
    // Check the transition validity.
    //
    switch (m_MessageType)
    {
    case MESSAGE_TYPE_SEND:
        
        if (!CMessageInfo::m_ValidSendTransitions.IsValidTransition(dwlCurrentState, dwlNewState))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CMessageInfo::SetState - invalid send transition"));
        }
        break;
    
    case MESSAGE_TYPE_RECEIVE:
    
        if (!CMessageInfo::m_ValidReceiveTransitions.IsValidTransition(dwlCurrentState, dwlNewState))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CMessageInfo::SetState - invalid receive transition"));
        }
        break;

    default:

        _ASSERT(false);
        return;
    }

    //
    // The transition is valid - set new state.
    //
    m_dwQueueStatus    = dwQueueStatus;
    m_dwExtendedStatus = dwExtendedStatus;
}



bool CMessageInfo::IsInFinalState() const
{
    DWORDLONG dwlState = TWO_32_AS_64(m_dwQueueStatus, m_dwExtendedStatus);

    switch (m_MessageType)
    {
    case MESSAGE_TYPE_SEND:

        return CMessageInfo::m_ValidSendTransitions.IsFinalState(dwlState);

    case MESSAGE_TYPE_RECEIVE:

        return CMessageInfo::m_ValidReceiveTransitions.IsFinalState(dwlState);

    default:

        _ASSERT(false);
        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cpersonalinfo.h ===
#ifndef __C_PERSONAL_INFO_H__
#define __C_PERSONAL_INFO_H__



#include <windows.h>
#include <fxsapip.h>
#include <tstring.h>


class CPersonalInfo {

public:

    CPersonalInfo(const tstring &tstrName = _T("RecipientName"), const tstring &tstrNumber = _T(""));

    void SetName(const tstring tstrName);
    
    void SetNumber(const tstring tstrNumber);

    void FillPersonalProfile(PFAX_PERSONAL_PROFILE pPersonalProfile) const;

    PFAX_PERSONAL_PROFILE CreatePersonalProfile() const;

    static void FreePersonalProfile(PFAX_PERSONAL_PROFILE pPersonalProfile, int iProfilesCount = 1);

private:

    tstring m_tstrName;
    tstring m_tstrNumber;
};



#endif // #ifndef __C_PERSONAL_INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cpersonalinfo.cpp ===
#include "CPersonalInfo.h"
#include <crtdbg.h>
#include <testruntimeerr.h>
#include <StringUtils.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
CPersonalInfo::CPersonalInfo(const tstring &tstrName, const tstring &tstrNumber)
: m_tstrName(tstrName), m_tstrNumber(tstrNumber)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CPersonalInfo::SetName(const tstring tstrName)
{
    m_tstrName = tstrName;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CPersonalInfo::SetNumber(const tstring tstrNumber)
{
    m_tstrNumber = tstrNumber;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CPersonalInfo::FillPersonalProfile(PFAX_PERSONAL_PROFILE pPersonalProfile) const
{
    if (!pPersonalProfile)
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CCoverPageInfo::FillCoverPageInfoEx - bad pPersonalProfile"));
    }

    ZeroMemory(pPersonalProfile, sizeof(FAX_PERSONAL_PROFILE));
    pPersonalProfile->dwSizeOfStruct  = sizeof(FAX_PERSONAL_PROFILE);
    pPersonalProfile->lptstrName      = DupString(m_tstrName.c_str());
    pPersonalProfile->lptstrFaxNumber = DupString(m_tstrNumber.c_str());
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline PFAX_PERSONAL_PROFILE CPersonalInfo::CreatePersonalProfile() const
{
    PFAX_PERSONAL_PROFILE pPersonalProfile = new FAX_PERSONAL_PROFILE;
    _ASSERT(pPersonalProfile);

    try
    {
        FillPersonalProfile(pPersonalProfile);
    }
    catch(Win32Err &)
    {
        CPersonalInfo::FreePersonalProfile(pPersonalProfile);
        throw;
    }

    return pPersonalProfile;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CPersonalInfo::FreePersonalProfile(PFAX_PERSONAL_PROFILE pPersonalProfile, int iProfilesCount)
{
    if (pPersonalProfile)
    {
        for (int i = 0; i < iProfilesCount; ++i)
        {
            delete pPersonalProfile[i].lptstrName;
            delete pPersonalProfile[i].lptstrFaxNumber;
            delete pPersonalProfile[i].lptstrCompany;
            delete pPersonalProfile[i].lptstrStreetAddress;
            delete pPersonalProfile[i].lptstrCity;
            delete pPersonalProfile[i].lptstrState;
            delete pPersonalProfile[i].lptstrZip;
            delete pPersonalProfile[i].lptstrCountry;
            delete pPersonalProfile[i].lptstrTitle;
            delete pPersonalProfile[i].lptstrDepartment;
            delete pPersonalProfile[i].lptstrOfficeLocation;
            delete pPersonalProfile[i].lptstrHomePhone;
            delete pPersonalProfile[i].lptstrOfficePhone;
            delete pPersonalProfile[i].lptstrEmail;
            delete pPersonalProfile[i].lptstrBillingCode;
            delete pPersonalProfile[i].lptstrTSID;
        }

        delete[] pPersonalProfile;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\creportgeneralinfo.h ===
#ifndef __C_REPORT_GENERAL_INFO_H__
#define __C_REPORT_GENERAL_INFO_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CReportGeneralInfo test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case adds to the suite log general information: OS version,
    logged on user, fax version.


    **************************************
    Test case specific INI file parameters
    **************************************

    No test case specific parameters.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"



class CReportGeneralInfo : public CNotReportedTestCase {

public:

    CReportGeneralInfo(
                       const tstring &tstrName,
                       const tstring &tstrDescription,
                       CLogger       &Logger,
                       int           iRunsCount,
                       int           iDeepness
                       );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    void ReportOSInfo() const;

    void ReportLoggedOnUser() const;

    void ReportFaxVersion() const;
};



DEFINE_TEST_FACTORY(CReportGeneralInfo);



#endif // #ifndef __C_REPORT_GENERAL_INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\csendandreceive.h ===
#ifndef __C_SEND_AND_RECEIVE_H__
#define  __C_SEND_AND_RECEIVE_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CSendAndReceive test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case allows to send a fax with a variety of parameters and track
    the send/receive process.


    **************************************
    Test case specific INI file parameters
    **************************************

    CoverPage = <cover page file name>
        Optional. Eihter a cover page or a document must be specified.
        Defines a coverpage to be used to send a fax. If not specified,
        no cover page is used.

    ServerBasedCoverPage = <1/0>
        Mandatory if CoverPage parameter defined. Ignored if no cover page
        defined.
        Specifies whether the cover page is server or client based ("personal").
        
    Document = <document file name>
        Optional. Eihter a cover page or a document must be specified.
        Defines a document to be used to send a fax. If not specified,
        no document is used.

    Broadcast - <1/0>
        Mandatory.
        Specifies whether the fax should be sent to single or multiple
        recipients.

    SendMechanism = <number>
        Mandatory.
        Specifies a sending machanism to be used.

        Currently supported mechanisms are:
            SEND_MECHANISM_API     = 1
            SEND_MECHANISM_SPOOLER = 2

    NotificationTimeoutFactor = <number>
        Optional.
        Specifies the factor, that should be applied to the maximal amount of
        time, allowed to elapse between two subsequent notifications in a single
        fax transmission, which is specified in by SendAndReceiveSetup test case.
        If not specified, the default value 1 (no factor) is used.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"
#include "CCoverpageInfo.h"
#include "CFaxMessage.h"



class CSendAndReceive : public CTestCase {

public:

    CSendAndReceive(
                    const tstring &tstrName,
                    const tstring &tstrDescription,
                    CLogger       &Logger,
                    int           iRunsCount,
                    int           iDeepness
                    );

    ~CSendAndReceive();

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    CCoverPageInfo       *m_pCoverPage;
    tstring               m_tstrDocument;
    bool                  m_bBroadcast;
    ENUM_SEND_MECHANISM   m_SendMechanism;
    ENUM_EVENTS_MECHANISM m_EventsMechanism;
    double                m_dNotificationTimeoutFactor;
};



DEFINE_TEST_FACTORY(CSendAndReceive);



#endif // #ifndef  __C_SEND_AND_RECEIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\cmessageinfo.h ===
#ifndef __C_MESSAGE_INFO_H__
#define __C_MESSAGE_INFO_H__



#pragma warning(disable :4786)
#include <map>
#include <windows.h>
#include "CTransitionMap.h"



typedef enum {
    MESSAGE_TYPE_UNKNOWN,
    MESSAGE_TYPE_SEND,
    MESSAGE_TYPE_RECEIVE
} ENUM_MESSAGE_TYPE;

    

class CMessageInfo {

public:

    CMessageInfo();
    
    void ResetAll();

    void SetMessageID(DWORDLONG dwlMessageID);

    DWORDLONG GetMessageID() const;

    void SetMessageType(ENUM_MESSAGE_TYPE MessageType);

    DWORD GetMessageQueueStatus() const;

    DWORD GetMessageExtendedStatus() const;

    void SetState(DWORD dwQueueStatus, DWORD dwExtendedStatus);

    bool IsInFinalState() const;

private:

    DWORDLONG                   m_dwlMessageID;
    ENUM_MESSAGE_TYPE           m_MessageType;
    DWORD                       m_dwQueueStatus;
    DWORD                       m_dwExtendedStatus;
    static const CTransitionMap m_ValidSendTransitions;
    static const CTransitionMap m_ValidReceiveTransitions;
};



#endif // #ifndef __C_MESSAGE_INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\csendandreceive.cpp ===
#include "CSendAndReceive.h"
#include <math.h>
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
CSendAndReceive::CSendAndReceive(
                                 const tstring &tstrName,
                                 const tstring &tstrDescription,
                                 CLogger       &Logger,
                                 int           iRunsCount,
                                 int           iDeepness
                                 )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness), m_pCoverPage(NULL)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceive::CSendAndReceive"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CSendAndReceive::~CSendAndReceive()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceive::~CSendAndReceive"));

    delete m_pCoverPage;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CSendAndReceive::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceive::Run"));

    bool bPassed = true;

    try
    {
        GetLogger().Detail(SEV_MSG, 1, _T("Creating a fax message..."));
    
        //
        // Recipients count is 1 for single recipient fax and size of suite global recipients array for broadcast fax.
        //
        DWORD dwRecipientsCount = m_bBroadcast ? g_dwRecipientsCount : 1;

        //
        // Create new fax message.
        //
        CFaxMessage FaxMessage(
                               m_pCoverPage,
                               m_tstrDocument,
                               g_aRecipients,
                               dwRecipientsCount,
                               GetLogger()
                               );

        GetLogger().Detail(SEV_MSG, 1, _T("Sending the message..."));

        //
        // Send the fax.
        // Track: sending       always
        //        receiving     when possible (single recipient faxes sent using API).
        //
        FaxMessage.Send(
                        g_tstrSendingServer,
                        g_tstrReceivingServer,
                        m_SendMechanism,
                        true,
                        (1 == dwRecipientsCount && SEND_MECHANISM_API == m_SendMechanism),
                        m_EventsMechanism,
                        static_cast<DWORD>(floor(g_dwNotificationTimeout * m_dNotificationTimeoutFactor))
                        );
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_ERR, 1, e.description());
        bPassed = false;
    }

    GetLogger().Detail(
                       bPassed ? SEV_MSG : SEV_ERR,
                       1,
                       _T("The message has%s been sent successfully."),
                       bPassed ? _T("") : _T(" NOT")
                       );

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceive::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceive::ParseParams"));

    tstring tstrDocumentsPath = g_tstrBVTDir + g_tstrDocumentsDir;

    //
    // Read document name - optional.
    //
    m_tstrDocument = _T("");
    try
    {
        m_tstrDocument = GetValueFromMap(mapParams, _T("Document"));
    }
    catch (...)
    {
    }

    if (!m_tstrDocument.empty())
    {
        //
        // The document name specified. Combine the full path.
        //
        m_tstrDocument = tstrDocumentsPath + m_tstrDocument;
    }

    //
    // Read cover page details - optional.
    //
    delete m_pCoverPage;
    m_pCoverPage = NULL;
    try
    {
        tstring tstrCoverPage = GetValueFromMap(mapParams, _T("CoverPage"));
        bool bServerBasedCoverPage  = FromString<bool>(GetValueFromMap(mapParams, _T("ServerBasedCoverPage")));

        if (!bServerBasedCoverPage)
        {
            //
            // Combine the full path.
            //
            tstrCoverPage = tstrDocumentsPath + tstrCoverPage;
        }

        //
        // Read subject - optional.
        //
        tstring tstrSubject;
        try
        {
            tstrSubject = GetValueFromMap(mapParams, _T("Subject"));
        }
        catch (...)
        {
        }

        //
        // Read note - optional.
        //
        tstring tstrNote;
        try
        {
            tstrNote = GetValueFromMap(mapParams, _T("Note"));
        }
        catch (...)
        {
        }
    
        m_pCoverPage = new CCoverPageInfo(tstrCoverPage, bServerBasedCoverPage, tstrSubject, tstrNote);
    }
    catch (...)
    {
    }

    //
    // Read send details.
    //
    m_bBroadcast = FromString<bool>(GetValueFromMap(mapParams, _T("Broadcast")));
    m_SendMechanism = static_cast<ENUM_SEND_MECHANISM>(FromString<DWORD>(GetValueFromMap(mapParams, _T("SendMechanism"))));

    //
    // Read server notifications mechanism - optional.
    //
    m_EventsMechanism = EVENTS_MECHANISM_DEFAULT;
    try
    {
        m_EventsMechanism = static_cast<ENUM_EVENTS_MECHANISM>(FromString<DWORD>(GetValueFromMap(mapParams, _T("EventsMechanism"))));
    }
    catch (...)
    {
    }

    //
    // Read the notification timeout factor. If not specified, use the default.
    //
    try
    {
        m_dNotificationTimeoutFactor = FromString<double>(GetValueFromMap(mapParams, _T("NotificationTimeoutFactor")));
    }
    catch (...)
    {
        m_dNotificationTimeoutFactor = 1.0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\creportgeneralinfo.cpp ===
#include "CReportGeneralInfo.h"
#include <StringUtils.h>



#define SECURITY_WIN32
#include <security.h>



#include <faxreg.h>
#include "CFileVersion.h"
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CReportGeneralInfo::CReportGeneralInfo(
                                       const tstring &tstrName,
                                       const tstring &tstrDescription,
                                       CLogger       &Logger,
                                       int           iRunsCount,
                                       int           iDeepness
                                       )
: CNotReportedTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::CReportGeneralInfo"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CReportGeneralInfo::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::Run"));

    ReportOSInfo();
    
    ReportLoggedOnUser();

    ReportFaxVersion();
    
    return true;
}

    

//-----------------------------------------------------------------------------------------------------------------------------------------
void CReportGeneralInfo::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::ParseParams"));

    UNREFERENCED_PARAMETER(mapParams);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CReportGeneralInfo::ReportOSInfo() const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::ReportOSInfo"));

    //
    // Log the Windows version.
    //
    GetLogger().Detail(SEV_MSG, 1, _T("Windows version: %s"), FormatWindowsVersion().c_str());
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CReportGeneralInfo::ReportLoggedOnUser() const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::ReportLoggedOnUser"));

    TCHAR tszBuffer[MAX_PATH] = _T("Unknown");
    ULONG ulBufferSize        = ARRAY_SIZE(tszBuffer);

    //
    // Retrieve user name.
    //
    if (!GetUserNameEx(NameSamCompatible, tszBuffer, &ulBufferSize))
    {
        DWORD dwEC = GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("GetUserNameEx failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CReportGeneralInfo::ReportLoggedOnUser - GetUserNameEx"));
    }

    //
    // Log the user name.
    //
    GetLogger().Detail(SEV_MSG, 1, _T("Logged on user: %s"), tszBuffer);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CReportGeneralInfo::ReportFaxVersion() const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CReportGeneralInfo::ReportFaxVersion"));

    //
    // Get full qualified path of the fax service image.
    //
    
    tstring tstrFaxServiceImagePath;
    
    DWORD dwEC = ExpandEnvString(FAX_SERVICE_IMAGE_NAME, tstrFaxServiceImagePath);
    if (ERROR_SUCCESS != dwEC)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("ExpandEnvString failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CReportGeneralInfo::ReportFaxVersion - ExpandEnvString"));
    }

    //
    // Retrieve fax service version.
    //
    CFileVersion FaxVersion(tstrFaxServiceImagePath);

    //
    // Log the fax version.
    //
    GetLogger().Detail(SEV_MSG, 1, _T("Fax version: %s"), FaxVersion.Format().c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\csendandreceivesetup.cpp ===
#include "CSendAndReceiveSetup.h"
#include <winspool.h>
#include <faxreg.h>
#include <autorel.h>
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>
#include "CFaxListener.h"
#include "CFaxEventExPtr.h"
#include "Util.h"



#define DELETE_JOB_TIMEOUT (1000 * 60)



typedef std::map<DWORDLONG, DWORD>      MESSAGE_ID_JOB_ID_MAP;
typedef MESSAGE_ID_JOB_ID_MAP::iterator MESSAGE_ID_JOB_ID_MAP_ITERATOR;

//-----------------------------------------------------------------------------------------------------------------------------------------
CSendAndReceiveSetup::CSendAndReceiveSetup(
                                           const tstring &tstrName,
                                           const tstring &tstrDescription,
                                           CLogger       &Logger,
                                           int           iRunsCount,
                                           int           iDeepness
                                           )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness),
  m_bUseFirstDeviceForSending(false),
  m_bUseLastDeviceForReceiving(false)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::CSendAndReceiveSetup"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CSendAndReceiveSetup::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::Run"));

    bool bPassed = true;
    
    try
    {
        bool bSameServer = !_tcsicmp(m_tstrSendingServer.c_str(), m_tstrReceivingServer.c_str());

        GetLogger().Detail(SEV_MSG, 1, _T("Setting fax server(s) configuration..."));

        //
        // Create sending fax connection. Automatically disconnects when goes out of scope.
        //
        CFaxConnection SendingFaxConnection(m_tstrSendingServer);

        if (bSameServer)
        {
            //
            // Sending and receiving servers are the same. Set configuration.
            //
            ServersSetup(true, SendingFaxConnection, SendingFaxConnection);
        }
        else
        {
            //
            // The sending and the receiving servers are not the same.
            // Create receiving fax connection. Automatically disconnects when goes out of scope.
            //
            CFaxConnection ReceivingFaxConnection(m_tstrReceivingServer);

            //
            // Set configuration.
            //
            ServersSetup(false, SendingFaxConnection, ReceivingFaxConnection);
        }

        GetLogger().Detail(SEV_MSG, 1, _T("Fax server(s) configuration set."));

        //
        // Update suite shared data.
        //
        GetLogger().Detail(SEV_MSG, 1, _T("Updating suite shared data..."));
        UpdateSuiteSharedData();
        GetLogger().Detail(SEV_MSG, 1, _T("Suite shared data updated."));
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_ERR, 1, e.description());
        bPassed = false;
    }

    GetLogger().Detail(
                       bPassed ? SEV_MSG : SEV_ERR,
                       1,
                       _T("The SendAndReceive setup has%s been completed successfully."),
                       bPassed ? _T("") : _T(" NOT")
                       );

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::ParseParams"));

    //
    // Read sending server name. If not specified, use local server.
    //
    try
    {
        m_tstrSendingServer = GetValueFromMap(mapParams, _T("SendingServer"));
    }
    catch (...)
    {
    }

    //
    // Read sending device name. If not specified, use first device.
    //
    try
    {
        m_tstrSendingDevice = GetValueFromMap(mapParams, _T("SendingDevice"));
    }
    catch (...)
    {
        m_bUseFirstDeviceForSending = true;
    }

    //
    // Read receiving server name. If not specified, use local server.
    //
    try
    {
        m_tstrReceivingServer = GetValueFromMap(mapParams, _T("ReceivingServer"));
    }
    catch (...)
    {
    }

    //
    // Read receiving device name. If not specified, use last device.
    //
    try
    {
        m_tstrReceivingDevice = GetValueFromMap(mapParams, _T("ReceivingDevice"));
    }
    catch (...)
    {
        m_bUseLastDeviceForReceiving = true;
    }

    //
    // Read the number that should be dialed to send faxes (the number of the receiving device).
    //
    m_tstrNumberToDial = GetValueFromMap(mapParams, _T("NumberToDial"));

    //
    // Read the notification timeout. If not specified, use the default.
    //
    try
    {
        m_dwNotificationTimeout = FromString<DWORD>(GetValueFromMap(mapParams, _T("NotificationTimeout")));
    }
    catch (...)
    {
        m_dwNotificationTimeout = DEFAULT_NOTIFICATION_TIMEOUT;
    }

    //
    // Read whether to empty archives and routging directory. If not specified, don't empty.
    //
    try
    {
        m_bEmptyArchivesAndRouting = FromString<bool>(GetValueFromMap(mapParams, _T("bEmptyArchivesAndRouting")));
    }
    catch (...)
    {
        m_bEmptyArchivesAndRouting = false;
    }

    //
    // Update suite shared data for correct construction and initialization of test cases.
    //
    GetLogger().Detail(SEV_MSG, 1, _T("Updating suite shared data..."));
    UpdateSuiteSharedData();
    GetLogger().Detail(SEV_MSG, 1, _T("Suite shared data updated."));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::ServersSetup(bool bSameServer, const CFaxConnection &SendingFaxConnection, const CFaxConnection &ReceivingFaxConnection) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::ServersSetup"));

    _ASSERT(bSameServer || SendingFaxConnection.GetHandle() != ReceivingFaxConnection.GetHandle());

    tstring tstrBVTPathForSendingServer   = SendingFaxConnection.IsLocal()   ? g_tstrBVTDir : g_tstrBVTDirUNC;
    tstring tstrBVTPathForReceivingServer = ReceivingFaxConnection.IsLocal() ? g_tstrBVTDir : g_tstrBVTDirUNC;

    //
    // Set queue configuration.
    //
    GetLogger().Detail(SEV_MSG, 5, _T("Setting queue configuration..."));
    if (!FaxSetQueue(SendingFaxConnection, 0))
    {
        DWORD dwEC = GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxSetQueue failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::ServersSetup - FaxSetQueue"));
    }
    GetLogger().Detail(SEV_MSG, 5, _T("Queue configuration set."));

    //
    // Set Outbox configuration.
    //
    GetLogger().Detail(SEV_MSG, 5, _T("Setting Outbox configuration..."));
    SetOutbox(SendingFaxConnection);
    GetLogger().Detail(SEV_MSG, 5, _T("Outbox configuration set."));

    //
    // We always locate archives and routing on the machine that runs the BVT for two main reasons:
    //
    // 1) We don't want to force the user to provide directories locations for each server.
    // 2) We don't want to force the user to create shares for directories (and cannot do this programatically) on each server.
    //
    // The side effect of this decision is having a share with full control for everyone on the machine, running the BVT.
    // The CExtendedBVTCleanUp test case removes the share.
    //

    //
    // Set SentItems directory.
    //
    tstring tstrSentItemsPath = tstrBVTPathForSendingServer + g_tstrSentItemsDir;
    GetLogger().Detail(SEV_MSG, 5, _T("Setting SentItems directory to %s..."), tstrSentItemsPath.c_str());
    SetArchiveDir(SendingFaxConnection, FAX_MESSAGE_FOLDER_SENTITEMS, tstrSentItemsPath);
    GetLogger().Detail(SEV_MSG, 5, _T("SentItems directory set."));

    //
    // Set Inbox directory.
    //
    tstring tstrInboxPath = tstrBVTPathForReceivingServer + g_tstrInboxDir;
    GetLogger().Detail(SEV_MSG, 5, _T("Setting Inbox directory to %s..."), tstrInboxPath.c_str());
    SetArchiveDir(ReceivingFaxConnection, FAX_MESSAGE_FOLDER_INBOX, tstrInboxPath);
    GetLogger().Detail(SEV_MSG, 5, _T("Inbox directory set."));

    //
    // Set devices configuration.
    //
    GetLogger().Detail(SEV_MSG, 5, _T("Setting devices configuration..."));
    SetDevices(
               bSameServer,
               SendingFaxConnection,
               ReceivingFaxConnection,
               tstrBVTPathForReceivingServer + g_tstrRoutingDir
               );
    GetLogger().Detail(SEV_MSG, 5, _T("Devices configuration set."));

    //
    // Empty queue.
    //
    GetLogger().Detail(SEV_MSG, 5, _T("Emptying queue..."));
    EmptyQueue(SendingFaxConnection);
    GetLogger().Detail(SEV_MSG, 5, _T("Queue emptied."));

    if (m_bEmptyArchivesAndRouting)
    {
        //
        // Empty SentItems archive.
        //
        GetLogger().Detail(SEV_MSG, 5, _T("Emptying SentItems archive..."));
        EmptyArchive(SendingFaxConnection, FAX_MESSAGE_FOLDER_SENTITEMS);
        GetLogger().Detail(SEV_MSG, 5, _T("SentItems archive emptied."));

        //
        // Empty Inbox archive.
        //
        GetLogger().Detail(SEV_MSG, 5, _T("Emptying Inbox archive..."));
        EmptyArchive(ReceivingFaxConnection, FAX_MESSAGE_FOLDER_INBOX);
        GetLogger().Detail(SEV_MSG, 5, _T("Inbox archive emptied."));

        //
        // Empty routing directory. Always use local path.
        //
        GetLogger().Detail(SEV_MSG, 5, _T("Emptying routing directory..."));
        ::EmptyDirectory(g_tstrBVTDir + g_tstrRoutingDir);
        GetLogger().Detail(SEV_MSG, 5, _T("Routing directory emptied."));
    }

    if (IsWindowsXP())
    {
        //
        // Turn off Configuratin Wizard.
        //
        GetLogger().Detail(SEV_MSG, 5, _T("WindowsXP OS - turning off Configuration Wizard..."));
        TurnOffConfigurationWizard();
        GetLogger().Detail(SEV_MSG, 5, _T("Configuration Wizard turned off."));
    }

    if (!SendingFaxConnection.IsLocal())
    {
        //
        // Add printer connection.
        //
        GetLogger().Detail(SEV_MSG, 5, _T("Remote sending server - adding fax printer connection..."));
        AddFaxPrinterConnection(m_tstrSendingServer);
        GetLogger().Detail(SEV_MSG, 5, _T("Fax printer connection added."));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::SetArchiveDir(HANDLE hFaxServer, FAX_ENUM_MESSAGE_FOLDER Archive, const tstring &tstrDir) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::SetArchiveDir"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetArchiveDir - invalid hFaxServer"));
    }

    //
    // Get current archive configuration.
    //
    
    PFAX_ARCHIVE_CONFIG pArchiveConfiguration = NULL;

    if (!::FaxGetArchiveConfiguration(hFaxServer, Archive, &pArchiveConfiguration))
    {
        DWORD dwEC = GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxGetArchiveConfiguration failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetArchiveDir - FaxGetArchiveConfiguration"));
    }

    //
    // Make desired changes in the configuration.
    // There is no memory leak here.
    // The service allocates contiguous block of memory for FAX_ARCHIVE_CONFIG and all its strings.
    // FaxFreeBuffer deallocates the block. Thus, there is no "pointer loss" here.
    //
    pArchiveConfiguration->bUseArchive = true;
    pArchiveConfiguration->lpcstrFolder = const_cast<LPTSTR>(tstrDir.c_str());

    try
    {
        //
        // Set changed configuration
        //
        if (!::FaxSetArchiveConfiguration(hFaxServer, Archive, pArchiveConfiguration))
        {
            DWORD dwEC = GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxSetArchiveConfiguration failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetArchiveDir - FaxSetArchiveConfiguration"));
        }

        FaxFreeBuffer(pArchiveConfiguration);
    }
    catch(Win32Err &)
    {
        FaxFreeBuffer(pArchiveConfiguration);
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::SetOutbox(HANDLE hFaxServer) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::SetOutbox"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetOutbox - invalid hFaxServer"));
    }

    //
    // Get current Outbox configuration.
    //
    
    PFAX_OUTBOX_CONFIG pOutboxConfiguration = NULL;

    if (!::FaxGetOutboxConfiguration(hFaxServer, &pOutboxConfiguration))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxGetOutboxConfiguration failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetOutbox - FaxGetOutboxConfiguration"));
    }

    //
    // Make desired changes in the configuration.
    //
    pOutboxConfiguration->bAllowPersonalCP = TRUE;  // We want to test personal CPs.
    pOutboxConfiguration->bUseDeviceTSID   = FALSE; // We want to use TSID per job for sent-received pairs identification.
    pOutboxConfiguration->dwRetries        = 0;     // We don't check scenarios with retries.
    pOutboxConfiguration->bBranding        = TRUE;  // We want to check branding (this doesn't hits tiff comparison).

    try
    {
        //
        // Set changed configuration
        //
        if (!::FaxSetOutboxConfiguration(hFaxServer, pOutboxConfiguration))
        {
            DWORD dwEC = ::GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxSetOutboxConfiguration failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetOutbox - FaxSetOutboxConfiguration"));
        }
        ::FaxFreeBuffer(pOutboxConfiguration);
    }
    catch(Win32Err &)
    {
        ::FaxFreeBuffer(pOutboxConfiguration);
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::SetDevices(bool bSameServer, HANDLE hSendingServer, HANDLE hReceivingServer, const tstring &tstrRoutingDir) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::SetDevices"));

    if (!hSendingServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hSendingServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetDevices - invalid hSendingServer"));
    }
    if (!hReceivingServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hReceivingServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetDevices - invalid hReceivingServer"));
    }

    PFAX_PORT_INFO_EX pSendingServerPortsInfo     = NULL;
    PFAX_PORT_INFO_EX pReceivingServerPortsInfo   = NULL;
    DWORD             dwSendingServerPortsCount   = 0;
    DWORD             dwReceivingServerPortsCount = 0;

    //
    // Get current ports configuration from the sending server.
    //
    if (!::FaxEnumPortsEx(hSendingServer, &pSendingServerPortsInfo, &dwSendingServerPortsCount))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxEnumPortsEx failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetDevices - FaxEnumPortsEx"));
    }
    _ASSERT(pSendingServerPortsInfo);

    try
    {
        if (bSameServer)
        {
            //
            // The sending server is the receiving server too.
            //
            pReceivingServerPortsInfo   = pSendingServerPortsInfo;
            dwReceivingServerPortsCount = dwSendingServerPortsCount;
        }
        else
        {
            //
            // Get current ports configuration from the receiving server.
            //
            if (!::FaxEnumPortsEx(hReceivingServer, &pReceivingServerPortsInfo, &dwReceivingServerPortsCount))
            {
                DWORD dwEC = GetLastError();
                GetLogger().Detail(SEV_ERR, 1, _T("FaxEnumPortsEx failed with ec=%ld."), dwEC);
                THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetDevices - FaxEnumPortsEx"));
            }
            _ASSERT(pReceivingServerPortsInfo);
        }

        //
        // We want to be sure the devices limitation will not beat us.
        // Therefore, here we disable all devices. Also we store the enumeration(s) indices of the devices,
        // intended for sending and receiving to appropriately enable them later.
        //
 
        DWORD dwSendingDeviceIndex   = m_bUseFirstDeviceForSending  ? 0                               : 0xFFFFFFFF;
        DWORD dwReceivingDeviceIndex = m_bUseLastDeviceForReceiving ? dwReceivingServerPortsCount - 1 : 0xFFFFFFFF;

        for (DWORD dwInd = 0; dwInd < dwSendingServerPortsCount || dwInd < dwReceivingServerPortsCount; ++dwInd)
        {
            if (dwInd < dwSendingServerPortsCount)
            {
                if (dwSendingDeviceIndex == 0xFFFFFFFF && pSendingServerPortsInfo[dwInd].lpctstrDeviceName == m_tstrSendingDevice)
                {
                    dwSendingDeviceIndex = dwInd;
                }

                pSendingServerPortsInfo[dwInd].bSend       = FALSE;
                pSendingServerPortsInfo[dwInd].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
            }
            if (dwInd < dwReceivingServerPortsCount)
            {
                if (dwReceivingDeviceIndex == 0xFFFFFFFF && pReceivingServerPortsInfo[dwInd].lpctstrDeviceName == m_tstrReceivingDevice)
                {
                    dwReceivingDeviceIndex = dwInd;
                }

                pReceivingServerPortsInfo[dwInd].bSend       = FALSE;
                pReceivingServerPortsInfo[dwInd].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
            }
        }

        //
        // Make sure we've found both receiving and sending devices.
        //
        if (dwSendingDeviceIndex == 0xFFFFFFFF)
        {
            GetLogger().Detail(SEV_ERR, 1, _T("Device %s not found."), m_tstrSendingDevice.c_str());
            THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("CSendAndReceiveSetup::SetDevices - device not found"));
        }
        if (dwReceivingDeviceIndex == 0xFFFFFFFF)
        {
            GetLogger().Detail(SEV_ERR, 1, _T("Device %s not found."), m_tstrReceivingDevice.c_str());
            THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("CSendAndReceiveSetup::SetDevices - device not found"));
        }
    
        //
        // Make sure the sending and the receiving devices are not the same.
        //
        if (pSendingServerPortsInfo + dwSendingDeviceIndex == pReceivingServerPortsInfo + dwReceivingDeviceIndex)
        {
            GetLogger().Detail(SEV_ERR, 1, _T("Cannot send and receive on the same device."));
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetDevices - cannot send and receive on the same device"));
        }

        //
        // Set sending and receiving devices.
        //
        pSendingServerPortsInfo[dwSendingDeviceIndex].bSend = TRUE;
        pReceivingServerPortsInfo[dwReceivingDeviceIndex].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;

        //
        // Set TSID and CSID.
        // There is no memory leak here.
        // The service allocates contiguous block of memory for ports enumeration and all its strings.
        // FaxFreeBuffer deallocates the block. Thus, there is no "pointer loss" here.
        //
        pSendingServerPortsInfo[dwSendingDeviceIndex].lptstrTsid     = _T("TSID");
        pReceivingServerPortsInfo[dwReceivingDeviceIndex].lptstrCsid = _T("CSID");

        //
        // Propagate the changes to the server.
        // Because of devices limitation on Desktop SKUs, we do this in two separate calls:
        // * the first call disables devices that should be disabled
        // * the second call enables devices that should be enabled
        //

        //
        // On the sending server.
        //
        SaveDevicesSettings(hSendingServer, pSendingServerPortsInfo, dwSendingServerPortsCount, false);
        SaveDevicesSettings(hSendingServer, pSendingServerPortsInfo, dwSendingServerPortsCount, true);

        if (!bSameServer)
        {
            //
            // On the receiving server.
            //
            SaveDevicesSettings(hReceivingServer, pReceivingServerPortsInfo, dwReceivingServerPortsCount, false);
            SaveDevicesSettings(hReceivingServer, pReceivingServerPortsInfo, dwReceivingServerPortsCount, true);
        }

        //
        // Set routing to folder on the receiving device.
        //
        SetRoutingToFolder(hReceivingServer, pReceivingServerPortsInfo[dwReceivingDeviceIndex].dwDeviceID, tstrRoutingDir);

        ::FaxFreeBuffer(pSendingServerPortsInfo);
        
        if (!bSameServer)
        {
            ::FaxFreeBuffer(pReceivingServerPortsInfo);
        }
    }

    catch(Win32Err &)
    {
        ::FaxFreeBuffer(pSendingServerPortsInfo);
        
        if (!bSameServer)
        {
            ::FaxFreeBuffer(pReceivingServerPortsInfo);
        }

        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::SaveDevicesSettings(HANDLE hFaxServer, PFAX_PORT_INFO_EX pPortsInfo, DWORD dwPortsCount, bool bSetEnabled) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::SaveDevicesSettings"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SaveDevicesSettings - invalid hFaxServer"));
    }

    for (DWORD dwInd = 0; dwInd < dwPortsCount; ++dwInd)
    {
        if (!bSetEnabled && (pPortsInfo[dwInd].bSend || pPortsInfo[dwInd].ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF))
        {
            //
            // The device is enabled but this time we don't set enabled devices - skip it.
            //
            continue;
        }

        if (!::FaxSetPortEx(hFaxServer, pPortsInfo[dwInd].dwDeviceID, &pPortsInfo[dwInd]))
        {
            DWORD dwEC = GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxSetPortEx failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SaveDevicesSettings - FaxSetPortEx"));
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::SetRoutingToFolder(HANDLE hFaxServer, DWORD dwDeviceID, const tstring &tstrRoutingDir) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::SetRoutingToFolder"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::SetRoutingToFolder - invalid hFaxServer"));
    }

    HANDLE hPort         = NULL;
    BYTE   *pRoutingInfo = NULL;

    try
    {
        //
        // Open the port for configuration (we need this for setting routing info).
        //
        if(!::FaxOpenPort(hFaxServer, dwDeviceID, PORT_OPEN_MODIFY, &hPort))
        {
            DWORD dwEC = GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxOpenPort failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetRoutingToFolder - FaxOpenPort"));
        }

        //
        // Calculate the required size of the blob.
	    // The first DWORD in the blob indicates whether the method is enabled.
	    // It is followed by a unicode string, specifying the folder name.
        //
        DWORD dwRoutingInfoSize = sizeof(DWORD) + sizeof(WCHAR) * (tstrRoutingDir.size() + 1);

        //
        // Allocate and nullify the memory.
        //
        pRoutingInfo = new BYTE[dwRoutingInfoSize];
        _ASSERT(pRoutingInfo);
        ZeroMemory(pRoutingInfo, dwRoutingInfoSize);

        //
        // Set the first DWORD to indicate the method is enabled.
        //
        *(reinterpret_cast<LPDWORD>(pRoutingInfo)) = LR_STORE;

#ifndef _UNICODE
        //
        // tstrRoutingDir is ANSI - should convert into unicode
        //
        if (!::MultiByteToWideChar(
                                 CP_ACP,
                                 0,
                                 tstrRoutingDir.c_str(),
                                 -1,
                                 reinterpret_cast<LPWSTR>(pRoutingInfo + sizeof(DWORD)),
                                 dwRoutingInfoSize - sizeof(DWORD)
                                 ))
        {
            DWORD dwEC = ::GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("MultiByteToWideChar failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetRoutingToFolder - MultiByteToWideChar"));
        }
#else
        //
        // tstrRoutingDir is unicode - no conversion needed, just copy.
        //
        _tcscpy(reinterpret_cast<LPWSTR>(pRoutingInfo + sizeof(DWORD)), tstrRoutingDir.c_str());
#endif

        //
        // Set the routing info.
        //
        if(!::FaxSetRoutingInfo(hPort, REGVAL_RM_FOLDER_GUID, pRoutingInfo, dwRoutingInfoSize))
        {
            DWORD dwEC = ::GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxSetRoutingInfo failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetRoutingToFolder - FaxSetRoutingInfo"));
        }

        //
        // Enable the routing method.
        //
        if(!::FaxEnableRoutingMethod(hPort, REGVAL_RM_FOLDER_GUID, TRUE))
        {
            DWORD dwEC = GetLastError();
            GetLogger().Detail(SEV_ERR, 1, _T("FaxEnableRoutingMethod failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::SetRoutingToFolder - FaxEnableRoutingMethod"));
        }

        delete pRoutingInfo;

        if (hPort && !::FaxClose(hPort))
        {
            DWORD dwEC = ::GetLastError();
            GetLogger().Detail(SEV_WRN, 1, _T("FaxClose failed with ec=%ld."), dwEC);
        }
    }
    catch(Win32Err &)
    {
        delete pRoutingInfo;
        ::FaxClose(hPort);
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::EmptyArchive(HANDLE hFaxServer, FAX_ENUM_MESSAGE_FOLDER Archive) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::EmptyArchive"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::EmptyArchive - invalid hFaxServer"));
    }

    //
    // Start archive messages enumeration 
    //
    
    HANDLE hEnum = NULL;

    if (!::FaxStartMessagesEnum(hFaxServer, Archive, &hEnum))
    {
        DWORD dwEC = ::GetLastError();
        
        if (dwEC == ERROR_NO_MORE_ITEMS)
        {
            //
            // No messages to delete - Ok.
            //
            return;
        }

        GetLogger().Detail(SEV_ERR, 1, _T("FaxStartMessagesEnum failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::EmptyArchive - FaxStartMessagesEnum"));
    }

    PFAX_MESSAGE pMessages          = NULL;
    DWORD        dwReturnedMessages = 0;

    while (::FaxEnumMessages(hEnum, 100, &pMessages, &dwReturnedMessages))
    {
        _ASSERT(pMessages && dwReturnedMessages > 0);
        
        try
        {
            for (DWORD dwInd = 0; dwInd < dwReturnedMessages; ++dwInd)
            {
                if (!::FaxRemoveMessage(hFaxServer, pMessages[dwInd].dwlMessageId, Archive))
                {
                    DWORD dwEC = ::GetLastError();
                    GetLogger().Detail(SEV_ERR, 1, _T("FaxRemoveMessage failed with ec=%ld."), dwEC);
                    THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::EmptyArchive - FaxRemoveMessage"));
                }
            }

            ::FaxFreeBuffer(pMessages);
        }
        catch(Win32Err &)
        {
            ::FaxFreeBuffer(pMessages);
            throw;
        }
    }

    //
    // Check why we exited the above while loop.
    //
    DWORD dwEC = ::GetLastError();
    if (dwEC != ERROR_NO_MORE_ITEMS)
    {
        //
        // There was a real error.
        //
        GetLogger().Detail(SEV_ERR, 1, _T("FaxEnumMessages failed with ec=%ld."), dwEC);
        
        if (!::FaxEndMessagesEnum(hEnum))
        {
            GetLogger().Detail(SEV_WRN, 1, _T("FaxEndMessagesEnum failed with ec=%ld."), GetLastError());
        }

        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::EmptyArchive - FaxEnumMessages"));
    }

    if (!::FaxEndMessagesEnum(hEnum))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxEndMessagesEnum failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::EmptyArchive - FaxEndMessagesEnum"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::EmptyQueue(HANDLE hFaxServer) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::EmptyQueue"));

    if (!hFaxServer)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Invalid hFaxServer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::EmptyQueue - invalid hFaxServer"));
    }

    //
    // Register for fax notifications.
    //
    CFaxListener Listener(
                          hFaxServer,
                          FAX_EVENT_TYPE_OUT_QUEUE | FAX_EVENT_TYPE_IN_QUEUE,
                          EVENTS_MECHANISM_COMPLETION_PORT,
                          DELETE_JOB_TIMEOUT
                          );

    //
    // Get enumeration of all jobs in the server queue.
    //

    PFAX_JOB_ENTRY_EX pJobs          = NULL;
    DWORD             dwJobsReturned = 0;

    if (!::FaxEnumJobsEx(hFaxServer, (JT_SEND | JT_RECEIVE | JT_UNKNOWN | JT_ROUTING ), &pJobs, &dwJobsReturned))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("FaxEnumJobsEx failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32((dwEC), _T("CSendAndReceiveSetup::EmptyQueue - FaxEnumJobsEx"));
    }
    GetLogger().Detail(SEV_MSG, 5, _T("Number of jobs to delete is %ld."), dwJobsReturned);

    if (0 == dwJobsReturned)
    {
        //
        // The queue is empty
        //
        return;
    }

    //
    // Create empty map of jobs.
    //
    MESSAGE_ID_JOB_ID_MAP mapJobsMap;

    try
    {
        for (DWORD dwInd = 0; dwInd < dwJobsReturned; ++dwInd)
        {
            //
            // Post a delete request to the service.
            //
            if (!FaxAbort(hFaxServer, pJobs[dwInd].pStatus->dwJobID))
            {
                DWORD dwEC = GetLastError();
                GetLogger().Detail(SEV_WRN, 1, _T("FaxAbort failed with ec=%ld."), dwEC);
            }
            else
            {
                //
                // The delete request succeeded. We would like to make sure the job is indeed deleted - add it to the map.
                //
                mapJobsMap.insert(MESSAGE_ID_JOB_ID_MAP::value_type(pJobs[dwInd].dwlMessageId, pJobs[dwInd].pStatus->dwJobID));
            }
        }

        _ASSERT(!mapJobsMap.empty());
        
        ::FaxFreeBuffer(pJobs);
        pJobs = NULL;

        GetLogger().Detail(SEV_MSG, 5, _T("All delete requests posted to the service."));

        //
        // FaxAbort() is asynchronous. Wait for operation completion.
        //
        for(;;)
        {
            CFaxEventExPtr FaxEventExPtr(Listener.GetEvent());

            if (!FaxEventExPtr.IsValid())
            {
                //
                // Invalid event.
                //
                break;
            }

            //
            // We are registered only for OUT_QUEUE and IN_QUEUE events.
            //
            _ASSERT(FaxEventExPtr->EventType == FAX_EVENT_TYPE_OUT_QUEUE ||
                    FaxEventExPtr->EventType == FAX_EVENT_TYPE_IN_QUEUE
                    );

        
            if (FaxEventExPtr->EventInfo.JobInfo.Type != FAX_JOB_EVENT_TYPE_REMOVED)
            {
                //
                // Useless event - skip.
                //
                continue;
            }

            //
            // Try to remove the job from the map.
            //
            mapJobsMap.erase(FaxEventExPtr->EventInfo.JobInfo.dwlMessageId);

            if (mapJobsMap.empty())
            {
                //
                // The map is empty - all jobs deleted.
                //
                GetLogger().Detail(SEV_MSG, 5, _T("All jobs deleted."));
                break;
            }
        }

        if (!mapJobsMap.empty())
        {
            //
            // For some reason failed to empty the queue.
            //
            GetLogger().Detail(SEV_WRN, 1, _T("Cannot empty the queue."));
        }
    }
    catch(Win32Err &)
    {
        ::FaxFreeBuffer(pJobs);
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::TurnOffConfigurationWizard() const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::TurnOffConfigurationWizard"));

    DWORD       dwEC    = ERROR_SUCCESS;
    const DWORD dwValue = 1;

    //
    // Set the flag responsible for service part.
    //

    //
    // Create (or open if already exists) the registry key.
    // The key is automatically closed when aahkService goes out of scope.
    //

    CAutoCloseRegHandle ahkService;

    dwEC = ::RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REGKEY_FAXSERVER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &ahkService,
                            NULL
                            );

    if (dwEC != ERROR_SUCCESS)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to create HKLM\\%s registry key (ec=%ld)."), REGKEY_FAXSERVER, dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::TurnOffConfigurationWizard - RegCreateKeyEx"));
    }

    //
    // Set the flag.
    //
    dwEC = ::RegSetValueEx(ahkService, REGVAL_CFGWZRD_DEVICE, 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
    if (dwEC != ERROR_SUCCESS)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to set %s registry value (ec=%ld)."), REGVAL_CFGWZRD_DEVICE, dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::TurnOffConfigurationWizard - RegSetValueEx"));
    }

    //
    // Set the flag responsible for user part.
    //
    
    //
    // Create (or open if already exists) the registry key.
    // The key is automatically closed when aahkUserInfo goes out of scope.
    //

    CAutoCloseRegHandle ahkUserInfo;

    dwEC = ::RegCreateKeyEx(
                            HKEY_CURRENT_USER,
                            REGKEY_FAX_SETUP,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &ahkUserInfo,
                            NULL
                            );

    if (dwEC != ERROR_SUCCESS)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to create HKCU\\%s registry key (ec=%ld)."), REGKEY_FAX_SETUP, dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::TurnOffConfigurationWizard - RegCreateKeyEx"));
    }

    //
    // Set the flag.
    //
    dwEC = ::RegSetValueEx(ahkUserInfo, REGVAL_CFGWZRD_USER_INFO, 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
    if (dwEC != ERROR_SUCCESS)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to set %s registry value (ec=%ld)."), REGVAL_CFGWZRD_USER_INFO, dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::TurnOffConfigurationWizard - RegSetValueEx"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::AddFaxPrinterConnection(const tstring &tstrServer) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CSendAndReceiveSetup::AddFaxPrinterConnection"));

    if (::IsLocalServer(tstrServer))
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Cannot add printer connection to the local printer."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CSendAndReceiveSetup::AddFaxPrinterConnection - cannot add printer connection to the local printer"));
    }

    tstring tstrPrinterUNC = ::GetFaxPrinterName(tstrServer);

    //
    // Add printer connection
    //
    if (!::AddPrinterConnection(const_cast<LPTSTR>(tstrPrinterUNC.c_str())))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("Failed to add printer connection to %s (ec=%ld)."), tstrPrinterUNC.c_str(), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::AddFaxPrinterConnection - AddPrinterConnection"));
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CSendAndReceiveSetup::UpdateSuiteSharedData() const
{
    g_tstrSendingServer   = m_tstrSendingServer;
    g_tstrReceivingServer = m_tstrReceivingServer;
    g_tstrNumberToDial    = m_tstrNumberToDial;

    for (int i = 0; i < g_dwRecipientsCount; ++i)
    {
        g_aRecipients[i].SetName(_T("Recipient") + ToString(i));
        g_aRecipients[i].SetNumber(m_tstrNumberToDial);
    }

    g_dwNotificationTimeout = m_dwNotificationTimeout;

    SYSTEMTIME SystemTime;
    GetSystemTime(&SystemTime);
    if (!SystemTimeToFileTime(&SystemTime, &g_TheOldestFileOfInterest))
    {
        DWORD dwEC = ::GetLastError();
        GetLogger().Detail(SEV_ERR, 1, _T("SystemTimeToFileTime failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CSendAndReceiveSetup::UpdateSuiteSharedData - SystemTimeToFileTime"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctracker.h ===
#ifndef __C_TRACKER_H__
#define __C_TRACKER_H__



#include <windows.h>
#include <autorel.h>
#include <ptrs.h>
#include <cs.h>
#include "CFaxEventExPtr.h"
#include "CFaxMessage.h"



//
// "Forward" declaration to resolve cyclic dependency of CTracker and CFaxMessage.
//
class CFaxMessage;

class CTracker {

public:

    CTracker(
             CFaxMessage           &FaxMessage,
             CLogger               &Logger,
             const tstring         &tstrSendingServer,
             const tstring         &tstrReceivingServer,
             bool                  bTrackSend,
             bool                  bTrackReceive,
             ENUM_EVENTS_MECHANISM EventsMechanism = EVENTS_MECHANISM_DEFAULT,
             DWORD                 dwNotificationTimeout = DEFAULT_NOTIFICATION_TIMEOUT
             );

    ~CTracker();

    void BeginTracking(ENUM_MESSAGE_TYPE MessageType);

    void ExamineTrackingResults();

private:

    void CreateTrackingThreads(
                               const tstring         &tstrSendingServer,
                               const tstring         &tstrReceivingServer,
                               bool                  bTrackSend,
                               bool                  bTrackReceive,
                               ENUM_EVENTS_MECHANISM EventsMechanism,
                               DWORD                 dwNotificationTimeout = DEFAULT_NOTIFICATION_TIMEOUT
                               );

    bool ProcessEvent(const CFaxEventExPtr &FaxEventExPtr, ENUM_MESSAGE_TYPE MessageType);

    void WaitForTrackingThreads();

    void Abort();

    void Track(ENUM_MESSAGE_TYPE MessageType);

    static DWORD WINAPI TrackSendThread(LPVOID pData);

    static DWORD WINAPI TrackReceiveThread(LPVOID pData);

    CCriticalSection      m_BeginTrackingCriticalSection;
    CFaxMessage           &m_FaxMessage;
    CLogger               &m_Logger;
    CAutoCloseHandle      m_ahSendTrackingThread;
    CAutoCloseHandle      m_ahReceiveTrackingThread;
    CAutoCloseHandle      m_ahEventSendListenerReady;
    CAutoCloseHandle      m_ahEventReceiveListenerReady;
    CAutoCloseHandle      m_ahEventBeginSendTracking;
    CAutoCloseHandle      m_ahEventBeginReceiveTracking;
    aptr<CFaxListener>    m_apSendListener;
    aptr<CFaxListener>    m_apReceiveListener;
    int                   m_iSendNotInFinalStateCount;
    int                   m_iReceiveNotInFinalStateCount;
    bool                  m_bShouldWait;
    bool                  m_bAborted;
    DWORD                 m_dwTrackingTimeout;
};



#endif // #ifndef __C_TRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctracker.cpp ===
#include "CTracker.h"
#include <crtdbg.h>



#define NOTIFICATIONS_PER_TRANSMISSION 5



//-----------------------------------------------------------------------------------------------------------------------------------------
CTracker::CTracker(
                   CFaxMessage           &FaxMessage,
                   CLogger               &Logger,
                   const tstring         &tstrSendingServer,
                   const tstring         &tstrReceivingServer,
                   bool                  bTrackSend,
                   bool                  bTrackReceive,
                   ENUM_EVENTS_MECHANISM EventsMechanism,
                   DWORD                 dwNotificationTimeout
                   )
: m_FaxMessage(FaxMessage), m_Logger(Logger), m_bAborted(false)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::CTracker"));

    try
    {
        //
        // Set number of messages not in final state.
        //
        m_iSendNotInFinalStateCount    = bTrackSend    ? FaxMessage.GetRecipientsCount() : 0;
        m_iReceiveNotInFinalStateCount = bTrackReceive ? FaxMessage.GetRecipientsCount() : 0;

        //
        // Create events.
        // The events are automatically destroyed when the object goes out of scope.
        //
        m_ahEventSendListenerReady = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_ahEventSendListenerReady)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CTracker::CTracker - CreateEvent"));
        }
        m_ahEventReceiveListenerReady = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_ahEventReceiveListenerReady)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CTracker::CTracker - CreateEvent"));
        }
        m_ahEventBeginSendTracking = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_ahEventBeginSendTracking)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CTracker::CTracker - CreateEvent"));
        }
        m_ahEventBeginReceiveTracking = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_ahEventBeginSendTracking)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("CTracker::CTracker - CreateEvent"));
        }

        //
        // Create trackning threads.
        //
        CreateTrackingThreads(tstrSendingServer, tstrReceivingServer, bTrackSend, bTrackReceive, EventsMechanism, dwNotificationTimeout);

        //
        // Set the entire tracking timeout.
        //
        m_dwTrackingTimeout = dwNotificationTimeout * NOTIFICATIONS_PER_TRANSMISSION * m_FaxMessage.GetRecipientsCount();
    }
    catch (Win32Err &)
    {
        Abort();
        WaitForTrackingThreads();
        throw;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTracker::~CTracker()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::~CTracker"));

    if (m_bShouldWait)
    {
        try
        {
            Abort();
            WaitForTrackingThreads();
        }
        catch (...)
        {
            if (!uncaught_exception())
            {
                throw;
            }
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::BeginTracking(ENUM_MESSAGE_TYPE MessageType)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::BeginTracking"));

    HANDLE hEvent;

    switch (MessageType)
    {
    case MESSAGE_TYPE_SEND:
        
        hEvent = m_ahEventBeginSendTracking;
        break;

    case MESSAGE_TYPE_RECEIVE:

        hEvent = m_ahEventBeginReceiveTracking;
        break;

    default:
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CTracker::BeginTracking - invalid MessageType"));
    }
    
    CS CriticalSectionLock(m_BeginTrackingCriticalSection);

    //
    // Release the thread from waiting for event.
    //
    if (!SetEvent(hEvent))
    {
        DWORD dwEC = GetLastError();
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::BeginTracking - SetEvent"));
        m_Logger.Detail(SEV_ERR, 1, _T("SetEvent failed with ec=%ld."), dwEC);
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::CreateTrackingThreads(
                                     const tstring         &tstrSendingServer,
                                     const tstring         &tstrReceivingServer,
                                     bool                  bTrackSend,
                                     bool                  bTrackReceive,
                                     ENUM_EVENTS_MECHANISM EventsMechanism,
                                     DWORD                 dwNotificationTimeout
                                     )
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::CreateTrackingThreads"));

    _ASSERT(!m_ahSendTrackingThread);
    _ASSERT(!m_ahReceiveTrackingThread);
    
    m_bShouldWait = false;
        
    m_Logger.Detail(SEV_MSG, 5, _T("Notification timeout is %ld."), dwNotificationTimeout);

    if (bTrackSend)
    {
        m_Logger.Detail(SEV_MSG, 5, _T("Create send tracking thread..."));

        //
        // Create send listener (with delayed registration).
        // The listener should be registered by the thread that will call GetEvent().
        // This is done in order to be able to receive notifications, using window messages.
        //
        m_apSendListener = new CFaxListener(
                                           tstrSendingServer,
                                           FAX_EVENT_TYPE_OUT_QUEUE,
                                           EventsMechanism,
                                           dwNotificationTimeout,
                                           true
                                           );

        //
        // Create send tracking thread.
        //
        DWORD dwThreadID;
        m_ahSendTrackingThread = CreateThread(
                                              NULL,
                                              0,
                                              CTracker::TrackSendThread,
                                              this,
                                              0,
                                              &dwThreadID
                                              );
        if (!m_ahSendTrackingThread)
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("CreateThread failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::CreateTrackingThreads - CreateThread"));
        }
        
        m_bShouldWait = true;
        
        m_Logger.Detail(
                        SEV_MSG,
                        5,
                        _T("Send tracking thread created (ID=0x%04x), waiting for listener registration..."),
                        dwThreadID
                        );

        //
        // Wait for the thread to register the listener.
        //
        DWORD dwWaitRes = WaitForSingleObject(m_ahEventSendListenerReady, dwNotificationTimeout);
        if (dwWaitRes == WAIT_TIMEOUT)
        {
            m_Logger.Detail(
                            SEV_ERR,
                            1,
                            _T("Send listener has not been registerd for events during %ld msec."),
                            dwNotificationTimeout
                            );

            THROW_TEST_RUN_TIME_WIN32(WAIT_TIMEOUT, _T("CTracker::CreateTrackingThreads - listener not registerd for events"));
        }
        else if (dwWaitRes == WAIT_FAILED)
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("WaitForSingleObject failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::CreateTrackingThreads - WaitForSingleObject"));
        }

        m_Logger.Detail(SEV_MSG, 5, _T("Listener registered."));
    }

    if (bTrackReceive)
    {
        m_Logger.Detail(SEV_MSG, 5, _T("Create receive tracking thread..."));

        //
        // Create receive listener (with delayed registration).
        // The listener should be registered by the thread that will call GetEvent().
        // This is done in order to be able to receive notifications, using window messages.
        //
        m_apReceiveListener = new CFaxListener(
                                              tstrReceivingServer,
                                              FAX_EVENT_TYPE_IN_QUEUE,
                                              EventsMechanism,
                                              dwNotificationTimeout,
                                              true
                                              );

        //
        // Create receive tracking thread.
        //
        DWORD dwThreadID;
        m_ahReceiveTrackingThread = CreateThread(
                                                 NULL,
                                                 0,
                                                 CTracker::TrackReceiveThread,
                                                 this,
                                                 0,
                                                 &dwThreadID
                                                 );
        if (!m_ahReceiveTrackingThread)
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("CreateThread failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::CreateTrackingThreads - CreateThread"));
        }

        m_bShouldWait = true;
        
        m_Logger.Detail(
                        SEV_MSG,
                        5,
                        _T("Receive tracking thread created (ID=0x%04x), waiting for listener registration..."),
                        dwThreadID
                        );

        //
        // Wait for the thread to register the listener.
        //
        DWORD dwWaitRes = WaitForSingleObject(m_ahEventReceiveListenerReady, dwNotificationTimeout);
        if (dwWaitRes == WAIT_TIMEOUT)
        {
            m_Logger.Detail(
                            SEV_ERR,
                            1,
                            _T("Receive listener has not been registerd for events during %ld msec."),
                            dwNotificationTimeout
                            );

            THROW_TEST_RUN_TIME_WIN32(WAIT_TIMEOUT, _T("CTracker::CreateTrackingThreads - listener not registerd for events"));
        }
        else if (dwWaitRes == WAIT_FAILED)
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("WaitForSingleObject failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::CreateTrackingThreads - WaitForSingleObject"));
        }

        m_Logger.Detail(SEV_MSG, 5, _T("Listener registered."));
    }
}

    
    
//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::ExamineTrackingResults()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::ExamineTrackingResults"));

    WaitForTrackingThreads();

    if (m_ahSendTrackingThread)
    {
        //
        // Examine send tracking results.
        //
        DWORD dwSendTrackingResult = ERROR_SUCCESS;

        if (!GetExitCodeThread(m_ahSendTrackingThread, &dwSendTrackingResult))
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("GetExitCodeThread failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::ExamineTrackingResults - GetExitCodeThread"));
        }
        if (dwSendTrackingResult != ERROR_SUCCESS)
        {
            m_Logger.Detail(SEV_ERR, 1, _T("Tracking of send failed (ec=%ld)."), dwSendTrackingResult);
            THROW_TEST_RUN_TIME_WIN32(dwSendTrackingResult, _T("CTracker::ExamineTrackingResults - tracking of send failed"));
        }
    }

    if (m_ahReceiveTrackingThread)
    {
        //
        // Examine receive tracking results.
        //
        DWORD dwReceiveTrackingResult = ERROR_SUCCESS;

        if (!GetExitCodeThread(m_ahReceiveTrackingThread, &dwReceiveTrackingResult))
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("GetExitCodeThread failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::ExamineTrackingResults - GetExitCodeThread"));
        }
        if (dwReceiveTrackingResult != ERROR_SUCCESS)
        {
            m_Logger.Detail(SEV_ERR, 1, _T("Tracking of receive failed (ec=%ld)."), dwReceiveTrackingResult);
            THROW_TEST_RUN_TIME_WIN32(dwReceiveTrackingResult, _T("CTracker::ExamineTrackingResults - tracking of receive failed"));
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTracker::ProcessEvent(const CFaxEventExPtr &FaxEventExPtr, ENUM_MESSAGE_TYPE MessageType)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::ProcessEvent"));

    if (!FaxEventExPtr.IsValid())
    {
        m_Logger.Detail(SEV_ERR, 1, _T("Invalid FaxEventExPtr."));
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CTracker::ProcessEvent - invalid FaxEventExPtr"));
    }

    m_Logger.Detail(SEV_MSG, 5, _T("Processing event...\n%s"), FaxEventExPtr.Format().c_str());

    switch (FaxEventExPtr->EventType)
    {
    case FAX_EVENT_TYPE_OUT_QUEUE:

        _ASSERT(MESSAGE_TYPE_SEND == MessageType);
        break;

    case FAX_EVENT_TYPE_IN_QUEUE:
        
        _ASSERT(MESSAGE_TYPE_RECEIVE == MessageType);
        break;

    case FAX_EVENT_TYPE_CONFIG:
	case FAX_EVENT_TYPE_ACTIVITY:
	case FAX_EVENT_TYPE_QUEUE_STATE:
	case FAX_EVENT_TYPE_IN_ARCHIVE:
	case FAX_EVENT_TYPE_OUT_ARCHIVE:
    default:
        //
        // We never register for these types of events - we shouldn't get them.
        //
        m_Logger.Detail(SEV_ERR, 1, _T("Invalid EventType: %ld."), FaxEventExPtr->EventType);
        _ASSERT(false);
        return true;
    }

    bool bMoreEventsWanted = true;

    if (FAX_JOB_EVENT_TYPE_STATUS == FaxEventExPtr->EventInfo.JobInfo.Type)
    {
        //
        // pJobData member of FAX_EVENT_JOB is a valid pointer.
        //
        m_Logger.Detail(SEV_MSG, 5, _T("Got notification on state change of job 0x%I64x."), FaxEventExPtr->EventInfo.JobInfo.dwlMessageId);

        try
        {
            //
            // SetStateAndCheckWhetherItIsFinal() tries to update a message state.
            // If the message cannot be found or the transition is invalid, it throws exception.
            // The return value indicates whether the new state is final.
            //
            bool bInFinalState = m_FaxMessage.SetStateAndCheckWhetherItIsFinal(
                                                                               MessageType,
                                                                               FaxEventExPtr->EventInfo.JobInfo.dwlMessageId,
                                                                               FaxEventExPtr->EventInfo.JobInfo.pJobData->dwQueueStatus,
                                                                               FaxEventExPtr->EventInfo.JobInfo.pJobData->dwExtendedStatus
                                                                               );

            if (bInFinalState)
            {
                if (MESSAGE_TYPE_SEND == MessageType)
                {
                    bMoreEventsWanted = (--m_iSendNotInFinalStateCount > 0);
                    _ASSERT(m_iSendNotInFinalStateCount >= 0);
                    m_Logger.Detail(SEV_MSG, 5, _T("%ld sent message(s) not in final state."), m_iSendNotInFinalStateCount);
                }
                else if (MESSAGE_TYPE_RECEIVE == MessageType)
                {
                    bMoreEventsWanted = (--m_iReceiveNotInFinalStateCount > 0);
                    _ASSERT(m_iReceiveNotInFinalStateCount >= 0);
                    m_Logger.Detail(SEV_MSG, 5, _T("%ld received message(s) not in final state."), m_iReceiveNotInFinalStateCount);
                }
                else
                {
                    _ASSERT(false);
                    return true;
                }
            }
        }
        catch (Win32Err &e)
        {
            switch (e.error())
            {
            case ERROR_NOT_FOUND:
                //
                // This event is regarding a job, which doesn't belong to our broadcast.
                // So, we would expect for more events.
                //
                m_Logger.Detail(SEV_MSG, 5, _T("The job doesn't belong to the broadcast - event discarded."));
                break;

            default:
                throw;
            }
        }
    }
    else
    {
        m_Logger.Detail(SEV_MSG, 5, _T("Not a status event - discarded."));
    }

    return bMoreEventsWanted;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::WaitForTrackingThreads()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::WaitForTrackingThreads"));

    if (!m_bShouldWait)
    {
        return;
    }

    m_Logger.Detail(SEV_MSG, 5, _T("Waiting for tracking thread(s) to exit (at most %ld msec)..."), m_dwTrackingTimeout);

    DWORD dwWaitRes;

    for (;;)
    {
        if (m_ahSendTrackingThread && m_ahReceiveTrackingThread)
        {
            //
            // Wait for both send and receive tracking threads.
            //
            HANDLE aHandles[2] = {m_ahSendTrackingThread, m_ahReceiveTrackingThread};
            dwWaitRes = WaitForMultipleObjects(2, aHandles, TRUE, m_dwTrackingTimeout);
        }
        else if (m_ahSendTrackingThread)
        {
            //
            // Wait for send tracking thread only.
            //
            dwWaitRes = WaitForSingleObject(m_ahSendTrackingThread, m_dwTrackingTimeout);
        }
        else if (m_ahReceiveTrackingThread)
        {
            //
            // Wait for receive tracking thread only.
            //
            dwWaitRes = WaitForSingleObject(m_ahReceiveTrackingThread, m_dwTrackingTimeout);
        }
        else
        {
            _ASSERT(false);
        }

        //
        // If WAIT_OBJECT_0 defined to be 0, the following expression is always true: dwWaitRes >= WAIT_OBJECT_0,
        // because DWORD is unsigned. This causes the razzle to issue a warning.
        // The following separation of (>=) to (> || ==) is to avoid this.
        //

        if ((WAIT_OBJECT_0 == dwWaitRes || WAIT_OBJECT_0 < dwWaitRes) && WAIT_OBJECT_0 + 1 >= dwWaitRes)
        {
            //
            // The wait succeeded, the thread(s) exited.
            //
            m_Logger.Detail(SEV_MSG, 5, _T("The tracking thread(s) exited."));
            m_bShouldWait = false;
            return;
        }
        else if (WAIT_TIMEOUT == dwWaitRes)
        {
            m_Logger.Detail(
                            SEV_ERR,
                            1,
                            _T("Tracking thread(s) did not exit during %ld msec. Waiting again..."),
                            m_dwTrackingTimeout
                            );
        }
        else if (WAIT_FAILED == dwWaitRes)
        {
            DWORD dwEC = GetLastError();
            m_Logger.Detail(SEV_ERR, 1, _T("WaitForMultipleObjects/WaitForSingleObject failed with ec=%ld."), dwEC);
            THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::WaitForTrackingThreads - WaitForMultipleObjects/WaitForSingleObject"));
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::Abort()
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::Abort"));

    if (m_bAborted)
    {
       return;
    }

    CS CriticalSectionLock(m_BeginTrackingCriticalSection);

    //
    // Release tracking threads from waiting for server notifications.
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Aborting tracking..."));
    if (m_apSendListener)
    {
        m_apSendListener->StopWaiting();
    }
    if (m_apReceiveListener)
    {
        m_apReceiveListener->StopWaiting();
    }

    //
    // Release tracking threads from waiting for events.
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Releasing tracking thread(s)..."));
    BeginTracking(MESSAGE_TYPE_SEND);
    BeginTracking(MESSAGE_TYPE_RECEIVE);

    m_bAborted = true;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTracker::Track(ENUM_MESSAGE_TYPE MessageType)
{
    CScopeTracer Tracer(m_Logger, 7, _T("CTracker::Track"));

    CFaxListener *pListener   = NULL;
    HANDLE       hEventToWait = NULL;
    HANDLE       hEventToSet  = NULL;

    switch (MessageType)
    {
    case MESSAGE_TYPE_SEND:
        pListener    = m_apSendListener;
        hEventToWait = m_ahEventBeginSendTracking;
        hEventToSet  = m_ahEventSendListenerReady;
        break;

    case MESSAGE_TYPE_RECEIVE:
        pListener    = m_apReceiveListener;
        hEventToWait = m_ahEventBeginReceiveTracking;
        hEventToSet  = m_ahEventReceiveListenerReady;
        break;

    default:
        m_Logger.Detail(SEV_ERR, 1, _T("Invalid MessageType: %ld."), MessageType);
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CTracker::Track - invalid MessageType"));
    }
    
    _ASSERT(pListener && hEventToWait && hEventToSet);
    
    //
    // Register for events.
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Registering listener..."));
    pListener->Register();

    if (!SetEvent(hEventToSet))
    {
        DWORD dwEC = GetLastError();
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::Track - SetEvent"));
        m_Logger.Detail(SEV_ERR, 1, _T("SetEvent failed with ec=%ld."), dwEC);
    }

    //
    // Wait until send/receive IDs are known.    
    //
    m_Logger.Detail(SEV_MSG, 5, _T("Waiting for message IDs..."));
    if (WaitForSingleObject(hEventToWait, INFINITE) != WAIT_OBJECT_0)
    {
        DWORD dwEC = GetLastError();
        m_Logger.Detail(SEV_ERR, 1, _T("WaitForSingleObject failed with ec=%ld"), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTracker::Track - WaitForSingleObject"));
    }

    //
    // Track events.
    //

    bool bMoreEventsExpected = true;
        
    while (bMoreEventsExpected)
    {
        if (m_bAborted)
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_OPERATION_ABORTED, _T("CTracker::Track - tracking aborted"));
        }

        //
        // The message is not in a final state - more events expected.
        // Get an event from the notifier and process it.
        //
        bMoreEventsExpected = ProcessEvent(pListener->GetEvent(), MessageType);
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD WINAPI CTracker::TrackSendThread(LPVOID pData)
{
    if (!pData)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    // Get "this" pointer from pData.
    //
    CTracker *pTracker = reinterpret_cast<CTracker *>(pData);

    _ASSERT(pTracker->m_apSendListener);

    try
    {
        pTracker->Track(MESSAGE_TYPE_SEND);
    }
    catch(Win32Err &e)
    {
        pTracker->Abort();
        return e.error();
    }

    return ERROR_SUCCESS;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD WINAPI CTracker::TrackReceiveThread(LPVOID pData)
{
    if (!pData)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    // Get "this" pointer from pData.
    //
    CTracker *pTracker = reinterpret_cast<CTracker *>(pData);

    _ASSERT(pTracker->m_apReceiveListener);

    try
    {
        pTracker->Track(MESSAGE_TYPE_RECEIVE);
    }
    catch(Win32Err &e)
    {
        pTracker->Abort();
        return e.error();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctiffcomparison.h ===
#ifndef __C_TIFF_COMPARISON_H__
#define  __C_TIFF_COMPARISON_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CTiffComparison test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case performs tiff comparison of files or directories.


    **************************************
    Test case specific INI file parameters
    **************************************

    ComparisonType = <number>
        Mandatory.
        Specifies how the Source and Destination entries should be interpreted.

        Currently supported values are:
            COMPARISON_TYPE_FILE          = 1
            COMPARISON_TYPE_DIRECTORY     = 2
            COMPARISON_TYPE_BVT_DIRECTORY = 3

    Source = <filename | directory name | SentItems | Inbox | Routing>
        Specifies a source for the comparison.

    Destination = <filename | directory name | SentItems | Inbox | Routing>
        Specifies a destination for the comparison.

    SkipFirstLine = <1/0>
    Specifies whether the file comparison should skip the first line.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"



typedef enum {
    COMPARISON_TYPE_FILE = 1,
    COMPARISON_TYPE_DIRECTORY,
    COMPARISON_TYPE_BVT_DIRECTORY
} ENUM_COMPARISON_TYPE;



class CTiffComparison : public CTestCase {

public:

    CTiffComparison(
                    const tstring &tstrName,
                    const tstring &tstrDescription,
                    CLogger       &Logger,
                    int           iRunsCount,
                    int           iDeepness
                    );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    bool AreIdenticalDirectories(
                                 const tstring &tstrSource,
                                 const tstring &m_tstrDestination,
                                 bool bSkipFirstLine
                                 ) const;
    
    bool AreIdenticalFiles(
                           const tstring &tstrSource,
                           const tstring &m_tstrDestination,
                           bool bSkipFirstLine
                           ) const;

    tstring GetBVTDirectory(const tstring &tstrDirectory) const;

    ENUM_COMPARISON_TYPE m_ComparisonType;
    bool                 m_bSkipFirstLine;
    tstring              m_tstrSource;
    tstring              m_tstrDestination;
};



DEFINE_TEST_FACTORY(CTiffComparison);



#endif // #ifndef  __C_TIFF_COMPARISON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctransitionmap.cpp ===
#include "CTransitionMap.h"
#include <fxsapip.h>


//-----------------------------------------------------------------------------------------------------------------------------------------
CTransitionMap::CTransitionMap(const TRANSITION *TransitionsArray, int iTransitionsCount)
{
    if (TransitionsArray && iTransitionsCount > 0)
    {
        for (int i = 0; i < iTransitionsCount; ++i)
        {
            m_mapTransitions.insert(TransitionsArray[i]);
        }
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTransitionMap::IsValidTransition(DWORDLONG dwlFrom, DWORDLONG dwlTo) const
{
    //
    // Find all valid transitions from the "From" state.
    //
    TRANSITION_MAP_EQUAL_RANGE EqualRange = m_mapTransitions.equal_range(dwlFrom);

    //
    // Check validity of the transition to "To" state.
    //
    TRANSITION_MAP_CONST_ITERATOR citTransitionIterator;
    for (citTransitionIterator = EqualRange.first; citTransitionIterator != EqualRange.second; ++citTransitionIterator)
    {
        if (citTransitionIterator->second == dwlTo)
        {
            break;
        }
    }

    if (citTransitionIterator == EqualRange.second)
    {
        //
        // We've scanned the entire range. The requested transition is not valid.
        //
        return false;
    }

    return true;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTransitionMap::IsFinalState(DWORDLONG dwlState) const
{
    //
    // Find any valid transition from the state.
    // If doesn't exist - the state is final.
    //
    return m_mapTransitions.find(dwlState) == m_mapTransitions.end();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctiffcomparison.cpp ===
#include "CTiffComparison.h"
#include <crtdbg.h>
#include <StringUtils.h>
#include <STLAuxiliaryFunctions.h>
#include <TiffUtils.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
CTiffComparison::CTiffComparison(
                                 const tstring &tstrName,
                                 const tstring &tstrDescription,
                                 CLogger       &Logger,
                                 int           iRunsCount,
                                 int           iDeepness
                                 )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::CTiffComparison"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTiffComparison::Run()
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::Run"));

    bool bPassed = true;

    try
    {
        GetLogger().Detail(
                           SEV_MSG,
                           1,
                           _T("Comparing %s and %s (first line%s skipped)..."),
                           m_tstrSource.c_str(),
                           m_tstrDestination.c_str(),
                           m_bSkipFirstLine ? _T("") : _T(" NOT")
                           );

        switch (m_ComparisonType)
        {
        case COMPARISON_TYPE_FILE:
            bPassed = AreIdenticalFiles(m_tstrSource, m_tstrDestination, m_bSkipFirstLine);
            break;

        case COMPARISON_TYPE_DIRECTORY:

            bPassed = AreIdenticalDirectories(
                                              ForceLastCharacter(m_tstrSource, _T('\\')),
                                              ForceLastCharacter(m_tstrDestination, _T('\\')),
                                              m_bSkipFirstLine
                                              );
            break;

        case COMPARISON_TYPE_BVT_DIRECTORY:
            bPassed = AreIdenticalDirectories(GetBVTDirectory(m_tstrSource), GetBVTDirectory(m_tstrDestination), m_bSkipFirstLine);
            break;

        default:
            GetLogger().Detail(SEV_ERR, 1, _T("Invalid m_ComparisonType: %ld."), m_ComparisonType);
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CTiffComparison::Run - invalid m_ComparisonType"));
        }

        GetLogger().Detail(
                           bPassed ? SEV_MSG : SEV_ERR,
                           1,
                           _T("%s and %s are%s identical."),
                           m_tstrSource.c_str(),
                           m_tstrDestination.c_str(),
                           bPassed ? _T("") : _T(" NOT")
                           );
    }
    catch(Win32Err &e)
    {
        GetLogger().Detail(SEV_ERR, 1, e.description());
        bPassed = false;
    }

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTiffComparison::ParseParams(const TSTRINGMap &mapParams)
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::ParseParams"));

    //
    // Read comparison type.
    //
    m_ComparisonType = static_cast<ENUM_COMPARISON_TYPE>(FromString<DWORD>(GetValueFromMap(mapParams, _T("ComparisonType"))));

    //
    // Read bSkipFirstLine.
    //
    m_bSkipFirstLine = FromString<bool>(GetValueFromMap(mapParams, _T("SkipFirstLine")));
    
    //
    // Read source and destination.
    //
    m_tstrSource = GetValueFromMap(mapParams, _T("Source"));
    m_tstrDestination = GetValueFromMap(mapParams, _T("Destination"));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline bool CTiffComparison::AreIdenticalDirectories(
                                                     const tstring &tstrSource,
                                                     const tstring &tstrDestination,
                                                     bool bSkipFirstLine
                                                     ) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::AreIdenticalDirectories"));

    GetLogger().Detail(SEV_MSG, 5, _T("Comparing directories...\nSource\t%s\nDestination\t%s"), tstrSource.c_str(), tstrDestination.c_str());

    CFileFilterNewerThanAndExtension Filter(g_TheOldestFileOfInterest, _T(".tif"));

    TSTRINGVector vecSource      = GetDirectoryFileNames(tstrSource, Filter);
    TSTRINGVector vecDestination = GetDirectoryFileNames(tstrDestination, Filter);

    int iNotMatchedFilesCount = 0;

    if (vecSource.size() != vecDestination.size())
    {
        GetLogger().Detail(
                           SEV_ERR,
                           1,
                           _T("Source and destination directories have different number of files (%ld - %ld)."),
                           vecSource.size(),
                           vecDestination.size()
                           );
        return false;
    }
    
    //
    // Go over all files in the source directory.
    //

    TSTRINGVector::iterator itSourceIterator = vecSource.begin();

    while (itSourceIterator != vecSource.end())
    {
        int     iMinimalDifferenceSoFar = INT_MAX;
        tstring tstrClosestFileSoFar;

        GetLogger().Detail(SEV_MSG, 6, _T("Looking for a match for %s..."), itSourceIterator->c_str());

        //
        // Look for a matching file in the destination directory.
        //
        
        TSTRINGVector::iterator itDestinationIterator = vecDestination.begin();
            
        while (itDestinationIterator != vecDestination.end())
        {
            GetLogger().Detail(SEV_MSG, 6, _T("Comparing with %s..."), itDestinationIterator->c_str());

            int iDifferentBitsCount;
            
            if (TiffCompare(
                            const_cast<LPTSTR>(itSourceIterator->c_str()),
                            const_cast<LPTSTR>(itDestinationIterator->c_str()),
                            bSkipFirstLine,
                            &iDifferentBitsCount
                            ))
            {
                if (0 == iDifferentBitsCount)
                {
                    //
                    // Matching file found.
                    //
                    GetLogger().Detail(SEV_MSG, 6, _T("Match found: %s."), itDestinationIterator->c_str());

                    vecDestination.erase(itDestinationIterator);
                    iMinimalDifferenceSoFar = 0;
                    break;
                }
                else if (-1 == iDifferentBitsCount)
                {
                    GetLogger().Detail(
                                       SEV_MSG,
                                       6,
                                       _T("The files have significant difference in general parameters.")
                                       );
                }
                else
                {
                    GetLogger().Detail(SEV_MSG, 6, _T("The files are different in %ld bits."), iDifferentBitsCount);

                    if (iDifferentBitsCount < iMinimalDifferenceSoFar)
                    {
                        _ASSERT(iDifferentBitsCount > 0);

                        iMinimalDifferenceSoFar = iDifferentBitsCount;
                        tstrClosestFileSoFar = *itDestinationIterator;
                    }
                }
            }
            else
            {
                GetLogger().Detail(SEV_WRN, 6, _T("TiffCompare failed with ec=%ld."), GetLastError());
            }

            ++itDestinationIterator;
        }

        if (0 == iMinimalDifferenceSoFar)
        {
            itSourceIterator = vecSource.erase(itSourceIterator);
        }
        else
        {
            if (INT_MAX > iMinimalDifferenceSoFar)
            {
                GetLogger().Detail(
                                   SEV_ERR,
                                   1,
                                   _T("Match not found. The closest file is %s with %ld different bits."),
                                   tstrClosestFileSoFar.c_str(),
                                   iMinimalDifferenceSoFar
                                   );
            }
            else
            {
                GetLogger().Detail(SEV_ERR, 1, _T("Match not found."));
            }

            ++iNotMatchedFilesCount;
            ++itSourceIterator;
        }
    }

    _ASSERT(vecSource.size() == iNotMatchedFilesCount && vecDestination.size() == iNotMatchedFilesCount);
    
    if (iNotMatchedFilesCount > 0)
    {
        GetLogger().Detail(SEV_ERR, 1, _T("Match not found for %ld file(s)."), iNotMatchedFilesCount);
    }

    return iNotMatchedFilesCount == 0;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline bool CTiffComparison::AreIdenticalFiles(
                                               const tstring &tstrSource,
                                               const tstring &tstrDestination,
                                               bool bSkipFirstLine
                                               ) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::AreIdenticalFiles"));

    if (tstrSource.empty() || m_tstrDestination.empty())
    {
        return false;
    }
    
    GetLogger().Detail(SEV_MSG, 5, _T("Comparing files...\nSource %s\nDestination%s"), tstrSource.c_str(), tstrDestination.c_str());
    
    int iDifferentBitsCount = 0;

    if (!TiffCompare(
                     const_cast<LPTSTR>(tstrSource.c_str()),
                     const_cast<LPTSTR>(tstrDestination.c_str()),
                     bSkipFirstLine,
                     &iDifferentBitsCount
                     ))
    {
        DWORD dwEC = GetLastError();
        GetLogger().Detail(SEV_MSG, 5, _T("TiffCompare failed with ec=%ld."), dwEC);
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("CTiffComparison::AreIdenticalFiles - TiffCompare"));
    }

    if (0 == iDifferentBitsCount)
    {
        GetLogger().Detail(SEV_MSG, 5, _T("Files are identical."));
        return true;
    }
    else if (-1 == iDifferentBitsCount)
    {
        GetLogger().Detail(
                           SEV_MSG,
                           5,
                           _T("The files have significant difference in general parameters.")
                           );
        return false;
    }
    else
    {
        GetLogger().Detail(SEV_MSG, 5, _T("The files are different in %ld bits."), iDifferentBitsCount);
        return false;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
inline tstring CTiffComparison::GetBVTDirectory(const tstring &tstrDirectory) const
{
    CScopeTracer Tracer(GetLogger(), 7, _T("CTiffComparison::GetBVTDirectory"));

    //
    // Always return local path.
    //

    if (tstrDirectory == _T("Inbox"))
    {
        return g_tstrBVTDir + g_tstrInboxDir;
    }
    else if (tstrDirectory == _T("SentItems"))
    {
        return g_tstrBVTDir + g_tstrSentItemsDir;
    }
    else if (tstrDirectory == _T("Routing"))
    {
        return g_tstrBVTDir + g_tstrRoutingDir;
    }
    else
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("CTiffComparison::GetBVTDirectory - invalid tstrDirectory"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\ctransitionmap.h ===
#ifndef __C_TRANSITION_MAP_H__
#define __C_TRANSITION_MAP_H__



#pragma warning(disable :4786)
#include <map>
#include <windows.h>



typedef std::multimap<DWORDLONG, DWORDLONG> TRANSITION_MAP;
typedef TRANSITION_MAP::value_type TRANSITION;
typedef TRANSITION_MAP::const_iterator TRANSITION_MAP_CONST_ITERATOR;
typedef std::pair<TRANSITION_MAP_CONST_ITERATOR, TRANSITION_MAP_CONST_ITERATOR> TRANSITION_MAP_EQUAL_RANGE;


    
class CTransitionMap {

public:

    CTransitionMap(const TRANSITION *TransitionsArray, int iTransitionsCount);

    bool IsValidTransition(DWORDLONG dwlFrom, DWORDLONG dwlTo) const;

    bool IsFinalState(DWORDLONG dwlState) const;

private:

    TRANSITION_MAP m_mapTransitions;
};



#endif // #ifndef __C_TRANSITION_MAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\csendandreceivesetup.h ===
#ifndef __C_SEND_AND_RECEIVE_SETUP_H__
#define __C_SEND_AND_RECEIVE_SETUP_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This is a header file of CSendAndReceiveSetup test case class.

    Author: Yury Berezansky (YuryB)

    27-May-2001


    *******
    General
    *******
    
    The class defines a test case, using the "Test Suite Manager" model.
    The test case performs configuration changes, needed to run CSendAndReceive
    test case.


    **************************************
    Test case specific INI file parameters
    **************************************

    SendingServer = <machine name>
        Optional.
        Specifies a machine to be used as a sending server. If not specified,
        the server is used.

    SendingDevice = <device name>
        Optional.
        Specifies a device on the sending server to be used to send faxes.
        If not specified, the first device on the sending server is used.

    ReceivingServer = <machine name>
        Optional.
        Specifies a machine to be used as a receiving server. If not specified,
        the server is used.

    ReceivingDevice = <device name>
        Optional.
        Specifies a device on the receiving server to be used to receive faxes.
        If not specified, the last device on the receiving server is used.

    NumberToDial = <fax number>
        Mandatory.
        Specifies a fax number to be dialed to send faxes. Obviously, it's the
        number of a line, attached to the receiving device.

    NotificationTimeout = <notification timeout (msec)>
        Optional.
        Specifies the maximal amount of time, allowed to elapse between two
        subsequent notifications in a single fax transmission.
        If not specified, the default value (#defiened as 3 min) is used.

    EmptyArchivesAndRouting = <1/0>
        Optional.
        Specifies whether the archives and the routing directory should be emptied.
        If not specified, the archives and the routing directory are not emptied.



-----------------------------------------------------------------------------------------------------------------------------------------*/



#include "ExtendedBVT.h"
#include "CFaxConnection.h"



class CSendAndReceiveSetup : public CTestCase {

public:

    CSendAndReceiveSetup(
                         const tstring &tstrName,
                         const tstring &tstrDescription,
                         CLogger       &Logger,
                         int           iRunsCount,
                         int           iDeepness
                         );

    virtual bool Run();

private:

    virtual void ParseParams(const TSTRINGMap &mapParams);

    void ServersSetup(bool bSameServer, const CFaxConnection &SendingFaxConnection, const CFaxConnection &ReceivingFaxConnection) const;

    void SetArchiveDir(HANDLE hFaxServer, FAX_ENUM_MESSAGE_FOLDER Archive, const tstring &tstrDir) const;

    void SetOutbox(HANDLE hFaxServer) const;

    void SetDevices(bool bSameServer, HANDLE hSendingServer, HANDLE hReceivingServer, const tstring &tstrRoutingDir) const;

    void SaveDevicesSettings(HANDLE hFaxServer, PFAX_PORT_INFO_EX pPortsInfo, DWORD dwPortsCount, bool bSetEnabled) const;

    void SetRoutingToFolder(HANDLE hFaxServer, DWORD dwDeviceID, const tstring &tstrRoutingDir) const;

    void EmptyArchive(HANDLE hFaxServer, FAX_ENUM_MESSAGE_FOLDER Archive) const;

    void EmptyQueue(HANDLE hFaxServer) const;

    void TurnOffConfigurationWizard() const;

    void AddFaxPrinterConnection(const tstring &tstrServer) const;

    void UpdateSuiteSharedData() const;

    tstring m_tstrSendingServer;
    tstring m_tstrSendingDevice;
    bool    m_bUseFirstDeviceForSending;
    tstring m_tstrReceivingServer;
    tstring m_tstrReceivingDevice;
    bool    m_bUseLastDeviceForReceiving;
    tstring m_tstrNumberToDial;
    DWORD   m_dwNotificationTimeout;
    bool    m_bEmptyArchivesAndRouting;
};



DEFINE_TEST_FACTORY(CSendAndReceiveSetup);



#endif // #ifndef __C_SEND_AND_RECEIVE_SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\extendedbvt.cpp ===
#include "ExtendedBVT.h"
#include "Util.h"



//
// Directories used by the BVT.
//
tstring g_tstrBVTDir;
tstring g_tstrBVTDirUNC;
tstring g_tstrDocumentsDir;
tstring g_tstrInboxDir;
tstring g_tstrSentItemsDir;
tstring g_tstrRoutingDir;

//
// Recipients, used by the BVT.
//
CPersonalInfo g_aRecipients[3];
DWORD         g_dwRecipientsCount = ARRAY_SIZE(g_aRecipients);

//
// Used for communication between CSendAndReceive and CSendAndReceiveSetup test cases.
//
tstring g_tstrSendingServer;
tstring g_tstrReceivingServer;
tstring g_tstrNumberToDial;
DWORD   g_dwNotificationTimeout;

//
// Designates the creation time of the oldest file in the SentItems, Inbox and Routing directories
// that should be taken into account.
//
FILETIME g_TheOldestFileOfInterest = {0};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\main.cpp ===
#pragma warning(disable :4786)
#include <windows.h>
#include <tstring.h>
#include <StringUtils.h>
#include "ExtendedBVT.h"
#include "CExtendedBVTSetup.h"
#include "CExtendedBVTCleanup.h"
#include "CSendAndReceiveSetup.h"
#include "CSendAndReceive.h"
#include "CTiffComparison.h"
#include "CEmptyBVTDirectories.h"
#include "CCheckFiles.h"
#include "CReportGeneralInfo.h"
#include "Util.h"



#ifdef _UNICODE

int __cdecl wmain(int argc, wchar_t *argv[])

#else

int __cdecl main(int argc, char *argv[])

#endif
{
    bool bSuitePassed = false;

    try
    {
        //
        // Get the ini file name.
        // The file must be in the process current directory. By default "params.ini" is used.
        // Other name may be specified in command line.
        //

        TCHAR tszBuffer[MAX_PATH];
        if (!::GetCurrentDirectory(ARRAY_SIZE(tszBuffer), tszBuffer))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("main - GetCurrentDirectory"));
        }

        tstring tstrIniFile = ForceLastCharacter(tszBuffer, _T('\\'));

        if (1 == argc)
        {
             tstrIniFile += _T("params.ini");
        }
        else if (2 == argc)
        {
            tstrIniFile += argv[1];
        }
        else
        {
            _tprintf(TEXT("Usage: ExtendedBVT [inifile]\n"));
            return ERROR_INVALID_COMMAND_LINE;
        }

        //
        // Create instances of test factories.
        //
        CExtendedBVTSetupFactory    ExtendedBVTSetupFactory;
        CExtendedBVTCleanupFactory  ExtendedBVTCleanupFactory;
        CSendAndReceiveSetupFactory SendAndReceiveSetupFactory;
        CSendAndReceiveFactory      SendAndReceiveFactory;
        CTiffComparisonFactory      TiffComparisonFactory;
        CEmptyBVTDirectoriesFactory EmptyBVTDirectoriesFactory;
        CCheckFilesFactory          CheckFilesFactory;
        CReportGeneralInfoFactory   ReportGeneralInfoFactory;

        //
        // Create map of test factories.
        //
        TEST_FACTORY_MAP mapTestFactoryMap;
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CExtendedBVTSetup"),    &ExtendedBVTSetupFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CExtendedBVTCleanup"),  &ExtendedBVTCleanupFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CSendAndReceiveSetup"), &SendAndReceiveSetupFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CSendAndReceive"),      &SendAndReceiveFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CTiffComparison"),      &TiffComparisonFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CEmptyBVTDirectories"), &EmptyBVTDirectoriesFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CCheckFiles"),          &CheckFilesFactory));
        mapTestFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(_T("CReportGeneralInfo"),   &ReportGeneralInfoFactory));

        //
        // Create elle logger with newline as details separator.
        //
        CElleLogger Logger(_T('\n'));

        //
        // Create an run the BVT.
        //
        CTestSuite ExtendedBVT(_T("ExtendedBVT"), _T("Fax Server basic verification test"), Logger);

        bSuitePassed = ExtendedBVT.Do(tstrIniFile, mapTestFactoryMap);
    }
    catch(Win32Err &e)
	{
        _tprintf(_T("%s\n"), e.description());
	}

    return bSuitePassed ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\faxconstantsnames.cpp ===
#pragma warning(disable :4786)
#include <map>
#include "FaxConstantsNames.h"
#include <StringUtils.h>
#include "Util.h"



//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type s_aEventTypes[] = {
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_IN_QUEUE,      _T("FAX_EVENT_TYPE_IN_QUEUE")     ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_OUT_QUEUE,     _T("FAX_EVENT_TYPE_OUT_QUEUE")    ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_CONFIG,        _T("FAX_EVENT_TYPE_CONFIG")       ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_ACTIVITY,      _T("FAX_EVENT_TYPE_ACTIVITY")     ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_QUEUE_STATE,   _T("FAX_EVENT_TYPE_QUEUE_STATE")  ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_IN_ARCHIVE,    _T("FAX_EVENT_TYPE_IN_ARCHIVE")   ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_OUT_ARCHIVE,   _T("FAX_EVENT_TYPE_OUT_ARCHIVE")  ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_FXSSVC_ENDED,  _T("FAX_EVENT_TYPE_FXSSVC_ENDED") ),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_DEVICE_STATUS, _T("FAX_EVENT_TYPE_DEVICE_STATUS")),
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::value_type(FAX_EVENT_TYPE_NEW_CALL,      _T("FAX_EVENT_TYPE_NEW_CALL")     )
};



std::map<FAX_ENUM_EVENT_TYPE, tstring> s_mapEventsTypes(
                                                        s_aEventTypes,
                                                        s_aEventTypes + ARRAY_SIZE(s_aEventTypes)
                                                        );



//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring>::value_type s_aJobEventTypes[] = {
    std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring>::value_type(FAX_JOB_EVENT_TYPE_ADDED,   _T("FAX_JOB_EVENT_TYPE_ADDED")  ),
    std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring>::value_type(FAX_JOB_EVENT_TYPE_REMOVED, _T("FAX_JOB_EVENT_TYPE_REMOVED")),
    std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring>::value_type(FAX_JOB_EVENT_TYPE_STATUS,  _T("FAX_JOB_EVENT_TYPE_STATUS") )
};



static const std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring> s_mapJobEventsTypes(
                                                                            s_aJobEventTypes,
                                                                            s_aJobEventTypes + ARRAY_SIZE(s_aJobEventTypes)
                                                                            );


    
//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type s_aConfigEventTypes[] = {
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_RECEIPTS,         _T("FAX_CONFIG_TYPE_RECEIPTS")        ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_ACTIVITY_LOGGING, _T("FAX_CONFIG_TYPE_ACTIVITY_LOGGING")),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_OUTBOX,           _T("FAX_CONFIG_TYPE_OUTBOX")          ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_SENTITEMS,        _T("FAX_CONFIG_TYPE_SENTITEMS")       ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_INBOX,            _T("FAX_CONFIG_TYPE_INBOX")           ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_SECURITY,         _T("FAX_CONFIG_TYPE_SECURITY")        ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_EVENTLOGS,        _T("FAX_CONFIG_TYPE_EVENTLOGS")       ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_DEVICES,          _T("FAX_CONFIG_TYPE_DEVICES")         ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_OUT_GROUPS,       _T("FAX_CONFIG_TYPE_OUT_GROUPS")      ),
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::value_type(FAX_CONFIG_TYPE_OUT_RULES,        _T("FAX_CONFIG_TYPE_OUT_RULES")       )
};



static const std::map<FAX_ENUM_CONFIG_TYPE, tstring> s_mapConfigEventsTypes(
                                                                            s_aConfigEventTypes,
                                                                            s_aConfigEventTypes + ARRAY_SIZE(s_aConfigEventTypes)
                                                                            );


    
//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<DWORD, tstring>::value_type s_aQueueStatuses[] = {
    std::map<DWORD, tstring>::value_type(0,                   _T("NO_STATUS")          ),
    std::map<DWORD, tstring>::value_type(JS_PENDING,          _T("JS_PENDING")         ),
    std::map<DWORD, tstring>::value_type(JS_INPROGRESS,       _T("JS_INPROGRESS")      ),
    std::map<DWORD, tstring>::value_type(JS_DELETING,         _T("JS_DELETING")        ),
    std::map<DWORD, tstring>::value_type(JS_FAILED,           _T("JS_FAILED")          ),
    std::map<DWORD, tstring>::value_type(JS_PAUSED,           _T("JS_PAUSED")          ),
    std::map<DWORD, tstring>::value_type(JS_NOLINE,           _T("JS_NOLINE")          ),
    std::map<DWORD, tstring>::value_type(JS_RETRYING,         _T("JS_RETRYING")        ),
    std::map<DWORD, tstring>::value_type(JS_RETRIES_EXCEEDED, _T("JS_RETRIES_EXCEEDED")),
    std::map<DWORD, tstring>::value_type(JS_COMPLETED,        _T("JS_COMPLETED")       ),
    std::map<DWORD, tstring>::value_type(JS_CANCELED,         _T("JS_CANCELED")        ),
    std::map<DWORD, tstring>::value_type(JS_CANCELING,        _T("JS_CANCELING")       ),
    std::map<DWORD, tstring>::value_type(JS_ROUTING,          _T("JS_ROUTING")         )
};



static const std::map<DWORD, tstring> s_mapQueueStatuses(
                                                         s_aQueueStatuses,
                                                         s_aQueueStatuses + ARRAY_SIZE(s_aQueueStatuses)
                                                         );

    

//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<DWORD, tstring>::value_type s_aExtendedStatuses[] = {
    std::map<DWORD, tstring>::value_type(0,                        _T("NO_EXTENDED_STATUS")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_DISCONNECTED,       _T("JS_EX_DISCONNECTED")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_INITIALIZING,       _T("JS_EX_INITIALIZING")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_DIALING,            _T("JS_EX_DIALING")           ),
    std::map<DWORD, tstring>::value_type(JS_EX_TRANSMITTING,       _T("JS_EX_TRANSMITTING")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_ANSWERED,           _T("JS_EX_ANSWERED")          ),
    std::map<DWORD, tstring>::value_type(JS_EX_RECEIVING,          _T("JS_EX_RECEIVING")         ),
    std::map<DWORD, tstring>::value_type(JS_EX_LINE_UNAVAILABLE,   _T("JS_EX_LINE_UNAVAILABLE")  ),
    std::map<DWORD, tstring>::value_type(JS_EX_BUSY,               _T("JS_EX_BUSY")              ),
    std::map<DWORD, tstring>::value_type(JS_EX_NO_ANSWER,          _T("JS_EX_NO_ANSWER")         ),
    std::map<DWORD, tstring>::value_type(JS_EX_BAD_ADDRESS,        _T("JS_EX_BAD_ADDRESS")       ),
    std::map<DWORD, tstring>::value_type(JS_EX_NO_DIAL_TONE,       _T("JS_EX_NO_DIAL_TONE")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_FATAL_ERROR,        _T("JS_EX_FATAL_ERROR")       ),
    std::map<DWORD, tstring>::value_type(JS_EX_CALL_DELAYED,       _T("JS_EX_CALL_DELAYED")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_CALL_BLACKLISTED,   _T("JS_EX_CALL_BLACKLISTED")  ),
    std::map<DWORD, tstring>::value_type(JS_EX_NOT_FAX_CALL,       _T("JS_EX_NOT_FAX_CALL")      ),
    std::map<DWORD, tstring>::value_type(JS_EX_PARTIALLY_RECEIVED, _T("JS_EX_PARTIALLY_RECEIVED")),
    std::map<DWORD, tstring>::value_type(JS_EX_HANDLED,            _T("JS_EX_HANDLED")           ),
    std::map<DWORD, tstring>::value_type(JS_EX_CALL_COMPLETED,     _T("JS_EX_CALL_COMPLETED")    ),
    std::map<DWORD, tstring>::value_type(JS_EX_CALL_ABORTED,       _T("JS_EX_CALL_ABORTED")      )
};



static const std::map<DWORD, tstring> s_mapExtendedStatuses(
                                                            s_aExtendedStatuses,
                                                            s_aExtendedStatuses + ARRAY_SIZE(s_aExtendedStatuses)
                                                            );



//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<FAX_ENUM_QUEUE_STATE, tstring>::value_type s_aQueueStates[] = {
    std::map<FAX_ENUM_QUEUE_STATE, tstring>::value_type(FAX_INCOMING_BLOCKED, _T("FAX_INCOMING_BLOCKED")),
    std::map<FAX_ENUM_QUEUE_STATE, tstring>::value_type(FAX_OUTBOX_BLOCKED,   _T("FAX_OUTBOX_BLOCKED")  ),
    std::map<FAX_ENUM_QUEUE_STATE, tstring>::value_type(FAX_OUTBOX_PAUSED,    _T("FAX_OUTBOX_PAUSED")   )
};



static const std::map<FAX_ENUM_QUEUE_STATE, tstring> s_mapQueueStates(
                                                                      s_aQueueStates,
                                                                      s_aQueueStates + ARRAY_SIZE(s_aQueueStates)
                                                                      );




//-----------------------------------------------------------------------------------------------------------------------------------------
static const std::map<FAX_ENUM_DEVICE_STATUS, tstring>::value_type s_aDeviceStatuses[] = {
    std::map<FAX_ENUM_DEVICE_STATUS, tstring>::value_type(FAX_DEVICE_STATUS_POWERED_OFF, _T("FAX_DEVICE_STATUS_POWERED_OFF")),
    std::map<FAX_ENUM_DEVICE_STATUS, tstring>::value_type(FAX_DEVICE_STATUS_SENDING,     _T("FAX_DEVICE_STATUS_SENDING")    ),
    std::map<FAX_ENUM_DEVICE_STATUS, tstring>::value_type(FAX_DEVICE_STATUS_RECEIVING,   _T("FAX_DEVICE_STATUS_RECEIVING")  ),
    std::map<FAX_ENUM_DEVICE_STATUS, tstring>::value_type(FAX_DEVICE_STATUS_RINGING,     _T("FAX_DEVICE_STATUS_RINGING")    )
};



static const std::map<FAX_ENUM_DEVICE_STATUS, tstring> s_mapDeviceStatuses(
                                                                           s_aDeviceStatuses,
                                                                           s_aDeviceStatuses + ARRAY_SIZE(s_aDeviceStatuses)
                                                                           );




//-----------------------------------------------------------------------------------------------------------------------------------------
tstring EventTypeToString(FAX_ENUM_EVENT_TYPE EventType)
{
    std::map<FAX_ENUM_EVENT_TYPE, tstring>::const_iterator citIterator = s_mapEventsTypes.find(EventType);

    if (citIterator == s_mapEventsTypes.end())
    {
        return ToString(EventType);
    }

    return citIterator->second;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring JobEventTypeToString(FAX_ENUM_JOB_EVENT_TYPE JobEventType)
{
    std::map<FAX_ENUM_JOB_EVENT_TYPE, tstring>::const_iterator citIterator = s_mapJobEventsTypes.find(JobEventType);

    if (citIterator == s_mapJobEventsTypes.end())
    {
        return ToString(JobEventType);
    }

    return citIterator->second;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring ConfigEventTypeToString(FAX_ENUM_CONFIG_TYPE ConfigEventType)
{
    std::map<FAX_ENUM_CONFIG_TYPE, tstring>::const_iterator citIterator = s_mapConfigEventsTypes.find(ConfigEventType);

    if (citIterator == s_mapConfigEventsTypes.end())
    {
        return ToString(ConfigEventType);
    }

    return citIterator->second;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring QueueStatusToString(DWORD dwQueueStatus)
{
    std::map<DWORD, tstring>::const_iterator citIterator = s_mapQueueStatuses.find(dwQueueStatus);

    if (citIterator == s_mapQueueStatuses.end())
    {
        return ToString(dwQueueStatus);
    }

    return citIterator->second;
}




//-----------------------------------------------------------------------------------------------------------------------------------------
tstring ExtendedStatusToString(DWORD dwExtendedStatus)
{
    std::map<DWORD, tstring>::const_iterator citIterator = s_mapExtendedStatuses.find(dwExtendedStatus);

    if (citIterator == s_mapExtendedStatuses.end())
    {
        return ToString(dwExtendedStatus);
    }

    return citIterator->second;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring QueueStateToString(FAX_ENUM_QUEUE_STATE QueueState)
{
    std::map<FAX_ENUM_QUEUE_STATE, tstring>::const_iterator citIterator = s_mapQueueStates.find(QueueState);

    if (citIterator == s_mapQueueStates.end())
    {
        return ToString(QueueState);
    }

    return citIterator->second;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
tstring DeviceStatusToString(FAX_ENUM_DEVICE_STATUS DeviceStatus)
{
    std::map<FAX_ENUM_DEVICE_STATUS, tstring>::const_iterator citIterator = s_mapDeviceStatuses.find(DeviceStatus);

    if (citIterator == s_mapDeviceStatuses.end())
    {
        return ToString(DeviceStatus);
    }

    return citIterator->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\faxconstantsnames.h ===
#ifndef __FAX_CONSTANTS_NAMES__
#define __FAX_CONSTANTS_NAMES__



#include <windows.h>
#include <tstring.h>
#include <fxsapip.h>



tstring EventTypeToString(FAX_ENUM_EVENT_TYPE EventType);

tstring JobEventTypeToString(FAX_ENUM_JOB_EVENT_TYPE JobEventType);

tstring ConfigEventTypeToString(FAX_ENUM_CONFIG_TYPE ConfigEventType);

tstring QueueStatusToString(DWORD dwQueueStatus);

tstring ExtendedStatusToString(DWORD dwExtendedStatus);

tstring QueueStateToString(FAX_ENUM_QUEUE_STATE QueueState);

tstring DeviceStatusToString(FAX_ENUM_DEVICE_STATUS DeviceStatus);



#endif // #ifndef __FAX_CONSTANTS_NAMES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\extendedbvt.h ===
#ifndef __C_EXTENDED_BVT_H__
#define __C_EXTENDED_BVT_H__



#include <windows.h>
#include <TestSuite.h>
#include "CPersonalInfo.h"



#define BVT_DIRECTORY_SHARE_NAME _T("FaxExBVT_0adeedb0-8f4a-488d-a0da-9d4998b23e94")



//
// Directories used by the BVT.
//
extern tstring g_tstrBVTDir;
extern tstring g_tstrBVTDirUNC;
extern tstring g_tstrDocumentsDir;
extern tstring g_tstrInboxDir;
extern tstring g_tstrSentItemsDir;
extern tstring g_tstrRoutingDir;

//
// Recipients, used by the BVT.
//
extern DWORD         g_dwRecipientsCount;
extern CPersonalInfo g_aRecipients[];

//
// Used for communication between CSendAndReceive and CSendAndReceiveSetup test cases.
//
extern tstring g_tstrSendingServer;
extern tstring g_tstrReceivingServer;
extern tstring g_tstrNumberToDial;
extern DWORD   g_dwNotificationTimeout;

//
// Designates the creation time of the oldest file in the SentItems, Inbox and Routing directories
// that should be taken into account.
//
extern FILETIME g_TheOldestFileOfInterest;



#endif // #ifndef __C_EXTENDED_BVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\util.cpp ===
#include "Util.h"
#include <winspool.h>
#include <faxreg.h>
#include <ptrs.h>
#include <StringUtils.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
CFileFilterNewerThanAndExtension::CFileFilterNewerThanAndExtension(const FILETIME &OldestAcceptable, const tstring &tstrExtension)
: FilterNewerThan(OldestAcceptable), FilterExtension(tstrExtension)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CFileFilterNewerThanAndExtension::Filter(const WIN32_FIND_DATA &FileData) const
{
    return FilterNewerThan.Filter(FileData) && FilterExtension.Filter(FileData);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Builds a string, representing the OS version.
//
// Parameters:      None.
//
// Return value:    The formated string.
//
// If error occurs, Win32Err exception is thrown.
//
tstring FormatWindowsVersion() throw(Win32Err)
{
    tstringstream WindowsVersionString;

    //
    // Initialize OSVERSIONINFOEX structure.
    //
    OSVERSIONINFOEX OSVersion;
    ::ZeroMemory(&OSVersion, sizeof(OSVERSIONINFOEX));
    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    //
    // Retrieve the version information.
    //
    if (!::GetVersionEx(((OSVERSIONINFO*)&OSVersion)))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("FormatWindowsVersion - GetVersionEx"));
    }

    if (3 == OSVersion.dwMajorVersion && 51 == OSVersion.dwMinorVersion)
    {
        WindowsVersionString << _T("Windows NT 3.51");
    }
    else if (4 == OSVersion.dwMajorVersion)
    {
        if (0 == OSVersion.dwMinorVersion)
        {
            if (VER_PLATFORM_WIN32_NT == OSVersion.dwPlatformId)
            {
                WindowsVersionString << _T("Windows NT 4");
            }
            else
            {
                WindowsVersionString << _T("Windows 95");
            }
        }
        else if (10 == OSVersion.dwMinorVersion)
        {
            WindowsVersionString << _T("Windows 98");
        }
        else if (90 == OSVersion.dwMinorVersion)
        {
            WindowsVersionString << _T("Windows ME");
        }
    }
    else if (5 == OSVersion.dwMajorVersion)
    {
        if (0 == OSVersion.dwMinorVersion)
        {
            WindowsVersionString << _T("Windows 2000");
        }
        else if (1 <= OSVersion.dwMinorVersion)
        {
            WindowsVersionString << _T("Windows XP");
        }

        //
        // Add SKU information.
        //
        if (OSVersion.wSuiteMask & VER_SUITE_PERSONAL)
        {
            //
            // Came up in Windows XP.
            //
            _ASSERT(1 <= OSVersion.dwMinorVersion);

            WindowsVersionString << _T(" Home Edition");
        }
        if (OSVersion.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            WindowsVersionString << _T(" Advanced Server");
        }
        else if (OSVersion.wSuiteMask & VER_SUITE_DATACENTER)
        {
            WindowsVersionString << _T(" Data Center");
        }
        else if (OSVersion.wProductType == VER_NT_WORKSTATION)
        {
            WindowsVersionString << _T(" Professional");
        }
        else if (OSVersion.wProductType == VER_NT_SERVER)
        {
            WindowsVersionString << _T(" Server");
        }
    }

    if (!WindowsVersionString.str().empty())
    {
        //
        // Add build information.
        //
        WindowsVersionString << _T(" (build ") << OSVersion.dwBuildNumber << _T(")");

        if (OSVersion.szCSDVersion && OSVersion.szCSDVersion[0])
        {
            //
            // Add service pack information.
            //
            WindowsVersionString << _T(", ") << OSVersion.szCSDVersion;
        }
    }

    return WindowsVersionString.str();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Determines whether the OS is Windows XP.
//
// Parameters:      None.
//
// Return value:    true if the OS is Windows XP, false otherwise.
//
// If error occurs, Win32Err exception is thrown.
//
bool IsWindowsXP() throw()
{
    DWORD dwVersion     = GetVersion();
    DWORD dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    DWORD dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));
    
    return (dwMajorWinVer == 5 && dwMinorWinVer >= 1);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Determines the SKU of the OS.
//
// Parameters:      None.
//
// Return value:    The OS SKU.
//
// If error occurs, Win32Err exception is thrown.
//
ENUM_WINDOWS_SKU GetWindowsSKU() throw(Win32Err)
{
    //
    // Initialize OSVERSIONINFOEX structure.
    //
    OSVERSIONINFOEX OSVersion;
    ::ZeroMemory(&OSVersion, sizeof(OSVERSIONINFOEX));
    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    //
    // Retrieve the version information.
    //
    if (!::GetVersionEx(((OSVERSIONINFO*)&OSVersion)))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("GetWindowsSKU - GetVersionEx"));
    }

    if (OSVersion.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        //
        // Can't tell SKU for win9x.
        //
        return SKU_UNKNOWN;
    }

    if (OSVersion.dwMajorVersion < 5)
    {
        //
        // Can't tell SKU for NT4.
        //
        return SKU_UNKNOWN;
    }

    //
    // This is the matching between the different SKUs and the constants returned by GetVersionEx
    // Personal 		VER_SUITE_PERSONAL
    // Professional		VER_NT_WORKSTATION
    // Server			VER_NT_SERVER
    // Advanced Server	VER_SUITE_ENTERPRISE
    // DataCanter		VER_SUITE_DATACENTER
    //

    if (OSVersion.wSuiteMask & VER_SUITE_PERSONAL)
    {
        return SKU_PER;
    }
    if (OSVersion.wSuiteMask & VER_SUITE_ENTERPRISE)
    {
        return SKU_ADS;
    }
    if (OSVersion.wSuiteMask & VER_SUITE_DATACENTER)
    {
        return SKU_DTC;
    }
    if (OSVersion.wProductType == VER_NT_WORKSTATION)
    {
        return SKU_PRO;
    }
    if (OSVersion.wProductType == VER_NT_SERVER)
    {
        return SKU_SRV;
    }

    return SKU_UNKNOWN;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Determines whether the OS is "desktop".
//
// Parameters:      None.
//
// Return value:    true if the OS is "desktop", false otherwise.
//
// If error occurs, Win32Err exception is thrown.
//
bool IsDesktop() throw(Win32Err)
{
    ENUM_WINDOWS_SKU SKU = GetWindowsSKU();
    return ((SKU == SKU_PER) || (SKU == SKU_PRO));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Determines whether the specified server is the local machine.
//
// Parameters:      [IN]  tstrServer    Server name.
//
// Return value:    true if the server is local, false otherwise.
//
// If error occurs, Win32Err exception is thrown.
//
bool IsLocalServer(const tstring &tstrServer) throw(Win32Err)
{
    if (tstrServer.empty())
    {
        return true;
    }

    TCHAR tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwComputerNameSize = ARRAY_SIZE(tszComputerName);

    if (!::GetComputerName(tszComputerName, &dwComputerNameSize))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("IsLocalServer - GetComputerName"));
    }

    return _tcsicmp(tszComputerName, tstrServer.c_str()) == 0;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
// Retrieves the name of the fax printer on the specified server.
//
// Parameters:      [IN]  tstrServer    The server name.
//
// Return value:    If the specified server is local, the fax printer name, for example "Fax".
//                  If the specified server is remote, the UNC path, for example "\\MyRemoteServer\FaxShareName".
//
// If error occurs, Win32Err exception is thrown.
//
tstring GetFaxPrinterName(const tstring &tstrServer) throw(Win32Err)
{
    DWORD dwBufferSize    = 0;
    DWORD dwPrintersCount = 0;

    bool bLocal = IsLocalServer(tstrServer);
    
    tstring tstrTemp = bLocal ? _T("") : (_T("\\\\") + tstrServer);

    if (EnumPrinters(
                     PRINTER_ENUM_NAME,
                     const_cast<LPTSTR>(tstrTemp.c_str()),
                     2,
                     NULL,
                     0,
                     &dwBufferSize,
                     &dwPrintersCount
                     ))
    {
        if (dwPrintersCount == 0)
        {
            //
            // There are no printers on the server.
            //
            THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("GetFaxPrinterName - there are no printers on the server"));
        }
        else
        {
            _ASSERT(false);
        }
    }

    DWORD dwEC = GetLastError();

    if (dwEC != ERROR_INSUFFICIENT_BUFFER)
    {
        THROW_TEST_RUN_TIME_WIN32(dwEC, _T("GetFaxPrinterName - EnumPrinters"));
    }

    //
    // Allocate the buffer.
    // The memory is automatically released when aapBuffer goes out of scope.
    //
    aaptr<BYTE> aapBuffer(new BYTE[dwBufferSize]);

    _ASSERT(aapBuffer);

    if (!EnumPrinters(
                      PRINTER_ENUM_NAME,
                      const_cast<LPTSTR>(tstrTemp.c_str()),
                      2,
                      aapBuffer,
                      dwBufferSize,
                      &dwBufferSize,
                      &dwPrintersCount
                      ))
    {
        THROW_TEST_RUN_TIME_WIN32(GetLastError(), _T("GetFaxPrinterName - EnumPrinters"));
    }

    PPRINTER_INFO_2 pPrinterInfo = reinterpret_cast<PPRINTER_INFO_2>(aapBuffer.get());

    for (DWORD dwInd = 0; dwInd < dwPrintersCount; ++dwInd)
    {
        if (!_tcscmp(pPrinterInfo[dwInd].pDriverName, FAX_DRIVER_NAME))
        {
            if (bLocal)
            {
                //
                // Return just the printer name.
                //
                tstrTemp = pPrinterInfo[dwInd].pPrinterName;
            }
            else
            {
                if ((pPrinterInfo[dwInd].Attributes & PRINTER_ATTRIBUTE_SHARED) != PRINTER_ATTRIBUTE_SHARED)
                {
                    THROW_TEST_RUN_TIME_WIN32(ERROR_PRINTER_NOT_FOUND, _T("GetFaxPrinterName - fax printer is not shared"));
                }
                //
                // Combine the UNC path.
                //
                tstrTemp += (tstring(_T("\\")) + pPrinterInfo[dwInd].pShareName);
            }
        
            break;
        }
    }

    if (dwInd == dwPrintersCount)
    {
        //
        // Printer not found.
        //
        THROW_TEST_RUN_TIME_WIN32(ERROR_PRINTER_NOT_FOUND, _T("GetFaxPrinterName - fax printer not found"));
    }

    return tstrTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\dummyfilenamevec.cpp ===
#include "..\..\..\..\FaxBVT\VerifyTiffFiles\FilenameVec.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\util.h ===
#ifndef __UTIL_H__
#define __UTIL_H__



#pragma warning(disable :4786)
#include <vector>
#include <crtdbg.h>
#include <windows.h>
#include <TCHAR.h>
#include <tstring.h>
#include <testruntimeerr.h>
#include <directoryutilities.h>



#define ARRAY_SIZE(ARRAY)       (sizeof(ARRAY) / sizeof((ARRAY)[0]))
#define TWO_32_AS_64(HIGH, LOW) (((DWORDLONG)(HIGH) << 32) | (LOW))



typedef enum {
    SKU_UNKNOWN,
    SKU_PER,
    SKU_PRO,
    SKU_SRV,
    SKU_ADS,
    SKU_DTC
} ENUM_WINDOWS_SKU;



class CFileFilterNewerThanAndExtension : public CFileFilter {

public:

    CFileFilterNewerThanAndExtension(const FILETIME &OldestAcceptable, const tstring &tstrExtension);

    virtual bool Filter(const WIN32_FIND_DATA &FileData) const;

private:

    CFileFilterNewerThan FilterNewerThan;
    CFileFilterExtension FilterExtension;
};



tstring FormatWindowsVersion() throw (Win32Err);
bool IsWindowsXP() throw (Win32Err);
ENUM_WINDOWS_SKU GetWindowsSKU() throw (Win32Err);
bool IsDesktop() throw (Win32Err);
bool IsLocalServer(const tstring &tstrServer) throw (Win32Err);
tstring GetFaxPrinterName(const tstring &tstrServer) throw (Win32Err);



#endif // #ifndef __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\bvt.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//


#pragma warning(disable :4786)

#include "bvt.h"
#include <iniutils.h>

// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
BOOL    g_fFaxServer = FALSE;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
BOOL    g_fNT4OrLater = FALSE;

//
// Bvt files
//
LPTSTR  g_szBvtDir     = NULL; //TEXT("C:\\CometBVT\\FaxBvt");
LPTSTR  g_szBvtDocFile = NULL;
LPTSTR  g_szBvtPptFile = NULL;
LPTSTR  g_szBvtXlsFile = NULL;

//
// global recipient profiles (used in test cases)
//
FAX_PERSONAL_PROFILE g_RecipientProfile[3] = {0,0,0};
std::map<tstring, tstring>  g_RecipientMap[3];
DWORD g_RecipientsCount = sizeof(g_RecipientProfile) / sizeof(FAX_PERSONAL_PROFILE);

//
// extern, input ini file path
//
extern TCHAR* g_InputIniFile;

#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR TEXT("true")

//
//
//
BOOL GetIsThisNT4OrLater(void)
{
	DWORD dwOsVersion = ::GetVersion();
	_ASSERTE(dwOsVersion);

	//
	// check if OS is NT4 or later
	//

	if (dwOsVersion >= 0x80000000)
	{
		// Win32 with Windows 3.1 or Win9x
        // Fax Server invocation
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	// Windows NT/2000
	DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwOsVersion)));
	if (dwWindowsMajorVersion < 4)
	{
		// NT 3.??
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	// Windows NT4 or later
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax SERVER (NT4\\NT5) Tests\r\n"),
			TEXT(__FILE__),
			__LINE__
			);
	return(TRUE);
}


//
// GetBoolFromStr:
//
static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
		    ::lgLogError(
                LOG_SEV_1,
                TEXT("\n3rd param is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}

//
// static function, set recipient's default profile
//
static void SetDefaultRecipientProfile(const DWORD dwIndex)
{  
	
	_ASSERTE( (dwIndex >= 0) && (dwIndex < g_RecipientsCount));
	
	g_RecipientProfile[dwIndex].lptstrName = TEXT("Default Recipient Number");
    g_RecipientProfile[dwIndex].lptstrFaxNumber = NULL;
	g_RecipientProfile[dwIndex].lptstrCompany = TEXT("Default Recipient Number Company");               
    g_RecipientProfile[dwIndex].lptstrStreetAddress = TEXT("Default Recipient Number Company");               
    g_RecipientProfile[dwIndex].lptstrCity = TEXT("Default Recipient Number City");               
    g_RecipientProfile[dwIndex].lptstrState = TEXT("Default Recipient Number State");               
    g_RecipientProfile[dwIndex].lptstrZip = TEXT("Default Recipient Number Zip");               
    g_RecipientProfile[dwIndex].lptstrCountry = TEXT("Default Recipient Number Country");               
    g_RecipientProfile[dwIndex].lptstrTitle = TEXT("Default Recipient Number Title");               
    g_RecipientProfile[dwIndex].lptstrDepartment = TEXT("Default Recipient Number Department");               
    g_RecipientProfile[dwIndex].lptstrOfficeLocation = TEXT("Default Recipient Number OfficeLocation");               
    g_RecipientProfile[dwIndex].lptstrHomePhone = TEXT("Default Recipient Number HomePhone");               
    g_RecipientProfile[dwIndex].lptstrOfficePhone = TEXT("Default Recipient Number OfficePhone");               
    g_RecipientProfile[dwIndex].lptstrEmail = TEXT("Default Recipient Number Email");               
    g_RecipientProfile[dwIndex].lptstrBillingCode = TEXT("Default Recipient Number BillingCode");               
    g_RecipientProfile[dwIndex].lptstrTSID = TEXT("Default Recipient Number TSID");
}


// Forward declerations:

/**/
static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
);


// Commented out due to EranY checkin (FaxSetPort API is no longer)
// this setup is now replaced by GuyM com setup (seperate exe) 
//
// SetupPort:
//	Private module function used to set port configuration.
//  See end of file.
// 
static BOOL SetupPort(
	IN HANDLE				hFaxSvc,
	IN PFAX_PORT_INFO_EX	pPortInfo,
	IN BOOL				    bSend,
	IN BOOL				    bReceive,
	IN LPCTSTR				szTsid,
	IN LPCTSTR				szCsid,
	IN LPCTSTR				szReceiveDir
	);

//
// SendRegularFax: 
//	Private module function used to send a fax
//  See end of file.
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);


//
// SendBroadcastFax: 
//	Private module function used to send a broadcast (3 * same recipient)
//  See end of file.
//
static BOOL SendBroadcastFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// PollJobAndVerify: 
//	Private module function used to poll job status
//  See end of file.
//
static BOOL PollJobAndVerify(
    HANDLE		/* IN */	hFaxSvc, 
    DWORDLONG	/* IN */	dwMsgId
);


//
// InitRecipientProfiles:
//  Initializes three recipients profiles with hard coded user info
//  according to 
//
VOID InitRecipientProfiles()
{
    DWORD dwIndex;

	for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
	{
		g_RecipientProfile[dwIndex].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
	}

	try
	{
   		//
		// Read the list of recipients records from ini file.
		std::vector<tstring> RecipientsList =  INI_GetSectionList( g_InputIniFile,
					 										   RECIPIENTS_SECTION);

		for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
		{
			if(RecipientsList.size() > dwIndex )
			{
				tstring tstrRecipientEntry = RecipientsList[dwIndex];
				g_RecipientMap[dwIndex] = INI_GetSectionEntries(g_InputIniFile,
																tstrRecipientEntry);

				if(!g_RecipientMap[dwIndex].empty())
				{
					std::map<tstring, tstring>::iterator iterMap;

					iterMap = g_RecipientMap[dwIndex].find(TEXT("Name"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrName = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("FaxNumber"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrFaxNumber = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("Company"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrCompany = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("StreetAddress"));
    				if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrStreetAddress = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("City"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrCity = const_cast<TCHAR*>((iterMap->second).c_str());
					}
      
					iterMap = g_RecipientMap[dwIndex].find(TEXT("State"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrState = const_cast<TCHAR*>((iterMap->second).c_str());
					}
           
					iterMap = g_RecipientMap[dwIndex].find(TEXT("Zip"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrZip = const_cast<TCHAR*>((iterMap->second).c_str());
					}
           
					iterMap = g_RecipientMap[dwIndex].find(TEXT("Country"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrCountry = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("Title"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrTitle = const_cast<TCHAR*>((iterMap->second).c_str());
					}
             
           			iterMap = g_RecipientMap[dwIndex].find(TEXT("Department"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrDepartment = const_cast<TCHAR*>((iterMap->second).c_str());
					}

					iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficeLocation"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrOfficeLocation = const_cast<TCHAR*>((iterMap->second).c_str());
					} 
					
					iterMap = g_RecipientMap[dwIndex].find(TEXT("HomePhone"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrHomePhone = const_cast<TCHAR*>((iterMap->second).c_str());
					} 

					iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficePhone"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrOfficePhone = const_cast<TCHAR*>((iterMap->second).c_str());
					} 
					
					iterMap = g_RecipientMap[dwIndex].find(TEXT("InternetMail"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrEmail = const_cast<TCHAR*>((iterMap->second).c_str());
					} 
          
					iterMap = g_RecipientMap[dwIndex].find(TEXT("BillingCode"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrBillingCode = const_cast<TCHAR*>((iterMap->second).c_str());
					} 

					iterMap = g_RecipientMap[dwIndex].find(TEXT("TSID"));
					if(iterMap != g_RecipientMap[dwIndex].end())
					{
						g_RecipientProfile[dwIndex].lptstrTSID = const_cast<TCHAR*>((iterMap->second).c_str());
					} 
				}
				else
				{
					SetDefaultRecipientProfile(dwIndex);
				}

			}
			else
			{
				SetDefaultRecipientProfile(dwIndex);
			}

		}
	}
	catch(Win32Err& err)
	{
	    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\r\nException in InitRecipientProfiles:\r\n%s\r\n"),
			    TEXT(__FILE__),
			    __LINE__,
				err.description()
				);

		// set default recipients profile
		for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
		{
			SetDefaultRecipientProfile(dwIndex);
		}
		
	}

}

 
//
// DeleteFilesInDir
//
static
BOOL
DeleteFilesInDir(
	LPCTSTR		szDir
    )
{
    BOOL                fRetVal = FALSE;
    DWORD               dwFileAttrib = -1;
    BOOL                fHasDirectoryAttrib = FALSE;
    CFilenameVector*    pDirFileVector = NULL;    
    DWORD ec = 0;

	_ASSERTE(NULL != szDir);

    dwFileAttrib = ::GetFileAttributes(szDir);
    if ( -1 != dwFileAttrib)
    {
        // got file attributes for szDir
        fHasDirectoryAttrib = FILE_ATTRIBUTE_DIRECTORY & dwFileAttrib;
        if ( !fHasDirectoryAttrib )
        {
            // szDir is not a directory
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\r\nGetFileAttributes returned %d => %s is not a directory\r\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwFileAttrib,
                szDir
			    );
            goto ExitFunc;
        }
        if (FALSE == ::GetTiffFilesOfDir(szDir, &pDirFileVector))
        {
            goto ExitFunc;
        }
        if (FALSE == ::DeleteVectorFiles(pDirFileVector))
        {
            goto ExitFunc;
        }
    }
    else
    {
        // GetFileAttributes failed
        ec = ::GetLastError();
        if ((ERROR_PATH_NOT_FOUND != ec) && (ERROR_FILE_NOT_FOUND != ec))
        {
            // error
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\r\nGetFileAttributes failed with GetLastError()=%d\r\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    ec
			    );
            goto ExitFunc;
        }
        // we do not consider ERROR_PATH_NOT_FOUND and ERROR_FILE_NOT_FOUND an error
    }
    fRetVal = TRUE;

ExitFunc:
    if (pDirFileVector)
    {
        ::FreeVector(pDirFileVector);
        delete(pDirFileVector);
    }
    return(fRetVal);
}

//
// SetBvtGlobalFileVars:
//  Sets BVT global variables (g_szBvtDir, g_szBvtDocFile, g_szBvtPptFile, g_szBvtXlsFile)
//  according to szBvtDir command line parameter
//
static
BOOL
SetBvtGlobalFileVars(
	LPCTSTR		szBvtDir
    )                  
{
    BOOL fRetVal = FALSE;
    DWORD dwSize = 0;

    _ASSERTE(szBvtDir);

    //
    // setup Bvt files global parameters 
    //
    g_szBvtDir = (LPTSTR)szBvtDir;
    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_DOC_FILE) + 1)*sizeof(TCHAR);
    g_szBvtDocFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtDocFile)
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtDocFile, dwSize);
    _stprintf(g_szBvtDocFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_DOC_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_PPT_FILE) + 1)*sizeof(TCHAR);
    g_szBvtPptFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtPptFile)
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtPptFile, dwSize);
    _stprintf(g_szBvtPptFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_PPT_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_XLS_FILE) + 1)*sizeof(TCHAR);
    g_szBvtXlsFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtXlsFile)
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtXlsFile, dwSize);
    _stprintf(g_szBvtXlsFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_XLS_FILE);

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("CometBVT files:\r\ng_szBvtDir=%s\r\ng_szBvtDocFile=%s\r\ng_szBvtPptFile=%s\r\ng_szBvtXlsFile=%s\r\n"),
		g_szBvtDir,
		g_szBvtDocFile,
		g_szBvtPptFile,
		g_szBvtXlsFile
		);

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(g_szBvtDocFile);
        g_szBvtDocFile = NULL;
        free(g_szBvtPptFile);
        g_szBvtPptFile = NULL;
        free(g_szBvtXlsFile);
        g_szBvtXlsFile = NULL;
        // we didn't alloc g_szBvtDir so we don't free
    }
    return(fRetVal);
}

//
// EmptyDirectories:
//  Deletes files in szReceiveDir, szSentDir and szInboxArchiveDir directories
//  if these directories exist.
//  Note - func does not consider it an error if the directories do not exist.
//
static
BOOL
EmptyDirectories(
	LPCTSTR		szReceiveDir,
	LPCTSTR		szSentDir,
	LPCTSTR		szInboxArchiveDir
    )
{
    BOOL                fRetVal = FALSE;

	_ASSERTE(NULL != szReceiveDir);
	_ASSERTE(NULL != szSentDir);
	_ASSERTE(NULL != szInboxArchiveDir);

    // empty the "received faxes" dir 
    if (FALSE == ::DeleteFilesInDir(szReceiveDir))
    {
        goto ExitFunc;
    }

    // empty the "sent faxes" dir 
    if (FALSE == ::DeleteFilesInDir(szSentDir))
    {
        goto ExitFunc;
    }

    // empty the "Inbox Archive" dir 
    if (FALSE == ::DeleteFilesInDir(szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);

}

//
//
//
static
BOOL
GetIsThisServerBvt(
    LPCTSTR szServerName, 
    BOOL*   pfServerBvt
    )
{
    BOOL fRetVal = FALSE;

    _ASSERTE(szServerName);
    _ASSERTE(pfServerBvt);

    TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPTSTR  szComputerNameUP = NULL;
    LPTSTR  szServerNameUP = NULL;
    ZeroMemory(szComputerName, (MAX_COMPUTERNAME_LENGTH+1)*sizeof(TCHAR));

    if (FALSE == ::GetComputerName(szComputerName, &dwComputerNameSize))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\r\nGetComputerName returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    // convert to upper case
    szServerNameUP = ::_tcsdup(szServerName);
    if (NULL == szServerNameUP)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\r\n_tcsdup returned NULL with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    // NOTE: upper case conversion is in place
    // no value reserved for error
    szServerNameUP = ::_tcsupr(szServerNameUP); 
    szComputerNameUP = ::_tcsupr(szComputerName); 

    if (0 == ::_tcscmp(szServerNameUP, szComputerNameUP))
    {
        // Fax Server invocation
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("\r\nRunning Fax SERVER Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
			);
        (*pfServerBvt) = TRUE;
    }
    else
    {
        // Fax Client invocation
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("\r\nRunning Fax CLIENT Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
			);
        (*pfServerBvt) = FALSE;
    }

    fRetVal = TRUE;

ExitFunc:
    free(szServerNameUP);
    return(fRetVal);
}


//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber1,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage,
    LPCTSTR     szReceiveDir,
    LPCTSTR     szSentDir,
    LPCTSTR     szInboxArchiveDir,
    LPCTSTR     szReferenceDir,
    LPCTSTR     szBvtDir
    )
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber1);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);
	_ASSERTE(NULL != szReceiveDir);
	_ASSERTE(NULL != szSentDir);
	_ASSERTE(NULL != szInboxArchiveDir);
	_ASSERTE(NULL != szReferenceDir);
	_ASSERTE(NULL != szBvtDir);

	BOOL                fRetVal = FALSE;
	HANDLE              hFaxSvc = NULL;
	int                 nPortIndex = 0;
	DWORD               dwNumFaxPorts = 0;
	PFAX_PORT_INFO_EX	pFaxPortsConfig = NULL;

    PFAX_OUTBOX_CONFIG      pOutboxConfig = NULL;
    PFAX_ARCHIVE_CONFIG     pArchiveConfig = NULL;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgInitializeLogger failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("BVT suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgBeginSuite failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

    //
    // initialize global recipient profiles
    //
    InitRecipientProfiles();

	// log command line params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("CometBVT params:\r\n\tszServerName=%s\r\n\tszFaxNumber1=%s\r\n\tszFaxNumber2=%s\r\n\tszDocument=%s\r\n\tszCoverPage=%s\r\n\tszReceiveDir=%s\r\n\tszSentDir=%s\r\n\tszInboxArchiveDir=%s\r\n\tszReferenceDir=%s\r\n\tszBvtDir=%s\r\n"),
		szServerName,
		szFaxNumber1,
		szFaxNumber2,
		szDocument,
		szCoverPage,
        szReceiveDir,
        szSentDir,
        szInboxArchiveDir,
        szReferenceDir,
        szBvtDir
		);

    //
    // Empty fax file directories
    //
    if (FALSE == EmptyDirectories(szReceiveDir, szSentDir, szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    //
    // Set bvt global file variables
    //
    if (FALSE == SetBvtGlobalFileVars(szBvtDir))
    {
        goto ExitFunc;
    }

	//
	// Copy the coverpage to the Personal CP directory
	//
	if (FALSE == PlacePersonalCP(szCoverPage))
	{
        goto ExitFunc;
	}

	//
	// Setup fax service
	//
	if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\r\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			szServerName,
			::GetLastError()
			);
        goto ExitFunc;
	}

/*  TO DO: need to redo after EranY checkin  (start) */

    //
    // Setup Service Outbox configuration
    //
    if (!FaxGetOutboxConfiguration(hFaxSvc, &pOutboxConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pOutboxConfig);

    ::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned:\r\ndwSizeOfStruct=%d\r\nbAllowPersonalCP=%d\r\nbUseDeviceTSID=%d\r\ndwRetries=%d\r\ndwRetryDelay=%d\r\r\ndtDiscountStart.Hour=%i\r\ndtDiscountStart.Minute=%i\r\ndtDiscountEnd.Hour=%i\r\ndtDiscountEnd.Minute=%i\r\ndwAgeLimit=%d\r\nbBranding=%d"),
		TEXT(__FILE__),
		__LINE__,
        pOutboxConfig->dwSizeOfStruct,
        pOutboxConfig->bAllowPersonalCP,
        pOutboxConfig->bUseDeviceTSID,
        pOutboxConfig->dwRetries,
        pOutboxConfig->dwRetryDelay,
        pOutboxConfig->dtDiscountStart.Hour,
        pOutboxConfig->dtDiscountStart.Minute,
        pOutboxConfig->dtDiscountEnd.Hour,
        pOutboxConfig->dtDiscountEnd.Minute,
        pOutboxConfig->dwAgeLimit,
        pOutboxConfig->bBranding
		);

    pOutboxConfig->bAllowPersonalCP = TRUE;
    pOutboxConfig->dwRetries = 0;
    pOutboxConfig->bBranding = FALSE;


    if (!FaxSetOutboxConfiguration(hFaxSvc, pOutboxConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

	//
    // Setup Service Queue configuration
    //
    if (!FaxSetQueue(hFaxSvc, 0))  // inbox and outbox not blocked, outbox not paused
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetQueue returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    //
    // Setup Service Inbox Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, &pArchiveConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
		TEXT(__FILE__),
		__LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
		);

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szInboxArchiveDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


	// Workaround for EdgeBug#8969
	pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);
 
    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, pArchiveConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);
    pArchiveConfig = NULL;

    //
    // Setup Service SentItems Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, &pArchiveConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
		TEXT(__FILE__),
		__LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
		);

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szSentDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


	// Workaround for EdgeBug#8969
	pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, pArchiveConfig))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);

    pArchiveConfig = NULL;

	//
	// Setup the two ports
	//

    // Retrieve the fax ports configuration
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPortsEx returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pFaxPortsConfig);

	// make sure we have at least TEST_MIN_PORTS ports for test
	if (BVT_MIN_PORTS > dwNumFaxPorts)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\r\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\r\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			BVT_MIN_PORTS
			);
        goto ExitFunc;
	}
	else
	{
		::lgLogDetail(
			LOG_X, 
			1,
			TEXT("FILE:%s LINE:%d\r\ndwNumFaxPorts=%d\r\nTEST_MIN_PORTS=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			BVT_MIN_PORTS
			);
	}
	// we know there are at least 2 (==TEST_MIN_PORTS) devices

	::lgLogDetail(
		LOG_X, 
		1,
		TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration BEFORE setting\r\n"),
		TEXT(__FILE__),
		__LINE__
		);
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);

	// Set 1st device as Send only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[0], 
					TRUE,   //bSend
                    FALSE,  //bReceive
					szFaxNumber1, 
					szFaxNumber1,
                    szReceiveDir
					)
		)
	{
		goto ExitFunc;
	}

	// Set 2nd device as Receive only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[1], 
                    FALSE,  //bSend
					TRUE,   //bReceive
					szFaxNumber2, 
					szFaxNumber2,
                    szReceiveDir
					)
		)
	{
		goto ExitFunc;
	}

	// set all other devices as Receive=No and Send=No
	// NOTE: nPortIndex is 0 based
	for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
	{
		if (FALSE == SetupPort(
						hFaxSvc, 
						&pFaxPortsConfig[nPortIndex], 
                        FALSE,  //bSend
					    FALSE,  //bReceive
						DEV_TSID, 
						DEV_CSID,
                        szReceiveDir
						)
			)
		{
			goto ExitFunc;
		}
	}

    FaxFreeBuffer(pFaxPortsConfig);
    pFaxPortsConfig = NULL;

    // Retrieve the fax ports configuration (to print new settings)
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pFaxPortsConfig);
	::lgLogDetail(
		LOG_X, 
		1,
		TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration AFTER setting\r\n"),
		TEXT(__FILE__),
		__LINE__
		);
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);


    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    if (FALSE == GetIsThisServerBvt(szServerName, &g_fFaxServer))
    {
        // GetIsThisServerBvt failed
        goto ExitFunc;
    }

    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    g_fNT4OrLater = GetIsThisNT4OrLater();
	::lgLogDetail(
		LOG_X, 
		1,
		TEXT("FILE:%s LINE:%d\r\ng_fNT4OrLater=%d\r\n"),
		TEXT(__FILE__),
		__LINE__,
		g_fNT4OrLater
		);

	fRetVal = TRUE;

ExitFunc:
    ::FaxFreeBuffer(pOutboxConfig);
    ::FaxFreeBuffer(pArchiveConfig);
	::FaxFreeBuffer(pFaxPortsConfig);
	if (FALSE == ::FaxClose(hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\r\nFaxClose returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}


//
// TestCase1:
//	Send a fax + CP.
//
BOOL WINAPIV TestCase1(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#1: Send a fax + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase2:
//	Send just a CP.
//
BOOL WINAPIV TestCase2(	
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	LPCTSTR szDocumentNULL = NULL;

	::lgBeginCase(
		2,
		TEXT("TC#2: Send just a CP")
		);

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocumentNULL, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase3:
//	Send a fax with no CP.
//
BOOL WINAPIV TestCase3(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);

	BOOL fRetVal = FALSE;
	LPCTSTR szCoverPageNULL = NULL;

	::lgBeginCase(
		3,
		TEXT("TC#3: Send a fax with no CP")
		);

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPageNULL);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase4:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL WINAPIV TestCase4(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		4,
		TEXT("TC#4: Send a broadcast (doc + CP)")
		);
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\r\nFaxNumber=%s\r\nDocument=%s\r\nCoverPage=%s\r\n"),
		szServerName,
		szFaxNumber2,
		szDocument,
		szCoverPage
		);

	fRetVal = SendBroadcastFax(
						szServerName,
						szFaxNumber2,
						szDocument,
						szCoverPage
						);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase5:
//	Send a broadcast of only CPs (3 times the same recipient).
//
BOOL WINAPIV TestCase5(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		5,
		TEXT("TC#5: Send a broadcast of only CPs")
		);
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\r\nFaxNumber=%s\r\nDocument=NULL\r\nCoverPage=%s\r\n"),
		szServerName,
		szFaxNumber2,
		szCoverPage
		);

	fRetVal = SendBroadcastFax(
						szServerName,
						szFaxNumber2,
						NULL,
						szCoverPage
						);

	::lgEndCase();
	return(fRetVal);
}


//
// TestCase6:
//	Send a broadcast without CPs (3 times the same recipient).
//
BOOL WINAPIV TestCase6(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		6,
		TEXT("TC#6: Send a broadcast without CPs")
		);
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\r\nFaxNumber=%s\r\nDocument=%s\r\nCoverPage=NULL\r\n"),
		szServerName,
		szFaxNumber2,
		szDocument
		);

	fRetVal = SendBroadcastFax(
						szServerName,
						szFaxNumber2,
						szDocument,
						NULL
						);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase7:
//	Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
BOOL WINAPIV TestCase7(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		7,
		TEXT("TC#7: Send a fax (*.doc file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtDocFile, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase8:
//	Send a fax (*.ppt file = BVT_PPT_FILE) + CP.
//
BOOL WINAPIV TestCase8(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		8,
		TEXT("TC#8: Send a fax (*.ppt file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtPptFile, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase9:
//	Send a fax (*.xls file = BVT_XLS_FILE) + CP.
//
BOOL WINAPIV TestCase9(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		9,
		TEXT("TC#9: Send a fax (*.xls file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtXlsFile, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase10:
//  Compare all received faxes (*.tif files) in directory szReceiveDir 
//  with the reference (*.tif) files in szReferenceDir
//
BOOL WINAPIV TestCase10(
    LPTSTR     /* IN */    szReceiveDir,
    LPTSTR     /* IN */    szReferenceDir
    )
{
	_ASSERTE(NULL != szReceiveDir);
	_ASSERTE(NULL != szReferenceDir);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		10,
		TEXT("TC#10: Compare RECEIVED Files To Reference Files")
		);

    // sleep a little - to allow for routing of last sent file.
    ::lgLogDetail(
        LOG_X,
        4,
        TEXT("Sleeping for 20 sec (to allow for routing of last received file)\r\n")
        );
    Sleep(20000);

    if (FALSE == DirToDirTiffCompare(szReceiveDir, szReferenceDir, FALSE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szReceiveDir,
            szReferenceDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}

//
// TestCase11:
//  Compare all archived (sent) faxes (*.tif files) in directory szSentDir 
//  with the reference (*.tif) files in szReferenceDir
//
BOOL WINAPIV TestCase11(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReferenceDir
    )
{
	_ASSERTE(NULL != szSentDir);
	_ASSERTE(NULL != szReferenceDir);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		11,
		TEXT("TC#11: Compare (archived) SENT Files To Reference Files - with skip first line")
		);

    if (FALSE == DirToDirTiffCompare(szSentDir, szReferenceDir, TRUE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szSentDir,
            szReferenceDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// TestCase12:
//  Compare all archived incoming faxes (*.tif files) in directory szInboxArchiveDir 
//  with the reference (*.tif) files in szReferenceDir
//
BOOL WINAPIV TestCase12(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReferenceDir
    )
{
	_ASSERTE(NULL != szInboxArchiveDir);
	_ASSERTE(NULL != szReferenceDir);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		12,
		TEXT("TC#12: Compare archived INCOMING Files To Reference Files")
		);

    if (FALSE == DirToDirTiffCompare(szInboxArchiveDir, szReferenceDir, FALSE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szInboxArchiveDir,
            szReferenceDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL WINAPIV TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgEndSuite returned FALSE\r\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgCloseLogger returned FALSE\r\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}


/**/

// Commented out due to EranY checkin (FaxSetPort API is no longer)
// this setup is now replaced by GuyM com setup (seperate exe) 
//
// SetupPort:
//	Private module function, used to set port configuration.
// 
// Parameters:
//	hFaxSvc			IN parameter.
//					A handle to the Fax service.
//
//	pPortInfo		IN parameter.
//					A pointer to the original port configuration, as returned 
//					from a call to FaxGetPort or FaxEnumPorts.
//
//	dwFlags			IN parameter.
//					Bit flags that specify the new capabilities of the fax port.
//					See FAX_PORT_INFO for more information.
//
//	szTsid			IN parameter.
//					A string that specifies the new transmitting station identifier.
//
//	szCsid			IN parameter.
//					A string that specifies the new called station identifier.
//
//	szReceiveDir	IN parameter
//					Name of "received faxes" directory to be used in tests.
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort(
	IN HANDLE				hFaxSvc,
	IN PFAX_PORT_INFO_EX	pPortInfo,
	IN BOOL				    bSend,
	IN BOOL				    bReceive,
	IN LPCTSTR				szTsid,
	IN LPCTSTR				szCsid,
	IN LPCTSTR				szReceiveDir
	)
{
	BOOL    fRetVal = FALSE;
	HANDLE  hPort = NULL;
    DWORD   dwRoutingInfoSize = 0;
    BYTE*   pRoutingInfo = NULL;
    LPDWORD pdwRoutingInfoMask =NULL;
    LPWSTR  szRoutingDir = NULL;

	// check in params
	_ASSERTE(NULL != hFaxSvc);
	_ASSERTE(NULL != pPortInfo);
	_ASSERTE(NULL != szTsid);
	_ASSERTE(NULL != szCsid);
	_ASSERTE(NULL != szReceiveDir);

	// Set pPortInfo as required
	pPortInfo->bSend        = bSend;
    pPortInfo->ReceiveMode  = bReceive ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF;
	pPortInfo->lptstrTsid   = (LPTSTR)szTsid;
	pPortInfo->lptstrCsid   = (LPTSTR)szCsid;

    // get the device Id
	DWORD dwDeviceId = pPortInfo->dwDeviceID;

	// set the device configuration
	if(!FaxSetPortEx(hFaxSvc, dwDeviceId, pPortInfo))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetPortEx for dwDeviceId=%d returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
            dwDeviceId,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// open the port for configuration (we need this for setting routing info)
	if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
    // set device inbound "StoreInFolder" routing 
	//
	// this info is read as UNICODE on the server
	// so we take the TCHAR string szReceiveDir and "convert" it to unicode
	//
    dwRoutingInfoSize = sizeof(DWORD) + (sizeof(WCHAR)*(::_tcslen(szReceiveDir)+1)); // MS StoreInFolder routing method expects DWORD followed by UNICODE string
    pRoutingInfo = (BYTE*) malloc(dwRoutingInfoSize);
    if (NULL == pRoutingInfo)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\r\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
		goto ExitFunc;
    }
	ZeroMemory(pRoutingInfo, dwRoutingInfoSize);
    pdwRoutingInfoMask = (LPDWORD)pRoutingInfo;
    (*pdwRoutingInfoMask) = LR_STORE;  // to indicate StoreInFolder Routing Method is active
    szRoutingDir = (LPWSTR)(pRoutingInfo + sizeof(DWORD)); //szRoutingDir is UNICODE

#ifndef _UNICODE
	// ANSI //

	// need to "convert" szReceiveDir into UNICODE (szRoutingDir);
	if (!::MultiByteToWideChar(
						CP_ACP, 
						0, 
						szReceiveDir, 
						-1, 
						szRoutingDir, 
						(dwRoutingInfoSize - sizeof(DWORD))
						)
	   )
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed with err=0x%8X\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

#else
	// UNICODE //

	::_tcscpy(szRoutingDir, szReceiveDir);
    if (0 != ::_tcscmp(szRoutingDir, szReceiveDir))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d tcscmp returned FALSE szRoutingDir=%s szReceiveDir=%s\r\n"),
			TEXT(__FILE__),
			__LINE__,
            szRoutingDir,
            szReceiveDir
			);
		goto ExitFunc;
    }

#endif

	if(!FaxSetRoutingInfo(
			hPort,
			REGVAL_RM_FOLDER_GUID,
			pRoutingInfo,
			dwRoutingInfoSize
			)
	  )
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxRouteSetRoutingInfo returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	if(!FaxEnableRoutingMethod(
			hPort,
			REGVAL_RM_FOLDER_GUID,
			TRUE
			)
	  )
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnableRoutingMethod returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
    free(pRoutingInfo);
	if (FALSE == ::FaxClose(hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\r\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}

//
// SendRegularFax:
//	Sends a fax from using the UI.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
	IN LPCTSTR			szServerName,
	IN LPCTSTR			szFaxNumber,
	IN LPCTSTR			szDocument,
	IN LPCTSTR			szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);

	BOOL				fRetVal = FALSE;
	HANDLE				hFaxSvc = NULL;
	PFAX_COVERPAGE_INFO	pCPInfo = NULL;
    PFAX_JOB_ENTRY_EX   pFaxJobs = NULL;
    DWORD               dwNumOfJobs = 0;
	DWORDLONG			dwlMsgId = 0;
	DWORD				dwErr = 0;
    PFAX_JOB_ENTRY      pJobEntry = NULL;

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("\nServer=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

    //
	// use UI to send the fax
	//
    if (FALSE == ::SendFaxUsingPrintUI(szServerName, szFaxNumber, szDocument, szCoverPage, 1, g_fFaxServer))
    {
        goto ExitFunc;
    }

    //
    // get our job id
    //
    Sleep(2000);

    if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxConnectFaxServer failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}
    if (FALSE == ::FaxEnumJobsEx(hFaxSvc, JT_SEND | JT_RECEIVE, &pFaxJobs, &dwNumOfJobs))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxEnumJobsEx failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
    }
    if (NULL == pFaxJobs)
    {
        // something is wrong. our job disappeared.
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\npFaxJobs=NULL and dwNumOfJobs=%d"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
    }
    switch (dwNumOfJobs) 
    {
    case 0:
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nToo few (%d) jobs in queue\n"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
        break;

    case 1:
        // we assume this job is ours.
        if (JT_SEND != pFaxJobs[0].pStatus->dwJobType)
		{
           // something is wrong. this isn't our job.
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n Only one job in queue but JobType=%d (!=JT_SEND)\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFaxJobs[0].pStatus->dwJobType
			    );
			goto ExitFunc;
		}
        dwlMsgId = pFaxJobs[0].dwlMessageId;
        break;

    case 2:
        // we assume one job is our send job and the other is the corresponding receive job
        if (JT_SEND == pFaxJobs[0].pStatus->dwJobType)
        {
            // we assume pFaxJobs[0] is our send job and check that pFaxJobs[1] is receive
            if (JT_RECEIVE != pFaxJobs[1].pStatus->dwJobType)
            {
                // something is wrong.
		        ::lgLogError(
			        LOG_SEV_1,
			        TEXT("FILE:%s LINE:%d\nTwo jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\n"),
			        TEXT(__FILE__),
			        __LINE__,
                    pFaxJobs[0].pStatus->dwJobType,
                    pFaxJobs[1].pStatus->dwJobType
			        );
		        goto ExitFunc;
            }
            dwlMsgId = pFaxJobs[0].dwlMessageId;
            break;
        }
        else if (JT_SEND == pFaxJobs[1].pStatus->dwJobType)
        {
            // we assume pFaxJobs[1] is our send job and check that pFaxJobs[0] is receive
            if (JT_RECEIVE != pFaxJobs[0].pStatus->dwJobType)
            {
                // something is wrong.
		        ::lgLogError(
			        LOG_SEV_1,
			        TEXT("FILE:%s LINE:%d\nTwo jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\n"),
			        TEXT(__FILE__),
			        __LINE__,
                    pFaxJobs[0].pStatus->dwJobType,
                    pFaxJobs[1].pStatus->dwJobType
			        );
		        goto ExitFunc;
            }
            dwlMsgId = pFaxJobs[1].dwlMessageId;
            break;
        }
        else
        {
            // something is wrong. neither job is a send job
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\nTwo jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFaxJobs[0].pStatus->dwJobType,
                pFaxJobs[1].pStatus->dwJobType
			    );
		    goto ExitFunc;
        }
        break;

    default:
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nToo many (%d) jobs in queue\n"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
        break;
    }

    //
    // Poll the queued job status 
    //  this is for now
    //
    _ASSERTE(0 != dwlMsgId);
    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwlMsgId))
    {
		goto ExitFunc;
    }

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// SendBroadcastFax:
//	Sends a broadcst fax using the UI.
//  Broadcast it to 3 times the same recipient.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
static BOOL SendBroadcastFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);

	BOOL				fRetVal = FALSE;
	HANDLE				hFaxSvc = NULL;
	PFAX_COVERPAGE_INFO	pCPInfo = NULL;
    PFAX_JOB_ENTRY_EX   pFaxJobs = NULL;
    DWORD               dwNumOfJobs = 0;
	DWORDLONG			dwlMsgId1 = 0;
	DWORDLONG			dwlMsgId2 = 0;
	DWORDLONG			dwlMsgId3 = 0;
	DWORD				dwErr = 0;
    PFAX_JOB_ENTRY      pJobEntry = NULL;

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("\nServer=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

    //
	// use UI to send the fax
	//
    if (FALSE == ::SendFaxUsingPrintUI(szServerName, szFaxNumber, szDocument, szCoverPage, 3, g_fFaxServer))
    {
        goto ExitFunc;
    }

    //
    // get our job ids
    //
    Sleep(2000);

    if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxConnectFaxServer failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}
    if (FALSE == ::FaxEnumJobsEx(hFaxSvc, JT_SEND | JT_RECEIVE, &pFaxJobs, &dwNumOfJobs))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxEnumJobsEx failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
    }
    if (NULL == pFaxJobs)
    {
        // something is wrong. our job disappeared.
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\npFaxJobs=NULL and dwNumOfJobs=%d"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
    }
    switch (dwNumOfJobs)  
    {
    case 0:
    case 1:
    case 2:
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nToo few (%d) jobs in queue\n"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
        break;

    case 3:
        // we assume all three are our send jobs
        if (JT_SEND != pFaxJobs[0].pStatus->dwJobType)
        {
            // something is wrong. this isn't our job.
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n Three jobs in queue but pFaxJobs[0].JobType=%d (!=JT_SEND)\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFaxJobs[0].pStatus->dwJobType
			    );
		    goto ExitFunc;
        }
        if (JT_SEND != pFaxJobs[1].pStatus->dwJobType)
        {
            // something is wrong. this isn't our job.
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n Three jobs in queue but pFaxJobs[0].JobType=%d (!=JT_SEND)\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFaxJobs[1].pStatus->dwJobType
			    );
		    goto ExitFunc;
        }
        if (JT_SEND != pFaxJobs[2].pStatus->dwJobType)
        {
            // something is wrong. this isn't our job.
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n Three jobs in queue but pFaxJobs[0].JobType=%d (!=JT_SEND)\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFaxJobs[2].pStatus->dwJobType
			    );
		    goto ExitFunc;
        }
        dwlMsgId1 = pFaxJobs[0].dwlMessageId;
        dwlMsgId2 = pFaxJobs[1].dwlMessageId;
        dwlMsgId3 = pFaxJobs[2].dwlMessageId;
        break;

    case 4:
        // we assume three jobs are our send jobs and the other is the 1st receive job
        if ( (JT_SEND == pFaxJobs[0].pStatus->dwJobType) &&
             (JT_SEND == pFaxJobs[1].pStatus->dwJobType) &&
             (JT_SEND == pFaxJobs[2].pStatus->dwJobType)
           )
        {
            // we assume pFaxJobs[0..2] are our send jobs and check that pFaxJobs[3] is receive
            if (JT_RECEIVE != pFaxJobs[3].pStatus->dwJobType)
            {
                // something is wrong.
		        ::lgLogError(
			        LOG_SEV_1,
			        TEXT("FILE:%s LINE:%d\nFour jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\npFaxJobs[2].JobType=%d\npFaxJobs[3].JobType=%d\n"),
			        TEXT(__FILE__),
			        __LINE__,
                    pFaxJobs[0].pStatus->dwJobType,
                    pFaxJobs[1].pStatus->dwJobType,
                    pFaxJobs[2].pStatus->dwJobType,
                    pFaxJobs[3].pStatus->dwJobType
			        );
		        goto ExitFunc;
            }
            dwlMsgId1 = pFaxJobs[0].dwlMessageId;
            dwlMsgId2 = pFaxJobs[1].dwlMessageId;
            dwlMsgId3 = pFaxJobs[2].dwlMessageId;
            break;
        }
        if ( (JT_SEND == pFaxJobs[1].pStatus->dwJobType) &&
             (JT_SEND == pFaxJobs[2].pStatus->dwJobType) &&
             (JT_SEND == pFaxJobs[3].pStatus->dwJobType)
           )
        {
            // we assume pFaxJobs[1..3] are our send jobs and check that pFaxJobs[0] is receive
            if (JT_RECEIVE != pFaxJobs[0].pStatus->dwJobType)
            {
                // something is wrong.
		        ::lgLogError(
			        LOG_SEV_1,
			        TEXT("FILE:%s LINE:%d\nFour jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\npFaxJobs[2].JobType=%d\npFaxJobs[3].JobType=%d\n"),
			        TEXT(__FILE__),
			        __LINE__,
                    pFaxJobs[0].pStatus->dwJobType,
                    pFaxJobs[1].pStatus->dwJobType,
                    pFaxJobs[2].pStatus->dwJobType,
                    pFaxJobs[3].pStatus->dwJobType
			        );
		        goto ExitFunc;
            }
            dwlMsgId1 = pFaxJobs[1].dwlMessageId;
            dwlMsgId2 = pFaxJobs[2].dwlMessageId;
            dwlMsgId3 = pFaxJobs[3].dwlMessageId;
            break;
        }
        // something is wrong. 
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nFour jobs in queue:\npFaxJobs[0].JobType=%d\npFaxJobs[1].JobType=%d\npFaxJobs[2].JobType=%d\npFaxJobs[3].JobType=%d\n"),
			TEXT(__FILE__),
			__LINE__,
            pFaxJobs[0].pStatus->dwJobType,
            pFaxJobs[1].pStatus->dwJobType,
            pFaxJobs[2].pStatus->dwJobType,
            pFaxJobs[3].pStatus->dwJobType
			);
		goto ExitFunc;
        break;

    default:
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nToo many (%d) jobs in queue\n"),
			TEXT(__FILE__),
			__LINE__,
            dwNumOfJobs
			);
		goto ExitFunc;
        break;
    }

    //
    // Poll the queued job status 
    //  this is for now
    //
    _ASSERTE(0 != dwlMsgId1);
    _ASSERTE(0 != dwlMsgId2);
    _ASSERTE(0 != dwlMsgId3);
	::lgLogDetail(
		LOG_X,
        1,
		TEXT("FILE:%s LINE:%d\ndwlMsgId1=0x%I64x\ndwlMsgId2=0x%I64x\ndwlMsgId3=0x%I64x\n"),
		TEXT(__FILE__),
		__LINE__,
        dwlMsgId1,
        dwlMsgId2,
        dwlMsgId3
		);

    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwlMsgId1))
    {
		goto ExitFunc;
    }
    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwlMsgId2))
    {
		goto ExitFunc;
    }
    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwlMsgId3))
    {
		goto ExitFunc;
    }

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

static BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORDLONG /* IN */ dwlMsgId)
{
    // get job repeatedly and verify its states make sense
    // should be PENDING - INPROGRESS (DIALING) - INPROGRESS (TRANSMITTING) * X - COMPLETED

	_ASSERTE(NULL != hFaxSvc);

	BOOL				fRetVal					= FALSE;
	PFAX_JOB_ENTRY_EX	pJobEntry				= NULL;
    DWORD               dwLastExtendedStatus	= 0; //there is no such status code
    UINT                uLoopCount				= 0;
    DWORD               dwErr					= 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJobEx(hFaxSvc, dwlMsgId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (JS_EX_TRANSMITTING == dwLastExtendedStatus && FAX_ERR_MESSAGE_NOT_FOUND == dwErr)
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\r\nFaxGetJobEx returned FALSE with GetLastError=%d dwLastStatus=%d\r\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwErr,
                dwLastExtendedStatus
			    );
			goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);


        //TO DO: better documentation
        switch (pJobEntry->pStatus->dwExtendedStatus)
        {
        case JS_EX_INITIALIZING:
            if (0 == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_INITIALIZING
	            ::lgLogDetail(
		            LOG_X,
                    3, 
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_INITIALIZING\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId
		            );
            }
            else if(JS_EX_INITIALIZING != dwLastExtendedStatus)
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
		            pJobEntry->pStatus->dwExtendedStatus
		            );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_INITIALIZING;
            break;

        case JS_EX_DIALING:
            if ((JS_EX_INITIALIZING == dwLastExtendedStatus) ||
                (0 == dwLastExtendedStatus))
            {
                //first time that we get JS_EX_DIALING
	            ::lgLogDetail(
		            LOG_X,
                    3, 
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_DIALING\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId
		            );
            }
            else if (JS_EX_DIALING != dwLastExtendedStatus)
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
		            pJobEntry->pStatus->dwExtendedStatus
		            );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_DIALING;
            break;

        case JS_EX_TRANSMITTING:
            if (JS_EX_DIALING == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_TRANSMITTING
	            ::lgLogDetail(
		            LOG_X,
                    3, 
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_TRANSMITTING\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId
		            );
            }
            else if (JS_EX_TRANSMITTING != dwLastExtendedStatus)
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
		            pJobEntry->pStatus->dwExtendedStatus
		            );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_TRANSMITTING;
            break;

        case 0:
            // 1) JS_PENDING and JS_COMPLETED don't have extended status
			// 2) we can fail into time interval between pJobStatus->dwQueueStatus and 
			//    pJobStatus->dwExtendedStatus updates

			//remove JS_NOLINE modifier
            switch (pJobEntry->pStatus->dwQueueStatus & ~JS_NOLINE)
            {
            case JS_PENDING:
            case JS_INPROGRESS:
				// ok
                break; // from inner switch

            case JS_COMPLETED:
				//
				// TODO: Should check the device is idle
				//

				if (JS_EX_TRANSMITTING == dwLastExtendedStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
		            pJobEntry->pStatus->dwExtendedStatus
		            );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
	        ::lgLogError(
		        LOG_SEV_1,
		        TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=%d\r\n"),
		        TEXT(__FILE__),
		        __LINE__,
                dwlMsgId,
	            pJobEntry->pStatus->dwExtendedStatus
		        );
            goto ExitFunc;
            break; // from outer switch
        }

		if (pJobEntry)
		{
			FaxFreeBuffer(pJobEntry);
			pJobEntry = NULL;
		}

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\r\nMAX_LOOP_COUNT > uLoopCount\r\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:

	if (pJobEntry)
	{
		FaxFreeBuffer(pJobEntry);
	}

	return(fRetVal);
}


/*
BOOL PollJobAndVerify(HANDLE hFaxSvc, DWORD dwJobId)
{
    // get job repeatedly and verify its states make sense
    // should be QUEUED-DIALING-SENDING*X-COMPLETED

	_ASSERTE(NULL != hFaxSvc);

	BOOL				fRetVal = FALSE;
    PFAX_JOB_ENTRY      pJobEntry = NULL;
    DWORD               dwStatus = 0;
    DWORD               dwLastStatus = 0; //there is no such status code
    UINT                uLoopCount = 0;
    DWORD               dwErr = 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJob(hFaxSvc, dwJobId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (((FPS_COMPLETED == dwLastStatus) || (FPS_AVAILABLE == dwLastStatus)) &&
                (ERROR_INVALID_PARAMETER == dwErr))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nFaxGetJob returned FALSE with GetLastError=%d dwLastStatus=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwErr,
                dwLastStatus
			    );
		    goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);

        dwStatus = pJobEntry->Status;

        //TO DO: better documentation
        switch (dwStatus)
        {
        case FPS_INITIALIZING:
            if (0 == dwLastStatus)
            {
                //first time that we get FPS_INITIALIZING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_INITIALIZING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_INITIALIZING != dwLastStatus) &&
                (0 != dwLastStatus))
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            dwLastStatus = FPS_INITIALIZING;
            break;

        case FPS_DIALING:
            if ((FPS_INITIALIZING == dwLastStatus) ||
                (0 == dwLastStatus))
            {
                //first time that we get FPS_DIALING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_DIALING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_INITIALIZING != dwLastStatus) &&
                (0!= dwLastStatus))
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            dwLastStatus = FPS_DIALING;
            break;

        case FPS_SENDING:
            if (FPS_DIALING == dwLastStatus)
            {
                //first time that we get FPS_SENDING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_SENDING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_SENDING != dwLastStatus))
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            dwLastStatus = FPS_SENDING;
            break;

        case FPS_COMPLETED:
            if (FPS_SENDING == dwLastStatus)
            {
                //first time that we get FPS_COMPLETED
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_COMPLETED\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_SENDING != dwLastStatus) &&
                (FPS_COMPLETED != dwLastStatus))
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            dwLastStatus = FPS_COMPLETED;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case FPS_AVAILABLE:
            if (FPS_COMPLETED == dwLastStatus)
            {
                //first time that we get FPS_AVAILABLE
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_AVAILABLE\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_COMPLETED != dwLastStatus) &&
                (FPS_AVAILABLE != dwLastStatus))
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            dwLastStatus = FPS_AVAILABLE;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case 0:
            //WORKAROUND
            // since pJobEntry->Status is initialized to 0 and is set only 
            // a bit after the job state is set to JS_INPROGRESS
            switch (pJobEntry->QueueStatus)
            {
            case JS_INPROGRESS:
            case JS_PENDING:
            case JS_NOLINE:
                //ok
                break; // from inner switch

            case JS_COMPLETED:
                if (FPS_AVAILABLE == dwLastStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
	        ::lgLogError(
		        LOG_SEV_1,
		        TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=%d\n"),
		        TEXT(__FILE__),
		        __LINE__,
                dwJobId,
		        dwStatus
		        );
            goto ExitFunc;
            break; // from outer switch
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nMAX_LOOP_COUNT > uLoopCount\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}
*/

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
)
{
    _ASSERTE(pPortsConfig);
    _ASSERTE(dwNumOfPorts);

    DWORD   dwLoopIndex = 0;
    for(dwLoopIndex = 0; dwLoopIndex < dwNumOfPorts; dwLoopIndex++)
    {
	    ::lgLogDetail(
		    LOG_X,
            7, 
		    TEXT("FILE:%s LINE:%d Port Number %d\r\ndwSizeOfStruct=%d\r\ndwDeviceID=%d\r\nlpctstrDeviceName=%s\r\nlptstrDescription=%s\r\nlpctstrProviderName=%s\r\nlpctstrProviderGUID=%s\r\nbSend=%d\r\nReceiveMode=%d\r\ndwRings=%d\r\nlptstrTsid=%s\r\n"),
		    TEXT(__FILE__),
		    __LINE__,
            dwLoopIndex,
            pPortsConfig[dwLoopIndex].dwSizeOfStruct,
            pPortsConfig[dwLoopIndex].dwDeviceID,
            pPortsConfig[dwLoopIndex].lpctstrDeviceName,
            pPortsConfig[dwLoopIndex].lptstrDescription,
            pPortsConfig[dwLoopIndex].lpctstrProviderName,
            pPortsConfig[dwLoopIndex].lpctstrProviderGUID,
            pPortsConfig[dwLoopIndex].bSend,
            pPortsConfig[dwLoopIndex].ReceiveMode,
            pPortsConfig[dwLoopIndex].dwRings,
            pPortsConfig[dwLoopIndex].lptstrCsid,
            pPortsConfig[dwLoopIndex].lptstrTsid
		    );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\dummydirtiffcmp.cpp ===
#include "..\..\..\..\FaxBVT\VerifyTiffFiles\DirTiffCmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\dummyvectiffcmp.cpp ===
#include "..\..\..\..\FaxBVT\VerifyTiffFiles\VecTiffCmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\dummylogelle.cpp ===
#include "..\log\LogElle.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\bvt.h ===
//
//
// Filename:	bvt.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _BVT_H_
#define _BVT_H_

#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <faxreg.h> // for setting MS Routing Extension information

#include "..\Log\log.h"
#include "..\..\..\..\FaxBVT\FaxSender\FaxSender.h"
#include "..\..\..\..\FaxBVT\VerifyTiffFiles\dirtiffcmp.h"

#include "VtPrintFax.h"
#include "FilesUtil.h"

//
// input/output files declarations
//
#define PARAMS_INI_FILE      TEXT("Params.ini")
#define PARAMS_SECTION	     TEXT("General")
#define RECIPIENTS_SECTION   TEXT("Recipients")
#define DEBUG_FILE			 TEXT("CometBVT.out")


#ifdef __cplusplus
extern "C" {
#endif

//
// Bvt files
//
extern LPTSTR  g_szBvtDir;
extern LPTSTR  g_szBvtDocFile;
extern LPTSTR  g_szBvtPptFile;
extern LPTSTR  g_szBvtXlsFile;


// due to Ronen's FaxSendDocumentEx changes, full path needed (regression)
#define BVT_BACKSLASH   TEXT("\\")
#define BVT_DOC_FILE	TEXT("file.doc")
#define BVT_XLS_FILE	TEXT("file.xls")
#define BVT_PPT_FILE	TEXT("file.ppt")

#define BVT_MIN_PORTS	2

#define DEV_TSID	TEXT("Comet dev")
#define DEV_CSID	TEXT("Comet dev")

#define MY_FPF_NONE			0

#define MAX_LOOP_COUNT      (60*60*1000)

typedef enum 
{
    LANGUAGE_ENG = 1,
    LANGUAGE_JPN,
    LANGUAGE_GER
}BVT_LANGUAGE;

extern FAX_PERSONAL_PROFILE g_RecipientProfile1;
extern FAX_PERSONAL_PROFILE g_RecipientProfile2;
extern FAX_PERSONAL_PROFILE g_RecipientProfile3;


// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
extern BOOL    g_fFaxServer;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
extern BOOL    g_fNT4OrLater;


//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber1	IN parameter
//					Phone number of first device installed on server.
//					Will be set up as sending device.
//
//	szFaxNumber2	IN parameter
//					Phone number of second device installed on server.
//					Will be set up as receiving device.
//
//	szDocument		IN parameter
//					Filename of document to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szCoverPage		IN parameter
//					Filename of cover page to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szReceiveDir	IN parameter
//					Name of "received faxes" directory to be used in tests.
//
//	pszSentDir		OUT parameter.
//					Pointer to string to copy 7th argument to.
//					Represents the name of directory to store (archive)  
//					sent faxes in.
//
//	szInboxArchiveDir   OUT parameter.
//					    Pointer to string to copy 8th argument to.
//					    Represents the name of directory to store (archive)  
//					    incoming faxes in.
//
//	pszReferenceDir	OUT parameter.
//					Pointer to string to copy 9th argument to.
//					Represents the name of directory containing reference  
//					faxes.
//
//	pszBvtDir	    OUT parameter.
//					Pointer to string to copy 10th argument to.
//					Represents the name of directory containing bvt files.  
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber1,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage,
	LPCTSTR		/* IN */	szReceiveDir,
	LPCTSTR		/* IN */	szSentDir,
	LPCTSTR		/* IN */	szInboxArchiveDir,
	LPCTSTR		/* IN */	szReferenceDir, 
	LPCTSTR		/* IN */	szBvtDir
);

//
// TestCase1:
//	Send a fax + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase2:
//	Send just a CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase3:
//	Send a fax with no CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase3(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument
);

//
// TestCase4:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase4(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase5:
//	Send a broadcast of only CPs (3 times the same recipient).
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase5(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase6:
//	Send a broadcast without CPs (3 times the same recipient).
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase6(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument
);

//
// TestCase7:
//	Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase7(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase8:
//	Send a fax (*.ppt file = BVT_PPT_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase8(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase9:
//	Send a fax (*.xls file = BVT_XLS_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase9(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase10:
//  Compare all received faxes (*.tif files) in directory szReceiveDir 
//  with the refference (*.tif) files in szRefferenceDir
//
// Parameters:
//	szReceive           IN parameter.
//					    Name of directory at which all (BVT) received faxes are stored.
//  
//	szReferenceDir	    IN parameter
//					    Name of directory at which all refference files are stored.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase10(
    LPTSTR     /* IN */    szReceiveDir,
    LPTSTR     /* IN */    szReferenceDir
    );

//
// TestCase11:
//  Compare all (archived) sent faxes (*.tif files) in directory szSentDir 
//  with the refference (*.tif) files in szReferenceDir
//
// Parameters:
//	szSentDir           IN parameter.
//					    Name of directory at which all (BVT) sent faxes are stored.
//  
//	szReferenceDir	    IN parameter
//					    Name of directory at which all reference files are stored.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase11(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReferenceDir
    );

//
// TestCase12:
//  Compare all (archived) incoming faxes (*.tif files) in directory szInboxArchiveDir 
//  with the refference (*.tif) files in szReferenceDir
//
// Parameters:
//	szInboxArchiveDir   IN parameter.
//					    Name of directory at which all (BVT) incoming faxes are stored.
//  
//	szReferenceDir	    IN parameter
//					    Name of directory at which all reference files are stored.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase12(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReferenceDir
    );

//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL WINAPIV TestSuiteShutdown(void);


#ifdef __cplusplus
}
#endif 

#endif //_BVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\dummywcsutil.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\Wcsutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\filesutil.h ===
//
// File:    FilesUtil.h
// Author:  Sigalit Bar (sigalitb)
// Date:    16-May-99
//


#ifndef __FILES_UTIL_H__
#define __FILES_UTIL_H__


#include <windows.h>
#include <faxutil.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include "..\log\log.h"


#define TEST_CP_NAME    TEXT("subnote.cov")
#define TEST_CP_NAME_STR    "subnote (personal)"


typedef enum{
	PERSONAL_COVER_PAGE_DIR,
	SERVER_COVER_PAGE_DIR
}COVER_PAGE_DIR;

//
//
//
BOOL GetCoverpageDirs(
    LPTSTR* /* OUT */	pszCommonCPDir,
    LPTSTR* /* OUT */	pszPersonalCPDir
    );

//
// PlaceServerCP:
//  Copies file szCoverPage into the local server's Common CP directory
//
BOOL PlaceServerCP(
	LPCTSTR		/* IN */	szCoverPage
);

//
// PlacePersonalCP:
//  Copies file szCoverPage into the user's Personal CP directory
//
BOOL PlacePersonalCP(
	LPCTSTR		/* IN */	szCoverPage
);

//
// GetPersonalCPDir
//	Gets the user's Personal CP dir
//
BOOL GetPersonalCPDir(
	LPTSTR*		/* OUT */	pszPersonalCPDir
);

//
// GetServerCPDir
//	Gets the rServer (common) CP dir
//
BOOL GetServerCPDir(
	LPTSTR*		/* OUT */	pszServerCPDir
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\filesutil.cpp ===
//
// File:    FilesUtil.cpp
// Author:  Sigalit Bar (sigalitb)
// Date:    16-May-99
//


#include "FilesUtil.h"


#define CP_DIR_SIZE (4*MAX_PATH)

//
// GetCPDir
//	Gets the Personal CP dir
//
BOOL GetCPDir(
	LPTSTR*		/* OUT */	pszCPDir,
	COVER_PAGE_DIR			eCpDir
)
{
	BOOL	fRetVal = FALSE;
    long	rslt = ERROR_SUCCESS;
    HKEY	hKey = NULL;
	HKEY	hKeyFaxUser = NULL;
	DWORD	dwNeeded = 0;
	LPTSTR	szTmpCPDir2 = NULL;
    TCHAR	szTmpCPDir[CP_DIR_SIZE] = {0};

	_ASSERTE(pszCPDir);
	_ASSERTE(PERSONAL_COVER_PAGE_DIR==eCpDir || SERVER_COVER_PAGE_DIR==eCpDir);

	//
	// call appropriate faxutil func
	//
	if (PERSONAL_COVER_PAGE_DIR==eCpDir)
	{
		//Personal Cp
		if (FALSE == GetClientCpDir(szTmpCPDir, CP_DIR_SIZE))
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\nGetClientCpDir failed with err=0x%08X\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFunc;
		}
	}
	else
	{
		//Server Cp
		if (FALSE == GetServerCpDir(NULL, szTmpCPDir, CP_DIR_SIZE))
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\nGetServerCpDir failed with err=0x%08X\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFunc;
		}
	}

	//
	// find out actual size of CpDir string
	//
	dwNeeded = _tcslen(szTmpCPDir) + 1;
	szTmpCPDir2 = (LPTSTR) malloc(dwNeeded*sizeof(TCHAR));
	if (NULL == szTmpCPDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nmalloc failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        goto ExitFunc;
	}
	ZeroMemory(szTmpCPDir2, dwNeeded*sizeof(TCHAR));
	::_tcscpy(szTmpCPDir2, szTmpCPDir);
	
	*pszCPDir = szTmpCPDir2;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// GetPersonalCPDir
//	Gets the Personal CP dir
//
BOOL GetPersonalCPDir(
	LPTSTR*		/* OUT */	pszPersonalCPDir
)
{
	return(GetCPDir(pszPersonalCPDir, PERSONAL_COVER_PAGE_DIR));
}

//
// GetServerCPDir
//	Gets the Server (common) CP dir
//
BOOL GetServerCPDir(
	LPTSTR*		/* OUT */	pszServerCPDir
)
{
	return(GetCPDir(pszServerCPDir, SERVER_COVER_PAGE_DIR));
}


//
//
//
BOOL GetCoverpageDirs(
    LPTSTR* /* OUT */	pszCommonCPDir,
    LPTSTR* /* OUT */	pszPersonalCPDir
    )
{
    BOOL fRetVal = FALSE;
    LPTSTR szTmpCommonCPDir = NULL;
    LPTSTR szTmpPersonalCPDir = NULL;

    _ASSERTE(NULL != pszCommonCPDir);
    _ASSERTE(NULL != pszPersonalCPDir);

	//
	// Get the server CP dir
	//
	if (FALSE == GetServerCPDir(&szTmpCommonCPDir))
	{
        goto ExitFunc;
	}

	//
	// Get the personal CP dir
	//
	if (FALSE == GetPersonalCPDir(&szTmpPersonalCPDir))
	{
        goto ExitFunc;
	}

    // set OUT params
    (*pszCommonCPDir) = szTmpCommonCPDir;
    (*pszPersonalCPDir) = szTmpPersonalCPDir;

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal) 
    {
        ::free(szTmpCommonCPDir);
        ::free(szTmpPersonalCPDir);
    }
    return(fRetVal);
}

BOOL PlacePersonalCP(
	LPCTSTR		/* IN */	szCoverPage
)
{
    BOOL	fRetVal = FALSE;
    LPTSTR	szPersonalCPDir = NULL;
	LPTSTR	szNewCoverPageName = NULL;
	DWORD	dwNewCoverPageNameLen = 0;
	DWORD	dwPersonalCPDirLen = 0;
	DWORD	dwCoverPageNameLen = 0;

	_ASSERTE(NULL != szCoverPage);

    if (FALSE == GetPersonalCPDir(&szPersonalCPDir))
    {
        goto ExitFunc;
    }
    _ASSERTE(NULL != szPersonalCPDir);

	::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE(%s) LINE(%d):\nszPersonalCPDir=%s\n"),
		TEXT(__FILE__),
		__LINE__,
        szPersonalCPDir
		);

	dwPersonalCPDirLen = ::_tcslen(szPersonalCPDir);
	dwCoverPageNameLen = ::_tcslen(TEST_CP_NAME);
	dwNewCoverPageNameLen = dwPersonalCPDirLen + dwCoverPageNameLen + 1 + 1; //for szPersonalCPDir\TEST_CP_NAME_STR and NULL
	szNewCoverPageName = (LPTSTR) malloc (dwNewCoverPageNameLen*sizeof(TCHAR));
	if (NULL == szNewCoverPageName)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nmalloc failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        goto ExitFunc;
	}
	ZeroMemory(szNewCoverPageName, dwNewCoverPageNameLen*sizeof(TCHAR));
	//----------------------
	// Changed by t-yossia
	//----------------------
	//  ::_stprintf(szNewCoverPageName, TEXT("%s\\%s"),szPersonalCPDir, TEST_CP_NAME);

	  ::_stprintf(szNewCoverPageName, TEXT("%s%s"),szPersonalCPDir, TEST_CP_NAME);

	
	::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE(%s) LINE(%d):\nszNewCoverPageName=%s\n"),
		TEXT(__FILE__),
		__LINE__,
        szNewCoverPageName
		);
	
    if (FALSE == CopyFile(szCoverPage, szNewCoverPageName, FALSE))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::free(szNewCoverPageName);
	::free(szPersonalCPDir);
    return(fRetVal);
}

BOOL PlaceServerCP(
	LPCTSTR		/* IN */	szCoverPage
)
{
    BOOL fRetVal = FALSE;
    LPTSTR szCommonCPDir = NULL;
    LPTSTR szPersonalCPDir = NULL;
    LPTSTR szNewCP = NULL;
    DWORD dwSize = 0;

	_ASSERTE(NULL != szCoverPage);

    if (FALSE == GetCoverpageDirs(&szCommonCPDir, &szPersonalCPDir))
    {
        goto ExitFunc;
    }
    _ASSERTE(NULL != szCommonCPDir);
    _ASSERTE(NULL != szPersonalCPDir);

	::lgLogDetail(
		LOG_X,
        7,
		TEXT("FILE(%s) LINE(%d):\nszCommonCPDir=%s\nszPersonalCPDir=%s\n"),
		TEXT(__FILE__),
		__LINE__,
        szCommonCPDir,
        szPersonalCPDir
		);

    // alloc for szCommonCPDir + '\' + TEST_CP_NAME + null
    dwSize = sizeof(TCHAR)*(::_tcslen(szCommonCPDir) + 1 + ::_tcslen(TEST_CP_NAME) + 1);
    szNewCP = (LPTSTR) malloc (dwSize);
    if (NULL == szNewCP)
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nmalloc failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        goto ExitFunc;
    }
	ZeroMemory(szNewCP, dwSize);

    // set szNewCP to szCommonCPDir + '\' + TEST_CP_NAME
    ::_stprintf(szNewCP, TEXT("%s\\%s"),szCommonCPDir, TEST_CP_NAME);
    if (FALSE == CopyFile(szCoverPage, szNewCP, FALSE))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::free(szCommonCPDir);
	::free(szPersonalCPDir);
	::free(szNewCP);
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//

#pragma warning(disable :4786)

#include "bvt.h"
#include <iniutils.h>

#define HELP_SWITCH_1        "/?"
#define HELP_SWITCH_2        "/H"
#define HELP_SWITCH_3        "-?"
#define HELP_SWITCH_4        "-H"

#define MAX_ARGS	11 //including exe name

#define ARGUMENT_IS_SERVER_NAME				1
#define ARGUMENT_IS_FAX_NUMBER1				2
#define ARGUMENT_IS_FAX_NUMBER2				3
#define ARGUMENT_IS_DOC						4
#define ARGUMENT_IS_CP						5
#define ARGUMENT_IS_RECEIVE_DIR				6
#define ARGUMENT_IS_SENT_DIR				7
#define ARGUMENT_IS_INBOX_ARCHIVE_DIR		8
#define ARGUMENT_IS_REFERENCE_DIR			9
#define ARGUMENT_IS_BVT_DIR					10

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;

//
// global input parameters file path
//
TCHAR* g_InputIniFile = NULL;


//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(void)
{
	::_tprintf(TEXT("FaxBVT.exe - BVT for BOSFax\n\n"));
	::_tprintf(TEXT("Input ini file, %s, general section should list server_name fax_number1 fax_number2 document cover_page receive_dir sent_dir reference_dir\n") , PARAMS_INI_FILE);
	::_tprintf(TEXT("    server_name   the name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number1   the fax number of the 1st device on server\n"));
	::_tprintf(TEXT("    fax_number2   the fax number of the 2nd device on server\n"));
	::_tprintf(TEXT("    document      the full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page    the full path to the cover page to send\n"));
	::_tprintf(TEXT("    receive_dir   the full path to the receive directory of receiving device\n"));
	::_tprintf(TEXT("    sent_dir      the full path to the sent archive directory\n"));
	::_tprintf(TEXT("    inbox_dir     the full path to the inbox archive directory\n"));
	::_tprintf(TEXT("    reference_dir the full path to the reference directory\n"));
	::_tprintf(TEXT("    bvt_dir       the full path to the bvt directory\n"));
	::_tprintf(TEXT("\n"));
    exit(0);
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvA[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber1		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszFaxNumber2		OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the fax number of 2nd device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 5th argument to.
//						Represents the name of the cover page to use
//						with tests.
//	pszReceiveDir		OUT parameter.
//						Pointer to string to copy 6th argument to.
//						Represents the name of directory to route received 
//						faxes to.
//	pszSentDir		    OUT parameter.
//						Pointer to string to copy 7th argument to.
//						Represents the name of directory to store (archive)  
//						sent faxes in.
//	pszInboxArchiveDir	OUT parameter.
//						Pointer to string to copy 8th argument to.
//						Represents the name of directory to store (archive)  
//						incoming faxes in.
//	pszReferenceDir		OUT parameter.
//						Pointer to string to copy 9th argument to.
//						Represents the name of directory containing reference  
//						faxes.
//	pszBvtDir		    OUT parameter.
//						Pointer to string to copy 10th argument to.
//						Represents the name of directory containing bvt  
//						files.
//	pszUseExtendedEvents    OUT parameter.
//							Pointer to string to copy 11th argument to.
//							Represents whether or not to use extended event notifications.  
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
LoadTestParams(
	LPCTSTR      /* IN */	tstrIniFileName,
	LPTSTR*		 /* OUT */	pszServerName,
	LPTSTR*		 /* OUT */	pszFaxNumber1,
	LPTSTR*		 /* OUT */	pszFaxNumber2,
	LPTSTR*		 /* OUT */	pszDocument,
	LPTSTR*		 /* OUT */	pszCoverPage,
    LPTSTR*		 /* OUT */	pszReceiveDir,
    LPTSTR*		 /* OUT */	pszSentDir,
    LPTSTR*		 /* OUT */	pszInboxArchiveDir,
    LPTSTR*		 /* OUT */	pszReferenceDir,
    LPTSTR*		 /* OUT */	pszBvtDir
    )
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber1);
	_ASSERTE(pszFaxNumber2);
	_ASSERTE(pszCoverPage);
	_ASSERTE(pszReceiveDir);
	_ASSERTE(pszSentDir);
	_ASSERTE(pszInboxArchiveDir);
	_ASSERTE(pszReferenceDir);
	_ASSERTE(pszBvtDir);

	// Declarations
	//
	DWORD	dwArgLoopIndex;
	DWORD	dwArgSize;
	LPTSTR	aszParam[MAX_ARGS];

	//
	// Read the list of test parameters from ini file.
	std::vector<tstring> ParamsList;
	try
	{
		ParamsList =  INI_GetSectionList( tstrIniFileName,
						 				  PARAMS_SECTION);
	}
	catch(Win32Err& err)
	{
		::_tprintf(
			TEXT("FILE:%s LINE:%d\n INI_GetSectionList failed with error = %d\n"),
			TEXT(__FILE__),
			__LINE__,
			err.error()
			);
		return FALSE;
	}

	std::vector<tstring>::iterator iterList;
	//
	// Check number of parameters
	//
	if ( ParamsList.size() != (MAX_ARGS - 1))  
	{
		::_tprintf(TEXT("\nInvalid invocation of FaxBVT.exe\n\n"));
		::_tprintf(TEXT("FaxBVT.exe Help:\n"));
		::UsageInfo(); //UsageInfo() exits process.
	}

	//
	// Initialize awcsParam[]
	//
	for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
	{
		aszParam[dwArgLoopIndex] = NULL;
	}

	//
	// Loop on arguments in list
	//
    for (iterList = ParamsList.begin(), dwArgLoopIndex = 1; iterList != ParamsList.end(); iterList++, dwArgLoopIndex++) 
	{
		//
        // Determine the memory required for the parameter
		//
        dwArgSize = (_tcsclen((*iterList).c_str()) + 1) * sizeof(TCHAR);

		//
        // Allocate the memory for the parameter
		//
		_ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
			g_hMainHeap, 
			HEAP_ZERO_MEMORY, 
			dwArgSize
			);
		if(NULL == aszParam[dwArgLoopIndex])
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFuncFail;
		}

	
		::_tcscpy(aszParam[dwArgLoopIndex],(*iterList).c_str());
		if (_tcscmp(aszParam[dwArgLoopIndex],(*iterList).c_str()))
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
				TEXT(__FILE__),
				__LINE__);
			goto ExitFuncFail;
		}
	
		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER1:
			//fax_number1 param
			(*pszFaxNumber1) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER2:
			//fax_number2 param
			(*pszFaxNumber2) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = aszParam[dwArgLoopIndex];
			break;

        case ARGUMENT_IS_RECEIVE_DIR:
			//receive_dir param
			(*pszReceiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_SENT_DIR:
			//sent_dir param
			(*pszSentDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_INBOX_ARCHIVE_DIR:
			//inbox_dir param
			(*pszInboxArchiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_REFERENCE_DIR:
			//reference_page param
			(*pszReferenceDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_BVT_DIR:
			//bvt_dir param
			(*pszBvtDir) = aszParam[dwArgLoopIndex];
            break;

		default:
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (iterList = ParamsList.begin(); iterList != ParamsList.end(); iterList++) 


	//If all is well then we do NOT free 
	//pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
	//since these allocations were the purpose of the function.
	return(TRUE);

ExitFuncFail:

	//
	// Free allocations
	//
	DWORD i;
	//0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
	for (i=0; i<MAX_ARGS; i++) 
	{
		if (NULL == aszParam[i]) continue;
		if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				i,
				::GetLastError()
				);
			return(FALSE);
		}
	}

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber1) = NULL;
	(*pszFaxNumber2) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
	(*pszReceiveDir) = NULL;
	(*pszSentDir) = NULL;
	(*pszInboxArchiveDir) = NULL;
	(*pszReferenceDir) = NULL;
	(*pszBvtDir) = NULL;

	return(FALSE);
}


//
// fPrintBinary
// dump formated data to stream.
//
void fPrintBinary(FILE* pStream, const TCHAR* tstrFormat , ...)
{
	const DWORD MAX_MSG_LEN = 1024;
	TCHAR tstrFormatedData[MAX_MSG_LEN];
	
	va_list args;
	va_start( args, tstrFormat);            /* Initialize variable arguments. */
	
    _vstprintf(tstrFormatedData,tstrFormat,args);


	::fwrite(tstrFormatedData, sizeof( TCHAR ),_tcslen(tstrFormatedData), pStream);
	va_end(args);
}

//
// main body of application.
//
int __cdecl
main(int argc, char* argv[])
{
	int nReturnValue = 0; //to indicate success

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber1 = NULL;
	LPTSTR szFaxNumber2 = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
	LPTSTR szReceiveDir = NULL;
    LPTSTR szReferenceDir = NULL;
    LPTSTR szSentDir = NULL;
    LPTSTR szInboxArchiveDir = NULL;
    LPTSTR szBvtDir = NULL;
	LPTSTR tstrCurrentDirectory = NULL;
	tstring tstrParamsFilePath;

	DWORD dwFuncRetVal = 0;
	DWORD cbDir = 0;


	//
	// Check for help switch
	//
	// If this is the second argument, it may be one of several help switches defined.
	// A help switch can appear only as the second argument.
    if (2 <= argc)
	{
		if (! (!::_stricmp(HELP_SWITCH_1, argv[1])) || 
			  (!::_stricmp(HELP_SWITCH_2, argv[1])) || 
			  (!::_stricmp(HELP_SWITCH_3, argv[1])) || 
			  (!::_stricmp(HELP_SWITCH_4, argv[1]))
			) 
		{
			::_tprintf(TEXT("Invalid invokation of BVT.exe\n\n"));
		}
		::UsageInfo(); //UsageInfo() exits the process.
	}


	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	    nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}

	//
	// Get current directory path
	cbDir = GetCurrentDirectory(0,                     // size of directory buffer
					            tstrCurrentDirectory); // directory buffer
	
	if(!cbDir)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		::GetLastError()
		);
	    nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}
	
	tstrCurrentDirectory = (TCHAR*)::HeapAlloc(	g_hMainHeap, 
												HEAP_ZERO_MEMORY, 
												cbDir * sizeof(TCHAR));
	if(NULL == tstrCurrentDirectory)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		  nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}

	dwFuncRetVal = GetCurrentDirectory(cbDir,                 // size of directory buffer
									   tstrCurrentDirectory); // directory buffer

	if((dwFuncRetVal + 1 != cbDir))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		::GetLastError()
		);
	    nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}

	// Compose the test params ini file.
	tstrParamsFilePath = tstrCurrentDirectory;
	tstrParamsFilePath += TEXT("\\");
	tstrParamsFilePath += PARAMS_INI_FILE; 
	g_InputIniFile = const_cast<TCHAR*>(tstrParamsFilePath.c_str());
	//
	// Parse the command line
	//
	if(!::LoadTestParams(
			tstrParamsFilePath.c_str(),
			&szServerName,
			&szFaxNumber1,
			&szFaxNumber2,
			&szDocument,
			&szCoverPage,
            &szReceiveDir,
            &szSentDir,
            &szInboxArchiveDir,
            &szReferenceDir,
            &szBvtDir
			)
		)
	{
	    nReturnValue = 1; // to indicate failure
		goto ExitFunc;
	}

	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	FILE* pOutputFile;
	//
	// Open debug file, override the old one if exists.
	pOutputFile = ::_tfopen( DEBUG_FILE, TEXT("wb") );
	if(!pOutputFile)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\n_tfopen output file failed with GetLastError()=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		::GetLastError()
		);
		nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}

	//
	// Prepare the output file unicode format header.
	BYTE buff[2];
	buff[0] = 0xFF;
	buff[1] = 0xFE;
	
	if(::fwrite( buff, 1,2, pOutputFile ) != 2)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nfwrite failed\n"),
		TEXT(__FILE__),
		__LINE__
		);
		nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}

	if(::fclose(pOutputFile))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nfclose output file failed\n"),
		TEXT(__FILE__),
		__LINE__
		);
		nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}
	
	//
	// Open unciode log file, append new output lines.
	pOutputFile = ::_tfopen( DEBUG_FILE, TEXT("ab") );

	if(!pOutputFile)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\n_tfopen output file failed with GetLastError()=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		::GetLastError()
		);
		nReturnValue = 1; //to indicate failure
		goto ExitFunc;
	}
		
	fPrintBinary(pOutputFile,
		TEXT("DEBUG\r\nServer=%s\r\nFaxNumber1=%s\nFaxNumber2=%s\r\nDocument=%s\r\nCoverPage=%s\r\nReceiveDir=%s\r\nszSentDir=%s\r\nszInboxArchiveDir=%s\r\nszReferenceDir=%s\r\nszBvtDir=%s\r\n"),
		szServerName,
		szFaxNumber1,
		szFaxNumber2,
		szDocument,
		szCoverPage,
		szReceiveDir,
		szSentDir,
		szInboxArchiveDir,
		szReferenceDir,
		szBvtDir
		);

	if(::fclose(pOutputFile))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nfclose output file failed\n"),
		TEXT(__FILE__),
		__LINE__
		);
		nReturnValue = 1; //to indicate failure
		goto ExitFunc;
    
	}
    
#endif


	if (!TestSuiteSetup(
			szServerName,
			szFaxNumber1,
			szFaxNumber2,
			szDocument,
			szCoverPage,
            szReceiveDir,
            szSentDir,
            szInboxArchiveDir,
            szReferenceDir,
            szBvtDir
			)
		)
	{
	    nReturnValue = 1; // to indicate failure
		goto ExitFunc;
	}


    //Send a fax + CP
	::_tprintf(TEXT("\nRunning TestCase1 (Send a fax + CP)...\n"));
	if (FALSE == TestCase1(			
		                szServerName,
		                szFaxNumber2,
		                szDocument,
		                szCoverPage
		                )
        )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase1 **FAILED**\n"));
    }
	else
	{
		::_tprintf(TEXT("\n\tTestCase1 PASSED\n"));
	}


	//Send just a CP
	::_tprintf(TEXT("\nRunning TestCase2 (Send just a CP)...\n"));
	if (FALSE == TestCase2(			
		            szServerName,
		            szFaxNumber2,
		            szCoverPage
		            )
        )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase2 **FAILED**\n"));
    }
	else
	{
		::_tprintf(TEXT("\n\tTestCase2 PASSED\n"));
	}

	//Send a fax with no CP
	::_tprintf(TEXT("\nRunning TestCase3 (Send a fax with no CP)...\n"));
	if (FALSE == TestCase3(			
		            szServerName,
		            szFaxNumber2,
		            szDocument
		            )
        )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase3 **FAILED**\n"));
    }
	else
	{
		::_tprintf(TEXT("\n\tTestCase3 PASSED\n"));
	}


    //Send a broadcast of fax + CP (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
		::_tprintf(TEXT("\nRunning TestCase4 (Send a broadcast of fax + CP)...\n"));
	     if (FALSE == TestCase4(			
		                    szServerName,
		                    szFaxNumber2,
		                    szDocument,
		                    szCoverPage
		                    )
            )
        {
	        nReturnValue = 1; // to indicate failure
			::_tprintf(TEXT("\n\tTestCase4 **FAILED**\n"));
		}
		else
		{
			::_tprintf(TEXT("\n\tTestCase4 PASSED\n"));
		}
    }


	//Send a broadcast of only CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
		::_tprintf(TEXT("\nRunning TestCase5 (Send a broadcast of only CP)...\n"));
	    if (FALSE == TestCase5(			
		                    szServerName,
		                    szFaxNumber2,
		                    szCoverPage
		                    )
           )
        {
	        nReturnValue = 1; // to indicate failure
			::_tprintf(TEXT("\n\tTestCase5 **FAILED**\n"));
		}
		else
		{
			::_tprintf(TEXT("\n\tTestCase5 PASSED\n"));
		}
    }


	//Send a broadcast without CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
		::_tprintf(TEXT("\nRunning TestCase6 (Send a broadcast without CP)...\n"));
	    if (FALSE == TestCase6(			
		                    szServerName,
		                    szFaxNumber2,
		                    szDocument
		                    )
           )
        {
	        nReturnValue = 1; // to indicate failure
			::_tprintf(TEXT("\n\tTestCase6 **FAILED**\n"));
		}
		else
		{
			::_tprintf(TEXT("\n\tTestCase6 PASSED\n"));
		}
    }


	//Send a fax (*.doc file) + CP
	::_tprintf(TEXT("\nRunning TestCase7 (Send a fax (*.doc file) + CP)...\n"));
	if (FALSE == TestCase7(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase7 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase7 PASSED\n"));
	}

	//Send a fax (*.ppt file) + CP
	::_tprintf(TEXT("\nRunning TestCase8 (Send a fax (*.ppt file) + CP)...\n"));
	if (FALSE == TestCase8(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase8 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase8 PASSED\n"));
	}

	//Send a fax (*.xls file) + CP
	::_tprintf(TEXT("\nRunning TestCase9 (Send a fax (*.xls file) + CP)...\n"));
	if (FALSE == TestCase9(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase9 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase9 PASSED\n"));
	}


    //Compare all "received faxes" in directory szReceiveDir
    //with the files in szReferenceDir
	::_tprintf(TEXT("\nRunning TestCase10 (Compare szReceiveDir with szReferenceDir)...\n"));
    if (FALSE == TestCase10(
            szReceiveDir,
            szReferenceDir
            )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase10 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase10 PASSED\n"));
	}

    //Compare all (archived) "sent faxes" in directory szSentDir
    //with the files in szReferenceDir
	::_tprintf(TEXT("\nRunning TestCase11 (Compare szSentDir with szReferenceDir)...\n"));
    if (FALSE == TestCase11(
                        szSentDir,
                        szReferenceDir
                        )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase11 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase11 PASSED\n"));
	}

    //Compare all (archived) "inbox faxes" in directory szInboxArchiveDir
    //with the files in szReferenceDir
	::_tprintf(TEXT("\nRunning TestCase12 (Compare szInboxArchiveDir with szReferenceDir)...\n"));
    if (FALSE == TestCase12(
                        szInboxArchiveDir,
                        szReferenceDir
                        )
       )
    {
	    nReturnValue = 1; // to indicate failure
		::_tprintf(TEXT("\n\tTestCase12 **FAILED**\n"));
	}
	else
	{
		::_tprintf(TEXT("\n\tTestCase12 PASSED\n"));
	}

	//
	// Output suite results to console
	//
	if (nReturnValue)
	{
		::_tprintf(TEXT("\nTest Suite ***FAILED***\n"));
	}
	else
	{
		::_tprintf(TEXT("\nTest Suite PASSED\n"));
	}

ExitFunc:
	TestSuiteShutdown();

	// free command line params
    if (szServerName) 
	{
        HeapFree(g_hMainHeap, 0, szServerName);
    }
    if (szFaxNumber1) 
	{
        HeapFree(g_hMainHeap, 0, szFaxNumber1);
    }
    if (szFaxNumber2) 
	{
        HeapFree(g_hMainHeap, 0, szFaxNumber2);
    }
    if (szDocument) 
	{
        HeapFree(g_hMainHeap, 0, szDocument);
    }
    if (szCoverPage) 
	{
        HeapFree(g_hMainHeap, 0, szCoverPage);
    }
    if (szReceiveDir) 
	{
        HeapFree(g_hMainHeap, 0, szReceiveDir);
    }
    if (szSentDir) 
	{
        HeapFree(g_hMainHeap, 0, szSentDir);
    }
    if (szInboxArchiveDir) 
	{
        HeapFree(g_hMainHeap, 0, szInboxArchiveDir);
    }
    if (szReferenceDir) 
	{
        HeapFree(g_hMainHeap, 0, szReferenceDir);
    }

	if (tstrCurrentDirectory) 
	{
        HeapFree(g_hMainHeap, 0, tstrCurrentDirectory);
    }

	return(nReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\vtprintfax.h ===
//
// Filename:    VtPrintFax.h
// Author:      Sigalit Bar (sigalitb)
// Date:        13-May-99
//


#ifndef __VT_PRINT_FAX_H__
#define __VT_PRINT_FAX_H__


#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>

#include "..\..\include\t4ctrl.h"
#include "..\log\log.h"
#include "..\..\..\..\FaxBVT\FaxSender\wcsutil.h"
#include "FilesUtil.h"


#define PRINTER_NAME    TEXT("Fax")
#define PRINT_ARGS      TEXT(" \"\" \"\"")

#define IMAGING_APPLICATION       11
#define WORD_APPLICATION          12
#define EXCEL_APPLICATION         13
#define POWERPOINT_APPLICATION    14

#define IMAGING_APPLICATION_CAPTION       "Imaging Preview"
#define WORD_APPLICATION_CAPTION          "Microsoft Word"
#define EXCEL_APPLICATION_CAPTION         "Microsoft Excel"
#define POWERPOINT_APPLICATION_CAPTION    "Microsoft PowerPoint"

#define SEND_FAX_WIZARD_APPLICATION       TEXT("fxssend.exe")

#define IMAGING_APPLICATION_CLASS       "ImgvueWClass"
#define WORD_APPLICATION_CLASS          "OpusApp"
#define EXCEL_APPLICATION_CLASS         "XLMAIN"
#define POWERPOINT_APPLICATION_CLASS    "PP9FrameClass"

#define IMAGING_EXTENSION       TEXT("tif")
#define WORD_EXTENSION          TEXT("doc")
#define EXCEL_EXTENSION         TEXT("xls")
#define POWERPOINT_EXTENSION    TEXT("ppt")

#define PRINT_MENU  "&File\\&Print..."

#define PRINT_WINDOW_CAPTION "Print"
#define IMAGING_PRINT_WINDOW_CLASS   "#32770"
#define WORD_PRINT_WINDOW_CLASS   "bosa_sdm_Microsoft Word 9.0"
#define EXCEL_PRINT_WINDOW_CLASS   "bosa_sdm_XL9"
#define POWERPOINT_PRINT_WINDOW_CLASS   "#32770"

#define COMET_FAX_PRINTER    "Comet Fax"

#define SEND_FAX_WIZARD_CAPTION "Send Fax Wizard"
#define SEND_FAX_WIZARD_CLASS   "#32770"

#define NEXT_BUTTON                     "&Next >"	
#define ADD_BUTTON                      "&Add"	
#define FINISH_BUTTON                   "Finish"
#define TO_EDIT_BOX                     "&To:"
#define LOCATION_COMBO_BOX				"&Location:"
#define FAX_AREA_CODE_EDIT_BOX          "&Fax number:"
#define FAX_NUMBER_EDIT_BOX             ")"
#define DIAL_EXACTLY_CHECK              "&Dial exactly as typed (no prefixes)"
#define DISCOUNT_RATES_OPTION           "When &discount rates apply"
#define NOW_OPTION                      "N&ow"
#define USE_COVERPAGE_CHECK             "Select a &cover page template with the following information"
#define USE_COVERPAGE_CHECK2            "#1400"
#define COVERPAGE_TEMPLATE_COMBO_BOX    "Cover page &template: "
#define CP_SUBJECT_EDIT_BOX             "&Subject line:"
#define CP_NOTE_EDIT_BOX                "N&ote:"
#define DONT_NOTIFY_OPTION              "Do&n't notify"

// For now the Israel and Haifa country and area codes 
// are hard coded
#define ISRAEL_LOCATION_COMBO_ITEM		"Israel (972)"
#define ARE_CODE_EDIT_ITEM				"04"

BOOL SendFaxUsingPrintUI(
    LPCTSTR szServerName, 
    LPCTSTR szFaxNumber, 
    LPCTSTR szDocument, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients,
	BOOL	fFaxServer
    );

BOOL SendFaxByPrint(
    LPCTSTR szServerName, 
    LPCSTR szFaxNumber, 
    LPCTSTR szDocument, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients,
	BOOL	fFaxServer
    );

BOOL SendFaxByWizard(
	LPCSTR szServerName,
    LPCSTR szFaxNumber, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients
    );

BOOL GetWindowCaptionAndClassFromFileName(
    LPCTSTR szFile, 
    LPSTR* szWindowCaption, 
    LPSTR* szWindowClass,
    LPDWORD pdwApplication
    );

BOOL IsAppFileName(LPCTSTR szFile, LPCTSTR szExtension);

BOOL GetCaptionAndClass(
    const DWORD dwApplication, 
    LPCTSTR szFile, 
    LPSTR* szWindowCaption,
    LPSTR* szWindowClass
    );

LPSTR GetPrintWindowClassFromApplication(const DWORD dwApplication);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\vtprintfax.cpp ===
//
// Filename:    VtPrintFax.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        13-May-99
//


#include "VtPrintFax.h"

// see end of file
static BOOL WalkThroughWizard(
	LPCSTR szServerName,
    LPCSTR szFaxNumber, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients
    );


BOOL SendFaxUsingPrintUI(
    LPCTSTR szServerName, 
    LPCTSTR szFaxNumber, 
    LPCTSTR szDocument, 
    LPCTSTR szCoverPage, 
    const DWORD dwNumOfRecipients,
	BOOL	fFaxServer
    )
{
    BOOL fRetVal = FALSE;
    LPSTR strFaxNumber = NULL;
	LPSTR strServerName = NULL;

    _ASSERTE(szFaxNumber);
    _ASSERTE(szServerName);

    // first convert szFaxNumber & szServerName to ANSI
    strFaxNumber = (LPSTR)::DupTStrAsStr(szFaxNumber);
	strServerName = (LPSTR)::DupTStrAsStr(szServerName);

    if ((NULL == strFaxNumber) || (NULL == strServerName))
    {
        goto ExitFunc;
    }

    if (szDocument)
    {
        // send by printing from the application
        fRetVal = ::SendFaxByPrint(szServerName, strFaxNumber, szDocument, szCoverPage, dwNumOfRecipients, fFaxServer);
    }
    else
    {
        // send just a cover page, using fxssend.exe (the CP Wizard)
        fRetVal = ::SendFaxByWizard(strServerName, strFaxNumber, szCoverPage, dwNumOfRecipients);
    }
    
    fRetVal = TRUE;

ExitFunc:
	//
	// Code added by Yossi Attas, fix possible leak.
	//
	if(NULL != strFaxNumber)
	{
		delete strFaxNumber;
	}

	if(NULL != strServerName)
	{
		delete strServerName;
	}


    return(fRetVal);
}


BOOL SendFaxByPrint(
    LPCTSTR szServerName,
    LPCSTR  szFaxNumber, 
    LPCTSTR szDocument, 
    LPCTSTR szCoverPage, 
    const DWORD dwNumOfRecipients,
	BOOL	fFaxServer
    )
{
    BOOL fRetVal = FALSE;
    HINSTANCE hInst = NULL;
    LPTSTR szFile = NULL;
    LPSTR szWindowCaption = NULL;
    LPSTR szWindowClass = NULL;
    DWORD dwApplication = 0;
    LPSTR szPrintWindowClass = NULL;
    SHELLEXECUTEINFO sei;
    DWORD dwRet = 0;
    DWORD dwLoopIndex = 1;
    LPSTR strCoverPage = NULL;
    DWORD dwServerNameLen = 0;
    DWORD dwPrinterNameLen = 0;
    DWORD dwPrintArgsLen = 0;
    DWORD dwParametersSize = 0;
    LPTSTR szParameters = NULL;
	LPSTR szAnsiServerName = NULL;

    _ASSERTE(szServerName);
    _ASSERTE(szFaxNumber);
    _ASSERTE(1 <= dwNumOfRecipients);

    //TO DO: for client we need to add server name to PRINT_ARGS
    dwServerNameLen = ::_tcslen(szServerName);
    _ASSERTE(0 != dwServerNameLen);
    dwPrinterNameLen = ::_tcslen(PRINTER_NAME);
    _ASSERTE(0 != dwPrinterNameLen);
    dwPrintArgsLen = ::_tcslen(PRINT_ARGS);
    _ASSERTE(0 != dwPrintArgsLen);
    dwParametersSize = sizeof(TCHAR)*(3+dwServerNameLen+1+dwPrinterNameLen+1+dwPrintArgsLen+1);
    // allocating +3+1+1+1 for str containing "\\<servername>\<prinetrname>"<print args> 
    // and NULL terminator
    szParameters = (LPTSTR) malloc (dwParametersSize);
    if (NULL == szParameters)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("File:%s Line:%d\nmalloc failed with err=0x%08X"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        _ASSERTE(FALSE);
        goto ExitFunc;
    }
    ZeroMemory(szParameters, dwParametersSize);

	if (FALSE == fFaxServer)
	{
		// this is a BOSFax client machine so we want
		// "\\<servername>\<prinetrname>"<print args>
#ifdef _UNICODE
		//----------------------------------------------------
		// Generate code suitable for a NON win 9x client
		//----------------------------------------------------
		::_tcscpy(szParameters, TEXT("\"\\\\"));
		::_tcscpy(&szParameters[3], szServerName);
		::_tcscpy(&szParameters[3+dwServerNameLen], TEXT("\\"));
		::_tcscpy(&szParameters[3+dwServerNameLen+1], PRINTER_NAME);
		::_tcscpy(&szParameters[3+dwServerNameLen+1+dwPrinterNameLen], TEXT("\""));
		::_tcscpy(&szParameters[3+dwServerNameLen+1+dwPrinterNameLen+1], PRINT_ARGS);
#else
		//----------------------------------------------------
		// Generate code suitable for a win9x client
		//----------------------------------------------------
		::_tcscpy(szParameters, PRINTER_NAME);

#endif
	}
	else
	{
		// this is a BOSFax server machine so we want
		// "<prinetrname>"<print args>
		::_tcscpy(szParameters, TEXT("\""));
		::_tcscpy(&szParameters[1], PRINTER_NAME);
		::_tcscpy(&szParameters[1+dwPrinterNameLen], TEXT("\""));
		::_tcscpy(&szParameters[1+dwPrinterNameLen+1], PRINT_ARGS);
	}
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("File:%s Line:%d\ncalling print_to with params: %s"),
        TEXT(__FILE__),
        __LINE__,
        szParameters
        );


	// SEE_MASK_FLAG_NO_UI | 
    sei.cbSize       = sizeof(sei);
    sei.fMask        = SEE_MASK_NOCLOSEPROCESS ;//| SEE_MASK_FLAG_DDEWAIT
    sei.hwnd         = NULL;
    sei.lpVerb       = TEXT("printto");
    sei.lpFile       = szDocument;
    sei.lpParameters = szParameters;
    //sei.lpParameters = PRINT_ARGS;
    sei.lpDirectory  = TEXT("E:\\BVT"); //NULL;
    sei.nShow        = SW_SHOWNORMAL;
    sei.hInstApp     = NULL;
    sei.lpIDList     = NULL;
    sei.lpClass      = NULL;
    sei.hkeyClass    = NULL;
    sei.dwHotKey     = 0;
    sei.hIcon        = NULL;
    sei.hProcess     = NULL;


    if (FALSE == ::ShellExecuteEx(&sei))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n ShellExecuteEx failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    Sleep(5000);
    // set above window as active
    //WSetActWnd(sei.hwnd);

	//-----------------------------------------
	// we need to convert szServerName to ANSI
	//-----------------------------------------
	szAnsiServerName = (char *)DupTStrAsStr(szServerName);

	if(NULL == szAnsiServerName)
	{
		goto ExitFunc;
	}

    if (FALSE == WalkThroughWizard(szAnsiServerName, szFaxNumber, szCoverPage, dwNumOfRecipients))
    {
        goto ExitFunc;
    }

    Sleep(5000); // to allow for job queueing    
    fRetVal = TRUE;

ExitFunc:

	if(NULL != szAnsiServerName)
	{
		delete szAnsiServerName;
	}

    return(fRetVal);
}

BOOL SendFaxByWizard(
	LPCSTR szServerName,
    LPCSTR szFaxNumber, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients
    )
{
    BOOL fRetVal = FALSE;
    HINSTANCE hInst = NULL;
    SHELLEXECUTEINFO sei;
    DWORD dwRet = 0;
    DWORD dwLoopIndex = 1;
    LPSTR strCoverPage = NULL;

    _ASSERTE(szFaxNumber);
    _ASSERTE(szCoverPage);
    _ASSERTE(1 <= dwNumOfRecipients);

    sei.cbSize       = sizeof(sei);
    sei.fMask        = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS; // | SEE_MASK_FLAG_DDEWAIT;
    sei.hwnd         = NULL;
    sei.lpVerb       = TEXT("open");
    sei.lpFile       = SEND_FAX_WIZARD_APPLICATION;
    sei.lpParameters = NULL;
    sei.lpDirectory  = NULL;
    sei.nShow        = SW_SHOWNORMAL;
    sei.hInstApp     = NULL;
    sei.lpIDList     = NULL;
    sei.lpClass      = NULL;
    sei.hkeyClass    = NULL;
    sei.dwHotKey     = 0;
    sei.hIcon        = NULL;
    sei.hProcess     = NULL;


    if (FALSE == ::ShellExecuteEx(&sei))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n ShellExecuteEx failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
    // set above window as active
    WSetActWnd(sei.hwnd);

    if (FALSE == WalkThroughWizard(szServerName, szFaxNumber, szCoverPage, dwNumOfRecipients))
    {
        goto ExitFunc;
    }

    Sleep(5000); // to allow for job queueing    
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}


static BOOL WalkThroughWizard(
	LPCSTR szServerName,
    LPCSTR szFaxNumber, 
    LPCTSTR szCoverPage,
    const DWORD dwNumOfRecipients
    )
{
    BOOL fRetVal = FALSE;
    DWORD dwLoopIndex = 1;
    LPSTR strCoverPage = NULL;
	CHAR pszAnsiServerName[200];

    _ASSERTE(szFaxNumber);
//    _ASSERTE(szCoverPage);
    _ASSERTE(1 <= dwNumOfRecipients);

	//--------------------------------------------------------------
	// Check if a "Select Fax Printer" window poped up
	//--------------------------------------------------------------
	if ( 0 != WFndWnd(
            "Select Fax Printer", 
            FW_PART | FW_ALL | FW_FOCUS, 
            2
            )
	)
	{
		//-------------------------------------------------
		// Compose the Server + Service full name
		//-------------------------------------------------
		ZeroMemory(pszAnsiServerName,sizeof(pszAnsiServerName));
		sprintf(pszAnsiServerName, "\\\\%s\\SharedFax", szServerName);
		if(!WListItemExists("@1" ,pszAnsiServerName, CTRL_DEF_TIMEOUT))
		{
			//------------------------------------------------------------------------
			// Such an item in the list was not found so we are most probably working
			// With the local server.
			//------------------------------------------------------------------------
			strcpy(pszAnsiServerName, "SharedFax");
		}
		WListItemDblClkEx("@1", pszAnsiServerName, 31, CTRL_DEF_TIMEOUT);
	}

	// let's make this part a bit faster
    // Sleep(1500);

    if ( 0 == WFndWndC(
                SEND_FAX_WIZARD_CAPTION, 
                SEND_FAX_WIZARD_CLASS, 
                FW_PART | FW_ALL | FW_FOCUS, 
                15//CTRL_DEF_TIMEOUT
                )
       )
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n WFndWndC failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

    //Sleep(1000);
    WButtonClick(NEXT_BUTTON, CTRL_DEF_TIMEOUT);

	//---------------------------------------------
	//  "Recipient Information" - Wizard page
	//---------------------------------------------

	//
    // enter all recipients
	//
    for (dwLoopIndex = 1; dwLoopIndex <= dwNumOfRecipients; dwLoopIndex++)
    {
		//
		// Set the To:
		//
        if (FALSE == WEditExists(TO_EDIT_BOX, CTRL_DEF_TIMEOUT))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n WEditExists for To: edit box returned FALSE\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
		WEditSetText(TO_EDIT_BOX, (LPSTR)szFaxNumber, CTRL_DEF_TIMEOUT);

		//
		// Set the Location:
		//
        if (FALSE == WComboExists(LOCATION_COMBO_BOX, CTRL_DEF_TIMEOUT))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n WComboExists for Location: Combo box returned FALSE\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
	    WComboItemClk(LOCATION_COMBO_BOX, ISRAEL_LOCATION_COMBO_ITEM, CTRL_DEF_TIMEOUT);
		
		//
		// Set the area code
		//
        if (FALSE == WEditExists(FAX_AREA_CODE_EDIT_BOX, CTRL_DEF_TIMEOUT))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n WEditExists for 1st FaxNumber: edit box (area code) returned FALSE\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
        WEditSetText(FAX_AREA_CODE_EDIT_BOX, ARE_CODE_EDIT_ITEM, CTRL_DEF_TIMEOUT);

		//
		// Set the local number
		//
        if (FALSE == WEditExists(FAX_NUMBER_EDIT_BOX, CTRL_DEF_TIMEOUT))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n WEditExists for 2nd FaxNumber: edit box (local number) returned FALSE\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
        WEditSetText(FAX_NUMBER_EDIT_BOX, (LPSTR)szFaxNumber, CTRL_DEF_TIMEOUT);

		//
		// Add the recipient
		//
        WButtonClick(ADD_BUTTON, CTRL_DEF_TIMEOUT);
    }
    // end recipients

	//
	// Click the Next wizard button
	//
    Sleep(1000);
    WButtonClick(NEXT_BUTTON, CTRL_DEF_TIMEOUT);


	//---------------------------------------------
	//  "Preparing the Cover Page" - Wizard page
	//---------------------------------------------

	//
    // decide on coverpage
    // if (szCoverPage) then enable check box, find cp in list and enter sub&note
	//
    if (NULL != szCoverPage)
    {
		//
        // Enable Cover Page check box, if it exists
        // (there is no such check box if Wizard is invoked from fxssend.exe)
        WCheckCheck(USE_COVERPAGE_CHECK, CTRL_DEF_TIMEOUT);

		//
		// Verify that TEST_CP_NAME_STR cover page appears in the 
		// Cover Page Template Combo box
		//
        if (FALSE == WComboItemExists(
							COVERPAGE_TEMPLATE_COMBO_BOX, 
							TEST_CP_NAME_STR, 
							CTRL_DEF_TIMEOUT
							)
			)
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE:%s LINE:%d\n WComboItemExists(COVERPAGE_TEMPLATE_COMBO_BOX=%s,TEST_CP_NAME_STR=%s) returned FALSE\n***This test must be run with the above cover page (%s) in the server common cover pages directory***\n"),
			    TEXT(__FILE__),
			    __LINE__,
				TEXT(COVERPAGE_TEMPLATE_COMBO_BOX),
				TEXT(TEST_CP_NAME_STR),
				TEXT(TEST_CP_NAME_STR)
			    );
            goto ExitFunc;
        }
	    WComboItemClk(COVERPAGE_TEMPLATE_COMBO_BOX, TEST_CP_NAME_STR, CTRL_DEF_TIMEOUT);
        // set subject and note
        WEditSetText(CP_SUBJECT_EDIT_BOX, "SUBJECT", CTRL_DEF_TIMEOUT);
        WEditSetText(CP_NOTE_EDIT_BOX, "NOTE1\nNOTE2\nNOTE3\nNOTE4", CTRL_DEF_TIMEOUT);
    }
    else
    {
        // disable check box, if it exists 
        WCheckUnCheck(USE_COVERPAGE_CHECK, CTRL_DEF_TIMEOUT);
    }
    
	//
	// Click the Next wizard button
	//
    Sleep(1000);
    WButtonClick(NEXT_BUTTON, CTRL_DEF_TIMEOUT);


	//---------------------------------------------
	//  "Scheduling Transmission" - Wizard page
	//---------------------------------------------
	WOptionSelect(NOW_OPTION, CTRL_DEF_TIMEOUT);
    Sleep(1000);
	//
	// Click the Next wizard button
	//
	WButtonClick(NEXT_BUTTON, CTRL_DEF_TIMEOUT);


	//---------------------------------------------
	//  "Delivery Notification" - Wizard page
	//---------------------------------------------
	WOptionSelect(DONT_NOTIFY_OPTION, CTRL_DEF_TIMEOUT);
    Sleep(1000);
	//
	// Click the Next wizard button
	//
	WButtonClick(NEXT_BUTTON, CTRL_DEF_TIMEOUT);


	//---------------------------------------------
	//  "Scheduling Transmission" - Wizard page
	//---------------------------------------------
    Sleep(1000);
	WButtonClick(FINISH_BUTTON, CTRL_DEF_TIMEOUT);
    
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\cfgwzrdvt.cpp ===
/*++
	This file implements main driver and common utils for Configuration Wizard Visual Test

	Author: Yury Berezansky (yuryb)

	17.10.2000
--*/

#pragma warning(disable :4786)

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include <commctrl.h>
#include <math.h>
#include <limits.h>
#include <FXSAPIP.h>
#include <Accctrl.h>
#include <Aclapi.h>
#include "..\..\include\t4ctrl.h"
#include "..\generalutils\iniutils.h"
#include "report.h"
#include "genutils.h"
#include "CfgWzrdVT.h"
#include "invocation.h"
#include "functionality.h"


/**************************************************************************************************************************
	General declarations and definitions
**************************************************************************************************************************/

#define COUNT_ARGUMENTS				1
#define ARG_INIFILE					1
#define INI_SEC_STRINGS				TEXT("Strings")
#define INI_SEC_DEVICES				TEXT("Devices")

static const MEMBERDESCRIPTOR aCommonStringsDescIni[] = {
	{TEXT("CommandLineClient"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrCmdLnCC)				},
	{TEXT("CommandLineSendWzrd"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrCmdLnSW)				},
	{TEXT("CommandLineCfgWzrd"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrCmdLnCW)				},
	{TEXT("RegKeyNameDevicePart"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegKeyDevicePart)		},
	{TEXT("RegKeyNameUserPart"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegKeyUserPart)		},
	{TEXT("RegValueNameDevice"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValDevice)			},
	{TEXT("RegValueNameUser"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValUser)			},
	{TEXT("RegKeyNameUserInfo"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegKeyUserInfo)		},
	{TEXT("RegValueNameUserName"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValUserName)		},
	{TEXT("RegValueNameFaxNumber"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValFaxNumber)		},
	{TEXT("RegValueNameEmail"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValEmail)			},
	{TEXT("RegValueNameTitle"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValTitle)			},
	{TEXT("RegValueNameCompany"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValCompany)		},
	{TEXT("RegValueNameOffice"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValOffice)			},
	{TEXT("RegValueNameDepartment"),		TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValDepartment)		},
	{TEXT("RegValueNameHomePhone"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValHomePhone)		},
	{TEXT("RegValueNameWorkPhone"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValWorkPhone)		},
	{TEXT("RegValueNameBillingCode"),		TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValBillingCode)	},
	{TEXT("RegValueNameStreet"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValStreet)			},
	{TEXT("RegValueNameCity"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValCity)			},
	{TEXT("RegValueNameState"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValState)			},
	{TEXT("RegValueNameZip"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValZip)			},
	{TEXT("RegValueNameCountry"),			TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrRegValCountry)		},
	{TEXT("Username"),						TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrUsername)				},
	{TEXT("Password"),						TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrPassword)				},
	{TEXT("GuidPrintOn"),					TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrGuidPrintOn)			},
	{TEXT("GuidStoreInFolder"),				TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrGuidStoreInFolder)	},
	{TEXT("ServiceName"),					TYPE_LPTSTR,	offsetof(COMMONSTRINGS, lptstrServiceName)			},
	{TEXT("Name"),							TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrSendName)				},
	{TEXT("Number"),						TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrSendNumber)			},
	{TEXT("Subject"),						TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrSendSubject)			},
	{TEXT("WindowCaptionClient"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrWndCapCC)				},
	{TEXT("WindowCaptionSendWzrd"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrWndCapSW)				},
	{TEXT("WindowCaptionCfgWzrd"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrWndCapCW)				},
	{TEXT("WindowCaptionUserInfo"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrWndCapUI)				},
	{TEXT("WindowCaptionAdminConsole"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrWndCapAC)				},
	{TEXT("EditSendWzrdName"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtSWName)				},
	{TEXT("CheckboxSendWzrdDialAsEntered"),	TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrChkSWDialAsEntered)	},
	{TEXT("EditSendWzrdNumber"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtSWNumber)			},
	{TEXT("ListSendWzrdRecipients"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrLstSWRecipients)		},
	{TEXT("ButtonSendWzrdRemove"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnSWRemove)			},
	{TEXT("ButtonSendWzrdAdd"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnSWAdd)				},
	{TEXT("EditSendWzrdSubject"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtSWSubject)			},
	{TEXT("OptionSendWzrdNoReceipt"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrOptSWNoReceipt)		},
	{TEXT("EditUserInfoName"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIName)				},
	{TEXT("EditUserInfoFaxNumber"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIFaxNumber)		},
	{TEXT("EditUserInfoEmail"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIEmail)			},
	{TEXT("EditUserInfoTitle"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUITitle)			},
	{TEXT("EditUserInfoCompany"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUICompany)			},
	{TEXT("EditUserInfoOffice"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIOffice)			},
	{TEXT("EditUserInfoDepartment"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIDepartment)		},
	{TEXT("EditUserInfoHomePhone"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIHomePhone)		},
	{TEXT("EditUserInfoWorkPhone"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIWorkPhone)		},
	{TEXT("EditUserInfoBillingCode"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIBillingCode)		},
	{TEXT("ButtonUserInfoAddress"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnUIAddress)			},
	{TEXT("EditUserInfoStreet"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIStreet)			},
	{TEXT("EditUserInfoCity"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUICity)				},
	{TEXT("EditUserInfoState"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIState)			},
	{TEXT("EditUserInfoZip"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtUIZip)				},
	{TEXT("ComboboxUserInfoCountry"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrCmbUICountry)			},
	{TEXT("CheckboxUserInfoThisOnly"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrChkUIThisOnly)			},
	{TEXT("ButtonSendWzrdSenderInfo"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnSWSenderInfo)		},
	{TEXT("MenuClientUserInfo"),			TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrMenuCCUserInfo)		},
	{TEXT("EditCfgWzrdName"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtCWName)				},
	{TEXT("ListCfgWzrdSendingDevices"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrLstCWSendDev)			},
	{TEXT("ButtonCfgWzrdUp"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnCWUp)				},
	{TEXT("ButtonCfgWzrdDown"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrBtnCWDown)				},
	{TEXT("EditCfgWzrdAnswerAfter"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtCWAnswerAfter)		},
	{TEXT("EditCfgWzrdTSID"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtCWTSID)				},
	{TEXT("StaticCfgWzrdNoDeviceSelected"),	TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrLblCWNoDevelected)		},
	{TEXT("ListCfgWzrdReceivingDevices"	),	TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrLstCWReceiveDev)		},
	{TEXT("EditCfgWzrdCSID"),				TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtCWCSID)				},
	{TEXT("CheckboxCfgWzrdPrintItOn"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrChkCWPrintItOn)		},
	{TEXT("CheckboxCfgWzrdSaveInFolder"),	TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrChkCWSaveInFolder)		},
	{TEXT("ComboboxCfgWzrdPrintItOn"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrCmbCWPrintItOn)		},
	{TEXT("EditCfgWzrdSaveInFolder"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrEdtCWSaveInFolder)		},
	{TEXT("StaticMsgBoxInternalErr"),		TYPE_LPSTR,		offsetof(COMMONSTRINGS, lpstrStaticMBIntErr)		}
};



// first DEVCONFIG_INI_PER_SUITE_SETTINGS properties
// (i.e from prop(0) to prop(DEVCONFIG_INI_PER_SUITE_SETTINGS - 1))
// should be read once per suite and remain identical for all test cases

// next DEVCONFIG_INI_PER_DEVICE_SETTINGS properties from
// should be read per device per test case.
// Names of this properties are assumed to appear in form <Property><device #>.

// all the rest should be read per test case (the same for all devices)

#define	DEVCONFIG_INI_PER_SUITE_SETTINGS	2 // ID and Name
#define DEVCONFIG_INI_PER_DEVICE_SETTINGS	2 // Type and Priority

static const MEMBERDESCRIPTOR aDevConfigDescIni[] = {
	{TEXT("ID"),					TYPE_DWORD,		offsetof(DEVCONFIG, dwID)			},
	{TEXT("Name"),					TYPE_LPTSTR,	offsetof(DEVCONFIG, lptstrName)		},
	{TEXT("Type"),					TYPE_DWORD,		offsetof(DEVCONFIG, dwType)			},
	{TEXT("Priority"),				TYPE_DWORD,		offsetof(DEVCONFIG, dwPriority)		},
	{TEXT("TSID"),					TYPE_LPTSTR,	offsetof(DEVCONFIG, lptstrTSID)		},
	{TEXT("CSID"),					TYPE_LPTSTR,	offsetof(DEVCONFIG, lptstrCSID)		},
	{TEXT("Rings"),					TYPE_DWORD,		offsetof(DEVCONFIG, dwRings)		},
	{TEXT("PrinterEnabled"),		TYPE_BOOL,		offsetof(DEVCONFIG, bPrinter)		},
	{TEXT("FolderEnabled"),			TYPE_BOOL,		offsetof(DEVCONFIG, bFolder)		},
	{TEXT("PrinterName"),			TYPE_LPTSTR,	offsetof(DEVCONFIG, lptstrPrinter)	},
	{TEXT("FolderName"),			TYPE_LPTSTR,	offsetof(DEVCONFIG, lptstrFolder)	}
};


static const MEMBERDESCRIPTOR aUserInfoDescIni[] = {
	{TEXT("Name"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrName)			},
	{TEXT("FaxNumber"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrFaxNumber)		},
	{TEXT("Email"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrEmail)			},
	{TEXT("Title"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrTitle)			},
	{TEXT("Company"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrCompany)		},
	{TEXT("Office"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrOffice)		},
	{TEXT("Department"),	TYPE_LPTSTR,	offsetof(USERINFO, lptstrDepartment)	},
	{TEXT("HomePhone"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrHomePhone)		},
	{TEXT("WorkPhone"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrWorkPhone)		},
	{TEXT("BillingCode"),	TYPE_LPTSTR,	offsetof(USERINFO, lptstrBillingCode)	},
	{TEXT("Street"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrStreet)		},
	{TEXT("City"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrCity)			},
	{TEXT("State"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrState)			},
	{TEXT("Zip"),			TYPE_LPTSTR,	offsetof(USERINFO, lptstrZip)			},
	{TEXT("Country"),		TYPE_LPTSTR,	offsetof(USERINFO, lptstrCountry)		}
};



#define FAX_ACCESS_ADMIN				\
	FAX_ACCESS_QUERY_JOBS			|	\
	FAX_ACCESS_MANAGE_JOBS			|	\
	FAX_ACCESS_QUERY_CONFIG			|	\
	FAX_ACCESS_MANAGE_CONFIG		|	\
	FAX_ACCESS_QUERY_IN_ARCHIVE		|	\
	FAX_ACCESS_MANAGE_IN_ARCHIVE	|	\
	FAX_ACCESS_QUERY_OUT_ARCHIVE	|	\
	FAX_ACCESS_MANAGE_OUT_ARCHIVE


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test Suite definition
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// add here test areas, you want to be available
static const TESTAREA *aTestAreas[] = {
	&taInvocation,
	&taFunctionality
};

// the structure describes the test suite
static const TESTSUITE tsCfgWzrd = {
	TEXT("Configuration Wizard"),
	aTestAreas,
	sizeof(aTestAreas) / sizeof(aTestAreas[0]),
};




/**************************************************************************************************************************
	Static functions declarations
**************************************************************************************************************************/

static	DWORD	GetIniFileFullPath	(LPCTSTR lpctstrIniFileName, LPTSTR *lplptstrIniFileFullPath);
static	DWORD	GetTestParams		(TESTPARAMS **ppTestParams, LPCTSTR lpctstrIniFile);
static	DWORD	FreeTestParams		(TESTPARAMS **ppTestParams);
static	DWORD	SetSendingCW		(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, DWORD *lpdwType);
static	DWORD	SetReceivingCW		(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, DWORD *lpdwType);




/**************************************************************************************************************************
	Functions definitions
**************************************************************************************************************************/

#ifdef _UNICODE

int __cdecl wmain(int argc, wchar_t *argv[])

#else

int __cdecl main(int argc, char *argv[])

#endif
{
	TESTPARAMS	*pTestParams			= NULL;
	LPTSTR		lptstrIniFileFullPath	= NULL;
	DWORD		dwEC					= ERROR_SUCCESS;
	DWORD		dwCleanUpEC				= ERROR_SUCCESS;

	// check number of command line argumnets
	if (argc != COUNT_ARGUMENTS + 1)
	{
		DbgMsg(TEXT("Usage: CfgWzrdVT <inifile>\n"));
		return ERROR_INVALID_COMMAND_LINE;
	}	

	// IniFile is assumed to be in current directory
	dwEC = GetIniFileFullPath(argv[ARG_INIFILE], &lptstrIniFileFullPath);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetIniFileFullPath"), dwEC);
		goto exit_func;
	}
	
	dwEC = GetTestParams(&pTestParams, lptstrIniFileFullPath);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetTestParams"), dwEC);
		goto exit_func;
	}

	dwEC = RunSuite(&tsCfgWzrd, pTestParams, lptstrIniFileFullPath);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RunSuite"), dwEC);
		return dwEC;
	}

exit_func:

	if (lptstrIniFileFullPath)
	{
		LocalFree(lptstrIniFileFullPath);
	}

	if (pTestParams)
	{
		dwCleanUpEC = FreeTestParams(&pTestParams);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeTestParams"), dwCleanUpEC);
		}
	}

	_tprintf(TEXT("%s\n"), TEXT("Done."));

	return ERROR_SUCCESS;
}



/*++
	Launches an application as a local user
  
	[IN]	lpcwstrUsername		User name
	[IN]	lpcwstrPassword		Password
	[IN]	lptstrCmdLine		Command line (with arguments)
  
	Return value:				Win32 error code

	If either lpcwstrUsername or lpcwstrPassword is NULL, the application is launched as a current user
--*/
DWORD LaunchApp(LPCTSTR lpctstrUsername, LPCTSTR lpctstrPassword, LPTSTR lptstrCmdLine) {

	STARTUPINFO			si;
	PROCESS_INFORMATION	pi;
	DWORD				dwEC = ERROR_SUCCESS;

	_ASSERT(lptstrCmdLine);
	if (!lptstrCmdLine)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	if (lpctstrUsername && lpctstrPassword)
	{
		TCHAR	tszRunAsCommandLine[500];
		TCHAR	tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD	dwBufSize = sizeof(tszComputerName);

		if (!GetComputerName(tszComputerName, &dwBufSize))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("GetComputerName"), dwEC);
			goto exit_func;
		}

		_stprintf(
			tszRunAsCommandLine,
			TEXT("cmd /c echo %s| runas /profile /user:%s\\%s \"%s\""),
			lpctstrPassword,
			tszComputerName,
			lpctstrUsername,
			lptstrCmdLine
			);

		if (!CreateProcess(
			NULL,					// name of executable module
			tszRunAsCommandLine,	// command line string
			NULL,					// process SD
			NULL,					// thread SD
			FALSE,					// handle inheritance option
			0,						// creation flags
			NULL,					// new environment block
			NULL,					// current directory name
			&si,					// startup information
			&pi						// process information
			))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("CreateProcess"), dwEC);
			goto exit_func;
		}
	}
	else
	{
		if (!CreateProcess(
			NULL,			// name of executable module
			lptstrCmdLine,	// command line string
			NULL,			// process SD
			NULL,			// thread SD
			FALSE,			// handle inheritance option
			0,				// creation flags
			NULL,			// new environment block
			NULL,			// current directory name
			&si,			// startup information
			&pi				// process information
			))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("CreateProcess"), dwEC);
			goto exit_func;
		}
	}

	if (lpctstrUsername && lpctstrPassword)
	{
		// Process created "AsUser"
		// In current implementation cannot use WaitForInputIdle, because we don't have PID
		// (pi.hProcess contains PID of cmd.exe)
	
		// Workaround
		Sleep(SHORT_SLEEP * 15);
	}
	else
	{
		dwEC = WaitForInputIdle(pi.hProcess, SHORT_SLEEP * 15);
		if (dwEC != ERROR_SUCCESS)
		{
			if (dwEC == WAIT_TIMEOUT)
			{
				DbgMsg(TEXT("timeout\n"));
			}
			else if (dwEC == -1) 
			{
				// an error occured

				if ((dwEC = GetLastError()) != ERROR_SUCCESS)
				{
					DbgMsg(DBG_FAILED_ERR, TEXT("WaitForInputIdle"), dwEC);
					goto exit_func;
				}
			}
			else
			{
				_ASSERT(FALSE);
			}
		}
	}

exit_func:

	if (pi.hProcess && !CloseHandle(pi.hProcess))
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CloseHandle"), GetLastError());
	}

	if (pi.hThread && !CloseHandle(pi.hThread))
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CloseHandle"), GetLastError());
	}

	return dwEC;
}



/*++
	Closes an application window with specified caption, if exists
  
	[IN]	lpstrCaption	Specifies the caption of Client Console window
	[IN]	dwCloseType		Specifies what kind of action should be taken in order to close
							the application (menu, button...)
	[IN]	lpstrDetails	Specifies details for the action: menu command, button caption...

	Return value:			Win32 error code
--*/
DWORD CloseApp(LPSTR lpstrCaption, DWORD dwCloseType, LPSTR lpstrDetails) {

	_ASSERT(lpstrCaption && lpstrDetails);
	if (!(lpstrCaption && lpstrDetails))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	// set focus to the window (if found)
	if (!WFndWnd(lpstrCaption, FW_DEFAULT | FW_FOCUS, VT_TIMEOUT))
	{
		return ERROR_NOT_FOUND;
	}

	switch (dwCloseType)
	{
	case VT_ACT_BUTTON:
		WButtonClick(lpstrDetails, VT_TIMEOUT);
		break;
	case VT_ACT_MENU:
		WMenuSelect(lpstrDetails, VT_TIMEOUT);
		break;
	default:
		_ASSERT(FALSE);
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	// give the application some time to close
	Sleep(SHORT_SLEEP);
	
	return ERROR_SUCCESS;
}



/*++
	Retrieves user information from the registry and saves it in USERINFO structure.
	The structure is allocated by the function and should be freed by FreeUserInfo()
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[OUT]	ppUserInfo		Pointer to pointer to USERINFO structure
							*ppUserInfo must be NULL when the function is called
							*ppUserInfo remains NULL if the function failes

	Return value:			Win32 error code

	If the function failes, it destroyes partially initialized structure
	and sets *ppUserInfo to NULL
--*/
DWORD GetUserInfoReg(const TESTPARAMS *pTestParams, USERINFO **ppUserInfo)
{
	MEMBERDESCRIPTOR aRegUserInfoDescReg[] = {
		{pTestParams->pStrings->lptstrRegValUserName,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrName)			},
		{pTestParams->pStrings->lptstrRegValFaxNumber,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrFaxNumber)		},
		{pTestParams->pStrings->lptstrRegValEmail,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrEmail)			},
		{pTestParams->pStrings->lptstrRegValTitle,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrTitle)			},
		{pTestParams->pStrings->lptstrRegValCompany,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrCompany)		},
		{pTestParams->pStrings->lptstrRegValOffice,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrOffice)		},
		{pTestParams->pStrings->lptstrRegValDepartment,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrDepartment)	},
		{pTestParams->pStrings->lptstrRegValHomePhone,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrHomePhone)		},
		{pTestParams->pStrings->lptstrRegValWorkPhone,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrWorkPhone)		},
		{pTestParams->pStrings->lptstrRegValBillingCode,	TYPE_LPTSTR,	offsetof(USERINFO, lptstrBillingCode)	},
		{pTestParams->pStrings->lptstrRegValStreet,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrStreet)		},
		{pTestParams->pStrings->lptstrRegValCity,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrCity)			},
		{pTestParams->pStrings->lptstrRegValState,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrState)			},
		{pTestParams->pStrings->lptstrRegValZip,			TYPE_LPTSTR,	offsetof(USERINFO, lptstrZip)			},
		{pTestParams->pStrings->lptstrRegValCountry,		TYPE_LPTSTR,	offsetof(USERINFO, lptstrCountry)		}
	};

	HKEY	hkUserInfo	= NULL;
	DWORD	dwEC		= ERROR_SUCCESS;
	DWORD	dwCleanUpEC	= ERROR_SUCCESS;

	_ASSERT(pTestParams);

	// do we lose a valid pointer ?
	_ASSERT(ppUserInfo && *ppUserInfo == NULL);

	if (!(pTestParams && ppUserInfo))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	dwEC = RegOpenKeyEx(
		HKEY_CURRENT_USER,
		pTestParams->pStrings->lptstrRegKeyUserInfo,
		0,
		KEY_QUERY_VALUE,
		&hkUserInfo
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RegOpenKeyEx"), dwEC);
		goto exit_func;
	}

	if (!(*ppUserInfo = (USERINFO *)LocalAlloc(LPTR, sizeof(USERINFO))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	dwEC = ReadStructFromRegistry(
		*ppUserInfo,
		aRegUserInfoDescReg,
		sizeof(aRegUserInfoDescReg) / sizeof(aRegUserInfoDescReg[0]),
		hkUserInfo
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ReadStructFromRegistry"), dwEC);
		goto exit_func;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS && *ppUserInfo)
	{
		dwCleanUpEC = FreeUserInfo(ppUserInfo);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeUserInfo"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Reads settings from inifile and saves them in USERINFO structure.
	The structure is allocated by the function and should be freed by FreeUserInfo()
  
	[IN]	pTestParams			Pointer to TESTPARAMS structure
	[IN]	lpctstrSection		Name of the section in inifile
	[OUT]	ppUserInfo			Pointer to pointer to USERINFO structure
								*ppUserInfo must be NULL when the function is called
								*ppUserInfo remains NULL if the function failes

	Return value:				Win32 error code

	If the function failes, it destroyes partially initialized structure
	and sets *ppUserInfo to NULL
--*/
DWORD GetUserInfoFile(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, USERINFO **ppUserInfo)
{
	DWORD	dwEC		= ERROR_SUCCESS;
	DWORD	dwCleanUpEC	= ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection);

	// do we lose a valid pointer ?
	_ASSERT(ppUserInfo && *ppUserInfo == NULL);

	if (!(pTestParams && lpctstrSection && ppUserInfo))
	{
		DbgMsg(TEXT("Invalid parameters\n"));

		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	if (!(*ppUserInfo = (USERINFO *)LocalAlloc(LPTR, sizeof(USERINFO))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	dwEC = ReadStructFromIniFile(
		*ppUserInfo,
		aUserInfoDescIni,
		sizeof(aUserInfoDescIni) / sizeof(aUserInfoDescIni[0]),
		pTestParams->lptstrIniFile,
		lpctstrSection
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ReadStructFromIniFile"), dwEC);
		goto exit_func;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS && *ppUserInfo)
	{
		dwCleanUpEC = FreeUserInfo(ppUserInfo);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeUserInfo"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Sets user information via Client Console
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pUserInfo		Pointer to USERINFO structure

	Return value:			Win32 error code
--*/
DWORD SetUserInfoCC(const TESTPARAMS *pTestParams, const USERINFO *pUserInfo) {

	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && pUserInfo);
	if (!(pTestParams && pUserInfo))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	// make sure Client Console has the focus
	if (!WFndWnd(pTestParams->pStrings->lpstrWndCapCC, FW_DEFAULT | FW_FOCUS, VT_TIMEOUT))
	{
		DbgMsg(TEXT("can't find Client Console window\n"));
		return ERROR_NOT_FOUND;
	}

	dwEC = SetUserInfo(pTestParams, pUserInfo, VT_ACT_MENU, pTestParams->pStrings->lpstrMenuCCUserInfo, FALSE);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetUserInfo"), dwEC);
		return dwEC;
	}

	// give the service some time to write to the registry
	Sleep(SHORT_SLEEP);

	return ERROR_SUCCESS;
}



/*++
	Sets user information via Send Wizard
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pUserInfo		Pointer to USERINFO structure
	[IN]	bForThisOnly	Specifies whether this information is set "for single use"

	Return value:			Win32 error code
--*/
DWORD SetUserInfoSW(const TESTPARAMS *pTestParams, const USERINFO *pUserInfo, BOOL bForThisOnly)
{
	DWORD	dwRecipientsCount	= 0;
	DWORD	dwEC				= ERROR_SUCCESS;

	_ASSERT(pTestParams && pUserInfo);
	if (!(pTestParams && pUserInfo))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	// move to Recipients page, remove all existing recipients and add new one
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwRecipientsCount = WViewCount(pTestParams->pStrings->lpstrLstSWRecipients, VT_TIMEOUT);
	while(dwRecipientsCount-- > 0)
	{
		WViewItemClk(pTestParams->pStrings->lpstrLstSWRecipients, "@1",VK_LBUTTON, VT_TIMEOUT);
		WButtonClick(pTestParams->pStrings->lpstrBtnSWRemove, VT_TIMEOUT);
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtSWName, pTestParams->pStrings->lpstrSendName, VT_TIMEOUT);
	WCheckCheck(pTestParams->pStrings->lpstrChkSWDialAsEntered, VT_TIMEOUT);
	WEditSetText(pTestParams->pStrings->lpstrEdtSWNumber, pTestParams->pStrings->lpstrSendNumber, VT_TIMEOUT);
	WButtonClick(pTestParams->pStrings->lpstrBtnSWAdd, VT_TIMEOUT);

	// move to Preparing the Cover page page, fill subject field and set user information
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	WEditSetText(pTestParams->pStrings->lpstrEdtSWSubject, pTestParams->pStrings->lpstrSendSubject, VT_TIMEOUT);
	dwEC = SetUserInfo(pTestParams, pUserInfo, VT_ACT_BUTTON, pTestParams->pStrings->lpstrBtnSWSenderInfo, bForThisOnly);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetUserInfo"), dwEC);
		return dwEC;
	}

	// move to "scheduling" page
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);

	// move to receipts page and select "No receipt" option
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	WOptionClick(pTestParams->pStrings->lpstrOptSWNoReceipt, VT_TIMEOUT);

	// move to the last page and send (and save settings)
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	WButtonClick(VT_BUTTON_FINISH, VT_TIMEOUT);

	// give the service some time to write to the registry
	Sleep(SHORT_SLEEP);

	return ERROR_SUCCESS;
}



/*++
	Fills all fields in User Info window.
	A caller can specify whether the window is already opened or the function should open it

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pUserInfo		Pointer to USERINFO structure
	[IN]	dwOpenType		Specifies what kind of action should be taken in order to open
							User Information window (menu, button, none...)
	[IN]	lpstrDetails	Specifies details for the action: menu command, button caption...
	[IN]	bForThisOnly	Specifies whether this information is set "for single use" (Send Wizard only)

	Return value:			Win32 error code
--*/
DWORD SetUserInfo(
	const TESTPARAMS *pTestParams,
	const USERINFO *pUserInfo,
	DWORD dwOpenType,
	LPSTR lpstrDetails,
	BOOL bForThisOnly)
{

	LPSTR	lpBuffer	= NULL;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(pTestParams && pUserInfo);

	// if an action required to open User Info window, details must be specified
	_ASSERT(!(dwOpenType != VT_ACT_NONE && !lpstrDetails));

	if (!(pTestParams && pUserInfo) || (dwOpenType != VT_ACT_NONE && !lpstrDetails))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	switch (dwOpenType)
	{
	case VT_ACT_NONE:
		break;
	case VT_ACT_BUTTON:
		WButtonClick(lpstrDetails, VT_TIMEOUT);
		break;
	case VT_ACT_MENU:
		WMenuSelect(lpstrDetails, VT_TIMEOUT);
		break;
	default:
		_ASSERT(FALSE);
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if (dwOpenType != VT_ACT_NONE)
	{
		// we tried to open the window

		// check whether we succeeded
		if (!WFndWnd(pTestParams->pStrings->lpstrWndCapUI, FW_DEFAULT | FW_FOCUS, VT_TIMEOUT))
		{
			DbgMsg(TEXT("can't find User Info window\n"));
			return ERROR_NOT_FOUND;
		}
	}
	// else we assume the window is already opened and in focus
	
	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrName);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIName, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrFaxNumber);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIFaxNumber, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrEmail);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIEmail, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrTitle);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUITitle, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrCompany);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUICompany, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrOffice);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIOffice, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrDepartment);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIDepartment, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrHomePhone);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIHomePhone, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrWorkPhone);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIWorkPhone, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrBillingCode);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIBillingCode, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	// open Address dialog
	WButtonClick(pTestParams->pStrings->lpstrBtnUIAddress, VT_TIMEOUT);
	
	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrStreet);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIStreet, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrCity);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUICity, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrState);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIState, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrZip);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtUIZip, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;
	
	dwEC = StrGenericToAnsiAllocAndCopy(&lpBuffer, pUserInfo->lptstrCountry);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		return dwEC;
	}
	WComboSetText(pTestParams->pStrings->lpstrCmbUICountry, lpBuffer, VT_TIMEOUT);
	LocalFree(lpBuffer);
	lpBuffer = NULL;

	// close Address dialog
	WButtonClick(VT_BUTTON_OK, VT_TIMEOUT);

	// set "For this only" checkbox
	// if it doesn't exist, WCheckCheck will return with timeout
	if (bForThisOnly)
	{
		WCheckCheck(pTestParams->pStrings->lpstrChkUIThisOnly, VT_TIMEOUT);
	}
	else
	{
		WCheckUnCheck(pTestParams->pStrings->lpstrChkUIThisOnly, VT_TIMEOUT);
	}

	if (dwOpenType != VT_ACT_NONE)
	{
		// we opened the window, we should close it

		WButtonClick(VT_BUTTON_OK, VT_TIMEOUT);
	}

	return ERROR_SUCCESS;
}



/*++
	Frees USERINFO structure
  
	[IN/OUT]		ppSvcConfig	Pointer to pointer to SVCCONFIG structure
					ppUserInfo must point to a valid pointer
					*ppUserInfo is set to NULL

	Return value:	Win32 error code
--*/
DWORD FreeUserInfo(USERINFO **ppUserInfo)
{
	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(ppUserInfo && *ppUserInfo);
	if (!(ppUserInfo && *ppUserInfo))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	dwEC = FreeStruct(
		*ppUserInfo,
		aUserInfoDescIni,
		sizeof(aUserInfoDescIni) / sizeof(aUserInfoDescIni[0]),
		TRUE
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("FreeStruct"), dwEC);
	}

	*ppUserInfo = NULL;

	return dwEC;
}



/*++
	ANSI version
	Unselects all items in spcified ListView control and unckeckes their checkboxes

	Current implementation is chosen for now because of problems with both Visual Test
	and comctl32.dll functions. It will be revised later.
  
	[IN]	lpcstrControl	String that identifies the list view control.
							Controls can be identified by their index position, ID value,
							hwnd, or the case-insensitive caption associated with the control
							For more details see Rational Visual Test help

	Return value:			Win32 error code
--*/
DWORD ViewResetA(LPSTR lpcstrControl)
{
	HWND		hView	= NULL;
	WNDPOSSIZ	wpsView;

	_ASSERT(lpcstrControl);
	if (!lpcstrControl)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if (!(hView = WViewFind(lpcstrControl, VT_TIMEOUT)))
	{
		DbgMsg(TEXT("cannot find %s ListView control\n"), lpcstrControl);
		return ERROR_NOT_FOUND;
	}

	// get position of the control relative to a parent window
	WGetWndPosSiz(hView, &wpsView, TRUE);

	// unselect all items and uncheck their checkboxes
	// in order to do that, double click in the left bottom corner of the control
	// (hopefully that there is white space below the last item)
	WDblClkWnd(hView, 1, wpsView.height - 5, VK_LBUTTON);

	return ERROR_SUCCESS;
}



/*++
	Retrieves settings from fax service and saves them in SVCCONFIG structure.
	The structure is allocated by the function and should be freed by FreeSvcConfig()
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[OUT]	ppSvcConfig		Pointer to pointer to SVCCONFIG structure
							*ppSvcConfig must be NULL when the function is called
							*ppSvcConfig remains NULL if the function failes

	Return value:			Win32 error code

	If the function failes, it destroyes partially initialized structure
	and sets *ppSvcConfig to NULL
--*/
DWORD GetSvcConfigAPI(const TESTPARAMS *pTestParams, SVCCONFIG **ppSvcConfig)
{
	HANDLE			hService		= NULL;
	PFAX_PORT_INFO	pPortInfo		= NULL;
	DWORD			dwDevInd		= 0;
	DWORD			dwMethodsInd	= 0;
	DWORD			dwEC			= ERROR_SUCCESS;
	DWORD			dwCleanUpEC		= ERROR_SUCCESS;

	_ASSERT(pTestParams);

	/* do we lose a valid pointer? */
	_ASSERT(ppSvcConfig && *ppSvcConfig == NULL);
	
	if (!(pTestParams && ppSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	if (!(*ppSvcConfig = (SVCCONFIG *)LocalAlloc(LPTR, sizeof(SVCCONFIG))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	if (!FaxConnectFaxServer(NULL, &hService))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxConnectFaxServer"), dwEC);
		goto exit_func;
	}

	if (!FaxEnumPorts(hService, &pPortInfo, &((*ppSvcConfig)->dwDevCount)))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxEnumPorts"), dwEC);
		goto exit_func;
	}

	if (!((*ppSvcConfig)->pDevConfig = (DEVCONFIG *)LocalAlloc(LPTR, sizeof(DEVCONFIG) * (*ppSvcConfig)->dwDevCount)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	for (dwDevInd = 0; dwDevInd < (*ppSvcConfig)->dwDevCount; dwDevInd++)
	{
		HANDLE				hPort			= NULL;
		PFAX_ROUTING_METHOD	pRoutingMethods	= NULL;
		DWORD				dwMethodsCount	= 0;

		(*ppSvcConfig)->pDevConfig[dwDevInd].dwID = pPortInfo[dwDevInd].DeviceId;

		dwEC = StrAllocAndCopy(&((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrName), pPortInfo[dwDevInd].DeviceName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
			goto exit_dev_loop;
		}

		(*ppSvcConfig)->pDevConfig[dwDevInd].dwType = pPortInfo[dwDevInd].Flags & (FPF_RECEIVE | FPF_SEND);

		dwEC = StrAllocAndCopy(&((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrTSID), pPortInfo[dwDevInd].Tsid);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
			goto exit_dev_loop;
		}

		dwEC = StrAllocAndCopy(&((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrCSID), pPortInfo[dwDevInd].Csid);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
			goto exit_dev_loop;
		}

		(*ppSvcConfig)->pDevConfig[dwDevInd].dwPriority = pPortInfo[dwDevInd].Priority;

		(*ppSvcConfig)->pDevConfig[dwDevInd].dwRings = pPortInfo[dwDevInd].Rings;

		if (!FaxOpenPort(hService, pPortInfo[dwDevInd].DeviceId, PORT_OPEN_QUERY, &hPort))
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FaxOpenPort"), GetLastError());
			goto exit_dev_loop;
		}

		if (!FaxEnumRoutingMethods(hPort, &pRoutingMethods, &dwMethodsCount))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("FaxEnumRoutingMethods"), dwEC);
			goto exit_dev_loop;
		}

		for (dwMethodsInd = 0; dwMethodsInd < dwMethodsCount; dwMethodsInd++)
		{
			LPTSTR	*lplptstrMethodInfo	= NULL;
			BOOL	*pbMethodEnabled	= NULL;
			LPBYTE	lpbBuffer			= NULL;
			DWORD	dwBufSize			= 0;

			if (_tcscmp(pRoutingMethods[dwMethodsInd].Guid, pTestParams->pStrings->lptstrGuidPrintOn) == 0)
			{
				lplptstrMethodInfo = &((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrPrinter);
				pbMethodEnabled = &((*ppSvcConfig)->pDevConfig[dwDevInd].bPrinter);
			}
			else if (_tcscmp(pRoutingMethods[dwMethodsInd].Guid, pTestParams->pStrings->lptstrGuidStoreInFolder) == 0)
			{
				lplptstrMethodInfo = &((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrFolder);
				pbMethodEnabled = &((*ppSvcConfig)->pDevConfig[dwDevInd].bFolder);
			}
			else
			{
				continue;
			}

			if (!FaxGetRoutingInfo(hPort, pRoutingMethods[dwMethodsInd].Guid, &lpbBuffer, &dwBufSize))
			{
				dwEC = GetLastError();
				DbgMsg(DBG_FAILED_ERR, TEXT("FaxGetRoutingInfo"), dwEC);
				goto exit_methods_loop;
			}
			
			// first DWORD in the buffer tells whether the method is enabled, skip it
			// the rest of the buffer is Unicode string, convert (if needed)
			dwEC = StrWideToGenericAllocAndCopy(
				lplptstrMethodInfo,
				(LPCWSTR)(lpbBuffer + sizeof(DWORD))
				);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("StrWideToGenericAllocAndCopy"), dwEC);
				goto exit_methods_loop;
			}

			*pbMethodEnabled = pRoutingMethods[dwMethodsInd].Enabled;

exit_methods_loop:

			if (lpbBuffer)
			{
				FaxFreeBuffer(lpbBuffer);
			}

			if (dwEC != ERROR_SUCCESS)
			{
				goto exit_dev_loop;
			}
		}

exit_dev_loop:
	
		if (pRoutingMethods)
		{
			FaxFreeBuffer(pRoutingMethods);
		}

		if (hPort)
		{
			FaxClose(hPort);
		}

		if (dwEC != ERROR_SUCCESS)
		{
			goto exit_func;
		}
	}

	dwEC = GetUserInfoReg(pTestParams, &((*ppSvcConfig)->pUserInfo));
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetUserInfoReg"), dwEC);
		goto exit_func;
	}

exit_func:

	if (pPortInfo)
	{
		FaxFreeBuffer(pPortInfo);
	}
	if (hService && !FaxClose(hService))
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetUserInfoReg"), GetLastError());
	}
	if (dwEC != ERROR_SUCCESS && *ppSvcConfig)
	{
		dwCleanUpEC = FreeSvcConfig(ppSvcConfig);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Reads settings from inifile and saves them in SVCCONFIG structure.
	The structure is allocated by the function and should be freed by FreeSvcConfig()
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	Name of the section in inifile
	[OUT]	ppSvcConfig		Pointer to pointer to SVCCONFIG structure
							*ppSvcConfig must be NULL when the function is called
							*ppSvcConfig remains NULL if the function failes

	Return value:			Win32 error code

	If the function failes, it destroyes partially initialized structure
	and sets *ppSvcConfig to NULL
--*/
DWORD GetSvcConfigFile(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, SVCCONFIG **ppSvcConfig)
{
	std::map<tstring, tstring>::const_iterator MapIterator;
	DWORD	dwDevInd				= 0;
	DWORD	dwPerDevSettingsCount	= 0;
	DWORD	dwEC					= ERROR_SUCCESS;
	DWORD	dwCleanUpEC				= ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection);

	/* do we lose a valid pointer? */
	_ASSERT(ppSvcConfig && *ppSvcConfig == NULL);
	
	if (!(pTestParams && lpctstrSection && ppSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));

		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// get map of test case parameters from ini file
	std::map<tstring, tstring> mParams = INI_GetSectionEntries(pTestParams->lptstrIniFile, lpctstrSection);
	if (mParams.empty())
	{
		dwEC = ERROR_NOT_FOUND;
		DbgMsg(
			TEXT("section %s not found in %s inifile\n"),
			lpctstrSection,
			pTestParams->lptstrIniFile
			);
		goto exit_func;
	}

	if (!(*ppSvcConfig = (SVCCONFIG *)LocalAlloc(LPTR, sizeof(SVCCONFIG))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	(*ppSvcConfig)->dwDevCount = pTestParams->dwDevicesCount;

	if (!((*ppSvcConfig)->pDevConfig = (DEVCONFIG *)LocalAlloc(LPTR, sizeof(DEVCONFIG) * (*ppSvcConfig)->dwDevCount)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	for (dwDevInd = 0; dwDevInd < (*ppSvcConfig)->dwDevCount; dwDevInd++)
	{
		DWORD	dwMembersCount		= sizeof(aDevConfigDescIni) / sizeof(aDevConfigDescIni[0]);
		DWORD	dwMembersInd		= 0;
		TCHAR	tszValueName[30];

		dwEC = StrAllocAndCopy(
			&((*ppSvcConfig)->pDevConfig[dwDevInd].lptstrName),
			pTestParams->aDevicesNames[dwDevInd]
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
			goto exit_func;
		}

		for (dwMembersInd = DEVCONFIG_INI_PER_SUITE_SETTINGS; dwMembersInd < dwMembersCount; dwMembersInd++)
		{
			if (dwMembersInd < DEVCONFIG_INI_PER_SUITE_SETTINGS + DEVCONFIG_INI_PER_DEVICE_SETTINGS)
			{
				// should read per test case per device

				_stprintf(tszValueName, TEXT("%s%ld"), aDevConfigDescIni[dwMembersInd].lpctstrName, dwDevInd);
			}
			else
			{
				// should read per test case, the same for all devices

				_stprintf(tszValueName, TEXT("%s"), aDevConfigDescIni[dwMembersInd].lpctstrName);
			}

			MapIterator = mParams.find(tszValueName);
			if(MapIterator == mParams.end())
			{
				dwEC = ERROR_NOT_FOUND;
				DbgMsg(
					TEXT("value %s not found in %s section of %s inifile\n"),
					tszValueName,
					lpctstrSection,
					pTestParams->lptstrIniFile
					);
				goto exit_func;
			}
			dwEC = StrToMember(
				(LPBYTE)((*ppSvcConfig)->pDevConfig + dwDevInd) + aDevConfigDescIni[dwMembersInd].dwOffset,
				MapIterator->second.c_str(),
				aDevConfigDescIni[dwMembersInd].dwType
				);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("StrToMember"), dwEC);
				goto exit_func;
			}
		}

		if ((*ppSvcConfig)->pDevConfig[dwDevInd].dwType != 0 &&
			(*ppSvcConfig)->pDevConfig[dwDevInd].dwType != FPF_SEND &&
			(*ppSvcConfig)->pDevConfig[dwDevInd].dwType != FPF_RECEIVE &&
			(*ppSvcConfig)->pDevConfig[dwDevInd].dwType != (FPF_SEND | FPF_RECEIVE)
			)
		{
			DbgMsg(TEXT("unknown device type: %s\n"), MapIterator->second.c_str());
			dwEC = ERROR_INVALID_DATA;
			goto exit_func;
		}
	}

	dwEC = GetUserInfoFile(pTestParams, lpctstrSection, &((*ppSvcConfig)->pUserInfo));
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetUserInfoFile"), dwEC);
		goto exit_func;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS && *ppSvcConfig)
	{
		dwCleanUpEC = FreeSvcConfig(ppSvcConfig);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Sets configuration via Configuration Wizard
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pSvcConfig		Pointer to SVCCONFIG structure
	[IN]	bSave			Specifies whether changes should be actually saved (Finish button)
							or discarded (Cancel button)
	[OUT]	lpdwType		Pointer to DWORD that represents send/receive capability of the configuration.
							If the configuration specifies at least one sending device,
							then FPF_SEND bits are set in the DWORD.
							If the configuration specifies at least one receiving device,
							then FPF_RECEIVE bits are set in the DWORD.

	Return value:			Win32 error code
--*/
DWORD SetSvcConfigCW(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, BOOL bSave, DWORD *lpdwType)
{
	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && pSvcConfig);
	if (!(pTestParams && pSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	if (lpdwType)
	{
		*lpdwType = 0;
	}
	
	// invoke the Wizard explicitly
	dwEC = LaunchApp(NULL, NULL, pTestParams->pStrings->lptstrCmdLnCW);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LaunchApp"), dwEC);
		goto exit_func;
	}

	// set user information
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwEC = SetUserInfo(pTestParams, pSvcConfig->pUserInfo, VT_ACT_NONE, NULL, FALSE);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetUserInfo"), dwEC);
		goto exit_func;
	}

	// set sending configuration
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwEC = SetSendingCW(pTestParams, pSvcConfig, lpdwType);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetSendingCW"), dwEC);
		goto exit_func;
	}

	// set receiving configuration
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwEC = SetReceivingCW(pTestParams, pSvcConfig, lpdwType);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetReceivingCW"), dwEC);
		goto exit_func;
	}

	// Completing page
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	if (bSave)
	{
		WButtonClick(VT_BUTTON_FINISH, VT_TIMEOUT);
	}
	else
	{
		WButtonClick(VT_BUTTON_CANCEL, VT_TIMEOUT);
	}

	// give the service some time to write to the registry
	Sleep(SHORT_SLEEP);

	// check whether error message box appeared
	if (WFndWndC(pTestParams->pStrings->lpstrStaticMBIntErr, VT_CLASS_STATIC, FW_DEFAULT | FW_FOCUS, VT_TIMEOUT))
	{
		DbgMsg(TEXT("ERROR DURING CONFIGURATION SAVING. TEST PROGRAM IS SUSPENDED. PRESS ENTER TO CONTINUE.\n"));
		getchar();
		dwEC = 0xFFFFFFFF;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS && dwEC != 0xFFFFFFFF)
	{
		DWORD dwCleanUpEC;
		dwCleanUpEC = CloseApp(pTestParams->pStrings->lpstrWndCapCW, VT_ACT_BUTTON, VT_BUTTON_CANCEL);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("CloseApp"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Writes service configuration details to log
  
	[IN]	lpctstrTitle	Title that will precede details (may be NULL)
	[IN]	pSvcConfig		Pointer to SVCCONFIG structure

	Return value:			Win32 error code
--*/
DWORD LogSvcConfig(LPCTSTR lpctstrTitle, const SVCCONFIG *pSvcConfig)
{
	DWORD	dwDevInd	= 0;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(pSvcConfig);
	if (!pSvcConfig)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if (lpctstrTitle)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("%s"), lpctstrTitle);
	}

	// devices configuration
	for (dwDevInd = 0; dwDevInd < pSvcConfig->dwDevCount; dwDevInd++)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("\tDevice%ld:"), dwDevInd);

		dwEC = LogStruct(
			pSvcConfig->pDevConfig + dwDevInd,
			aDevConfigDescIni,
			sizeof(aDevConfigDescIni) / sizeof(aDevConfigDescIni[0])
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("LogStruct"), dwEC);
			return dwEC;
		}
	}

	// user information
	lgLogDetail(LOG_X, LOG_X, TEXT("\tUser Information:"));
	dwEC = LogStruct(
		pSvcConfig->pUserInfo,
		aUserInfoDescIni,
		sizeof(aUserInfoDescIni) / sizeof(aUserInfoDescIni[0])
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LogStruct"), dwEC);
		return dwEC;
	}

	return ERROR_SUCCESS;
}



/*++
	Receives SVCCONFIG structure and makes some changes in it.
	The changes DOES NOT propagated to the service.
  
	[IN/OUT]	pSvcConfig	Pointer to SVCCONFIG structure

	Return value:			Win32 error code
--*/
DWORD ChangeSvcConfig(SVCCONFIG *pSvcConfig)
{
	DWORD dwInd = 0;

	_ASSERT(pSvcConfig);
	if (!pSvcConfig)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	for (dwInd = 0; dwInd < pSvcConfig->dwDevCount; dwInd++)
	{
		pSvcConfig->pDevConfig[dwInd].dwType ^= (FPF_SEND | FPF_RECEIVE);
		pSvcConfig->pDevConfig[dwInd].dwPriority = pSvcConfig->dwDevCount - pSvcConfig->pDevConfig[dwInd].dwPriority + 1;
		pSvcConfig->pDevConfig[dwInd].dwRings++;
	}

	return ERROR_SUCCESS;
}



/*++
	Checks whether a SVCCONFIG structure is "identical" to a "base" SVCCONFIG structure.
	Implementation of this function should reflect the policy, implemented in Configuration Wizard.
	Example:
		If the policy is not to save routing information for disabled method, it's clear
		that requested (base) and saved (checked) configurations will not be the same.
	In order to make the implementation more generic and flexible, dwPolicy argument is used.
  
	[IN]	pTestParams				Pointer to TESTPARAMS structure
	[IN]	pSvcConfigChecked		Pointer to SVCCONFIG structure which should be checked
	[IN]	pSvcConfigBase			Pointer to the "base" SVCCONFIG structure
	[IN]	dwPolicy				Specifies the policy that will be applied to configurations comparison:

		1)	Type and Priority are checked always
		2)	If dwPolicy contains COMPARE_SEND, TSID is checked
		3)	If dwPolicy contains COMPARE_RECEIVE, CSID and dwRings are checked
		4)	If dwPolicy contains COMPARE_ROUTING_OPTIONS_WHEN_ENABLED, then:
				a)	bPrinter is checked if there are non fax printers installed
				b)	bFolder is checked
		5)	If dwPolicy contains COMPARE_ROUTING_OPTIONS_ALWAYS, bPrinter and bFolder are checked
		6)	If dwPolicy contains COMPARE_ROUTING_INFO_WHEN_ENABLED, then:
				a)	lptstrPrinter is checked if bPrinter is TRUE
				b)	lptstrFolder is checked if bFolder is TRUE
		7) If dwPolicy contains COMPARE_ROUTING_INFO_ALWAYS, lptstrPrinter and lptstrFolder are checked
		8) If dwPolicy contains COMPARE_USERINFO, user information fields are checked

	[OUT]	lpbIdentical			Pointer to a boolean that receives the result of comparison
	[OUT]	lptstrFirstMismatch		Pointer to a buffer that receives name of the first field that causes two
									configurations to be not identical (according to the selected policy). May be NULL.
	[IN]	dwFirstMismatchSize		Size of the buffer, pointed to by lptstrFirstMismatch

	Return value:					Win32 error code
--*/
DWORD CompareSvcConfig(
	const TESTPARAMS *pTestParams,
	const SVCCONFIG *pSvcConfigChecked,
	const SVCCONFIG *pSvcConfigBase,
	DWORD dwPolicy,
	BOOL *lpbIdentical,
	LPTSTR lptstrFirstMismatch,
	DWORD dwFirstMismatchSize
	)
{
	LPCTSTR	lpctstrTmpFirstMismatch	= NULL;
	DWORD	dwCheckedInd			= 0;
	BOOL	bTmpIdentical			= FALSE;
	DWORD	dwBaseInd				= 0;
	DWORD	dwEC					= ERROR_SUCCESS;

	_ASSERT(pTestParams && pSvcConfigChecked && pSvcConfigBase && &bTmpIdentical);
	if (!(pTestParams && pSvcConfigChecked && pSvcConfigBase && &bTmpIdentical))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}
	
	if (pSvcConfigChecked->dwDevCount != pSvcConfigBase->dwDevCount)
	{
		*lpbIdentical = FALSE;
		return ERROR_SUCCESS;
	}

	for (dwCheckedInd = 0; dwCheckedInd < pSvcConfigChecked->dwDevCount; dwCheckedInd++)
	{
		// search for corresponding device in base configuration and compare
		for (dwBaseInd = 0; dwBaseInd < pSvcConfigBase->dwDevCount; dwBaseInd++)
		{
			bTmpIdentical = FALSE;

			/*
			the right way is to compare IDs, will be done later

			if (pSvcConfigChecked->pDevConfig[dwCheckedInd].dwID != pSvcConfigBase->pDevConfig[dwBaseInd].dwID)
			{
				continue;
			}
			*/

			if (_tcscmp(pSvcConfigChecked->pDevConfig[dwCheckedInd].lptstrName, pSvcConfigBase->pDevConfig[dwBaseInd].lptstrName) != 0)
			{
				// the device doesn't correspond

				// continue search
				continue;
			}

			// compare dwType
			if (pSvcConfigChecked->pDevConfig[dwCheckedInd].dwType != pSvcConfigBase->pDevConfig[dwBaseInd].dwType)
			{
				lpctstrTmpFirstMismatch = TEXT("Type");
				break;
			}

			// compare dwPriority
			if (pSvcConfigChecked->pDevConfig[dwCheckedInd].dwPriority != pSvcConfigBase->pDevConfig[dwBaseInd].dwPriority)
			{
				lpctstrTmpFirstMismatch = TEXT("Priority");
				break;
			}

			if ((dwPolicy & COMPARE_SEND) == COMPARE_SEND)
			{
				// compare lptstrTSID
				if (_tcscmp(pSvcConfigChecked->pDevConfig[dwCheckedInd].lptstrTSID, pSvcConfigBase->pDevConfig[dwBaseInd].lptstrTSID) != 0)
				{
					lpctstrTmpFirstMismatch = TEXT("TSID");
					break;
				}
			}

			if ((dwPolicy & COMPARE_RECEIVE) == COMPARE_RECEIVE)
			{
				// compare lptstrCSID
				if (_tcscmp(pSvcConfigChecked->pDevConfig[dwCheckedInd].lptstrCSID, pSvcConfigBase->pDevConfig[dwBaseInd].lptstrCSID) != 0)
				{
					lpctstrTmpFirstMismatch = TEXT("CSID");
					break;
				}

				// compare dwRings
				if (pSvcConfigChecked->pDevConfig[dwCheckedInd].dwRings != pSvcConfigBase->pDevConfig[dwBaseInd].dwRings)
				{
					lpctstrTmpFirstMismatch = TEXT("Rings");
					break;
				}
			}

			if ((dwPolicy & COMPARE_ROUTING_OPTIONS_WHEN_ENABLED) == COMPARE_ROUTING_OPTIONS_WHEN_ENABLED)
			{
				BOOL bTmpRes = FALSE;

				// compare bPrinter
				if ((dwPolicy & COMPARE_ROUTING_OPTIONS_ALWAYS) == COMPARE_ROUTING_OPTIONS_ALWAYS)
				{
					bTmpRes = TRUE;
				}
				else
				{
					dwEC = DoesPrinterExist(NULL, FALSE, &bTmpRes);
					if (dwEC != ERROR_SUCCESS)
					{
						DbgMsg(DBG_FAILED_ERR, TEXT("DoesPrinterExist"), dwEC);
						break;
					}
				}
				if (bTmpRes)
				{
					if (pSvcConfigChecked->pDevConfig[dwCheckedInd].bPrinter != pSvcConfigBase->pDevConfig[dwBaseInd].bPrinter)
					{
						lpctstrTmpFirstMismatch = TEXT("PrinterEnabled");
						break;
					}
				}

				// compare bFolder
				if (pSvcConfigChecked->pDevConfig[dwCheckedInd].bFolder != pSvcConfigBase->pDevConfig[dwBaseInd].bFolder)
				{
					lpctstrTmpFirstMismatch = TEXT("FolderEnabled");
					break;
				}
			}

			if ((dwPolicy & COMPARE_ROUTING_INFO_WHEN_ENABLED) == COMPARE_ROUTING_INFO_WHEN_ENABLED)
			{
				if (pSvcConfigChecked->pDevConfig[dwCheckedInd].bPrinter ||
					(dwPolicy & COMPARE_ROUTING_INFO_ALWAYS) == COMPARE_ROUTING_INFO_ALWAYS
					)
				{
					// compare lptstrPrinter
					if (_tcscmp(pSvcConfigChecked->pDevConfig[dwCheckedInd].lptstrPrinter, pSvcConfigBase->pDevConfig[dwBaseInd].lptstrPrinter) != 0)
					{
						lpctstrTmpFirstMismatch = TEXT("PrinterName");
						break;
					}
				}
				if (pSvcConfigChecked->pDevConfig[dwCheckedInd].bFolder ||
					(dwPolicy & COMPARE_ROUTING_INFO_ALWAYS) == COMPARE_ROUTING_INFO_ALWAYS
					)
				{
					// compare lptstrFolder
					if (_tcscmp(pSvcConfigChecked->pDevConfig[dwCheckedInd].lptstrFolder, pSvcConfigBase->pDevConfig[dwBaseInd].lptstrFolder) != 0)
					{
						lpctstrTmpFirstMismatch = TEXT("FolderName");
						break;
					}
				}
			}

			bTmpIdentical = TRUE;
			break;
		}

		if (!bTmpIdentical)
		{
			// corresponding device in base configuration not found, not identical or an error occured

			break;
		}
	}

	if (bTmpIdentical && (dwPolicy & COMPARE_USERINFO) == COMPARE_USERINFO)
	{
		// we get here if there were no errors and configuratons are identical so far

		dwEC = CompareStruct(
			pSvcConfigChecked->pUserInfo,
			pSvcConfigBase->pUserInfo,
			aUserInfoDescIni,
			sizeof(aUserInfoDescIni) / sizeof(aUserInfoDescIni[0]),
			&bTmpIdentical
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("CompareStruct"), dwEC);
		}

		if (!bTmpIdentical)
		{
			lpctstrTmpFirstMismatch = TEXT("UserInfo");
		}
	}

	if (dwEC != ERROR_SUCCESS)
	{
		return dwEC;
	}

	if (!bTmpIdentical && lptstrFirstMismatch)
	{
		_ASSERT(lpctstrTmpFirstMismatch);

		if (_tcslen(lpctstrTmpFirstMismatch) < dwFirstMismatchSize)
		{
			_tcscpy(lptstrFirstMismatch, lpctstrTmpFirstMismatch);
		}
		else
		{
			return ERROR_INSUFFICIENT_BUFFER;
		}
	}

	*lpbIdentical = bTmpIdentical;

	return ERROR_SUCCESS;
}


/*++
	Frees SVCCONFIG structure
  
	[IN/OUT]	ppSvcConfig	Pointer to pointer to SVCCONFIG structure
						ppSvcConfig must point to a valid pointer
						*ppSvcConfig is set to NULL

	Return value:		Win32 error code (currently always ERROR_SUCCESS)
--*/
DWORD FreeSvcConfig(SVCCONFIG **ppSvcConfig)
{
	DWORD	dwDevInd	= 0;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(ppSvcConfig && *ppSvcConfig);
	if (!(ppSvcConfig && *ppSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if ((*ppSvcConfig)->pDevConfig)
	{
		for (dwDevInd = 0; dwDevInd < (*ppSvcConfig)->dwDevCount; dwDevInd++)
		{
			dwEC = FreeStruct(
				(*ppSvcConfig)->pDevConfig + dwDevInd,
				aDevConfigDescIni,
				sizeof(aDevConfigDescIni) / sizeof(aDevConfigDescIni[0]),
				FALSE
				);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("FreeStruct"), dwEC);
			}
		}

		LocalFree((*ppSvcConfig)->pDevConfig);
	}

	LocalFree(*ppSvcConfig);
	*ppSvcConfig = NULL;
	
	return dwEC;
}



/*++
	Checkes whether printer or printer connection with specified name exists.

	[IN]	lpctstrPrinterName		Name of a printer or printer connection. If it is NULL or empty string (""), 
									the function searches for any printer.
	[IN]	bAllowFax				Specifies whether fax printers should be included in the search.
	[OUT]	lpbResult				Pointer to a boolean that receives the result.

	Return value:	Win32 error code
--*/
DWORD DoesPrinterExist(LPCTSTR lpctstrPrinterName, BOOL bAllowFax, BOOL *lpbResult)
{
    PBYTE				pbBuffer		= NULL;
	PPRINTER_INFO_2		pPrinterInfo	= NULL;
    DWORD				dwBufSize		= 0;
	DWORD				dwPrintersCount	= 0;
	DWORD				dwInd			= 0;
	DWORD				dwEC			= ERROR_SUCCESS;

	_ASSERT(lpbResult);
	if (!lpbResult)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	*lpbResult = FALSE;

	// get required buffer size
	if (EnumPrinters(
		PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
	    NULL,
		2,			// PRINTER_INFO_2
		NULL,
		0,
		&dwBufSize,
		&dwPrintersCount
		))
	{
		_ASSERT(FALSE);
	}
    dwEC = GetLastError();
	if (dwEC != ERROR_INSUFFICIENT_BUFFER) 
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("EnumPrinters"), dwEC);
		goto exit_func;
	}
	dwEC = ERROR_SUCCESS;

	// got the size, go with it
	if (!(pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwBufSize)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}
    if (!EnumPrinters(
		PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
	    NULL,
		2,		// PRINTER_INFO_2
		pbBuffer,
		dwBufSize,
		&dwBufSize,
		&dwPrintersCount
		))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("EnumPrinters"), dwEC);
		goto exit_func;
    }

	pPrinterInfo = (PPRINTER_INFO_2)pbBuffer;

    for (dwInd = 0; dwInd < dwPrintersCount; dwInd++) 
    {
        // we check the printer attribute instead of comparing driver name
        if (bAllowFax || ((pPrinterInfo[dwInd].Attributes & PRINTER_ATTRIBUTE_FAX) != PRINTER_ATTRIBUTE_FAX))
        {
			if (!lpctstrPrinterName || *lpctstrPrinterName == (TCHAR)'\0')
			{
				// any printer is good enough

				break;
			}
			if (_tcscmp(lpctstrPrinterName, pPrinterInfo[dwInd].pPrinterName) == 0)
			{
				break;
			}
		}
	}

	if (dwInd < dwPrintersCount)
	{
		*lpbResult = TRUE;
	}

exit_func:

	if (pbBuffer)
	{
		LocalFree(pbBuffer);
	}

	return dwEC;
}



/*++
	Allows / denies specified user to configure Fax service

	[IN]	lptstrUser		User name. If it's NULL, access is set for currently logged on user
	[IN]	bAdmin			Specifies whether access should be allowed (TRUE) or denied (FALSE)

	Return value:			Win32 error code
--*/

DWORD SetAdminRights(LPTSTR lptstrUser, BOOL bAdmin)
{
	HANDLE					hFaxServer			=	NULL;
	SECURITY_INFORMATION	SecurityInformation	=	DACL_SECURITY_INFORMATION;
	PSECURITY_DESCRIPTOR	pCurrSecDesc		=	NULL;
	PSECURITY_DESCRIPTOR	pNewSecDescAbs		=	NULL;
	PSECURITY_DESCRIPTOR	pNewSecDescRel		=	NULL;
	PACL					pCurrDacl			=	NULL;
	PACL					pNewDacl			=	NULL;
	BOOL					bDaclPresent		=	FALSE;
	BOOL					bDaclDefaulted		=	FALSE;
	EXPLICIT_ACCESS			ManageAccess		=	{
														FAX_ACCESS_ADMIN,
														bAdmin ? GRANT_ACCESS : DENY_ACCESS,
														NO_INHERITANCE,
														{
															NULL,
															NO_MULTIPLE_TRUSTEE,
															TRUSTEE_IS_NAME,
															TRUSTEE_IS_USER,
															lptstrUser ? lptstrUser : TEXT("CURRENT_USER")
														}
													};
	DWORD					dwSecDescSize		=	0;
	DWORD					dwEC				=	ERROR_SUCCESS;

	if (!FaxConnectFaxServer(NULL, &hFaxServer))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxConnectFaxServer"), dwEC);
		goto exit_func;
	}

	// get current security descriptor form the service
	if (!FaxGetSecurity(hFaxServer, &pCurrSecDesc))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxGetSecurity"), dwEC);
		goto exit_func;
	}
	if (!GetSecurityDescriptorDacl(
		pCurrSecDesc,
		&bDaclPresent,
		&pCurrDacl,
		&bDaclDefaulted
		))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSecurityDescriptorDacl"), dwEC);
		goto exit_func;
	}
	if (!bDaclPresent)
	{
		dwEC = 0xFFFFFFFF;
		DbgMsg(TEXT("DACL not found\n"));
		goto exit_func;
	}

	// create new DACL
	dwEC = SetEntriesInAcl(1, &ManageAccess, pCurrDacl, &pNewDacl);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetAclInformation"), dwEC);
		goto exit_func;
	}

	// create new security descriptor in absolute form
	if (!(pNewSecDescAbs = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, SECURITY_DESCRIPTOR_MIN_LENGTH)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}
	if (!InitializeSecurityDescriptor(pNewSecDescAbs, SECURITY_DESCRIPTOR_REVISION))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("InitializeSecurityDescriptor"), dwEC);
		goto exit_func;
	}

	// add newly created DACL to it
	if (!SetSecurityDescriptorDacl(pNewSecDescAbs, TRUE, pNewDacl, FALSE))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("SetSecurityDescriptorDacl"), dwEC);
		goto exit_func;
	}

	// convert newly created security descriptor into self relative form
	if (MakeSelfRelativeSD(pNewSecDescAbs, pNewSecDescRel, &dwSecDescSize))
	{
		_ASSERT(FALSE);
	}
	if ((dwEC = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("MakeSelfRelativeSD"), dwEC);
		goto exit_func;
	}
	dwEC = ERROR_SUCCESS;

	if (!(pNewSecDescRel = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSecDescSize)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}
	if (!MakeSelfRelativeSD(pNewSecDescAbs, pNewSecDescRel, &dwSecDescSize))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("MakeSelfRelativeSD"), dwEC);
		goto exit_func;
	}
	
	// apply new security descriptor to the service
	if (!FaxSetSecurity(hFaxServer, SecurityInformation, pNewSecDescRel))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxSetSecurity"), dwEC);
		goto exit_func;
	}

exit_func:

	if (pNewDacl && LocalFree(pNewDacl) != NULL)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalFree"), GetLastError());
	}
	if (pCurrSecDesc)
	{
		FaxFreeBuffer(pCurrSecDesc);
	}
	if (pNewSecDescAbs)
	{
		LocalFree(pNewSecDescAbs);
	}
	if (pNewSecDescRel)
	{
		LocalFree(pNewSecDescRel);
	}
	if (hFaxServer && !FaxClose(hFaxServer))
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("FaxClose"), GetLastError());
	}

	return dwEC;
}



/*++
	Creates the full path of IniFile.
	Currently searches only in current directory
  
	[IN]	lpctstrIniFile				Name of inifile

	[OUT]	lplptstrIniFileFullPath		Pointer to pointer to a full path of the IniFile
										*lplptstrIniFileFullPath must be NULL when the function is called
										*lplptstrIniFileFullPath remains NULL if the function failes

	Return value:						Win32 error code
--*/
static DWORD GetIniFileFullPath (LPCTSTR lpctstrIniFileName, LPTSTR *lplptstrIniFileFullPath)
{
	LPTSTR	lptstrFilePart	= NULL;
	DWORD	dwRequiredSize	= 0;
	DWORD	dwEC			= ERROR_SUCCESS;

	_ASSERT(lpctstrIniFileName);

	// do we lose a valid pointer ?
	_ASSERT(lplptstrIniFileFullPath && *lplptstrIniFileFullPath == NULL);

	if (!(lpctstrIniFileName && lplptstrIniFileFullPath))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	dwRequiredSize = SearchPath(NULL, lpctstrIniFileName, NULL, 0, NULL, &lptstrFilePart);
	if (dwRequiredSize == 0)
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("SearchPath"), dwEC);
		goto exit_func;
	}

	if (!(*lplptstrIniFileFullPath = (LPTSTR)LocalAlloc(LMEM_FIXED, dwRequiredSize * sizeof(TCHAR))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	dwRequiredSize = SearchPath(NULL, lpctstrIniFileName, NULL, dwRequiredSize, *lplptstrIniFileFullPath, &lptstrFilePart);
	if (dwRequiredSize == 0)
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("SearchPath"), dwEC);
		goto exit_func;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS)
	{
		if (*lplptstrIniFileFullPath && LocalFree(*lplptstrIniFileFullPath) != NULL)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("LocalFree"), GetLastError());
		}
	}
	
	return dwEC;
}




/*++
	Reads settings from inifile and saves them in TESTPARAMS structure
	The structure is allocated by the function and should be freed by FreeTestParams()
  
	[OUT]	ppTestParams		Pointer to pointer to TESTPARAMS structure
								*ppTestParams must be NULL when the function is called
								*ppTestParams remains NULL if the function failes
	[IN]	lpctstrIniFile		Name of inifile

	Return value:				Win32 error code

	If the function failes, it destroyes partially initialized structure and sets *ppTestParams to NULL
--*/
static DWORD GetTestParams(TESTPARAMS **ppTestParams, LPCTSTR lpctstrIniFile)
{
	std::map<tstring, tstring>::const_iterator MapIterator;
	DWORD	dwInd		= 0;
	DWORD	dwEC		= ERROR_SUCCESS;
	DWORD	dwCleanUpEC	= ERROR_SUCCESS;

	_ASSERT(lpctstrIniFile);

	/* do we lose a valid pointer? */
	_ASSERT(ppTestParams && *ppTestParams == NULL);
	
	if (!(ppTestParams && lpctstrIniFile))
	{
		DbgMsg(TEXT("Invalid parameters\n"));

		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// read devices

	// get map of devices from ini file
	std::map<tstring, tstring> mDevices = INI_GetSectionEntries(lpctstrIniFile, INI_SEC_DEVICES);
	if (mDevices.empty())
	{
		dwEC = ERROR_NOT_FOUND;
		DbgMsg(
			TEXT("section %s not found in %s inifile\n"),
			INI_SEC_DEVICES,
			lpctstrIniFile
			);
		goto exit_func;
	}

	if (!(*ppTestParams = (TESTPARAMS *)LocalAlloc(LPTR, sizeof(TESTPARAMS))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	(*ppTestParams)->dwDevicesCount = mDevices.size();

	if (!((*ppTestParams)->aDevicesNames = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR) * (*ppTestParams)->dwDevicesCount)))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	MapIterator = mDevices.begin();
	for (dwInd = 0; dwInd < (*ppTestParams)->dwDevicesCount; dwInd++)
	{
		dwEC = StrAllocAndCopy(&((*ppTestParams)->aDevicesNames[dwInd]), MapIterator->first.c_str());
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
			goto exit_func;
		}

		MapIterator++;
	}

	dwEC = StrAllocAndCopy(&((*ppTestParams)->lptstrIniFile), lpctstrIniFile);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrAllocAndCopy"), dwEC);
		goto exit_func;
	}

	// read common strings

	if (!((*ppTestParams)->pStrings = (COMMONSTRINGS *)LocalAlloc(LPTR, sizeof(COMMONSTRINGS))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}
	dwEC = ReadStructFromIniFile(
		(*ppTestParams)->pStrings,
		aCommonStringsDescIni,
		sizeof(aCommonStringsDescIni) / sizeof(aCommonStringsDescIni[0]),
		lpctstrIniFile,
		INI_SEC_STRINGS
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ReadStructFromIniFile"), dwEC);
		goto exit_func;
	}

exit_func:

	if (dwEC != ERROR_SUCCESS && *ppTestParams)
	{
		// TESTPARAMS structure is partially initialized, should free

		dwCleanUpEC = FreeTestParams(ppTestParams);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeTestParams"), dwCleanUpEC);
		}
	}

	return dwEC;
}



/*++
	Frees TESTPARAMS structure, initialized by GetTestParams()
  
	[IN/OUT]	ppTestParams	Pointer to pointer to TESTPARAMS structure
								ppTestParams must point to a valid pointer
								*ppTestParams is set to NULL
	[IN]		pTestSuite		Pointer to TESTSUITE structure

	Return value:				Win32 error code
--*/
static DWORD FreeTestParams(TESTPARAMS **ppTestParams)
{
	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(ppTestParams && *ppTestParams);
	if (!(ppTestParams && *ppTestParams))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if ((*ppTestParams)->lptstrIniFile)
	{
		LocalFree((*ppTestParams)->lptstrIniFile);
	}
	
	if ((*ppTestParams)->pStrings)
	{
		dwEC = FreeStruct(
			(*ppTestParams)->pStrings,
			aCommonStringsDescIni,
			sizeof(aCommonStringsDescIni) / sizeof(aCommonStringsDescIni[0]),
			TRUE
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeStruct"), dwEC);
		}
	}

	if ((*ppTestParams)->aDevicesNames)
	{
		DWORD dwInd = 0;

		for (dwInd = 0; dwInd < (*ppTestParams)->dwDevicesCount; dwInd++)
		{
			if ((*ppTestParams)->aDevicesNames[dwInd])
			{
				LocalFree((*ppTestParams)->aDevicesNames[dwInd]);
			}
		}

		LocalFree((*ppTestParams)->aDevicesNames);
	}

	LocalFree(*ppTestParams);
	*ppTestParams = NULL;

	return dwEC;
}



/*++
	Sets sending related part of configuration via Configuration Wizard
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pSvcConfig		Pointer to SVCCONFIG structure
	[OUT]	lpdwType		Pointer to DWORD that represents send/receive capability of the configuration.
							If the configuration specifies at least one sending device, FPF_SEND bits are set in the DWORD.

	Return value:			Win32 error code
--*/
static DWORD SetSendingCW(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, DWORD *lpdwType)
{
	BOOL	bSend		= FALSE;
	LPSTR	lpstrBuffer	= NULL;
	DWORD	dwInd		= 0;
	DWORD	dwDevCount	= 0;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(pTestParams && pSvcConfig);
	if (!(pTestParams && pSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}
	
	dwDevCount = WViewCount(pTestParams->pStrings->lpstrLstCWSendDev, VT_TIMEOUT);
	_ASSERT(dwDevCount == pSvcConfig->dwDevCount);

	dwEC = ViewResetA(pTestParams->pStrings->lpstrLstCWSendDev);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ViewResetA"), dwEC);
		goto exit_func;
	}

	for (dwInd = 0; dwInd < dwDevCount; dwInd++)
	{
		DWORD dwPosition = 0;
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[dwInd].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		dwPosition = WViewItemIndex(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VT_TIMEOUT);

		while (dwPosition < pSvcConfig->pDevConfig[dwInd].dwPriority)
		{
			// select the item and move it one position down
			WViewItemClk(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);
			WButtonClick(VT_BUTTON_DOWN, VT_TIMEOUT);
			dwPosition++;
		}
		while (dwPosition > pSvcConfig->pDevConfig[dwInd].dwPriority)
		{
			// select the item and move it one position up
			WViewItemClk(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);
			WButtonClick(VT_BUTTON_UP, VT_TIMEOUT);
			dwPosition--;
		}
		if ((pSvcConfig->pDevConfig[dwInd].dwType & FPF_SEND) == FPF_SEND)
		{
			// check item's checkbox
			WViewItemDblClk(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);
			bSend = TRUE;
		}

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}

	if (bSend)
	{
		if (lpdwType)
		{
			*lpdwType |= FPF_SEND;
		}
	}
	else
	{
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[0].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		// temporaraly enable send related controls in oreder to set configuration
		// disable them before return 
		WViewItemDblClk(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}

	// TSID page
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwEC = StrGenericToAnsiAllocAndCopy(&lpstrBuffer, pSvcConfig->pDevConfig[0].lptstrTSID);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		goto exit_func;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtCWTSID, lpstrBuffer, VT_TIMEOUT);
	LocalFree(lpstrBuffer);

exit_func:

	if (dwEC == ERROR_SUCCESS && !bSend)
	{
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[0].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		// disable temporaraly enabled controls
		WButtonClick(VT_BUTTON_BACK, VT_TIMEOUT);
		WViewItemDblClk(pTestParams->pStrings->lpstrLstCWSendDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}

	return dwEC;
}



/*++
	Sets receiving related part of configuration via Configuration Wizard
  
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	pSvcConfig		Pointer to SVCCONFIG structure
	[OUT]	lpdwType		Pointer to DWORD that represents send/receive capability of the configuration.
							If the configuration specifies at least one receiving device, FPF_RECEIVE bits are set in the DWORD.

	Return value:			Win32 error code
--*/
static DWORD SetReceivingCW(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, DWORD *lpdwType)
{
	char	szRings[DWORD_DECIMAL_LENGTH + 1];
	BOOL	bReceive	= FALSE;
	BOOL	bTmpRes		= FALSE;
	DWORD	dwInd		= 0;
	DWORD	dwDevCount	= 0;
	LPSTR	lpstrBuffer = NULL;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(pTestParams && pSvcConfig);
	if (!(pTestParams && pSvcConfig))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// Receiving devices page

	dwDevCount = WViewCount(pTestParams->pStrings->lpstrLstCWReceiveDev, VT_TIMEOUT);
	_ASSERT(dwDevCount == pSvcConfig->dwDevCount);
		 
	dwEC = ViewResetA(pTestParams->pStrings->lpstrLstCWReceiveDev);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ViewResetA"), dwEC);
		goto exit_func;
	}

	for (dwInd = 0; dwInd < dwDevCount; dwInd++)
	{
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[dwInd].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		if ((pSvcConfig->pDevConfig[dwInd].dwType & FPF_RECEIVE) == FPF_RECEIVE)
		{
			// check item's checkbox
			WViewItemDblClk(pTestParams->pStrings->lpstrLstCWReceiveDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);
			bReceive = TRUE;
		}

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}
	if (bReceive)
	{
		if (lpdwType)
		{
			*lpdwType |= FPF_RECEIVE;
		}
	}
	else
	{
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[0].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		// temporaraly enable receive related controls in oreder to set configuration
		// disable them before return 
		WViewItemDblClk(pTestParams->pStrings->lpstrLstCWReceiveDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}

	// Rings
	WEditSetText(
		pTestParams->pStrings->lpstrEdtCWAnswerAfter,
		_itoa(pSvcConfig->pDevConfig[0].dwRings, szRings, 10),
		VT_TIMEOUT
		);
	
	// CSID page
	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);
	dwEC = StrGenericToAnsiAllocAndCopy(&lpstrBuffer, pSvcConfig->pDevConfig[0].lptstrCSID);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		goto exit_func;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtCWCSID, lpstrBuffer, VT_TIMEOUT);
	LocalFree(lpstrBuffer);
	lpstrBuffer = NULL;

	// Routing page

	WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT);

	// Printer
	dwEC = DoesPrinterExist(pSvcConfig->pDevConfig[0].lptstrPrinter, FALSE, &bTmpRes);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("DoesPrinterExist"), dwEC);
		goto exit_func;
	}
	if (!bTmpRes)
	{
		DbgMsg(TEXT("printer not found: %s\n"), pSvcConfig->pDevConfig[0].lptstrPrinter);
		dwEC = ERROR_NOT_FOUND;
		goto exit_func;
	}
	WCheckCheck(pTestParams->pStrings->lpstrChkCWPrintItOn, VT_TIMEOUT);
	dwEC = StrGenericToAnsiAllocAndCopy(&lpstrBuffer, pSvcConfig->pDevConfig[0].lptstrPrinter);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		goto exit_func;
	}
	WComboSetText(pTestParams->pStrings->lpstrCmbCWPrintItOn, lpstrBuffer, VT_TIMEOUT);
	LocalFree(lpstrBuffer);
	lpstrBuffer = NULL;
	if (!pSvcConfig->pDevConfig[0].bPrinter)
	{
		WCheckUnCheck(pTestParams->pStrings->lpstrChkCWPrintItOn, VT_TIMEOUT);
	}

	// Folder
	WCheckCheck(pTestParams->pStrings->lpstrChkCWSaveInFolder, VT_TIMEOUT);
	dwEC = StrGenericToAnsiAllocAndCopy(&lpstrBuffer, pSvcConfig->pDevConfig[0].lptstrFolder);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
		goto exit_func;
	}
	WEditSetText(pTestParams->pStrings->lpstrEdtCWSaveInFolder, lpstrBuffer, VT_TIMEOUT);
	LocalFree(lpstrBuffer);
	lpstrBuffer = NULL;
	if (!pSvcConfig->pDevConfig[0].bFolder)
	{
		WCheckUnCheck(pTestParams->pStrings->lpstrChkCWSaveInFolder, VT_TIMEOUT);
	}

exit_func:

	if (dwEC == ERROR_SUCCESS && !bReceive)
	{
		LPSTR lpstrDevName = NULL;

		dwEC = StrGenericToAnsiAllocAndCopy(&lpstrDevName, pSvcConfig->pDevConfig[0].lptstrName);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("StrGenericToAnsiAllocAndCopy"), dwEC);
			goto exit_func;
		}

		// disable temporaraly enabled controls
		WButtonClick(VT_BUTTON_BACK, VT_TIMEOUT);
		WButtonClick(VT_BUTTON_BACK, VT_TIMEOUT);
		WViewItemDblClk(pTestParams->pStrings->lpstrLstCWReceiveDev, lpstrDevName, VK_LBUTTON, VT_TIMEOUT);

		if (lpstrDevName)
		{
			LocalFree(lpstrDevName);
		}
	}

	return dwEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\dummylogelle.cpp ===
#include "..\Log\LogElle.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\cfgwzrdvt.h ===
#ifndef __CFGWZRDVT_H__
#define __CFGWZRDVT_H__

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include "testsuite.h"

// some numeric constants
#define VT_TIMEOUT					2		// seconds
#define VT_STRING_LENGTH			200

#define SHORT_SLEEP					1000	// milliseconds

// standatd window classes
#define VT_CLASS_STATIC				"STATIC"

// standard menus
#define VT_MENU_EXIT				"File\\Exit"

// standard buttons captions
#define VT_BUTTON_YES				"Yes"
#define VT_BUTTON_NO				"No"
#define VT_BUTTON_OK				"OK"
#define VT_BUTTON_CANCEL			"Cancel"
#define VT_BUTTON_NEXT				"Next >"
#define VT_BUTTON_BACK				"< Back"
#define VT_BUTTON_FINISH			"Finish"
#define VT_BUTTON_UP				"Up"
#define VT_BUTTON_DOWN				"Down"

// some additional constants used in Visual Test part

#define VT_ACT_NONE					0x00000000
#define VT_ACT_BUTTON				0x00000001
#define VT_ACT_MENU					0x00000002


typedef struct commonstrings_tag {
	// generic strings
	LPTSTR lptstrCmdLnCC;
	LPTSTR lptstrCmdLnSW;
	LPTSTR lptstrCmdLnCW;
	LPTSTR lptstrRegKeyDevicePart;
	LPTSTR lptstrRegKeyUserPart;
	LPTSTR lptstrRegValDevice;
	LPTSTR lptstrRegValUser;
	LPTSTR lptstrRegKeyUserInfo;
	LPTSTR lptstrRegValUserName;
	LPTSTR lptstrRegValFaxNumber;
	LPTSTR lptstrRegValEmail;
	LPTSTR lptstrRegValTitle;
	LPTSTR lptstrRegValCompany;
	LPTSTR lptstrRegValOffice;
	LPTSTR lptstrRegValDepartment;
	LPTSTR lptstrRegValHomePhone;
	LPTSTR lptstrRegValWorkPhone;
	LPTSTR lptstrRegValBillingCode;
	LPTSTR lptstrRegValStreet;
	LPTSTR lptstrRegValCity;
	LPTSTR lptstrRegValState;
	LPTSTR lptstrRegValZip;
	LPTSTR lptstrRegValCountry;
	LPTSTR lptstrUsername;
	LPTSTR lptstrPassword;
	LPTSTR lptstrGuidPrintOn;
	LPTSTR lptstrGuidStoreInFolder;
	LPTSTR lptstrServiceName;
	// ANSI strings
	LPSTR lpstrSendName;
	LPSTR lpstrSendNumber;
	LPSTR lpstrSendSubject;
	LPSTR lpstrWndCapCC;
	LPSTR lpstrWndCapSW;
	LPSTR lpstrWndCapCW;
	LPSTR lpstrWndCapUI;
	LPSTR lpstrWndCapAC;
	LPSTR lpstrEdtSWName;
	LPSTR lpstrChkSWDialAsEntered;
	LPSTR lpstrEdtSWNumber;
	LPSTR lpstrLstSWRecipients;
	LPSTR lpstrBtnSWRemove;
	LPSTR lpstrBtnSWAdd;
	LPSTR lpstrEdtSWSubject;
	LPSTR lpstrOptSWNoReceipt;
	LPSTR lpstrEdtUIName;
	LPSTR lpstrEdtUIFaxNumber;
	LPSTR lpstrEdtUIEmail;
	LPSTR lpstrEdtUITitle;
	LPSTR lpstrEdtUICompany;
	LPSTR lpstrEdtUIOffice;
	LPSTR lpstrEdtUIDepartment;
	LPSTR lpstrEdtUIHomePhone;
	LPSTR lpstrEdtUIWorkPhone;
	LPSTR lpstrEdtUIBillingCode;
	LPSTR lpstrBtnUIAddress;
	LPSTR lpstrEdtUIStreet;
	LPSTR lpstrEdtUICity;
	LPSTR lpstrEdtUIState;
	LPSTR lpstrEdtUIZip;
	LPSTR lpstrCmbUICountry;
	LPSTR lpstrChkUIThisOnly;
	LPSTR lpstrBtnSWSenderInfo;
	LPSTR lpstrMenuCCUserInfo;
	LPSTR lpstrEdtCWName;
	LPSTR lpstrLstCWSendDev;
	LPSTR lpstrBtnCWUp;
	LPSTR lpstrBtnCWDown;
	LPSTR lpstrEdtCWAnswerAfter;
	LPSTR lpstrEdtCWTSID;
	LPSTR lpstrLblCWNoDevelected;
	LPSTR lpstrLstCWReceiveDev;
	LPSTR lpstrEdtCWCSID;
	LPSTR lpstrChkCWPrintItOn;
	LPSTR lpstrChkCWSaveInFolder;
	LPSTR lpstrCmbCWPrintItOn;
	LPSTR lpstrEdtCWSaveInFolder;
	LPSTR lpstrStaticMBIntErr;
} COMMONSTRINGS;

struct testparams_tag {
	LPTSTR			lptstrIniFile;
	COMMONSTRINGS	*pStrings;
	DWORD			dwDevicesCount;
	LPTSTR			*aDevicesNames;
};

typedef struct devconfig_tag {
	DWORD dwID;
	LPTSTR lptstrName;
	DWORD dwType;
	LPTSTR lptstrTSID;
	LPTSTR lptstrCSID;
	DWORD dwPriority;
	DWORD dwRings;
	BOOL bPrinter;
	BOOL bFolder;
	LPTSTR lptstrPrinter;
	LPTSTR lptstrFolder;
} DEVCONFIG;


typedef struct userinfo_tag {
	LPTSTR lptstrName;
	LPTSTR lptstrFaxNumber;
	LPTSTR lptstrEmail;
	LPTSTR lptstrTitle;
	LPTSTR lptstrCompany;
	LPTSTR lptstrOffice;
	LPTSTR lptstrDepartment;
	LPTSTR lptstrHomePhone;
	LPTSTR lptstrWorkPhone;
	LPTSTR lptstrBillingCode;
	LPTSTR lptstrStreet;
	LPTSTR lptstrCity;
	LPTSTR lptstrState;
	LPTSTR lptstrZip;
	LPTSTR lptstrCountry;
} USERINFO;


typedef struct svcconfig_tag {
	DEVCONFIG *pDevConfig;
	DWORD dwDevCount;
	USERINFO *pUserInfo;
} SVCCONFIG;


#define COMPARE_USERINFO						0x00000001
#define COMPARE_SEND							0x00000002
#define	COMPARE_RECEIVE							0x00000004
#define COMPARE_ROUTING_OPTIONS_WHEN_ENABLED	0x0000000C	// COMPARE_RECEIVE						| 0x00000008
#define COMPARE_ROUTING_OPTIONS_ALWAYS			0x0000001C	// COMPARE_ROUTING_INFO_WHEN_ENABLED	| 0x00000010
#define COMPARE_ROUTING_INFO_WHEN_ENABLED		0x0000002C	// COMPARE_ROUTING_OPTIONS_WHEN_ENABLED	| 0x00000020
#define COMPARE_ROUTING_INFO_ALWAYS				0x0000007C	// COMPARE_ROUTING_OPTIONS_ALWAYS		| COMPARE_ROUTING_INFO_WHEN_ENABLED	| 0x00000040
#define COMPARE_FULL							0xFFFFFFFF


DWORD	LaunchApp				(LPCTSTR lpctstrUsername, LPCTSTR lpctstrPassword, LPTSTR lptstrCmdLine);
DWORD	CloseApp				(LPSTR lpstrCaption, DWORD dwCloseType, LPSTR lpstrText);
DWORD	GetUserInfoReg			(const TESTPARAMS *pTestParams, USERINFO **ppUserInfo);
DWORD	GetUserInfoFile			(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, USERINFO **ppUserInfo);
DWORD	SetUserInfoCC			(const TESTPARAMS *pTestParams, const USERINFO *pUserInfo);
DWORD	SetUserInfoSW			(const TESTPARAMS *pTestParams, const USERINFO *pUserInfo, BOOL bForThisOnly);
DWORD	SetUserInfo				(const TESTPARAMS *pTestParams, const USERINFO *pUserInfo, DWORD dwOpenType, LPSTR lpstrText,  BOOL bForThisOnly);
DWORD	FreeUserInfo			(USERINFO **ppUserInfo);
DWORD	ViewResetA				(LPSTR lpcstrControl);
DWORD	GetSvcConfigAPI			(const TESTPARAMS *pTestParams, SVCCONFIG **ppSvcConfig);
DWORD	GetSvcConfigFile		(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, SVCCONFIG **ppSvcConfig);
DWORD	SetSvcConfigCW			(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfig, BOOL bSave, DWORD *lpdwType);
DWORD	LogSvcConfig			(LPCTSTR lpctstrTitle, const SVCCONFIG *pSvcConfig);
DWORD	ChangeSvcConfig			(SVCCONFIG *pSvcConfig);
DWORD	CompareSvcConfig		(const TESTPARAMS *pTestParams, const SVCCONFIG *pSvcConfigChecked, const SVCCONFIG *pSvcConfigBase, DWORD dwType, BOOL *lpbIdentical, LPTSTR lptstrFirstMismatch, DWORD dwFirstMismatchSize);
DWORD	FreeSvcConfig			(SVCCONFIG **ppSvcConfig);
DWORD	DoesPrinterExist		(LPCTSTR lpctstrPrinterName, BOOL bAllowFax, BOOL *lpbResult);
DWORD	SetAdminRights			(LPTSTR lptstrUser, BOOL bAdmin);


#endif /* __CFGWZRDVT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\functionality.h ===
#ifndef __FUNCTIONALITY_H__
#define __FUNCTIONALITY_H__

#include "testsuite.h"

extern const TESTAREA taFunctionality;

DWORD TestCase_SaveSettings(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);
DWORD TestCase_DontSaveWhenCanceled(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);

#endif /* #ifndef __FUNCTIONALITY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\invocation.h ===
#ifndef __INVOCATION_H__
#define __INVOCATION_H__

#include "testsuite.h"

extern const TESTAREA taInvocation;

DWORD TestCase_Clean		(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);
DWORD TestCase_Cancel		(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);
DWORD TestCase_ConfigureUI	(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);
DWORD TestCase_ConfigureAll	(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);

#endif /* #ifndef __INVOCATION_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\functionality.cpp ===
/*++
	This file implements functionality test of Configuration Wizard

	Author: Yury Berezansky (yuryb)

	31.10.2000
--*/

#pragma warning(disable :4786)

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include <FXSAPIP.h>
#include "..\..\include\t4ctrl.h"
#include "..\generalutils\iniutils.h"
#include "genutils.h"
#include "report.h"
#include "CfgWzrdVT.h"
#include "functionality.h"


/**************************************************************************************************************************
	General declarations and definitions
**************************************************************************************************************************/

static const TESTCASE mpitcFunctionality[] = {
	{TestCase_SaveSettings, TEXT("SaveSettings")},
	{TestCase_DontSaveWhenCanceled, TEXT("DontSaveWhenCanceled")}
};

extern const TESTAREA taFunctionality = {
	TEXT("Functionality"),
	mpitcFunctionality,
	sizeof(mpitcFunctionality) / sizeof(mpitcFunctionality[0])
};

#define CURRENT_POLICY (/*COMPARE_USERINFO |*/ COMPARE_SEND | COMPARE_ROUTING_INFO_WHEN_ENABLED)




/**************************************************************************************************************************
	Static functions declarations
**************************************************************************************************************************/
//
//
//





/**************************************************************************************************************************
	Functions definitions
**************************************************************************************************************************/

/*++
	Checks that the wizard correctly saves valid configuration.

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_SaveSettings(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	SVCCONFIG	*pSvcConfigWizard	= NULL;
	SVCCONFIG	*pSvcConfigService	= NULL;
	TCHAR		szFirstMismatch[50]	= {(TCHAR)'\0'};
	DWORD		dwType				= 0;
	DWORD		dwPolicy			= 0;
	DWORD		dwEC				= ERROR_SUCCESS;
	DWORD		dwCleanUpEC			= ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// make sure that current user has service administrator rights
	dwEC = SetAdminRights(NULL, TRUE);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetAdminRights"), dwEC);
		goto exit_func;
	}

	dwEC = GetSvcConfigFile(pTestParams, lpctstrSection, &pSvcConfigWizard);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigFile"), dwEC);
		goto exit_func;
	}

	dwEC = LogSvcConfig(TEXT("Set following configuration via the wizard:"), pSvcConfigWizard);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LogSvcConfig"), dwEC);
		goto exit_func;
	}

	dwEC = SetSvcConfigCW(pTestParams, pSvcConfigWizard, TRUE, &dwType);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetSvcConfigCW"), dwEC);
		goto exit_func;
	}

	// read new (hopefully) configuration from the service
	dwEC = GetSvcConfigAPI(pTestParams, &pSvcConfigService);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigAPI"), dwEC);
		goto exit_func;
	}

	dwEC = LogSvcConfig(TEXT("Service configuration is:"), pSvcConfigService);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LogSvcConfig"), dwEC);
		goto exit_func;
	}

	// set comparison policy
	/*
	if ((dwType & FPF_SEND) == FPF_SEND)
	{
		dwPolicy |= COMPARE_SEND;
	}
	if ((dwType & FPF_RECEIVE) == FPF_RECEIVE)
	{
		dwPolicy |= COMPARE_RECEIVE;
	}
	*/
	
	// compare configurations
	dwPolicy = CURRENT_POLICY;
	lgLogDetail(LOG_X, LOG_X, TEXT("Comparison policy is set to 0x%0*lX"), DWORD_HEX_LENGTH, dwPolicy);

	dwEC = CompareSvcConfig(
		pTestParams,
		pSvcConfigService,
		pSvcConfigWizard,
		dwPolicy,
		lpbPassed,
		szFirstMismatch,
		sizeof(szFirstMismatch) / sizeof(szFirstMismatch[0])
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CompareSvcConfig"), dwEC);
		goto exit_func;
	}
	if (!*lpbPassed)
	{
		lgLogError(LOG_SEV_1, TEXT("Configurations are NOT identical according to the selected policy"));
		lgLogDetail(LOG_X, LOG_X, TEXT("First mismatch found in %s"), szFirstMismatch);
	}

exit_func:
	
	if (pSvcConfigWizard)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfigWizard);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwCleanUpEC);
		}
	}

	if (pSvcConfigService)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfigService);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwEC);
		}
	}

	return dwEC;
}



/*++
	Checks that the wizard doesn't save configuration if canceled

	[IN]	pTestParams				Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_DontSaveWhenCanceled(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	SVCCONFIG	*pSvcConfigWizard	= NULL;
	SVCCONFIG	*pSvcConfigService1	= NULL;
	SVCCONFIG	*pSvcConfigService2	= NULL;
	TCHAR		szFirstMismatch[50]	= {(TCHAR)'\0'};
	DWORD		dwEC				= ERROR_SUCCESS;
	DWORD		dwCleanUpEC			= ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// make sure that current user has service administrator rights
	dwEC = SetAdminRights(NULL, TRUE);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetAdminRights"), dwEC);
		goto exit_func;
	}

	// read current settings and save a copy
	dwEC = GetSvcConfigAPI(pTestParams, &pSvcConfigService1);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigAPI"), dwEC);
		goto exit_func;
	}
	
	// read current settings and "change" them
	dwEC = GetSvcConfigAPI(pTestParams, &pSvcConfigWizard);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigAPI"), dwEC);
		goto exit_func;
	}
	dwEC = ChangeSvcConfig(pSvcConfigWizard);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ChangeSvcConfig"), dwEC);
		goto exit_func;
	}
	// pass through all steps and press Cancel
	dwEC = SetSvcConfigCW(pTestParams, pSvcConfigWizard, FALSE, NULL);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("SetSvcConfigCW"), dwEC);
		goto exit_func;
	}

	// get a fresh copy of settings and compare with the previously saved
	dwEC = GetSvcConfigAPI(pTestParams, &pSvcConfigService2);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigAPI"), dwEC);
		goto exit_func;
	}
	dwEC = CompareSvcConfig(
		pTestParams,
		pSvcConfigService2,
		pSvcConfigService1,
		COMPARE_FULL,
		lpbPassed,
		szFirstMismatch,
		sizeof(szFirstMismatch) / sizeof(szFirstMismatch[0])
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CompareSvcConfig"), dwEC);
		goto exit_func;
	}
	if (!*lpbPassed)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Wizard saves changes when Cancel button is pressed")
			);
		dwEC = LogSvcConfig(TEXT("Configuration before the wizard invocation is:"), pSvcConfigService1);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("LogSvcConfig"), dwEC);
			goto exit_func;
		}
		dwEC = LogSvcConfig(TEXT("Configuration after the wizard invocation is:"), pSvcConfigService2);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("LogSvcConfig"), dwEC);
			goto exit_func;
		}
		lgLogError(LOG_SEV_1, TEXT("First mismatch found in %s"), szFirstMismatch);
	}

exit_func:

	if (pSvcConfigWizard)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfigWizard);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwCleanUpEC);
		}
	}

	if (pSvcConfigService1)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfigService1);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwEC);
		}
	}

	if (pSvcConfigService2)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfigService2);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwEC);
		}
	}

	return dwEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\genutils.h ===
#ifndef __GENUTILS_H__
#define __GENUTILS_H__


#define DWORD_DECIMAL_LENGTH	9	// number of digits in decimal representation of the largest DWORD
#define DWORD_HEX_LENGTH		8	// number of digits in hexadecimal representation of the largest DWORD



DWORD	RandomStringA					(LPCSTR lpcstrSource, LPSTR lpstrDestBuf, DWORD *lpdwBufSize, char chPad);
char	RandomCharA						(void);
DWORD	StrAllocAndCopy					(LPTSTR *lplptstrDest, LPCTSTR lpctstrSrc);
DWORD	StrGenericToAnsiAllocAndCopy	(LPSTR *lplpstrDest, LPCTSTR lpctstrSrc);
DWORD	StrWideToGenericAllocAndCopy	(LPTSTR *lplptstrDest, LPCWSTR lpcwstrSrc);
DWORD	_tcsToDword						(LPCTSTR lpctstr, DWORD *lpdw);
DWORD	_tcsToBool						(LPCTSTR lpctstr, BOOL *lpb);


#endif /* #ifndef __GENUTILS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\invocation.cpp ===
/*++
	This file implements test of implicit invocation of Configuration Wizard

	Author: Yury Berezansky (yuryb)

	17.10.2000
--*/

#pragma warning(disable :4786)

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <userenv.h>
#include <crtdbg.h>
#include <FXSAPIP.h>
#include "..\..\include\t4ctrl.h"
#include "..\generalutils\iniutils.h"
#include "genutils.h"
#include "report.h"
#include "CfgWzrdVT.h"
#include "invocation.h"


/**************************************************************************************************************************
	General declarations and definitions
**************************************************************************************************************************/

#define INVOKE_IMP_CC				0x00000001
#define INVOKE_IMP_SW				0x00000002
#define	INVOKE_EXP					0x00000004
#define INVOKE_MASK					(INVOKE_IMP_CC | INVOKE_IMP_SW | INVOKE_EXP)

#define CANCEL_FIRST_TIME			0x00000100
#define SHOW_AGAIN					0x00000300	// CANCEL_FIRST_TIME	| 0x00000200
#define CONFIGURE_UI				0x00000500	// CANCEL_FIRST_TIME	| 0x00000400
#define SINGLE_USE					0x00000D00	// CONFIGURE_UI			| 0x00000800
#define CONFIGURE_ALL				0x00001400

#define USER_ADMIN					0x00010000
#define USER_OTHER					0x00020000

#define	PART_NONE					0x00000000  // the wizard shouldn't be invoked
#define PART_USER					0x01000000
#define	PART_SERVICE				0x02000000
#define PART_DONT_CARE				0x07000000	// the fact of invocation is important and not the parts



static DWORD aInvocations[] = {
	INVOKE_IMP_CC									,
	INVOKE_IMP_CC	|	USER_ADMIN					,
	INVOKE_IMP_CC	|					USER_OTHER	,
	INVOKE_IMP_CC	|	USER_ADMIN	|	USER_OTHER	,
	INVOKE_IMP_SW									,
	INVOKE_IMP_SW	|	USER_ADMIN					,
	INVOKE_IMP_SW	|					USER_OTHER	,
	INVOKE_IMP_SW	|	USER_ADMIN	|	USER_OTHER	,
	INVOKE_EXP										,
	INVOKE_EXP		|	USER_ADMIN					, /*, Don't run because of problems with CreateProcessAsUser */
	INVOKE_EXP		|					USER_OTHER	,
	INVOKE_EXP		|	USER_ADMIN	|	USER_OTHER
};


static const TESTCASE mpitcInvocation[] = {
	{TestCase_Clean, TEXT("Clean")},
	{TestCase_Cancel, TEXT("Cancel")},
	{TestCase_ConfigureUI, TEXT("ConfigureUI")},
	{TestCase_ConfigureAll, TEXT("ConfigureAll")}
};


extern const TESTAREA taInvocation = {
	TEXT("Invocation"),
	mpitcInvocation,
	sizeof(mpitcInvocation) / sizeof(mpitcInvocation[0])
};





/**************************************************************************************************************************
	Static functions declarations
**************************************************************************************************************************/

static	DWORD	ResetInvocationFlags	(const TESTPARAMS *pTestParams, LPTSTR lptstrUser, LPTSTR lptstrPassword);
static	DWORD	InvokeWizard			(const TESTPARAMS *pTestParams, DWORD dwFlags, BOOL bCloseMainApp, DWORD *lpdwActualParts);
static	DWORD	CheckAllInvocations		(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, DWORD dwPreActions, BOOL *lpbResult);
static	DWORD	LogInvocationDetails	(LPCTSTR lpctstrTitle, DWORD dwPreActions, DWORD dwInvocation);
static	DWORD	LogParts				(LPCTSTR lpctstrTitle, DWORD dwParts);

/**************************************************************************************************************************
	Functions definitions
**************************************************************************************************************************/

/*++
	Checks the wizard invocations after clean setup (simulated)

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_Clean(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	*lpbPassed = FALSE;
	
	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, 0, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	return ERROR_SUCCESS;
}



/*++
	Checks the wizard invocation after it was canceled

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_Cancel(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	*lpbPassed = FALSE;
	
	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_CC | CANCEL_FIRST_TIME, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_SW | CANCEL_FIRST_TIME, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_CC | CANCEL_FIRST_TIME | SHOW_AGAIN, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_SW | CANCEL_FIRST_TIME | SHOW_AGAIN, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_EXP | CANCEL_FIRST_TIME, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	return ERROR_SUCCESS;
}



/*++
	Checkes the wizard invocation after user information external configuration

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_ConfigureUI(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	*lpbPassed = FALSE;
	
	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_CC | CANCEL_FIRST_TIME | SHOW_AGAIN | CONFIGURE_UI, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_SW | CANCEL_FIRST_TIME | SHOW_AGAIN | CONFIGURE_UI, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_IMP_SW | CANCEL_FIRST_TIME | SHOW_AGAIN | CONFIGURE_UI | SINGLE_USE, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	return ERROR_SUCCESS;
}



/*++
	Checkes the wizard invocation after user information and service configuration

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
DWORD TestCase_ConfigureAll(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed) {

	DWORD dwEC = ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbPassed);
	if (!(pTestParams && lpctstrSection && lpbPassed))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	*lpbPassed = FALSE;
	
	dwEC = CheckAllInvocations(pTestParams, lpctstrSection, INVOKE_EXP | CONFIGURE_ALL, lpbPassed);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CheckAllInvocations"), dwEC);
		return dwEC;
	}

	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Auxiliary functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*++
	Clears (sets to 0) registry flags, responible for implicit invocation of Configuration Wizard
  
	[IN]	pTestParams			Pointer to TESTPARAMS structure
	[IN]	lptstrUser			User name
	[IN]	lptstrPassword		Password

	return value:				Win32 error code
--*/
static DWORD ResetInvocationFlags(const TESTPARAMS *pTestParams, LPTSTR lptstrUser, LPTSTR lptstrPassword)
{
	PROFILEINFO		UserProfileInfo;
	HANDLE			hToken		= NULL;
	HKEY			hkUserRoot	= HKEY_CURRENT_USER;
	HKEY			hkDevice	= NULL;
	HKEY			hkUserInfo	= NULL;
	DWORD			dwValue		= 0;
	DWORD			dwEC		= ERROR_SUCCESS;
	DWORD			dwCleanUpEC	= ERROR_SUCCESS;

	_ASSERT(pTestParams);
	if (!pTestParams)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	ZeroMemory(&UserProfileInfo, sizeof(UserProfileInfo));
	UserProfileInfo.dwSize = sizeof(UserProfileInfo);
	UserProfileInfo.lpUserName = lptstrUser;
	
	// clear the flag responsible for service part
	dwEC = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		pTestParams->pStrings->lptstrRegKeyDevicePart,
		0,
		KEY_SET_VALUE,
		&hkDevice
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RegOpenKeyEx"), dwEC);
		goto exit_func;
	}
	dwEC = RegSetValueEx(
		hkDevice,
		pTestParams->pStrings->lptstrRegValDevice,
		0,
		REG_DWORD,
		(CONST BYTE *)&dwValue,
		sizeof(dwValue)
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RegSetValueEx"), dwEC);
		goto exit_func;
	}

	// clear the flag responsible for user part
	if (lptstrUser && lptstrPassword)
	{
		if (!LogonUser(
			lptstrUser,
			TEXT("."),
			lptstrPassword,
			LOGON32_LOGON_BATCH,
			LOGON32_PROVIDER_DEFAULT,
			&hToken
			))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("LogonUser"), dwEC);
			goto exit_func;
		}
		if(!LoadUserProfile(hToken, &UserProfileInfo))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("LoadUserProfile"), dwEC);
			goto exit_func;
		}
		hkUserRoot = (HKEY)UserProfileInfo.hProfile;
	}
	dwEC = RegOpenKeyEx(
		hkUserRoot,
		pTestParams->pStrings->lptstrRegKeyUserPart,
		0,
		KEY_SET_VALUE,
		&hkUserInfo
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RegOpenKeyEx"), dwEC);
		goto exit_func;
	}
	dwEC = RegSetValueEx(
		hkUserInfo,
		pTestParams->pStrings->lptstrRegValUser,
		0,
		REG_DWORD,
		(CONST BYTE *)&dwValue,
		sizeof(dwValue)
		);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("RegSetValueEx"), dwEC);
		goto exit_func;
	}

exit_func:

	if (hkDevice)
	{
		dwCleanUpEC = RegCloseKey(hkDevice);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("RegCloseKey"), dwCleanUpEC);
		}
	}
	if (hkUserInfo)
	{
		dwCleanUpEC = RegCloseKey(hkUserInfo);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("RegCloseKey"), dwCleanUpEC);
		}
	}
	if (UserProfileInfo.hProfile && !UnloadUserProfile(hToken, UserProfileInfo.hProfile))
	{
			DbgMsg(DBG_FAILED_ERR, TEXT("UnloadUserProfile"), GetLastError());
	}
	if (hToken && !CloseHandle(hToken))
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("CloseHandle"), GetLastError());
	}

	return dwEC;
}



/*++
	Checks all invocatinos defined in aInvocations.

	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[IN]	dwPreActions	Specifies which actions should be taken prior to invocations checkes
	[OUT]	lpbResult		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/
static DWORD CheckAllInvocations(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, DWORD dwPreActions, BOOL *lpbResult)
{
	DWORD		dwInd			= 0;
	SVCCONFIG	*pSvcConfig		= NULL;
	USERINFO	*pUserInfo		= NULL;
	BOOL		bTmpRes			= TRUE;
	DWORD		dwEC			= ERROR_SUCCESS;
	DWORD		dwCleanUpEC		= ERROR_SUCCESS;

	_ASSERT(pTestParams && lpctstrSection && lpbResult);
	if (!(pTestParams && lpctstrSection && lpbResult))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}
	
	// clear invocation flags for current user
	dwEC = ResetInvocationFlags(pTestParams, NULL, NULL);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ResetInvocationFlags"), dwEC);
		return dwEC;
	}

	// clear invocation flags for another user
	dwEC = ResetInvocationFlags(pTestParams, pTestParams->pStrings->lptstrUsername, pTestParams->pStrings->lptstrPassword);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("ResetInvocationFlags"), dwEC);
		return dwEC;
	}

	if ((dwPreActions & CANCEL_FIRST_TIME) == CANCEL_FIRST_TIME)
	{
		// invoke the wizard implicitly, cancel, answer "Show again" question, close main App
		dwEC = InvokeWizard(
			pTestParams,
			dwPreActions & (INVOKE_MASK | SHOW_AGAIN),
			(dwPreActions & CONFIGURE_UI) != CONFIGURE_UI,
			NULL
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("InvokeWizard"), dwEC);
			return dwEC;
		}

		if ((dwPreActions & CONFIGURE_ALL) == CONFIGURE_ALL)
		{
			dwEC = GetSvcConfigFile(pTestParams, lpctstrSection, &pSvcConfig);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("GetSvcConfigFile"), dwEC);
				goto exit_func;
			}

			dwEC = SetSvcConfigCW(pTestParams, pSvcConfig, TRUE, NULL);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("SetSvcConfigCW"), dwEC);
				goto exit_func;
			}
		}
		else if ((dwPreActions & CONFIGURE_UI) == CONFIGURE_UI)
		{
			dwEC = GetUserInfoFile(pTestParams, lpctstrSection, &pUserInfo);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("GetUserInfoFile"), dwEC);
				goto exit_func;
			}
			switch (dwPreActions & INVOKE_MASK)
			{
			case INVOKE_IMP_CC:
				dwEC = SetUserInfoCC(pTestParams, pUserInfo);
				if (dwEC != ERROR_SUCCESS)
				{
					DbgMsg(DBG_FAILED_ERR, TEXT("SetUserInfoCC"), dwEC);
					goto exit_func;
				}
				dwEC = CloseApp(pTestParams->pStrings->lpstrWndCapCC, VT_ACT_MENU, VT_MENU_EXIT);
				if (dwEC != ERROR_SUCCESS)
				{
					DbgMsg(DBG_FAILED_ERR, TEXT("CloseApp"), dwEC);
					goto exit_func;
				}
				break;
			case INVOKE_IMP_SW:
				dwEC = SetUserInfoSW(pTestParams, pUserInfo, (dwPreActions & SINGLE_USE) == SINGLE_USE);
				if (dwEC != ERROR_SUCCESS)
				{
					DbgMsg(DBG_FAILED_ERR, TEXT("SetUserInfoCC"), dwEC);
					goto exit_func;
				}
				break;
			default:
				_ASSERT(FALSE);
			}
		}
	}

	for (dwInd = 0; dwInd < sizeof(aInvocations) / sizeof(aInvocations[0]); dwInd++)
	{
		DWORD	dwExpectedParts	= PART_NONE;
		DWORD	dwActualParts	= PART_NONE;

		// User part is expected when one of the following is true:
		//
		// 1) The wizard is invoked explicitly.
		// 2) The wizard is invoked by other user.
		// 3) The wizard is invoked imlicitly and has never been canceled.
		// 4) The wizard is invoked imlicitly. Its previous EXPLICIT invocation has been canceled.
		// 5) The wizard is invoked imlicitly. Its previous IMPLICIT invocation has been canceled
		//    with "Show again" option. User information has never been configured or has been
		//    configured "for single use".
		
		if ((aInvocations[dwInd] & INVOKE_EXP) == INVOKE_EXP			||
			(aInvocations[dwInd] & USER_OTHER) == USER_OTHER			||
			(dwPreActions & CANCEL_FIRST_TIME) != CANCEL_FIRST_TIME		||
			(dwPreActions & INVOKE_EXP) == INVOKE_EXP					||
				((dwPreActions & SHOW_AGAIN) == SHOW_AGAIN					&&
					((dwPreActions & CONFIGURE_UI) != CONFIGURE_UI				||
					(dwPreActions & SINGLE_USE) == SINGLE_USE))
			)
		{
			dwExpectedParts |= PART_USER;
		}

		// Service part is expected when the wizard is invoked by administrator AND
		// one of the following is true:
		//
		// 1) The wizard is invoked explicitly.
		// 2) The wizard is invoked imlicitly and has never been canceled.
		// 3) The wizard is invoked imlicitly. Its previous EXPLICIT invocation has been canceled.
		// 4) The wizard is invoked imlicitly. Its previous IMPLICIT invocation has been canceled
		//    with "Show again" option. Full configuratoin has never been configured.

		if ((aInvocations[dwInd] & USER_ADMIN) == USER_ADMIN			&&
				((aInvocations[dwInd] & INVOKE_EXP) == INVOKE_EXP			||
				(dwPreActions & CANCEL_FIRST_TIME) != CANCEL_FIRST_TIME		||
				(dwPreActions & INVOKE_EXP) == INVOKE_EXP					||
					((dwPreActions & SHOW_AGAIN) == SHOW_AGAIN					&&
					(dwPreActions & CONFIGURE_ALL) != CONFIGURE_ALL))
			)
		{
			dwExpectedParts |= PART_SERVICE;
		}

		dwEC = SetAdminRights(
			(aInvocations[dwInd] & USER_OTHER) == USER_OTHER ? pTestParams->pStrings->lptstrUsername : NULL,
			(aInvocations[dwInd] & USER_ADMIN) == USER_ADMIN
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("SetAdminRights"), dwEC);
			goto exit_func;
		}

		dwEC = LogInvocationDetails(TEXT("Invocation details:"), dwPreActions, aInvocations[dwInd]);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("LogInvocationDetails"), dwEC);
		}

		dwEC = InvokeWizard(pTestParams, aInvocations[dwInd] | SHOW_AGAIN, TRUE, &dwActualParts);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("InvokeWizard"), dwEC);
			goto exit_func;
		}

		if (dwActualParts != dwExpectedParts)
		{
			lgLogError(LOG_SEV_1, TEXT("Invocation failed:"));
			dwEC = LogParts(TEXT("Expected parts:"), dwExpectedParts);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("LogParts"), dwEC);
				goto exit_func;
			}
			dwEC = LogParts(TEXT("Actual parts:"), dwActualParts);
			if (dwEC != ERROR_SUCCESS)
			{
				DbgMsg(DBG_FAILED_ERR, TEXT("LogParts"), dwEC);
				goto exit_func;
			}
			bTmpRes = FALSE;
		}
	}

exit_func:

	if (pSvcConfig)
	{
		dwCleanUpEC = FreeSvcConfig(&pSvcConfig);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeSvcConfig"), dwCleanUpEC);
		}
	}

	if (pUserInfo)
	{
		dwCleanUpEC = FreeUserInfo(&pUserInfo);
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("FreeUserInfo"), dwCleanUpEC);
		}
	}

	if (dwEC == ERROR_SUCCESS)
	{
		*lpbResult = bTmpRes;
	}

	return dwEC;
}



/*++
	Invokes Configuration Wizard, checks which parts it contains and closes it

	[IN]	pTestParams			Pointer to TESTPARAMS structure
	[IN]	dwFlags				Specifies the following:
									1) the way the Wizard should be invoked
									2) whether the wizard should be invoked by other user
									3) which parts the Wizard should contain
									4) response for "Do you want to see this wizard next time..." dialog
	[IN]	bCloseMainApp		Specifies whether the "main" application should be closed
	[OUT]	lpdwActualParts		Pointer to a DWORD that receives bitmask indicating parts, actually existing
								in the wizard. If it is NULL, no check is done.

	Return value:			Win32 error code
--*/
static DWORD InvokeWizard(const TESTPARAMS *pTestParams, DWORD dwFlags, BOOL bCloseMainApp, DWORD *lpdwActualParts)
{
	LPTSTR	lptstrCommandLine	= NULL;
	LPCTSTR	lpctstrUsername		= NULL;
	LPCTSTR	lpctstrPassword		= NULL;
	DWORD	dwTmpActualParts	= PART_NONE;
	DWORD	dwEC				= ERROR_SUCCESS;
	DWORD	dwCleanUpEC			= ERROR_SUCCESS;
	
	_ASSERT(pTestParams);
	if (!pTestParams)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	if ((dwFlags & USER_OTHER) == USER_OTHER)
	{
		lpctstrUsername = pTestParams->pStrings->lptstrUsername;
		lpctstrPassword = pTestParams->pStrings->lptstrPassword;
	}

	// try to invoke the Wizard
	switch (dwFlags & INVOKE_MASK)
	{
	case INVOKE_IMP_CC:
		lptstrCommandLine = pTestParams->pStrings->lptstrCmdLnCC;
		break;
	case INVOKE_IMP_SW:
		lptstrCommandLine = pTestParams->pStrings->lptstrCmdLnSW;
		break;
	case INVOKE_EXP:
		lptstrCommandLine = pTestParams->pStrings->lptstrCmdLnCW;
		break;
	default:
		_ASSERT(FALSE);
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}
	dwEC = LaunchApp(lpctstrUsername, lpctstrPassword, lptstrCommandLine);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("LaunchApp"), dwEC);

		// failed to open an application - shouldn't close it (even if requested)
		bCloseMainApp = FALSE;
		goto exit_func;
	}

	if (!WFndWnd(pTestParams->pStrings->lpstrWndCapCW, FW_DEFAULT | FW_FOCUS, VT_TIMEOUT * 3))
	{
		goto exit_func;
	}

	if (lpdwActualParts)
	{
		// should check which parts the Wizard contains
		
		WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT); // move to 2nd page

		if (WEditExists(
				pTestParams->pStrings->lpstrEdtCWName,
				VT_TIMEOUT
				))
		{
			// 2nd page is "User Info"

			dwTmpActualParts |= PART_USER;
			WButtonClick(VT_BUTTON_NEXT, VT_TIMEOUT); // move to 3rd page
		}

		if (WButtonExists(VT_BUTTON_NEXT, VT_TIMEOUT))
		{
			// current (2nd or 3rd) page is not last page

			dwTmpActualParts |= PART_SERVICE;
		}
	}
		
	WButtonClick(VT_BUTTON_CANCEL, VT_TIMEOUT);

	if ((dwFlags & INVOKE_MASK) != INVOKE_EXP)
	{
		// close the "Do you want to see this wizard next time..."
		dwEC = CloseApp(
			pTestParams->pStrings->lpstrWndCapCW,
			VT_ACT_BUTTON,
			(dwFlags & SHOW_AGAIN) == SHOW_AGAIN ? VT_BUTTON_YES : VT_BUTTON_NO
			);
		if (dwEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("CloseApp"), dwEC);
			goto exit_func;
		}
	}

exit_func:

	if (bCloseMainApp)
	{
		switch (dwFlags & INVOKE_MASK)
		{
		case INVOKE_IMP_CC:
			dwCleanUpEC = CloseApp(pTestParams->pStrings->lpstrWndCapCC, VT_ACT_MENU, VT_MENU_EXIT);
			break;
		case INVOKE_IMP_SW:
			dwCleanUpEC = CloseApp(pTestParams->pStrings->lpstrWndCapSW, VT_ACT_BUTTON, VT_BUTTON_CANCEL);
			break;
		case INVOKE_EXP:
			break;
		default:
			_ASSERT(FALSE);
		}
		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("CloseApp"), dwCleanUpEC);
		}
	}

	if (lpdwActualParts && dwEC == ERROR_SUCCESS)
	{
		*lpdwActualParts = dwTmpActualParts;
	}

	return dwEC;
}


/*++
	Writes invocation details to log
  
	[IN]	lpctstrTitle	Title that will precede details (may be NULL)
	[IN]	dwPreActions	Specifies actions, taken prior to invocation
	[IN]	dwInvocation	Specifies invocation details

	Return value:			Win32 error code
--*/
static DWORD LogInvocationDetails(LPCTSTR lpctstrTitle, DWORD dwPreActions, DWORD dwInvocation)
{
	LPCTSTR	lpctstrInvokeBy1	= NULL;
	LPCTSTR	lpctstrCancel		= NULL;
	LPCTSTR	lpctstrInvokeBy2	= NULL;
	LPCTSTR	lpctstrConfigure	= NULL;
	LPCTSTR	lpctstrUser			= NULL;
	DWORD	dwStep				= 1;

	if (lpctstrTitle)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("%s"), lpctstrTitle);
	}

	switch(dwPreActions & INVOKE_MASK)
	{
	case 0:
		// no actions have been taken prior to invocation
		break;
	case INVOKE_IMP_CC:
		lpctstrInvokeBy1 = TEXT("implicitly by Client Console");
		break;
	case INVOKE_IMP_SW:
		lpctstrInvokeBy1 = TEXT("implicitly by Send Wizard");
		break;
	case INVOKE_EXP:
		lpctstrInvokeBy1 = TEXT("explicitly");
		break;
	default:
		_ASSERT(FALSE);
	}
	
	if ((dwPreActions & CANCEL_FIRST_TIME) == CANCEL_FIRST_TIME)
	{
		if ((dwPreActions & SHOW_AGAIN) == SHOW_AGAIN)
		{
			lpctstrCancel = TEXT("yes");
		}
		else
		{
			lpctstrCancel = TEXT("no");
		}

		if ((dwPreActions & CONFIGURE_ALL) == CONFIGURE_ALL)
		{
			// cannot configure all, if canceled
			_ASSERT(FALSE);
		}
		else if ((dwPreActions & CONFIGURE_UI) == CONFIGURE_UI)
		{
			if ((dwPreActions & SINGLE_USE) == SINGLE_USE)
			{
				lpctstrConfigure = TEXT("Configure user information for single use");
			}
			else
			{
				lpctstrConfigure = TEXT("Configure user information");
			}
		}
	}
	else if ((dwPreActions & CONFIGURE_ALL) == CONFIGURE_ALL)
	{
		lpctstrConfigure = TEXT("Configure all");
	}

	switch(dwInvocation & INVOKE_MASK)
	{
	case INVOKE_IMP_CC:
		lpctstrInvokeBy2 = TEXT("implicitly by Client Console");
		break;
	case INVOKE_IMP_SW:
		lpctstrInvokeBy2 = TEXT("implicitly by Send Wizard");
		break;
	case INVOKE_EXP:
		lpctstrInvokeBy2 = TEXT("explicitly");
		break;
	default:
		_ASSERT(FALSE);
	}

	if ((dwInvocation & USER_OTHER) == USER_OTHER)
	{
		if ((dwInvocation & USER_ADMIN) == USER_ADMIN)
		{
			lpctstrUser = TEXT("other administrator");
		}
		else
		{
			lpctstrUser = TEXT("other regular user");
		}
	}
	else
	{
		if ((dwInvocation & USER_ADMIN) == USER_ADMIN)
		{
			lpctstrUser = TEXT("administrator");
		}
		else
		{
			lpctstrUser = TEXT("regular user");
		}
	}

	if (lpctstrInvokeBy1)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("\t%ld. Invoke %s"), dwStep++, lpctstrInvokeBy1);
	}

	if (lpctstrCancel)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("\t%ld. Cancel first invocation, answer %s"), dwStep++, lpctstrCancel);
	}

	if (lpctstrConfigure)
	{
		lgLogDetail(LOG_X, LOG_X, TEXT("\t%ld. %s"), dwStep++, lpctstrConfigure);
	}

	lgLogDetail(LOG_X, LOG_X, TEXT("\t%ld. Invoke %s as %s"), dwStep++, lpctstrInvokeBy2, lpctstrUser);

	return ERROR_SUCCESS;
}



/*++
	Writes wizard parts to log
  
	[IN]	lpctstrTitle	Title that will precede details (may be NULL)
	[IN]	dwParts			Specifies parts

	Return value:			Win32 error code
--*/
static DWORD LogParts(LPCTSTR lpctstrTitle, DWORD dwParts)
{
	LPCTSTR	lpctstrLocalTitle	= lpctstrTitle ? lpctstrTitle : TEXT("");
	LPCTSTR	lpctstrParts		= NULL;

	switch(dwParts)
	{
	case PART_USER:
		lpctstrParts = TEXT("user part only");
		break;
	case PART_SERVICE:
		lpctstrParts = TEXT("service part only");
		break;
	case (PART_USER | PART_SERVICE):
		lpctstrParts = TEXT("both user and service parts");
		break;
	case PART_NONE:
		lpctstrParts = TEXT("neither user nor service part");
		break;
	default:
		_ASSERT(FALSE);
	}
	
	lgLogDetail(LOG_X, LOG_X, TEXT("%s %s"), lpctstrLocalTitle, lpctstrParts);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\genutils.cpp ===
/*++
	This file implements some general utils

	Author: Yury Berezansky (yuryb)

	07.11.2000
--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include "report.h"
#include "genutils.h"


/**************************************************************************************************************************
	General declarations and definitions
**************************************************************************************************************************/
	//
	//
	//




/**************************************************************************************************************************
	Static functions declarations
**************************************************************************************************************************/
	//
	//
	//


/**************************************************************************************************************************
	Functions definitions
**************************************************************************************************************************/

/*++
	ANSI version
	Creates a random string by appending a decimal representation of the value returned by GetTickCount()
	to specified string and filling of the rest of the buffer with a padding character
  
	[IN]		lpcstrSource	Specifies the prefix of the random string
	[OUT]		lpstrDestBuf	Pointer to a buffer to receive the random string
	[IN/OUT]	lpdwBufSize		Pointer to a variable that:
								On input specifies the size, in characters, of the buffer,
								pointed to by the lpstrDestBuf parameter
								On output, if the function fails with the error ERROR_INSUFFICIENT_BUFFER,
								this variable receives buffer size, in characters, required to hold string
								and its	terminating null character
	[IN]		chPad			Padding character

	Return value:				Win32 error code
--*/
DWORD RandomStringA(LPCSTR lpcstrSource, LPSTR lpstrDestBuf, DWORD *lpdwBufSize, char chPad) {

	DWORD	dwSrcLength	= 0;
	DWORD	dwInd		= 0;

	_ASSERT(lpcstrSource && lpstrDestBuf && lpdwBufSize);
	if (!(lpcstrSource && lpstrDestBuf && lpdwBufSize))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	dwSrcLength = strlen(lpcstrSource);

	// is the buffer big enough?
	// (DWORD_DECIMAL_LENGTH for string representation of DWORD, 1 for terminating '\0')
	if (*lpdwBufSize < dwSrcLength + DWORD_DECIMAL_LENGTH + 1)
	{
		*lpdwBufSize = dwSrcLength + DWORD_DECIMAL_LENGTH + 1;
		return ERROR_INSUFFICIENT_BUFFER;
	}

	// insert terminating '\0' at the last position
	lpstrDestBuf[*lpdwBufSize - 1] = '\0';

	// copy source string
	strcpy(lpstrDestBuf, lpcstrSource);

	// add a random part
	lpstrDestBuf += dwSrcLength;
	sprintf(lpstrDestBuf, "%*d", DWORD_DECIMAL_LENGTH, GetTickCount());

	// fill with padding character
	lpstrDestBuf += DWORD_DECIMAL_LENGTH;
	for (dwInd = 0; dwInd < *lpdwBufSize - (dwSrcLength + DWORD_DECIMAL_LENGTH + 1); dwInd++)
	{
		*lpstrDestBuf++ = chPad;	
	}

	return ERROR_SUCCESS;
}



/*++
	ANSI version
	Returns random English capital
--*/
char RandomCharA(void)
{
	srand(GetTickCount());
	return char((double)rand() / RAND_MAX * ('Z' - 'A')) + 'A';
}



/*++
	Creates a copy of generic (t) string. The function allocates memory that should be freed
	by call to LocalFree().

	[OUT]	lplptstrDest	Pointer to destination string
	[IN]	lpctstrSrc		Source string

	Return value:			Win32 error code
--*/
DWORD StrAllocAndCopy(LPTSTR *lplptstrDest, LPCTSTR lpctstrSrc)
{
	_ASSERT(lpctstrSrc);

	// do we lose a valid pointer ?
	_ASSERT(lplptstrDest && *lplptstrDest == NULL);

	if (!(lplptstrDest && lpctstrSrc))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}

	if (!(*lplptstrDest = (TCHAR *)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (_tcslen(lpctstrSrc) + 1))))
	{
		DWORD dwEC = GetLastError();

		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		return dwEC;
	}

	_tcscpy(*lplptstrDest, lpctstrSrc);

	return ERROR_SUCCESS;
}


/*++
	Creates ANSI copy of generic (t) string. The function allocates memory that should be freed
	by call to LocalFree().

	[OUT]	lplpstrDest		Pointer to destination string
	[IN]	lpctstrSrc		Source string

	Return value:			Win32 error code
--*/
DWORD StrGenericToAnsiAllocAndCopy(LPSTR *lplpstrDest, LPCTSTR lpctstrSrc)
{
	DWORD	dwLength	= 0;
	DWORD	dwEC		= ERROR_SUCCESS;

	_ASSERT(lpctstrSrc);
	
	// do we lose a valid pointer ?
	_ASSERT(lplpstrDest && *lplpstrDest == NULL);

	if (!(lplpstrDest && lpctstrSrc))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	dwLength = _tcslen(lpctstrSrc);

	// memory is always allocated for ANSI string
	if (!(*lplpstrDest = (LPSTR)LocalAlloc(LMEM_FIXED, sizeof(char) * (dwLength + 1))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	if (dwLength == 0)
	{
		**lplpstrDest = '\0';
		goto exit_func;
	}

	#ifdef UNICODE

		// should convert from Unicode to ANSI

		if (!WideCharToMultiByte(
			CP_ACP,							// code page
			0,								// performance and mapping flags
			lpctstrSrc,						// wide-character string
			dwLength + 1,					// number of chars in string
			*lplpstrDest,					// buffer for new string
			dwLength + 1,					// size of buffer
			NULL,							// default for unmappable chars
			NULL							// set when default char used
			))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("WideCharToMultiByte"), dwEC);
			goto exit_func;
		}

	#else

		// string is ANSI, no convertion needed

		strcpy(*lplpstrDest, lpctstrSrc);

	#endif // #ifdef UNICODE

exit_func:

	if (dwEC != ERROR_SUCCESS && *lplpstrDest)
	{
		LocalFree(*lplpstrDest);
		*lplpstrDest = NULL;
	}

	return dwEC;
}



/*++
	Creates generic (t) copy of Unicode string. The function allocates memory that should be freed
	by call to LocalFree().

	[OUT]	lplptstrDest	Pointer to destination string
	[IN]	lpcwstrSrc		Source string

	Return value:			Win32 error code
--*/
DWORD StrWideToGenericAllocAndCopy(LPTSTR *lplptstrDest, LPCWSTR lpcwstrSrc)
{
	DWORD	dwLength	= 0;
	DWORD	dwEC		= ERROR_SUCCESS;
	
	_ASSERT(lpcwstrSrc);

	// do we lose a valid pointer ?
	_ASSERT(lplptstrDest && *lplptstrDest == NULL);
	
	if (!(lplptstrDest && lpcwstrSrc))
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	dwLength = wcslen(lpcwstrSrc);
	
	if (!(*lplptstrDest = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (dwLength + 1))))
	{
	    dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("LocalAlloc"), dwEC);
		goto exit_func;
	}

	if (dwLength == 0)
	{
		**lplptstrDest = (TCHAR)'\0';
		goto exit_func;
	}

	#ifndef UNICODE

		// should convert from Unicode to ANSI

		if (!WideCharToMultiByte(
			CP_ACP,							// code page
			0,								// performance and mapping flags
			lpcwstrSrc,						// wide-character string
			dwLength + 1,					// number of chars in string
			*lplptstrDest,					// buffer for new string
			dwLength + 1,					// size of buffer
			NULL,							// default for unmappable chars
			NULL							// set when default char used
			))
		{
			dwEC = GetLastError();
			DbgMsg(DBG_FAILED_ERR, TEXT("WideCharToMultiByte"), dwEC);
			goto exit_func;
		}

	#else

		// destination is Unicode, no convertion needed

		wcscpy(*lplptstrDest, lpcwstrSrc);

	#endif // #ifndef UNICODE

exit_func:

	if (dwEC != ERROR_SUCCESS && *lplptstrDest)
	{
		LocalFree(*lplptstrDest);
		*lplptstrDest = NULL;
	}

	return dwEC;
}



/*++
	Converts generic (t) string to DWORD.

	[IN]	lpctstr		Pointer to source string
	[OUT]	lpdw		Pointer to DWORD variable that receives the result of convertion

	Return value:		Win32 error code
--*/
DWORD _tcsToDword(LPCTSTR lpctstr, DWORD *lpdw)
{
	long lTmp = 0;

	_ASSERT(lpdw);
	if (!lpdw)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}
	
	if (_tcscmp(lpctstr, TEXT("0")) == 0)
	{
		*lpdw = 0;
		return ERROR_SUCCESS;
	}

	lTmp = _ttol(lpctstr);
	if(lTmp <= 0)
	{
		DbgMsg(TEXT("cannot convert string to DWORD\n"));
		return ERROR_INVALID_PARAMETER;
	}

	*lpdw = (DWORD)lTmp;

	return ERROR_SUCCESS;
}



/*++
	Converts generic (t) string to BOOL.

	[IN]	lpctstr		Pointer to source string
	[OUT]	lpb			Pointer to BOOL variable that receives the result of convertion

	Return value:		Win32 error code
--*/
DWORD _tcsToBool(LPCTSTR lpctstr, BOOL *lpb)
{
	_ASSERT(lpb);
	if (!lpb)
	{
		DbgMsg(TEXT("Invalid parameters\n"));
		return ERROR_INVALID_PARAMETER;
	}
	
	if (_tcscmp(lpctstr, TEXT("0")) == 0)
	{
		*lpb = FALSE;
	}
	else if (_tcscmp(lpctstr, TEXT("1")) == 0)
	{
		*lpb = TRUE;
	}
	else
	{
		DbgMsg(TEXT("cannot convert string to BOOL\n"));
		return ERROR_INVALID_PARAMETER;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\report.h ===
#ifndef __REPORT_H__
#define __REPORT_H__

#include "..\Log\log.h"

#ifdef _DEBUG

	#define DbgLocation			_tprintf(TEXT("%-40s line: %5d\t"), TEXT(__FILE__), __LINE__)
	#define DBG_FAILED			TEXT("%-30s failed\n")
	#define DBG_FAILED_ERR		TEXT("%-30s failed (ec: 0x%08lX)\n")
	#define DbgMsg				DbgLocation, _tprintf

#else /* #ifdef _DEBUG */

	#define DbgLocation			/* empty */
	#define DBG_FAILED			0
	#define DBG_FAILED_ERR		0
	#define DbgMsg				(void)

#endif /* #ifdef _DEBUG */

#endif /* #ifndef __REPORT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacynotificationtest\notif.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   notif.c

Author:

   Lior Shmueli (liors)

Abstract:

    This module tests fax notifications in WINFAX.DLL
    
--*/


#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>
#include <shellapi.h>
#include <wtypes.h>
//#include <lior_platform.h>
 
#define NOTIF_ERROR_DONT_MATCH TEXT("API ERROR: FEI event code does not match WINFAX.H source\n")

// Events Linked list
//typedef struct MyEventRecord 
							//{
							//DWORD EventId;
							//MY_EVENT_RECORD	*Next;
							//} MY_EVENT_RECORD;
   
  

DWORD gErrors=0;


void GiveUsage(
              LPTSTR AppName
              )
{
   _tprintf( TEXT("Usage : %s /d <full path to doc> /n <number>\n --send a fax\n"),AppName);
   _tprintf( TEXT("Usage : %s /? -- this message\n"),AppName);

}




void PrintEventDescription (
						   PFAX_EVENT FaxEvent
						   )
{



_tprintf( TEXT("\tDescription: "));
switch (FaxEvent->EventId) {
	case FEI_DIALING: _tprintf( TEXT("FEI_DIALING 0x00000001\n"));
		
	if (FEI_DIALING != 0x1) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_SENDING: _tprintf( TEXT("FEI_SENDING 0x00000002\n"));
	if (FEI_SENDING != 0x2) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_RECEIVING: _tprintf( TEXT("FEI_RECEIVING 0x00000003\n"));
	if (FEI_RECEIVING != 0x3) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_COMPLETED: _tprintf( TEXT("FEI_COMPLETED 0x00000004\n"));
	if (FEI_COMPLETED != 0x4) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_BUSY: _tprintf( TEXT("FEI_BUSY 0x00000005\n"));
	if (FEI_BUSY != 0x5) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_NO_ANSWER: _tprintf( TEXT("FEI_NO_ANSWER 0x00000006\n"));
	if (FEI_NO_ANSWER != 0x6) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_BAD_ADDRESS: _tprintf( TEXT("FEI_BAD_ADDRESS 0x00000007\n"));
	if (FEI_BAD_ADDRESS != 0x7) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_NO_DIAL_TONE: _tprintf( TEXT("FEI_NO_DIAL_TONE 0x00000008\n"));
	if (FEI_NO_DIAL_TONE != 0x8) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_DISCONNECTED: _tprintf( TEXT("FEI_DISCONNECTED 0x00000009\n"));
	if (FEI_DISCONNECTED != 0x9) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_FATAL_ERROR: _tprintf( TEXT("FEI_FATAL_ERROR 0x0000000a\n"));
	if (FEI_FATAL_ERROR != 0xa) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_NOT_FAX_CALL: _tprintf( TEXT("FEI_NOT_FAX_CALL 0x0000000b\n"));
	if (FEI_NOT_FAX_CALL != 0xb) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_CALL_DELAYED: _tprintf( TEXT("FEI_CALL_DELAYED 0x0000000c\n"));
	if (FEI_CALL_DELAYED != 0xc) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_CALL_BLACKLISTED: _tprintf( TEXT("FEI_BLACKLISTED 0x0000000d\n"));
	if (FEI_CALL_BLACKLISTED != 0xd) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_RINGING: _tprintf( TEXT("FEI_RINGING 0x0000000e\n"));
	if (FEI_RINGING != 0xe) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_ABORTING: _tprintf( TEXT("FEI_ABORTING 0x0000000f\n"));
	if (FEI_ABORTING != 0xf) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_ROUTING: _tprintf( TEXT("FEI_ROUTING 0x00000010\n"));
	if (FEI_ROUTING != 0x10) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;

	case FEI_MODEM_POWERED_ON: _tprintf( TEXT("FEI_MODEM_POWERED_ON 0x00000011\n"));
	if (FEI_MODEM_POWERED_ON != 0x11) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_MODEM_POWERED_OFF: _tprintf( TEXT("FEI_MODEM_POWERED_OFF 0x00000012\n"));
	if (FEI_MODEM_POWERED_OFF != 0x12) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_IDLE: _tprintf( TEXT("FEI_IDLE 0x00000013\n"));
	if (FEI_IDLE != 0x13) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_FAXSVC_ENDED: _tprintf( TEXT("FEI_FAXSVC_ENDED 0x00000014\n"));
	if (FEI_FAXSVC_ENDED != 0x14) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_ANSWERED: _tprintf( TEXT("FEI_ANSWERED 0x00000015\n"));
	if (FEI_ANSWERED != 0x15) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_JOB_QUEUED: _tprintf( TEXT("FEI_JOB_QUEUED 0x00000016\n"));
	if (FEI_JOB_QUEUED != 0x16) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_DELETED: _tprintf( TEXT("FEI_DELETED 0x00000017\n"));
	if (FEI_DELETED != 0x17) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_INITIALIZING: _tprintf( TEXT("FEI_INITIALIZING 0x00000018\n"));
	if (FEI_INITIALIZING != 0x18) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_LINE_UNAVAILABLE: _tprintf( TEXT("FEI_LINE_UNAVAILBLE 0x00000019\n"));
	if (FEI_LINE_UNAVAILABLE != 0x19) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_HANDLED: _tprintf( TEXT("FEI_HANDLED 0x0000001a\n"));
	if (FEI_HANDLED != 0x1a) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	
	case FEI_FAXSVC_STARTED: _tprintf( TEXT("FEI_FAXSVC_STARTED 0x0000001b\n"));
	if (FEI_FAXSVC_STARTED != 0x1b) {
								gErrors++;
								_tprintf( NOTIF_ERROR_DONT_MATCH);
								}
	break;
	}
}



void PrintDeviceStatus(
                      PFAX_DEVICE_STATUS fds
                      )
{
   TCHAR SubmitBuffer[100];
   TCHAR StartBuffer[100];
   SYSTEMTIME SystemTime;

   if (!fds) {
      return;
   }

   _tprintf(TEXT("Device Id:\t\t%d\n"),fds->DeviceId );
   _tprintf(TEXT("Device Name:\t\t%s\n"),fds->DeviceName );
   _tprintf(TEXT("CallerId:\t\t%s\n"),fds->CallerId );
   _tprintf(TEXT("CSID:\t\t\t%s\n"),fds->Csid );
   _tprintf(TEXT("TSID:\t\t\t%s\n"),fds->Tsid );
   _tprintf(TEXT("Page:\t\t\t%d of %d\n"),fds->CurrentPage,fds->TotalPages );
   _tprintf(TEXT("DocumentName:\t\t%s\n"),fds->DocumentName);
   _tprintf(TEXT("JobType:\t\t%d\n"),fds->JobType);
   _tprintf(TEXT("PhoneNumber:\t\t%s\n"),fds->PhoneNumber);
   _tprintf(TEXT("SenderName:\t\t%s\n"),fds->SenderName);
   _tprintf(TEXT("RecipientName:\t\t%s\n"),fds->RecipientName);
   _tprintf(TEXT("Size (in bytes):\t%d\n"),fds->Size);
   _tprintf(TEXT("Status (see FPS flags):\t%x\n"),fds->Status);

   FileTimeToSystemTime(&fds->StartTime,&SystemTime);

   GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &SystemTime,
                 NULL,
                 StartBuffer,
                 sizeof(StartBuffer)
                );

   FileTimeToSystemTime(&fds->SubmittedTime,&SystemTime);
   SystemTimeToTzSpecificLocalTime(NULL,&SystemTime,&SystemTime);

   GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &SystemTime,
                 NULL,
                 SubmitBuffer,
                 sizeof(SubmitBuffer)
                );

   _tprintf(TEXT("Job Submited at %s\n"),SubmitBuffer);
   _tprintf(TEXT("Job transmission started at %s\n\n"),StartBuffer);

}

int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
/*++

Routine Description:

    Entry point to the setup program

Arguments:

    argc - Number of args.
    argvA - the commandline arguments.


Return Value:


--*/
{

   // Events Linked list
   
   LPTSTR *argv;
   int argcount = 0;
   TCHAR Document[MAX_PATH] = {0};
   TCHAR Number[64] = {0};
   HANDLE hFax;
   HANDLE hCompletionPort = INVALID_HANDLE_VALUE;
   DWORD dwBytes, CompletionKey;
   PFAX_EVENT FaxEvent;
   BOOL bTerminate = FALSE;
   HANDLE hPort;
   PFAX_DEVICE_STATUS DeviceStatus;
   SYSTEMTIME EventSystemTime;
   CONST FILETIME *EventFileTime=NULL;
   FILE *fp;

//   EVENT_RECORD *Top,*CurEvent,*PrevEvent;

   


   //
   // do commandline stuff
   //
#ifdef UNICODE
   argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
   argv = argvA;
#endif

   
   // check for commandline switches
   for (argcount=0; argcount<argc; argcount++) {
      if ((argv[argcount][0] == L'/') || (argv[argcount][0] == L'-')) {
         switch (towlower(argv[argcount][1])) {
            case 'n':
               lstrcpy(Number, argv[argcount+1]);
               break;
            case 'd':
               lstrcpy(Document, argv[argcount+1]);
               break;
            case '?':
               GiveUsage(argv[0]);
               return 0;
            default:
               break;
         }
      }
   }

   if (!Number[0] || !Document[0]) {

	 
      _tprintf( TEXT("Missing args.\n") );
      GiveUsage(argv[0]);
      return -1;
   }

   //
   // connect to fax service
   //
   if (!FaxConnectFaxServer(NULL,&hFax)) {
      _tprintf( TEXT("FaxConnectFaxServer failed, ec = %d\n"),GetLastError() );
      return -1;
   }

   assert (hFax != NULL);

   hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);

   if (!hCompletionPort) {
      _tprintf( TEXT("CreateIoCompletionPort failed, ec = %d\n"), GetLastError() );
      FaxClose( hFax );
      return -1;
   }

   if (!FaxInitializeEventQueue(hFax,
                                hCompletionPort,
                                0,
                                NULL, 
                                0 ) ) {
      _tprintf( TEXT("FaxInitializeEventQueue failed, ec = %d\n"), GetLastError() );
      FaxClose( hFax );
      return -1;
   }

   //FaxCompleteJobParams(&JobParam,&CoverpageInfo);

   //JobParam->RecipientNumber = Number;

   //if (!FaxSendDocument( hFax, Document, JobParam, NULL , &JobId) ) {
   //   _tprintf( TEXT("FaxSendDocument failed, ec = %d \n"), GetLastError() );
   //   FaxClose( hFax );
   //   CloseHandle( hCompletionPort );
   //   FaxFreeBuffer(JobParam);
   //   FaxFreeBuffer(CoverpageInfo);
   //   return -1;
   //}

   //_tprintf( TEXT("Queued document %s for transmition to %s, JobID = %d\n"),
   //         Document,
   //          Number,
   //          JobId );

   //FaxFreeBuffer( JobParam );
   //FaxFreeBuffer( CoverpageInfo );


//	CurEvent=malloc(sizeof(EVENT_RECORD));
//	CurEvent->EventId=0;
//	CurEvent->Next=NULL;
//	Top=CurEvent;
   fp=fopen("notif_events","w");
   fclose(fp);

   while (!bTerminate && GetQueuedCompletionStatus(hCompletionPort,
                                    &dwBytes,
                                    &CompletionKey,
                                    (LPOVERLAPPED *)&FaxEvent,
                                    INFINITE) ) {

	
	  
		EventFileTime=&FaxEvent->TimeStamp;	   
		FileTimeToSystemTime(EventFileTime,&EventSystemTime);
		_tprintf( TEXT("\n>>> EVENT\n"));
		_tprintf( TEXT("\tTimeStamp: %d-%d-%d (%d) %d:%d:%d:%d\n"),EventSystemTime.wYear,EventSystemTime.wMonth,EventSystemTime.wDay,EventSystemTime.wDayOfWeek,EventSystemTime.wHour,EventSystemTime.wMinute,EventSystemTime.wSecond,EventSystemTime.wMilliseconds);
		_tprintf( TEXT("\tEventId: %x\n\tJobId: %d\n\tDeviceId: %d\n"),FaxEvent->EventId,FaxEvent->JobId,FaxEvent->DeviceId);
		PrintEventDescription(FaxEvent);

	

//      CurEvent->EventId=FaxEvent->EventId;
//      PrevEvent=CurEvent;
//		CurEvent=malloc(sizeof(EVENT_RECORD));
//      PrevEvent->Next=CurEvent;

		fp=fopen("notif_events","a");
		fprintf(fp,"%d\n",FaxEvent->EventId);
		fprintf(fp,"%d\n",FaxEvent->JobId);
		fclose(fp);

		switch (FaxEvent->EventId) {		    	
	
			case FEI_FAXSVC_ENDED:     
				bTerminate = TRUE;
	        break;

			case FEI_FATAL_ERROR:      
				if (FaxOpenPort( hFax, FaxEvent->DeviceId,PORT_OPEN_QUERY, &hPort) ) {
					if (FaxGetDeviceStatus(hPort,&DeviceStatus) ) {
						PrintDeviceStatus(DeviceStatus);
						FaxFreeBuffer( DeviceStatus );
					}
				FaxClose( hPort );
				}
		}
	}
	FaxClose( hFax );
	CloseHandle( hCompletionPort );

	//CurEvent->Next=NULL;

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\dllapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  dllapi.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#ifndef _DLLAPI_H
#define _DLLAPI_H

#include <winfax.h>

typedef struct _API_INTERFACE {
    HINSTANCE                      hInstance;
    PFAXABORT                      FaxAbort;
    PFAXACCESSCHECK                FaxAccessCheck;
    PFAXCLOSE                      FaxClose;
    PFAXCOMPLETEJOBPARAMSW         FaxCompleteJobParamsW;
    PFAXCOMPLETEJOBPARAMSA         FaxCompleteJobParamsA;
    PFAXCONNECTFAXSERVERW          FaxConnectFaxServerW;
    PFAXCONNECTFAXSERVERA          FaxConnectFaxServerA;
    PFAXENABLEROUTINGMETHODW       FaxEnableRoutingMethodW;
    PFAXENABLEROUTINGMETHODA       FaxEnableRoutingMethodA;
    PFAXENUMGLOBALROUTINGINFOW     FaxEnumGlobalRoutingInfoW;
    PFAXENUMGLOBALROUTINGINFOA     FaxEnumGlobalRoutingInfoA;
    PFAXENUMJOBSW                  FaxEnumJobsW;
    PFAXENUMJOBSA                  FaxEnumJobsA;
    PFAXENUMPORTSW                 FaxEnumPortsW;
    PFAXENUMPORTSA                 FaxEnumPortsA;
    PFAXENUMROUTINGMETHODSW        FaxEnumRoutingMethodsW;
    PFAXENUMROUTINGMETHODSA        FaxEnumRoutingMethodsA;
    PFAXFREEBUFFER                 FaxFreeBuffer;
    PFAXGETCONFIGURATIONW          FaxGetConfigurationW;
    PFAXGETCONFIGURATIONA          FaxGetConfigurationA;
    PFAXGETDEVICESTATUSW           FaxGetDeviceStatusW;
    PFAXGETDEVICESTATUSA           FaxGetDeviceStatusA;
    PFAXGETJOBW                    FaxGetJobW;
    PFAXGETJOBA                    FaxGetJobA;
    PFAXGETLOGGINGCATEGORIESW      FaxGetLoggingCategoriesW;
    PFAXGETLOGGINGCATEGORIESA      FaxGetLoggingCategoriesA;
    PFAXGETPAGEDATA                FaxGetPageData;
    PFAXGETPORTW                   FaxGetPortW;
    PFAXGETPORTA                   FaxGetPortA;
    PFAXGETROUTINGINFOW            FaxGetRoutingInfoW;
    PFAXGETROUTINGINFOA            FaxGetRoutingInfoA;
    PFAXINITIALIZEEVENTQUEUE       FaxInitializeEventQueue;
    PFAXOPENPORT                   FaxOpenPort;
    PFAXPRINTCOVERPAGEW            FaxPrintCoverPageW;
    PFAXPRINTCOVERPAGEA            FaxPrintCoverPageA;
    PFAXREGISTERROUTINGEXTENSIONW  FaxRegisterRoutingExtensionW;
    PFAXREGISTERSERVICEPROVIDERW   FaxRegisterServiceProviderW;
    PFAXSENDDOCUMENTW              FaxSendDocumentW;
    PFAXSENDDOCUMENTA              FaxSendDocumentA;
    PFAXSENDDOCUMENTFORBROADCASTW  FaxSendDocumentForBroadcastW;
    PFAXSENDDOCUMENTFORBROADCASTA  FaxSendDocumentForBroadcastA;
    PFAXSETCONFIGURATIONW          FaxSetConfigurationW;
    PFAXSETCONFIGURATIONA          FaxSetConfigurationA;
    PFAXSETGLOBALROUTINGINFOW      FaxSetGlobalRoutingInfoW;
    PFAXSETGLOBALROUTINGINFOA      FaxSetGlobalRoutingInfoA;
    PFAXSETJOBW                    FaxSetJobW;
    PFAXSETJOBA                    FaxSetJobA;
    PFAXSETLOGGINGCATEGORIESW      FaxSetLoggingCategoriesW;
    PFAXSETLOGGINGCATEGORIESA      FaxSetLoggingCategoriesA;
    PFAXSETPORTW                   FaxSetPortW;
    PFAXSETPORTA                   FaxSetPortA;
    PFAXSETROUTINGINFOW            FaxSetRoutingInfoW;
    PFAXSETROUTINGINFOA            FaxSetRoutingInfoA;
    PFAXSTARTPRINTJOBW             FaxStartPrintJobW;
    PFAXSTARTPRINTJOBA             FaxStartPrintJobA;
} API_INTERFACE, *PAPI_INTERFACE;

#define DLL_PATH          L"Dll_Path"
#define DLL_DESCRIPTION   L"Dll_Description"
#define DLL_LOCAL_CASES   L"Dll_Local_Cases"
#define DLL_SERVER_CASES  L"Dll_Server_Cases"

#define MAX_DWORD 4294967295
#define MAX_WORD 65535
#define MAX_INT 32767
#define MIN_INT -32768
#define LONG_STRING "alkjhfdskjhfdkjsahakldfshlkfdashlkfadjhalkfdshklfdshlkfdshlkjfd"


//define test mode
#define WHIS_TEST_MODE_SKIP 0
#define WHIS_TEST_MODE_DO 1
#define WHIS_TEST_MODE_LIMITS 2
#define WHIS_TEST_MODE_DO_W2K_FAILS 3
#define WHIS_TEST_MODE_REAL_SEND 4
#define WHIS_TEST_MODE_DONT_CATCH_EXCEPTIONS 5




// whistler further INI settings
#define DLL_WHIS_TEST_MODE L"Whis_Test_Mode"
#define GLOBAL_WHIS_PHONE_NUM_1 L"Whis_phone_num_1"
#define GLOBAL_WHIS_PHONE_NUM_2 L"Whis_phone_num_2"
#define GLOBAL_WHIS_REMOTE_SERVER_NAME L"Whis_remote_server_name"


		
// Whistler further definitons

#define WHIS_DEFAULT_PHONE_NUMBER  "2222"
#define WHIS_DEFAULT_SERVER_NAME  NULL
#define WHIS_FAX_PRINTER_NAME "Fax"

typedef VOID
(WINAPI *PFNWRITELOGFILEW)(
    LPWSTR  szFormatString,
    ...
);

typedef VOID
(WINAPI *PFNWRITELOGFILEA)(
    LPSTR  szFormatString,
    ...
);

#ifdef UNICODE

#define PFNWRITELOGFILE  PFNWRITELOGFILEW

#else

#define PFNWRITELOGFILE  PFNWRITELOGFILEA

#endif

typedef VOID
(WINAPI *PFAXAPIDLLINIT)(
    HANDLE            hHeap,
    API_INTERFACE     ApiInterface,
    PFNWRITELOGFILEW  pfnWriteLogFileW,
    PFNWRITELOGFILEA  pfnWriteLogFileA
);

typedef BOOL
(WINAPI *PFAXAPIDLLTEST)(
	LPCWSTR  szWhisPhoneNumberW,
    LPCSTR   szWhisPhoneNumberA,
    LPCWSTR  szServerNameW,
    LPCSTR   szServerNameA,
    UINT     nNumCasesLocal,
    UINT     nNumCasesServer,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	DWORD	 dwTestMode
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\confgapi\confgapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  confgapi.c

Abstract:

  ConfgApi: Fax API Test Dll: Client Configuration APIs
    1) FaxGetConfiguration()
    2) FaxSetConfiguration()
    3) FaxGetLoggingCategories()
    4) FaxSetLoggingCategories()

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/


#include <wtypes.h>

#include "dllapi.h"

// g_hHeap is the handle to the heap
HANDLE           g_hHeap = NULL;
// g_ApiInterface is the API_INTERFACE structure
API_INTERFACE    g_ApiInterface;
// fnWriteLogFile is the pointer to the function to write a string to the log file
PFNWRITELOGFILE  fnWriteLogFile = NULL;

#define FAX_REGKEY                     TEXT("Software\\Microsoft\\Fax")
#define RETRIES_REGVALUE               TEXT("Retries")
#define RETRYDELAY_REGVALUE            TEXT("Retry Delay")
#define DIRTYDAYS_REGVALUE             TEXT("Dirty Days")
#define BRANDING_REGVALUE              TEXT("Branding")
#define USEDEVICETSID_REGVALUE         TEXT("UseDeviceTsid")
#define SERVERCP_REGVALUE              TEXT("ServerCoverPageOnly")
#define PAUSESERVERQUEUE_REGVALUE      TEXT("QueuePaused")
#define STARTCHEAPTIME_REGVALUE        TEXT("StartCheapTime")
#define STOPCHEAPTIME_REGVALUE         TEXT("StopCheapTime")
#define ARCHIVEOUTGOINGFAXES_REGVALUE  TEXT("ArchiveOutgoingFax")
#define ARCHIVEDIRECTORY_REGVALUE      TEXT("ArchiveDirectory")
#define INBOUNDPROFILE_REGVALUE        TEXT("Inbound Profile")

#define FAX_LOGGING_REGKEY             TEXT("Software\\Microsoft\\Fax\\Logging")
#define NAME_REGVALUE                  TEXT("Name")
#define CATEGORY_REGVALUE              TEXT("Number")
#define LEVEL_REGVALUE                 TEXT("Level")

DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

VOID WINAPI
FaxAPIDllInit(
    HANDLE            hHeap,
    API_INTERFACE     ApiInterface,
    PFNWRITELOGFILEW  pfnWriteLogFileW,
    PFNWRITELOGFILEA  pfnWriteLogFileA
)
{
    // Set g_hHeap
    g_hHeap = hHeap;
    // Set g_ApiInterface
    g_ApiInterface = ApiInterface;
#ifdef UNICODE
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileW;
#else
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileA;
#endif

    return;
}

BOOL
fnRegQueryDword(
    HKEY     hKey,
    LPTSTR   szValue,
    LPDWORD  pdwData
)
/*++

Routine Description:

  Queries a Registry data as a REG_DWORD

Arguments:

  hKey - handle to the Registry key
  szValue - value to be queried
  pdwData - pointer to the data to be queried

Return Value:

  TRUE on success

--*/
{
    DWORD  cb;

    cb = sizeof(DWORD);
    if (RegQueryValueEx(hKey, szValue, NULL, NULL, (PBYTE) pdwData, &cb)) {
        *pdwData = 0;
        return FALSE;
    }

    return TRUE;
}

BOOL
fnRegQuerySz(
    HKEY    hKey,
    LPTSTR  szValue,
    LPTSTR  *pszData
)
/*++

Routine Description:

  Queries a Registry data as a REG_SZ

Arguments:

  hKey - handle to the Registry key
  szValue - value to be queried
  pszData - pointer to the data to be queried

Return Value:

  TRUE on success

--*/
{
    DWORD  cb;

    cb = 0;
    // Determine the memory required by pszData
    if (RegQueryValueEx(hKey, szValue, NULL, NULL, NULL, &cb)) {
        return FALSE;
    }

    if (!cb) {
        *pszData = NULL;
        return TRUE;
    }

    // Allocate the memory for pszData
    *pszData = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb);

    if (RegQueryValueEx(hKey, szValue, NULL, NULL, (PBYTE) *pszData, &cb)) {
        HeapFree(g_hHeap, 0, *pszData);
        *pszData = NULL;
        return FALSE;
    }

    return TRUE;
}

BOOL
fnVerifyConfiguration(
    PFAX_CONFIGURATION  pFaxConfig
)
/*++

Routine Description:

  Verifies the fax configuration vs. the registry

Arguments:

  pFaxConfig - pointer to the fax configuration

Return Value:

  None

--*/
{
    // hFaxKey is the handle to the fax registry key
    HKEY    hFaxKey;
    // szValue is the registry value (REG_SZ)
    LPTSTR  szValue;
    // dwValue is the registry value (REG_DWORD)
    DWORD   dwValue;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_REGKEY, 0, KEY_ALL_ACCESS, &hFaxKey)) {
        fnWriteLogFile(TEXT("Could not open the Registry Key %s, ec = 0x%08x.\r\n"), FAX_REGKEY, GetLastError());
        goto RegFailed0;
    }

    if (pFaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATION)) {
        fnWriteLogFile(TEXT("SizeOfStruct: Received: %d, Expected: %d.\r\n"), pFaxConfig->SizeOfStruct, sizeof(FAX_CONFIGURATION));
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, RETRIES_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), RETRIES_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->Retries != dwValue) {
        fnWriteLogFile(TEXT("Retries: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->Retries);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, RETRYDELAY_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), RETRYDELAY_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->RetryDelay != dwValue) {
        fnWriteLogFile(TEXT("RetryDelay: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->RetryDelay);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, DIRTYDAYS_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), DIRTYDAYS_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->DirtyDays != dwValue) {
        fnWriteLogFile(TEXT("DirtyDays: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->DirtyDays);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, BRANDING_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), BRANDING_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->Branding != (BOOL) dwValue) {
        fnWriteLogFile(TEXT("Branding: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->Branding);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, USEDEVICETSID_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), USEDEVICETSID_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->UseDeviceTsid != (BOOL) dwValue) {
        fnWriteLogFile(TEXT("UseDeviceTsid: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->UseDeviceTsid);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, SERVERCP_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), SERVERCP_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->ServerCp != (BOOL) dwValue) {
        fnWriteLogFile(TEXT("ServerCp: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->ServerCp);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, PAUSESERVERQUEUE_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), PAUSESERVERQUEUE_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->PauseServerQueue != (BOOL) dwValue) {
        fnWriteLogFile(TEXT("PauseServerQueue: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->PauseServerQueue);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, STARTCHEAPTIME_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), STARTCHEAPTIME_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->StartCheapTime.Hour != LOWORD(dwValue)) {
        fnWriteLogFile(TEXT("StartCheapTime.Hour: Received: %d, Expected: %d.\r\n"), LOWORD(dwValue), pFaxConfig->StartCheapTime.Hour);
        goto RegFailed1;
    }
    if (pFaxConfig->StartCheapTime.Minute != HIWORD(dwValue)) {
        fnWriteLogFile(TEXT("StartCheapTime.Minute: Received: %d, Expected: %d.\r\n"), HIWORD(dwValue), pFaxConfig->StartCheapTime.Minute);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, STOPCHEAPTIME_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), STOPCHEAPTIME_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->StopCheapTime.Hour != LOWORD(dwValue)) {
        fnWriteLogFile(TEXT("StopCheapTime.Hour: Received: %d, Expected: %d.\r\n"), LOWORD(dwValue), pFaxConfig->StopCheapTime.Hour);
        goto RegFailed1;
    }
    if (pFaxConfig->StopCheapTime.Minute != HIWORD(dwValue)) {
        fnWriteLogFile(TEXT("StopCheapTime.Minute: Received: %d, Expected: %d.\r\n"), HIWORD(dwValue), pFaxConfig->StopCheapTime.Minute);
        goto RegFailed1;
    }

    if (!fnRegQueryDword(hFaxKey, ARCHIVEOUTGOINGFAXES_REGVALUE, &dwValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), ARCHIVEOUTGOINGFAXES_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (pFaxConfig->ArchiveOutgoingFaxes != (BOOL) dwValue) {
        fnWriteLogFile(TEXT("ArchiveOutgoingFaxes: Received: %d, Expected: %d.\r\n"), dwValue, pFaxConfig->ArchiveOutgoingFaxes);
        goto RegFailed1;
    }

    if (!fnRegQuerySz(hFaxKey, ARCHIVEDIRECTORY_REGVALUE, &szValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), ARCHIVEDIRECTORY_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    if (lstrcmp(pFaxConfig->ArchiveDirectory, szValue)) {
        fnWriteLogFile(TEXT("ArchiveDirectory: Received: %s, Expected: %s.\r\n"), szValue, pFaxConfig->ArchiveDirectory);
        if (szValue) {
            HeapFree(g_hHeap, 0, szValue);
        }
        goto RegFailed1;
    }
    if (szValue) {
        HeapFree(g_hHeap, 0, szValue);
    }

    if (!fnRegQuerySz(hFaxKey, INBOUNDPROFILE_REGVALUE, &szValue)) {
        fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), INBOUNDPROFILE_REGVALUE, GetLastError());
        goto RegFailed1;
    }
    
	
	#ifdef FAXAPI_W2K
		if (lstrcmp(pFaxConfig->InboundProfile, szValue)) {
        fnWriteLogFile(TEXT("InboundProfile: Received: %s, Expected: %s.\r\n"), szValue, pFaxConfig->InboundProfile);
        if (szValue) {
            HeapFree(g_hHeap, 0, szValue);
			}
        goto RegFailed1;
		}	
	#endif

    if (szValue) {
        HeapFree(g_hHeap, 0, szValue);
    }

    RegCloseKey(hFaxKey);

    return TRUE;

RegFailed1:
    RegCloseKey(hFaxKey);

RegFailed0:
    return FALSE;
}

VOID
fnFaxGetConfiguration(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxGetConfiguration()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;

    DWORD               dwIndex;

    // internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxGetConfiguration().\r\n"));

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        return;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s.\r\n"),szServerName);
	}


    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        
		// Get the configuration
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case (will do twice).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            fnWriteLogFile(TEXT("FaxGetConfiguration() failed.  The error code is 0x%08x.  This is an error.  FaxGetConfiguration() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxConfig == NULL) {
                fnWriteLogFile(TEXT("pFaxConfig is NULL.  This is an error.  pFaxConfig should not be NULL.\r\n"));
            }
            else {
                if (fnVerifyConfiguration(pFaxConfig)) {
                    (*pnNumCasesPassed)++;
					dwFuncCasesPass++;
                }
            }

            g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetConfiguration(NULL, &pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxGetConfiguration() returned TRUE.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxConfig = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, NULL)) {
        fnWriteLogFile(TEXT("FaxGetConfiguration() returned TRUE.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle (connection to fax was closed...) .  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxGetConfiguration() returned TRUE.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
      //  if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
        //    return;
        //}

        //(*pnNumCasesAttempted)++;
        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
          //  fnWriteLogFile(TEXT("FaxGetConfiguration() failed.  The error code is 0x%08x.  This is an error.  FaxGetConfiguration() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            //(*pnNumCasesPassed)++;
        //}

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxGetConfiguration, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxSetConfiguration(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits
)
/*++

Routine Description:

  FaxSetConfiguration()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // pCopyFaxConfig is the pointer to the copy of the fax configuration
    PFAX_CONFIGURATION  pCopyFaxConfig;

    DWORD               cb;
    DWORD               dwOffset;
	DWORD				dwTempValue;
	int					iTempValue;
	WORD				wTempValue;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


    fnWriteLogFile(TEXT(  "\n--------------------------"));
	fnWriteLogFile(TEXT("### FaxSetConfiguration().\r\n"));

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        return;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s.\r\n"),szServerName);
	}

    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not GET configuration from fax server %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    cb = sizeof(FAX_CONFIGURATION);

	#ifdef FAXAPI_W2K
		{
		if (pFaxConfig->InboundProfile) {
        cb += (lstrlen(pFaxConfig->InboundProfile) + 1) * sizeof(TCHAR);
		}
	#endif

    if (pFaxConfig->ArchiveDirectory) {
        cb += (lstrlen(pFaxConfig->ArchiveDirectory) + 1) * sizeof(TCHAR);
    }

    pCopyFaxConfig = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb);
    dwOffset = sizeof(FAX_CONFIGURATION);

	
			
	pCopyFaxConfig->SizeOfStruct = pFaxConfig->SizeOfStruct;
	pCopyFaxConfig->Retries = pFaxConfig->Retries + 1;
	pCopyFaxConfig->RetryDelay = pFaxConfig->RetryDelay + 1;
	pCopyFaxConfig->DirtyDays = pFaxConfig->DirtyDays + 1;
	pCopyFaxConfig->Branding = !pFaxConfig->Branding;
	pCopyFaxConfig->UseDeviceTsid = !pFaxConfig->UseDeviceTsid;
	pCopyFaxConfig->ServerCp = !pFaxConfig->ServerCp;
	pCopyFaxConfig->PauseServerQueue = !pFaxConfig->PauseServerQueue;
	pCopyFaxConfig->StartCheapTime.Hour = pFaxConfig->StopCheapTime.Hour;
	pCopyFaxConfig->StartCheapTime.Minute = pFaxConfig->StopCheapTime.Minute;
	pCopyFaxConfig->StopCheapTime.Hour = pFaxConfig->StartCheapTime.Hour;
	pCopyFaxConfig->StopCheapTime.Minute = pFaxConfig->StartCheapTime.Minute;
	pCopyFaxConfig->ArchiveOutgoingFaxes = pCopyFaxConfig->ArchiveOutgoingFaxes;

	
	#ifdef FAXAPI_W2K
		if (pFaxConfig->InboundProfile) {
			pCopyFaxConfig->InboundProfile = (LPTSTR) ((DWORD) pCopyFaxConfig + dwOffset);
			lstrcpy((LPTSTR) pCopyFaxConfig->InboundProfile, pFaxConfig->InboundProfile);
			dwOffset += (lstrlen(pCopyFaxConfig->InboundProfile) + 1) * sizeof(TCHAR);
		}
	#endif


	if (pFaxConfig->ArchiveDirectory) {
        pCopyFaxConfig->ArchiveDirectory = (LPTSTR) ((DWORD) pCopyFaxConfig + dwOffset);
        lstrcpy((LPTSTR) pCopyFaxConfig->ArchiveDirectory, pFaxConfig->ArchiveDirectory);
        dwOffset += (lstrlen(pCopyFaxConfig->ArchiveDirectory) + 1) * sizeof(TCHAR);
		}
	
  

    // Set the configuration
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	
    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pCopyFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() failed.  The error code is 0x%08x.  This is an error.  FaxSetConfiguration() should succeed.\r\n"), GetLastError());
    }
    else {
        if (fnVerifyConfiguration(pCopyFaxConfig)) {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    HeapFree(g_hHeap, 0, pCopyFaxConfig);

    // Set the configuration
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() failed.  The error code is 0x%08x.  This is an error.  FaxSetConfiguration() should succeed.\r\n"), GetLastError());
    }
    else {
        if (fnVerifyConfiguration(pFaxConfig)) {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    pFaxConfig->SizeOfStruct = 0;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxConfig->SizeOfStruct = 0.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }
    pFaxConfig->SizeOfStruct = sizeof(FAX_CONFIGURATION);


	// add limit values cases
	if (bTestLimits)	{

		pFaxConfig->SizeOfStruct = MAX_DWORD;
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;
		fnWriteLogFile(TEXT("pFaxConfig->SizeOfStruct = MAX_DWORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
	        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
	    }
	    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
			fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	    }
	    pFaxConfig->SizeOfStruct = sizeof(FAX_CONFIGURATION);

	
		dwTempValue=pFaxConfig->Retries;
		pFaxConfig->Retries = MAX_DWORD;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->Retries = MAX_DWORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	    }
	    else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->Retries=dwTempValue;
	
		dwTempValue=pFaxConfig->RetryDelay;
		pFaxConfig->RetryDelay = MAX_DWORD;
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->RetryDelay = MAX_DWORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	    }
	    else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->RetryDelay=dwTempValue;
	
		dwTempValue=pFaxConfig->DirtyDays;
		pFaxConfig->DirtyDays = MAX_DWORD;
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->DirtyDays = MAX_DWORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
	        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
	    }
	    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
			fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	    }
	    pFaxConfig->DirtyDays=dwTempValue;
	
	
		iTempValue=pFaxConfig->Branding;
		pFaxConfig->Branding = MIN_INT;
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->Branding = MIN_INT.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	    }
	    else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->Branding=dwTempValue;
	
		iTempValue=pFaxConfig->UseDeviceTsid;
		pFaxConfig->UseDeviceTsid = MIN_INT;
		
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->UseDeviceTsid = MIN_INT.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	    }
	    else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->UseDeviceTsid=dwTempValue;
	
		iTempValue=pFaxConfig->ServerCp;
		pFaxConfig->ServerCp = MIN_INT;
		
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->ServerCp = MIN_INT.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	    }
	    else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->ServerCp=dwTempValue;
	
		iTempValue=pFaxConfig->PauseServerQueue;
		pFaxConfig->PauseServerQueue = MIN_INT;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->PauseServerQueue = MIN_INT.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	    }
	    pFaxConfig->PauseServerQueue=dwTempValue;
	
		iTempValue=pFaxConfig->ArchiveOutgoingFaxes;
		pFaxConfig->ArchiveOutgoingFaxes = MIN_INT;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->ArchiveOutgoingFaxes = MIN_INT.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
			fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->ArchiveOutgoingFaxes=dwTempValue;

	
		
		wTempValue=pFaxConfig->StartCheapTime.Hour;
		pFaxConfig->StartCheapTime.Hour = MAX_WORD;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->StartCheapTime.Hour = MAX_WORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
			fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->StartCheapTime.Hour=wTempValue;

		
		
		
		
		wTempValue=pFaxConfig->StartCheapTime.Minute;
		pFaxConfig->StartCheapTime.Minute = MAX_WORD;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->StartCheapTime.Minute = MAX_WORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
			fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
	    else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
		pFaxConfig->StartCheapTime.Minute=wTempValue;

		
	
		wTempValue=pFaxConfig->StopCheapTime.Hour;
		pFaxConfig->StopCheapTime.Hour = MAX_WORD;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->StopCheapTime.Hour = MAX_WORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
	        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			}
		pFaxConfig->StopCheapTime.Hour=wTempValue;

		
		
		wTempValue=pFaxConfig->StopCheapTime.Minute;
		pFaxConfig->StopCheapTime.Minute = MAX_WORD;

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("pFaxConfig->StopCheapTime.Minute = MAX_WORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
	        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
		}
		else if (GetLastError() != ERROR_INVALID_PARAMETER) {
			fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
		}
	    pFaxConfig->StopCheapTime.Minute=wTempValue;


	
	}


    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetConfiguration(NULL, pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxConfig = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, NULL)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
        fnWriteLogFile(TEXT("FaxSetConfiguration() returned TRUE.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetConfiguration() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

  //  if (szServerName) {
        // Connect to the fax server
    //    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
      //      return;
       // }

        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
       // }

        //(*pnNumCasesAttempted)++;
        //if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
          //  fnWriteLogFile(TEXT("FaxSetConfiguration() failed.  The error code is 0x%08x.  This is an error.  FaxSetConfiguration() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  (*pnNumCasesPassed)++;

        //}

        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxSetConfiguration, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}


BOOL
fnVerifyCategories(
    PFAX_LOG_CATEGORY  pFaxCategories,
    DWORD              dwNumMethods
)
/*++

Routine Description:

  Verifies the fax logging categories vs. the registry

Arguments:

  pFaxCategories - pointer to the fax logging categories
  dwNumMethods - number of fax logging categories

Return Value:

  None

--*/
{
    // hFaxLoggingKey is the handle to the fax logging registry key
    HKEY    hFaxLoggingKey;
    // szKeyName is the name of a logging registry subkey
    TCHAR   szKeyName[3];
    // hFaxCategoryKey is the handle to the category registry key
    HKEY    hFaxCategoryKey;
    // szValue is the registry value (REG_SZ)
    LPTSTR  szValue;
    // dwValue is the registry value (REG_DWORD)
    DWORD   dwValue;

    DWORD   dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_LOGGING_REGKEY, 0, KEY_ALL_ACCESS, &hFaxLoggingKey)) {
        fnWriteLogFile(TEXT("Could not open the Registry Key %s, ec = 0x%08x.\r\n"), FAX_LOGGING_REGKEY, GetLastError());
        goto RegFailed0;
    }

    for (dwIndex = 0; dwIndex < dwNumMethods; dwIndex++) {
        wsprintf(szKeyName, TEXT("%d"), pFaxCategories[dwIndex].Category);

        if (RegOpenKeyEx(hFaxLoggingKey, szKeyName, 0, KEY_ALL_ACCESS, &hFaxCategoryKey)) {
            fnWriteLogFile(TEXT("Could not open the Registry Key %s, ec = 0x%08x.\r\n"), szKeyName, GetLastError());
            goto RegFailed1;
        }

        if (!fnRegQuerySz(hFaxCategoryKey, NAME_REGVALUE, &szValue)) {
            fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), NAME_REGVALUE, GetLastError());
            goto RegFailed2;
        }
        if (lstrcmp(pFaxCategories[dwIndex].Name, szValue)) {
            fnWriteLogFile(TEXT("Name: Received: %s, Expected: %s.\r\n"), szValue, pFaxCategories[dwIndex].Name);
            if (szValue) {
                HeapFree(g_hHeap, 0, szValue);
            }
            goto RegFailed2;
        }
        if (szValue) {
            HeapFree(g_hHeap, 0, szValue);
        }

        if (!fnRegQueryDword(hFaxCategoryKey, CATEGORY_REGVALUE, &dwValue)) {
            fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), CATEGORY_REGVALUE, GetLastError());
            goto RegFailed2;
        }
        if (pFaxCategories[dwIndex].Category != dwValue) {
            fnWriteLogFile(TEXT("Category: Received: %d, Expected: %d.\r\n"), dwValue, pFaxCategories[dwIndex].Category);
            goto RegFailed2;
        }

        if (!fnRegQueryDword(hFaxCategoryKey, LEVEL_REGVALUE, &dwValue)) {
            fnWriteLogFile(TEXT("Could not query the Registry Value %s, ec = 0x%08x.\r\n"), LEVEL_REGVALUE, GetLastError());
            goto RegFailed2;
        }
        if (pFaxCategories[dwIndex].Level != dwValue) {
            fnWriteLogFile(TEXT("Level: Received: %d, Expected: %d.\r\n"), dwValue, pFaxCategories[dwIndex].Level);
            goto RegFailed2;
        }

        RegCloseKey(hFaxCategoryKey);
    }

    RegCloseKey(hFaxLoggingKey);

    return TRUE;

RegFailed2:
    RegCloseKey(hFaxCategoryKey);

RegFailed1:
    RegCloseKey(hFaxLoggingKey);

RegFailed0:
    return FALSE;
}

VOID
fnFaxGetLoggingCategories(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxGetLoggingCategories()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE             hFaxSvcHandle;
    // pFaxCategories is the pointer to the fax logging categories
    PFAX_LOG_CATEGORY  pFaxCategories;
    // dwNumCategories is the number of fax logging categories
    DWORD              dwNumCategories;

    DWORD              dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;
	
	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxGetLoggingCategories().\r\n"));

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        return;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s.\r\n"),szServerName);
	}


    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Get the logging categories
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        if (!g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, &dwNumCategories)) {
            fnWriteLogFile(TEXT("FaxGetLoggingCategories() failed.  The error code is 0x%08x.  This is an error.  FaxGetLoggingCategories() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxCategories == NULL) {
                fnWriteLogFile(TEXT("pFaxCategories is NULL.  This is an error.  pFaxCategories should not be NULL.\r\n"));
            }

            if (dwNumCategories != 4) {
                fnWriteLogFile(TEXT("dwNumCategories is not 4.  This is an error.  dwNumCategories should be 4.\r\n"));
            }

            if ((pFaxCategories != NULL) && (dwNumCategories == 4)) {
                if (fnVerifyCategories(pFaxCategories, dwNumCategories)) {
                    (*pnNumCasesPassed)++;
					dwFuncCasesPass++;
                }
            }

            g_ApiInterface.FaxFreeBuffer(pFaxCategories);
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetLoggingCategories(NULL, &pFaxCategories, &dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxGetLoggingCategories() returned TRUE.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxCategories);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxCategories = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, NULL, &dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxGetLoggingCategories() returned TRUE.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxCategories);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwNumCategories = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, NULL)) {
        fnWriteLogFile(TEXT("FaxGetLoggingCategories() returned TRUE.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxCategories);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, &dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxGetLoggingCategories() returned TRUE.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxCategories);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
      //  if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
        //    return;
        //}

        //(*pnNumCasesAttempted)++;
        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, &dwNumCategories)) {
          //  fnWriteLogFile(TEXT("FaxGetLoggingCategories() failed.  The error code is 0x%08x.  This is an error.  FaxGetLoggingCategories() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  g_ApiInterface.FaxFreeBuffer(pFaxCategories);
            //(*pnNumCasesPassed)++;
        //}

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxGetLogginCategories, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxSetLoggingCategories(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits
)
/*++

Routine Description:

  FaxSetLoggingCategories()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE             hFaxSvcHandle;
    // pFaxCategories is the pointer to the fax logging categories
    PFAX_LOG_CATEGORY  pFaxCategories;
    // dwNumCategories is the number of fax logging categories
    DWORD              dwNumCategories;
    // pCopyFaxCategories is the pointer to the copy of the fax logging categories
    PFAX_LOG_CATEGORY  pCopyFaxCategories;

    DWORD              dwIndex;
    DWORD              cb;
    DWORD              dwOffset;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxSetLoggingCategories().\r\n"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        return;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s.\r\n"),szServerName);
	}


    if (!g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, &dwNumCategories)) {
		fnWriteLogFile(TEXT("WHIS> Test error: can not get Loggin catagories from %s, The error code is 0x%08x.\r\n"),szServerName,GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    for (dwIndex = 0, cb = 0; dwIndex < dwNumCategories; dwIndex++) {
        cb += sizeof(FAX_LOG_CATEGORY);
        cb += (lstrlen(pFaxCategories[dwIndex].Name) + 1) * sizeof(TCHAR);
    }

    pCopyFaxCategories = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb);
    dwOffset = dwNumCategories * sizeof(FAX_LOG_CATEGORY);
	
	
	if (bTestLimits)	{
		fnWriteLogFile(TEXT("WHIS> SETTING LIMIT VALUES...\r\n"));
		for (dwIndex = 0; dwIndex < dwNumCategories; dwIndex++) {
        pCopyFaxCategories[dwIndex].Name = (LPTSTR) ((DWORD) pCopyFaxCategories + dwOffset);
        lstrcpy((LPTSTR) pCopyFaxCategories[dwIndex].Name, pFaxCategories[dwIndex].Name);
        dwOffset += (lstrlen(pCopyFaxCategories[dwIndex].Name) + 1) * sizeof(TCHAR);

        pCopyFaxCategories[dwIndex].Category = pFaxCategories[dwIndex].Category;
        pCopyFaxCategories[dwIndex].Level = MAX_DWORD;
		}
	}
	else	{
		for (dwIndex = 0; dwIndex < dwNumCategories; dwIndex++) {
        pCopyFaxCategories[dwIndex].Name = (LPTSTR) ((DWORD) pCopyFaxCategories + dwOffset);
        lstrcpy((LPTSTR) pCopyFaxCategories[dwIndex].Name, pFaxCategories[dwIndex].Name);
        dwOffset += (lstrlen(pCopyFaxCategories[dwIndex].Name) + 1) * sizeof(TCHAR);

        pCopyFaxCategories[dwIndex].Category = pFaxCategories[dwIndex].Category;
        pCopyFaxCategories[dwIndex].Level = (pFaxCategories[dwIndex].Level + 1) % (FAXLOG_LEVEL_MAX + 1);
		}
	}

    // Set the logging categories
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	if (bTestLimits)
	{
		fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	}
	else
	{
		fnWriteLogFile(TEXT("Valid Case, Limit Values.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	}

    if (!g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, pCopyFaxCategories, dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() failed.  The error code is 0x%08x.  This is an error.  FaxSetLoggingCategories() should succeed.\r\n"), GetLastError());
    }
    else {
        if (fnVerifyCategories(pCopyFaxCategories, dwNumCategories)) {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    HeapFree(g_hHeap, 0, pCopyFaxCategories);

    // Set the logging categories
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, pFaxCategories, dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() failed.  The error code is 0x%08x.  This is an error.  FaxSetLoggingCategories() should succeed.\r\n"), GetLastError());
    }
    else {
        if (fnVerifyCategories(pFaxCategories, dwNumCategories)) {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetLoggingCategories(NULL, pFaxCategories, dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() returned TRUE.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    
	fnWriteLogFile(TEXT("pFaxCategories = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, NULL, dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() returned TRUE.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwNumCategories = 0.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, pFaxCategories, 0)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() returned TRUE.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, pFaxCategories, dwNumCategories)) {
        fnWriteLogFile(TEXT("FaxSetLoggingCategories() returned TRUE.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetLoggingCategories() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxFreeBuffer(pFaxCategories);

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //if (!g_ApiInterface.FaxGetLoggingCategories(hFaxSvcHandle, &pFaxCategories, &dwNumCategories)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

		//(*pnNumCasesAttempted)++;
		//fnWriteLogFile(TEXT("### FaxSetLoggingCategories().\r\n"));
        //if (!g_ApiInterface.FaxSetLoggingCategories(hFaxSvcHandle, pFaxCategories, dwNumCategories)) {
          //  fnWriteLogFile(TEXT("FaxSetLoggingCategories() failed.  The error code is 0x%08x.  This is an error.  FaxSetLoggingCategories() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;
        //}

//        g_ApiInterface.FaxFreeBuffer(pFaxCategories);

        // Disconnect from the fax server
  //      g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxSetLogginCategories, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}



BOOL WINAPI
FaxAPIDllTest(
	LPCWSTR  szWhisPhoneNumberW,
	LPCSTR   szWhisPhoneNumberA,
	LPCWSTR  szServerNameW,
    LPCSTR   szServerNameA,
    UINT     nNumCasesLocal,
    UINT     nNumCasesServer,
	PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	DWORD	 dwTestMode
)
{
    LPCTSTR  szServerName;
    UINT     nNumCases;

#ifdef UNICODE
    szServerName = szServerNameW;
#else
    szServerName = szServerNameA;
#endif


    if (szServerName) {
        nNumCases = nNumCasesServer;
		fnWriteLogFile(TEXT("WHIS> REMOTE SERVER MODE:\r\n"));
    }
    else {
        nNumCases = nNumCasesLocal;
    }

    // FaxGetConfiguration()
    fnFaxGetConfiguration(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

   

	// FaxSetConfiguration() limit testing
	if (dwTestMode == WHIS_TEST_MODE_LIMITS)
	{
		fnFaxSetConfiguration(szServerName, pnNumCasesAttempted, pnNumCasesPassed,TRUE);
	}
	else	{
		 // FaxSetConfiguration()
		fnFaxSetConfiguration(szServerName, pnNumCasesAttempted, pnNumCasesPassed,FALSE);
	}

	// FaxGetLoggingCategories()
    fnFaxGetLoggingCategories(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    // FaxSetLoggingCategories()
    fnFaxSetLoggingCategories(szServerName, pnNumCasesAttempted, pnNumCasesPassed,FALSE);

	// FaxSetLoggingCategories()
	if (dwTestMode == WHIS_TEST_MODE_LIMITS)
	{
		fnFaxSetLoggingCategories(szServerName, pnNumCasesAttempted, pnNumCasesPassed,TRUE);
	}

    if ((*pnNumCasesAttempted == nNumCases) && (*pnNumCasesPassed == *pnNumCasesAttempted)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxapi\faxapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxapi.c

Abstract:

  This module is a harness to test the Fax APIs

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#include <wtypes.h>
#include <stdio.h>
#include <lior_platform.h>

#include "dllapi.h"
#include "faxapi.h"

#include "util.c"


VOID
fnUsageInfo(
)
/*++

Routine Description:

  Displays the usage info in stdout

Return Value:

  None

--*/
{
    wprintf(L"Fax API Test Harness.\n");
    wprintf(L"\n");
    wprintf(L"FAXAPI /I:<ini file> /L:<log file> /V\n");
    wprintf(L"\n");
    wprintf(L"  /I:<ini file>       Ini file name.  Defaults to \"%s\".\n", FAXAPI_INIFILE);
    wprintf(L"  /L:<log file>       Log file name.  Defaults to \"%s\".\n", FAXAPI_LOGFILE);
    wprintf(L"  /S:<computer name>  Computer name.  Defaults to NULL\n");
    wprintf(L"  /V                  Verbose.\n");
    wprintf(L"\n");
}

BOOL
LoadFaxAPIs(
    PAPI_INTERFACE  pApiInterface
)
/*++

Routine Description:

  Loads the Fax APIs

Arguments:

  pApiInterface - pointer to the api interface structure

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the fax dll resides
    WCHAR  szDllPath[MAX_PATH];

    // Clear the dll path
    ZeroMemory(szDllPath, MAX_PATH);

    // Get the path
    if (GetSystemDirectory(szDllPath, MAX_PATH) == 0) {
        LocalEcho(L"GetSystemDirectory() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Concatenate the fax dll with the path
    lstrcat(szDllPath, WINFAX_DLL);

    // Get the handle to the fax dll
    pApiInterface->hInstance = LoadLibrary((LPCWSTR) szDllPath);
    if (!pApiInterface->hInstance) {
        LocalEcho(L"Could not load \"%s\", ec = 0x%08x.\n", szDllPath, GetLastError());
        return FALSE;
    }

    // Map all needed functions to pApiInterface

    // FaxAbort
    pApiInterface->FaxAbort = (PFAXABORT) GetProcAddress(pApiInterface->hInstance, "FaxAbort");
    if (!pApiInterface->FaxAbort) {
        LocalEcho(L"Could not retrieve the address of \"FaxAbort()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxAccessCheck
    pApiInterface->FaxAccessCheck = (PFAXACCESSCHECK) GetProcAddress(pApiInterface->hInstance, "FaxAccessCheck");
    if (!pApiInterface->FaxAccessCheck) {
        LocalEcho(L"Could not retrieve the address of \"FaxAccessCheck()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxClose
    pApiInterface->FaxClose = (PFAXCLOSE) GetProcAddress(pApiInterface->hInstance, "FaxClose");
    if (!pApiInterface->FaxClose) {
        LocalEcho(L"Could not retrieve the address of \"FaxClose()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxCompleteJobParamsW
    pApiInterface->FaxCompleteJobParamsW = (PFAXCOMPLETEJOBPARAMSW) GetProcAddress(pApiInterface->hInstance, "FaxCompleteJobParamsW");
    if (!pApiInterface->FaxCompleteJobParamsW) {
        LocalEcho(L"Could not retrieve the address of \"FaxCompleteJobParamsW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxCompleteJobParamsA
    pApiInterface->FaxCompleteJobParamsA = (PFAXCOMPLETEJOBPARAMSA) GetProcAddress(pApiInterface->hInstance, "FaxCompleteJobParamsA");
    if (!pApiInterface->FaxCompleteJobParamsA) {
        LocalEcho(L"Could not retrieve the address of \"FaxCompleteJobParamsA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxConnectFaxServerW
    pApiInterface->FaxConnectFaxServerW = (PFAXCONNECTFAXSERVERW) GetProcAddress(pApiInterface->hInstance, "FaxConnectFaxServerW");
    if (!pApiInterface->FaxConnectFaxServerW) {
        LocalEcho(L"Could not retrieve the address of \"FaxConnectFaxServerW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxConnectFaxServerA
    pApiInterface->FaxConnectFaxServerA = (PFAXCONNECTFAXSERVERA) GetProcAddress(pApiInterface->hInstance, "FaxConnectFaxServerA");
    if (!pApiInterface->FaxConnectFaxServerA) {
        LocalEcho(L"Could not retrieve the address of \"FaxConnectFaxServerA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnableRoutingMethodW
    pApiInterface->FaxEnableRoutingMethodW = (PFAXENABLEROUTINGMETHODW) GetProcAddress(pApiInterface->hInstance, "FaxEnableRoutingMethodW");
    if (!pApiInterface->FaxEnableRoutingMethodW) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnableRoutingMethodW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnableRoutingMethodA
    pApiInterface->FaxEnableRoutingMethodA = (PFAXENABLEROUTINGMETHODA) GetProcAddress(pApiInterface->hInstance, "FaxEnableRoutingMethodA");
    if (!pApiInterface->FaxEnableRoutingMethodA) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnableRoutingMethodA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumGlobalRoutingInfoW
    pApiInterface->FaxEnumGlobalRoutingInfoW = (PFAXENUMGLOBALROUTINGINFOW) GetProcAddress(pApiInterface->hInstance, "FaxEnumGlobalRoutingInfoW");
    if (!pApiInterface->FaxEnumGlobalRoutingInfoW) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumGlobalRoutingInfoW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumGlobalRoutingInfoA
    pApiInterface->FaxEnumGlobalRoutingInfoA = (PFAXENUMGLOBALROUTINGINFOA) GetProcAddress(pApiInterface->hInstance, "FaxEnumGlobalRoutingInfoA");
    if (!pApiInterface->FaxEnumGlobalRoutingInfoA) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumGlobalRoutingInfoA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumJobsW
    pApiInterface->FaxEnumJobsW = (PFAXENUMJOBSW) GetProcAddress(pApiInterface->hInstance, "FaxEnumJobsW");
    if (!pApiInterface->FaxEnumJobsW) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumJobsW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumJobsA
    pApiInterface->FaxEnumJobsA = (PFAXENUMJOBSA) GetProcAddress(pApiInterface->hInstance, "FaxEnumJobsA");
    if (!pApiInterface->FaxEnumJobsA) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumJobsA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumPortsW
    pApiInterface->FaxEnumPortsW = (PFAXENUMPORTSW) GetProcAddress(pApiInterface->hInstance, "FaxEnumPortsW");
    if (!pApiInterface->FaxEnumPortsW) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumPortsW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumPortsA
    pApiInterface->FaxEnumPortsA = (PFAXENUMPORTSA) GetProcAddress(pApiInterface->hInstance, "FaxEnumPortsA");
    if (!pApiInterface->FaxEnumPortsA) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumPortsA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumRoutingMethodsW
    pApiInterface->FaxEnumRoutingMethodsW = (PFAXENUMROUTINGMETHODSW) GetProcAddress(pApiInterface->hInstance, "FaxEnumRoutingMethodsW");
    if (!pApiInterface->FaxEnumRoutingMethodsW) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumRoutingMethodsW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxEnumRoutingMethodsA
    pApiInterface->FaxEnumRoutingMethodsA = (PFAXENUMROUTINGMETHODSA) GetProcAddress(pApiInterface->hInstance, "FaxEnumRoutingMethodsA");
    if (!pApiInterface->FaxEnumRoutingMethodsA) {
        LocalEcho(L"Could not retrieve the address of \"FaxEnumRoutingMethodsA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxFreeBuffer
    pApiInterface->FaxFreeBuffer = (PFAXFREEBUFFER) GetProcAddress(pApiInterface->hInstance, "FaxFreeBuffer");
    if (!pApiInterface->FaxFreeBuffer) {
        LocalEcho(L"Could not retrieve the address of \"FaxFreeBuffer()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetConfigurationW
    pApiInterface->FaxGetConfigurationW = (PFAXGETCONFIGURATIONW) GetProcAddress(pApiInterface->hInstance, "FaxGetConfigurationW");
    if (!pApiInterface->FaxGetConfigurationW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetConfigurationW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetConfigurationA
    pApiInterface->FaxGetConfigurationA = (PFAXGETCONFIGURATIONA) GetProcAddress(pApiInterface->hInstance, "FaxGetConfigurationA");
    if (!pApiInterface->FaxGetConfigurationA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetConfigurationA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetDeviceStatusW
    pApiInterface->FaxGetDeviceStatusW = (PFAXGETDEVICESTATUSW) GetProcAddress(pApiInterface->hInstance, "FaxGetDeviceStatusW");
    if (!pApiInterface->FaxGetDeviceStatusW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetDeviceStatusW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetDeviceStatusA
    pApiInterface->FaxGetDeviceStatusA = (PFAXGETDEVICESTATUSA) GetProcAddress(pApiInterface->hInstance, "FaxGetDeviceStatusA");
    if (!pApiInterface->FaxGetDeviceStatusA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetDeviceStatusA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetJobW
    pApiInterface->FaxGetJobW = (PFAXGETJOBW) GetProcAddress(pApiInterface->hInstance, "FaxGetJobW");
    if (!pApiInterface->FaxGetJobW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetJobW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetJobA
    pApiInterface->FaxGetJobA = (PFAXGETJOBA) GetProcAddress(pApiInterface->hInstance, "FaxGetJobA");
    if (!pApiInterface->FaxGetJobA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetJobA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetLoggingCategoriesW
    pApiInterface->FaxGetLoggingCategoriesW = (PFAXGETLOGGINGCATEGORIESW) GetProcAddress(pApiInterface->hInstance, "FaxGetLoggingCategoriesW");
    if (!pApiInterface->FaxGetLoggingCategoriesW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetLoggingCategoriesW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetLoggingCategoriesA
    pApiInterface->FaxGetLoggingCategoriesA = (PFAXGETLOGGINGCATEGORIESA) GetProcAddress(pApiInterface->hInstance, "FaxGetLoggingCategoriesA");
    if (!pApiInterface->FaxGetLoggingCategoriesA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetLoggingCategoriesA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetPageData
    pApiInterface->FaxGetPageData = (PFAXGETPAGEDATA) GetProcAddress(pApiInterface->hInstance, "FaxGetPageData");
    if (!pApiInterface->FaxGetPageData) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetPageData()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetPortW
    pApiInterface->FaxGetPortW = (PFAXGETPORTW) GetProcAddress(pApiInterface->hInstance, "FaxGetPortW");
    if (!pApiInterface->FaxGetPortW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetPortW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetPortA
    pApiInterface->FaxGetPortA = (PFAXGETPORTA) GetProcAddress(pApiInterface->hInstance, "FaxGetPortA");
    if (!pApiInterface->FaxGetPortA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetPortA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetRoutingInfoW
    pApiInterface->FaxGetRoutingInfoW = (PFAXGETROUTINGINFOW) GetProcAddress(pApiInterface->hInstance, "FaxGetRoutingInfoW");
    if (!pApiInterface->FaxGetRoutingInfoW) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetRoutingInfoW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxGetRoutingInfoA
    pApiInterface->FaxGetRoutingInfoA = (PFAXGETROUTINGINFOA) GetProcAddress(pApiInterface->hInstance, "FaxGetRoutingInfoA");
    if (!pApiInterface->FaxGetRoutingInfoA) {
        LocalEcho(L"Could not retrieve the address of \"FaxGetRoutingInfoA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxInitializeEventQueue
    pApiInterface->FaxInitializeEventQueue = (PFAXINITIALIZEEVENTQUEUE) GetProcAddress(pApiInterface->hInstance, "FaxInitializeEventQueue");
    if (!pApiInterface->FaxInitializeEventQueue) {
        LocalEcho(L"Could not retrieve the address of \"FaxInitializeEventQueue()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxOpenPort
    pApiInterface->FaxOpenPort = (PFAXOPENPORT) GetProcAddress(pApiInterface->hInstance, "FaxOpenPort");
    if (!pApiInterface->FaxOpenPort) {
        LocalEcho(L"Could not retrieve the address of \"FaxOpenPort()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxPrintCoverPageW
    pApiInterface->FaxPrintCoverPageW = (PFAXPRINTCOVERPAGEW) GetProcAddress(pApiInterface->hInstance, "FaxPrintCoverPageW");
    if (!pApiInterface->FaxPrintCoverPageW) {
        LocalEcho(L"Could not retrieve the address of \"FaxPrintCoverPageW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxPrintCoverPageA
    pApiInterface->FaxPrintCoverPageA = (PFAXPRINTCOVERPAGEA) GetProcAddress(pApiInterface->hInstance, "FaxPrintCoverPageA");
    if (!pApiInterface->FaxPrintCoverPageA) {
        LocalEcho(L"Could not retrieve the address of \"FaxPrintCoverPageA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxRegisterRoutingExtensionW
    pApiInterface->FaxRegisterRoutingExtensionW = (PFAXREGISTERROUTINGEXTENSIONW) GetProcAddress(pApiInterface->hInstance, "FaxRegisterRoutingExtensionW");
    if (!pApiInterface->FaxRegisterRoutingExtensionW) {
        LocalEcho(L"Could not retrieve the address of \"FaxRegisterRoutingExtensionW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxRegisterServiceProviderW
    pApiInterface->FaxRegisterServiceProviderW = (PFAXREGISTERSERVICEPROVIDERW) GetProcAddress(pApiInterface->hInstance, "FaxRegisterServiceProviderW");
    if (!pApiInterface->FaxRegisterServiceProviderW) {
        LocalEcho(L"Could not retrieve the address of \"FaxRegisterServiceProviderW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSendDocumentW
    pApiInterface->FaxSendDocumentW = (PFAXSENDDOCUMENTW) GetProcAddress(pApiInterface->hInstance, "FaxSendDocumentW");
    if (!pApiInterface->FaxSendDocumentW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSendDocumentW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSendDocumentA
    pApiInterface->FaxSendDocumentA = (PFAXSENDDOCUMENTA) GetProcAddress(pApiInterface->hInstance, "FaxSendDocumentA");
    if (!pApiInterface->FaxSendDocumentA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSendDocumentA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSendDocumentForBroadcastW
    pApiInterface->FaxSendDocumentForBroadcastW = (PFAXSENDDOCUMENTFORBROADCASTW) GetProcAddress(pApiInterface->hInstance, "FaxSendDocumentForBroadcastW");
    if (!pApiInterface->FaxSendDocumentForBroadcastW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSendDocumentForBroadcastW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSendDocumentForBroadcastA
    pApiInterface->FaxSendDocumentForBroadcastA = (PFAXSENDDOCUMENTFORBROADCASTA) GetProcAddress(pApiInterface->hInstance, "FaxSendDocumentForBroadcastA");
    if (!pApiInterface->FaxSendDocumentForBroadcastA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSendDocumentForBroadcastA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetConfigurationW
    pApiInterface->FaxSetConfigurationW = (PFAXSETCONFIGURATIONW) GetProcAddress(pApiInterface->hInstance, "FaxSetConfigurationW");
    if (!pApiInterface->FaxSetConfigurationW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetConfigurationW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetConfigurationA
    pApiInterface->FaxSetConfigurationA = (PFAXSETCONFIGURATIONA) GetProcAddress(pApiInterface->hInstance, "FaxSetConfigurationA");
    if (!pApiInterface->FaxSetConfigurationA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetConfigurationA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetGlobalRoutingInfoW
    pApiInterface->FaxSetGlobalRoutingInfoW = (PFAXSETGLOBALROUTINGINFOW) GetProcAddress(pApiInterface->hInstance, "FaxSetGlobalRoutingInfoW");
    if (!pApiInterface->FaxSetGlobalRoutingInfoW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetGlobalRoutingInfoW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetGlobalRoutingInfoA
    pApiInterface->FaxSetGlobalRoutingInfoA = (PFAXSETGLOBALROUTINGINFOA) GetProcAddress(pApiInterface->hInstance, "FaxSetGlobalRoutingInfoA");
    if (!pApiInterface->FaxSetGlobalRoutingInfoA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetGlobalRoutingInfoA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetJobW
    pApiInterface->FaxSetJobW = (PFAXSETJOBW) GetProcAddress(pApiInterface->hInstance, "FaxSetJobW");
    if (!pApiInterface->FaxSetJobW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetJobW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetJobA
    pApiInterface->FaxSetJobA = (PFAXSETJOBA) GetProcAddress(pApiInterface->hInstance, "FaxSetJobA");
    if (!pApiInterface->FaxSetJobA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetJobA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetLoggingCategoriesW
    pApiInterface->FaxSetLoggingCategoriesW = (PFAXSETLOGGINGCATEGORIESW) GetProcAddress(pApiInterface->hInstance, "FaxSetLoggingCategoriesW");
    if (!pApiInterface->FaxSetLoggingCategoriesW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetLoggingCategoriesW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetLoggingCategoriesA
    pApiInterface->FaxSetLoggingCategoriesA = (PFAXSETLOGGINGCATEGORIESA) GetProcAddress(pApiInterface->hInstance, "FaxSetLoggingCategoriesA");
    if (!pApiInterface->FaxSetLoggingCategoriesA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetLoggingCategoriesA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetPortW
    pApiInterface->FaxSetPortW = (PFAXSETPORTW) GetProcAddress(pApiInterface->hInstance, "FaxSetPortW");
    if (!pApiInterface->FaxSetPortW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetPortW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetPortA
    pApiInterface->FaxSetPortA = (PFAXSETPORTA) GetProcAddress(pApiInterface->hInstance, "FaxSetPortA");
    if (!pApiInterface->FaxSetPortA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetPortA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetRoutingInfoW
    pApiInterface->FaxSetRoutingInfoW = (PFAXSETROUTINGINFOW) GetProcAddress(pApiInterface->hInstance, "FaxSetRoutingInfoW");
    if (!pApiInterface->FaxSetRoutingInfoW) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetRoutingInfoW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxSetRoutingInfoA
    pApiInterface->FaxSetRoutingInfoA = (PFAXSETROUTINGINFOA) GetProcAddress(pApiInterface->hInstance, "FaxSetRoutingInfoA");
    if (!pApiInterface->FaxSetRoutingInfoA) {
        LocalEcho(L"Could not retrieve the address of \"FaxSetRoutingInfoA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxStartPrintJobW
    pApiInterface->FaxStartPrintJobW = (PFAXSTARTPRINTJOBW) GetProcAddress(pApiInterface->hInstance, "FaxStartPrintJobW");
    if (!pApiInterface->FaxStartPrintJobW) {
        LocalEcho(L"Could not retrieve the address of \"FaxStartPrintJobW()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    // FaxStartPrintJobA
    pApiInterface->FaxStartPrintJobA = (PFAXSTARTPRINTJOBA) GetProcAddress(pApiInterface->hInstance, "FaxStartPrintJobA");
    if (!pApiInterface->FaxStartPrintJobA) {
        LocalEcho(L"Could not retrieve the address of \"FaxStartPrintJobA()\".\n");
        FreeLibrary(pApiInterface->hInstance);
        return FALSE;
    }

    return TRUE;
}

BOOL
LoadFaxAPIDll(
    LPCWSTR         szIniFile,
    LPCWSTR         szCurrentSection,
    PDLL_INTERFACE  pDllInterface
)
/*++

Routine Description:

  Loads a Fax API Test Dll

Arguments:

  szIniFile - ini file name
  szCurrentSection - section name
  pDllInterface - pointer to the dll interface structure

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the dll resides
    WCHAR  szDllPath[MAX_PATH];

    GetPrivateProfileString(szCurrentSection, DLL_PATH, L"", szDllPath, MAX_PATH, szIniFile);

    if (!lstrcmpi(szDllPath, L"")) {
        LocalEcho(L"Could not find the \"Dll_Path\" key for section \"%s\".\n", szCurrentSection);
        return FALSE;
    }

    pDllInterface->hInstance = LoadLibrary(szDllPath);
    if (!pDllInterface->hInstance) {
        LocalEcho(L"Could not load \"%s\" for section \"%s\", ec = 0x%08x.\n", szDllPath, szCurrentSection, GetLastError());
        return FALSE;
    }

    pDllInterface->pFaxAPIDllInit = (PFAXAPIDLLINIT) GetProcAddress(pDllInterface->hInstance, "FaxAPIDllInit");
    if (!pDllInterface->pFaxAPIDllInit) {
        LocalEcho(L"Could not retrieve the address of \"FaxAPIDllInit()\".\n");
        FreeLibrary(pDllInterface->hInstance);
        return FALSE;
    }

	pDllInterface->pFaxAPIDllTest = (PFAXAPIDLLTEST) GetProcAddress(pDllInterface->hInstance, "FaxAPIDllTest");
    if (!pDllInterface->pFaxAPIDllTest) {
        LocalEcho(L"Could not retrieve the address of \"FaxAPIDllTest()\".\n");
        FreeLibrary(pDllInterface->hInstance);
        return FALSE;
    }

    return TRUE;
}

int _cdecl
main(
    INT   argc,
    CHAR  *argvA[]
)
{

    // bIniFile indicates an ini file name was found
    BOOL           bIniFile = FALSE;
    // szIniFile is the ini file name
    LPWSTR         szIniFile = NULL;
    // bLogFile indicates a log file name was found
    BOOL           bLogFile = FALSE;
    // szLogFile is the log file name
    LPWSTR         szLogFile = NULL;
    // bServerName indicates a server name was found
    BOOL           bServerName = FALSE;
    // szServerNameW is the server name
    LPWSTR         szServerNameW = NULL;
    // szServerNameA is the server name
    LPSTR          szServerNameA = NULL;
	
	// phone number 1 (ansi & widechar)
	//LPWSTR		   szWhisPhoneNumber1W=NULL;
	//LPSTR		   szWhisPhoneNumber1A=NULL;

    // szParam is a command line parameter
    LPWSTR         szParam;
    // wParamChar is a command line parameter character
    WCHAR          wParamChar;

    // ApiInterface is a API_INTERFACE structure
    API_INTERFACE  ApiInterface;

    // szSectionNames is the section names of the ini file
    LPWSTR         szSectionNames;
    // szCurrentSection is the current section
    LPWSTR         szCurrentSection;

	// whis: max routing global declaration (from ini)
    //UINT		   nWhisMaxRoutingMethods;

    // DllInterface is a DLL_INTERFACE structure
    DLL_INTERFACE  DllInterface;

    // szDescription is the description of the section
    WCHAR          szDescription[MAX_PATH];

	// szRemoteServerName is the name of the remote server
	WCHAR		   szWhisRemoteServerNameW[MAX_PATH];
	CHAR		   szWhisRemoteServerNameA[MAX_PATH];
	
	// szWhisPhoneNum1 is the 1st phone number to be used
	WCHAR		   szWhisPhoneNumber1W[MAX_PATH];
	CHAR		   szWhisPhoneNumber1A[MAX_PATH];
	
	// szWhisPhoneNum2 is the 2nd phone number to be used
	WCHAR		   szWhisPhoneNumber2W[MAX_PATH];	
	CHAR		   szWhisPhoneNumber2A[MAX_PATH];
	
	// flag for running in local case
	BOOL		   bLocalMode=TRUE;

	// result of DLL call
	BOOL		   bTestResult=FALSE;
    
	// nNumCasesLocal is the number of local cases in the section
    UINT           nNumCasesLocal;
    // nNumCasesServer is the number of server cases in the section
    UINT           nNumCasesServer;
    // nNumCasesAttempted is the number of cases attempted for the section
    UINT           nNumCasesAttempted;
    // nNumCasesPassed is the number of cases passed for the section
    UINT           nNumCasesPassed;
	// nWhisDoThisSet is a 0/1 var to flag if this test will be done
	DWORD		   dwWhisTestMode=0;

	// Summery variables
	UINT			nWhisNumSkipped=0;
	UINT			nWhisNumFailed=0;

    // iVal is the return value
    INT            iVal = -1;

    // dwIndex is a counter
    DWORD          dwIndex = 0;
    DWORD          cb;

	// total of all cases
	UINT			nTotCasesAttempted=0;
	UINT			nTotCasesPassed=0;
    

	
	
	// Welcome message (whis)
	LocalEcho(L"Welcome to whistler API Test");
//  LocalEcho(L"This test name is \"%s\".\n", WHIS_TITLE);
//	LocalEcho(L"This test var \"%d\".\n", dwData);
	
	
	// Get the handle to the process heap
    g_hHeap = GetProcessHeap();
	if (!g_hHeap) {
		LocalEcho(L"WHIS> ERROR Could not get proccess heap");
		goto ExitLevel0;
	}


    for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++) {
        // Determine the memory required for the parameter
        cb = (lstrlenA(argvA[dwIndex]) + 1) * sizeof(WCHAR);

        // Allocate the memory for the parameter
        szParam = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb);
		
		if (!szParam) {
		LocalEcho(L"WHIS> ERROR Could not alocate params heap");
		goto ExitLevel0;
		}


        // szParam is a CHAR*, so it needs to be converted to a WCHAR*
        // Conver szParam
        MultiByteToWideChar(CP_ACP, 0, argvA[dwIndex], -1, szParam, (lstrlenA(argvA[dwIndex]) + 1) * sizeof(WCHAR));

        // Set wParamChar
        wParamChar = szParam[2];

        // Replace wParamChar
        szParam[2] = '\0';

        if ((!lstrcmpi(HELP_SWITCH_1, szParam)) || (!lstrcmpi(HELP_SWITCH_2, szParam)) || (!lstrcmpi(HELP_SWITCH_3, szParam)) || (!lstrcmpi(HELP_SWITCH_4, szParam))) {
            fnUsageInfo();
            goto ExitLevel0;
        }
        else if (!lstrcmpi(VERBOSE_SWITCH, szParam)) {
            // Set g_bVerbose to TRUE
            g_bVerbose = TRUE;
        }
        else {
            // Reset wParamChar
            szParam[2] = wParamChar;

            // Set wParamChar
            wParamChar = szParam[3];

            if (wParamChar) {
                // Replace wParamChar
                szParam[3] = '\0';

                if ((!lstrcmpi(INIFILE_SWITCH, szParam)) && (!bIniFile)) {
                    // Reset wParamChar
                    szParam[3] = wParamChar;

                    // Set bIniFile to TRUE
                    bIniFile = TRUE;

                    cb = GetFullPathName(&szParam[3], 0, NULL, NULL);
                    // Allocate the memory for the ini file
                    szIniFile = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb * sizeof(WCHAR));
					if (!szIniFile) {
					LocalEcho(L"WHIS> ERROR Could not alocate heap for szIniFile");
					goto ExitLevel0;
					}

                    GetFullPathName(&szParam[3], cb, szIniFile, NULL);
                }
                else if ((!lstrcmpi(LOGFILE_SWITCH, szParam)) && (!bLogFile)) {
                    // Reset wParamChar
                    szParam[3] = wParamChar;

                    // Set bLogFile to TRUE
                    bLogFile = TRUE;

                    // Allocate the memory for the log file
                    szLogFile = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(szParam) - 1) * sizeof(WCHAR));
					if (!szLogFile) {
					LocalEcho(L"WHIS> ERROR Could not alocate heap for szLogFile");
					goto ExitLevel0;
					}

                    // Set szLogFile
                    lstrcpy(szLogFile, &szParam[3]);
                }
                else if ((!lstrcmpi(SERVER_SWITCH, szParam)) && (!bServerName)) {
					LocalEcho(L"WHIS> Server Name not supported as argument, use INI file");
                    // Reset wParamChar
                    //szParam[3] = wParamChar;

                    //Set bServerName to TRUE
                    //bServerName = TRUE;

                    //Allocate the memory for the server name
                    //szServerNameW = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(szParam) - 1) * sizeof(WCHAR));
					//if (!szServerNameW) {
					//LocalEcho(L"WHIS> ERROR Could not alocate heap for szServerNameW");
					//goto ExitLevel0;
					//}
                    //szServerNameA = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(szParam) - 1) * sizeof(CHAR));
					//if (!szServerNameA) {
				
					//goto ExitLevel0;
					//}

                    // Set szServerName
                    //lstrcpy(szServerNameW, &szParam[3]);
                    //ideCharToMultiByte(CP_ACP, 0, szServerNameW, -1, szServerNameA, (lstrlenW(szServerNameW) + 1) * sizeof(CHAR), NULL, NULL);
                }
            }
        }

        // Free the parameter
        if (!HeapFree(g_hHeap, 0, szParam))
		{
				LocalEcho(L"WHIS> ERROR Could not free heap for szParam");
		}

    }

    if (!bIniFile) {
        cb = GetFullPathName(FAXAPI_INIFILE, 0, NULL, NULL);
        // Allocate the memory for the ini file
        szIniFile = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb * sizeof(WCHAR));
		if (!szIniFile) {
					LocalEcho(L"WHIS> ERROR Could not alocate heap for szIniFile");
					goto ExitLevel0;
					}
        GetFullPathName(FAXAPI_INIFILE, cb, szIniFile, NULL);
    }



    if (!bLogFile) {
        // Allocate the memory for the log file
        szLogFile = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(FAXAPI_LOGFILE) + 1) * sizeof(WCHAR));
		if (!szLogFile) {
					LocalEcho(L"WHIS> ERROR Could not alocate heap for szLogFile");
					goto ExitLevel0;
					}

        // Set szLogFile
        lstrcpy(szLogFile, FAXAPI_LOGFILE);
    }

    if (GetFileAttributes(szIniFile) == 0xFFFFFFFF) {
        LocalEcho(L"Could not find the ini file \"%s\".\n", szIniFile);
        fnUsageInfo();
        goto ExitLevel0;
    }

    if (!LoadFaxAPIs(&ApiInterface)) {
        goto ExitLevel0;
    }

    // Get the section names
    cb = MAX_PATH;

	
	szSectionNames = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb * sizeof(WCHAR));
	if (!szSectionNames) {
					LocalEcho(L"WHIS> ERROR Could not alocate heap for szSectionNames");
					goto ExitLevel0;
					}
	
	while (GetPrivateProfileSectionNames(szSectionNames, cb, szIniFile) == (cb - 2)) {
        cb += MAX_PATH;
        szSectionNames = HeapReAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, szSectionNames, cb * sizeof(WCHAR));
		if (!szSectionNames) {
					LocalEcho(L"WHIS> ERROR Could not RE-alocate heap for szSectionNames");
					goto ExitLevel0;
					}
    }

    fnOpenLogFile(szLogFile);

    for (szCurrentSection = szSectionNames; szCurrentSection[0]; szCurrentSection = (LPWSTR) ((DWORD) szCurrentSection + (lstrlen(szCurrentSection) + 1) * sizeof(WCHAR))) {
        ZeroMemory(&DllInterface, sizeof(DLL_INTERFACE));

		// read global section values
		if (wcscmp(szCurrentSection,TEXT("global"))==0)	{
			
			
			
			// read phone number 1
			ZeroMemory(szWhisPhoneNumber1W, sizeof(szWhisPhoneNumber1W));
			ZeroMemory(szWhisPhoneNumber1A, sizeof(szWhisPhoneNumber1A));
			GetPrivateProfileString(szCurrentSection, GLOBAL_WHIS_PHONE_NUM_1, L"", szWhisPhoneNumber1W, MAX_PATH, szIniFile);
			if (lstrlen(szWhisPhoneNumber1W)==0)	{
				fnWriteAndEcho(L"WHIS> Warning, WhisPhoneNum1 missing, using default: \"%s\" \r\n", TEXT(WHIS_DEFAULT_PHONE_NUMBER));
				lstrcpy(szWhisPhoneNumber1W,TEXT(WHIS_DEFAULT_PHONE_NUMBER));
				WideCharToMultiByte(CP_ACP, 0, szWhisPhoneNumber1W, -1, szWhisPhoneNumber1A, (lstrlenW(szWhisPhoneNumber1W) + 1) * sizeof(CHAR), NULL, NULL);
			}
			else {
				WideCharToMultiByte(CP_ACP, 0, szWhisPhoneNumber1W, -1, szWhisPhoneNumber1A, (lstrlenW(szWhisPhoneNumber1W) + 1) * sizeof(CHAR), NULL, NULL);
			}

						
			// read phone number 2
			ZeroMemory(szWhisPhoneNumber2W, sizeof(szWhisPhoneNumber2W));
			ZeroMemory(szWhisPhoneNumber2A, sizeof(szWhisPhoneNumber2A));
			GetPrivateProfileString(szCurrentSection, GLOBAL_WHIS_PHONE_NUM_2, L"", szWhisPhoneNumber2W, MAX_PATH, szIniFile);
			if (lstrlen(szWhisPhoneNumber2W)==0)	{
				fnWriteAndEcho(L"WHIS> Warning, WhisPhoneNum2 missing, using default: \"%s\" \r\n", TEXT(WHIS_DEFAULT_PHONE_NUMBER));
				lstrcpy(szWhisPhoneNumber2W,TEXT(WHIS_DEFAULT_PHONE_NUMBER));
				WideCharToMultiByte(CP_ACP, 0, szWhisPhoneNumber2W, -1, szWhisPhoneNumber2A, (lstrlenW(szWhisPhoneNumber2W) + 1) * sizeof(CHAR), NULL, NULL);
			}
			else {
				WideCharToMultiByte(CP_ACP, 0, szWhisPhoneNumber2W, -1, szWhisPhoneNumber2A, (lstrlenW(szWhisPhoneNumber2W) + 1) * sizeof(CHAR), NULL, NULL);
			}

		
			// read server name
			ZeroMemory(szWhisRemoteServerNameW, sizeof(szWhisRemoteServerNameW));
			ZeroMemory(szWhisRemoteServerNameA, sizeof(szWhisRemoteServerNameA));
			GetPrivateProfileString(szCurrentSection,GLOBAL_WHIS_REMOTE_SERVER_NAME,L"",szWhisRemoteServerNameW,MAX_PATH,szIniFile);
			if (lstrlen(szWhisRemoteServerNameW)==0)	{
				fnWriteAndEcho(L"WHIS> Warning, szWhisRemoteServerName missing, using NULL server name (local)\r\n");
				ZeroMemory(szWhisRemoteServerNameW, sizeof(szWhisRemoteServerNameW));
				bLocalMode=TRUE;
				
			}
			else	{
				WideCharToMultiByte(CP_ACP, 0, szWhisRemoteServerNameW, -1, szWhisRemoteServerNameA, (lstrlenW(szWhisRemoteServerNameW) + 1) * sizeof(CHAR), NULL, NULL);
				bLocalMode=FALSE;
			}

			
				
			// read max routing extensions
			//nWhisMaxRoutingMethods = GetPrivateProfileInt(szCurrentSection, GLOBAL_WHIS_MAX_ROUTING_METHODS, 0, szIniFile);
			fnWriteAndEcho(L"WHIS> Using publics from \"%s\" \r\n", FAXAPI_PLATFORM);
			fnWriteAndEcho(L"WHIS> Whistler Phone Number \"%s\" \r\n", szWhisPhoneNumber1W);
			fnWriteAndEcho(L"WHIS> Whistler Phone Number \"%s\" \r\n", szWhisPhoneNumber2W);
			fnWriteAndEcho(L"WHIS> Whistler Remote Server Name \"%s\" \r\n", szWhisRemoteServerNameW);

#ifdef FAXAPI_W2K
	fnWriteAndEcho(L"$$$ Summery for this test, Name:Legacy C API, Id:21, Version:%s",FAXAPI_PLATFORM);
#else
	fnWriteAndEcho(L"$$$ Summery for this test, Name:Legacy C API, Id:20, Version:%s",FAXAPI_PLATFORM);
#endif

			//fnWriteAndEcho(L"WHIS> Whistler Max Routing methods %d \r\n", nWhisMaxRoutingMethods);
		}
		else
		{
			if (LoadFaxAPIDll(szIniFile, szCurrentSection, &DllInterface)) {

		        ZeroMemory(szDescription, sizeof(szDescription));
			    nNumCasesLocal = 0;
				nNumCasesServer = 0;
				nNumCasesAttempted = 0;
				nNumCasesPassed = 0;
			
	            __try {
		            DllInterface.pFaxAPIDllInit(g_hHeap, ApiInterface, fnWriteLogFileW, fnWriteLogFileA);
			    }
				__except(EXCEPTION_EXECUTE_HANDLER) {
					fnWriteAndEcho(L"Exception occurred in FaxAPIDllInit() for section \"%s\".  ec = 0x%08x.\r\n", szCurrentSection, GetExceptionCode());
					goto DllFailed;
				}

				GetPrivateProfileString(szCurrentSection, DLL_DESCRIPTION, L"", szDescription, MAX_PATH, szIniFile);
				nNumCasesLocal = GetPrivateProfileInt(szCurrentSection, DLL_LOCAL_CASES, 0, szIniFile);
				nNumCasesServer = GetPrivateProfileInt(szCurrentSection, DLL_SERVER_CASES, 0, szIniFile);
				dwWhisTestMode = GetPrivateProfileInt(szCurrentSection, DLL_WHIS_TEST_MODE, 0, szIniFile);
				fnWriteAndEcho(L"Section: %s\r\nDescription: %s\r\nNumber of local cases: %d\r\nNumber of server cases: %d\r\nTest Mode: %d\r\n", szCurrentSection, szDescription, nNumCasesLocal, nNumCasesServer,dwWhisTestMode);

				if (dwWhisTestMode == WHIS_TEST_MODE_DONT_CATCH_EXCEPTIONS)
				{
							fnWriteAndEcho(L"WHIS> Running extended test (NOTICE: WILL NOT CATCH EXCEPTIONS)...\r\n");
							if (bLocalMode)	{
								fnWriteAndEcho(L"WHIS> LOCAL MODE SET\r\n");
								bTestResult=!DllInterface.pFaxAPIDllTest(szWhisPhoneNumber1W,szWhisPhoneNumber1A,NULL, NULL, nNumCasesLocal, nNumCasesServer, &nNumCasesAttempted, &nNumCasesPassed,WHIS_TEST_MODE_DO);
							}
							else {
								fnWriteAndEcho(L"WHIS> SERVER MODE SET\r\n");
								bTestResult=!DllInterface.pFaxAPIDllTest(szWhisPhoneNumber1W,szWhisPhoneNumber1A,szWhisRemoteServerNameW, szWhisRemoteServerNameA, nNumCasesLocal, nNumCasesServer, &nNumCasesAttempted, &nNumCasesPassed,WHIS_TEST_MODE_DO);
								
							}
							
							if (bTestResult)	{
								fnWriteAndEcho(L"pFaxAPIDllTest() returned FALSE for section \"%s\".\r\n", szCurrentSection);
								}
							else {
								fnWriteAndEcho(L"pFaxAPIDllTest() returned TRUE for section \"%s\".\r\n", szCurrentSection);
								}
				} // (whis) end of don't catch exceptions
				else if (dwWhisTestMode != WHIS_TEST_MODE_SKIP) // (whis) INI configured to run this case
				{
					__try {
							fnWriteAndEcho(L"WHIS> Running extended test...\r\n");
							if (bLocalMode)	{
								fnWriteAndEcho(L"WHIS> LOCAL MODE SET\r\n");
								bTestResult=!DllInterface.pFaxAPIDllTest(szWhisPhoneNumber1W,szWhisPhoneNumber1A,NULL, NULL, nNumCasesLocal, nNumCasesServer, &nNumCasesAttempted, &nNumCasesPassed,dwWhisTestMode);
							}
							else {
								fnWriteAndEcho(L"WHIS> SERVER MODE SET\r\n");
								bTestResult=!DllInterface.pFaxAPIDllTest(szWhisPhoneNumber1W,szWhisPhoneNumber1A,szWhisRemoteServerNameW, szWhisRemoteServerNameA, nNumCasesLocal, nNumCasesServer, &nNumCasesAttempted, &nNumCasesPassed,dwWhisTestMode);
								
							}
							
							if (bTestResult)	{
								fnWriteAndEcho(L"pFaxAPIDllTest() returned FALSE for section \"%s\".\r\n", szCurrentSection);
								}
							else {
								fnWriteAndEcho(L"pFaxAPIDllTest() returned TRUE for section \"%s\".\r\n", szCurrentSection);
								}
							}
					__except(EXCEPTION_EXECUTE_HANDLER) {
							fnWriteAndEcho(L"Exception occurred in pFaxAPIDllTest() for section \"%s\".  ec = 0x%08x.\r\n", szCurrentSection, GetExceptionCode());
							goto DllFailed;
							}  // of try-except
				} // (whis) end of normal call to API DLL
				else {
				fnWriteAndEcho(L"Section: %s\r\nCanceled by user (see INI file for details)\r\n", szCurrentSection);
				}// (whis) end of don't run test at all


				fnWriteAndEcho(L"Section: %s\r\nNumber of cases attempted: %d\r\nNumber of cases passed: %d\r\n", szCurrentSection, nNumCasesAttempted, nNumCasesPassed);
				if (bLocalMode)		{
						nWhisNumSkipped=nNumCasesLocal-nNumCasesAttempted;
						nWhisNumFailed=nNumCasesAttempted-nNumCasesPassed;
				}
				else	{
						nWhisNumSkipped=nNumCasesServer-nNumCasesAttempted;
						nWhisNumFailed=nNumCasesAttempted-nNumCasesPassed;
				}

				
				fnWriteAndEcho(L"*** Number of cases skipped %d\r\n*** Number of cases failed %d\r\n",nWhisNumSkipped,nWhisNumFailed);

				nTotCasesAttempted+=nNumCasesAttempted;
				nTotCasesPassed+=nNumCasesPassed;

				


	DllFailed:
		        FreeLibrary(DllInterface.hInstance);
			}
		}
		
	}

		CloseHandle(g_hLogFile);



		iVal = 0;

	
	
		// Free the section names
		if (!HeapFree(g_hHeap, 0, szSectionNames))	{
		LocalEcho(L"WHIS> ERROR Could not free heap from szSectionNames");
		}

		// Free the phone number
		//if (szWhisPhoneNumber1W) {
		//	if (!HeapFree(g_hHeap, 0, szWhisPhoneNumber1W))	{
		//			LocalEcho(L"WHIS> ERROR Could not free heap from szWhisPhoneNumber1W");
		//	}
		//	if (!HeapFree(g_hHeap, 0, szWhisPhoneNumber1A))	{
		//			LocalEcho(L"WHIS> ERROR Could not free heap from szWhisPhoneNumber1A");
		//	}
		//}


		FreeLibrary(ApiInterface.hInstance);

		fnWriteAndEcho(L"\n\nSummery\n------------------");
		fnWriteAndEcho(L"\nNumber of cases attempted: %d\r\nNumber of cases passed: %d\r\n", nTotCasesAttempted, nTotCasesPassed);


	ExitLevel0:

		

		//if (szServerNameW) {
			// Free the server name
		//	if (!HeapFree(g_hHeap, 0, szServerNameW))
		//	{
		//		LocalEcho(L"WHIS> ERROR Could not free heap from szServerNameW");
		//	}
		//	if (!HeapFree(g_hHeap, 0, szServerNameA))
		//	{
		//		LocalEcho(L"WHIS> ERROR Could not free heap from szServerNameA");
		//	}
		//}

		
		if (szIniFile) {
			// Free the ini file name
			if (!HeapFree(g_hHeap, 0, szIniFile)) {
				LocalEcho(L"WHIS> ERROR Could not free heap from szIniFile");
			}

		}
		if (szLogFile) {
	        // Free the log file name
			if (!HeapFree(g_hHeap, 0, szLogFile)) {
			LocalEcho(L"WHIS> ERROR Could not free heap from szIniFile");
			}
		}

		return iVal;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\testsuite.cpp ===
/*++
	This file implements generic test suite

	Author: Yury Berezansky (yuryb)

	12.11.2000
--*/

#pragma warning(disable :4786)

#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include "..\generalutils\iniutils.h"
#include "report.h"
#include "genutils.h"
#include "testsuite.h"

/**************************************************************************************************************************
	General declarations and definitions
**************************************************************************************************************************/

#define INI_SEC_AREAS					TEXT("Areas")

static BOOL s_bLoggerInitialized	= FALSE;
static BOOL s_bSuiteLogInitialized	= FALSE;





/**************************************************************************************************************************
	Static functions declarations
**************************************************************************************************************************/

static	DWORD	RunArea			(const TESTAREA *pTestArea, const TESTPARAMS *pTestParams, LPCTSTR lpctstrIniFile, BOOL *lpbAreaPassed);





/**************************************************************************************************************************
	Functions definitions
**************************************************************************************************************************/

DWORD InitSuiteLog(LPCTSTR lpctstrSuiteName)
{
	DWORD dwEC = ERROR_SUCCESS;

	// Initialize logger
	if (!s_bLoggerInitialized && !lgInitializeLogger())
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("lgInitializeLogger"), dwEC);
		goto exit_func;
	}
	s_bLoggerInitialized = TRUE;

	// Begin test suite (logger)
	if(!s_bSuiteLogInitialized && !lgBeginSuite(lpctstrSuiteName))
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("lgBeginSuite"), dwEC);
		goto exit_func;
	}
	s_bSuiteLogInitialized = TRUE;

exit_func:
	
	if (dwEC != ERROR_SUCCESS)
	{
		DWORD dwCleanUpEC = EndSuiteLog();

		if (dwCleanUpEC != ERROR_SUCCESS)
		{
			DbgMsg(DBG_FAILED_ERR, TEXT("EndSuiteLog"), dwCleanUpEC);
		}
	}

	return dwEC;
}



DWORD EndSuiteLog(void)
{
	DWORD dwEC = ERROR_SUCCESS;
	
	if (s_bSuiteLogInitialized && !lgEndSuite())
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("lgEndSuite"), dwEC);
	}
	s_bSuiteLogInitialized = FALSE;

	if (s_bLoggerInitialized && !lgCloseLogger())
	{
		dwEC = GetLastError();
		DbgMsg(DBG_FAILED_ERR, TEXT("lgCloseLogger"), dwEC);
	}
	s_bLoggerInitialized = FALSE;

	return dwEC;
}



/*++
	Runs specified test suite, using specified global suite parameters and inifile

	[IN]	pTestSuite		Pointer to TESTSUITE structure
	[IN]	pTestParams		Pointer to TESTPARAMS structure (if the suite doesn't use global
							parameters, should be NULL)
	[IN]	lpctstrIniFile	Name of inifile that should be used

	Return value:			Win32 error code
--*/
DWORD RunSuite(const TESTSUITE *pTestSuite, const TESTPARAMS *pTestParams, LPCTSTR lpctstrIniFile)
{
	std::map<tstring, tstring>::const_iterator mci;
	BOOL		bLoggerInitialized		= FALSE;
	BOOL		bSuiteLogInitialized	= FALSE;
	BOOL		bRes					= FALSE;
	DWORD		dwInd					= 0;
	DWORD		dwEC					= ERROR_SUCCESS;
	DWORD		dwCleanUpEC				= ERROR_SUCCESS;


	dwEC = InitSuiteLog(pTestSuite->szName);
	if (dwEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("InitSuiteLog"), dwEC);

		// no clean up needed at this stage
		return dwEC;
	}
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering RunSuite\n\tpTestSuite = 0x%08lX\n\tpTestParams = 0x%08lX\n\tlpctstrIniFile = %s"),
		(DWORD)pTestSuite,
		(DWORD)pTestParams,
		lpctstrIniFile
		);

	if (!(pTestSuite && lpctstrIniFile))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to RunSuite() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);

		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// get map of areas from ini file
	std::map<tstring, tstring> mAreas = INI_GetSectionEntries(lpctstrIniFile, INI_SEC_AREAS);
	if (mAreas.empty())
	{
		dwEC = ERROR_NOT_FOUND;
		lgLogError(
			LOG_SEV_1,
			TEXT("section %s not found in %s inifile\n"),
			INI_SEC_AREAS,
			lpctstrIniFile
			);
		goto exit_func;
	}

	for (mci = mAreas.begin(); mci != mAreas.end(); mci++)
	{
		if (mci->second != TEXT("1"))
		{
			continue;
		}

		for (dwInd = 0; dwInd < pTestSuite->dwAvailableAreas; dwInd++)
		{
			if (mci->first == pTestSuite->ppTestArea[dwInd]->szName)
			{
				dwEC = RunArea(pTestSuite->ppTestArea[dwInd], pTestParams, lpctstrIniFile, &bRes);
				if (dwEC != ERROR_SUCCESS)
				{
					lgLogError(
						LOG_SEV_2, 
						TEXT("FILE:%s LINE:%ld An error occured while running %s area (ec = 0x%08lX)."),
						TEXT(__FILE__),
						__LINE__,
						pTestSuite->ppTestArea[dwInd]->szName,
						dwEC
						);

					// failure of one test area is not failure of the whole suite
					dwEC = ERROR_SUCCESS;
				}
				break;
			}
		}
		if (dwInd == pTestSuite->dwAvailableAreas)
		{
			// we leaved the loop because of condition and not with break
			// it means that requested test area is not found among available test areas

			lgLogError(LOG_SEV_2, TEXT("Unknown test area: %s\n"), mci->first.c_str());
		}
	}

exit_func:

	dwCleanUpEC = EndSuiteLog();
	if (dwCleanUpEC != ERROR_SUCCESS)
	{
		DbgMsg(DBG_FAILED_ERR, TEXT("EndSuiteLog"), dwCleanUpEC);
	}

	return dwEC;
}



/*++
	Reads a structure from inifile

	[IN]	lpStruct			Pointer to a structure
	[IN]	pStructDesc			Pointer to MEMBERDESCRIPTOR array (each member of it describes structure's member)
	[IN]	dwMembersCount		Number of members in the structure (members in array of MEMBERDESCRIPTOR)
	[IN]	lpctstrIniFile		Name of inifile
	[IN]	lpctstrSection		Name of section in the inifile

	Return value:				Win32 error code
--*/
DWORD ReadStructFromIniFile(
	LPVOID lpStruct,
	const MEMBERDESCRIPTOR *pStructDesc,
	DWORD dwMembersCount,
	LPCTSTR lpctstrIniFile,
	LPCTSTR lpctstrSection
	)
{
	DWORD	dwMembersInd	= 0;
	DWORD	dwEC			= ERROR_SUCCESS;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering ReadStructFromIniFile\n\tlpStruct = 0x%08lX\n\tpStructDesc = 0x%08lX\n\tdwMembersCount = %ld\n\tlpctstrIniFile = %s\n\tlpctstrSection = %s"),
		(DWORD)lpStruct,
		(DWORD)pStructDesc,
		dwMembersCount,
		lpctstrIniFile,
		lpctstrSection
		);

	if (!(lpStruct && pStructDesc && lpctstrIniFile && lpctstrSection))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to ReadStructFromIniFile() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	// get map of the section
	std::map<tstring, tstring> mSection = INI_GetSectionEntries(lpctstrIniFile, lpctstrSection);
	if (mSection.empty())
	{
		dwEC = ERROR_NOT_FOUND;
		lgLogError(
			LOG_SEV_1,
			TEXT("section %s not found in %s inifile\n"),
			lpctstrSection,
			lpctstrIniFile
			);
		return dwEC;
	}

	for (dwMembersInd = 0; dwMembersInd < dwMembersCount; dwMembersInd++)
	{
		std::map<tstring, tstring>::const_iterator MapIterator = mSection.find(pStructDesc[dwMembersInd].lpctstrName);

		if(MapIterator == mSection.end())
		{
			lgLogError(
				LOG_SEV_1,
				TEXT("value %s not found in %s section of %s inifile\n"),
				pStructDesc[dwMembersInd].lpctstrName,
				lpctstrSection,
				lpctstrIniFile
				);
			return ERROR_NOT_FOUND;
		}

		dwEC = StrToMember(
			(LPBYTE)(lpStruct) + pStructDesc[dwMembersInd].dwOffset,
			MapIterator->second.c_str(),
			pStructDesc[dwMembersInd].dwType
			);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld StrToMember failed (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				dwEC
				);
			return dwEC;
		}
	}

	return ERROR_SUCCESS;
}



/*++
	Reads a structure from specified registry key

	[IN]	lpStruct			Pointer to a structure
	[IN]	pStructDesc			Pointer to MEMBERDESCRIPTOR array (each member of it describes structure's member)
	[IN]	dwMembersCount		Number of members in the structure (members in array of MEMBERDESCRIPTOR)
	[IN]	hkRegKey			Handle to a registry key

	Return value:				Win32 error code
--*/
DWORD ReadStructFromRegistry(
	LPVOID lpStruct,
	const MEMBERDESCRIPTOR *pStructDesc,
	DWORD dwMembersCount,
	HKEY hkRegKey
	)
{
	LPBYTE	lpBuffer	= NULL;
	DWORD	dwInd		= 0;
	DWORD	dwEC		= ERROR_SUCCESS;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering ReadStructFromRegistry\n\tlpStruct = 0x%08lX\n\tpStructDesc = 0x%08lX\n\tdwMembersCount = %ld\n\thkRegKey = %ld"),
		(DWORD)lpStruct,
		(DWORD)pStructDesc,
		dwMembersCount,
		(DWORD)hkRegKey
		);

	if (!(lpStruct && pStructDesc && hkRegKey))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to ReadStructFromRegistry() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	for (dwInd = 0; dwInd < dwMembersCount; dwInd++)
	{
		DWORD	dwBufSize	= 0;

		// get required buffer size
		dwEC = RegQueryValueEx(hkRegKey, pStructDesc[dwInd].lpctstrName, NULL, NULL, NULL, &dwBufSize);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld RegQueryValueEx failed (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				dwEC
				);
			goto exit_func;
		}

		// got the size, go with it
		if (dwBufSize > 0)
		{
			if (!(lpBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, dwBufSize)))
			{
				dwEC = GetLastError();
				lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
					TEXT(__FILE__),
					__LINE__,
					dwEC
					);
				goto exit_func;
			}
			dwEC = RegQueryValueEx(hkRegKey, pStructDesc[dwInd].lpctstrName, NULL, NULL, lpBuffer, &dwBufSize);
			if (dwEC != ERROR_SUCCESS)
			{
				lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%ld RegQueryValueEx failed (ec = 0x%08lX)"),
					TEXT(__FILE__),
					__LINE__,
					dwEC
					);
					goto exit_func;
			}
			dwEC = StrToMember(
				(LPBYTE)(lpStruct) + pStructDesc[dwInd].dwOffset,
				(LPCTSTR)lpBuffer,
				pStructDesc[dwInd].dwType
				);
			if (dwEC != ERROR_SUCCESS)
			{
				lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%ld StrToMember failed (ec = 0x%08lX)"),
					TEXT(__FILE__),
					__LINE__,
					dwEC
					);
				goto exit_func;
			}

			if (lpBuffer)
			{
				LocalFree(lpBuffer);
				lpBuffer = NULL;
			}
		}
	}

exit_func:

	if (lpBuffer)
	{
		LocalFree(lpBuffer);
	}

	return dwEC;
}



/*++
	Compares two structures

	[IN]	lpStruct1			Pointer to first structure
	[IN]	lpStruct2			Pointer to second structure
	[IN]	pStructDesc			Pointer to MEMBERDESCRIPTOR array (each member of it describes structure's member)
	[IN]	dwMembersCount		Number of members in the structure (members in array of MEMBERDESCRIPTOR)
	[OUT]	lpbIdentical		Pointer to a boolean that receives the result of comparison
	
	Return value:				Win32 error code
--*/
DWORD CompareStruct(const LPVOID lpStruct1, const LPVOID lpStruct2, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, BOOL *lpbIdentical)
{
	DWORD	dwMembersInd	= 0;
	BOOL	bTmpRes			= TRUE;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering CompareStruct\n\tlpStruct1 = 0x%08lX\n\tlpStruct2 = 0x%08lX\n\tpStructDesc = 0x%08lX\n\tdwMembersCount = %ld\n\tlpbIdentical = 0x%08lX"),
		(DWORD)lpStruct1,
		(DWORD)lpStruct2,
		(DWORD)pStructDesc,
		dwMembersCount,
		(DWORD)lpbIdentical
		);

	if (!(lpStruct1 && lpStruct2 && pStructDesc))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to CompareStruct() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	for (dwMembersInd = 0; dwMembersInd < dwMembersCount; dwMembersInd++)
	{
		LPVOID lpMember1 = (LPBYTE)(lpStruct1) + pStructDesc[dwMembersInd].dwOffset;
		LPVOID lpMember2 = (LPBYTE)(lpStruct2) + pStructDesc[dwMembersInd].dwOffset;

		bTmpRes = TRUE;
		
		switch (pStructDesc[dwMembersInd].dwType)
		{
		case TYPE_UNKNOWN:
			break;
		case TYPE_DWORD:
			bTmpRes = *(DWORD *)lpMember1 == *(DWORD *)lpMember2;
			break;
		case TYPE_BOOL:
			bTmpRes = *(BOOL *)lpMember1 != *(BOOL *)lpMember2;
			break;
		case TYPE_LPTSTR:
			bTmpRes = _tcscmp(*(LPTSTR *)lpMember1, *(LPTSTR *)lpMember1) == 0;
			break;
		case TYPE_LPSTR:
			break;
		default:
			_ASSERT(FALSE);
		}

		if (!bTmpRes)
		{
			break;
		}
	}

	*lpbIdentical = bTmpRes;

	return ERROR_SUCCESS;
}



/*++
	Writes to log contents of a structure

	[IN]	lpStruct			Pointer to structure
	[IN]	pStructDesc			Pointer to MEMBERDESCRIPTOR array (each member of it describes structure's member)
	[IN]	dwMembersCount		Number of members in the structure (members in array of MEMBERDESCRIPTOR)
	
	Return value:				Win32 error code
--*/
DWORD LogStruct(const LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount)
{
	DWORD			dwMembersInd	= 0;
	const DWORD		dwTitleWidth	= 15;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering LogStruct\n\tlpStruct = 0x%08lX\n\tpStructDesc = 0x%08lX\n\tdwMembersCount = %ld"),
		(DWORD)lpStruct,
		(DWORD)pStructDesc,
		dwMembersCount
		);

	if (!(lpStruct && pStructDesc))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to LogStruct() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	for (dwMembersInd = 0; dwMembersInd < dwMembersCount; dwMembersInd++)
	{
		LPVOID lpMember = (LPBYTE)(lpStruct) + pStructDesc[dwMembersInd].dwOffset;

		switch (pStructDesc[dwMembersInd].dwType)
		{
		case TYPE_UNKNOWN:
			break;
		case TYPE_DWORD:
			lgLogDetail(
				LOG_X,
				LOG_X,
				TEXT("\t\t%-*s%ld"),
				dwTitleWidth,
				pStructDesc[dwMembersInd].lpctstrName,
				*(DWORD *)lpMember
				);
			break;
		case TYPE_BOOL:
			lgLogDetail(
				LOG_X,
				LOG_X,
				TEXT("\t\t%-*s%s"),
				dwTitleWidth,
				pStructDesc[dwMembersInd].lpctstrName,
				*(BOOL *)lpMember ? TEXT("yes") : TEXT("no")
				);
			break;
		case TYPE_LPTSTR:
			lgLogDetail(
				LOG_X,
				LOG_X,
				TEXT("\t\t%-*s%s"),
				dwTitleWidth,
				pStructDesc[dwMembersInd].lpctstrName,
				*(LPTSTR *)lpMember
				);
			break;
		case TYPE_LPSTR:
			break;
		default:
			_ASSERT(FALSE);
		}
	}

	return ERROR_SUCCESS;
}



/*++
	Frees a structure

	[IN]	lpStruct			Pointer to structure
	[IN]	pStructDesc			Pointer to MEMBERDESCRIPTOR array (each member of it describes structure's member)
	[IN]	dwMembersCount		Number of members in the structure (members in array of MEMBERDESCRIPTOR)
	[IN]	bStructItself		If FALSE, only memory pointed to by structure's members is freed.
								If TRUE, memory occupied by structure itself is freed too.
	
	Return value:				Win32 error code
--*/
DWORD FreeStruct(LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, BOOL bStructItself)
{
	DWORD dwMembersInd = 0;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering ReadStructFromIniFile\n\tlpStruct = 0x%08lX\n\tpStructDesc = 0x%08lX\n\tdwMembersCount = %ld\n\tbStructItself = %ld"),
		(DWORD)lpStruct,
		(DWORD)pStructDesc,
		dwMembersCount,
		bStructItself
		);

	if (!(lpStruct && pStructDesc))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to FreeStruct() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	for (dwMembersInd = 0; dwMembersInd < dwMembersCount; dwMembersInd++)
	{
		LPVOID lpMember = (LPBYTE)lpStruct + pStructDesc[dwMembersInd].dwOffset;

		switch (pStructDesc[dwMembersInd].dwType)
		{
		case TYPE_UNKNOWN:
		case TYPE_DWORD:
		case TYPE_BOOL:
			break;
		case TYPE_LPTSTR:
			{
				LPTSTR lptstrString = *(LPTSTR *)lpMember;
				if (lptstrString)
				{
					LocalFree(lptstrString);
				}
			}
			break;
		case TYPE_LPSTR:
			{
				LPSTR lpstrString = *(LPSTR *)lpMember;
				if (lpstrString)
				{
					LocalFree(lpstrString);
				}
			}
			break;
		default:
			_ASSERT(FALSE);
		}
	}
	
	if (bStructItself)
	{
		LocalFree(lpStruct);
	}

	return ERROR_SUCCESS;
}



/*++
	Receives string, converts it to specified type (if possible) and saves it

	[OUT]	lpParam			Pointer to variable that receives converted data
	[IN]	lpctstrStr		String that should be converted
	[IN]	dwType			Type of variable pointed to by lpParam
	
	Return value:			Win32 error code
--*/
DWORD StrToMember(LPVOID lpParam, LPCTSTR lpctstrStr, DWORD dwType)
{
	DWORD dwEC = ERROR_SUCCESS;

	if (!s_bSuiteLogInitialized)
	{
		DbgMsg(TEXT("Suite log is not initialized. Call InitSuiteLog()."));
		return 0xFFFFFFFF;
	}
	
	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering StrToMember\n\tlpParam = 0x%08lX\n\tlpctstrStr = %s\n\tdwType = %ld"),
		(DWORD)lpParam,
		lpctstrStr,
		dwType
		);

	if (!(lpParam && lpctstrStr))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to StrToMember() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);
		return ERROR_INVALID_PARAMETER;
	}

	switch(dwType)
	{
	case TYPE_UNKNOWN:
		break;
	case TYPE_DWORD:
		dwEC = _tcsToDword(lpctstrStr, (DWORD *)lpParam);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld Failed to convert %s to DWORD (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				lpctstrStr,
				dwEC
				);
		}
		break;
	case TYPE_BOOL:
		dwEC = _tcsToBool(lpctstrStr, (BOOL *)lpParam);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld Failed to convert %s to BOOL (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				lpctstrStr,
				dwEC
				);
		}
		break;
	case TYPE_LPTSTR:
		dwEC = StrAllocAndCopy((LPTSTR *)lpParam, lpctstrStr);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld StrAllocAndCopy failed (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				dwEC
				);
		}
		break;
	case TYPE_LPSTR:
		dwEC = StrGenericToAnsiAllocAndCopy((LPSTR *)lpParam, lpctstrStr);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld StrGenericToAnsiAllocAndCopy failed (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				dwEC
				);
		}
		break;
	default:
		_ASSERT(FALSE);
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Invalid member type: %ld"),
			TEXT(__FILE__),
			__LINE__,
			dwType
			);
		return ERROR_INVALID_PARAMETER;
	}

	return dwEC;
}



/*++
	Runs specified area in a test suite

	[IN]	pTestArea		Pointer to TESTAREA structure
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrIniFile	Name of inifile that should be used
	[OUT]	lpbAreaPassed	Pointer to a boolean that receives the area test result
	
	Return value:			Win32 error code
--*/
static DWORD RunArea(const TESTAREA *pTestArea, const TESTPARAMS *pTestParams, LPCTSTR lpctstrIniFile, BOOL *lpbAreaPassed)
{
	std::map<tstring, tstring>::const_iterator mci;
	DWORD	dwEC	= ERROR_SUCCESS;

	lgLogDetail(
		LOG_X, 
		5,
		TEXT("Entering RunArea\n\tpTestArea = 0x%08lX\n\tpTestParams = 0x%08lX\n\tlpctstrIniFile = %s\n\tlpbAreaPassed = 0x%08lX"),
		(DWORD)pTestArea,
		(DWORD)pTestParams,
		lpctstrIniFile,
		(DWORD)lpbAreaPassed
		);

	if (!(pTestParams && pTestArea && lpbAreaPassed))
	{
		lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Call to RunArea() with invalid parameters"),
			TEXT(__FILE__),
			__LINE__
			);

		// no clean up needed at this stage
		return ERROR_INVALID_PARAMETER;
	}

	// get map of test cases from ini file
	std::map<tstring, tstring> mCases = INI_GetSectionEntries(lpctstrIniFile, pTestArea->szName);
	if (mCases.empty())
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("section %s not found in %s inifile\n"),
			pTestArea->szName,
			lpctstrIniFile
			);
		return ERROR_NOT_FOUND;
	}

	*lpbAreaPassed = TRUE;
	
	for (mci = mCases.begin(); mci != mCases.end(); mci++)
	{
		DWORD	dwCaseInd	= 0;
		DWORD	dwRunsCount	= 0;

		dwEC = _tcsToDword(mci->second.c_str(), &dwRunsCount);
		if (dwEC != ERROR_SUCCESS)
		{
			lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%ld Failed to read runs count for %s test case (ec = 0x%08lX)"),
				TEXT(__FILE__),
				__LINE__,
				mci->first.c_str(),
				dwEC
				);
			continue;
		}

		if (dwRunsCount == 0)
		{
			continue;
		}

		for (dwCaseInd = 0; dwCaseInd < pTestArea->dwAvailableCases; dwCaseInd++)
		{
			if (mci->first == pTestArea->ptc[dwCaseInd].szName)
			{
				DWORD	dwRunInd = 0;

				for (dwRunInd = 0; dwRunInd < dwRunsCount; dwRunInd++)
				{
					BOOL bCasePassed;
					TCHAR tszSection[NAME_LENGTH + DWORD_DECIMAL_LENGTH + 1];

					// Begin test case (logger)
					lgBeginCase(dwCaseInd, pTestArea->ptc[dwCaseInd].szName);

					_stprintf(tszSection, TEXT("%s%ld"), mci->first.c_str(), dwRunInd);
					dwEC = (pTestArea->ptc[dwCaseInd].pftc)(pTestParams, tszSection, &bCasePassed);
					if (dwEC != ERROR_SUCCESS)
					{
						lgLogError(
							LOG_SEV_1,
							TEXT("An error occured running test case %s (ec = 0x%08lX)\n"),
							pTestArea->ptc[dwCaseInd].szName,
							dwEC
							);

						// internal error in a test case doesn't stop exicution of other test cases in the area
						dwEC = ERROR_SUCCESS;
					}

					*lpbAreaPassed = *lpbAreaPassed && bCasePassed;

					// End test case (logger)
					lgEndCase();
				}

				break;
			}
		}

		if (dwCaseInd == pTestArea->dwAvailableCases)
		{
			lgLogError(LOG_SEV_2, TEXT("Unknown test case: %s\n"), mci->first.c_str());
		}
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\testsuite.h ===
#ifndef __TESTSUITE_H__
#define __TESTSUITE_H__


#define NAME_LENGTH		20


/*++
	MEMBERDESCRIPTOR structure is the core of the mechanizm that allows to perform the following operations in a loop:
		* read values from inifile and save them in a structure
		* free a memory, pointed to by structure members (one level only)
		* perform member to member comparison of two structures
		:
		:
	Bottom line: it allows to perform similar operations on all members of a structure in a loop.

	Example:

		1) define a structure:

			typedef struct mystruct_tag {
				DWORD	dwSomeDword;
				BOOL	bSomeBoolean;
				LPTSTR	lpctstrSomeString;
				:
				:
			} MYSTRUCT;

		2) define and initialize an array of MEMBERDESCRIPTOR structures that describe MYSTRUCT's members:

			const MEMBERDESCRIPTOR aMyStructDesc[] {
				{TEXT("SomeDword"),		TYPE_DWORD,		offsetof(MYSTRUCT,	dwSomeDwordValue)	},
				{TEXT("SomeBoolean"),	TYPE_BOOL,		offsetof(MYSTRUCT,	bSomeBoolean)		},
				{TEXT("SomeString"),	TYPE_LPTSTR,	offsetof(MYSTRUCT,	lpctstrSomeString)	},
				:
				:
			};

		3) create an instanse of MYSTRUCT:

			MYSTRUCT MyStruct;

		4) use it:

			DWORD dwMemebersCount = sizeof(aMyStructDesc) / sizeof(aMyStructDesc[0]);
			DWORD dwMembersInd;

			for (dwMembersInd = 0; dwMembersInd < ; dwMembersInd++)
			{
				LPVOID lpMember = (LPBYTE)(&MyStruct) + aMyStructDesc[dwMembersInd].dwOffset;

				GetValueFromIniFile(
					aMyStructDesc[dwMembersInd].lpctstrName,	// entry name in inifile
					aMyStructDesc[dwMembersInd].dwType,			// expected type
					lpMember									// pointer to a member
					);
			}
--*/

typedef struct memberdescriptor_tag {
	LPCTSTR lpctstrName;	// entry in an inifile, registry value, control caption ...
	DWORD dwType;			// expected type
	DWORD dwOffset;			// offset in a structure in bytes
} MEMBERDESCRIPTOR;

#define	TYPE_UNKNOWN			0x00000000
#define	TYPE_DWORD				0x00000001
#define	TYPE_BOOL				0x00000002
#define TYPE_LPTSTR				0x00000003
#define	TYPE_LPSTR				0x00000004

typedef struct testparams_tag TESTPARAMS;


typedef DWORD (*PFTESTCASE)(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *lpbPassed);
/*++
	[IN]	pTestParams		Pointer to TESTPARAMS structure
	[IN]	lpctstrSection	The name of a section in inifile, that supplies additional per run information
	[OUT]	lpbPassed		Pointer to a boolean, that receives the result

	Return value:			Win32 error code
--*/


typedef struct testcase_tag {
	PFTESTCASE pftc;						// address of the function, implementing the testcase
	TCHAR szName[NAME_LENGTH + 1];			// test case name
} TESTCASE;


typedef struct testarea_tag {
	TCHAR	szName[NAME_LENGTH + 1];		// test area name
	const	TESTCASE	*ptc;				// array of testcases, implemented for the area
	DWORD	dwAvailableCases;				// number of test cases, implemented for the area
} TESTAREA;


typedef struct testsuite_tag {
	TCHAR szName[NAME_LENGTH + 1];			// test suite name
	const TESTAREA	**ppTestArea;			// array of pointers to test areas, implemented by the suite
	DWORD dwAvailableAreas;					// number of test areas, implemented by the suite
} TESTSUITE;


DWORD	InitSuiteLog			(LPCTSTR lpctstrSuiteName);
DWORD	EndSuiteLog				(void);
DWORD	RunSuite				(const TESTSUITE *pTestSuite, const TESTPARAMS *pTestParams, LPCTSTR lpctstrIniFile);
DWORD	ReadStructFromIniFile	(LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, LPCTSTR lpctstrIniFile, LPCTSTR lpctstrSection);
DWORD	ReadStructFromRegistry	(LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, HKEY hkRegKey);
DWORD	CompareStruct			(const LPVOID lpStruct1, const LPVOID lpStruct2, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, BOOL *lpbIdentical);
DWORD	LogStruct				(LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD MembersCount);
DWORD	FreeStruct				(const LPVOID lpStruct, const MEMBERDESCRIPTOR *pStructDesc, DWORD dwMembersCount, BOOL bStructItself);
DWORD	StrToMember				(LPVOID lpParam, LPCTSTR lpctstrStr, DWORD dwType);


#endif /* #ifndef __TESTSUITE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxapi\faxapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxapi.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#ifndef _FAXAPI_H
#define _FAXAPI_H

typedef struct _DLL_INTERFACE {
    HINSTANCE       hInstance;
    PFAXAPIDLLINIT  pFaxAPIDllInit;
    PFAXAPIDLLTEST  pFaxAPIDllTest;
} DLL_INTERFACE, *PDLL_INTERFACE;

// g_hHeap is a global handle to the process heap
HANDLE         g_hHeap = NULL;
// g_hLogFile is the handle to the log file
HANDLE         g_hLogFile = INVALID_HANDLE_VALUE;
// g_bVerbose indicates the verbose switch was found
BOOL           g_bVerbose = FALSE;
// g_ApiInterface is the API interface structure
API_INTERFACE  g_ApiInterface;

#define HELP_SWITCH_1   L"/?"
#define HELP_SWITCH_2   L"/H"
#define HELP_SWITCH_3   L"-?"
#define HELP_SWITCH_4   L"-H"
#define INIFILE_SWITCH  L"/I:"
#define LOGFILE_SWITCH  L"/L:"
#define SERVER_SWITCH   L"/S:"
#define VERBOSE_SWITCH  L"/V"

#define FAXAPI_INIFILE  L"faxapi.ini"
#define FAXAPI_LOGFILE  L"faxapi.log"

#define WINFAX_DLL      L"\\winfax.dll"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxapi\whisfaxapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

whisfaxapi.h

Abstract:

  This module contains some further definition for Whistler Fax

Author:

  Lior Shmueli (liors) 16/10/2000

--*/

#ifndef _WHISFAXAPI_H
#define _WHISFAXAPI_H

#define WHIS_REMOTE_SERVER_NAME  L"liors1"
#define WHIS_TITLE  L"Whistler Fax API Test"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxapi\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module:
    1) Displays a string in stdout
    2) Opens the log file
    3) Writes a string to the log file
    4) Writes a string to the log file
    5) Writes a string to the log file and stdout

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

#ifndef _UTIL_C
#define _UTIL_C

VOID
LocalEcho(
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Displays a string in stdout

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputBuffer is the output string
    WCHAR    szOutputBuffer[1024];

    // Initialize the buffer
    ZeroMemory(szOutputBuffer, sizeof(szOutputBuffer));

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(szOutputBuffer, sizeof(szOutputBuffer), szFormatString, varg_ptr);
    wprintf(L"%s\n", szOutputBuffer);
}

BOOL
fnOpenLogFile(
    LPCWSTR  szLogFile
)
/*++

Routine Description:

  Opens the log file

Arguments:

  szLogFile - log file name

Return Value:

  TRUE on success

--*/
{
    // cUnicodeBOM is the Unicode BOM
    WCHAR  cUnicodeBOM = 0xFEFF;
    DWORD  cb;

    // Create the new log file
    g_hLogFile = CreateFile(szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (g_hLogFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!WriteFile(g_hLogFile, &cUnicodeBOM, sizeof(WCHAR), &cb, NULL)) {
        return FALSE;
    }

    return TRUE;
}

VOID WINAPI
fnWriteLogFileW(
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Writes a string to the log file

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputString is the output string
    WCHAR    szOutputString[1024];
    DWORD    cb;

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(szOutputString, sizeof(szOutputString), szFormatString, varg_ptr);

    if (g_bVerbose) {
        LocalEcho(L"%s", szOutputString);
    }

    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        lstrcat(szOutputString, L"\r\n");
        WriteFile(g_hLogFile, szOutputString, lstrlen(szOutputString) * sizeof(WCHAR), &cb, NULL);
    }

}

VOID WINAPI
fnWriteLogFileA(
    LPSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Writes a string to the log file

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputString is the output string
    CHAR     szOutputString[1024];
    WCHAR    szOutputStringW[1024];
    DWORD    cb;

    va_start(varg_ptr, szFormatString);
    _vsnprintf(szOutputString, sizeof(szOutputString), szFormatString, varg_ptr);

    MultiByteToWideChar(CP_ACP, 0, szOutputString, -1, szOutputStringW, sizeof(szOutputStringW) / sizeof(WCHAR));

    fnWriteLogFileW(L"%s", szOutputStringW);
}

VOID
fnWriteAndEcho(
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Writes a string to the log file and stdout

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputString is the output string
    WCHAR    szOutputString[1024];
    DWORD    cb;

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(szOutputString, sizeof(szOutputString), szFormatString, varg_ptr);

    LocalEcho(L"%s", szOutputString);

    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        lstrcat(szOutputString, L"\r\n");
        WriteFile(g_hLogFile, szOutputString, lstrlen(szOutputString) * sizeof(WCHAR), &cb, NULL);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\jobsapi\jobsapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  jobsapi.c

Abstract:

  JobsApi: Fax API Test Dll: Client Job APIs
    1) FaxEnumJobs()
    2) FaxGetJob()
    3) FaxSetJob()
    4) FaxAbort()
    5) FaxGetPageData()

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#include <wtypes.h>
#include <tchar.h>


#include "dllapi.h"

// g_hHeap is the handle to the heap
HANDLE           g_hHeap = NULL;
// g_ApiInterface is the API_INTERFACE structure
API_INTERFACE    g_ApiInterface;
// fnWriteLogFile is the pointer to the function to write a string to the log file
PFNWRITELOGFILE  fnWriteLogFile = NULL;

// whistler phone number
//LPCTSTR  g_szWhisPhoneNumber;
LPCTSTR		    g_szWhisPhoneNumber=NULL;
TCHAR			g_szWhisPhoneNumberVar1[MAX_PATH];
TCHAR			g_szWhisPhoneNumberVar2[MAX_PATH];
TCHAR			g_szWhisPhoneNumberVar3[MAX_PATH];

DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

VOID WINAPI
FaxAPIDllInit(
    HANDLE            hHeap,
    API_INTERFACE     ApiInterface,
    PFNWRITELOGFILEW  pfnWriteLogFileW,
    PFNWRITELOGFILEA  pfnWriteLogFileA
)
{
    // Set g_hHeap
    g_hHeap = hHeap;
    // Set g_ApiInterface
    g_ApiInterface = ApiInterface;
#ifdef UNICODE
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileW;
#else
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileA;
#endif

    return;
}

VOID
fnFaxEnumJobs(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxEnumJobs()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // pFaxJobs is the pointer to the fax jobs
    PFAX_JOB_ENTRY      pFaxJobs;
    // dwNumJobs1 is the number of fax jobs
    DWORD               dwNumJobs;
    // FaxJobParam1 is the first fax job params
    FAX_JOB_PARAM       FaxJobParam1;
    // FaxJobParam2 is the second fax job params
    FAX_JOB_PARAM       FaxJobParam2;
    // FaxJobParam3 is the second fax job params
    FAX_JOB_PARAM       FaxJobParam3;
    // dwFaxId1 is the first fax job id
    DWORD               dwFaxId1;
    // dwFaxId2 is the second fax job id
    DWORD               dwFaxId2;
    // dwFaxId3 is the third fax job id
    DWORD               dwFaxId3;

    DWORD               dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxEnumJobs().\r\n"));

    ZeroMemory(&FaxJobParam1, sizeof(FAX_JOB_PARAM));
    FaxJobParam1.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam1.RecipientNumber = g_szWhisPhoneNumberVar1;
    FaxJobParam1.ScheduleAction = JSA_NOW;

    ZeroMemory(&FaxJobParam2, sizeof(FAX_JOB_PARAM));
    FaxJobParam2.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam2.RecipientNumber = g_szWhisPhoneNumberVar2;
    FaxJobParam2.ScheduleAction = JSA_SPECIFIC_TIME;
    GetSystemTime(&FaxJobParam2.ScheduleTime);

    ZeroMemory(&FaxJobParam3, sizeof(FAX_JOB_PARAM));
    FaxJobParam3.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam3.RecipientNumber = g_szWhisPhoneNumberVar3;
    FaxJobParam3.ScheduleAction = JSA_DISCOUNT_PERIOD;

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Can not connect to fax server %s, The error code is 0x%08x.\r\n"), szServerName,GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s\r\n"), szServerName);
	}

    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> Can not GET configuration from %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Can not SET configuration in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Enumerate the jobs
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, &pFaxJobs, &dwNumJobs)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() failed.  The error code is 0x%08x.  This is an error.  FaxEnumJobs() should succeed.\r\n"), GetLastError());
    }
    else {
        if (pFaxJobs == NULL) {
            fnWriteLogFile(TEXT("pFaxJobs is NULL.  This is an error.  pFaxJobs should not be NULL.\r\n"));
        }

        if (dwNumJobs != 0) {
            fnWriteLogFile(TEXT("dwNumJobs is %d.  This is an error.  dwNumJobs should be 0.\r\n"), dwNumJobs);
        }

        if ((pFaxJobs != NULL) && (dwNumJobs == 0)) {
			
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }

        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam1, NULL, &dwFaxId1)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam2, NULL, &dwFaxId2)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId1);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam3, NULL, &dwFaxId3)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId1);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId2);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Enumerate the jobs
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, &pFaxJobs, &dwNumJobs)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() failed.  The error code is 0x%08x.  This is an error.  FaxEnumJobs() should succeed.\r\n"), GetLastError());
    }
    else {
        if (pFaxJobs == NULL) {
            fnWriteLogFile(TEXT("pFaxJobs is NULL.  This is an error.  pFaxJobs should not be NULL.\r\n"));
        }

        if (dwNumJobs != 3) {
            fnWriteLogFile(TEXT("dwNumJobs is %d.  This is an error.  dwNumJobs should be 3.\r\n"), dwNumJobs);
        }

        if ((pFaxJobs != NULL) && (dwNumJobs == 3)) {
            for (dwIndex = 0; dwIndex < dwNumJobs; dwIndex++) {
                if (pFaxJobs[dwIndex].SizeOfStruct != sizeof(FAX_JOB_ENTRY)) {
                    fnWriteLogFile(TEXT("SizeOfStruct: Received: %d, Expected: %d.\r\n"), pFaxJobs[dwIndex].SizeOfStruct, sizeof(FAX_JOB_ENTRY));
                    goto FuncFailed;
                }
				fnWriteLogFile(TEXT("WHIS> (not error message) JobType: Received: %d, Expected: (JT_SEND) %d.\r\n"), pFaxJobs[dwIndex].JobType, JT_SEND);
                if (pFaxJobs[dwIndex].JobType != JT_SEND) {
                    fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JT_SEND) %d.\r\n"), pFaxJobs[dwIndex].JobType, JT_SEND);
                    goto FuncFailed;
                }

                if (pFaxJobs[dwIndex].QueueStatus != JS_PENDING) {
                    fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JS_PENDING) %d.\r\n"), pFaxJobs[dwIndex].QueueStatus, JS_PENDING);
                    goto FuncFailed;
                }

                if (pFaxJobs[dwIndex].JobId == dwFaxId1) {
                    if (lstrcmp(pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar1)) {
                        fnWriteLogFile(TEXT("RecipientNumber: Received: %s, Expected: %s.\r\n"), pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar1);
                        goto FuncFailed;
                    }

                    if (pFaxJobs[dwIndex].ScheduleAction != JSA_NOW) {
                        fnWriteLogFile(TEXT("ScheduleAction: Received: %s, Expected: (JSA_NOW) %s.\r\n"), pFaxJobs[dwIndex].ScheduleAction, JSA_NOW);
                        goto FuncFailed;
                    }
                }
                else if (pFaxJobs[dwIndex].JobId == dwFaxId2) {
                    if (lstrcmp(pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar2)) {
                        fnWriteLogFile(TEXT("RecipientNumber: Received: %s, Expected: %s.\r\n"), pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar2);
                        goto FuncFailed;
                    }

                    if (pFaxJobs[dwIndex].ScheduleAction != JSA_SPECIFIC_TIME) {
                        fnWriteLogFile(TEXT("ScheduleAction: Received: %s, Expected: (JSA_SPECIFIC_TIME) %s.\r\n"), pFaxJobs[dwIndex].ScheduleAction, JSA_SPECIFIC_TIME);
                        goto FuncFailed;
                    }
                }
                else if (pFaxJobs[dwIndex].JobId == dwFaxId3) {
                    if (lstrcmp(pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar3)) {
                        fnWriteLogFile(TEXT("RecipientNumber: Received: %s, Expected: %s.\r\n"), pFaxJobs[dwIndex].RecipientNumber, g_szWhisPhoneNumberVar1);
                        goto FuncFailed;
                    }

                    if (pFaxJobs[dwIndex].ScheduleAction != JSA_DISCOUNT_PERIOD) {
                        fnWriteLogFile(TEXT("ScheduleAction: Received: %s, Expected: (JSA_DISCOUNT_PERIOD) %s.\r\n"), pFaxJobs[dwIndex].ScheduleAction, JSA_DISCOUNT_PERIOD);
                        goto FuncFailed;
                    }
                }
                else {
                    fnWriteLogFile(TEXT("Unknown job id: %d.\r\n"), pFaxJobs[dwIndex].JobId);
                    goto FuncFailed;
                }
            }

            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }

FuncFailed:
        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxEnumJobs(NULL, &pFaxJobs, &dwNumJobs)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() returned TRUE.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxJobs = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, NULL, &dwNumJobs)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() returned TRUE.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwNumJobs = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, &pFaxJobs, NULL)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() returned TRUE.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId2);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId3);

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, &pFaxJobs, &dwNumJobs)) {
        fnWriteLogFile(TEXT("FaxEnumJobs() returned TRUE.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxJobs);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxEnumJobs() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxEnumJobs(hFaxSvcHandle, &pFaxJobs, &dwNumJobs)) {
            //fnWriteLogFile(TEXT("FaxEnumJobs() failed.  The error code is 0x%08x.  This is an error.  FaxEnumJobs() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //g_ApiInterface.FaxFreeBuffer(pFaxJobs);
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxEnumJobs, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxGetJob(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxGetJob()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // pFaxJob is the pointer to the fax job
    PFAX_JOB_ENTRY      pFaxJob;
    // FaxJobParam is the fax job params
    FAX_JOB_PARAM       FaxJobParam;
    // dwFaxId is the fax job id
    DWORD               dwFaxId;

    DWORD               dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxGetJob().\r\n"));

    ZeroMemory(&FaxJobParam, sizeof(FAX_JOB_PARAM));
    FaxJobParam.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam.RecipientNumber = g_szWhisPhoneNumber;

	fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);





    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Can not connect to fax server %s, The error code is 0x%08x.\r\n"), szServerName,GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s\r\n"), szServerName);
	}


    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> Can not GET configuration from %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Can not SET configuration in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
		fnWriteLogFile(TEXT("WHIS> Can not send test document in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Get the job
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob)) {
            fnWriteLogFile(TEXT("FaxGetJob() failed.  The error code is 0x%08x.  This is an error.  FaxGetJob() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxJob == NULL) {
                fnWriteLogFile(TEXT("pFaxJob is NULL.  This is an error.  pFaxJob should not be NULL.\r\n"));
            }
            else {
                if (pFaxJob->SizeOfStruct != sizeof(FAX_JOB_ENTRY)) {
                    fnWriteLogFile(TEXT("SizeOfStruct: Received: %d, Expected: %d.\r\n"), pFaxJob->SizeOfStruct, sizeof(FAX_JOB_ENTRY));
                    goto FuncFailed;
                }

                if (pFaxJob->JobType != JT_SEND) {
                    fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JT_SEND) %d.\r\n"), pFaxJob->JobType, JT_SEND);
                    goto FuncFailed;
                }

                if (pFaxJob->QueueStatus != JS_PENDING) {
                    fnWriteLogFile(TEXT("Queue status: Received: %d, Expected: (JS_PENDING) %d.\r\n"), pFaxJob->QueueStatus, JS_PENDING);
                    goto FuncFailed;
                }

                if (pFaxJob->JobId != dwFaxId) {
                    fnWriteLogFile(TEXT("JobId: Received: %d, Expected: %d.\r\n"), pFaxJob->JobId, dwFaxId);
                    goto FuncFailed;
                }

                if (lstrcmp(pFaxJob->RecipientNumber, g_szWhisPhoneNumber)) {
                    fnWriteLogFile(TEXT("RecipientNumber: Received: %s, Expected: %s.\r\n"), pFaxJob->RecipientNumber, g_szWhisPhoneNumber);
                    goto FuncFailed;
                }

                if (pFaxJob->ScheduleAction != JSA_NOW) {
                    fnWriteLogFile(TEXT("ScheduleAction: Received: %s, Expected: (JSA_NOW) %s.\r\n"), pFaxJob->ScheduleAction, JSA_NOW);
                    goto FuncFailed;
                }

                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
            }

FuncFailed:
            g_ApiInterface.FaxFreeBuffer(pFaxJob);
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetJob(NULL, dwFaxId, &pFaxJob)) {
        fnWriteLogFile(TEXT("FaxGetJob() returned TRUE.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxJob);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid dwFaxId.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetJob(hFaxSvcHandle, -1, NULL)) {
        fnWriteLogFile(TEXT("FaxGetJob() returned TRUE.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxJob);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxJob = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, NULL)) {
        fnWriteLogFile(TEXT("FaxGetJob() returned TRUE.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pFaxJob);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob)) {
        fnWriteLogFile(TEXT("FaxGetJob() returned TRUE.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pFaxJob);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //pFaxConfig->PauseServerQueue = TRUE;

        //if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
          //  g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Send a document
        //if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
          //  pFaxConfig->PauseServerQueue = FALSE;
            //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
            //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
//            g_ApiInterface.FaxClose(hFaxSvcHandle);
  //          return;
    //    }

      //  (*pnNumCasesAttempted)++;
//		dwFuncCasesAtt++;

  //      fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob)) {
            //fnWriteLogFile(TEXT("FaxGetJob() failed.  The error code is 0x%08x.  This is an error.  FaxGetJob() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  g_ApiInterface.FaxFreeBuffer(pFaxJob);
//            (*pnNumCasesPassed)++;
//			dwFuncCasesPass++;
  //      }

    //    pFaxConfig->PauseServerQueue = FALSE;
      //  g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxGetJob, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxSetJob(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits
)
/*++

Routine Description:

  FaxSetJob()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // pFaxJob1 is the pointer to the fax job
    PFAX_JOB_ENTRY      pFaxJob1;
    // pFaxJob2 is the pointer to the fax job
    PFAX_JOB_ENTRY      pFaxJob2;
    // FaxJobParam is the fax job params
    FAX_JOB_PARAM       FaxJobParam;
    // dwFaxId is the fax job id
    DWORD               dwFaxId;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxSetJob().\r\n"));

    ZeroMemory(&FaxJobParam, sizeof(FAX_JOB_PARAM));
    FaxJobParam.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam.RecipientNumber = g_szWhisPhoneNumber;
	
	fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Can not connect to fax server %s, The error code is 0x%08x.\r\n"), szServerName,GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s\r\n"), szServerName);
	}

    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> Can not GET configuration from %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Can not SET configuration in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }
    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
		fnWriteLogFile(TEXT("WHIS> Can not send test document in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Set the job
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (JC_PAUSE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_PAUSE, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
    }
	
    else {
	
        // Get the job
        if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob2)) {
            fnWriteLogFile(TEXT("FaxGetJob() failed.  The error code is 0x%08x.  This is an error.  FaxGetJob() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxJob2->QueueStatus != JS_PAUSED) {
                fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JS_PAUSED) %d.\r\n"), pFaxJob2->QueueStatus, JS_PAUSED);
            }
            else {
                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
            }

            g_ApiInterface.FaxFreeBuffer(pFaxJob2);
        }
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Set the job
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (JC_RESUME).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESUME, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
    }
    else {
        // Get the job
        if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob2)) {
            fnWriteLogFile(TEXT("FaxGetJob() failed.  The error code is 0x%08x.  This is an error.  FaxGetJob() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxJob2->QueueStatus != JS_PENDING) {
                fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JS_PENDING) %d.\r\n"), pFaxJob2->QueueStatus, JS_PENDING);
            }
            else {
                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
            }

            g_ApiInterface.FaxFreeBuffer(pFaxJob2);
        }
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Set the job
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (JC_RESTART).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESTART, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
    }
    else {
        // Get the job
        if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob2)) {
            fnWriteLogFile(TEXT("FaxGetJob() failed.  The error code is 0x%08x.  This is an error.  FaxGetJob() should succeed.\r\n"), GetLastError());
        }
        else {
            if (pFaxJob2->QueueStatus != JS_PENDING) {
                fnWriteLogFile(TEXT("JobType: Received: %d, Expected: (JS_RESTART) %d.\r\n"), pFaxJob2->QueueStatus, JS_PENDING);
            }
            else {
                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
            }

            g_ApiInterface.FaxFreeBuffer(pFaxJob2);
        }
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Set the job
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (JC_DELETE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_DELETE, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
    }
    else {
        if (g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob2)) {
            fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE.\r\n"));
            g_ApiInterface.FaxFreeBuffer(pFaxJob2);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }



	
  
	// Set the job (limit testing)
	if (bTestLimits)	{
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;
		fnWriteLogFile(TEXT("Invalid Case (MAX_DWORD).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, MAX_DWORD, pFaxJob1)) {
			fnWriteLogFile(TEXT("WHIS> FaxSetJob() succeeded, the is an error, FaxSetJob should fail and the error should be ERROR_INVALID_PARAMETER .\r\n"));
		}
		else {
			if (GetLastError() != ERROR_INVALID_PARAMETER) {
				fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
			}
			else {
				(*pnNumCasesPassed)++;
				dwFuncCasesPass++;
			}
        }
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);
    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Get the job
    if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }





    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetJob(NULL, dwFaxId, JC_RESTART, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid dwFaxId.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetJob(hFaxSvcHandle, -1, JC_RESTART, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid dwCommand.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, -1, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pFaxJob = NULL.  (This will fail on whistler, see RAID 10909) Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESTART, NULL)) {
        fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESTART, pFaxJob1)) {
        fnWriteLogFile(TEXT("FaxSetJob() returned TRUE.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSetJob() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxFreeBuffer(pFaxJob1);

//    if (szServerName) {

//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));

        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
          //  // Disconnect from the fax server
//            g_ApiInterface.FaxClose(hFaxSvcHandle);
  //          return;
    //    }

      //  pFaxConfig->PauseServerQueue = TRUE;

//        if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
  //          g_ApiInterface.FaxFreeBuffer(pFaxConfig);
    //        // Disconnect from the fax server
      //      g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Send a document
        //if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
          //  pFaxConfig->PauseServerQueue = FALSE;
            //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
            //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
//            g_ApiInterface.FaxClose(hFaxSvcHandle);
  //          return;
    //    }

        // Get the job
      //  if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
        //    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

          //  pFaxConfig->PauseServerQueue = FALSE;
//            g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
  //          g_ApiInterface.FaxFreeBuffer(pFaxConfig);
//
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

        // Set the job
//        (*pnNumCasesAttempted)++;
//		dwFuncCasesAtt++;

  //      fnWriteLogFile(TEXT("Remote hFaxSvcHandle (JC_PAUSE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    //    if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_PAUSE, pFaxJob1)) {
      //      fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
//        }
  //      else {
    //        (*pnNumCasesPassed)++;
	//		dwFuncCasesPass++;
      //  }

        //g_ApiInterface.FaxFreeBuffer(pFaxJob1);
        //g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        // Send a document
        //if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
          //  pFaxConfig->PauseServerQueue = FALSE;
            //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
            //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Get the job
        //if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
          //  g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
//
  //          pFaxConfig->PauseServerQueue = FALSE;
    //        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
      //      g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
        //    g_ApiInterface.FaxClose(hFaxSvcHandle);
          //  return;
        //}

        // Set the job
        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle (JC_RESUME).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESUME, pFaxJob1)) {
          //  fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  (*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //g_ApiInterface.FaxFreeBuffer(pFaxJob1);
        //g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        // Send a document
//        if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
  //          pFaxConfig->PauseServerQueue = FALSE;
    //        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
      //      g_ApiInterface.FaxFreeBuffer(pFaxConfig);
//
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

        // Get the job
        //if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
          //  g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

            //pFaxConfig->PauseServerQueue = FALSE;
            //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
            //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
//            g_ApiInterface.FaxClose(hFaxSvcHandle);
  //          return;
        //}

        // Set the job
        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle (JC_RESTART).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_RESTART, pFaxJob1)) {
            //fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //g_ApiInterface.FaxFreeBuffer(pFaxJob1);
        //g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        // Send a document
//        if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
  //          pFaxConfig->PauseServerQueue = FALSE;
    //        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
      //      g_ApiInterface.FaxFreeBuffer(pFaxConfig);
//
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

        // Get the job
        //if (!g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob1)) {
          //  g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

//            pFaxConfig->PauseServerQueue = FALSE;
  //          g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
 //        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
///
            // Disconnect from the fax server
   //         g_ApiInterface.FaxClose(hFaxSvcHandle);
     //       return;
       // }

        // Set the job
        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle (JC_DELETE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxSetJob(hFaxSvcHandle, dwFaxId, JC_DELETE, pFaxJob1)) {
            //fnWriteLogFile(TEXT("FaxSetJob() failed.  The error code is 0x%08x.  This is an error.  FaxSetJob() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  (*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //g_ApiInterface.FaxFreeBuffer(pFaxJob1);
        //g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

        //pFaxConfig->PauseServerQueue = FALSE;
        //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for fnFaxSetJob, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxAbort(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxAbort()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // pFaxJob is the pointer to the fax job
    PFAX_JOB_ENTRY      pFaxJob;
    // FaxJobParam is the fax job params
    FAX_JOB_PARAM       FaxJobParam;
    // dwFaxId is the fax job id
    DWORD               dwFaxId;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxAbort().\r\n"));

    ZeroMemory(&FaxJobParam, sizeof(FAX_JOB_PARAM));
    FaxJobParam.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam.RecipientNumber = g_szWhisPhoneNumber;

	fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);
	
    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Can not connect to fax server %s, The error code is 0x%08x.\r\n"), szServerName,GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s\r\n"), szServerName);
	}


    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> Can not GET configuration from %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Can not SET configuration in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
		fnWriteLogFile(TEXT("WHIS> Can not send test document in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Abort the job
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId)) {
        fnWriteLogFile(TEXT("FaxAbort() failed.  The error code is 0x%08x.  This is an error.  FaxAbort() should succeed.\r\n"), GetLastError());
    }
    else {
        if (g_ApiInterface.FaxGetJob(hFaxSvcHandle, dwFaxId, &pFaxJob)) {
            fnWriteLogFile(TEXT("FaxGetJob() returned TRUE.  This is an error.  FaxGetJob() should return FALSE.\r\n"));
            g_ApiInterface.FaxFreeBuffer(pFaxJob);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxAbort(NULL, dwFaxId)) {
        fnWriteLogFile(TEXT("FaxAbort() returned TRUE.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid dwFaxId.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxAbort(hFaxSvcHandle, -1)) {
        fnWriteLogFile(TEXT("FaxAbort() returned TRUE.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId)) {
        fnWriteLogFile(TEXT("FaxAbort() returned TRUE.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //pFaxConfig->PauseServerQueue = TRUE;

        //if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
          //  g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Send a document
        //if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
          //  pFaxConfig->PauseServerQueue = FALSE;
            //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
            //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Abort the job
        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

//        fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
  //      if (!g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId)) {
    //        fnWriteLogFile(TEXT("FaxAbort() failed.  The error code is 0x%08x.  This is an error.  FaxAbort() should succeed.\r\n"), GetLastError());
      //  }
        //else {
          //  (*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //pFaxConfig->PauseServerQueue = FALSE;
        //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxAbort, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxGetPageData(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxGetPageData()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // FaxJobParam is the fax job params
    FAX_JOB_PARAM       FaxJobParam;
    // dwFaxId is the fax job id
    DWORD               dwFaxId;
    // pPageDataBuffer is a pointer to the page data
    LPBYTE              pPageDataBuffer;
    // dwPageDataBufferSize is the size of the page data buffer
    DWORD               dwPageDataBufferSize;
    // dwImageWidth is the page data width
    DWORD               dwImageWidth;
    // dwImageHeight is the page data height
    DWORD               dwImageHeight;

    DWORD               dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxGetPageData().\r\n"));

    ZeroMemory(&FaxJobParam, sizeof(FAX_JOB_PARAM));
    FaxJobParam.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParam.RecipientNumber = g_szWhisPhoneNumber;

	fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> Can not connect to fax server %s, The error code is 0x%08x.\r\n"), szServerName,GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to %s\r\n"), szServerName);
	}


    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> Can not GET configuration from %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> Can not SET configuration in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    // Send a document
    if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
		fnWriteLogFile(TEXT("WHIS> Can not send test document in %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        pFaxConfig->PauseServerQueue = FALSE;
        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Get the page data
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        if (!g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
            fnWriteLogFile(TEXT("FaxGetPageData() failed.  The error code is 0x%08x.  This is an error.  FaxGetPageData() should succeed.\r\n"), GetLastError());
        }
        else {
            g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(NULL, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid dwFaxId.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, -1, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pPageDataBuffer = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, NULL, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwPageDataBufferSize = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, NULL, &dwImageWidth, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwImageWidth = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, NULL, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwImageHeight = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, NULL)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
        fnWriteLogFile(TEXT("FaxGetPageData() returned TRUE.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxGetPageData() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        //if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
//            return;
  //      }

    //    pFaxConfig->PauseServerQueue = TRUE;

      //  if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
        //    g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Send a document
//        if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
  //          pFaxConfig->PauseServerQueue = FALSE;
    //        g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
      //      g_ApiInterface.FaxFreeBuffer(pFaxConfig);
//
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

        // Get the page data
        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

//        fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
  //      if (!g_ApiInterface.FaxGetPageData(hFaxSvcHandle, dwFaxId, &pPageDataBuffer, &dwPageDataBufferSize, &dwImageWidth, &dwImageHeight)) {
    //       fnWriteLogFile(TEXT("FaxGetPageData() failed.  The error code is 0x%08x.  This is an error.  FaxGetPageData() should succeed.\r\n"), GetLastError());
     //   }
       // else {
         //   g_ApiInterface.FaxFreeBuffer(pPageDataBuffer);
           // (*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //pFaxConfig->PauseServerQueue = FALSE;
        //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);
//
        // Disconnect from the fax server
  //      g_ApiInterface.FaxClose(hFaxSvcHandle);
//    }
fnWriteLogFile(TEXT("$$$ Summery for FaxGetPageData, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}


//BOOL WINAPI
//FaxAPIDllWhisSetPhoneNumber(
//							LPCWSTR  szWhisPhoneNumberW,
//							LPCSTR   szWhisPhoneNumberA
//							)
//{

    
//#ifdef UNICODE
    //g_szWhisPhoneNumber = szWhisPhoneNumberW;
//#else
  //  g_szWhisPhoneNumber = szWhisPhoneNumberA;
//#endif
	
	
//	fnWriteLogFile(TEXT("WHIS> Whis Phone Number Recieved: %s\r\n"),g_szWhisPhoneNumber);
	//return TRUE;
//}
							



BOOL WINAPI
FaxAPIDllTest(
	LPCWSTR  szWhisPhoneNumberW,
	LPCSTR   szWhisPhoneNumberA,
	LPCWSTR  szServerNameW,
    LPCSTR   szServerNameA,
    UINT     nNumCasesLocal,
    UINT     nNumCasesServer,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	DWORD	 dwTestMode
)
{
    LPCTSTR  szServerName;
	UINT     nNumCases;

	// for Whis-extended only
#ifdef UNICODE
    if (lstrlen(szWhisPhoneNumberW)>0) { 
		g_szWhisPhoneNumber = szWhisPhoneNumberW; 
	}
	else {
		g_szWhisPhoneNumber=TEXT(WHIS_DEFAULT_PHONE_NUMBER);
	}
#else
	if (lstrlen(szWhisPhoneNumberA)>0) {
		g_szWhisPhoneNumber = szWhisPhoneNumberA;
	}
	else {
		g_szWhisPhoneNumber=TEXT(WHIS_DEFAULT_PHONE_NUMBER);
	}
#endif

	_tcscpy(g_szWhisPhoneNumberVar1,g_szWhisPhoneNumber);
	_tcscat(g_szWhisPhoneNumberVar1,TEXT("1"));

	_tcscpy(g_szWhisPhoneNumberVar2,g_szWhisPhoneNumber);
	_tcscat(g_szWhisPhoneNumberVar2,TEXT("2"));

	_tcscpy(g_szWhisPhoneNumberVar3,g_szWhisPhoneNumber);
	_tcscat(g_szWhisPhoneNumberVar3,TEXT("3"));



#ifdef UNICODE
    szServerName = szServerNameW;
#else
    szServerName = szServerNameA;
#endif

    if (szServerName) {
        nNumCases = nNumCasesServer;
		fnWriteLogFile(TEXT("WHIS> REMOTE SERVER MODE:\r\n"));
    }
    else {
        nNumCases = nNumCasesLocal;
    }

    // FaxEnumJobs()
    fnFaxEnumJobs(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    // FaxGetJob()
    fnFaxGetJob(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

  
	if (dwTestMode==WHIS_TEST_MODE_LIMITS)	{
		// FaxSetJob() limits
		fnFaxSetJob(szServerName, pnNumCasesAttempted, pnNumCasesPassed,TRUE);
	}
	else	{
		// FaxSetJob()
		fnFaxSetJob(szServerName, pnNumCasesAttempted, pnNumCasesPassed,FALSE);
	}


    // FaxAbort()
    fnFaxAbort(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    // FaxGetPageData()
    fnFaxGetPageData(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    if ((*pnNumCasesAttempted == nNumCases) && (*pnNumCasesPassed == *pnNumCasesAttempted)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\miscapi\miscapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  miscapi.c

Abstract:

  MiscApi: Fax API Test Dll: Client Misc APIs
    1) FaxConnectFaxServer()
    2) FaxFreeBuffer()
    3) FaxClose()

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/


/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#include <wtypes.h>

#include "dllapi.h"

// g_hHeap is the handle to the heap
HANDLE           g_hHeap = NULL;
// g_ApiInterface is the API_INTERFACE structure
API_INTERFACE    g_ApiInterface;
// fnWriteLogFile is the pointer to the function to write a string to the log file
PFNWRITELOGFILE  fnWriteLogFile = NULL;



DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

VOID WINAPI
FaxAPIDllInit(
    HANDLE            hHeap,
    API_INTERFACE     ApiInterface,
    PFNWRITELOGFILEW  pfnWriteLogFileW,
    PFNWRITELOGFILEA  pfnWriteLogFileA
)
{
    // Set g_hHeap
    g_hHeap = hHeap;
    // Set g_ApiInterface
    g_ApiInterface = ApiInterface;
#ifdef UNICODE
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileW;
#else
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileA;
#endif

    return;
}

VOID
fnFaxConnectFaxServer(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits
)
/*++

Routine Description:

  FaxConnectFaxServer()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE  hFaxSvcHandle;

    DWORD   dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxConnectFaxServer().\r\n"));

    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Connect to the fax server
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
            fnWriteLogFile(TEXT("FaxConnectFaxServer() failed.  The error code is 0x%08x.  This is an error.  FaxConnectFaxServer() should succeed.\r\n"), GetLastError());
        }
        else {
            if (hFaxSvcHandle == NULL) {
                fnWriteLogFile(TEXT("hFaxSvcHandle is NULL.  This is an error.  hFaxSvcHandle should not be NULL.\r\n"));
            }
            else {
                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
            }

            g_ApiInterface.FaxClose(hFaxSvcHandle);
        }
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxConnectFaxServer(NULL, NULL)) {
        fnWriteLogFile(TEXT("FaxConnectFaxServer() returned TRUE.  This is an error.  FaxConnectFaxServer() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxClose(hFaxSvcHandle);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxConnectFaxServer() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;

    }



	if (bTestLimits) {
	    (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

	    fnWriteLogFile(TEXT("ServerName=LONG_STRING  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		if (g_ApiInterface.FaxConnectFaxServer(TEXT(LONG_STRING), &hFaxSvcHandle)) {
			fnWriteLogFile(TEXT("FaxConnectFaxServer() returned TRUE.  This is an error.  FaxConnectFaxServer() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
			g_ApiInterface.FaxClose(hFaxSvcHandle);
		}
		else 	{
			if (GetLastError() != ERROR_INVALID_PARAMETER) {
				fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxConnectFaxServer() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
			}
			else	{
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			}
		}
        
    }

//	if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      (*pnNumCasesAttempted)++;
	//	dwFuncCasesAtt++;

      //  fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
          //  fnWriteLogFile(TEXT("FaxConnectFaxServer() failed.  The error code is 0x%08x.  This is an error.  FaxConnectFaxServer() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  (*pnNumCasesPassed)++;
//			dwFuncCasesPass++;

  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //    }
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxConnectFaxServer, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxFreeBuffer(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxFreeBuffer()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxFreeBuffer().\r\n"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not GET configuration, The error code is 0x%08x.\r\n"), GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);
    (*pnNumCasesPassed)++;
	dwFuncCasesPass++;

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);
fnWriteLogFile(TEXT("$$$ Summery for FaxFreeBuffer, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}

VOID
fnFaxClose(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxClose()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE          hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE          hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO  pFaxPortInfo;
    // dwNumPorts is the number of fax ports
    DWORD           dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD           dwDeviceId;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxClose().\r\n"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}


    // Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not enum ports on %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    dwDeviceId = pFaxPortInfo[0].DeviceId;

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        return;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (Port Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxClose(hFaxPortHandle)) {
        fnWriteLogFile(TEXT("FaxClose() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid Handle (Port Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxClose(hFaxPortHandle)) {
        fnWriteLogFile(TEXT("FaxClose() returned TRUE.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (Service Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (!g_ApiInterface.FaxClose(hFaxSvcHandle)) {
        fnWriteLogFile(TEXT("FaxClose() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid Handle (Service Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxClose(hFaxSvcHandle)) {
        fnWriteLogFile(TEXT("FaxClose() returned TRUE.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("NULL Handle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
    if (g_ApiInterface.FaxClose(NULL)) {
        fnWriteLogFile(TEXT("FaxClose() returned TRUE.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        // Enumerate the fax ports
//        if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

//        dwDeviceId = pFaxPortInfo[0].DeviceId;

        // Free the fax port info
  //      g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    //    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
            // Disconnect from the fax server
      //      g_ApiInterface.FaxClose(hFaxSvcHandle);
        //    return;
        //}

        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Valid Case (Port Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxClose(hFaxPortHandle)) {
            //fnWriteLogFile(TEXT("FaxClose() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Invalid Handle (Port Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (g_ApiInterface.FaxClose(hFaxPortHandle)) {
            //fnWriteLogFile(TEXT("FaxClose() returned TRUE.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        //}
        //else if (GetLastError() != ERROR_INVALID_HANDLE) {
          //  fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
        //}
        //else {
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Valid Case (Service Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxClose(hFaxSvcHandle)) {
          //  fnWriteLogFile(TEXT("FaxClose() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}

        //(*pnNumCasesAttempted)++;
		//dwFuncCasesAtt++;

        //fnWriteLogFile(TEXT("Invalid Handle (Service Handle).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (g_ApiInterface.FaxClose(hFaxSvcHandle)) {
            //fnWriteLogFile(TEXT("FaxClose() returned TRUE.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_HANDLE);
        //}
        //else if (GetLastError() != ERROR_INVALID_HANDLE) {
            //fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxClose() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
        //}
        //else {
            //(*pnNumCasesPassed)++;
			//dwFuncCasesPass++;
        //}
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxClose, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}




VOID
fnFaxCompleteJobParams(
	LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits,
	BOOL	 bDoW2KFails
)
{
   // hFaxSvcHandle is the handle to the fax server
    HANDLE          hFaxSvcHandle;
 	
	// return value
	BOOL			bRetVal;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	int				i;

	// Complate job params structures
	PFAX_JOB_PARAM pJobParam;
	PFAX_COVERPAGE_INFO pCoverpageInfo;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxCompleteJobParams().\r\n"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	
	
	bRetVal=g_ApiInterface.FaxCompleteJobParams(&pJobParam,&pCoverpageInfo);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxCompleteJobParmas() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		 (*pnNumCasesPassed)++;
		 dwFuncCasesPass++;
    }
	
	fnWriteLogFile(TEXT("pJobParam-> Values...\r\n"));
	fnWriteLogFile(TEXT("SizeOfStruct: %d.\r\n"),pJobParam->SizeOfStruct);
    fnWriteLogFile(TEXT("RecipientNumber: %s.\r\n"),pJobParam->RecipientNumber);
	fnWriteLogFile(TEXT("RecipientName: %s.\r\n"),pJobParam->RecipientName);
	fnWriteLogFile(TEXT("Tsid: %s.\r\n"),pJobParam->Tsid);
	fnWriteLogFile(TEXT("SenderName: %s.\r\n"),pJobParam->SenderName);
	fnWriteLogFile(TEXT("SenderCompany: %s.\r\n"),pJobParam->SenderCompany);
	fnWriteLogFile(TEXT("SenderDept: %s.\r\n"),pJobParam->SenderDept);
	fnWriteLogFile(TEXT("BillingCode: %s.\r\n"),pJobParam->BillingCode);
	fnWriteLogFile(TEXT("ScheduleAction: %d.\r\n"),pJobParam->ScheduleAction);
	fnWriteLogFile(TEXT("ScheduleTime: %d.\r\n"),pJobParam->ScheduleTime);
	fnWriteLogFile(TEXT("DeliveryReportType: %d.\r\n"),pJobParam->DeliveryReportType);
	fnWriteLogFile(TEXT("DeliveryReportAddress: %s.\r\n"),pJobParam->DeliveryReportAddress);
	fnWriteLogFile(TEXT("DocumentName: %s.\r\n"),pJobParam->DocumentName);	
	for (i=0;i<3;i++)	{
		fnWriteLogFile(TEXT("Reserved[%d]: %d.\r\n"),i,pJobParam->Reserved[i]);
	}

	fnWriteLogFile(TEXT("pCoverpageInfo-> Values...\r\n"));
	fnWriteLogFile(TEXT("SizeOfStruct: %d.\r\n"),pCoverpageInfo->SizeOfStruct);
	fnWriteLogFile(TEXT("CoverPageName: %s.\r\n"),pCoverpageInfo->CoverPageName);      
	fnWriteLogFile(TEXT("UseServerCoverPage: %d.\r\n"),pCoverpageInfo->UseServerCoverPage);
  
    fnWriteLogFile(TEXT("RecName: %s.\r\n"),pCoverpageInfo->RecName);
	fnWriteLogFile(TEXT("RecFaxNumber: %s.\r\n"),pCoverpageInfo->RecFaxNumber);
	fnWriteLogFile(TEXT("RecCompany: %s.\r\n"),pCoverpageInfo->RecCompany);
	fnWriteLogFile(TEXT("RecStreetAddress: %s.\r\n"),pCoverpageInfo->RecStreetAddress);
	fnWriteLogFile(TEXT("RecCity: %s.\r\n"),pCoverpageInfo->RecCity);
	fnWriteLogFile(TEXT("RecState: %s.\r\n"),pCoverpageInfo->RecState);
	fnWriteLogFile(TEXT("RecZip: %s.\r\n"),pCoverpageInfo->RecZip);
	fnWriteLogFile(TEXT("RecCountry: %s.\r\n"),pCoverpageInfo->RecCountry);
	fnWriteLogFile(TEXT("RecTitle: %s.\r\n"),pCoverpageInfo->RecTitle);
	fnWriteLogFile(TEXT("RecDepartment: %s.\r\n"),pCoverpageInfo->RecDepartment);
	fnWriteLogFile(TEXT("RecOfficeLocation: %s.\r\n"),pCoverpageInfo->RecOfficeLocation);
	fnWriteLogFile(TEXT("RecHomePhone: %s.\r\n"),pCoverpageInfo->RecHomePhone);
	fnWriteLogFile(TEXT("RecOfficePhone: %s.\r\n"),pCoverpageInfo->RecOfficePhone);
	  
  
	fnWriteLogFile(TEXT("SdrName: %s.\r\n"),pCoverpageInfo->SdrName);
	fnWriteLogFile(TEXT("SdrFaxNumber: %s.\r\n"),pCoverpageInfo->SdrFaxNumber);
	fnWriteLogFile(TEXT("SdrCompany: %s.\r\n"),pCoverpageInfo->SdrCompany);
	fnWriteLogFile(TEXT("SdrAddress: %s.\r\n"),pCoverpageInfo->SdrAddress);
	fnWriteLogFile(TEXT("SdrTitle: %s.\r\n"),pCoverpageInfo->SdrTitle);
	fnWriteLogFile(TEXT("SdrDepartment: %s.\r\n"),pCoverpageInfo->SdrDepartment);
	fnWriteLogFile(TEXT("SdrOfficeLocation: %s.\r\n"),pCoverpageInfo->SdrOfficeLocation);
	fnWriteLogFile(TEXT("SdrHomePhone: %s.\r\n"),pCoverpageInfo->SdrHomePhone);
	fnWriteLogFile(TEXT("SdrOfficePhone: %s.\r\n"),pCoverpageInfo->SdrOfficePhone);
	  
  
	fnWriteLogFile(TEXT("Note: %s.\r\n"),pCoverpageInfo->Note);
	fnWriteLogFile(TEXT("Subject: %s.\r\n"),pCoverpageInfo->Subject);
	fnWriteLogFile(TEXT("TimeSent: %s.\r\n"),pCoverpageInfo->TimeSent);
	fnWriteLogFile(TEXT("PageCount: %s.\r\n"),pCoverpageInfo->PageCount);

	g_ApiInterface.FaxFreeBuffer(pCoverpageInfo);
	g_ApiInterface.FaxFreeBuffer(pJobParam);

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	fnWriteLogFile(TEXT("pCoverpageInfo = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	if (g_ApiInterface.FaxCompleteJobParams(&pJobParam,NULL)) {
			fnWriteLogFile(TEXT("axCompleteJobParams() returned TRUE.  This is an error.  axCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
			g_ApiInterface.FaxFreeBuffer(pJobParam);
	}
	else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("axCompleteJobParams() returned 0x%08x.  This is an error.  axCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	}
	else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	}

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	fnWriteLogFile(TEXT("pJobParam = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	if (g_ApiInterface.FaxCompleteJobParams(NULL,&pCoverpageInfo)) {
			fnWriteLogFile(TEXT("axCompleteJobParams() returned TRUE.  This is an error. axCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
			g_ApiInterface.FaxFreeBuffer(pCoverpageInfo);
	}
	else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("axCompleteJobParams() returned 0x%08x.  This is an error.  axCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	}
	else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	}

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	fnWriteLogFile(TEXT("pCoverpageInfo = NULL & pJobParam = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	if (g_ApiInterface.FaxCompleteJobParams(NULL,NULL)) {
			fnWriteLogFile(TEXT("FaxCompleteJobParams() returned TRUE.  This is an error.  FaxCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), ERROR_INVALID_PARAMETER);
	}
	else if (GetLastError() != ERROR_INVALID_PARAMETER) {
	        fnWriteLogFile(TEXT("FaxCompleteJobParams() returned 0x%08x.  This is an error.  FaxCompleteJobParams() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
	}
	else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
	}

fnWriteLogFile(TEXT("$$$ Summery for FaxCompleteJobParams, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
}





VOID
fnFaxAccessCheck(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits,
	BOOL	 bDoW2KFails
)
/*++

Routine Description:

  FaxClose()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE          hFaxSvcHandle;
 	// return value
	BOOL			bRetVal;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;


	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxAccessCheck().\r\n"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_READ).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_READ);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_WRITE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_WRITE);
    if (!bRetVal) {
		fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_ALL_ACCESS).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_ALL_ACCESS);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_CONFIG_QUERY).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_CONFIG_QUERY);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_CONFIG_SET).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_CONFIG_SET);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_JOB_MANAGE).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_JOB_MANAGE);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_JOB_QUERY).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_JOB_QUERY);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_JOB_SUBMIT).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hFaxSvcHandle,FAX_JOB_SUBMIT);
    if (!bRetVal) {
        fnWriteLogFile(TEXT("FaxAccessCheck() failed.  The error code is 0x%08x.  This is an error.  FaxClose() should succeed.\r\n"), GetLastError());
    }
    else {
		fnWriteLogFile(TEXT("FaxAccessCheck() returned %d, GetLastError() is 0x%08x.  \r\n"),bRetVal, GetLastError());
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    }

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case (FAX_PORT_QUERY).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	bRetVal=g_ApiInterface.FaxAccessCheck(hF