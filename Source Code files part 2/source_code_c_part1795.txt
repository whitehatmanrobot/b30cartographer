    dwDefDeviceId = GetWaveOutID();

    if (dwDeviceId != dwDefDeviceId) ShowWindow (GetDlgItem(hDlg, IDB_EFFECT_PLAY), SW_HIDE);
	
    if (gAudData.fRecord)
            dwType = GFXTYPE_CAPTURE;
    else
            dwType = GFXTYPE_RENDER;

    if (mixerGetID(HMIXEROBJ_INDEX(dwDeviceId), &uMixId, gAudData.fRecord ? MIXER_OBJECTF_WAVEIN : MIXER_OBJECTF_WAVEOUT)) uMixId = (-1);

    hr = GFXUI_CreateList(uMixId, dwType, FALSE, &pRetList);

    if (SUCCEEDED (hr))
    {
        ASSERT(pRetList);
        gpGfxInitList = pRetList;
        pTempGFX = gpGfxInitList->puiList;
    }

    if(SUCCEEDED (hr) && pTempGFX)
    {
		dwIndex  = GetListIndex(pTempGFX);
        SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_SETCURSEL, dwIndex, 0);
    } else {        
        SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_SETCURSEL,0,0);
    }

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

}


/***************************************************************
 * LoadEffectList
 *
 * Description:
 *      Adds all the effects to the Combobox, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    
 *      None
 *
 ***************************************************************/

void LoadEffectList(HWND hDlg)
{
    int     nItemNum = 0;
    TCHAR   szBuffer[MAX_PATH];
    DWORD   dwType = 0;
    DWORD   dwWaveId = 0;
    UINT    uMixId;
    PGFXUI  pList = NULL;
    HRESULT hr;
	
    SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_RESETCONTENT,0,0);

    LoadString (ghInstance, IDS_NOGFXSET, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
    SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) szBuffer);

    if (gAudData.fRecord)
        dwType = GFXTYPE_CAPTURE;
    else
        dwType = GFXTYPE_RENDER;

    dwWaveId = gAudData.waveId;

    if (mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, gAudData.fRecord ? MIXER_OBJECTF_WAVEIN : MIXER_OBJECTF_WAVEOUT)) uMixId = (-1);

    hr = GFXUI_CreateList(uMixId, dwType, TRUE, &gpFullList);

    if (SUCCEEDED (hr))
    {
        ASSERT(gpFullList);
        pList = gpFullList->puiList;
    }

    if(SUCCEEDED (hr) && pList)
    {
        do
        {
            SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pList->pszName);
            gpGfxNodeArray[nItemNum] = pList;
            nItemNum++;

            pList = pList->pNext;

        }while(pList);
        gpGfxNodeArray[nItemNum] = NULL;

 	}
}

/****************************************************************
 *  ShowProperties
 *
 *  Description:
 *        Show properties button if applicable.
 *
 *  Parameters:
 *        HWND        hDlg            window handle of dialog window
 *
 *  Returns:     
 *        None
 *
 ****************************************************************/

void ShowProperties (HWND hDlg)
{
 
    PGFXUI   pGfxTemp = NULL;
    PGFXUI   pGfxBase = NULL;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    if (0 == dwIndex) return;

    if (!gpGfxNodeArray[dwIndex-1]) return;
    else pGfxTemp = gpGfxNodeArray[dwIndex-1];

    if (!gpGfxInitList->puiList) return;
    else pGfxBase = gpGfxInitList->puiList;

    if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
        GFXUI_Properties (pGfxBase, hDlg);;
    
    return;
}

/****************************************************************
 *  ChangeGFX
 *
 *  Description:
 *        Show properties button if applicable.
 *
 *  Parameters:
 *        HWND        hDlg            window handle of dialog window
 *
 *  Returns:     
 *        None
 *
 ****************************************************************/

void ChangeGFX (HWND hDlg)
{
    DWORD dwIndex = 0;
    HWND  hwndSheet = GetParent(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), FALSE);

    dwIndex = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

	if (dwIndex != CB_ERR)
    {
        EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

        PropSheet_Changed(hwndSheet,hDlg);
    }
}

/*
 ***************************************************************
 *  EffectDlg
 *
 *  Description:
 *        EffectDlg for MM control panel applet.
 *
 *  Parameters:
 *   HWND        hDlg            window handle of dialog window
 *   UINT        uiMessage       message number
 *   WPARAM        wParam          message-dependent
 *   LPARAM        lParam          message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
INT_PTR CALLBACK SoundEffectsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
	NMHDR FAR * lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

 				break;
            }
            break;

        case WM_INITDIALOG:
        {
            LoadEffectList(hDlg);
            if (gAudData.fRecord)
            {
                // Hide the "Play Default Sound" button for Recording devices
                ShowWindow (GetDlgItem(hDlg, IDB_EFFECT_PLAY), SW_HIDE);
            }
			LoadEffects(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            GFXUI_FreeList(&gpGfxInitList);
            GFXUI_FreeList(&gpFullList);
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                  (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_COMMAND:
    
		    switch (LOWORD(wParam))    
            {
		    case ID_APPLY:
                {   
			        SetEffects(hDlg);
                }
                break;

            case IDC_EFFECT_LIST:
				{
                    if (HIWORD(wParam) == CBN_SELCHANGE) ChangeGFX(hDlg);
				}
                break;

            case IDB_EFFECT_PROP:
                {
                    ShowProperties (hDlg);
                }
                break;

            case IDB_EFFECT_PLAY:
                {
                    PlaySound(TEXT(".Default"), NULL, SND_FILENAME | SND_ASYNC );
                }
                break;
            }
            break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\idf.h ===
//************************************************************************
//**
//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//**  A PARTICULAR PURPOSE.
//**
//**  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//**
//**  IDF.h
//**
//**  DESCRIPTION:
//**     This file contains the format of the .IDF files.
//**
//**  HISTORY:
//**     04/29/93       created.
//**     07/04/93       added UNICODE for displayable strings.
//**     09/04/93       added keymaps.
//**     09/05/93       added ID's for channel types.
//**
//************************************************************************

/*
@doc  EXTERNAL SDK

@types   IDFHEADER |
   This is the format of the "hdr " chunk in a Microsoft IDF file.
   This will be the first subchunk of a "MMAP" list chunk.  This will 
   provide information on the IDF itself; what version, who created it,
   and a unique ASCII ID for the instrument.

@field   DWORD | cbStruct |
   This is the inclusive size of the header structure.

@field   DWORD | dwVersion |
   This is the version of the IDF file.
   under.

@field   DWORD | dwCreator |
   This is the creator ID for the IDF.

@field   DWORD | cbInstID |
   This is the size of the unique instrument identifier including the NULL.

@field   BYTE | abInstID[] |
   This is the actual ASCII bytes of the unique instrument id. This _IS_ 
   NULL terminated.  There is no UNICODE version of this since this will
   only be used internally and not displayed to the user.

@othertype  IDFHEADER * | PIDFHEADER |
   A memory model dependant pointer to the structure.

@othertype  IDFHEADER FAR* | LPIDFHEADER |
   A far pointer to the structure.
*/

typedef struct tag_IDFHEADER
{
   DWORD cbStruct;

   DWORD dwVersion;
   DWORD dwCreator;

   DWORD cbInstID;
   BYTE  abInstID[1];
} IDFHEADER, *PIDFHEADER, FAR *LPIDFHEADER;


/*
@doc  EXTERNAL SDK

@types   IDFINSTINFO |
   This is the format of the "inst" chunk in a Microsoft IDF file.
   This chunk will contain information on the instrument, e.g. who
   manufactured it, the name of the instrument, it's manufacturer and
   product id's and a revision number.

@field   DWORD | cbStruct |
   This is the inclusive size of the instrument information structure.

@field   DWORD | dwManufactID |
   Manufacturer's ID.

@field   DWORD | dwProductID |
   Product's ID.

@field   DWORD | dwRevision |
   Revision of the product.

@field   DWORD | cbManufactASCII |
   Length of the ASCII version of the manufacturuers name.

@field   DWORD | cbManufactUNICODE |
   Length of the UNICODE version of the manufacturuers name.

@field   DWORD | cbProductASCII |
   Length of the ASCII version of the product name.

@field   DWORD | cbProductUNICODE |
   Length of the UNICODE version of the product name.

@field   BYTE | abData[] |
   Contains the ASCII and UNICODE strings for the manufacturer and product
   names.  NOTE that all strings are separated by a NULL and the NULL IS
   counted in the string lengths.

@othertype  IDFINSTINFO * | PIDFINSTINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTINFO FAR * | LPIDFINSTINFO |
   A far pointer to the structure.

@comm The idea is that the cbManufactXXXXX and cbProductXXXXX will be the
      offsets into the bData array of bytes and it will contain a complete
      string that you can strcpy out.  That is why the NULL is included in
      the byte count and in the actual data.
*/

typedef struct tag_IDFINSTINFO
{
   DWORD cbStruct;

   DWORD dwManufactID;
   DWORD dwProductID;
   DWORD dwRevision;

   DWORD cbManufactASCII;
   DWORD cbManufactUNICODE;
   DWORD cbProductASCII;
   DWORD cbProductUNICODE;

   BYTE  abData[1];
} IDFINSTINFO, FAR *LPIDFINSTINFO;

/*
@doc  EXTERNAL SDK

@types   IDFINSTCAPS |
   This is the format of the "caps" chunk in a Microsoft IDF file.
   This chunk will contain information on the MIDI capabilities of
   the device. e.g. basic channel of the instrument, number of channels
   that the instrument has available. the polyphony of the instrument, 
   whether or not it supports General MIDI, etc....

@field   DWORD | cbStruct |
   This is the size of the capabilities structure.

@field   DWORD | fdwFlags |
   Flags specifiying additional capabilities of an instrument.

@flag IDFINSTCAPS_F_GENERAL_MIDI |
   Instrument supports General MIDI.

@flag IDFINSTCAPS_F_SYSTEMEXCLUSIVE |
   Instrument supports system exclusive messages

@field   DWORD | dwBasicChannel |
   The basic channel for the instrument.

@field   DWORD | cNumChannels |
   Number of channels that the instrument supports to.

@field   DWORD | cInstrumentPolyphony |
   The total polyphony for the instrument.

@field   DWORD | cChannelPolyphony |
   The polyphony per channel.

@othertype  IDFINSTCAPS * | PIDFINSTCAPS |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTCAPS FAR * | LPIDFINSTCAPS |
   A far pointer to the structure.
*/

typedef struct tag_IDFINSTCAPS
{
   DWORD cbStruct;
   DWORD fdwFlags;
   DWORD dwBasicChannel;
   DWORD cNumChannels;
   DWORD cInstrumentPolyphony;
   DWORD cChannelPolyphony;
} IDFINSTCAPS, *PIDFINSTCAPS, FAR *LPIDFINSTCAPS;

#define  IDFINSTCAPS_F_GENERAL_MIDI       0x00000001
#define  IDFINSTCAPS_F_SYSTEMEXCLUSIVE    0x00000002

/*
@doc  EXTERNAL SDK

@types   IDFCHANNELHDR |
   This is the format of the "chan" chunk in a Microsoft IDF file.
   This contains a description on what "type" a channel is, i.e. 
   is it a General MIDI channel, a drum channel, etc... Directly 
   following this header is the actual data on each channel.

@field   DWORD | cbStruct |
   This is the size of the channel header structure.

@field   DWORD | fdwFlags |
   Flags describing the channel type information.

@flag IDFCHANNELHDR_F_GENERAL_MIDI |
   If this flag is set then any channels that are not defined in the 
   IDF are General MIDI channel types.  If this flag is _NOT_ set then
   any channels that are not defined in the IDF are undefined and should 
   NOT be used in mapping. This flag overrides the contents of dwGeneralMask
   and dwDrumMask.

@field DWORD | dwGeneralMask |
   This mask indicates which channels are available for
   use as general channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field DWORD | dwDrumMask |
   This mask indicates which channels are available for
   use as drum channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field   DWORD | cNumChannels |
   This is the number of channels that follows the header.

@othertype  IDFCHANNELHDR * | PIDFCHANNELHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELHDR FAR * | LPIDFCHANNELHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELHDR
{
   DWORD cbStruct;
   DWORD dwGeneralMask;
   DWORD dwDrumMask;
   DWORD dwReserved;                    // Must be zero
   DWORD fdwFlags;
} IDFCHANNELHDR, *PIDFCHANNELHDR, FAR *LPIDFCHANNELHDR;

#define  IDFCHANNELHDR_F_GENERAL_MIDI     0x00000001


/*
@doc  EXTERNAL SDK

@types    IDFCHANNELINFO |
   This is the format of the actual channel information for Microsoft
   authored IDF files. This is the Microsoft supported format for
   channel information.

@field   DWORD | dwChannel |
   This is the channel number that the structure defines.

@field   DWORD | fdwChannel |
   Defines the possible types this channel can be.

   @flag    IDFCHANNELINFO_F_GENERAL_CHANNEL |
       Indicates that this channel may be a general channel.

   @flag    IDFCHANNELINFO_F_DRUM_CHANNEL |
       Indicates that this channel may be a drum channel.

@field   DWORD | cbInitData |
    Specifies the length of the data which should be sent to initialize
    the channel. This data will be send to initialize the channel each
    time the mapper is opened.

@field    BYTE | abData[] |
    This field contains the actual initialization data.
    <f cbInitData> should indicate the length of this sequence,
    byte aligned. However, the actual sequence should be padded so that
    it is actually DWORD aligned (i.e. even multiple
    of four bytes). <f cbStruct> should reflect the padded length of
    the sequences.
        
@othertype  IDFCHANNELINFO * | PIDFCHANNELINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELINFO FAR * | LPIDFCHANNELINFO |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELINFO
{
   DWORD cbStruct;
   DWORD dwChannel;
   DWORD cbInitData;
   BYTE  abData[];
} IDFCHANNELINFO, *PIDFCHANNELINFO, FAR *LPIDFCHANNELINFO;

/*
@doc  EXTERNAL SDK

@types   IDFPATCHMAPHDR |
   This is the format of the "map " chunk in a Microsoft IDF file.
   This chunk contains information on the patch map used for the 
   instrument. Directly following this header is the actual mapping 
   information for each patch.

@field   DWORD | cbStruct |
   This is the size of the patch map header structure.

@field   BYTE | abPatchMap[128] |
   This array contains the actual patch map. The incoming patch is
   used to index the array; the array contents are the new patch value
   and must be in the range 0x00-0x7F. Patch maps will only apply to
   channels of type general. If the instrument needs a patch change
   on a drum channel, it should be included in the initialization data
   in the IDFCHANNELINFO.

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFPATCHMAPHDR
{
   DWORD cbStruct;
   BYTE  abPatchMap[128];
           
} IDFPATCHMAPHDR, *PIDFPATCHMAPHDR, FAR *LPIDFPATCHMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAPHDR |
   This is the format of the "key " chunk in a Microsoft IDF file.
   This chunk contains information on the all of the key maps used 
   for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | cNumKeyMaps |
   This is the number of key maps that follow the header.

@field   DWORD | cbKeyMap |
   This is the size of each key map that follows the header.   

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAPHDR
{
   DWORD cbStruct;
   DWORD cNumKeyMaps;
   DWORD cbKeyMap;
} IDFKEYMAPHDR, *PIDFKEYMAPHDR, FAR *LPIDFKEYMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAP |
   This is the format of the "gkey" or "dkey" chunk in a Microsoft
   IDF file. This chunk contains information on the all of the key maps
   used for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   BYTE | abKeyMap[128] |
    This field contains the actual key map. The incoming key number from
    a note on or note off message is used to index this array; the array
    contents are the new key value. If the high bit it set in the new
    key value, then the note on or note off will be ignore; otherwise,
    it will be transmitted with the new key value.
    
@othertype  IDFKEYMAP * | PIDFKEYMAP |
   A memory model dependant pointer to the structure.

@othertype  IDFKEYMAP FAR * | LPIDFKEYMAP |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAP
{
   DWORD cbStruct;
   BYTE  abKeyMap[128];
} IDFKEYMAP, *PIDFKEYMAP, FAR *LPIDFKEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\filecopy.c ===
/**************************************************************************
 *
 *  FILECOPY.C
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Control Panel Applet for installing installable driver.
 *
 *  This file contains hooks to SULIB, COMPRESS libraries, and the dialogs
 *  from the display applet to prompt for insert disk, error action...
 *
 *  Note SULIB.LIB, COMPRESS.LIB, SULIB.H come from the display applet
 *  and are updated here if/when updated there.
 *
 *  History:
 *
 *      Sat Oct 27 1990 -by- MichaelE
 *          Munged from display applet's DLG.C.
 *
 **************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include "drivers.h"
#include "sulib.h"
#include <cphelp.h>

// Hidden parameter between wsSingleCopyStatus and wExistDlg

static TCHAR     szErrMsg[MAXSTR];

// Hidden parameters passed from wsInsertDisk to wDiskDlg

static TCHAR     CurrentDisk[MAX_PATH];
static LPTSTR    szEdit;

// Function prototypes

BOOL wsInfParseInit    (void);
int  fDialog           (int, HWND, DLGPROC);
UINT wsCopyError       (int, LPTSTR);
UINT wsInsertDisk      (LPTSTR, LPTSTR);
INT_PTR wsDiskDlg         (HWND, UINT, WPARAM, LPARAM);
INT_PTR wsExistDlg        (HWND, UINT, WPARAM, LPARAM);

/*
 *  Load the description from the inf file or the driver file.
 *
 *  The type of file is also returned in the driver structure.
 *
 *  Parameters :
 *       pIDriver - Pointer to driver data - in particular the driver file name
 *       pstrKey  - The ini file key under which the driver should be found
 *       pstrDesc - Where to return the description
 */

 int LoadDescFromFile(PIDRIVER pIDriver, LPTSTR pstrKey, LPTSTR pstrDesc)
 {
     PINF        pinf;
     TCHAR        szFileName[MAX_INF_LINE_LEN];
     LPTSTR        pstrFile = pIDriver->szFile;
     TCHAR        ExpandedName[MAX_PATH];
     LPTSTR        FilePart;

    /*
     *  See if the file can be found
     */


     if (SearchPath(NULL, pstrFile, NULL, MAX_PATH, ExpandedName, &FilePart)
         == 0) {
         return(DESC_NOFILE);
     }

    /*
     * -jyg- Let's look in the mmdriver.inf first!
     */

     for (pinf = FindInstallableDriversSection(NULL);
          pinf;
          pinf = infNextLine(pinf))
     {
         infParseField(pinf, 1, szFileName); // compare filename

        /*
         *  FileName strips of drive and path
         */

         if (lstrcmpi(FileName(pstrFile), FileName(szFileName)) == 0)
         {
             infParseField(pinf, 3, pstrDesc); // get Description Field

             return DESC_INF;
         }
     }

    /*
     *  If that failed try to get the description from the file
     */

     if (!GetFileTitle(ExpandedName, pstrDesc, MAXSTR)) {
         return DESC_EXE;
     } else {
         return DESC_NOFILE;
     }
 }

/*
 *  Find the install path from the registry if there is one there
 */

 BOOL GetInstallPath(LPTSTR szDirOfSrc)
 {
     HKEY RegHandle;
     DWORD Type;
     DWORD Length = MAX_PATH - 1;
     BOOL Found = FALSE;

     if (MMSYSERR_NOERROR ==
         RegOpenKey(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                    &RegHandle)) {

         if (MMSYSERR_NOERROR ==
             RegQueryValueEx(RegHandle,
                             TEXT("SourcePath"),
                             NULL,
                             &Type,
                             (LPBYTE)szDirOfSrc,
                             &Length) &&
             Type == REG_SZ) {

             Found = TRUE;
         }

         RegCloseKey(RegHandle);

     }

     return Found;
 }

/*
 *  Initialize the SULIB library stuff which loads the mmdriver.inf file
 *  into RAM and parses it all over the place.
 */

 BOOL wsInfParseInit(void)
 {
     TCHAR       szPathName[MAX_PATH];
     TCHAR*      pszFilePart;
     PINF        pinf;
     TCHAR       szNoInf[MAXSTR];
     TCHAR       iDrive;
     static BOOL bChkCDROM = FALSE;
     HANDLE      hFile;

	 szPathName[0] = '\0';

    /*
     *  put up an hour glass here
     */

     wsStartWait();

     hFile = CreateFile(szSetupInf, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

     if (hFile == INVALID_HANDLE_VALUE)
     {
         wsEndWait();
         LoadString(myInstance, IDS_NOINF, szNoInf, sizeof(szNoInf)/sizeof(TCHAR));
         MessageBox(hMesgBoxParent, szNoInf, szDrivers, MB_OK | MB_ICONEXCLAMATION);
         return FALSE;
     }

     CloseHandle(hFile);

     GetFullPathName(szSetupInf,sizeof(szPathName)/sizeof(TCHAR),szPathName,&pszFilePart);

     pinf = infOpen(szPathName);

     wsEndWait();

     if (GetWindowsDirectory(szSetupPath, sizeof(szSetupPath)/sizeof(TCHAR)))
		 szSetupPath[0] = '\0';

     if (bChkCDROM == FALSE) {

         /*
          *  Use the setup path from the registry if there is one
          */

          if (!GetInstallPath(szDirOfSrc))
          {
             /*
              *  use the CD ROM drive as the default drive (if there is one)
              */

              for ( iDrive=TEXT('A'); iDrive <= TEXT('Z'); iDrive++ ) {
                  szDirOfSrc[0] = iDrive;

                  if ( GetDriveType(szDirOfSrc) == DRIVE_CDROM)
                  {
                          break;
                  }
                 /*
                  *  If we didn't find a CD ROM default to the A drive
                  */

                  if (iDrive == TEXT('Z')) {
                      szDirOfSrc[0] = TEXT('A');
                  }
              }
          }

          bChkCDROM = TRUE;
     }

     lstrcpy(szDiskPath, szDirOfSrc);

     return TRUE;
 }


/*----------------------------------------------------------------------------*\
|   wsStartWait()                                                              |
|                                                                              |
|   Turn the WinSetup cursor to a hour glass                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsStartWait()
{
    SetCursor(LoadCursor(NULL,IDC_WAIT));
}

/*----------------------------------------------------------------------------*\
|   wsEndWait()                                                                |
|                                                                              |
|   Turn the WinSetup cursor back to what it was                               |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsEndWait()
{
    SetCursor(LoadCursor(NULL,IDC_ARROW));
}


/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       fpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int fDialog(int id, HWND hwnd, DLGPROC fpfn)
{
    return ( (int)DialogBox(myInstance, MAKEINTRESOURCE(id), hwnd, fpfn) );
}


/****************************************************************************
 *                                                                             |
 *wsCopyError()                                                                |
 *                                                                             |
 *  Handles errors, as the result of copying files.                            |
 *                                                                             |
 *  This may include net contention errors, in which case the user must        |
 *  retry the operation.                                                       |
 *                                                                             |
 *  Parameters :
 *
 *     n      - Copy error number
 *
 *     szFile - the fully qualified name of the file we are copying
 *
 *  Returns
 *
 *     Always returns FC_ABORT
 *
 ****************************************************************************/
 UINT wsCopyError(int n, LPTSTR szFile)
 {
     TCHAR strBuf[MAXSTR];
     int i = 0;

    /*
     *  We do not want to report any errors that occur while installing
     *  related drivers to the user
     */

     if (bCopyingRelated)
          return(FC_ABORT);

    /*
     *  check for out of disk space
     */

     if (n == ERROR_DISK_FULL) {

        LoadString(myInstance, IDS_OUTOFDISK, strBuf, MAXSTR);

     } else {

       /*
        *  Check to see if a copy has been done on a file that is currently
        *  loaded by the system.
        *
        *  n is the return code from VerInstallFile after translating
        *  by ConvertFlagToValue
        */

        if (n == FC_ERROR_LOADED_DRIVER)
        {
            BOOL bFound = FALSE;
            PIDRIVER pIDriver;

           /*
            *  The driver is in use :
            *
            *  Search the list of curently installed drivers to see
            *  if this file is one of them.  If so tell the user to
            *  de-install and re-start.
            *
            *  If the driver is not currently installed then tell
            *  the user to re-start in the hope that it will then
            *  not be loaded (and so in use)
            *
            *  Note that there is another case not catered for that
            *  this is just a file in the driver's copy list which
            *  failed to copy because it was 'in use'.
            *
            */

            pIDriver = FindIDriverByName (FileName(szFile));

            if (pIDriver != NULL)    // Found an already-installed driver?
            {
                TCHAR sztemp[MAXSTR];
                LoadString(myInstance,
                           IDS_FILEINUSEREM,
                           sztemp,
                           sizeof(sztemp)/sizeof(TCHAR));

                wsprintf(strBuf, sztemp, (LPTSTR)pIDriver->szDesc);
                bFound = TRUE;
            } else {
                iRestartMessage = IDS_FILEINUSEADD;
                DialogBox(myInstance,
                          MAKEINTRESOURCE(DLG_RESTART),
                          hMesgBoxParent,
                          RestartDlg);

                return(FC_ABORT);
            }

        } else {

           /*
            *  Tell the user there is a problem which we don't
            *  understand here.
            */

            LoadString(myInstance,
                       IDS_UNABLE_TOINSTALL,
                       strBuf,
                       MAXSTR);
        }
     }

    /*
     *  Put up the message box we have selected.
     */

     MessageBox(hMesgBoxParent,
                strBuf,
                szFileError,
                MB_OK | MB_ICONEXCLAMATION  | MB_TASKMODAL);

     return (FC_ABORT);

 }


/*----------------------------------------------------------------------------*\
|                                                                              |
| wsInsertDisk()                                                               |
|                                                                              |
|   Handles errors, as the result of copying files.                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath)
{
    UINT temp;
    int i;

   /*
    *  Create the real disk letter
    */
    for (i = 0; Disk[i] != TEXT('\0') && Disk[i] != TEXT(':'); i++) {
        CurrentDisk[i] = Disk[i];
    }
    CurrentDisk[i] = TEXT('\0'); // Null terminate

    szEdit = szSrcPath;

    bFindOEM = TRUE;
    temp =  (UINT)fDialog(DLG_INSERTDISK, GetActiveWindow(), wsDiskDlg);
    bFindOEM = FALSE;
    return(temp);
}


/*----------------------------------------------------------------------------*
|   wsDiskDlg( hDlg, uiMessage, wParam, lParam )                               |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/

INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{

    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDH_DLG_INSERT_DISK:
                   goto DoHelp;

                case IDS_BROWSE:

                  /*
                   *  Call the browse dialog to open drivers
                   */

                   BrowseDlg(hDlg,
                             3);    // index 3 points to no filter
                                    // - see szFilter
                   break;

                case IDOK:

                   /*
                    *  szEdit points to the path that will be retried
                    *  if the copy fails
                    */

                    GetDlgItemText(hDlg, ID_EDIT, szEdit, MAX_PATH);
                    RemoveSpaces(szDiskPath, szEdit);
                    lstrcpy(szEdit, szDiskPath);
                    EndDialog(hDlg, FC_RETRY);
                    UpdateWindow(hMesgBoxParent);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FC_ABORT);
                    break;
            }
            return TRUE;

        case WM_INITDIALOG:
            {

            TCHAR DisksSection[MAXSTR];

           /*
            *  now look in the [disks] section for the disk name
            *  the disk name is the second field.
            */

            TCHAR buf[MAXSTR];
            TCHAR buf2[MAXSTR];
            TCHAR bufout[MAXSTR];

            *buf = TEXT('\0');

           /*
            *  See what the name of the section should be
            */

            LoadString(myInstance,
                       IDS_DISKS,
                       DisksSection,
                       sizeof(DisksSection)/sizeof(TCHAR));

            infGetProfileString(NULL, DisksSection, CurrentDisk, (LPTSTR)buf);

            if (*buf) {

               /*
                * Position of description in Windows NT
                */

               infParseField(buf, 1, buf2);
            } else {

               /*
                *  Didn't find the section we were looking for so try
                *  the old names
                */

               infGetProfileString(NULL, TEXT("disks"), CurrentDisk, (LPTSTR)buf);
               if (!*buf)
                 infGetProfileString(NULL, TEXT("oemdisks"), CurrentDisk, (LPTSTR)buf);

               if (!*buf) {
                   return FALSE;
               }

               infParseField(buf, 2, buf2);
            }

            wsprintf(bufout, szKnown, (LPTSTR)buf2, (LPTSTR)szDrv);
            SetDlgItemText(hDlg,ID_TEXT,bufout);
            SetDlgItemText(hDlg,ID_EDIT,szEdit);

            return TRUE;
            }
        default:
            if (uiMessage == wHelpMessage) {
DoHelp:
               WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
               return TRUE;
            }
            else
                return FALSE;
         break;
    }
}

/*--------------------------------------------------------------------------
 *
 * Function : wsCopySingleStatus
 *     File copying callback routine
 *
 * Parameters :
 *     msg - Which callback function
 *     n   - various
 *     szFile - which file
 *
 * this call back only copies it's file if it does not exist in the
 * path.
 *
 *--------------------------------------------------------------------------*/

 UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile)
 {
    OFSTRUCT ofs;
    TCHAR szFullPath[MAX_PATH];
    TCHAR szDriverExists[MAXSTR];

    switch (msg)
     {
         case COPY_INSERTDISK:
             return wsInsertDisk((LPTSTR)n, szFile);

         case COPY_ERROR:
             return wsCopyError((int)n, szFile);


         case COPY_QUERYCOPY:

            /*
             *  See if the file already exists in the windows system
             *  directory
             */

             GetSystemDirectory(szFullPath, MAX_PATH);

             if (IsFileKernelDriver(szFile)) {
                 lstrcat(szFullPath, TEXT("\\drivers"));
             }

             lstrcat(szFullPath, TEXT("\\"));

             lstrcat(szFullPath, RemoveDiskId(szFile));

             // BUGBUG -- handle leak since time immemorial
             if (CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) != INVALID_HANDLE_VALUE)
             {
                /*
                 *  DriverCopy remembers whether to copy from
                 *  current or new after we have queried the user
                 *  once
                 */

                 static int DriverCopy;

                 if (bQueryExist)
                 {
                     bQueryExist = FALSE;

                     LoadString(myInstance,
                                IDS_DRIVER_EXISTS,
                                szDriverExists,
                                sizeof(szDriverExists)/sizeof(TCHAR));

                     wsprintf(szErrMsg, szDriverExists, FileName(szFile));

                    /*
                     *  Ask the user whether to copy or not ?
                     */

                     DriverCopy = (int)DialogBox(myInstance,
                                            MAKEINTRESOURCE(DLG_EXISTS),
                                            hMesgBoxParent,
                                            wsExistDlg);
                 }

                 return DriverCopy;
             } else {

                 return CopyNew;
             }

         case COPY_START:
         case COPY_END:
             SetErrorMode(msg == COPY_START);    // don't crit error on us
             break;
     }
     return FC_IGNORE;
 }

/*
 *  Function : wsExistDlg - 'File exists' dialog
 */

 INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam)
 {
     switch (uiMessage)
     {
         case WM_COMMAND:
             switch (LOWORD(wParam))
             {
                 case ID_CURRENT:

                     EndDialog(hDlg, CopyCurrent);
                     break;

                 case ID_NEW:

                    /*
                     *  User selected to copy the new files over the
                     *  existing ones
                     */

                     EndDialog(hDlg, CopyNew);
                     break;

                 case IDCANCEL:
                     EndDialog(hDlg, CopyNeither);  // Cancel
                     break;
             }
             return TRUE;

         case WM_INITDIALOG:
             SetDlgItemText(hDlg, ID_STATUS2, szErrMsg);
             return TRUE;

         default:
          break;
     }
     return FALSE;
 }

/*
 *  Function : RemoveSpaces
 *     Copies a string removing leading and trailing spaces but allowing
 *     for long file names with internal spaces.
 *
 *  Parameters :
 *     szPath - The output result
 *     szEdit - The input path
 */

 VOID RemoveSpaces(LPTSTR szPath, LPTSTR szEdit)
 {
     LPTSTR szLastSpaceList;

     while (*szEdit == TEXT(' ')) {
         szEdit = CharNext(szEdit);
     }

     lstrcpy(szPath, szEdit);

     for (szLastSpaceList = NULL;
          *szPath != TEXT('\0');
          szPath = CharNext(szPath)) {

        if (*szPath == TEXT(' ')) {
            if (szLastSpaceList == NULL) {
                szLastSpaceList = szPath;
            }
        } else {
            szLastSpaceList = NULL;
        }

     }

     if (szLastSpaceList != NULL) {
         *szLastSpaceList = TEXT('\0');
     }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\infparse.c ===
/*
 * Infparse.c - Setup.inf parsing code.
 * Clark Cyr, Mike Colee, Todd Laney
 * Copyright (C) Microsoft, 1989
 * March 15, 1989
 *
 *  Modification History:
 *
 *  3/15/89  CC  Clark wrote this code for control Panel. This is windows
 *               code.
 *
 *  3/20/89  MC  Decided this code would work for Dos and windows portion
 *               of setup. take out windows specifc stuff like local alloc's
 *               and dialog stuff. Replace it with standard C run time calls.
 *
 *  3/24/89  Toddla TOTAL rewrite! nothing is the same any more.
 *
 *  6/29/89  MC fixed getprofilestring func to not strip quotes if more
 *              than one field exists.
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*** hack.  to avoid realloc problems we make READ_BUFSIZE
            as big as the inf file, thus avoiding any reallocs */

#define READ_BUFSIZE    27000   /* size of inf buffer */
#define TMP_BUFSIZE     1024    /* size of temp reads */

#define EOF        0x1A
#define ISEOL(c)     ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == EOF)
#define ISSEP(c)   ((c) == '='  || (c) == ',')
#define ISWHITE(c) ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISNOISE(c) ((c) == '"')

#define QUOTE   '"'
#define EQUAL   '='

PINF   pinfDefault = NULL;

static LPSTR   pBuf;
static PINF    pInf;
static UINT    iBuf;
static UINT    iInf;

/* Globaly used pointers to non-translatable text strings. */

extern TCHAR *pszPATH;

/* Local prototypes */

BOOL multifields(PINF);


static TCHAR GETC(int fh)
{
    register UINT n;

    if (!pBuf)
        return EOF;

    n = iBuf % TMP_BUFSIZE;

    if (n == 0)
    {
       _lread(fh,pBuf,TMP_BUFSIZE);
    }
    iBuf++;
    return pBuf[n];
}

static void PUTC(TCHAR c)
{
    if (!pInf)
        return;

    pInf[iInf++] = c;
}

static void MODIFYC(TCHAR c)
{
    if (!pInf)
        return;

    pInf[iInf++ - 1] = c;
}

static TCHAR LASTC(void) {
    if (!pInf) return ' ';

    if (iInf == 0) {
        return ' ';
    }
    return pInf[iInf - 1];
}

/* int infLoadFile()      Load a entire INF file into memory
 *                        comments are removed, each line is terminated
 *                        by a \0 each section is terminated by a \0\0
 *                        ONLY spaces inside of " " are preserved
 *                        the end of file is marked with a ^Z
 *
 *   RETURNS:  A pointer to a block of memory containg file, NULL if failure
 *
 */
PINF infLoadFile(int fh)
{
    UINT    len;
    TCHAR    c;
    BOOL    fQuote = FALSE;
    BOOL    inSectionName = FALSE;

    if (fh == -1)
      return NULL;

    len = (UINT)_llseek(fh,0L,SEEK_END);

    _llseek(fh,0L,SEEK_SET);

    iBuf = 0;
    iInf = 0;
    pBuf = ALLOC(TMP_BUFSIZE);          // temp buffer
    if (!pBuf)
        return NULL;
    pInf = FALLOC(len*sizeof(TCHAR));                 // destination, at least as big as file
    if (!pInf) {
        FREE((HANDLE)pBuf);
        return NULL;
    }

    while (iBuf < len)
    {
        c = GETC(fh);
loop:
        if (iBuf >= len)
            break;

        switch (c)
        {
            case TEXT('['):
                inSectionName = TRUE;
                PUTC(c);
                break;

            case TEXT(']'):
                if (inSectionName) {
                    if (LASTC() == TEXT(' ')) {
                        MODIFYC(c);
                    } else {
                        PUTC(c);
                    }
                    inSectionName = FALSE;
                } else {
                    PUTC(c);
                }
                break;

            case TEXT('\r'):      /* ignore '\r' */
                break;

            case TEXT('\n'):
                for (; ISWHITE(c); c = GETC(fh))
                    ;
                if (c != TEXT(';'))
                    PUTC(0);    /* all lines end in a \0 */

                if (c == TEXT('[')) {
                    PUTC(0);    /* all sections end with \0\0 */
                }

                fQuote = FALSE;
                goto loop;
                break;

            case TEXT('\t'):
            case TEXT(' '):
                if (inSectionName) {
                    if (LASTC() != TEXT(' ') && LASTC() != TEXT(']'))
                        PUTC(TEXT(' '));
                } else {
                    if (fQuote)
                        PUTC(c);
                }
                break;

            case TEXT('"'):
                fQuote = !fQuote;
                PUTC(c);
                break;

            case TEXT(';'):
                for (; !ISEOL(c); c = GETC(fh))
                    ;
                goto loop;
                break;

            default:
                PUTC(c);
                break;
        }
    }

    PUTC(0);
    PUTC(0);
    PUTC(EOF);
    FREE((HANDLE)pBuf);

    // try to shrink this block


    // just leave pInf it's original size.  don't bother shrinking it

    return pInf;
}

/* PINF FAR PASCAL infOpen()
 *   PARAMETERS
 *           szInf - path to inf file to open and load
 *
 *   RETURNS:  A pointer to the parsed inf file if successful,
 *             Null pointer in the case of failure.
 *
 *   ENTER:
 *   EXIT:   To caller
 */

PINF infOpen(LPTSTR szInf)
{
    TCHAR    szBuf[MAX_PATH];
    int     fh;
    PINF    pinf;

    fh = -1;

    if (szInf == NULL)
        szInf = szSetupInf;

    /*
     * Next try to open passed parameter as is. For Dos half.
     */
    if (fh == -1)
    {
        fh = HandleToUlong(CreateFile(szInf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    /*
     * Next try destination path\system32. for win half.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, TEXT("system32"));
      catpath(szBuf, szInf);
      fh = HandleToUlong(CreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    /*
     * Next try destination path. for initial setup.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, szInf);
      fh = HandleToUlong(CreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    if (fh != -1)
    {
        pinf = infLoadFile(fh);
        _lclose(fh);

        if (pinf && !pinfDefault)
            pinfDefault = pinf;

        return pinf;
    }
    return NULL;
}

/* void FAR PASCAL infClose(PINF pinf)
 *
 *   ENTER:
 *   EXIT:   To caller
 */
void infClose(PINF pinf)
{
    if (pinf == NULL)
        pinf = pinfDefault;

    if (pinf != NULL)
    {
        FFREE(pinf);

        if (pinf == pinfDefault)
            pinfDefault = NULL;
    }
}


/* FindSection  locates a section in Setup.Inf.  Sections are
 *               assumed to be delimited by a '[' as the first
 *               character on a line.
 *
 * Arguments:   pInf     Pointer to SETUP.INF buffer
 *              pszSect  LPTSTR to section name
 *
 * Return:      UINT file position of the first line in the section
 *               0 if section not found
 */

UINT_PTR FindSection(PINF pInf, LPTSTR pszSect)
{
    BOOL        fFound = FALSE;
    int         nLen = lstrlen(pszSect);
    PINF        pch;

    if (!pInf)
        return 0;

    pch = pInf;
    while (!fFound && *pch != EOF)
    {
        if (*pch++ == TEXT('['))
        {
            fFound = !_wcsnicmp(pszSect, pch, nLen) && pch[nLen] == TEXT(']');
        }

        /*
         * go to the next line, dont forget to skip over \0 and \0\0
         */
        while (*pch != EOF && *pch != TEXT('\0'))
            pch++;

        while (*pch == 0)
            pch++;
    }
    return((fFound && *pch != TEXT('[') && *pch != EOF) ? pch - pInf : 0);
}

/* TCHAR* fnGetDataString(npszData,szDataStr)
 *
 * Called by functions that read sections of information from setup.inf
 * to obtain strings that are set equal to keywords. Example:
 *
 * welcome=("Hello There")
 *
 * This function will return a pointer to the null terminated string
 * "Hello There".
 *
 * ENTRY:
 *
 * npszData    : pointer to entire section taken from setup.inf
 * npszDataStr : pointer to key word to look for (welcome in example above.)
 *
 * EXIT: returns pointer to string if successful, NULL if failure.
 *
 */
BOOL fnGetDataString(PINF npszData, LPTSTR szDataStr, LPTSTR szBuf)
{
    int len = lstrlen(szDataStr);

    while (npszData)
    {
            if (!_wcsnicmp(npszData,szDataStr,len))  // looking for correct prof.
            {
               npszData += len;            // found !, look past prof str.
               while (ISWHITE(*npszData))  // pull out the garbage.
                       npszData++;
          if (*npszData == EQUAL)     // Now we have what were looking for !
               {
                       npszData++;

             if (!multifields(npszData) )
             {
                while (ISWHITE(*npszData) || ISNOISE(*npszData))
                             npszData++;

                          while (*npszData)
                             *szBuf++ = *npszData++;

                       /*
                        * remove trailing spaces, and those pesky ()'s
                           */

                while (ISWHITE(szBuf[-1]) || ISNOISE(szBuf[-1]))
                             szBuf--;

                          *szBuf = 0;
                          return TRUE;
             }
             else
             {
                while (*npszData)
                   *szBuf++ = *npszData++;
                *szBuf = TEXT('\0');
                return TRUE;
             }
               }
       }
       npszData = infNextLine(npszData);
    }
    *szBuf = 0;
    return FALSE;
}

/*  PINF FAR PASCAL infSetDefault(pinf)
 *
 *  Sets the default INF file
 *
 * ENTRY:
 *      pinf            : inf file to be new default
 *
 * EXIT: returns old default
 *
 */
PINF infSetDefault(PINF pinf)
{
    PINF pinfT;

    pinfT = pinfDefault;
    pinfDefault = pinf;
    return pinfT;
}

/*  PINF FAR PASCAL infFindSection(pinf,szSection)
 *
 *  Reads a entire section into memory and returns a pointer to it
 *
 * ENTRY:
 *      pinf            : inf file to search for section
 *      szSection       : section name to read
 *
 * EXIT: returns pointer to section, NULL if error
 *
 */
PINF infFindSection(PINF pinf, LPTSTR szSection)
{
    UINT_PTR   pos;

    if (pinf == NULL)
        pinf = pinfDefault;

    pos = FindSection(pinf, szSection);
    return pos ? pinf + pos : NULL;
}

/*  BOOL FAR PASCAL infGetProfileString(szSection,szItem,szBuf)
 *
 *  Reads a single string from a section in SETUP.INF
 *
 *  [section]
 *      item = string
 *
 * ENTRY:
 *      szSection       : pointer to section name to read.
 *      szItem          : pointer to item name to read
 *      szBuf           : pointer to a buffer to hold result
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
BOOL infGetProfileString(PINF pinf, LPTSTR szSection,LPTSTR szItem,LPTSTR szBuf)
{
    PINF    pSection;

    pSection = infFindSection(pinf,szSection);
    if (pSection )
        return fnGetDataString(pSection,szItem,szBuf);
    else
        *szBuf = 0;
    return FALSE;
}

/* BOOL FAR PASCAL infParseField(szData,n,szBuf)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szBuf     : pointer to buffer to hold extracted field
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
BOOL infParseField(PINF szData, int n, LPTSTR szBuf)
{
    BOOL    fQuote = FALSE;
    PINF    pch;
    LPTSTR   ptr;

    if (!szData || !szBuf)
        return FALSE;

    /*
     * find the first separator
     */
    for (pch=szData; *pch && !ISSEP(*pch); pch++) {
      if ( *pch == QUOTE )
         fQuote = !fQuote;
    }

    if (n == 0 && *pch != TEXT('='))
        return FALSE;

    if (n > 0 && *pch == TEXT('=') && !fQuote)
        szData = ++pch;

    /*
     *  locate the nth comma, that is not inside of quotes
     */
    fQuote = FALSE;
    while (n > 1)
    {
            while (*szData)
            {
          if (!fQuote && ISSEP(*szData))
                   break;

          if (*szData == QUOTE)
                   fQuote = !fQuote;

               szData++;
            }

            if (!*szData) {
               szBuf[0] = 0;            // make szBuf empty
               return FALSE;
            }

            szData++;
            n--;
    }
    /*
     * now copy the field to szBuf
     */
    while (ISWHITE(*szData))
            szData++;

    fQuote = FALSE;
    ptr = szBuf;                // fill output buffer with this
    while (*szData)
    {
       if (*szData == QUOTE)
               fQuote = !fQuote;
       else if (!fQuote && ISSEP(*szData))
               break;
            else
               *ptr++ = *szData;
            szData++;
    }
    /*
     * remove trailing spaces, and those pesky ()'s
     */
    while ((ptr > szBuf) && (ISWHITE(ptr[-1]) || ISNOISE(ptr[-1])))
            ptr--;

    *ptr = 0;
    return TRUE;
}

/* BOOL multifields(LPTSTR npszData);
 *
 * Given a line line from mmdriver.inf that was after a profile
 * string this function will determine if that line has more than one
 * field. ie. Fields are seperated by commas that are NOT contained between
 * quotes.
 *
 * ENYRY:
 *
 * npszData : a line from setup.inf Example "xyz adapter",1:foobar.drv
 *
 * EXIT: This function will return TRUE if the line containes more than
 *       one field, ie the function would return TRUE for the example line
 *       shown above.
 *
 */
BOOL multifields(PINF npszData)
{
   BOOL    fQuote = FALSE;

        while (*npszData)
        {
      if (!fQuote && ISSEP(*npszData))
                   return TRUE;

      if (*npszData == QUOTE)
                   fQuote = !fQuote;

           npszData++;
        }
   return FALSE;
}

/* LPTSTR FAR PASCAL infNextLine(sz)
 *
 * Given a line from SETUP.INF, advance to the next line.  will skip past the
 * ending NULL character checking for end of buffer \0\0
 *
 * ENTRY:
 *
 * sz        : pointer to line from a SETUP.INF section
 *
 * EXIT: returns pointer to next line if successful, NULL if failure.
 *
 */
PINF infNextLine(PINF pinf)
{
    if (!pinf)
        return NULL;

    while (*pinf != 0 || *(pinf + 1) == TEXT(' '))
        pinf++;

    return *++pinf ? pinf : NULL;
}

/* int FAR PASCAL infLineCount(pinf)
 *
 * Given a section from SETUP.INF, returns the number of lines in the section
 *
 * ENTRY:
 *
 * pinf      : pointer to a section from SETUP.INF
 *
 * EXIT: returns line count
 *
 */
int infLineCount(PINF pinf)
{
    int n = 0;

    for (n=0; pinf; pinf = infNextLine(pinf))
        n++;

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\medhelp.h ===
// Context Help IDs for the Sound and Multimedia Control Panels                 
// Updated: 5-12-00, with new values for MMC Panels. See "Updated"
// section at bottom of file for new entries. 
// Pete Mentele
//


#ifndef NO_HELP
#define NO_HELP                                 ((DWORD) -1) // Disables Help for a control
#endif

#define IDH_COMM_GROUPBOX                       28548  // Value copied from help.h
#define IDH_FPROP_GEN_NAME                      4708   // Value copied from help.h
#define IDH_FPROP_GEN_ICON                      4779   // Value copied from help.h

#define IDH_ADDMIDI_CHANNEL                     2400
#define IDH_ADDMIDI_INSTRUMENT                  2401
#define IDH_ADV_PROPERTIES                      2402
#define IDH_AUDIO_CUST_ATTRIB                   2403
#define IDH_AUDIO_CUST_FORMAT                   2404
#define IDH_AUDIO_CUST_NAME                     2405
#define IDH_AUDIO_CUST_REMOVE                   2406
#define IDH_AUDIO_CUST_SAVEAS                   2407
#define IDH_AUDIO_PLAY_PREFER_DEV               2408
#define IDH_AUDIO_PLAY_VOL                      2409
#define IDH_AUDIO_REC_CUST                      2410
#define IDH_AUDIO_REC_PREFER_DEV                2411
#define IDH_AUDIO_REC_PREFER_QUAL               2412
#define IDH_AUDIO_REC_VOL                       2413
#define IDH_AUDIO_USE_PREF_ONLY                 2414
#define IDH_AUDIO_PLAY_PREFER_QUAL              2417
#define IDH_AUDIO_PLAY_CUST                     2418
#define IDH_CD_PLAY_ANALOG                      2420
#define IDH_CD_VOL_HEADPHONE                    2420
#define IDH_EVENT_BROWSE                        2422
#define IDH_EVENT_DELETE_BUTTON                 2423
#define IDH_EVENT_EVENT                         2424
#define IDH_EVENT_FILE                          2425
#define IDH_EVENT_LABEL                         2427
#define IDH_EVENT_PLAY                          2428
#define IDH_EVENT_SAVEAS_BUTTON                 2430
#define IDH_EVENT_SCHEME                        2431
#define IDH_SOUNDS_SYS_VOL_CONTROL              2432
#define IDH_EVENT_STOP                          2434
#define IDH_GENERIC_DEVICES                     2435
#define IDH_MIDI_ADD_NEW                        2436
#define IDH_MIDI_CFGDLG_CHANGE                  2437
#define IDH_MIDI_CFGDLG_DELETE                  2438
#define IDH_MIDI_CFGDLG_SAVEAS                  2439
#define IDH_MIDI_CFGDLG_SCHEME                  2440
#define IDH_MIDI_CONFIG_SCHEME                  2441
#define IDH_MIDI_CUST_CONFIG                    2442
#define IDH_MIDI_INSTRUMENTS                    2443
#define IDH_MIDI_SAVEDLG_SCHEMENAME             2444
#define IDH_MIDI_SCHEME                         2445
#define IDH_MIDI_SINGLE_INST                    2446
#define IDH_MMCPL_DEVPROP_ABOUT                 2447
#define IDH_MMCPL_DEVPROP_CHANGE_PRI            2448
#define IDH_MMCPL_DEVPROP_DETAILS_BROWSE        2449
#define IDH_MMCPL_DEVPROP_DETAILS_INS_DEF       2450
#define IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT    2451
#define IDH_MMCPL_DEVPROP_DISABLE               2452
#define IDH_MMCPL_DEVPROP_DONT_MAP              2453
#define IDH_MMCPL_DEVPROP_ENABLE                2454
#define IDH_MMCPL_DEVPROP_REMOVE                2455
#define IDH_MMCPL_DEVPROP_SETTINGS              2456
#define IDH_ADD_DRIVER_LIST                     2457
#define IDH_MIDI_SINGLE_INST_BUTTON             2458
#define IDH_SAVEAS_SCHEMENAME                   2459
#define IDH_VIDEO_FIXED_WINDOW                  2460
#define IDH_VIDEO_FULL_SCREEN                   2461
#define IDH_VIDEO_GRAPHIC                       2462
#define IDH_MMCPL_DEVPROP_DETAILS_MIDI_PORT     2463
#define IDH_MIDI_SINGLE_INST_LIST               2464
#define IDH_MMCPL_DEVPROP_INST_LIST             2465
#define IDH_ADV_ADDDRIVER                       2466
#define IDH_AUDIO_SHOW_INDICATOR                2467
#define IDH_CD_CDROM_DRIVE                      2468
#define IDH_EVENT_BROWSE_PREVIEW                2469
#define IDH_FCAB_MM_COPYRIGHT                   2470
#define IDH_FCAB_MM_FILELEN                     2471
#define IDH_FCAB_MM_AUDIOFORMAT                 2472
#define IDH_FCAB_MM_MIDISEQUENCENAME            2473
#define IDH_FCAB_MM_VIDEOFORMAT                 2474
#define IDH_FCAB_MM_DETAILSINFO                 2475
#define IDH_FCAB_MM_PREVIEW_CONTROL             2476
#define IDH_AUDIO_CUST_SAVEAS_SAVE_FORMAT       2477
#define IDH_VIDEO_ADVANCED_BUTTON               2478
#define IDH_VIDEO_ADVANCED_COMPAT               2479

// 2480 - 2499 reserved for joy.cpl.

//////////////
// Help ID's for advanced audio dialog
//////////////

#define IDH_ADV_AUDIO_ACCELERATION              2602
#define IDH_ADV_AUDIO_SRCQUALITY                2603
#define IDH_ADV_AUDIO_RESTOREDEFAULTS           2604
#define IDH_ADV_AUDIO_PLAY_PROP                 2605
#define IDH_ADV_AUDIO_REC_PROP                  2606
#define IDH_SPEAKERS_PICKER                     2607
#define IDH_SPEAKERS_IMAGE                      2608
#define IDH_CD_CDROM_VOLUME                     2609

//////////////
// Help ID's for advanced Voice dialog
//////////////

#define IDH_VOICE_SPEAKERICON                   2624
#define IDH_VOICE_LAUNCH_VOCVOL                 2623
#define IDH_VOICE_PLAYBACK_ADVVOC               2627
#define IDH_VOICE_RECORDICON                    2625
#define IDH_VOICE_LAUNCH_CAPVOL                 2622
#define IDH_VOICE_CAPTURE_ADVVOL                2626
#define IDH_VOICE_ADVANCED_TEST                 2621 

#define IDH_SOUNDS_VOL_MUTE_BUTTON              90001
#define IDH_AUDIO_MIDI_VOL                      90002
#define IDH_CDROM_PROPERTIES_DIGITAL	        90003

//////////////
// Generic Help ID for the about dialog box
// Displays in MIDI Music Playback group box, 
// under Audio tab.
//////////////
#define IDH_ABOUT	80000


///////////////////////
//
// Updated: 5-12-00, by Pete Mentele
// New values for additions made by Roger Wynn, inserted by Pete Mentele. 
//
// Using values 2500-2599 for the following items.
//
///////////////////////

// Volume Page
#define IDH_VOLUME_BRAND                        2500
#define IDH_VOLUME_MIXER                        2502
#define IDH_LAUNCH_MULTICHANNEL                 2510

// Multichannel Page
#define IDH_MC_ALL_SLIDERS                      2514
#define IDH_MC_MOVE_TOGETHER                    2560
#define IDH_MC_RESTORE                          2562

// Effects
#define IDH_EFFECT_STATIC                       2584
#define IDH_EFFECT_UP                           2586
#define IDH_EFFECT_DOWN                         2588
#define IDH_EFFECT_PROP                         2590
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\install.h ===
#ifndef INSTALL_H
#define INSTALL_H

///////////////////////////////////////////////////////////////////////////////


#define SECTION         512                   // Maximum size of section
#define MAXSTR          256
#define UNLIST_LINE     1
#define NO_UNLIST_LINE  0
#define WEC_RESTART     0x42
#define DESC_SYS        3
#define DESC_INF        2
#define DESC_EXE        1
#define DESC_NOFILE     0

#define FALLOC(n)                ((VOID *)GlobalAlloc(GPTR, n))
#define FFREE(n)                 GlobalFree(n)
#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
#define FREE(p)                  LocalFree(p)
#define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0

#define MAXFILESPECLEN       MAX_PATH /* drive: + path length max + Null Byte */
#define MAX_INF_LINE_LEN     256      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      256      /* ##: + 8.3 + NULL */
#define MAX_SECT_NAME_LEN    40       /* Max length of a section Name. */
#define MAX_FILE_SPEC        MAX_PATH // 8.3 + X: + NULL.

#define DISK_SECT              TEXT("disks")
#define OEMDISK_SECT           TEXT("oemdisks")

/* Return codes from 'file exists' dialog */

enum {
    CopyNeither,            // User wants to cancel if file exists
    CopyCurrent,            // User wants to use current file
    CopyNew                 // User wants to copy new file
};

#define SLASH(c)     ((c) == TEXT('/')|| (c) == TEXT('\\'))
#define CHSEPSTR                TEXT("\\")
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')

/* Globals and routines for .inf file parsing */

typedef LPTSTR    PINF;

/* Message types for FileCopy callback function */

typedef BOOL (*FPFNCOPY) (int,DWORD_PTR,LPTSTR);
#define COPY_ERROR          0x0001
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006
#define COPY_EXISTS         0x0007

/* Option Flag values for FileCopy */

#define FC_FILE              0x0000
#define FC_LIST              0x0001
#define FC_SECTION           0x0002
#define FC_QUALIFIED         0x0008
#define FC_DEST_QUALIFIED    0x0010
#define FC_LISTTYPE          0x0020
#define FC_CALLBACK_WITH_VER 0x0040

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2
#define FC_ERROR_LOADED_DRIVER  0x80


/*******************************************************************
 *
 * Global Variables
 *
 *******************************************************************/

 // Path to the directory where we found the .inf file

 extern char szSetupPath[MAX_PATH];

 // Path to the user's disk(s)

 extern char szDiskPath[MAX_PATH];   // Path to the default drive -
                                     //
 extern BOOL bRetry;

 // Name of the driver being installed

 extern char szDrv[120];

 //

 extern char szFileError[50];

 // Parent window for file copy dialogues

 extern HWND hMesgBoxParent;

 // TRUE on copying first file to prompt user if file already exists
 // FALSE for subsequent copies

 extern BOOL bQueryExist;

///////////////////////////////////////////////////////////////////////////////

BOOL DefCopyCallback(int msg, DWORD_PTR n, LPTSTR szFile);
UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy, HWND hPar, BOOL fQuery);
LONG TryCopy(LPTSTR, LPTSTR, LPTSTR, FPFNCOPY);
BOOL GetDiskPath(LPTSTR Disk, LPTSTR szPath);
BOOL ExpandFileName(LPTSTR szFile, LPTSTR szPath);
void catpath(LPTSTR path, LPTSTR sz);
LPTSTR FileName(LPTSTR szPath);
LPTSTR RemoveDiskId(LPTSTR szPath);
LPTSTR StripPathName(LPTSTR szPath);
BOOL IsFileKernelDriver(LPTSTR szPath);
UINT ConvertFlagToValue(DWORD dwFlags);
BOOL IsValidDiskette(int iDrive);
BOOL IsDiskInDrive(int iDisk);
BOOL GetInstallPath(LPTSTR szDirOfSrc);
BOOL wsInfParseInit(void);
void wsStartWait();
void wsEndWait();
int fDialog(int id, HWND hwnd, DLGPROC fpfn);
UINT wsCopyError(int n, LPTSTR szFile);
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath);
INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile);
INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
VOID RemoveSpaces(LPTSTR szPath, LPTSTR szEdit);
PINF infLoadFile(int fh);
PINF infOpen(LPTSTR szInf);
void infClose(PINF pinf);
UINT_PTR FindSection(PINF pInf, LPTSTR pszSect);
BOOL fnGetDataString(PINF npszData, LPTSTR szDataStr, LPTSTR szBuf);
PINF infSetDefault(PINF pinf);
PINF infFindSection(PINF pinf, LPTSTR szSection);
BOOL infGetProfileString(PINF pinf, LPTSTR szSection,LPTSTR szItem,LPTSTR szBuf);
BOOL infParseField(PINF szData, int n, LPTSTR szBuf);
int infLineCount(PINF pinf);
PINF infNextLine(PINF pinf);
int infLineCount(PINF pinf);
PINF infFindInstallableDriversSection(PINF pinf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\legcyinf.c ===
#include "mmcpl.h"

#include <tchar.h>
#include <initguid.h>
#include <devguid.h>

#include "drivers.h"
#include "sulib.h"
#include "trayvol.h"
#include "debug.h"

static PTSTR szLocalAllocFailMsg = TEXT("Failed memory allocation\n");

#define GUESS_LEGACY_SERVICE_NAME 0
#define tsizeof(s)  (sizeof(s)/sizeof(TCHAR))

// Generic listnode structure
typedef struct _LISTNODE
{
    struct _LISTNODE *pNext;
} LISTNODE;

// Structure describing a source disk entry
typedef struct _SOURCEDISK
{
    struct _SOURCEDISK *pNext;  // Next source disk in list
    TCHAR szDiskName[_MAX_PATH]; // Description of this disk
    int   DiskId;
} SOURCEDISK;

// Structure describing a file to copy
// We keep a list of these files in two places:
// 1. A global list of all files copied by the inf attached to the LEGACY_INF struct.
// 2. A pair driver-specific lists (user & kernel) attached to the LEGACY_DRIVER struct.
typedef struct _FILETOCOPY
{
    struct _FILETOCOPY *pNext;      // Next file to copy
    TCHAR szFileName[_MAX_FNAME];   // Name of file to copy
    int   DiskId;
} FILETOCOPY;

// Structure representing a legacy driver's information
typedef struct _LEGACY_DRIVER
{
    struct _LEGACY_DRIVER *pNext;

    TCHAR szDevNameKey[32];     // Device name key
    TCHAR szUserDevDrv[32];     // User-level device driver
    TCHAR szClasses[128];       // List of device classes this driver supports
    TCHAR szDesc[128];          // Description of device
    TCHAR szVxD[32];            // Name of VxD driver (not supported)
    TCHAR szParams[128];        // Params (not supported)
    TCHAR szDependency[128];    // Dependent device (not supported)
    FILETOCOPY *UserCopyList;   // List of all user files to copy
    FILETOCOPY *KernCopyList;   // List of all kernel files to copy
} LEGACY_DRIVER;

// Structure representing a legacy inf
typedef struct _LEGACY_INF
{
    struct _LEGACY_INF *pNext;

    TCHAR szLegInfPath[_MAX_PATH];   // Path to original legacy inf
    TCHAR szNewInfPath[_MAX_PATH];   // Path to converted inf
    LEGACY_DRIVER *DriverList;      // List of all drivers in this inf
    SOURCEDISK *SourceDiskList;     // List of all source disks in this inf
    FILETOCOPY *FileList;           // List of all files copied as part of this inf
} LEGACY_INF;

// Root structure for the whole tree
typedef struct _PROCESS_INF_INFO
{
    TCHAR szLegInfDir[_MAX_PATH];    // Directory where legacy infs are located
    TCHAR szNewInfDir[_MAX_PATH];    // Temp directory where new infs are generated
    TCHAR szSysInfDir[_MAX_PATH];    // Windows inf directory
    TCHAR szTemplate[_MAX_PATH];     // Template to search for
    LEGACY_INF *LegInfList;          // List of all infs to be converted
} PROCESS_INF_INFO;

#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
// Debugging routine to dump the contents of a LEGACY_INF list
void DumpLegacyInfInfo(PROCESS_INF_INFO *pPII)
{
    LEGACY_INF *pLI;
    LEGACY_DRIVER *pLD;

    for (pLI=pPII->LegInfList;pLI;pLI=pLI->pNext)
    {
        dlog1("Dumping legacy inf %s\n",pLI->szLegInfPath);

        dlog("Dump of legacy driver info:\n");
        for (pLD=pLI->DriverList; pLD; pLD=pLD->pNext)
        {
            dlog1("DriverNode=0x%x",    pLD);
            dlog1("\tszDevNameKey=%s",  pLD->szDevNameKey);
            dlog1("\tszUserDevDrv=%s",  pLD->szUserDevDrv);
            dlog1("\tszClasses=%s",     pLD->szClasses);
            dlog1("\tszDesc=%s",        pLD->szDesc);
            dlog1("\tszVxD=%s",         pLD->szVxD);
            dlog1("\tszParams=%s",      pLD->szParams);
            dlog1("\tszDependency=%s",  pLD->szDependency);
        }
    }

    return;
}
#else
    #define DumpLegacyInfInfo()
#endif


// Function to remove a directory tree and all its subtrees
void RemoveDirectoryTree(PTSTR szDirTree)
{
    TCHAR  PathBuffer[_MAX_PATH];
    PTSTR CurrentFile;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

	PathBuffer[0] = '\0';

    // Build a file spec to find all files in specified directory
    // (i.e., <DirPath>\*.INF)
    _tcscpy(PathBuffer, szDirTree);
    catpath(PathBuffer,TEXT("\\*"));

    // Get a pointer to the end of the path part of the string
    // (minus the wildcard filename), so that we can append
    // each filename to it.
    CurrentFile = _tcsrchr(PathBuffer, TEXT('\\')) + 1;

    FindHandle = FindFirstFile(PathBuffer, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        // Skip '.' and '..' files, or else we crash!
        if ( (!_tcsicmp(FindData.cFileName,TEXT("."))) ||
             (!_tcsicmp(FindData.cFileName,TEXT(".."))) )
        {
            continue;
        }

        // Build the full pathname.
        _tcscpy(CurrentFile, FindData.cFileName);

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            RemoveDirectoryTree(PathBuffer);
        }
        else
        {
            DeleteFile(PathBuffer);
        }
    } while (FindNextFile(FindHandle, &FindData));

    // Remember to close the find handle
    FindClose(FindHandle);

    // Now remove the directory
    RemoveDirectory(szDirTree);

    return;
}

// Generic routine to free a list
void FreeList(LISTNODE *pList)
{
    LISTNODE *pNext;
    while (pList)
    {
        pNext = pList->pNext;
        LocalFree(pList);
        pList=pNext;
    }

    return;
}

// Routine to free all memory that is part of a PROCESS_INF_INFO struct
void DestroyLegacyInfInfo(PROCESS_INF_INFO *pPII)
{

    LEGACY_INF    *pLIList, *pLINext;
    LEGACY_DRIVER *pLDList, *pLDNext;

    pLIList=pPII->LegInfList;
    while (pLIList)
    {
        pLINext = pLIList->pNext;

        pLDList = pLIList->DriverList;
        while (pLDList)
        {
            pLDNext = pLDList->pNext;

            // Free file copy lists
            FreeList((LISTNODE *)pLDList->UserCopyList);
            FreeList((LISTNODE *)pLDList->KernCopyList);

            // Free Driver node
            LocalFree(pLDList);

            pLDList = pLDNext;
        }

        // Free the source disk list
        FreeList((LISTNODE *)pLIList->SourceDiskList);

        // Free the file list
        FreeList((LISTNODE *)pLIList->FileList);

        // Free up the legacy inf structure
        LocalFree(pLIList);

        pLIList = pLINext;
    }

    // Free the pPII struct
    LocalFree(pPII);

    return;
}

// Searches a file list for a matching entry
FILETOCOPY *FindFile(PTSTR szFileName, FILETOCOPY *pFileList)
{
    FILETOCOPY *pFTC;

    for (pFTC=pFileList;pFTC;pFTC=pFTC->pNext)
    {
        if (!_tcsicmp(szFileName,pFTC->szFileName))
        {
            return pFileList;
        }
    }

    return NULL;
}

// Generic function for adding a file to a copy list
BOOL AddFileToFileList(PTSTR szFileName, int DiskId, FILETOCOPY **ppList)
{
    FILETOCOPY *pFTC;

    // Only add the entry if another one doesn't already exist
    if (!FindFile(szFileName,*ppList))
    {
        pFTC = (FILETOCOPY *)LocalAlloc(LPTR, sizeof(FILETOCOPY));
        if (!pFTC)
        {
            dlogt(szLocalAllocFailMsg);
            return FALSE;
        }

        // Save the fields
        pFTC->DiskId=DiskId;
        _tcscpy(pFTC->szFileName,szFileName);

        // Put it in the list
        pFTC->pNext=(*ppList);
        (*ppList)=pFTC;
    }

    return TRUE;
}

// Add a file to both the global and driver-specific copy lists
BOOL AddFileToCopyList(LEGACY_INF *pLI, LEGACY_DRIVER *pLD, TCHAR *szIdFile)
{
    int DiskId;
    TCHAR *szFileName;

    // szFile has both a disk ID and a file name, e.g. "1:foo.drv"
    // Get the disk ID and file name from szFile
    DiskId = _ttol(szIdFile);
    szFileName = RemoveDiskId(szIdFile);

    // Add the file to the global list
    AddFileToFileList(szFileName,DiskId,&(pLI->FileList));

    // Add the file to the correct driver-specific list
    if (IsFileKernelDriver(szFileName))
    {
        AddFileToFileList(szFileName,DiskId,&(pLD->KernCopyList));
    }
    else
    {
        AddFileToFileList(szFileName,DiskId,&(pLD->UserCopyList));
    }

    return TRUE;
}

// Build the data structure associated with a legacy inf file
// and return a pointer to it, or NULL if failure
LEGACY_INF *CreateLegacyInf(IN PCTSTR szLegInfPath)
{
    HINF hInf;              // Handle to the legacy inf
    INFCONTEXT InfContext;  // Inf context struct for parsing inf file

    LEGACY_INF *pLI;        // Struct describing this inf
    LEGACY_DRIVER *pLDList; // ptrs to drivers in this inf
    LEGACY_DRIVER *pLD;
    TCHAR szIdFile[32];     // Holds <DiskId>:<File> strings, e.g. "1:foo.drv"
    int MediaDescFieldId;

    // Open the inf file
    hInf = SetupOpenInfFile( szLegInfPath, NULL, INF_STYLE_OLDNT, NULL);
    if (hInf==INVALID_HANDLE_VALUE)
    {
        return NULL;
    }

    // Try to open the Installable.drivers32 or Installable.drivers section
    if (!SetupFindFirstLine(  hInf,TEXT("Installable.drivers32"),NULL,&InfContext))
    {
        if (!SetupFindFirstLine(  hInf,TEXT("Installable.drivers"),NULL,&InfContext))
        {
            SetupCloseInfFile(hInf);
            return NULL;
        }
    }

    // Allocate the LEGACY_INF struct which is the root of the data struct
    pLI = (LEGACY_INF *)LocalAlloc(LPTR, sizeof(LEGACY_INF));
    if (!pLI)
    {
        dlogt(szLocalAllocFailMsg);
        SetupCloseInfFile(hInf);
        return NULL;
    }

    // Save off the path to the legacy inf
    _tcscpy(pLI->szLegInfPath, szLegInfPath);

    // Init all other fields to 'safe' values
    pLI->szNewInfPath[0]='\0';
    pLI->DriverList=NULL;
    pLI->SourceDiskList=NULL;
    pLI->FileList=NULL;

    // Build legacy driver list
    pLDList = NULL;
    do
    {
        // Allocate a structure to hold info about this driver
        pLD = (LEGACY_DRIVER *)LocalAlloc(LPTR, sizeof(LEGACY_DRIVER));
        if (!pLD)
        {
            dlogt(szLocalAllocFailMsg);
            break;
        }

        // Init fields
        pLD->UserCopyList=NULL;
        pLD->KernCopyList=NULL;

        // parse the driver installation line
        SetupGetStringField(&InfContext,0,pLD->szDevNameKey,tsizeof(pLD->szDevNameKey),NULL);

        // The user-level driver has a disk id prepended to it. Throw it away.
        SetupGetStringField(&InfContext,1,szIdFile         ,tsizeof(szIdFile) ,NULL);
        _tcscpy(pLD->szUserDevDrv,RemoveDiskId(szIdFile));

        SetupGetStringField(&InfContext,2,pLD->szClasses   ,tsizeof(pLD->szClasses)   ,NULL);
        SetupGetStringField(&InfContext,3,pLD->szDesc      ,tsizeof(pLD->szDesc)      ,NULL);
        SetupGetStringField(&InfContext,4,pLD->szVxD       ,tsizeof(pLD->szVxD)       ,NULL);
        SetupGetStringField(&InfContext,5,pLD->szParams    ,tsizeof(pLD->szParams)    ,NULL);
        SetupGetStringField(&InfContext,6,pLD->szDependency,tsizeof(pLD->szDependency),NULL);

        // Remember to also copy the user-level driver
        AddFileToCopyList(pLI,pLD,szIdFile);

        // Put it into the list
        pLD->pNext = pLDList;
        pLDList = pLD;
    } while (SetupFindNextLine(&InfContext,&InfContext));

    // Status check- did we find any drivers?
    // If not, clean up and get out now!
    if (pLDList==NULL)
    {
        dlog1("CreateLegacyInf: Didn't find any drivers in inf %s\n",szLegInfPath);
        SetupCloseInfFile(hInf);
        LocalFree(pLI);
        return NULL;
    }

    // Save list in Legacy Inf structure
    pLI->DriverList = pLDList;

    // Generate file copy lists
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Now add the other files into the list
        if (SetupFindFirstLine(hInf,pLD->szDevNameKey,NULL,&InfContext))
        {
            do
            {
                SetupGetStringField(&InfContext,0,szIdFile,tsizeof(szIdFile),NULL);
                AddFileToCopyList(pLI,pLD,szIdFile);
            } while (SetupFindNextLine(&InfContext,&InfContext));
        }
    }

    // Generate the SourceDiskList iff we find a section that lists them
    if (SetupFindFirstLine(hInf,TEXT("Source Media Descriptions"),NULL,&InfContext))
    {
        MediaDescFieldId=1;
    }
    else if (SetupFindFirstLine(hInf,TEXT("disks"),NULL,&InfContext))   // Old style
    {
        MediaDescFieldId=2;
    }
    else if (SetupFindFirstLine(hInf,TEXT("disks"),NULL,&InfContext))   // Old style
    {
        MediaDescFieldId=2;
    }
    else
    {
        MediaDescFieldId=0;
    }

    if (MediaDescFieldId)
    {
        do
        {
            SOURCEDISK *pSD;

            TCHAR szDiskId[8];
            pSD = (SOURCEDISK *)LocalAlloc(LPTR, sizeof(SOURCEDISK));
            if (!pSD)
            {
                dlogt(szLocalAllocFailMsg);
                break;
            }

            // Read the disk ID and description
            SetupGetIntField(&InfContext,0,&pSD->DiskId);
            SetupGetStringField(&InfContext,MediaDescFieldId,pSD->szDiskName,tsizeof(pSD->szDiskName),NULL);

            // Put it in the list
            pSD->pNext = pLI->SourceDiskList;
            pLI->SourceDiskList = pSD;
        } while (SetupFindNextLine(&InfContext,&InfContext));
    }

    SetupCloseInfFile(hInf);

    return pLI;
}


// Build a list containing information about all the legacy infs in the specified directory
PROCESS_INF_INFO *BuildLegacyInfInfo(PTSTR szLegacyInfDir, BOOL bEnumSingleInf)
{
    LEGACY_INF *pLegacyInf;
    PROCESS_INF_INFO *pPII;
    TCHAR  PathBuffer[_MAX_PATH];

    dlog1("ProcessLegacyInfDirectory processing directory %s\n",szLegacyInfDir);

    // Allocate a process inf info struct to hold params relating to the conversion process
    pPII = (PROCESS_INF_INFO *)LocalAlloc(LPTR, sizeof(PROCESS_INF_INFO));
    if (!pPII)
    {
        dlogt(szLocalAllocFailMsg);
        return NULL;
    }

    // Get a path to the windows inf directory
    if (!GetWindowsDirectory(pPII->szSysInfDir,tsizeof(pPII->szSysInfDir)))
	{
		DestroyLegacyInfInfo(pPII);
        return NULL;
    }

    catpath(pPII->szSysInfDir,TEXT("\\INF"));

    // Create a temp dir for the new infs under the windows inf directory
    _tcscpy(pPII->szNewInfDir,pPII->szSysInfDir);
    catpath(pPII->szNewInfDir,TEXT("\\MEDIAINF"));

    // If the directory exists, delete it
    RemoveDirectoryTree(pPII->szNewInfDir);

    // Now create it.
    CreateDirectory(pPII->szNewInfDir,NULL);

    // Init list to NULL
    pPII->LegInfList=NULL;

    if (bEnumSingleInf) // If bEnumSingleInf true, szLegacyInfDir points to a single file
    {
        // Grab the path to the directory and store it in pPII->szLegInfDir
        _tcscpy(PathBuffer,szLegacyInfDir);
        _tcscpy(pPII->szLegInfDir,StripPathName(PathBuffer));

        // Load all the information about the legacy inf
        pLegacyInf = CreateLegacyInf(szLegacyInfDir);

        // If no error, link it into the list
        if (pLegacyInf)
        {
            pLegacyInf->pNext = pPII->LegInfList;
            pPII->LegInfList  = pLegacyInf;
        }

    }
    else    // bEnumSingleInf false, szLegacyInfDir points to a directory
    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;
        PTSTR CurrentInfFile;

        // Save path to original infs
        _tcscpy(pPII->szLegInfDir,szLegacyInfDir);

        // Build a file spec to find all INFs in specified directory, i.e., "<DirPath>\*.INF"
        _tcscpy(PathBuffer, szLegacyInfDir);
        catpath(PathBuffer,TEXT("\\*.INF"));

        // Get a pointer to the end of the path part of the string
        // (minus the wildcard filename), so that we can append
        // each filename to it.
        CurrentInfFile = _tcsrchr(PathBuffer, TEXT('\\')) + 1;

        // Search for all the inf files in this directory
        FindHandle = FindFirstFile(PathBuffer, &FindData);
        if (FindHandle != INVALID_HANDLE_VALUE)
        {
            do
            {
                // Build the full pathname.
                _tcscpy(CurrentInfFile, FindData.cFileName);

                // Load all the information about the legacy inf
                pLegacyInf = CreateLegacyInf(PathBuffer);

                // If no error, link it into the list
                if (pLegacyInf)
                {
                    pLegacyInf->pNext = pPII->LegInfList;
                    pPII->LegInfList = pLegacyInf;
                }
            } while (FindNextFile(FindHandle, &FindData));

            // Remember to close the find handle
            FindClose(FindHandle);
        }
    }

    // If we didn't find any drivers, just return NULL.
    if (pPII->LegInfList==NULL)
    {
        DestroyLegacyInfInfo(pPII);
        return NULL;
    }

    return pPII;
}

// Create a unique inf file in the temp directory
// Files will have the name INFxxxx.INF, where xxxx is a value between 0 and 1000
HANDLE OpenUniqueInfFile(PTSTR szDir, PTSTR szNewPath)
{
    HANDLE hInf;
    int Id;

    // Try up to 1000 values before giving up
    for (Id=0;Id<1000;Id++)
    {
        wsprintf(szNewPath,TEXT("%s\\INF%d.inf"),szDir,Id);

        // Setting CREATE_NEW flag will make call fail if file already exists
        hInf = CreateFile(  szNewPath,
                            GENERIC_WRITE|GENERIC_READ,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

        // If we got back a valid handle, we can return
        if (hInf!=INVALID_HANDLE_VALUE)
        {
            return hInf;
        }
    }

    // Never found a valid handle. Give up.
    dlog("OpenUniqueInfFile: Couldn't create unique inf\n");
    return INVALID_HANDLE_VALUE;
}

// Helper function to append one formatted line of text to an open inf
void cdecl InfPrintf(HANDLE hInf, LPTSTR szFormat, ...)
{
    TCHAR Buf[MAXSTRINGLEN];
    int   nChars;

    // format into buffer
    va_list va;
    va_start (va, szFormat);
    nChars = wvsprintf (Buf,szFormat,va);
    va_end (va);

    // Append cr-lf
    _tcscpy(&Buf[nChars],TEXT("\r\n"));
    nChars+=2;

#ifdef UNICODE
    {
        int   mbCount;
        char  mbBuf[MAXSTRINGLEN];

        // Need to converto to mbcs before writing to file
        mbCount = WideCharToMultiByte(  GetACP(),               // code page
                                        WC_NO_BEST_FIT_CHARS,   // performance and mapping flags
                                        Buf,                    // address of wide-character string
                                        nChars,                 // number of characters in string
                                        mbBuf,                  // address of buffer for new string
                                        sizeof(mbBuf),          // size of buffer
                                        NULL,                   // address of default for unmappable characters
                                        NULL                    // address of flag set when default char. used
                                     );

        // Write line out to file
        WriteFile(hInf,mbBuf,mbCount,&mbCount,NULL);
    }
#else
    WriteFile(hInf,Buf,nChars,&nChars,NULL);
#endif

    return;
}

// Creates a new NT5-style inf file in the temporary directory.
BOOL CreateNewInfFile(PROCESS_INF_INFO *pPII, LEGACY_INF *pLI)
{
    SOURCEDISK *pSD;
    TCHAR szTmpKey[_MAX_PATH];
    LEGACY_DRIVER *pLDList, *pLD;
    HANDLE hInf;
    FILETOCOPY *pFTC;

    // Get a pointer to the legacy driver list
    pLDList = pLI->DriverList;

    dlog1("Creating new inf file %s\n",pPII->szNewInfDir);

    hInf = OpenUniqueInfFile(pPII->szNewInfDir, pLI->szNewInfPath);
    if (hInf==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Write out version section
    InfPrintf(hInf,TEXT("[version]"));
    InfPrintf(hInf,TEXT("Signature=\"$WINDOWS NT$\""));
    InfPrintf(hInf,TEXT("Class=MEDIA"));
    InfPrintf(hInf,TEXT("ClassGUID=\"{4d36e96c-e325-11ce-bfc1-08002be10318}\""));
    InfPrintf(hInf,TEXT("Provider=Unknown"));

    // Write out Manufacturer section
    InfPrintf(hInf,TEXT("[Manufacturer]"));
    InfPrintf(hInf,TEXT("Unknown=OldDrvs"));

    // Write out OldDrvs section
    InfPrintf(hInf,TEXT("[OldDrvs]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Create an key to index into the strings section
        // This gives us something like:
        // %foo% = foo
        InfPrintf(hInf,TEXT("%%%s%%=%s"),pLD->szDevNameKey,pLD->szDevNameKey);
    }

    // Write out install section for each device
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // install section header, remember NT only
        InfPrintf(hInf,TEXT("[%s.NT]"),pLD->szDevNameKey);

        // DriverVer entry. Pick a date that's earlier than any NT5 infs
        InfPrintf(hInf,TEXT("DriverVer = 1/1/1998, 4.0.0.0"));

        // Addreg entry
        InfPrintf(hInf,TEXT("AddReg=%s.AddReg"),pLD->szDevNameKey);

        // CopyFiles entry
        InfPrintf(hInf,TEXT("CopyFiles=%s.CopyFiles.User,%s.CopyFiles.Kern"),pLD->szDevNameKey,pLD->szDevNameKey);

        // Reboot entry. Legacy drivers always require a reboot
        InfPrintf(hInf,TEXT("Reboot"));
    }

    // Write out the services section for each device
    // Legacy drivers have a stub services key
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {

        InfPrintf(hInf,TEXT("[%s.NT.Services]"),pLD->szDevNameKey);
#if GUESS_LEGACY_SERVICE_NAME
        // If we install a .sys file, assume that the service name is the same as the filename
        pFTC=pLD->KernCopyList;
        if (pFTC)
        {
            TCHAR szServiceName[_MAX_FNAME];
            lsplitpath(pFTC->szFileName,NULL,NULL,szServiceName,NULL);

            InfPrintf(hInf,TEXT("AddService=%s,0x2,%s_Service_Inst"),szServiceName,szServiceName);
            InfPrintf(hInf,TEXT("[%s_Service_Inst]"),szServiceName);
            InfPrintf(hInf,TEXT("DisplayName    = %%%s%%"),pLD->szDevNameKey);
            InfPrintf(hInf,TEXT("ServiceType    = 1"));
            InfPrintf(hInf,TEXT("StartType      = 1"));
            InfPrintf(hInf,TEXT("ErrorControl   = 1"));
            InfPrintf(hInf,TEXT("ServiceBinary  = %%12%%\\%s"),pFTC->szFileName);
            InfPrintf(hInf,TEXT("LoadOrderGroup = Base"));
        }
        else
        {
            InfPrintf(hInf,TEXT("AddService=,0x2"));
        }
#else
        InfPrintf(hInf,TEXT("AddService=,0x2"));
#endif

    }

    // Write out the AddReg section for each device
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        int nClasses;
        TCHAR szClasses[_MAX_PATH];
        TCHAR *pszState, *pszClass;

        // section header
        InfPrintf(hInf,TEXT("[%s.AddReg]"),pLD->szDevNameKey);
        InfPrintf(hInf,TEXT("HKR,Drivers,SubClasses,,\"%s\""),pLD->szClasses);

        // For safety, copy the string (mystrtok corrupts the original source string)
        _tcscpy(szClasses,pLD->szClasses);
        for (
            pszClass = mystrtok(szClasses,NULL,&pszState);
            pszClass;
            pszClass = mystrtok(NULL,NULL,&pszState)
            )
        {
            InfPrintf(hInf,TEXT("HKR,\"Drivers\\%s\\%s\", Driver,,%s"),         pszClass,pLD->szUserDevDrv,pLD->szUserDevDrv);
            InfPrintf(hInf,TEXT("HKR,\"Drivers\\%s\\%s\", Description,,%%%s%%"),pszClass,pLD->szUserDevDrv,pLD->szDevNameKey);
        }
    }

    // Write out the CopyFiles section for each device for user files
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // section header
        InfPrintf(hInf,TEXT("[%s.CopyFiles.User]"),pLD->szDevNameKey);
        for (pFTC=pLD->UserCopyList;pFTC;pFTC=pFTC->pNext)
        {
            InfPrintf(hInf,TEXT("%s"),pFTC->szFileName);
        }
    }

    // Write out the CopyFiles section for each device for kern files
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // section header
        InfPrintf(hInf,TEXT("[%s.CopyFiles.Kern]"),pLD->szDevNameKey);
        for (pFTC=pLD->KernCopyList;pFTC;pFTC=pFTC->pNext)
        {
            InfPrintf(hInf,TEXT("%s"),pFTC->szFileName);
        }
    }

    // Write out DestinationDirs section
    InfPrintf(hInf,TEXT("[DestinationDirs]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        InfPrintf(hInf,TEXT("%s.CopyFiles.User = 11"),pLD->szDevNameKey);
        InfPrintf(hInf,TEXT("%s.CopyFiles.Kern = 12"),pLD->szDevNameKey);
    }

    // Write out the SourceDisksNames section
    InfPrintf(hInf,TEXT("[SourceDisksNames]"));
    for (pSD=pLI->SourceDiskList;pSD;pSD=pSD->pNext)
    {
        InfPrintf(hInf,TEXT("%d = \"%s\",\"\",1"),pSD->DiskId,pSD->szDiskName);
    }
    // Write out the SourceDisksFiles section
    InfPrintf(hInf,TEXT("[SourceDisksFiles]"));
    for (pFTC=pLI->FileList;pFTC;pFTC=pFTC->pNext)
    {
        InfPrintf(hInf,TEXT("%s=%d"),pFTC->szFileName,pFTC->DiskId);
    }

    // Write out Strings section
    InfPrintf(hInf,TEXT("[Strings]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Create the device description
        InfPrintf(hInf,TEXT("%s=\"%s\""),pLD->szDevNameKey,pLD->szDesc);
    }

    CloseHandle(hInf);

    return TRUE;
}

// Creates a PNF file in the temporary directory to go along with the inf
// This allows us to have the inf file in one directory while the driver's
// files are in a different directory.
BOOL CreateNewPnfFile(PROCESS_INF_INFO *pPII, LEGACY_INF *pLI)
{
    BOOL bSuccess;

    TCHAR szSysInfPath[_MAX_PATH];
    TCHAR szSysPnfPath[_MAX_PATH];
    TCHAR szTmpPnfPath[_MAX_PATH];

    TCHAR szSysInfDrive[_MAX_DRIVE];
    TCHAR szSysInfDir[_MAX_DIR];
    TCHAR szSysInfFile[_MAX_FNAME];

    TCHAR szNewInfDrive[_MAX_DRIVE];
    TCHAR szNewInfDir[_MAX_DIR];
    TCHAR szNewInfFile[_MAX_FNAME];

    // Copy inf to inf directory to create pnf file
    bSuccess = SetupCopyOEMInf(
                              pLI->szNewInfPath,       //    IN  PCSTR   SourceInfFileName,
                              pPII->szLegInfDir,       //    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
                              SPOST_PATH,   //    IN  DWORD   OEMSourceMediaType,
                              0,            //    IN  DWORD   CopyStyle,
                              szSysInfPath, //    OUT PSTR    DestinationInfFileName,         OPTIONAL
                              tsizeof(szSysInfPath),   //    IN  DWORD   DestinationInfFileNameSize,
                              NULL,         //    OUT PDWORD  RequiredSize,                   OPTIONAL
                              NULL          //    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
                              );

    if (!bSuccess)
    {
        dlog1("CreateNewPnfFile: SetupCopyOEMInf failed for inf %s\n",pLI->szNewInfPath);
        return FALSE;
    }

    // Cut apart the directory names
    lsplitpath(szSysInfPath,      szSysInfDrive, szSysInfDir, szSysInfFile, NULL);
    lsplitpath(pLI->szNewInfPath, szNewInfDrive, szNewInfDir, szNewInfFile, NULL);

    // Copy the pnf file back to the original directory
    wsprintf(szSysPnfPath,TEXT("%s%s%s.pnf"), szSysInfDrive, szSysInfDir, szSysInfFile);
    wsprintf(szTmpPnfPath,TEXT("%s%s%s.pnf"), szNewInfDrive, szNewInfDir, szNewInfFile);
    CopyFile(szSysPnfPath, szTmpPnfPath, FALSE);

    // Delete the inf and pnf file in the system inf directory
    DeleteFile(szSysInfPath);
    DeleteFile(szSysPnfPath);

    return TRUE;
}

// Create a new inf file for each legacy inf in the list
BOOL ProcessLegacyInfInfo(PROCESS_INF_INFO *pPII)
{
    LEGACY_INF *pLI;
    BOOL bSuccess;

    for (pLI=pPII->LegInfList;pLI;pLI=pLI->pNext)
    {
        bSuccess = CreateNewInfFile(pPII,pLI);
        if (bSuccess)
        {
            CreateNewPnfFile(pPII,pLI);
        }
    }

    return TRUE;
}

BOOL ConvertLegacyInfDir(PTSTR szLegacyDir, PTSTR szNewDir, BOOL bEnumSingleInf)
{
    PROCESS_INF_INFO *pPII;

    // Couldn't find any NT5-style drivers. Try to find some legacy inf files.
    // Build the list
    pPII = BuildLegacyInfInfo(szLegacyDir, bEnumSingleInf);
    if (!pPII)
    {
        return FALSE;
    }

    // Process the list
    ProcessLegacyInfInfo(pPII);

    if (bEnumSingleInf)
    {
        // if bEnumSingleInf is true, we should return a path to the new inf
        // (there should be exactly one)
        _tcscpy(szNewDir,pPII->LegInfList->szNewInfPath);
    }
    else
    {
        // if bEnumSingleInf is false, we should return a path to the directory
        _tcscpy(szNewDir,pPII->szNewInfDir);
    }

    // Cleanup data structures
    DestroyLegacyInfInfo(pPII);

    return TRUE;
}

int CountDriverInfoList(IN HDEVINFO         DeviceInfoSet,
                        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                        IN DWORD            DriverType
                       )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    int DriverCount = 0;
    int Count = 0;

    // Count the number of drivers in the list
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                 DeviceInfoData,
                                 DriverType,
                                 Count,
                                 &DriverInfoData))
    {
        // Only count drivers which don't have the DNF_BAD_DRIVER flag set
        DriverInstallParams.cbSize=sizeof(DriverInstallParams);
        if (SetupDiGetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams))
        {
            if (!(DriverInstallParams.Flags & DNF_BAD_DRIVER))
            {
                DriverCount++;
            }
        }
        Count++;
    }

    return DriverCount;
}

// Called to display a list of drivers to be installed
DWORD Media_SelectDevice(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
    BOOL bResult;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    int DriverCount;

    // Undocumented: When user selects "Have Disk", setupapi only looks at the
    // class driver list. Therefore, we'll only work with that list
    DWORD DriverType = SPDIT_CLASSDRIVER;

    // Get the path to where the inf files are located
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    bResult = SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // For safety, don't support append mode
    if (DeviceInstallParams.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST)
    {
        return ERROR_DI_DO_DEFAULT;
    }        

    // If not going outside of inf directory, the DriverPath field will be an
    // empty string. In this case, don't do special processing.
    if (DeviceInstallParams.DriverPath[0]=='\0')
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // We're going off to an OEM directory.

    // See if setup can find any NT5-compatible inf files

    // Try to build a driver info list in the current directory
    if (DeviceInfoSet) SetupDiDestroyDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);
    SetupDiBuildDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    // Filter out non NT inf files (e.g. Win9x inf files)
    if (DeviceInfoSet) 
        FilterOutNonNTInfs(DeviceInfoSet,DeviceInfoData,DriverType);

    // Now count the number of drivers
    DriverCount = CountDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    // If we found at least one NT5 driver for this device, just return
    if (DriverCount>0)
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // Didn't find any NT5 drivers.

    // Destroy the existing list
    SetupDiDestroyDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    //Retrieve the device install params prior to setting new INF path and update 
    //any information DeviceInstallParams 
    bResult = SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT;
    }
    // Convert any legacy infs and get back ptr to temp directory for converted infs
    bResult = ConvertLegacyInfDir(DeviceInstallParams.DriverPath, DeviceInstallParams.DriverPath, (DeviceInstallParams.Flags & DI_ENUMSINGLEINF));
    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT; // Didn't find any legacy infs
    }

    //Clean up this DI_FLAGSEX_FILTERSIMILARDRIVERS for old NT 4 driver installation.
    DeviceInstallParams.FlagsEx &=  ~DI_FLAGSEX_FILTERSIMILARDRIVERS;

    // Save new driver path
    bResult = SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    // Note: We don't have to call SetupDiBuildDriverInfoList; setupapi will do that for us
    // with the new path to the infs.
    return ERROR_DI_DO_DEFAULT;
}

BOOL CreateRootDevice( IN     HDEVINFO    DeviceInfoSet,
                       IN     PTSTR       DeviceId,
                       IN     BOOL        bInstallNow
                     )
{
    BOOL                    bResult;
    SP_DEVINFO_DATA         DeviceInfoData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DEVINSTALL_PARAMS    DeviceInstallParams;
    TCHAR                   tmpBuffer[100];
    DWORD                   bufferLen;
    DWORD                   Error;

    // Attempt to manufacture a new device information element for the root enumerated device
    _tcscpy(tmpBuffer,TEXT("ROOT\\MEDIA\\"));
    _tcscat(tmpBuffer,DeviceId);

    dlog2("CreateRootDevice: DeviceId = %s, Device = %s%",DeviceId,tmpBuffer);

    // Try to create the device info
    DeviceInfoData.cbSize = sizeof( DeviceInfoData );
    bResult = SetupDiCreateDeviceInfo( DeviceInfoSet,
                                       tmpBuffer,
                                       (GUID *) &GUID_DEVCLASS_MEDIA,
                                       NULL, // PCTSTR DeviceDescription
                                       NULL, // HWND hwndParent
                                       0,
                                       &DeviceInfoData );
    if (!bResult)
    {
        Error = GetLastError();
        dlog1("CreateRootDevice: SetupDiCreateDeviceInfo failed Error=%x",Error);
        return (Error == ERROR_DEVINST_ALREADY_EXISTS);
    }

    // Set the hardware ID.
    _tcscpy(tmpBuffer, DeviceId);
    bufferLen = _tcslen(tmpBuffer);                 // Get buffer len in chars
    tmpBuffer[bufferLen+1] = TEXT('\0');            // must terminate with an extra null (so we have two nulls)
    bufferLen = (bufferLen + 2) * sizeof(TCHAR);    // Convert buffer length to bytes & add extra for two nulls
    bResult = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                &DeviceInfoData,
                                                SPDRP_HARDWAREID,
                                                (PBYTE)tmpBuffer,
                                                bufferLen );
    if (!bResult) goto CreateRootDevice_err;

    // Setup some flags before building a driver list
    bResult = SetupDiGetDeviceInstallParams( DeviceInfoSet,&DeviceInfoData,&DeviceInstallParams);
    if (bResult)
    {

        _tcscpy( DeviceInstallParams.DriverPath, TEXT( "" ) );
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;
        bResult = SetupDiSetDeviceInstallParams( DeviceInfoSet,&DeviceInfoData,&DeviceInstallParams);
    }

    // Build a compatible driver list for this new device...
    bResult = SetupDiBuildDriverInfoList( DeviceInfoSet,
                                          &DeviceInfoData,
                                          SPDIT_COMPATDRIVER);
    if (!bResult) goto CreateRootDevice_err;

    // Get the first driver on the list
    DriverInfoData.cbSize = sizeof (DriverInfoData);
    bResult = SetupDiEnumDriverInfo( DeviceInfoSet,
                                     &DeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     0,
                                     &DriverInfoData);
    if (!bResult) goto CreateRootDevice_err;

    // Save the device description
    bResult = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                &DeviceInfoData,
                                                SPDRP_DEVICEDESC,
                                                (PBYTE) DriverInfoData.Description,
                                                (_tcslen( DriverInfoData.Description ) + 1) * sizeof( TCHAR ) );
    if (!bResult) goto CreateRootDevice_err;

    // Set the selected driver
    bResult = SetupDiSetSelectedDriver( DeviceInfoSet,
                                        &DeviceInfoData,
                                        &DriverInfoData);
    if (!bResult) goto CreateRootDevice_err;

    // Register the device so it is not a phantom anymore
    bResult = SetupDiRegisterDeviceInfo( DeviceInfoSet,
                                         &DeviceInfoData,
                                         0,
                                         NULL,
                                         NULL,
                                         NULL);
    if (!bResult) goto CreateRootDevice_err;

    return bResult;

    // Error, delete the device info and give up
    CreateRootDevice_err:
    SetupDiDeleteDeviceInfo (DeviceInfoSet, &DeviceInfoData);
    return FALSE;
}

DWORD Media_MigrateLegacy(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )
{
    BOOL bInstallNow = TRUE;

    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMMCI"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMVID"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMACM"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMVCD"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMDRV"), bInstallNow);
    return NO_ERROR;
}

int IsSpecialDriver(HDEVINFO         DeviceInfoSet,
                    PSP_DEVINFO_DATA DeviceInfoData)
{
    BOOL bResult;
    TCHAR HardwareId[32];
    bResult = SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                                DeviceInfoData,
                                                SPDRP_HARDWAREID,
                                                NULL,
                                                (PBYTE)HardwareId,
                                                sizeof(HardwareId),
                                                NULL );

    if (!_tcscmp(HardwareId,TEXT("MS_MMMCI")))
        return IS_MS_MMMCI;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMVID")))
        return IS_MS_MMVID;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMACM")))
        return IS_MS_MMACM;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMVCD")))
        return IS_MS_MMVCD;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMDRV")))
        return IS_MS_MMDRV;
    return 0;
}

BOOL IsPnPDriver(IN PTSTR szName)
{
    LONG lRet;
    HKEY hkClass;

    int  iDriverInst;
    TCHAR szDriverInst[32];
    HKEY hkDriverInst;

    int iDriverType;
    TCHAR szDriverType[32];
    HKEY hkDriverType;

    int iDriverName;
    TCHAR szDriverName[32];

    // Open class key
    hkClass = SetupDiOpenClassRegKey((GUID *) &GUID_DEVCLASS_MEDIA, KEY_READ);
    if (hkClass == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // enumerate each driver instances (e.g. 0000, 0001, etc.)
    for (iDriverInst = 0;
        !RegEnumKey(hkClass, iDriverInst, szDriverInst, sizeof(szDriverInst)/sizeof(TCHAR));
        iDriverInst++)
    {
        // Open the Drivers subkey, (e.g. 0000\Drivers)
        if (lstrlen(szDriverInst) > 23) // 23 is the max length minus "\Drivers" plus a NULL
        {
            continue;
        }
        _tcscat(szDriverInst,TEXT("\\Drivers"));
        lRet = RegOpenKey(hkClass, szDriverInst, &hkDriverInst);
        if (lRet!=ERROR_SUCCESS)
        {
            continue;
        }

        // Enumerate each of the driver types (e.g. wave, midi, mixer, etc.)
        for (iDriverType = 0;
            !RegEnumKey(hkDriverInst, iDriverType, szDriverType, sizeof(szDriverType)/sizeof(TCHAR));
            iDriverType++)
        {

            // Open the driver type subkey
            lRet = RegOpenKey(hkDriverInst, szDriverType, &hkDriverType);
            if (lRet!=ERROR_SUCCESS)
            {
                continue;
            }

            // Enumerate each of the driver names (e.g. foo.drv)
            for (iDriverName = 0;
                !RegEnumKey(hkDriverType, iDriverName, szDriverName, sizeof(szDriverName)/sizeof(TCHAR));
                iDriverName++)
            {

                // Does this name match the one we were passed?
                if (!_tcsicmp(szName,szDriverName))
                {
                    RegCloseKey(hkDriverType);
                    RegCloseKey(hkDriverInst);
                    RegCloseKey(hkClass);
                    return TRUE;
                }
            }
            RegCloseKey(hkDriverType);
        }
        RegCloseKey(hkDriverInst);
    }
    RegCloseKey(hkClass);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\midi.c ===
/*==========================================================================*/
//
//  midi.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
/*==========================================================================*/

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <cpl.h> 
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <string.h>
#include <memory.h>
#include <regstr.h>
#include "draw.h"
#include "utils.h"
#include "roland.h"

#include "midi.h"
#include "tchar.h"

//#include "newexe.h"
#include <winnt.h>

#if defined DEBUG || defined DEBUG_RETAIL
 extern TCHAR szNestLevel[];
 TCHAR szNestLevel[] = TEXT ("0MidiProp:");
 #define MODULE_DEBUG_PREFIX szNestLevel
#endif

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define _INC_MMDEBUG_CODE_ TRUE
#include "mmdebug.h"

#include "medhelp.h"

#ifndef TVIS_ALL
#define TVIS_ALL 0xFF7F // internal
#endif

#ifndef MIDI_IO_CONTROL
#define MIDI_IO_CONTROL 0x00000008L     // internal
#endif

#ifndef DRV_F_ADD       // FEATURE: These should be in MMDDK.H
#define DRV_F_ADD                0x00000000
#define DRV_F_REMOVE             0x00000001
#define DRV_F_CHANGE             0x00000002
#define DRV_F_PROP_INSTR         0x00000004
#define DRV_F_NEWDEFAULTS        0x00000008
#define DRV_F_PARAM_IS_DEVNODE   0x10000000
#endif

/*==========================================================================*/

// containing struct for what would otherwise be global variables
//
struct _globalstate gs;

// this is the registry key that has midi instrument aliases
// as subkeys
//
SZCODE cszSchemeRoot[] =  REGSTR_PATH_PRIVATEPROPERTIES TEXT ("\\MIDI\\Schemes");

SZCODE cszMidiMapRoot[] = REGSTR_PATH_MULTIMEDIA TEXT ("\\MIDIMap");

// this is the registry key that has midi driver/port names
//
SZCODE cszDriversRoot[] = REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

// this is the list of known hindered midi drivers (or rather,
// known drivers that require special idf's)
//
SZCODE cszHinderedMidiList[] = REGSTR_PATH_MEDIARESOURCES TEXT ("\\NonGeneralMIDIDriverList");

SZCODE  cszFriendlyName[]     = TEXT ("FriendlyName");
SZCODE  cszDescription[]      = TEXT ("Description");
SZCODE  cszSlashInstruments[] = TEXT ("\\Instruments");
SZCODE  cszExternal[]         = TEXT ("External");
SZCODE  cszActive[]           = TEXT ("Active");
SZCODE  cszDefinition[]       = TEXT ("Definition");
SZCODE  cszPort[]             = TEXT ("Port");
SZCODE  cszMidiSlash[]        = TEXT ("midi\\");
SZCODE  csz02d[]              = TEXT ("%02d");
SZCODE  cszEmpty[]            = TEXT ("");

static SZCODE cszChannels[]            = TEXT ("Channels");
static SZCODE cszCurrentScheme[]       = TEXT ("CurrentScheme");
static SZCODE cszCurrentInstrument[]   = TEXT ("CurrentInstrument");
static SZCODE cszUseScheme[]           = TEXT ("UseScheme");
static SZCODE cszAutoScheme[]          = TEXT ("AutoScheme");
static SZCODE cszRunOnceCount[]        = TEXT ("ConfigureCount");
static SZCODE cszDriverList[]          = TEXT ("DriverList");
static SZCODE cszDriverVal[]           = TEXT ("Driver");

//
// structures used to hold data for the control panel dialogs.
//
//
typedef struct _midi_scheme {
    PMCMIDI  pmcm;
    HKEY     hkSchemes;
    TCHAR    szNone[MAX_ALIAS];
    DWORD    dwChanMask;
    TCHAR    szName[MAX_ALIAS];
    UINT     nChildren;
    BOOL     bDirty;
    struct {
	PINSTRUM  pi;
	DWORD     dwMask;
	} a[NUM_CHANNEL*4 +1];
    } MSCHEME, * PMSCHEME;

typedef struct _midi_cpl {
    LPPROPSHEETPAGE ppsp;

    MSCHEME         ms;
    TCHAR           szScheme[MAX_ALIAS];
    TCHAR           szDefault[MAX_ALIAS];
    PINSTRUM        piSingle;
    BOOL            bUseScheme;
    BOOL            bAutoScheme;  // TRUE if scheme was auto created
    DWORD           dwRunCount;   // counts the number of times runonce
    LPTSTR           pszReason;    // reason for choosing external port
    BOOL            bDlgType2;
    BOOL            bPastInit;
    BOOL            bIgnoreSelChange;

    MCMIDI          mcm;

    } MCLOCAL, * PMCLOCAL;

BOOL WINAPI ShowDetails (
    HWND     hWnd,
    PMCLOCAL pmcl);

LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey);

static UINT
DeviceIDFromDriverName(
    PTSTR pstrDriverName);

extern BOOL AccessServiceController(void);

/*+ SimulateNotify
 *
 *-=================================================================*/

STATICFN LRESULT SimulateNotify (
    HWND hWnd,
    WORD uId,
    WORD wNotify)
{
    #ifdef _WIN32
     return SendMessage (hWnd, WM_COMMAND,
			 MAKELONG(uId, wNotify),
			 (LPARAM)GetDlgItem (hWnd, uId));
    #else
    #error this code is not designed for 16 bits
    #endif
}


/*+ Confirm
 *
 *-=================================================================*/

STATICFN UINT Confirm (
    HWND    hWnd,
    UINT    idQuery,
    LPTSTR  pszArg)
{
    TCHAR szQuery[255];
    TCHAR sz[255];

    LoadString (ghInstance, idQuery, sz, NUMELMS(sz));
    wsprintf (szQuery, sz, pszArg);

    LoadString (ghInstance, IDS_DEF_CAPTION, sz, NUMELMS(sz));

    return MessageBox (hWnd, szQuery, sz, MB_YESNO | MB_ICONQUESTION);
}


/*+ TellUser
 *
 *-=================================================================*/

STATICFN UINT TellUser (
    HWND    hWnd,
    UINT    idQuery,
    LPTSTR  pszArg)
{
    TCHAR szQuery[255];
    TCHAR sz[255];

    LoadString (ghInstance, idQuery, sz, NUMELMS(sz));
    wsprintf (szQuery, sz, pszArg);

    LoadString (ghInstance, IDS_DEF_CAPTION, sz, NUMELMS(sz));

    return MessageBox (hWnd, szQuery, sz, MB_OK | MB_ICONINFORMATION);
}



/*+ ForwardBillNotify
 *
 *-=================================================================*/

STATICFN void ForwardBillNotify (
    HWND  hWnd,
    NMHDR FAR * lpnm)
{
    static struct {
	UINT code;
	UINT uId;
	} amap[] = {PSN_KILLACTIVE, IDOK,
		    PSN_APPLY,      ID_APPLY,
		    PSN_SETACTIVE,  ID_INIT,
		    PSN_RESET,      IDCANCEL,
		    };
    UINT ii;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("ForwardBillNotify() code = %X\r\n"), lpnm->code);
#endif

    for (ii = 0; ii < NUMELMS(amap); ++ii)
	if (lpnm->code == amap[ii].code)
	{
	    FORWARD_WM_COMMAND (hWnd, amap[ii].uId, 0, 0, SendMessage);
	    break;
	}
    return;
}


/*+
 *
 *-=================================================================*/

STATICFN void EnumChildrenIntoCombo (
    HWND   hWndT,
    LPTSTR pszSelect,
    HKEY   hKey)
{
    TCHAR  sz[MAX_ALIAS];
    DWORD  cch = sizeof(sz)/sizeof(TCHAR);
    UINT   ii = 0;

    //SetWindowRedraw (hWndT, FALSE);
    ComboBox_ResetContent (hWndT);

    if (!hKey)
	return;

    while (RegEnumKey (hKey, ii, sz, cch) == ERROR_SUCCESS)
    {
	int ix = ComboBox_AddString (hWndT, sz);
	//ComboBox_SetItemData (hWndT, ix, ii);
	++ii;
    }

    ii = 0;
    if (pszSelect)
       ii = ComboBox_FindString (hWndT, -1, pszSelect);

    ComboBox_SetCurSel (hWndT, ii);
}

STDAPI_(BOOL) QueryGSSynth(LPTSTR pszDriver)
{
    MIDIOUTCAPS moc;
    MMRESULT    mmr;
    UINT        mid;
    BOOL        fGSSynth = FALSE;

    
    if (pszDriver)
    {
        mid = DeviceIDFromDriverName(pszDriver);

        if (mid!=(UINT)-1)
        {
            mmr = midiOutGetDevCaps(mid, &moc, sizeof(moc));

            if (MMSYSERR_NOERROR == mmr)
            {
                if ((moc.wMid == MM_MICROSOFT) && (moc.wPid == MM_MSFT_WDMAUDIO_MIDIOUT) && (moc.wTechnology == MOD_SWSYNTH))
                {
                    fGSSynth = TRUE;
                } //end if synth
            } //end if no mm error
        } //end if mid is valid
    } //end if driver is valid string

    return(fGSSynth);
}

/*+
 *
 *-=================================================================*/

LONG WINAPI GetAlias (
    HKEY   hKey,
    LPTSTR szSub,
    LPTSTR pszAlias,
    DWORD  cchAlias,
    BOOL * pbExtern,
    BOOL * pbActive)
{
    LONG  lRet;
    DWORD cbSize;
    HKEY  hkSub;
    DWORD dw;

#ifdef DEBUG
    AuxDebugEx (8, DEBUGLINE TEXT ("GetAlias(%08x,'%s',%08x,%d,%08x)\r\n"),
		hKey, szSub, pszAlias, cchAlias, pbExtern);
#endif

    if (!(lRet = RegOpenKeyEx (hKey, szSub, 0, KEY_QUERY_VALUE, &hkSub)))
    {
	cbSize = cchAlias * sizeof (TCHAR);
	if ((lRet = RegQueryValueEx (hkSub, cszFriendlyName, NULL, &dw, (LPBYTE)pszAlias, &cbSize)) || cbSize <= 2)
	{
	    cbSize = cchAlias * sizeof (TCHAR);
	    if ((lRet = RegQueryValueEx (hkSub, cszDescription, NULL, &dw, (LPBYTE)pszAlias, &cbSize)) || cbSize <= 2)
	    {
		TCHAR szDriver[MAXSTR];

		cbSize = sizeof(szDriver);
		if (!RegQueryValueEx(hkSub, cszDriverVal, NULL, &dw, (LPBYTE)szDriver, &cbSize))
		{
		    LoadVERSION();
		    if (!LoadDesc(szDriver, pszAlias))
			lstrcpy(pszAlias, szDriver);
		    FreeVERSION();

		    cbSize = (lstrlen(pszAlias)+1) * sizeof(TCHAR);
		    RegSetValueEx(hkSub, cszFriendlyName, (DWORD)0, REG_SZ, (LPBYTE)pszAlias, cbSize);
		    RegSetValueEx(hkSub, cszDescription, (DWORD)0, REG_SZ, (LPBYTE)pszAlias, cbSize);
		}
		else
		    pszAlias[0] = 0;
	    }
	}

	if (pbExtern)
	{
	    *pbExtern = 0;
	    cbSize = sizeof(*pbExtern);
	    if (!(lRet = RegQueryValueEx (hkSub, cszExternal, NULL, &dw, (LPBYTE)pbExtern, &cbSize)))
	    {
		if (REG_SZ == dw)
		    *pbExtern = (*(LPTSTR)pbExtern == TEXT('0')) ? FALSE : TRUE;
	    }
	}

	if (pbActive)
	{
	    *pbActive = 0;
	    cbSize = sizeof(*pbActive);
	    if (!(lRet = RegQueryValueEx (hkSub, cszActive, NULL, &dw, (LPBYTE)pbActive, &cbSize)))
	    {
		if (REG_SZ == dw)
		    *pbActive = (*(LPTSTR)pbActive == TEXT('1')) ? TRUE : FALSE;
	    }
	}

	RegCloseKey (hkSub);
    }

   #ifdef DEBUG
    if (lRet)
    {
	TCHAR szErr[MAX_PATH];

	FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lRet, 0,
		      szErr, NUMELMS(szErr), NULL);

#ifdef DEBUG
	AuxDebugEx (1, DEBUGLINE TEXT ("GetAlias failed: %d %s\r\n"), lRet, szErr);
#endif
    }
   #endif

    return lRet;
}


/*+
 *
 *-=================================================================*/

LONG WINAPI GetDriverFilename (
    HKEY    hKey,
    LPTSTR  szSub,
    LPTSTR  pszDriver,
    DWORD   cchDriver)
{
    HKEY  hkSub;
    LONG  lRet;

    if (!(lRet = RegOpenKeyEx (hKey, szSub, 0, KEY_QUERY_VALUE, &hkSub)))
    {
       DWORD dwType;
       TCHAR sz[MAX_PATH];
       UINT  cb = sizeof(sz);

       // get the contents of the 'driver' value of the given key.
       // then copy the filename part
       //
       lRet = RegQueryValueEx(hkSub, cszDriverVal, NULL, &dwType, (LPBYTE)sz, &cb);
       if (lRet || dwType != REG_SZ)
	   *pszDriver = 0;
       else
       {
	   LPTSTR psz = sz;
	   UINT   ii;

	   // scan forward till we get to the file part of the pathname
	   // then copy that part into the supplied buffer
	   //
	   for (ii = 0; psz[ii]; )
	   {
		if (psz[ii] == TEXT('\\') || psz[ii] == TEXT(':'))
		{
		    psz += ii+1;
		    ii = 0;
		}
		else
		    ++ii;
	   }
	   lstrcpyn (pszDriver, psz, cchDriver);
       }
       RegCloseKey (hkSub);
    }
    return lRet;
}


/*+ LoadInstruments
 *
 * load interesting data for all instruments, if bDriverAsAlias
 * is true, then put driver filename in szFriendly field of each
 * instrument. (scheme init uses this for hindered driver detection)
 * if !bDriverAsAlias, put friendly name in friendly name slot
 *
 *
 *-=================================================================*/

void WINAPI LoadInstruments (
    PMCMIDI pmcm,
    BOOL    bDriverAsAlias)
{
    HKEY     hkMidi;
    TCHAR    sz[MAX_ALIAS];
    DWORD    cch = sizeof(sz)/sizeof(TCHAR);
    UINT     ii;
    UINT     nInstr;
    PINSTRUM pi;
    UINT     idxPort = 0;

    pmcm->nInstr = 0;
    pmcm->bHasExternal = FALSE;

    if (!(hkMidi = pmcm->hkMidi))
    {
	if (RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &hkMidi))
	    return;
	pmcm->hkMidi = hkMidi;
    }

    if (!(pi = pmcm->api[0]))
    {
	pmcm->api[0] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
	if (!pi)
	    return;
    }

    for (cch = sizeof(pi->szKey)/sizeof(TCHAR), nInstr = 0, ii = 0;
	 ! RegEnumKey (hkMidi, ii, pi->szKey, cch);
	 ++ii)
    {
	UINT        jj;
	HKEY        hkInst;
	PINSTRUM    piParent;
	BOOL        bActive = FALSE;

	// get driver alias, external, and active flags.  This has the side
	// effect of initializing the friendly name key for legacy drivers
	// that have neither friendly name, nor description
	//
	GetAlias (hkMidi, pi->szKey, pi->szFriendly, 
		  NUMELMS(pi->szFriendly), &pi->bExternal, &bActive);

	// if requested, stomp friendly name with driver filename
	//
	if (bDriverAsAlias)
	    GetDriverFilename (hkMidi, pi->szKey, 
			       pi->szFriendly, NUMELMS(pi->szFriendly));

    pi->fGSSynth = QueryGSSynth(pi->szKey);
    pi->uID = idxPort;

	if (pi->bExternal)
	    pmcm->bHasExternal = TRUE;

	pi->piParent = 0;
	pi->bActive = bActive;
	piParent = pi;

	++nInstr;
	if (nInstr >= NUMELMS(pmcm->api))
	{
	    assert2 (0, TEXT ("Tell JohnKn to make midi instrument table bigger"));
	    break;
	}

	if (!(pi = pmcm->api[nInstr]))
	{
	    pmcm->api[nInstr] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
	    if (!pi)
		break;
	}

	// open the parent's instruments subkey
	//
	lstrcpy (sz, piParent->szKey);
	lstrcat (sz, cszSlashInstruments);
	if (RegCreateKey (hkMidi, sz, &hkInst))
	    continue;

	// enum the instruments and add them to the list
	//
	for (jj = 0; ! RegEnumKey (hkInst, jj, sz, cch); ++jj)
	{
	    lstrcpy (pi->szKey, piParent->szKey);
	    lstrcat (pi->szKey, cszSlashInstruments);
	    lstrcat (pi->szKey, cszSlash);
	    lstrcat (pi->szKey, sz);

	    GetAlias (hkInst, sz, pi->szFriendly, 
		      NUMELMS(pi->szFriendly), NULL, NULL);
	    pi->piParent = piParent;
	    pi->bExternal = FALSE;
	    pi->bActive = bActive;

	    ++nInstr;
	    if (nInstr >= NUMELMS(pmcm->api))
	    {
		assert2 (0, TEXT ("Tell JohnKn to make midi instrument table bigger"));
		break;
	    }

	    if (!(pi = pmcm->api[nInstr]))
	    {
		pmcm->api[nInstr] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
		if (!pi)
		    break;
	    }
	}

	RegCloseKey (hkInst);
    }

    // create a 'none' entry at the end
    //
    if (pi)
    {
	pi->piParent = 0;
	pi->bExternal = FALSE;
	pi->bActive = TRUE;
	pi->szKey[0] = 0;
	LoadString (ghInstance, IDS_NONE, pi->szFriendly, NUMELMS(pi->szFriendly));
	++nInstr;
    }

    pmcm->nInstr = nInstr;
}


/*+
 *
 *-=================================================================*/

void WINAPI FreeInstruments (
    PMCMIDI pmcm)
{
    UINT ii;

    for (ii = 0; ii < NUMELMS (pmcm->api); ++ii)
	if (pmcm->api[ii])
	    LocalFree ((HLOCAL)(PVOID)pmcm->api[ii]), pmcm->api[ii] = NULL;

    pmcm->nInstr = 0;
}



#ifdef DEBUG
/*+ CleanStringCopy
 *
 * Replaces unprintable characters with '.'
 *
 *-=================================================================*/

STATICFN LPTSTR CleanStringCopy (
    LPTSTR pszOut,
    LPTSTR pszIn,
    UINT   cbOut)
{
    LPTSTR psz = pszOut;
    while (cbOut && *pszIn)
    {
	*psz = (*pszIn >= 32 && *pszIn < 127) ? *pszIn : TEXT('.');
	++psz;
	++pszIn;
    }

    *psz = 0;
    return pszOut;
}


/*+ DumpInstruments
 *
 *-=================================================================*/

STATICFN void DumpInstruments (
    PMCMIDI pmcm)
{
    UINT     ii;
    PINSTRUM pi;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("DumpInstruments(%08x) nInstr=%d\r\n"),
		pmcm, pmcm->nInstr);
#endif

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	TCHAR szKey[MAX_ALIAS];
	TCHAR szFriendly[MAX_ALIAS];

	pi = pmcm->api[ii];
	if (!pi)
	{
#ifdef DEBUG
	    AuxDebugEx (2, TEXT ("\tapi[%d] NULL\r\n"), ii);
#endif
	    continue;
	}

	CleanStringCopy (szKey, pi->szKey, NUMELMS(szKey));
	CleanStringCopy (szFriendly, pi->szFriendly, NUMELMS(szFriendly));

#ifdef DEBUG
	AuxDebugEx (3, TEXT ("\tapi[%d]%08X p:%08x x:%d a:%d '%s' '%s'\r\n"),
		    ii, pi, pi->piParent,
		    pi->bExternal, pi->bActive,
		    szKey, szFriendly);
#endif
    }
}
#endif


/*+
 *
 *-=================================================================*/

STATICFN PINSTRUM WINAPI FindInstrumPath (
    PMCMIDI pmcm,
    LPTSTR   pszPath)
{
    UINT  ii;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	assert (pmcm->api[ii]);
	if (IsSzEqual(pszPath, pmcm->api[ii]->szKey))
	    return pmcm->api[ii];
    }

    return NULL;
}


/*+
 *
 *-=================================================================*/

PINSTRUM WINAPI FindInstrumentFromKey (
    PMCMIDI  pmcm,
    LPTSTR   pszKey)
{
    UINT  ii;

    if (!pszKey || !pszKey[0])
	return NULL;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	assert (pmcm->api[ii]);
	if (IsSzEqual(pszKey, pmcm->api[ii]->szKey))
	    return pmcm->api[ii];
    }

    return NULL;
}



/*+
 *
 *-=================================================================*/

STATICFN void LoadInstrumentsIntoCombo (
    HWND     hWnd,
    UINT     uId,
    PINSTRUM piSelect,
    PMCMIDI  pmcm)
{
    HWND   hWndT = GetDlgItem (hWnd, uId);
    UINT   ii;
    int    ix;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("LoadInstrumentsIntoCombo(%08X,%d,%08x,%08x)\r\n"),
		hWnd, uId, piSelect, pmcm);
#endif

    assert (hWndT);
    if (!hWndT)
	return;

    if (pmcm->nInstr > 0)
	SetWindowRedraw (hWndT, FALSE);
    ComboBox_ResetContent(hWndT);

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	if (ii == pmcm->nInstr-1)
	   SetWindowRedraw (hWndT, TRUE);

	if (pmcm->api[ii]->bActive
       #ifdef EXCLUDE_EXTERNAL
	    && !pmcm->api[ii]->bExternal
       #endif
	   )
	{
#ifdef DEBUG
	    AuxDebugEx (7, DEBUGLINE TEXT ("Instrument[%d] = '%s'\r\n"),
			ii, pmcm->api[ii]->szFriendly);
#endif

	    ix = ComboBox_AddString (hWndT, pmcm->api[ii]->szFriendly);
	    ComboBox_SetItemData (hWndT, ix, (LPARAM)pmcm->api[ii]);

	    if (piSelect && pmcm->api[ii] == piSelect)
		ComboBox_SetCurSel (hWndT, ix);
	}
    }
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadInstrumentsIntoTree (
    HWND     hWnd,
    UINT     uId,
    UINT     uIdSingle,
    PINSTRUM piSelect,
    PMCLOCAL pmcl)
{
    PMCMIDI   pmcm = &pmcl->mcm;
    HWND      hWndT = GetDlgItem (hWnd, uId);
    UINT      ii;
    HTREEITEM htiSelect = NULL;
    HTREEITEM htiParent = TVI_ROOT;

    assert (hWndT);
    if (!hWndT)
	return;

    #ifdef UNICODE
    TreeView_SetUnicodeFormat(hWndT,TRUE);
    #endif

    //if (pmcm->nInstr > 0)
    //    SetWindowRedraw (hWndT, FALSE);
    pmcl->bIgnoreSelChange = TRUE;
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_DeleteAllItems(%08X)\r\n"), hWndT);
#endif
    TreeView_DeleteAllItems(hWndT);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_DeleteAllItems(%08X) ends\r\n"), hWndT);
#endif

    pmcl->bIgnoreSelChange = FALSE;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	PINSTRUM        pi = pmcm->api[ii];
	TV_INSERTSTRUCT ti;
	HTREEITEM       hti;

	//if (ii == pmcm->nInstr-1)
	//   SetWindowRedraw (hWndT, TRUE);

	if (!pi->szKey[0] || !pi->bActive)
	    continue;

	ZeroMemory (&ti, sizeof(ti));

	ti.hParent = TVI_ROOT;
	if (pi->piParent)
	    ti.hParent = htiParent;

	ti.hInsertAfter   = TVI_SORT;
	ti.item.mask      = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;

	// TV_ITEM may not be ported to UNICODE ?!?
	ti.item.pszText   = pi->szFriendly;
	ti.item.state     = TVIS_EXPANDED;
	ti.item.stateMask = TVIS_ALL;
	ti.item.lParam    = (LPARAM)pi;

	hti = TreeView_InsertItem (hWndT, &ti);

	if (piSelect && (piSelect == pi))
	   htiSelect = hti;

	if ( ! pi->piParent)
	    htiParent = hti;
    }

    // if a 'single' control id has been specified, propagate
    // selected item text into this control
    //
    if (uIdSingle)
    {
	if (htiSelect)
	{
	    assert (piSelect);
	    TreeView_SelectItem (hWndT, htiSelect);
	    SetDlgItemText (hWnd, uIdSingle, piSelect->szFriendly);
        EnableWindow(GetDlgItem(hWnd, IDC_ABOUTSYNTH), piSelect->fGSSynth);
	}
	else
	    SetDlgItemText (hWnd, uIdSingle, cszEmpty);
    }

}


/*+
 *
 *-=================================================================*/

STATICFN void LoadSchemesIntoCombo (
    HWND     hWnd,
    UINT     uId,
    LPTSTR   pszSelect,
    PMSCHEME pms)
{
    HWND  hWndT = GetDlgItem (hWnd, uId);
    HKEY  hKey;

    assert (hWndT);
    if (!hWndT)
	return;

    hKey = pms->hkSchemes;
    if (!hKey &&
	!RegCreateKey (HKEY_LOCAL_MACHINE, cszSchemeRoot, &hKey))
	pms->hkSchemes = hKey;

    EnumChildrenIntoCombo (hWndT, pszSelect, hKey);
}


/*+ ChildKeyExists
 *
 * given an open registry key, and the name of a child of that
 * registry key,  returns true if a child key with the given
 * name exists.
 *
 *-=================================================================*/

STATICFN BOOL ChildKeyExists (
    HKEY     hKey,
    LPTSTR   pszChild)
{
    TCHAR  sz[MAX_ALIAS];
    UINT   ii;

    if (!hKey)
	return FALSE;

    for (ii = 0; ! RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
	if (IsSzEqual (pszChild, sz))
	    return TRUE;
    }

    return FALSE;
}


/*+ LoadSchemeFromReg
 *
 *-=================================================================*/

STATICFN void LoadSchemeFromReg (
    PMCMIDI   pmcm,
    PMSCHEME  pms,
    LPTSTR    pszName)
{
    HKEY  hKey;
    DWORD dwAccum;
    UINT  count;

    // try to open the indicated scheme key in the registry
    // and read channel map from it.  Failure here is permissible.
    // it indicates that we are createing a new scheme.
    //
    count = 0;
    if (RegOpenKey (pms->hkSchemes, pszName, &hKey) == ERROR_SUCCESS)
    {
	DWORD cb;
	TCHAR sz[MAX_ALIAS];

	while (RegEnumKey (hKey, count, sz, sizeof(sz)/sizeof(TCHAR)) == ERROR_SUCCESS)
	{
	    HKEY  hKeyA;
	    DWORD dwType;

	    if (RegOpenKey (hKey, sz, &hKeyA) != ERROR_SUCCESS)
		    break;

	    pms->a[count].pi = NULL;
	    cb = sizeof(sz);
	    if ( ! RegQueryValue (hKeyA, NULL, sz, &cb))
		    pms->a[count].pi = FindInstrumPath (pmcm, sz);

	    pms->a[count].dwMask = 0;
	    cb = sizeof(pms->a[count].dwMask);
	    RegQueryValueEx (hKeyA, cszChannels, NULL,
			     &dwType, (LPBYTE)&pms->a[count].dwMask, &cb);

	    assert (dwType == REG_DWORD);

	    RegCloseKey (hKeyA);

        // Don't allow empty entries
	    //assert (pms->a[ii].dwMask);
        if (0 == pms->a[count].dwMask)
        {
    	    pms->a[count].pi = NULL;
        }
        
        ++count;

#ifdef DEBUG
	    AuxDebugEx (4, DEBUGLINE TEXT ("[%d]Chan %08X Alias '%s'\r\n"),
			count, pms->a[count].dwMask, pms->a[count].pi
					       ? pms->a[count].pi->szFriendly
					       : TEXT ("(null)"));
#endif
	    if (count == NUMELMS(pms->a) -1)
		    break;
	}

	RegCloseKey (hKey);
    }
    pms->nChildren = count;
    lstrcpyn (pms->szName, pszName, NUMELMS(pms->szName));

    // slam a dummy (none) alias that matches all channels
    // at the end of our channel/alias list
    //
    assert (count < NUMELMS(pms->a));
    pms->a[count].dwMask = (DWORD)~0;
    pms->a[count].pi = NULL;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("[%d]Chan %08X Alias '%s'\r\n"),
		count, pms->a[count].dwMask, "null");
#endif

    // make sure scheme channel masks are in a valid state
    //
    for (dwAccum = 0, count = 0; count < NUMELMS(pms->a); ++count)
    {
	pms->a[count].dwMask &= ~dwAccum;
	dwAccum |= pms->a[count].dwMask;
    }

    return;
}


/*+ KickMapper
 *
 *-=================================================================*/


void WINAPI KickMapper (
    HWND hWnd)
{
    HMIDIOUT  hmo;

    if (! midiOutOpen(&hmo, MIDI_MAPPER, 0, 0, MIDI_IO_CONTROL))
    {
	BOOL bDone;

#ifdef DEBUG
	AuxDebugEx (2, DEBUGLINE TEXT ("Kicking Midi Mapper\r\n"));
#endif

	bDone = midiOutMessage(hmo, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_PROP_INSTR);
	
	midiOutClose(hmo);
    /*
    //no longer necessary due to winmm change allowing configure during play
	if (!bDone && hWnd)
	    TellUser (hWnd, IDS_MAPPER_BUSY, NULL);
    */
    }

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("Done Kicking Midi Mapper\r\n"));
#endif
}


/*+ SaveSchemeToReg
 *
 *-=================================================================*/

STATICFN void SaveSchemeToReg (
    PMCMIDI   pmcm,
    PMSCHEME  pms,
    LPTSTR    pszName,
    HWND      hWnd)
{
    TCHAR sz[MAX_ALIAS];
    HKEY  hKey;
    DWORD dwAccum;
    UINT  ii;
    UINT  kk;
    UINT  cb;

    #ifdef DEBUG
     AuxDebugEx (4, DEBUGLINE TEXT ("Saving Scheme '%s' children=%d\r\n"),
		 pszName, pms->nChildren);
     for (ii = 0; ii < NUMELMS(pms->a); ++ii)
     {
	 AuxDebugEx (4, TEXT ("\t%08X '%s'\r\n"),
		     pms->a[ii].dwMask,
		     pms->a[ii].pi ? pms->a[ii].pi->szKey : TEXT ("(null)"));
     }
    #endif

    // make sure scheme channel masks are in a valid state,
    // that is, prevent a channel bit from being set in more
    // than one member of a scheme
    //
    for (dwAccum = 0, ii = 0; ii < NUMELMS(pms->a); ++ii)
    {
	pms->a[ii].dwMask &= ~dwAccum;
	dwAccum |= pms->a[ii].dwMask;
    }

    // try to open/create the indicated scheme key in the registry
    // and write/update channel map to it.
    //
    if (!RegCreateKey (pms->hkSchemes, pszName, &hKey))
    {
	HKEY  hKeyA;
	BOOL  bKill;

	// salvage all of the existing keys that we can. delete
	// the rest.
	//
	for (dwAccum = 0, ii = 0; !RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
	{
	    if (ii >= NUMELMS(pms->a))
		break;

	    // we reuse the first N keys in this scheme
	    // and delete the rest.
	    //
	    bKill = TRUE;
	    if (((dwAccum & 0xFFFF) != 0xFFFF) &&
		pms->a[ii].pi &&
		(!ii || (pms->a[ii].pi->szKey[0] && pms->a[ii].dwMask)))
	       bKill = FALSE;

	    dwAccum |= pms->a[ii].dwMask;

	    // if we have an obsolete alias key, remove it now
	    // otherwise create/open the alias key and set it's
	    // channel property to the correct value.
	    //
	    if (bKill)
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key[%d] '%s'\r\n"), ii, sz);
#endif
		RegDeleteKey (hKey, sz);
	    }
	    else
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Reusing key[%d] '%s'\r\n"), ii, pms->a[ii].pi->szKey);
#endif
		if (RegOpenKeyEx (hKey, sz, 0, KEY_ALL_ACCESS, &hKeyA))
		    break;


		cb = (lstrlen(pms->a[ii].pi->szKey) + 1) * sizeof(TCHAR);
		RegSetValueEx (hKeyA, NULL, 0, REG_SZ,
			       (LPBYTE)(pms->a[ii].pi->szKey), cb);

		RegSetValueEx (hKeyA, cszChannels, 0,
			       REG_DWORD,
			       (LPBYTE)&pms->a[ii].dwMask,
			       sizeof(DWORD));

		RegCloseKey (hKeyA);
	    }

	}

	// if we have channels that have not yet been written.
	// do that now
	//
	for (kk = 0; ii < NUMELMS(pms->a); ++ii)
	{
	    // if this alias has any assigned channels, create
	    // a key and give it a channels value
	    //
	    if (pms->a[ii].pi &&
		(!ii || (pms->a[ii].pi->szKey[0] && pms->a[ii].dwMask)))
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Creating key[%d] '%s'\r\n"), ii, pms->a[ii].pi->szKey);
#endif
		// find an unused keyname;
		//
		for ( ; kk < NUMELMS(pms->a); ++kk)
		{
		   wsprintf (sz, csz02d, kk);
		   if (RegOpenKey (hKey, sz, &hKeyA))
		       break;
		   RegCloseKey (hKeyA);
		}

		// create a key with that name
		//
		if (RegCreateKey (hKey, sz, &hKeyA))
		    break;

		cb = (lstrlen(pms->a[ii].pi->szKey) + 1) * sizeof(TCHAR);
		RegSetValueEx (hKeyA, NULL, 0, REG_SZ,
			       (LPBYTE)(pms->a[ii].pi->szKey),cb);

#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Setting Channel Value %08X\r\n"), pms->a[ii].dwMask);
#endif
		RegSetValueEx (hKeyA, cszChannels, 0,
			       REG_DWORD,
			       (LPBYTE)&pms->a[ii].dwMask,
			       sizeof(DWORD));

		RegCloseKey (hKeyA);
	    }
	}

	RegCloseKey (hKey);
    }

    // if no HWND supplied, we are in the runonce, so we dont
    // want to kick mapper just because a scheme has changed
    //
    if (hWnd)
       KickMapper (hWnd);
    return;
}


/*+ DeleteSchemeFromReg
 *
 *-=================================================================*/

STATICFN void DeleteSchemeFromReg (
    HKEY      hkSchemes,
    LPTSTR    pszName)
{
    TCHAR sz[MAX_ALIAS];
    HKEY  hKey;
    UINT  ii;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("DeletingSchemeFromReg(%08X,'%s')\r\n"),
		hkSchemes,pszName);
#endif
    SHRegDeleteKey(hkSchemes, pszName);
/*
    // if we cannot open this key as a child of the 'schemes' key
    // we are done.
    //
    if (RegOpenKey (hkSchemes, pszName, &hKey))
	return;

    // Before we can delete a key, we must delete its children
    //
    for (ii = 0; !RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
	// if we have an obsolete alias key, remove it now
	// otherwise create/open the alias key and set it's
	// channel property to the correct value.
	//
	AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key[%d] '%s'\r\n"), ii, sz);
	RegDeleteKey (hKey, sz);
    }

    RegCloseKey (hKey);

    // now delete this key
    //
    RegDeleteKey (hkSchemes, pszName);
    return;
*/
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadChannelsIntoList (
    HWND     hWnd,
    UINT     uId,
    UINT     uIdLabel,
    PMSCHEME pms)
{
    HWND  hWndT = GetDlgItem (hWnd, uId);
    RECT  rc;
    UINT  ii;
    UINT  nChan;
    int   nTabs;

    assert (pms);

    // empty the list
    //
    SetWindowRedraw (hWndT, FALSE);
    ListBox_ResetContent (hWndT);

    // calculate the width of the tabstop
    // so that the second column lines up under the indicated
    // label
    //
    GetWindowRect (GetDlgItem(hWnd, uIdLabel), &rc);
    nTabs = rc.left;
    GetWindowRect (hWnd, &rc);
    nTabs = MulDiv(nTabs - rc.left, 4, LOWORD(GetDialogBaseUnits()));
    ListBox_SetTabStops (hWndT, 1, &nTabs);

    // fill the list with channel data
    //
    for (nChan = 0; nChan < NUM_CHANNEL; ++nChan)
    {
	static CONST TCHAR cszDtabS[] = TEXT ("%d\t%s");
	TCHAR sz[MAX_ALIAS + 10];

	for (ii = 0; ii < NUMELMS(pms->a); ++ii)
	   if (pms->a[ii].dwMask & (1 << nChan))
	       break;
	assert (ii < NUMELMS(pms->a));

	wsprintf (sz, cszDtabS, nChan+1,
		  pms->a[ii].pi ? pms->a[ii].pi->szFriendly
					 : pms->szNone);
	if (nChan == (UINT)NUM_CHANNEL-1)
	   SetWindowRedraw (hWndT, TRUE);
	ListBox_InsertString (hWndT, nChan, sz);

	if (pms->dwChanMask & (1 << nChan))
	    ListBox_SetSel (hWndT, TRUE, nChan);
    }
}


/*+
 *
 *-=================================================================*/

/*+ ChannelMaskToEdit
 *
 * convert a bit mask to a string containing list of set bits
 * and bit ranges. Then SetWindowText the result into the given
 * edit control.
 *
 * This function loads prefix text from resource strings.
 *
 * For Example: ChannelMaskToEdit(....0x0000F0F) would set the text
 * 'Channels 1-4,9-12'.
 *
 *-=================================================================*/

STATICFN void ChannelMaskToEdit (
    HWND     hWnd,
    UINT     uId,
    DWORD    dwMask)
{
    HWND   hWndT = GetDlgItem (hWnd, uId);
    TCHAR  sz[NUM_CHANNEL * 4 + MAX_ALIAS];

    if (!dwMask)
	LoadString (ghInstance, IDS_NOCHAN, sz, NUMELMS(sz));
    else
    {
	LPTSTR psz;
	LPTSTR pszT;
	int    ii;
	int    iSpan;
	DWORD  dwLast;
	DWORD  dwBit;

	LoadString (ghInstance,
		    (dwMask & (dwMask-1)) ? IDS_CHANPLURAL : IDS_CHANSINGULAR,
		    sz, NUMELMS(sz));

	pszT = psz = sz + lstrlen(sz);

	for (ii = 0, dwBit = 1, dwLast = 0, iSpan = 0;
	     ii <= 32;
	     dwLast = dwMask & dwBit, ++ii, dwBit += dwBit)
	{
	    if ((dwMask & dwBit) ^ (dwLast + dwLast))
	    {
		static CONST TCHAR cszCommaD[] = TEXT (",%d");
		static CONST TCHAR cszDashD[] = TEXT ("-%d");

		if ( ! dwLast)
		    psz += wsprintf (psz, cszCommaD, ii+1);
		else if (iSpan)
		    psz += wsprintf (psz, cszDashD, ii);
		iSpan = 0;
	    }
	    else
		++iSpan;
	}

	*pszT = TEXT (' ');
    }

    SetWindowText (hWndT, sz);
}



/*+ MidiChangeCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiChangeCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);
    PMSCHEME pms = &pmcl->ms;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiChangeCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case ID_APPLY:
	    return TRUE;

	case IDOK:
	{
	    int  ix;
	    HWND hWndT = GetDlgItem (hWnd, IDC_INSTRUMENTS);

	    ix = ComboBox_GetCurSel (hWndT);
	    if (ix >= 0)
	    {
		BOOL     bFound = FALSE;
		PINSTRUM piSel;
	BOOL     bFoundFirst = FALSE;

		piSel = (LPVOID)ComboBox_GetItemData (hWndT, ix);
		assert (!IsBadWritePtr(piSel, sizeof(*piSel)));

		// has the <none> item been selected?  in this
		// case, set stuff up so that we will not try
		// to add none to the scheme, but we will clear
		// all bits from other channels that are set
		// to none.
		//
		if ( ! piSel || ! piSel->szKey[0])
		    piSel = NULL, bFound = TRUE;

		// turn channels on for this instrument and off for
		// other instruments in this scheme.
		//
	for (ix = 0; ix < (int)NUMELMS(pms->a); ++ix)
	{
		    if (pms->a[ix].pi != piSel)
		pms->a[ix].dwMask &= ~pms->dwChanMask;
		    else if (! pms->a[ix].pi)
	    {
		if (! bFoundFirst)
		{
		    pms->a[ix].dwMask |= pms->dwChanMask;
		    bFound = TRUE;
		    bFoundFirst = TRUE;
		}
	    }
	    else
		    {
		pms->a[ix].dwMask |= pms->dwChanMask;
		bFound = TRUE;
		    }
	}

		// if this instrument was not already in the scheme,
		// find an empty slot and add it to the scheme.
		//
		if (!bFound)
	{
	    for (ix = 0; ix < (int)NUMELMS(pms->a); ++ix)
	    {
		if ( ! pms->a[ix].dwMask)
		{
		    pms->a[ix].dwMask = pms->dwChanMask;
		    pms->a[ix].pi = piSel;
		    bFound = TRUE;
		    break;
		}
	    }
	}

		assert2 (bFound, TEXT ("no room to add instrument to scheme"));
	    }
	    EndDialog (hWnd, IDOK);
	    break;
	}

	case IDCANCEL:
	    EndDialog (hWnd, IDCANCEL);
	    break;

	//
	//case ID_INIT:
	//    break;
    }

    return FALSE;
}


/*+ SaveAsDlgProc
 *
 *-=================================================================*/

const static DWORD aSaveAsHelpIds[] = {  // Context Help IDs
    IDE_SCHEMENAME,     IDH_MIDI_SAVEDLG_SCHEMENAME,

    0, 0
};

INT_PTR CALLBACK SaveAsDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    switch (GET_WM_COMMAND_ID(wParam, lParam))
	    {
		case IDOK:
		{
		    LPTSTR pszName = GetDlgData (hWnd);
		    assert (pszName);
		    GetDlgItemText (hWnd, IDE_SCHEMENAME, pszName, MAX_ALIAS);
		}
		// fall through
		case IDCANCEL:
		   EndDialog (hWnd, GET_WM_COMMAND_ID(wParam, lParam));
		   break;
	    }
	    break;
	
	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    LPTSTR pszName = (LPVOID) lParam;
	    assert (pszName);
	    SetDlgData (hWnd, pszName);
	    SetDlgItemText (hWnd, IDE_SCHEMENAME, pszName);
	    break;
	}
    
	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aSaveAsHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aSaveAsHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}



/*+ GetNewSchemeName
 *
 *-=================================================================*/

STATICFN BOOL WINAPI GetNewSchemeName (
    HWND     hWnd,
    HKEY     hkSchemes,
    LPTSTR   pszName)
{
    TCHAR szNew[MAX_ALIAS];
    UINT_PTR  uBtn;

    lstrcpy (szNew, pszName);

    uBtn = DialogBoxParam (ghInstance,
			   MAKEINTRESOURCE(IDD_SAVENAME),
			   hWnd,
			   SaveAsDlgProc,
			   (LPARAM)szNew);
    if (IDOK == uBtn)
    {
	if (ChildKeyExists (hkSchemes, szNew))
	    uBtn = Confirm (hWnd, IDS_QUERY_OVERSCHEME, szNew);
	else
	    lstrcpy (pszName, szNew);
    }

    return (IDOK == uBtn || IDYES == uBtn);
}


/*+ MidiChangeDlgProc
 *
 *-=================================================================*/

const static DWORD aChngInstrHelpIds[] = {  // Context Help IDs
    IDC_INSTRUMENTS,     IDH_ADDMIDI_INSTRUMENT,
    IDC_TEXT_1,          IDH_ADDMIDI_CHANNEL,
    IDE_SHOW_CHANNELS,   IDH_ADDMIDI_CHANNEL,

    0, 0
};

INT_PTR CALLBACK MidiChangeDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiChangeCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	    break;
	
	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl = (LPVOID) lParam;
	    PMSCHEME pms = &pmcl->ms;

	    SetDlgData (hWnd, pmcl);

	    LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS, NULL, &pmcl->mcm);
	    ChannelMaskToEdit (hWnd, IDE_SHOW_CHANNELS, pms->dwChanMask);
	    break;
	}

	//case WM_DESTROY:
	//    break;

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aChngInstrHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aChngInstrHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


/*+ MidiConfigCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiConfigCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);
    PMSCHEME pms  = &pmcl->ms;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiConfigCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case IDB_CHANGE:
	{
	    UINT_PTR uRet;
	    int      ii;
	    HWND     hWndList = GetDlgItem (hWnd, IDL_CHANNELS);

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Change Dialog\r\n"));
#endif
	    pms->dwChanMask = 0;
	    for (ii = 0; ii < NUM_CHANNEL; ++ii)
		 if (ListBox_GetSel (hWndList, ii))
		    pms->dwChanMask |= (1 << ii);

	    uRet = DialogBoxParam (ghInstance,
				   MAKEINTRESOURCE(IDD_MIDICHANGE),
				   hWnd,
				   MidiChangeDlgProc,
				   (LPARAM)pmcl);
	    if (uRet == IDOK)
	    {
	       LoadChannelsIntoList (hWnd, IDL_CHANNELS, IDC_TEXT_1, pms);
	       pms->bDirty = TRUE;
	    }
	    break;
	}

	case IDB_DELETE:
	    if (IsSzEqual(pmcl->szScheme, pmcl->szDefault))
	    {
		break;
	    }
	    if (Confirm (hWnd, IDS_QUERY_DELETESCHEME, pmcl->szScheme) == IDYES)
	    {
		HWND hWndCtl = GetDlgItem (hWnd, IDC_SCHEMES);
		int  ix = ComboBox_FindStringExact (hWndCtl, -1, pmcl->szScheme);
		assert (ix >= 0);

		DeleteSchemeFromReg (pms->hkSchemes, pmcl->szScheme);

		ComboBox_DeleteString (hWndCtl, ix);
		ComboBox_SetCurSel (hWndCtl, 0);
		SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);
	    }
	    break;

	case IDB_SAVE_AS:
	    if (GetNewSchemeName (hWnd, pms->hkSchemes, pmcl->szScheme))
	    {
		SaveSchemeToReg (&pmcl->mcm, pms, pmcl->szScheme, hWnd);

		LoadSchemesIntoCombo (hWnd, IDC_SCHEMES,
				      pmcl->szScheme, pms);
	    }
	    SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);
	    break;

	case IDC_SCHEMES:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    ComboBox_GetLBText (hWndCtl, ix, pmcl->szScheme);

		LoadSchemeFromReg (&pmcl->mcm, pms, pmcl->szScheme);

		pms->dwChanMask = 0;
		LoadChannelsIntoList (hWnd, IDL_CHANNELS, IDC_TEXT_1, pms);

		EnableWindow (GetDlgItem (hWnd, IDB_DELETE),
			      !IsSzEqual(pmcl->szDefault, pmcl->szScheme));
	    }
	    break;

	case IDL_CHANNELS:
	    if (wNotify == LBN_SELCHANGE)
	    {
		int ix;

		ix = ListBox_GetSelCount (hWndCtl);
		EnableWindow (GetDlgItem (hWnd, IDB_CHANGE), (ix > 0));
	    }
	    break;

	case IDOK:
	{
	    SaveSchemeToReg (&pmcl->mcm, pms, pmcl->szScheme, hWnd);

	    EndDialog (hWnd, IDOK);
	    break;
	}

	case IDCANCEL:
	    EndDialog (hWnd, IDCANCEL);
	    break;
    }

    return FALSE;
}


/*+ MidiConfigDlgProc
 *
 *-=================================================================*/

const static DWORD aMidiConfigHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,    IDH_COMM_GROUPBOX,
    IDC_SCHEMES,     IDH_MIDI_CFGDLG_SCHEME,
    IDB_SAVE_AS,     IDH_MIDI_CFGDLG_SAVEAS,
    IDB_DELETE,      IDH_MIDI_CFGDLG_DELETE,
    IDC_GROUPBOX_2,  IDH_COMM_GROUPBOX,
    IDL_CHANNELS,    IDH_MIDI_INSTRUMENTS,
    IDB_CHANGE,      IDH_MIDI_CFGDLG_CHANGE,
    IDC_TEXT_1,      IDH_MIDI_INSTRUMENTS,
    IDC_TEXT_2,      IDH_MIDI_INSTRUMENTS,
    IDC_TEXT_3,      NO_HELP,

    0, 0
};

INT_PTR CALLBACK MidiConfigDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiConfigCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	    break;

	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl = (LPVOID) lParam;
	    
	    assert (pmcl);

	    SetDlgData (hWnd, pmcl);
	    LoadString (ghInstance, IDS_NONE, pmcl->ms.szNone, NUMELMS(pmcl->ms.szNone));

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES, pmcl->szScheme, &pmcl->ms);
	    SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);

	    EnableWindow (GetDlgItem(hWnd, IDB_CHANGE), FALSE);
	    break;
	}

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aMidiConfigHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aMidiConfigHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


STATICFN void WINAPI PickMidiInstrument(
    LPTSTR   pszKey)
{
    HKEY            hKeyMR, hKeyDriver;
    UINT            cDevs;
    UINT            ii, jj;
    DWORD           cbSize, dwType;
    LPMIDIOUTCAPS   pmoc;
    MMRESULT        mmr;
    PWSTR           pszDevIntDev, pszDevIntKey;
    UINT            aTech[]  = { MOD_SWSYNTH,
                                 MOD_WAVETABLE,
                                 MOD_SYNTH,
                                 MOD_FMSYNTH,
                                 MOD_SQSYNTH,
                                 MOD_MIDIPORT};
    UINT            cTech    = sizeof(aTech)/sizeof(aTech[0]);
    TCHAR           szKey[MAX_ALIAS];
    TCHAR           szPname[MAXPNAMELEN];
    TCHAR           szPnameTarget[MAXPNAMELEN];
    LONG            lr;

    szPname[0] = 0;
    cDevs = midiOutGetNumDevs();

    if (0 == cDevs)
    {
        return;
    }

    pmoc = (LPMIDIOUTCAPS)LocalAlloc (LPTR, cDevs * sizeof(MIDIOUTCAPS));

    if (NULL == pmoc)
    {
        return;
    }

    for (ii = cDevs; ii; ii--)
    {
        mmr = midiOutGetDevCaps(ii - 1, &(pmoc[ii - 1]), sizeof(MIDIOUTCAPS));

        if (MMSYSERR_NOERROR != mmr)
        {
            LocalFree ((HLOCAL)pmoc);
            return;
        }
    }

    for (ii = 0; ii < cTech; ii++)
    {
        for (jj = cDevs; jj; jj--)
        {
            if (pmoc[jj - 1].wTechnology == aTech[ii])
            {
                lstrcpy(szPname, pmoc[jj - 1].szPname);
                break;
            }
        }

        if (jj)
        {
            //  Broke out of inner loop, found match

            break;
        }
    }

    LocalFree ((HLOCAL)pmoc);

    if (0 == jj)
    {
        //  This should never happen...

        return;
    }

    jj--;

    mmr = midiOutMessage (HMIDIOUT_INDEX(jj), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)(PULONG)&cbSize, 0L);

    if (MMSYSERR_NOERROR != mmr)
    {
        return;
    }

	pszDevIntDev = (PWSTR)LocalAlloc (LPTR, cbSize);

    if (NULL == pszDevIntDev)
    {
        return;
    }

    mmr = midiOutMessage (HMIDIOUT_INDEX(jj), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)pszDevIntDev, (DWORD)cbSize);

    if (MMSYSERR_NOERROR != mmr)
    {
        LocalFree ((HLOCAL)pszDevIntDev);
        return;
    }

    lr = RegOpenKey(HKEY_LOCAL_MACHINE, cszDriversRoot, &hKeyMR);

    if (ERROR_SUCCESS != lr)
    {
        LocalFree ((HLOCAL)pszDevIntDev);
        return;
    }

    for (ii = 0; ; )
    {
        lr = RegEnumKey(hKeyMR, ii++, szKey, sizeof(szKey)/sizeof(szKey[0]));

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        lr = RegOpenKey(hKeyMR, szKey, &hKeyDriver);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        cbSize = sizeof(szPnameTarget);

        lr = RegQueryValueEx(
                hKeyDriver,
                cszActive,
                NULL,
                &dwType,
                (LPSTR)szPnameTarget,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (TEXT('1') != szPnameTarget[0])
        {
            RegCloseKey(hKeyDriver);
            continue;
        }

        cbSize = sizeof(szPnameTarget);

        lr = RegQueryValueEx(
                hKeyDriver,
                cszDescription,
                NULL,
                &dwType,
                (LPSTR)szPnameTarget,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (0 != lstrcmp(szPnameTarget, szPname))
        {
            RegCloseKey(hKeyDriver);
            continue;
        }

        cbSize = 0;

        lr = RegQueryValueExW (
                hKeyDriver,
                L"DeviceInterface",
                NULL,
                &dwType,
                (LPSTR)NULL,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        pszDevIntKey = (PWSTR) LocalAlloc (LPTR, cbSize);

        if (NULL == pszDevIntKey)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        lr = RegQueryValueExW (
                hKeyDriver,
                L"DeviceInterface",
                NULL,
                &dwType,
                (LPSTR)pszDevIntKey,
                &cbSize);

        RegCloseKey(hKeyDriver);

        if (ERROR_SUCCESS != lr)
        {
            LocalFree ((HLOCAL)pszDevIntKey);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (0 == lstrcmpiW(pszDevIntKey, pszDevIntDev))
        {
            LocalFree ((HLOCAL)pszDevIntKey);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            lstrcpy(pszKey, szKey);
            return;
        }

        LocalFree ((HLOCAL)pszDevIntKey);
    }
}


/*+ SaveLocal
 *
 *-=================================================================*/

STATICFN void WINAPI SaveLocal (
    PMCLOCAL pmcl,
    BOOL     bUserSetting,
    HWND     hWnd)  // optional window to report errors: NULL - no reports
{
    HKEY hKey = NULL;
    UINT cb;

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("SaveLocal(%08X,%X) %s\r\n"),
		pmcl, hWnd, pmcl->pszReason ? pmcl->pszReason : TEXT (""));
#endif
    
    if ((RegCreateKey (HKEY_CURRENT_USER, cszMidiMapRoot, &hKey) == ERROR_SUCCESS) && hKey)
    {
    	cb = (lstrlen(pmcl->szScheme) + 1) * sizeof(TCHAR);
	    RegSetValueEx (hKey, cszCurrentScheme, 0, REG_SZ,
		               (LPBYTE)pmcl->szScheme, cb);

	    //assert (pmcl->piSingle);
	    if ((pmcl->piSingle) && (pmcl->piSingle->bActive))
	    {
#ifdef DEBUG
	        AuxDebugEx (2, DEBUGLINE TEXT ("Setting CurrentInstrument Key to %08X '%s'\r\n"),
			            pmcl->piSingle, pmcl->piSingle->szKey);
#endif
    	    cb = (lstrlen(pmcl->piSingle->szKey) + 1) * sizeof(TCHAR);
	        RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ,
		    	           (LPBYTE)(pmcl->piSingle->szKey),
			               cb);
	    }
	    else
	    {
            // Assume No Match

            TCHAR   szKey[MAX_ALIAS];
            LONG    lr;

            szKey[0] = 0;

	        RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ, (LPBYTE)cszEmpty, 0);
            PickMidiInstrument(szKey);

	        cb = (lstrlen(szKey) + 1) * sizeof(TCHAR);
	        lr = RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ,
			                (LPBYTE)(szKey), cb);
            
	    }

	    RegSetValueEx (hKey, cszUseScheme, 0, REG_DWORD,
		               (LPBYTE)&pmcl->bUseScheme, sizeof(pmcl->bUseScheme));

	    if (bUserSetting)
	        pmcl->bAutoScheme = FALSE;

	    RegSetValueEx (hKey, cszAutoScheme, 0, REG_DWORD,
		               (LPBYTE)&pmcl->bAutoScheme, sizeof(pmcl->bAutoScheme));

	    RegSetValueEx (hKey, cszRunOnceCount, 0, REG_DWORD,
		               (LPBYTE)&pmcl->dwRunCount, sizeof(pmcl->dwRunCount));

	    if (pmcl->pszReason)
	    {
	        cb = (lstrlen(pmcl->pszReason) + 1) * sizeof(TCHAR);
	        RegSetValueEx (hKey, cszDriverList, 0, REG_SZ,
			               (LPBYTE)pmcl->pszReason, cb);
	    }
	    else
	        RegSetValueEx (hKey, cszDriverList, 0, REG_SZ, (LPBYTE)cszEmpty, 0);

	    RegCloseKey (hKey);

	    // Don't Kick mapper unless we have a window
	    if (hWnd)
	        KickMapper (hWnd);
    }
}


/*+ InitLocal
 *
 *-=================================================================*/

STATICFN void WINAPI InitLocal (
    PMCLOCAL pmcl,
    LPARAM   lParam,
    BOOL     bDriverAsAlias) // driver as alias mode used only for scheme init
{
    HKEY hKey;

    LoadString (ghInstance, IDS_DEFAULT_SCHEME_NAME,
		pmcl->szDefault, NUMELMS(pmcl->szDefault));

    // NOTE : Comment below regarding RunOnceSchemeInit is in reference
    //  to an obsolete RunOnce initialization.
    //
    // we allow driver as alias (szFriendly) only for InitLocal when called
    // from RunOnceSchemeInit.  this works because in this case we have
    // no UI so we dont need the friendly names for anything.
    //
    assert (!bDriverAsAlias || lParam == 0);
    LoadInstruments (&pmcl->mcm, bDriverAsAlias);

   #ifdef DEBUG
    if (mmdebug_OutputLevel >= 3)
       DumpInstruments (&pmcl->mcm);
   #endif

    if (RegCreateKey (HKEY_CURRENT_USER, cszMidiMapRoot, &hKey) == ERROR_SUCCESS)
    {
	DWORD cb;
	DWORD dwType;
	TCHAR szSingle[MAX_ALIAS];

	cb = sizeof(pmcl->szScheme);
	if (RegQueryValueEx (hKey, cszCurrentScheme, NULL, &dwType, (LPBYTE)pmcl->szScheme, &cb))
	    pmcl->szScheme[0] = 0;

	pmcl->piSingle = NULL;
	cb = sizeof(szSingle);
	if (!RegQueryValueEx (hKey, cszCurrentInstrument, NULL, &dwType, (LPBYTE)szSingle, &cb))
	    pmcl->piSingle = FindInstrumentFromKey (&pmcl->mcm, szSingle);

	cb = sizeof(pmcl->bUseScheme);
	if (RegQueryValueEx (hKey, cszUseScheme, NULL, &dwType, (LPBYTE)&pmcl->bUseScheme, &cb))
	    pmcl->bUseScheme = 0;

	cb = sizeof(pmcl->bAutoScheme);
	if (RegQueryValueEx (hKey, cszAutoScheme, NULL, &dwType, (LPBYTE)&pmcl->bAutoScheme, &cb))
	    pmcl->bAutoScheme = TRUE;

	cb = sizeof(pmcl->dwRunCount);
	if (RegQueryValueEx (hKey, cszRunOnceCount, NULL, &dwType, (LPBYTE)&pmcl->dwRunCount, &cb))
	    pmcl->dwRunCount = 0;

	pmcl->pszReason = NULL;

	RegCloseKey (hKey);
    }

    pmcl->ppsp = (LPVOID)lParam;
}


/*+ FixupHinderedIDFs
 *
 *-=================================================================*/

VOID WINAPI FixupHinderedIDFs (
    PMCLOCAL pmcl,
    LPTSTR   pszTemp,  // ptr to temp memory
    UINT     cchTemp)  // size of temp memory
{
    HKEY     hkHind; // hinderedMidiList root
    LPTSTR   pszDriver = pszTemp; // max size is short filename
    UINT     cch;
    LPTSTR   pszIDF = (LPVOID)(pszTemp + MAX_PATH);
    UINT     cbSize;
    DWORD    iEnum;
    DWORD    dwType;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("FixupHinderedIDFs(%08x)\r\n"), pmcl);
#endif
    assert (pszTemp);
    assert (cchTemp > MAX_PATH + MAX_PATH + 64);

    // the midi key should have already been opened.
    //
    assert (pmcl->mcm.hkMidi);

    if (RegCreateKey (HKEY_LOCAL_MACHINE, cszHinderedMidiList, &hkHind))
	return;

    // enumerate the known hindered driver list looking for
    // drivers that need to have their IDF's set
    //
    for (iEnum = 0, cch = MAX_PATH, cbSize = (MAX_PATH + 64) * sizeof(TCHAR);
	 ! RegEnumValue (hkHind, iEnum, pszDriver, &cch, NULL, &dwType, (LPBYTE)pszIDF, &cbSize);
	 ++iEnum, cch = MAX_PATH, cbSize = (MAX_PATH + 64) * sizeof(TCHAR))
    {
	UINT ii;

#ifdef DEBUG
	AuxDebugEx (3, DEBUGLINE TEXT ("enum[%d] pszDriver='%s' pszIDF='%s'\r\n"), iEnum, pszDriver, pszIDF);
#endif
	// just to be careful.  ignore any registry entry that
	// does not have string data
	//
	assert (dwType == REG_SZ);
	if (dwType != REG_SZ)
	    continue;

	// scan through the list of drivers looking for one that is
	// internal, and has the same driver name as one of our known
	// list of hindered drivers.  if we find one, force its
	// IDF to be the given IDF
	//
	for (ii = 0; ii < pmcl->mcm.nInstr; ++ii)
	{
	    PINSTRUM pi = pmcl->mcm.api[ii];
	    HKEY hkSub;

	    if (!pi || !pi->szKey[0] || pi->bExternal ||
		!IsSzEqual (pi->szFriendly, pszDriver))
		continue;

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("forcing driver '%s' to use IDF '%s'\r\n"), pi->szKey, pszIDF);
#endif
	    if ( ! RegOpenKeyEx (pmcl->mcm.hkMidi, pi->szKey, 0, KEY_ALL_ACCESS, &hkSub))
	    {
		RegSetValueEx (hkSub, cszDefinition, 0, REG_SZ, (LPBYTE)pszIDF, cbSize);
		RegCloseKey (hkSub);
	    }
	}
    }

    RegCloseKey (hkHind);
    return;
}


STDAPI_(void) HandleSynthAboutBox(HWND hWnd)
{
    HWND hTree =  GetDlgItem(hWnd, IDL_INSTRUMENTS);
    HTREEITEM hItem = TreeView_GetSelection(hTree);
    TV_ITEM       ti;
    PINSTRUM      pi;

    memset(&ti, 0, sizeof(ti));
    ti.mask       = TVIF_PARAM;
    ti.hItem      = hItem;
    
    TreeView_GetItem (hTree, &ti);
    pi = (LPVOID)ti.lParam; 

    if (pi)
    {
        UINT uWaveID;

        if (GetWaveID(&uWaveID) != (MMRESULT)MMSYSERR_ERROR)
        {
            WAVEOUTCAPS woc;

            if (waveOutGetDevCaps(uWaveID, &woc, sizeof(woc)) == MMSYSERR_NOERROR)
            {
                RolandProp(hWnd, ghInstance, woc.szPname);
            }  
        }
    }
}



/*+ MidiCplCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiCplCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("MidiCplCommands(%08X,%X,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    assert (pmcl);
    if (!pmcl)
	return FALSE;

    switch (wId)
    {
	case IDB_CONFIGURE:
	{
	    UINT_PTR uRet;
	    TCHAR    szOld[MAX_ALIAS];

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Config Dialog\r\n"));
#endif

	    lstrcpy (szOld, pmcl->szScheme);
	    uRet = DialogBoxParam (ghInstance,
				   MAKEINTRESOURCE(IDD_MIDICONFIG),
				   hWnd,
				   MidiConfigDlgProc,
				   (LPARAM)pmcl);
	    if (uRet != IDOK)
		lstrcpy (pmcl->szScheme, szOld);
	    else
		PropSheet_Changed(GetParent(hWnd), hWnd);

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES, pmcl->szScheme, &pmcl->ms);
	}
	    break;

    case IDC_ABOUTSYNTH:
    {
        HandleSynthAboutBox(hWnd);
    }
    break;

	case IDB_ADDWIZ:
#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Midi Wizard\r\n"));
#endif
	    MidiInstrumentsWizard (hWnd, &pmcl->mcm, NULL);

	    LoadInstruments (&pmcl->mcm, FALSE);
	   #ifdef DEBUG
	    if (mmdebug_OutputLevel >= 3)
	       DumpInstruments (&pmcl->mcm);
	   #endif

	    if (pmcl->bDlgType2)
	    {
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, IDC_INSTRUMENTS,
					 pmcl->piSingle, pmcl);
	    }
	    else
	    {
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }
	    MMExtPropSheetCallback(MM_EPS_BLIND_TREECHANGE, 0,0,0);
	    break;

	case IDC_SCHEMES:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    ComboBox_GetLBText (hWndCtl, ix, pmcl->szScheme);
		PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    break;

	case IDC_INSTRUMENTS:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		assert (!pmcl->bDlgType2);

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		{
		    pmcl->piSingle = (LPVOID)ComboBox_GetItemData (hWndCtl, ix);
		}
		PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    break;

	case IDC_RADIO_CUSTOM:
	case IDC_RADIO_SINGLE:
	    {
	    BOOL bUseScheme = pmcl->bUseScheme;
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    if (bUseScheme != pmcl->bUseScheme)
		PropSheet_Changed(GetParent(hWnd), hWnd);

	    if (pmcl->bDlgType2)
	    {
		HWND hWndCtl;
		EnableWindow(GetDlgItem (hWnd, IDL_INSTRUMENTS), !pmcl->bUseScheme);
		if (hWndCtl = GetDlgItem (hWnd, IDB_DETAILS))
		    EnableWindow(hWndCtl, !pmcl->bUseScheme);
	    }
	    EnableWindow(GetDlgItem (hWnd, IDC_INSTRUMENTS), !pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDC_SCHEMES), pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDC_SCHEMESLABEL), pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDB_CONFIGURE), pmcl->bUseScheme);
	    }
	    break;

       #if 1 //def DETAILS_FROM_MAIN_CPL
	case IDB_DETAILS:
	    assert (pmcl->bDlgType2);
	    if (pmcl->bDlgType2)
	    {
		TCHAR szSingle[MAX_PATH];
		int  ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    pmcl->piSingle = (LPVOID)ComboBox_GetItemData (hWndCtl, ix);

		szSingle[0] = 0;
		if (pmcl->piSingle)
		    lstrcpy (szSingle, pmcl->piSingle->szKey);

		if (ShowDetails (hWnd, pmcl))
		{
		    LoadInstruments (&pmcl->mcm, FALSE);
		    pmcl->piSingle = FindInstrumentFromKey (&pmcl->mcm, szSingle);

		    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS,
					     IDC_INSTRUMENTS, pmcl->piSingle,
					     pmcl);
		}
	    }
	    break;
       #endif

	case ID_INIT:
	    LoadInstruments (&pmcl->mcm, FALSE);
	   #ifdef DEBUG
	    if (mmdebug_OutputLevel >= 3)
	       DumpInstruments (&pmcl->mcm);
	   #endif

	    if (pmcl->bDlgType2)
	    {
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, IDC_INSTRUMENTS,
					 pmcl->piSingle, pmcl);
	    }
	    else
	    {
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }
	    break;

	case ID_APPLY:
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    SaveLocal (pmcl, TRUE, hWnd);
	    break;

	case IDOK:
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    break;

	case IDCANCEL:
	    break;

	//
	//case ID_INIT:
	//    break;
    }

    return FALSE;
}


/*+ HandleInstrumentsSelChange
 *
 *-=================================================================*/

STATICFN BOOL WINAPI HandleInstrumentsSelChange (
    HWND     hWnd,
    LPNMHDR  lpnm)
{
    PMCLOCAL      pmcl = GetDlgData(hWnd);
    LPNM_TREEVIEW pntv = (LPVOID)lpnm;
    LPTV_ITEM     pti  = &pntv->itemNew;
    TV_ITEM       ti;
    PINSTRUM      pi;
    TCHAR         szSingle[MAX_ALIAS];
    BOOL          bChange = FALSE;

    if (!pmcl || pmcl->bIgnoreSelChange)
	return FALSE;

    // setup ti to get text & # of children
    // from the IDF filename entry.
    //
    ti.mask       = TVIF_TEXT | TVIF_PARAM;
    ti.pszText    = szSingle;
    ti.cchTextMax = NUMELMS(szSingle);
    ti.hItem      = pti->hItem;

    TreeView_GetItem (lpnm->hwndFrom, &ti);
    pi = (LPVOID)ti.lParam; // FindInstrument (&pmcl->mcm, szSingle);

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("HandInstSelChg(%X,...) %X %X Init=%d\r\n"),
		hWnd, pmcl->piSingle, pi, !pmcl->bPastInit);
#endif

    SetDlgItemText (hWnd, IDC_INSTRUMENTS, szSingle);
    if (pmcl->piSingle != pi)
    {
	EnableWindow(GetDlgItem(hWnd,IDC_ABOUTSYNTH),pi->fGSSynth);
    bChange = TRUE;
	pmcl->piSingle = pi;
    }

    return (bChange && pmcl->bPastInit);
}


/*+ MidiCplDlgProc
 *
 *-=================================================================*/

const static DWORD aKeyWordIds[] = {  // Context Help IDs
    IDC_GROUPBOX,     IDH_COMM_GROUPBOX,
    IDC_RADIO_SINGLE, IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_INSTRUMENTS,  IDH_MIDI_SINGLE_INST,
    IDL_INSTRUMENTS,  IDH_MIDI_SINGLE_INST_LIST,
    IDC_RADIO_CUSTOM, IDH_MIDI_CUST_CONFIG,
    IDC_SCHEMESLABEL, IDH_MIDI_SCHEME,
    IDC_SCHEMES,      IDH_MIDI_SCHEME,
	IDC_ABOUTSYNTH,	  IDH_ABOUT,
    //IDB_DETAILS,      IDH_MIDI_SINGLE_INST_PROP,
    IDB_CONFIGURE,    IDH_MIDI_CONFIG_SCHEME,
    IDB_ADDWIZ,       IDH_MIDI_ADD_NEW,

    0, 0
};

INT_PTR CALLBACK MidiCplDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCplDlgProc(%08X,%X,%08X,%08X)\r\n"),
		hWnd, uMsg, wParam, lParam);
#endif

    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiCplCommands);
	    break;
	
	case WM_NOTIFY:
	{
	    LPNMHDR lpnm = (LPVOID)lParam;
	    if (lpnm->idFrom == (UINT)IDL_INSTRUMENTS &&
		lpnm->code == TVN_SELCHANGED)
	    {
		if (HandleInstrumentsSelChange (hWnd, lpnm))
		    PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    else
		ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	}
	    break;
	
	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl;
	    
	    pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
	    SetDlgData (hWnd, pmcl);
	    if (!pmcl)
	    {
		break;
	    }
	    pmcl->bPastInit = FALSE;

	    InitLocal (pmcl, lParam, FALSE);
	    EnableWindow (GetDlgItem (hWnd, IDB_ADDWIZ), pmcl->mcm.bHasExternal & AccessServiceController());
		EnableWindow(GetDlgItem(hWnd, IDC_ABOUTSYNTH), FALSE);

	    if (GetDlgItem(hWnd, IDL_INSTRUMENTS))
	    {
		pmcl->bDlgType2 = TRUE;
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS,
					 IDC_INSTRUMENTS, pmcl->piSingle,
					 pmcl);
	    }
	    else
	    {
		pmcl->bDlgType2 = FALSE;
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }

	    CheckRadioButton (hWnd,
			      IDC_RADIO_SINGLE,
			      IDC_RADIO_CUSTOM,
			      pmcl->bUseScheme ? IDC_RADIO_CUSTOM
					       : IDC_RADIO_SINGLE);

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES,
				  pmcl->szScheme, &pmcl->ms);

	    if (pmcl->mcm.nInstr > 1)
	    {
	       if (pmcl->bDlgType2)
	       {
		   HWND hWndCtl;

		   EnableWindow(GetDlgItem (hWnd, IDL_INSTRUMENTS), !pmcl->bUseScheme);
		   if (hWndCtl = GetDlgItem (hWnd, IDB_DETAILS))
		      EnableWindow (hWndCtl, !pmcl->bUseScheme);
	       }
	       EnableWindow(GetDlgItem (hWnd, IDC_INSTRUMENTS), !pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDC_SCHEMES), pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDC_SCHEMESLABEL), pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDB_CONFIGURE), pmcl->bUseScheme);
	    }
	    else
	    {
		UINT aid[] = { IDL_INSTRUMENTS, IDC_INSTRUMENTS, IDC_SCHEMES,
			       IDC_RADIO_SINGLE, IDC_RADIO_CUSTOM,
			       IDB_CONFIGURE, IDB_DETAILS, IDB_ADDWIZ };
		UINT ii;

		for (ii = 0; ii < NUMELMS(aid); ++ii)
		{
		    HWND hWndCtl = GetDlgItem (hWnd, aid[ii]);
		    if (hWndCtl)
			EnableWindow (hWndCtl, FALSE);
		}
	    }
	    pmcl->bPastInit = TRUE;
	    break;
	}

	case WM_DESTROY:
	{
	    PMCLOCAL pmcl = GetDlgData(hWnd);

#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCPL - begin WM_DESTROY\r\n"));
#endif
	    if (pmcl)
	    {
		if (pmcl->mcm.hkMidi)
		    RegCloseKey (pmcl->mcm.hkMidi);
		if (pmcl->ms.hkSchemes)
		    RegCloseKey (pmcl->ms.hkSchemes);

		FreeInstruments (&pmcl->mcm);
		SetDlgData (hWnd, 0);
		LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
	    }
#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCPL -  done with WM_DESTROY\r\n"));
#endif
	    break;
	}

	//case WM_DROPFILES:
	//    break;

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aKeyWordIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aKeyWordIds);
	    return TRUE;
	}

       #if 0
	default:
	    if (uMsg == wHelpMessage)
	    {
		WinHelp (hWnd, gszWindowsHlp, HELP_CONTEXT, ID_SND_HELP);
		return TRUE;
	    }
	    break;
       #endif
    }

    return FALSE;
}


/*+ MidiClassCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiClassCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);

	if (!pmcl) return FALSE;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiClassCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case IDB_ADDWIZ:
	    MidiInstrumentsWizard (hWnd, &pmcl->mcm, NULL);
	    LoadInstruments (&pmcl->mcm, FALSE);
	    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, 0, NULL, pmcl);

	    // flog the parent property sheet to let it know that we have
	    // made changes to the advanced midi page structures
	    //
	    {
		PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
		if (pmpsa && pmpsa->lpfnMMExtPSCallback)
		    pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, pmpsa->lParam);
	    }
	    break;

	//case ID_APPLY:
	//    return TRUE;
	//
	//case IDCANCEL:
	//    break;
    }

    return FALSE;
}


/*+ MidiClassDlgProc
 *
 *-=================================================================*/

const static DWORD aMidiClassHelpIds[] = {  // Context Help IDs
    IDB_ADDWIZ,      IDH_MIDI_ADD_NEW,
    IDC_CLASS_ICON,  NO_HELP,
    IDC_CLASS_LABEL, NO_HELP,
    IDL_INSTRUMENTS, IDH_MMCPL_DEVPROP_INST_LIST,

    0, 0
};

INT_PTR CALLBACK MidiClassDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiClassCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify (hWnd, (NMHDR FAR *)lParam);
	    break;
	
	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl;
	    TCHAR    sz[MAX_ALIAS];
	    
	    pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
	    SetDlgData (hWnd, pmcl);
	    if (!pmcl)
	    {
		break;
	    }


	    InitLocal (pmcl, lParam, FALSE);

#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("midiClass.WM_INITDLG ppsp=%08X\r\n"), pmcl->ppsp);
#endif
	    //AuxDebugDump (8, pmcl->ppsp, sizeof(*pmcl->ppsp));

	    LoadString (ghInstance, IDS_MIDI_DEV_AND_INST, sz, NUMELMS(sz));
	    SetDlgItemText (hWnd, IDC_CLASS_LABEL, sz);
	    Static_SetIcon(GetDlgItem (hWnd, IDC_CLASS_ICON),
			   LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_INSTRUMENT)));

	    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, 0, NULL, pmcl);
	    EnableWindow (GetDlgItem (hWnd, IDB_ADDWIZ), pmcl->mcm.bHasExternal & AccessServiceController());
	    break;
	}

	case WM_DESTROY:
	{
	    PMCLOCAL pmcl = GetDlgData(hWnd);

	    if (pmcl)
	    {
		if (pmcl->mcm.hkMidi)
		    RegCloseKey (pmcl->mcm.hkMidi);
		if (pmcl->ms.hkSchemes)
		    RegCloseKey (pmcl->ms.hkSchemes);

		FreeInstruments (&pmcl->mcm);
		LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
	    }
	    break;
	}
    
	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aMidiClassHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aMidiClassHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


/*+ PropPageCallback
 *
 *  add a property page
 *
 *-=================================================================*/

UINT CALLBACK PropPageCallback (
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE) {
	//LocalFree ((HLOCAL)(UINT)(DWORD)ppsp->pszTitle);
	LocalFree ((HLOCAL)ppsp->lParam);
    }
    return 1;
}


/*+ AddPropPage
 *
 *  add a property page
 *
 *-=================================================================*/

STATICFN HPROPSHEETPAGE WINAPI AddPropPage (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    DLGPROC                     fnDlgProc,
    UINT                        idTemplate,
    LPARAM                      lParam)
{
    PROPSHEETPAGE   psp;
    PMPSARGS        pmpsa;
    UINT            cbSize;

    cbSize = sizeof(MPSARGS) + lstrlen (pszTitle) * sizeof(TCHAR);
    if (pmpsa = (PVOID) LocalAlloc (LPTR, cbSize))
    {
	HPROPSHEETPAGE  hpsp;

	lstrcpy (pmpsa->szTitle, pszTitle);
	pmpsa->lpfnMMExtPSCallback = lpfnAddPropSheetPage;
	pmpsa->lParam = lParam;

	psp.dwSize      = sizeof(psp);
	psp.dwFlags     = PSP_USETITLE | PSP_USECALLBACK;
	psp.hInstance   = ghInstance;
	psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
	psp.pszIcon     = NULL;
	psp.pszTitle    = pmpsa->szTitle;
	psp.pfnDlgProc  = fnDlgProc;
	psp.lParam      = (LPARAM)pmpsa;
	psp.pfnCallback = PropPageCallback;
	psp.pcRefParent = NULL;

	if (hpsp = CreatePropertySheetPage (&psp))
	{
	    if ( ! lpfnAddPropSheetPage ||
		lpfnAddPropSheetPage (MM_EPS_ADDSHEET, (DWORD_PTR)hpsp, 0, lParam))
	    {

		return hpsp;
	    }
	    DestroyPropertySheetPage (hpsp);
	    LocalFree ((HLOCAL) pmpsa);
	}
    }
    return NULL;
}


/*+ AddInstrumentPages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Muitimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddInstrumentPages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("AddInstrumentPages(%08X,%08X,%08X)\r\n"),
		pszTitle, lpfnAddPropSheetPage, lParam);
#endif

    LoadString (ghInstance, IDS_GENERAL, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_INSTRUMENT_GEN,
			lParam);
    if ( ! hpsp)
	return FALSE;

    LoadString (ghInstance, IDS_MIDIDETAILS, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_INSTRUMENT_DETAIL,
			lParam);

    return (hpsp != NULL);
}


/*+ AddDevicePages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Multimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddDevicePages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("AddInstrumentPages(%08X,%08X,%08X)\r\n"),
		pszTitle, lpfnAddPropSheetPage, lParam);
#endif

    LoadString (ghInstance, IDS_MIDIDETAILS, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_DEVICE_DETAIL,
			lParam);

    return (hpsp != NULL);
}


/*+ ShowDetails
 *
 *  Show Instrument or device details sheet and allow edits
 *  return TRUE if changes were made
 *
 *-=================================================================*/

struct _show_details_args {
    PMCLOCAL        pmcl;
    BOOL            bChanged;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[2];
    };

BOOL CALLBACK fnPropCallback (
    DWORD dwFunc,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    DWORD_PTR dwInstance)
{
    struct _show_details_args * psda = (LPVOID)dwInstance;

    assert (psda);
    if (!psda)
	return FALSE;

    switch (dwFunc)
    {
	case MM_EPS_GETNODEDESC:
	    *(LPTSTR)dwParam1 = 0;
	    if (psda->pmcl->piSingle)
	       lstrcpyn ((LPTSTR)dwParam1, psda->pmcl->piSingle->szFriendly, (int)(dwParam2/sizeof(TCHAR)));
	    break;

	case MM_EPS_GETNODEID:
	    *(LPTSTR)dwParam1 = 0;
	    if (psda->pmcl->piSingle)
	    {
		lstrcpy ((LPTSTR)dwParam1, cszMidiSlash);
		lstrcat ((LPTSTR)dwParam1, psda->pmcl->piSingle->szKey);
	    }
	    break;

	case MM_EPS_ADDSHEET:
	    if (psda->psh.nPages >= NUMELMS(psda->hpsp)-1)
		return FALSE;
	    psda->psh.phpage[psda->psh.nPages++] = (HPROPSHEETPAGE)dwParam1;
	    break;

	case MM_EPS_TREECHANGE:
	    psda->bChanged = TRUE;
	    break;

	default:
	    return FALSE;
    }

    return TRUE;
}

BOOL WINAPI ShowDetails (
    HWND     hWnd,
    PMCLOCAL pmcl)
{
    struct _show_details_args sda;
    TCHAR           szTitle[MAX_ALIAS];
    HPROPSHEETPAGE  hpsp;
    UINT            idDlg;

    idDlg = IDD_DEVICE_DETAIL;
    if (pmcl->piSingle && pmcl->piSingle->piParent)
	idDlg = IDD_INSTRUMENT_DETAIL;

    ZeroMemory (&sda, sizeof(sda));
    sda.pmcl            = pmcl;
    sda.psh.dwSize      = sizeof(sda.psh);
    sda.psh.dwFlags     = PSH_PROPTITLE;
    sda.psh.hwndParent  = hWnd;
    sda.psh.hInstance   = ghInstance;
    sda.psh.pszCaption  = MAKEINTRESOURCE (IDS_MMPROP);
    sda.psh.nPages      = 0;
    sda.psh.nStartPage  = 0;
    sda.psh.phpage      = sda.hpsp;

    LoadString (ghInstance, IDS_MIDIDETAILS, szTitle, NUMELMS(szTitle));
    hpsp = AddPropPage (szTitle,
			fnPropCallback,
			MidiInstrumentDlgProc,
			idDlg,
			(LPARAM)&sda);
    if (hpsp)
	sda.psh.nPages = 1;

    PropertySheet (&sda.psh);
    return sda.bChanged;
}

/*+ AddMidiPages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Muitimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddMidiPages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

    LoadString (ghInstance, IDS_GENERAL, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiClassDlgProc,
			IDD_MIDICLASS_GEN,
			lParam);
    return (hpsp != NULL);
}


/*+ AddSimpleMidiPages
 *
 *  add a midi page to a MM control panel.
 *
 *-=================================================================*/

BOOL CALLBACK  AddSimpleMidiPages (
    LPTSTR                      pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    //static CONST TCHAR sz[13] = TEXT ("            ");
    //UINT cch = lstrlen (pszTitle);

    DebugSetOutputLevel (GetProfileInt(TEXT ("Debug"), TEXT ("midiprop"), 0));

    // pad my tab to 12 spaces so it looks nice with the
    // other simple tabls (as per request of vijr)
    //
    //if (cch < NUMELMS(sz)-2)
    //{
    //    lstrcpy (sz + NUMELMS(sz)/2 - cch/2, pszTitle);
    //    pszTitle = sz;
    //    pszTitle[lstrlen(pszTitle)] = TEXT (' ');
    //}

    hpsp = AddPropPage (pszTitle,
			lpfnAddPropSheetPage,
			MidiCplDlgProc,
			IDD_CPL_MIDI2,
			lParam);
    return (hpsp != NULL);
}


/*
 ***************************************************************
 *  BOOL PASCAL LoadDesc(LPCTSTR pszFile, LPCTSTR pszDesc)
 *      This function gets the description string from the executable
 *      file specified. We first try to get the string from the version info
 *      If that fails then we try to get the string from the exehdr.
 *      If that fails we return a NULL string. 
 *      Return TRUE on success, else FALSE.
 ***************************************************************
 */

BOOL PASCAL LoadDesc(LPCTSTR pszFile, LPTSTR pszDesc)
{
   LPTSTR           psz;
   static TCHAR     szProfile[MAXSTR];
   UINT             cchSize;
   HANDLE           hFind;
   WIN32_FIND_DATA  wfd;
  
   DPF (TEXT ("LoadDesc: %s\r\n"), pszFile);

   // Make sure file exists
   hFind = FindFirstFile (pszFile, &wfd);
   if (hFind == INVALID_HANDLE_VALUE)
	   return(FALSE);
   FindClose (hFind);

   // Get User Friendly name from Version Info
   if (GetVerDesc (wfd.cFileName, pszDesc))
	   return TRUE;

   //
   // As a last resort, look at the description in the Executable Header
   //

   cchSize = sizeof(szProfile)/sizeof(TCHAR);
   if ((! GetExeDesc (wfd.cFileName, szProfile, cchSize)) ||
	    (lstrlen (szProfile) < 3))
      {
	   *pszDesc = 0;
	   return(FALSE);    
      }
   else    
      {    
	   // There is EXEHDR information Parse according to driver spec
	   psz = szProfile;
	   while (*psz && *psz++ != TEXT (':'))
	      {
	      ; // skip type information
	      }
	   if (!(*psz))
	      psz = szProfile;
	   lstrcpy (pszDesc, psz);
	   return(TRUE);
      }
}


/* BOOL FAR PASCAL GetExeDesc(szFile, szBuff, cchBuff)
 *
 *  Function will return the an executable's description
 *
 *      szFile      - Path Name a new exe
 *      pszBuf      - Buffer to place returned info
 *      cchBuf      - Size of buffer (in characters
 *
 *  returns:  TRUE if successful, FALSE otherwise.
 */

STATIC BOOL FAR PASCAL GetExeDesc(
    LPTSTR  szFile, 
    LPTSTR  pszBuff, 
    int     cchBuff)
{
   DWORD             dwSig;
   WORD              wSig;
   HANDLE            hFile;
   DWORD             offset;
   BYTE              cbLen;
   DWORD             cbRead;
   IMAGE_DOS_HEADER  doshdr;    // Original EXE Header

      // Open File
   hFile = CreateFile (szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
		       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return FALSE;

   // Get Original Dos Header
   if ((! ReadFile (hFile, (LPVOID)&doshdr, sizeof(doshdr), &cbRead, NULL)) ||
       (cbRead != sizeof(doshdr)) ||             // Read Error
       (doshdr.e_magic != IMAGE_DOS_SIGNATURE))  // Invalid DOS Header
      {
      goto error;        /* Abort("Not an exe",h); */
      }

   // Seek to new header
   offset = doshdr.e_lfanew;
   SetFilePointer (hFile, offset, NULL, FILE_BEGIN);
   
   // Read in signature
   if ((! ReadFile (hFile, (LPVOID)&dwSig, sizeof(dwSig), &cbRead, NULL)) ||
       (cbRead != sizeof(dwSig)))            // Read Error
      {
      goto error;        /* Abort("Not an exe",h); */
      }
   wSig = LOWORD (dwSig);

   if (dwSig == IMAGE_NT_SIGNATURE)
      {   
      DPF (TEXT ("GetExeDesc: NT Portable Executable Format\r\n"));

      // NOTE - The NT Portatble Executable Format does not store
      //        the executable's user friendly name.
      goto error;
      }
   else if (wSig == IMAGE_OS2_SIGNATURE) 
      {
      IMAGE_OS2_HEADER  winhdr;    // New Windows/OS2 header
      TCHAR              szInfo[256];

      DPF (TEXT ("GetExeDesc: Windows or OS2 Executable Format\r\n"));

      // Seek to Windows Header
      offset = doshdr.e_lfanew;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Read Windows Header
      if ((! ReadFile (hFile, (LPVOID)&winhdr, sizeof(winhdr), 
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(winhdr)) || // Read Error
	  (winhdr.ne_magic != IMAGE_OS2_SIGNATURE)) // Invalid Windows Header
	 {
	 goto error;
	 }

      // Seek to module name which is the first entry in the non-resident name table
      offset = winhdr.ne_nrestab;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Get Size of Module Name
      if ((! ReadFile (hFile, (LPVOID)&cbLen, sizeof(BYTE),
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(BYTE)))
	 {
	 goto error;
	 }

      cchBuff--;         // leave room for a \0

      if (cbLen > (BYTE)cchBuff)
	 cbLen = (BYTE)cchBuff;

      // Read Module Name
      if ((! ReadFile (hFile, (LPVOID)szInfo, cbLen,
		       &cbRead, NULL)) || 
	  (cbRead != cbLen))
	 {
	 goto error;
	 }
      szInfo[cbLen] = 0;

      // Copy to Buffer
      lstrcpy (pszBuff, szInfo);
      }
   else if (wSig == IMAGE_VXD_SIGNATURE)
      {
      IMAGE_VXD_HEADER  vxdhdr;    // New Windows/OS2 VXD  Header
      TCHAR              szInfo[256];

      DPF (TEXT ("GetExeDesc: Windows or OS2 VXD Executable Format\r\n"));

      // Seek to VXD Header
      offset = doshdr.e_lfanew;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Read VXD Header
      if ((! ReadFile (hFile, (LPVOID)&vxdhdr, sizeof(vxdhdr), 
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(vxdhdr)) || // Read Error
	  (vxdhdr.e32_magic != IMAGE_VXD_SIGNATURE)) // Invalid VXD Header
	 {
	 goto error;
	 }

      // Seek to module name which is the first entry in the non-resident name table
      offset = vxdhdr.e32_nrestab;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Get Size of Module Name
      if ((! ReadFile (hFile, (LPVOID)&cbLen, sizeof(BYTE),
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(BYTE)))
	 {
	 goto error;
	 }

      cchBuff--;         // leave room for a \0

      if (cbLen > (BYTE)cchBuff)
	 cbLen = (BYTE)cchBuff;

      // Read Module Name
      if ((! ReadFile (hFile, (LPVOID)szInfo, cbLen,
		       &cbRead, NULL)) || 
	  (cbRead != cbLen))
	 {
	 goto error;
	 }
      szInfo[cbLen] = 0;

      // Copy to Buffer
      lstrcpy (pszBuff, szInfo);
      }
   else
      {
      DPF (TEXT ("GetExeDesc: Unknown Executable\r\n"));
      goto error;        /* Abort("Not an exe",h); */
      }

   CloseHandle (hFile);
   return TRUE;

error:
   CloseHandle (hFile);
   return FALSE;
}


/*
 ***************************************************************
 * STATIC INT_PTR GetVerDesc
 *      Loads the version DLL and uses it to get Version Description string 
 *      from the specified file.
 ***************************************************************
 */

STATIC INT_PTR PASCAL GetVerDesc (LPCTSTR pstrFile, LPTSTR pstrDesc)
{
    DWORD_PTR dwVerInfoSize;
    DWORD dwVerHnd;
    INT_PTR  bRetCode;

	bRetCode = FALSE;

    DPF( TEXT ("Getting VERSION string for %s \r\n"), pstrFile);

    dwVerInfoSize = GetFileVersionInfoSize (pstrFile, &dwVerHnd);

    if (dwVerInfoSize) 
    {
	LPBYTE   lpVffInfo;             // Pointer to block to hold info

	// Get a block big enough to hold version info
	if (lpVffInfo  = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, dwVerInfoSize)) 
	{


	   // Get the File Version first
	    if (GetFileVersionInfo (pstrFile, 0L, 
				    dwVerInfoSize, lpVffInfo)) 
	    {
		static SZCODE cszFileDescr[] = TEXT ("\\StringFileInfo\\040904E4\\FileDescription");
		TCHAR   szBuf[MAX_PATH];
		LPTSTR  lpVersion;       
		WORD    wVersionLen;

		   // Now try to get the FileDescription
		   // First try this for the "Translation" entry, and then
		   // try the American english translation.  
		   // Keep track of the string length for easy updating.  
		   // 040904E4 represents the language ID and the four 
		   // least significant digits represent the codepage for 
		   // which the data is formatted.  The language ID is 
		   // composed of two parts: the low ten bits represent 
		   // the major language and the high six bits represent 
		   // the sub language.

		lstrcpy(szBuf, cszFileDescr);
     
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string. 
		bRetCode = VerQueryValue((LPVOID)lpVffInfo,    
					 (LPTSTR)szBuf,
					 (void FAR* FAR*)&lpVersion,
					 (UINT FAR *) &wVersionLen);

		if (bRetCode && wVersionLen > 2 && lpVersion)
		{
		    lstrcpy (pstrDesc, lpVersion);
		}
		else
		    bRetCode = FALSE;


		// Let go of the memory
		GlobalFreePtr(lpVffInfo);
	    }
	}
    } else
	bRetCode = FALSE;
    return bRetCode;
}




LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey)
{
    LONG    lResult;
    HKEY    hkSubKey;
    DWORD   dwIndex;
    TCHAR   szSubKeyName[MAX_PATH + 1];
    DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
    TCHAR   szClass[MAX_PATH];
    DWORD   cchClass = ARRAYSIZE(szClass);
    DWORD   dwDummy1, dwDummy2, dwDummy3, dwDummy4, dwDummy5, dwDummy6;
    FILETIME ft;

    // Open the subkey so we can enumerate any children
    lResult = RegOpenKeyEx(hKey, lpSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == lResult)
    {
	// I can't just call RegEnumKey with an ever-increasing index, because
	// I'm deleting the subkeys as I go, which alters the indices of the
	// remaining subkeys in an implementation-dependent way.  In order to
	// be safe, I have to count backwards while deleting the subkeys.

	// Find out how many subkeys there are
	lResult = RegQueryInfoKey(hkSubKey, 
				  szClass, 
				  &cchClass, 
				  NULL, 
				  &dwIndex, // The # of subkeys -- all we need
				  &dwDummy1,
				  &dwDummy2,
				  &dwDummy3,
				  &dwDummy4,
				  &dwDummy5,
				  &dwDummy6,
				  &ft);

	if (ERROR_SUCCESS == lResult)
	{
	    // dwIndex is now the count of subkeys, but it needs to be 
	    // zero-based for RegEnumKey, so I'll pre-decrement, rather
	    // than post-decrement.
	    while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
	    {
		SHRegDeleteKey(hkSubKey, szSubKeyName);
	    }
	}

	RegCloseKey(hkSubKey);

	lResult = RegDeleteKey(hKey, lpSubKey);
    }
    
    return lResult;
} // End SHRegDeleteKey


/* DeviceIDFromDriverName
 *
 * Query MMSYSTEM to find the given device. Return its base device ID.
 * Return -1 if we cannot find the driver
 */
static UINT
DeviceIDFromDriverName(
    PTSTR pstrDriverName)
{
    UINT idxDev;
    UINT cPorts;
    DWORD cPort;
    PTSTR pstrDriver;
    MMRESULT mmr;


    if (NULL == (pstrDriver = LocalAlloc(LPTR, MAX_ALIAS*sizeof(TCHAR))))
    {
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: LocalAlloc() failed.\r\n"));
        return (UINT)-1;
    }

    // Walk through the base device ID of each driver. Use MMSYSTEM's
    // driver query messages to find out how many ports & the driver name
    //
    cPorts = midiOutGetNumDevs();
    for (idxDev = 0; idxDev < cPorts; idxDev++)
    {
        if (MMSYSERR_NOERROR != (mmr = midiOutMessage(HMIDIOUT_INDEX(idxDev),
            DRV_QUERYNUMPORTS,
            (DWORD_PTR)(LPDWORD)&cPort,
            0)))
        {
            // Something is wrong with this driver. Skip it
            //
            AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: DRV_QUERYNUMPORTS(%u)->%u\r\n"),
                       (UINT)idxDev,
                       (UINT)mmr);
            continue;
        }

        if (MMSYSERR_NOERROR != (mmr = midiOutMessage(HMIDIOUT_INDEX(idxDev),
            DRV_QUERYDRVENTRY,
            (DWORD_PTR)(LPTSTR)pstrDriver,
            MAX_ALIAS)))
        {
            AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: DRV_QUERYDRVENTRY(%u)->%u\r\n"),
                       (UINT)idxDev,
                       (UINT)mmr);
            continue;
        }

        if (!_tcscmp(pstrDriver, pstrDriverName))
            break;
    }

    if (idxDev >= cPorts)
    {
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: No match for [%s]\r\n"),
                   (LPTSTR)pstrDriverName);
        idxDev = (UINT)-1;
    }
    else
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: [%s] at %d\r\n"),
                   (LPTSTR)pstrDriverName,
                   (int)idxDev);

    LocalFree(pstrDriver);
    return (int)idxDev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\midi.h ===
/*  MIDI.H
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**
**  Multimedia Control Panel MIDI Applet.
**
**  Display a list of all installed MIDI devices, allow user to configure
**  existing or install new ones.
**
*/ 

//---------------------------------------------------------------------------
#ifndef RC_INVOKED
//---------------------------------------------------------------------------


#ifndef MIDI_DPF
 #define MIDI_DPF AuxDebugEx
#endif

void PASCAL UpdateListBox(HWND hDlg);

#define  MAX_ALIAS     80
#define  NUM_CHANNEL   16
#define  NUM_TABSTOPS  1

#define  BITONE        1

// Common states
#define  CHANGE_NONE    0

// Instrument states
#define  CHANGE_ACTIVE  1
#define  CHANGE_CHANNEL 2

// Driver states
#define  CHANGE_REMOVE  4
#define  CHANGE_ADD     8

#define  IS_INSTRUMENT(hwnd, i)  (!((LPINSTRUMENT)ListBox_GetItemData(hwnd, i))->fDevice)

typedef struct tag_Driver FAR * LPDRIVER;

#ifndef NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#define SetDlgData(h,lp)  SetWindowLongPtr (h, DWLP_USER, (LONG_PTR)lp)
#define GetDlgData(h)     (LPVOID)GetWindowLongPtr (h, DWLP_USER)

// lParam of PROPSHEETPAGE points to a struct like this.
// it is freed in ReleasePropSheet() function.
//
typedef struct _midi_ps_args {
    LPFNMMEXTPROPSHEETCALLBACK  lpfnMMExtPSCallback;
    LPARAM                      lParam;
    TCHAR                       szTitle[1];
    } MPSARGS, * PMPSARGS;

// info for internal & external midi instruments
//
typedef struct _instrum * PINSTRUM;
typedef struct _instrum {
    PINSTRUM      piParent;
    BOOL          bExternal;
    BOOL          bActive;
    BOOL          fGSSynth;
    UINT          uID;
    TCHAR         szKey[MAX_ALIAS];
    TCHAR         szFriendly[MAX_ALIAS];
    } INSTRUM;

// the the loaded array of all instruments, used to refresh
// lists of all instruments and the treeview's of instruments
// and how they are connected
//
typedef struct _midi_instrums {
    HKEY          hkMidi;
    UINT          nInstr;
    BOOL          bHasExternal;
    PINSTRUM      api[128];
    } MCMIDI, * PMCMIDI;

//------------------ function prototypes ------------------------------------

// midi.c
//
INT_PTR CALLBACK MidiCplDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

LONG WINAPI GetAlias (
    HKEY  hKey,
    LPTSTR szSub,
    LPTSTR pszAlias,
    DWORD cbAlias,
    BOOL *pbExtern,
    BOOL *pbActive);

void WINAPI LoadInstruments (
    PMCMIDI pmcm,
    BOOL    bDriverAsAlias);

void WINAPI FreeInstruments (
    PMCMIDI pmcm);

PINSTRUM WINAPI FindInstrument (
    PMCMIDI pmcm,
    LPTSTR  pszFriendly);

void WINAPI KickMapper (
    HWND hWnd);

// iface.c
//
BOOL WINAPI InitIface (
   HINSTANCE hInst,
   DWORD     dwReason,
   LPVOID    lpReserved);

// class.c
//
INT_PTR CALLBACK MidiClassDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

INT_PTR CALLBACK MidiInstrumentDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

INT_PTR MidiInstrumentsWizard (
    HWND  hWnd,
    PMCMIDI pmcm,       // optional
    LPTSTR pszCmd);

//void LoadInstrumentsIntoTree (
//    HWND     hWnd,
//    UINT     uId,
//    LPTSTR   pszSelect,
//    HKEY *   phkMidi);

BOOL WINAPI RemoveInstrumentByKeyName (
    LPCTSTR pszKey);


// containing struct for what would otherwise be global variables
// only one instance of this structure is used.  (declared in main.c)
//
struct _globalstate {
    int                   cRef;

    BOOL                  fLoadedRegInfo;
    TCHAR                 szPlayCmdLn[128];
    TCHAR                 szOpenCmdLn[128];
    TCHAR                 szNewCmdLn[128];

    HWND                  hWndDeviceList;
    HWND                  hWndInstrList;
    //HWND                  hWndMainList;

    BOOL                  fChangeInput;
    BOOL                  fChangeOutput;
    BOOL                  fInputPort;
    DWORD                 dwReconfigFlags;

    WORD                  wHelpMessage;
    WORD                  wFill;

    UINT                  nDrivers;
    UINT                  nMaxDrivers;
    //DRIVER                aDrivers[16];
    };
extern struct _globalstate gs;

#endif // ifndef RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\install.c ===
/*************************************************************************
 *
 *  INSTALL.C
 *
 *  Copyright (C) Microsoft, 1991, All Rights Reserved.
 *
 *  History:
 *
 *      Thu Oct 17 1991 -by- Sanjaya
 *      Created. Culled out of drivers.c
 *
 *************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>
#include <regstr.h>
#include <infstr.h>
#include <cphelp.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"
#include "debug.h"

BOOL     GetValidAlias           (LPTSTR, LPTSTR);
BOOL     SelectInstalled         (HWND, PIDRIVER, LPTSTR, HDEVINFO, PSP_DEVINFO_DATA);
void     InitDrvConfigInfo       (LPDRVCONFIGINFO, PIDRIVER );
BOOL     InstallDrivers          (HWND, HWND, LPTSTR);
void     RemoveAlreadyInstalled  (LPTSTR, LPTSTR);
void     CheckIniDrivers         (LPTSTR, LPTSTR);
void     RemoveDriverParams      (LPTSTR, LPTSTR);

void     InsertNewIDriverNodeInList(PIDRIVER *, PIDRIVER);
void     DestroyIDriverNodeList(PIDRIVER, BOOL, BOOL);


/*
 ***************************************************************
 * Global strings
 ***************************************************************
 */
CONST TCHAR gszDriversSubkeyName[]      = TEXT("Drivers");
CONST TCHAR gszSubClassesValue[]        = TEXT("SubClasses");
CONST TCHAR gszDescriptionValue[]       = TEXT("Description");
CONST TCHAR gszDriverValue[]            = TEXT("Driver");
static CONST TCHAR gszAliasValue[]             = TEXT("Alias");
static CONST TCHAR gszAliasWOW64Value[]        = TEXT("AliasWOW64");
static CONST TCHAR gszWaveWOW64Value[]         = TEXT("WOW64");


/**************************************************************************
 *
 *  InstallDrivers()
 *
 *  Install a driver and set of driver types.
 *
 *  Parameters :
 *      hwnd      - Window handle of the main drivers.cpl windows
 *      hwndAvail - Handle of the 'available drivers' dialog window
 *      pstrKey   - Key name of the inf section item we are installing
 *
 *  This routine calls itself recursively to install related drivers
 *  (as listed in the .inf file).
 *
 **************************************************************************/

BOOL InstallDrivers(HWND hWnd, HWND hWndAvail, LPTSTR pstrKey)
{
    IDRIVER     IDTemplate; // temporary for installing, removing, etc.
    PIDRIVER    pIDriver=NULL;
    int         n;
    TCHAR        szTypes[MAXSTR];
    TCHAR        szType[MAXSTR];
    TCHAR        szParams[MAXSTR];

    szTypes[0] = TEXT('\0');

    hMesgBoxParent = hWndAvail;

    /*
     * mmAddNewDriver needs a buffer for all types we've actually installed
     * User critical errors will pop up a task modal
     */

    IDTemplate.bRelated = FALSE;
    IDTemplate.szRemove[0] = TEXT('\0');

    /*
     *  Do the copying and extract the list of types (WAVE, MIDI, ...)
     *  and the other driver data
     */

    if (!mmAddNewDriver(pstrKey, szTypes, &IDTemplate))
        return FALSE;

    szTypes[lstrlen(szTypes)-1] = TEXT('\0');         // Remove space left at end

    RemoveAlreadyInstalled(IDTemplate.szFile, IDTemplate.szSection);

    /*
     *  At this point we assume the drivers were actually copied.
     *  Now we need to add them to the installed list.
     *  For each driver type we create an IDRIVER and add to the listbox
     */

    for (n = 1; infParseField(szTypes, n, szType); n++)
    {
        /*
         *  Find a valid alias for this device (eg Wave2).  This is
         *  used as the key in the [MCI] or [drivers] section.
         */

        if (GetValidAlias(szType, IDTemplate.szSection) == FALSE)
        {
            /*
             *  Exceeded the maximum, tell the user
             */

            LPTSTR pstrMessage;
            TCHAR szApp[MAXSTR];
            TCHAR szMessage[MAXSTR];

            LoadString(myInstance,
                       IDS_CONFIGURE_DRIVER,
                       szApp,
                       sizeof(szApp)/sizeof(TCHAR));

            LoadString(myInstance,
                       IDS_TOO_MANY_DRIVERS,
                       szMessage,
                       sizeof(szMessage)/sizeof(TCHAR));

            if (NULL !=
                (pstrMessage =
                 (LPTSTR)LocalAlloc(LPTR,
                                    sizeof(szMessage) + (lstrlen(szType)*sizeof(TCHAR)))))
            {
                wsprintf(pstrMessage, szMessage, (LPTSTR)szType);

                MessageBox(hWndAvail,
                           pstrMessage,
                           szApp,
                           MB_OK | MB_ICONEXCLAMATION|MB_TASKMODAL);

                LocalFree((HANDLE)pstrMessage);
            }
            continue;
        }

        if ( (pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER))) != NULL)
        {
            /*
             *  Copy all fields
             */

            memcpy(pIDriver, &IDTemplate, sizeof(IDRIVER));
            wcsncpy(pIDriver->szAlias, szType, sizeof(pIDriver->szAlias)/sizeof(TCHAR));
            pIDriver->szAlias[sizeof(pIDriver->szAlias)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszAlias, pIDriver->szAlias);


            /*
             *  Want only one instance of each driver to show up in the list
             *  of installed drivers. Thus for the remaining drivers just
             *  place an entry in the drivers section of system.ini
             */


            if ( n > 1)
            {


                if (wcslen(szParams) != 0 && !pIDriver->KernelDriver)
                {
                    /*
                     *  Write their parameters to a section bearing their
                     *  file name with an alias reflecting their alias
                     */

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       szParams);
                }

                WritePrivateProfileString(pIDriver->szSection,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szSysIni);
            }
            else
            {


                /*
                 *  Reduce to just the driver name
                 */

                RemoveDriverParams(pIDriver->szFile, szParams);

                wcscpy(pIDriver->wszFile, pIDriver->szFile);

                if (wcslen(szParams) != 0 && !pIDriver->KernelDriver)
                {
                    /*
                     *  Write their parameters to a section bearing their
                     *  file name with an alias reflecting their alias
                     */

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       szParams);
                }

                WritePrivateProfileString(pIDriver->szSection,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szSysIni);

                /*
                 *  Call the driver to see if it can be configured
                 *  and configure it if it can be
                 */

                if (!SelectInstalled(hWndAvail, pIDriver, szParams, INVALID_HANDLE_VALUE, NULL))
                {

                    /*
                     *  Error talking to driver
                     */

                    WritePrivateProfileString(pIDriver->szSection,
                                              pIDriver->szAlias,
                                              NULL,
                                              szSysIni);

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       NULL);

                    RemoveIDriver (hAdvDlgTree, pIDriver, TRUE);
                    return FALSE;
                }

                /*
                 *  for displaying the driver desc. in the restart mesg
                 */

                if (!bRelated || pIDriver->bRelated)
                {
                    wcscpy(szRestartDrv, pIDriver->szDesc);
                }

                /*
                 *  We need to write out the driver description to the
                 *  control.ini section [Userinstallable.drivers]
                 *  so we can differentiate between user and system drivers
                 *
                 *  This is tested by the function UserInstalled when
                 *  the user tries to remove a driver and merely
                 *  affects which message the user gets when being
                 *  asked to confirm removal (non user-installed drivers
                 *  are described as being necessary to the system).
                 */

                WritePrivateProfileString(szUserDrivers,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szControlIni);


                /*
                 *  Update [related.desc] section of control.ini :
                 *
                 *  ALIAS=driver name list
                 *
                 *  When the driver whose alias is ALIAS is removed
                 *  the drivers in the name list will also be removed.
                 *  These were the drivers in the related drivers list
                 *  when the driver is installed.
                 */

                WritePrivateProfileString(szRelatedDesc,
                                          pIDriver->szAlias,
                                          pIDriver->szRemove,
                                          szControlIni);


                /*
                 * Cache the description string in control.ini in the
                 * drivers description section.
                 *
                 * The key is the driver file name + extension.
                 */

                WritePrivateProfileString(szDriversDesc,
                                          pIDriver->szFile,
                                          pIDriver->szDesc,
                                          szControlIni);

#ifdef DOBOOT // We don't do the boot section on NT

                if (bInstallBootLine)
                {
                    szTemp[MAXSTR];

                    GetPrivateProfileString(szBoot,
                                            szDrivers,
                                            szTemp,
                                            szTemp,
                                            sizeof(szTemp) / sizeof(TCHAR),
                                            szSysIni);
                    wcscat(szTemp, TEXT(" "));
                    wcscat(szTemp, pIDriver->szAlias);
                    WritePrivateProfileString(szBoot,
                                              szDrivers,
                                              szTemp,
                                              szSysIni);
                    bInstallBootLine = FALSE;
                }
#endif // DOBOOT
            }
        }
        else
            return FALSE;                       //ERROR
    }


    /*
     *  If no types were added then fail
     */

    if (pIDriver == NULL)
    {
        return FALSE;
    }

    /*
     *  If there are related drivers listed in the .inf section to install
     *  then install them now by calling ourselves.  Use IDTemplate which
     *  is where mmAddNewDriver put the data.
     */

    if (IDTemplate.bRelated == TRUE)
    {

        int i;
        TCHAR szTemp[MAXSTR];

        /*
         *  Tell file copying to abort rather than put up errors
         */

        bCopyingRelated = TRUE;

        for (i = 1; infParseField(IDTemplate.szRelated, i, szTemp);i++)
        {

            InstallDrivers(hWnd, hWndAvail, szTemp);
        }
    }
    return TRUE;
}

BOOL SelectInstalledKernelDriver(PIDRIVER pIDriver, LPTSTR pszParams)
{
    SC_HANDLE SCManagerHandle;
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    TCHAR BinaryPath[MAX_PATH];
    BOOL Success;
    SC_LOCK ServicesDatabaseLock;
    DWORD dwTagId;

    /*
     *  These drivers are not configurable
     */

    pIDriver->fQueryable = 0;

    /*
     *  The services controller will create the registry node to
     *  which we can add the device parameters value
     */

    wcscpy(BinaryPath, TEXT("\\SystemRoot\\system32\\drivers\\"));
    wcscat(BinaryPath, pIDriver->szFile);

    /*
     *  First try and obtain a handle to the service controller
     */

    SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (SCManagerHandle == NULL)
        return FALSE;

    /*
     *  Lock the service controller database to avoid deadlocks
     *  we have to loop because we can't wait
     */


    for (ServicesDatabaseLock = NULL;
        (ServicesDatabaseLock =
         LockServiceDatabase(SCManagerHandle))
        == NULL;
        Sleep(100))
    {
    }

    {
        TCHAR drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
        lsplitpath(pIDriver->szFile, drive, directory, ServiceName, ext);
    }


    ServiceHandle = CreateService(SCManagerHandle,
                                  ServiceName,
                                  NULL,
                                  SERVICE_ALL_ACCESS,
                                  SERVICE_KERNEL_DRIVER,
                                  SERVICE_DEMAND_START,
                                  SERVICE_ERROR_NORMAL,
                                  BinaryPath,
                                  TEXT("Base"),
                                  &dwTagId,
                                  TEXT("\0"),
                                  NULL,
                                  NULL);

    UnlockServiceDatabase(ServicesDatabaseLock);

    if (ServiceHandle == NULL)
    {
        CloseServiceHandle(SCManagerHandle);
        return FALSE;
    }

    /*
     *  Try to write the parameters to the registry if there
     *  are any
     */

    if (wcslen(pszParams))
    {

        HKEY ParmsKey;
        TCHAR RegPath[MAX_PATH];
        wcscpy(RegPath, TEXT("\\SYSTEM\\CurrentControlSet\\Services\\"));
        wcscat(RegPath, ServiceName);
        wcscat(RegPath, TEXT("\\Parameters"));

        Success = RegCreateKey(HKEY_LOCAL_MACHINE,
                               RegPath,
                               &ParmsKey) == ERROR_SUCCESS &&
                  RegSetValue(ParmsKey,
                              TEXT(""),
                              REG_SZ,
                              pszParams,
                              wcslen(pszParams)*sizeof(TCHAR)) == ERROR_SUCCESS &&
                  RegCloseKey(ParmsKey) == ERROR_SUCCESS;

    }
    else
    {
        Success = TRUE;
    }

    /*
     *  Service created so try and start it
     */

    if (Success)
    {
        //  We tell them to restart just in case
        bRestart = TRUE;

        /*
         *  Load the kernel driver by starting the service.
         *  If this is successful it should be safe to let
         *  the system load the driver at system start so
         *  we change the start type.
         */

        Success =
            StartService(ServiceHandle, 0, NULL) &&
            ChangeServiceConfig(ServiceHandle,
                                SERVICE_NO_CHANGE,
                                SERVICE_SYSTEM_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (!Success)
        {
            TCHAR szMesg[MAXSTR];
            TCHAR szMesg2[MAXSTR];
            TCHAR szTitle[50];

            /*
             *  Uninstall driver if we couldn't load it
             */

            for (ServicesDatabaseLock = NULL;
                (ServicesDatabaseLock =
                 LockServiceDatabase(SCManagerHandle))
                == NULL;
                Sleep(100))
            {
            }

            DeleteService(ServiceHandle);

            UnlockServiceDatabase(ServicesDatabaseLock);

            /*
             *  Tell the user there was a configuration error
             *  (our best guess).
             */

            LoadString(myInstance, IDS_DRIVER_CONFIG_ERROR, szMesg, sizeof(szMesg)/sizeof(TCHAR));
            LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            wsprintf(szMesg2, szMesg, FileName(pIDriver->szFile));
            MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
        }
    }

    CloseServiceHandle(ServiceHandle);
    CloseServiceHandle(SCManagerHandle);

    return Success;
}

/************************************************************************
 *
 *  SelectInstalled()
 *
 *  Check if the driver can be configured and configure it if it can be.
 *
 *  hwnd           - Our window - parent for driver to make its config window
 *  pIDriver       - info about the driver
 *  params         - the drivers parameters from the .inf file.
 *  DeviceInfoSet  - Optionally, specifies the set containing the PnP device
 *                   being installed.  Specify INVALID_HANDLE_VALUE is this
 *                   parameter is not present.
 *  DeviceInfoData - Optionally, specifies the PnP device being installed
 *                   (ignored if DeviceInfoSet is not specified).
 *
 *  Returns FALSE if an error occurred, otherwise TRUE.  GetLastError() may
 *  be called to determine the cause of the failure.
 *
 ************************************************************************/

BOOL SelectInstalled(HWND hwnd, PIDRIVER pIDriver, LPTSTR pszParams, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    BOOL bSuccess      = TRUE;  // Assume we succeed
    BOOL bPutUpMessage = FALSE; // Assume we don't have to put up a message
    HANDLE hDriver = 0;
    DRVCONFIGINFO DrvConfigInfo;
    DWORD_PTR DrvMsgResult;
    DWORD ConfigFlags;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HKEY hkDrv = NULL;

    // Open device reg key
    hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                 DeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_ALL_ACCESS);

    if (!hkDrv)
    {
        return GetLastError();
    }

    wsStartWait();

    /*
     *  If it's a kernel driver call the services controller to
     *  install the driver (unless it's a PnP device, in which case
     *  SetupDiInstallDevice would've already handled any necessary
     *  service installation).
     */

    if (pIDriver->KernelDriver)
    {
        // If DeviceInfoSet is a valid handle, then this is a PnP device
        // and there's nothing we need to do. Otherwise, config the kernel driver.
        if (DeviceInfoSet == INVALID_HANDLE_VALUE)
            bSuccess = SelectInstalledKernelDriver(pIDriver,pszParams);
        goto SelectInstalled_exit;
    }

    //  See if we can open the driver
    hDriver = OpenDriver(pIDriver->wszFile, NULL, 0L);

    if (!hDriver)
    {
        bSuccess      = FALSE;
        bPutUpMessage = TRUE;
        goto SelectInstalled_exit;
    }

    // Driver opened, prepare to send config messages to driver
    InitDrvConfigInfo(&DrvConfigInfo, pIDriver);

    // On ISAPNP devices, we need to set the CONFIGFLAG_NEEDS_FORCED_CONFIG before
    // we call into the driver to setup resources.
    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_CONFIGFLAGS,
                                          NULL,
                                          (PBYTE)&ConfigFlags,
                                          sizeof(ConfigFlags),
                                          NULL))
    {
        ConfigFlags = 0;
    }

    ConfigFlags |= CONFIGFLAG_NEEDS_FORCED_CONFIG;

    SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_CONFIGFLAGS,
                                     (PBYTE)&ConfigFlags,
                                     sizeof(ConfigFlags)
                                    );

    // See if this is a PnP device by trying to send it a PnP install message.
    // Call driver with DRV_PNPINSTALL
    DrvMsgResult = SendDriverMessage(hDriver,
                                     DRV_PNPINSTALL,
                                     (LONG_PTR)DeviceInfoSet,
                                     (LONG_PTR)DeviceInfoData);

    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

    // Look at result of DRV_PNPINSTALL
    switch (DrvMsgResult)
    {
    case DRVCNF_RESTART :
        // The installation was successful, but a reboot is required.
        // Ensure that the 'need reboot' flag in the device's installation parameters.
        DeviceInstallParams.Flags |= DI_NEEDREBOOT;

        // Let fall through to processing of successful installation.
    case DRVCNF_OK :
        // Remember that this is a PNPISA device driver
        RegSetValueEx(hkDrv,TEXT("DriverType"),0,REG_SZ,(LPBYTE)(TEXT("PNPISA")),14);

        break;

    default:
        // The driver did not want to install.
        // This may be because
        // 1) The user wanted to cancel
        // 2) Installation failed for some other reason
        // 3) This is not an ISAPNP driver (it's either a legacy driver or a WDM driver)
        //    and it doesn't support the DRV_PNPINSTALLis messsage.
        // Unfortunately, we don't have fine enough granularity in the return codes to
        // distinguish between these cases.

        // Assume it's a legacy or WDM driver that doesn't support DRV_PNPINSTALL.
        // Try calling DRV_INSTALL instead.

        // Remember to clear CONFIGFLAG_NEEDS_FORCED_CONFIG flag, which shouldn't be set
        // for legacy or WDM drivers.
        ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags)
                                        );

        // Call driver with DRV_INSTALL
        DrvMsgResult = SendDriverMessage(hDriver,
                                         DRV_INSTALL,
                                         0L,
                                         (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo);
        // Look at result of DRV_INSTALL
        switch (DrvMsgResult)
        {
        case DRVCNF_RESTART:
            // Remember to restart, then fall through to OK case
            DeviceInstallParams.Flags |= DI_NEEDREBOOT;
            bRestart = TRUE;
        case DRVCNF_OK:
            // Remember whether the driver is configurable
            // If it's a WDM driver, it will return FALSE.
            pIDriver->fQueryable =
                (int)SendDriverMessage(hDriver,
                                       DRV_QUERYCONFIGURE,
                                       0L,
                                       0L);

            // If the driver is configurable then configure it.
            // Configuring the driver may result in a need to restart
            // the system.  The user may also cancel install.
            if (pIDriver->fQueryable)
            {
                RegSetValueEx(hkDrv,TEXT("DriverType"),0,REG_SZ,(LPBYTE)(TEXT("Legacy")),14);

                switch (SendDriverMessage(hDriver,
                                          DRV_CONFIGURE,
                                          (LONG_PTR)hwnd,
                                          (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo))
                {
                case DRVCNF_RESTART:
                    DeviceInstallParams.Flags |= DI_NEEDREBOOT;
                    bRestart = TRUE;
                case DRVCNF_OK:
                    break;

                case DRVCNF_CANCEL:
                    // Don't put up the error box if the user cancelled
                    bSuccess = FALSE;
                    break;
                }
            }
            break;
        case DRVCNF_CANCEL:
            // The driver did not want to install
            SetLastError(ERROR_CANCELLED);
            bPutUpMessage = TRUE;
            bSuccess = FALSE;
            break;
        }
    }

    SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

    SelectInstalled_exit:

    if (hkDrv)
    {
        RegCloseKey(hkDrv);
    }

    if (hDriver)
    {
        CloseDriver(hDriver, 0L, 0L);
    }

    //  If dealing with the driver resulted in error then put up a message
    if (bPutUpMessage)
    {
        OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
    }

    wsEndWait();

    return bSuccess;
}

/***********************************************************************
 *
 *  InitDrvConfigInfo()
 *
 *  Initialize Driver Configuration Information.
 *
 ***********************************************************************/

void InitDrvConfigInfo( LPDRVCONFIGINFO lpDrvConfigInfo, PIDRIVER pIDriver )
{
    lpDrvConfigInfo->dwDCISize          = sizeof(DRVCONFIGINFO);
    lpDrvConfigInfo->lpszDCISectionName = pIDriver->wszSection;
    lpDrvConfigInfo->lpszDCIAliasName   = pIDriver->wszAlias;
}

/***********************************************************************
 *
 *  GetValidAlias()
 *
 *  pstrType     - Input  - the type
 *                 Output - New alias for that type
 *
 *  pstrSection  - The system.ini section we're dealing with
 *
 *  Create a valid alias name for a type.  Searches the system.ini file
 *  in the drivers section for aliases of the type already defined and
 *  returns a new alias (eg WAVE1).
 *
 ***********************************************************************/
BOOL GetValidAlias(LPTSTR pstrType, LPTSTR pstrSection)
{
    TCHAR keystr[32];
    TCHAR *pstrTypeEnd;
    int AppendVal;
    DWORD CharsFound;

    pstrTypeEnd = pstrType + wcslen(pstrType);
    for (AppendVal=0; AppendVal<=9; AppendVal++)
    {
        if (AppendVal!=0)
        {
            _itow(AppendVal,pstrTypeEnd,10);
        }

        CharsFound = GetPrivateProfileString( pstrSection,
                                            pstrType,
                                            TEXT(""),
                                            keystr,
                                            sizeof(keystr) / sizeof(TCHAR),
                                            szSysIni);

        if (!CharsFound)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*******************************************************************
 *
 *  IsConfigurable
 *
 *  Find if a driver supports configuration
 *
 *******************************************************************/

BOOL IsConfigurable(PIDRIVER pIDriver, HWND hwnd)
{
    HANDLE hDriver;

    wsStartWait();

    /*
     *  have we ever checked if this driver is queryable?
     */

    if ( pIDriver->fQueryable == -1 )
    {

        /*
         *  Check it's not a kernel driver
         */

        if (pIDriver->KernelDriver)
        {
            pIDriver->fQueryable = 0;
        }
        else
        {

            /*
             *  Open the driver and ask it if it is configurable
             */

            hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

            if (hDriver)
            {
                pIDriver->fQueryable =
                    (int)SendDriverMessage(hDriver,
                                           DRV_QUERYCONFIGURE,
                                           0L,
                                           0L);

                CloseDriver(hDriver, 0L, 0L);
            }
            else
            {
                pIDriver->fQueryable = 0;
                OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
                wsEndWait();
                return(FALSE);
            }
        }
    }
    wsEndWait();
    return((BOOL)pIDriver->fQueryable);
}

/******************************************************************
 *
 *  Find any driver with the same name currently installed and
 *  remove it
 *
 *  szFile     - File name of driver
 *  szSection  - system.ini section ([MCI] or [drivers]).
 *
 ******************************************************************/

void RemoveAlreadyInstalled(LPTSTR szFile, LPTSTR szSection)
{
    PIDRIVER pIDriver;

    pIDriver = FindIDriverByName (szFile);

    if (pIDriver != NULL)
    {
        PostRemove(pIDriver, FALSE);
        return;
    }

    CheckIniDrivers(szFile, szSection);
}

/******************************************************************
 *
 *  Remove system.ini file entries for our driver
 *
 *  szFile    - driver file name
 *  szSection - [drivers] or [MCI]
 *
 ******************************************************************/

void CheckIniDrivers(LPTSTR szFile, LPTSTR szSection)
{
    TCHAR allkeystr[MAXSTR * 2];
    TCHAR szRemovefile[20];
    TCHAR *keystr;

    GetPrivateProfileString(szSection,
                            NULL,
                            NULL,
                            allkeystr,
                            sizeof(allkeystr) / sizeof(TCHAR),
                            szSysIni);

    keystr = allkeystr;
    while (wcslen(keystr) > 0)
    {

        GetPrivateProfileString(szSection,
                                keystr,
                                NULL,
                                szRemovefile,
                                sizeof(szRemovefile) / sizeof(TCHAR),
                                szSysIni);

        if (!FileNameCmp(szFile, szRemovefile))
            RemoveDriverEntry(keystr, szFile, szSection, FALSE);

        keystr = &keystr[wcslen(keystr) + 1];
    }
}

/******************************************************************
 *
 *   RemoveDriverParams
 *
 *   Remove anything after the next token
 *
 ******************************************************************/

void RemoveDriverParams(LPTSTR szFile, LPTSTR Params)
{
    for (;*szFile == TEXT(' '); szFile++);
    for (;*szFile != TEXT(' ') && *szFile != TEXT('\0'); szFile++);
    if (*szFile == TEXT(' '))
    {
        *szFile = TEXT('\0');
        for (;*++szFile == TEXT(' '););
        wcscpy(Params, szFile);
    }
    else
    {
        *Params = TEXT('\0');
    }
}


DWORD
    InstallDriversForPnPDevice(
                              IN HWND             hWnd,
                              IN HDEVINFO         DeviceInfoSet,
                              IN PSP_DEVINFO_DATA DeviceInfoData
                              )
/*++

Routine Description:

    This routine traverses the "Drivers" tree under the specified device's software
    key, adding each multimedia type entry present to the Drivers32 key of the registry.
    The driver is then invoked to perform any configuration necessary for that type.

Arguments:

    hWnd - Supplies the handle of the window to be used as the parent for any UI.

    DeviceInfoSet - Supplies a handle to the device information set containing the
        multimedia device being installed.

    DeviceInfoData - Supplies the address of the SP_DEVINFO_DATA structure representing
        the multimedia device being installed.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error code.

--*/
{
    HKEY hKey, hDriversKey, hTypeInstanceKey;
    TCHAR szTypes[MAXSTR];
    TCHAR szType[MAXSTR];
    DWORD Err;
    DWORD RegDataType, cbRegDataSize, RegKeyIndex;
    int i;
    PIDRIVER pIDriver, pPrevIDriver;
    PIDRIVER IDriverList = NULL, IDriverListToCleanUp = NULL;
    TCHAR CharBuffer[MAX_PATH + sizeof(TCHAR)];
    LPCTSTR CurrentFilename;
    BOOL bNoMoreAliases = FALSE;
    LPCTSTR szAliasStringToUse;   // Pointer to the Alias value name to use
    BOOL bIsWOW64Process = FALSE; // TRUE if we're running under WOW64

    //
    // If we're running in WOW64, we need to use a different Alias string so that
    // we don't overwrite the 64-bit alias string
    //
    if( IsWow64Process(GetCurrentProcess(), &bIsWOW64Process)
    &&  bIsWOW64Process )
    {
        szAliasStringToUse = gszAliasWOW64Value;
    }
    else
    {
        szAliasStringToUse = gszAliasValue;
    }

    if ((hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                     DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DRV,
                                     KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    //
    // What we're really interested in is the "Drivers" subkey.
    //
    Err = (DWORD)RegOpenKeyEx(hKey, gszDriversSubkeyName, 0, KEY_ALL_ACCESS, &hDriversKey);

    RegCloseKey(hKey);      // don't need this key anymore.

    if (Err != ERROR_SUCCESS)
    {
        //
        // If the key is not present, then there is no work to do.
        //
        return NO_ERROR;
    }

    //
    // Retrieve the "SubClasses" value from this key.  This contains a comma-delimited
    // list of all multimedia type entries associated with this device.
    //
    cbRegDataSize = sizeof(szTypes);
    if ((Err = RegQueryValueEx(hDriversKey,
                               gszSubClassesValue,
                               NULL,
                               &RegDataType,
                               (PBYTE)szTypes,
                               &cbRegDataSize)) != ERROR_SUCCESS)
    {
        goto clean0;
    }

    if ((RegDataType != REG_SZ) || !cbRegDataSize)
    {
        Err = ERROR_INVALID_DATA;
        goto clean0;
    }


    //
    // OK, we have the list of types, now process each one.
    //
    for (i = 1; ((Err == NO_ERROR) && infParseField(szTypes, i, szType)); i++)
    {

#ifdef _WIN64
        //
        // Check for magic WaveWOW64 value
        if( 0 == _wcsnicmp( szType, gszWaveWOW64Value, wcslen(gszWaveWOW64Value) ) )
        {
            // Thunk the installation to the 32-bit mmsys.cpl installer
            mmWOW64ThunkMediaClassInstaller(DIF_INSTALLDEVICE, DeviceInfoSet, DeviceInfoData);

            continue;
        }
#endif //_WIN64

        if (RegOpenKeyEx(hDriversKey, szType, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        {
            //
            // Couldn't find a subkey for this entry--move on to the next one.
            //
            continue;
        }

        for (RegKeyIndex = 0;
            ((Err == NO_ERROR) &&
             (RegEnumKey(hKey, RegKeyIndex, CharBuffer, sizeof(CharBuffer)/sizeof(TCHAR)) == ERROR_SUCCESS));
            RegKeyIndex++)
        {
            if (RegOpenKeyEx(hKey, CharBuffer, 0, KEY_ALL_ACCESS, &hTypeInstanceKey) != ERROR_SUCCESS)
            {
                //
                // For some reason, we couldn't open the key we just enumerated.  Oh well, move on
                // to the next one.
                //
                continue;
            }

            if (!(pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER))))
            {
                //
                // Not enough memory!  Abort the whole thing.
                //
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto CloseInstanceAndContinue;
            }

            //
            // Retrieve the description and driver filename from this key.
            //
            cbRegDataSize = sizeof(pIDriver->szDesc);
            if ((RegQueryValueEx(hTypeInstanceKey,
                                 gszDescriptionValue,
                                 NULL,
                                 &RegDataType,
                                 (LPBYTE)pIDriver->szDesc,
                                 &cbRegDataSize) != ERROR_SUCCESS)
                || (RegDataType != REG_SZ) || !cbRegDataSize)
            {
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            wcsncpy(pIDriver->szSection,
                    wcsstr(pIDriver->szDesc, TEXT("MCI")) ? szMCI : szDrivers,
                    sizeof(pIDriver->szSection) / sizeof(TCHAR)
                   );

            cbRegDataSize = sizeof(pIDriver->szFile);
            if ((RegQueryValueEx(hTypeInstanceKey,
                                 gszDriverValue,
                                 NULL,
                                 &RegDataType,
                                 (LPBYTE)pIDriver->szFile,
                                 &cbRegDataSize) != ERROR_SUCCESS)
                || (RegDataType != REG_SZ) || !cbRegDataSize)
            {
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            pIDriver->KernelDriver = IsFileKernelDriver(pIDriver->szFile);

            //
            // Find a valid alias for this device (eg Wave2).  This is
            // used as the key in the [MCI] or [Drivers32] section.
            //
            wcsncpy(pIDriver->szAlias, szType, sizeof(pIDriver->szAlias) / sizeof(TCHAR));

            if (!GetValidAlias(pIDriver->szAlias, pIDriver->szSection))
            {
                //
                // Exceeded the maximum--but can't tell the user.  We can't bring up a dialog
                // in the services.exe process
                //
                bNoMoreAliases = TRUE;
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            //
            // Fill in the Unicode fields from the ANSI ones.
            //
            wcscpy(pIDriver->wszSection, pIDriver->szSection);
            wcscpy(pIDriver->wszAlias,   pIDriver->szAlias);
            wcscpy(pIDriver->wszFile,    pIDriver->szFile);

            //
            // We must write the alias out now, because we may need to generate
            // other aliases for this same type, and we can't generate a unique
            // alias unless all existing aliases are present in the relevant
            // registry key.
            //
            WritePrivateProfileString(pIDriver->szSection,
                                      pIDriver->szAlias,
                                      pIDriver->szFile,
                                      szSysIni
                                     );

            //
            // We also must write the alias out to the key we're currently in (under
            // the device's software key), because during uninstall, we need to be
            // able to figure out what devices get removed.
            //
            RegSetValueEx(hTypeInstanceKey,
                          szAliasStringToUse,
                          0,
                          REG_SZ,
                          (PBYTE)(pIDriver->szAlias),
                          (wcslen(pIDriver->szAlias)*sizeof(TCHAR)) + sizeof(TCHAR)
                         );

            //
            // Add this new IDriver node to our linked list.  The list is sorted by
            // driver filename, and this node should be inserted at the end of the
            // the group of nodes that have the same driver filename.
            //
            InsertNewIDriverNodeInList(&IDriverList, pIDriver);

            CloseInstanceAndContinue:

            RegCloseKey(hTypeInstanceKey);
        }

        RegCloseKey(hKey);
    }

    if ((Err == NO_ERROR) && !IDriverList)
    {
        //  We actually don't want to present the ugly "Data is invalid" error if we ran out of aliases
        if (bNoMoreAliases)
        {
            DestroyIDriverNodeList(IDriverList, TRUE, FALSE);
            goto clean0;
        }
        else
        {
            //
            // We didn't find anything to install!
            //
            Err = ERROR_INVALID_DATA;
        }
    }

    if (Err != NO_ERROR)
    {
        //
        // Clean up anything we put in the multimedia sections of the registry.
        //
        DestroyIDriverNodeList(IDriverList, TRUE, FALSE);
        goto clean0;
    }

    //
    // If we get to here, then we've successfully built up a list of all driver entries
    // we need to install.  Now, traverse the list, and install each one.
    //
    CurrentFilename = NULL;
    *CharBuffer = TEXT('\0');        // use this character buffer to contain (empty) parameter string.
    pIDriver = IDriverList;
    pPrevIDriver = NULL;

    while (pIDriver)
    {
        if (!CurrentFilename || _wcsicmp(CurrentFilename, pIDriver->szFile))
        {
            //
            // This is the first entry we've encountered for this driver.  We need
            // to call the driver to see if it can be configured, and configure it
            // if it can be.
            //
            if (SelectInstalled(hWnd, pIDriver, CharBuffer, DeviceInfoSet, DeviceInfoData))
            {
                //
                // Move this IDriver node to our list of clean-up items.  This is used in
                // case we hit an error with some other driver, and we need to notify this
                // driver that even though it was successful, someone else messed up and
                // complete removal of the device must occur.
                //
                if (pPrevIDriver)
                {
                    pPrevIDriver->related = pIDriver->related;
                }
                else
                {
                    IDriverList = pIDriver->related;
                }
                pIDriver->related = IDriverListToCleanUp;
                IDriverListToCleanUp = pIDriver;
            }
            else
            {
                //
                // Error talking to driver
                //
                Err = GetLastError();
                goto clean1;
            }

#if 0       // We don't need this piece of code in the Plug&Play install case.

            /*
             *  for displaying the driver desc. in the restart mesg
             */
            if (!bRelated || pIDriver->bRelated)
            {
                wcscpy(szRestartDrv, pIDriver->szDesc);
            }
#endif

            //
            // We need to write out the driver description to the
            // control.ini section [Userinstallable.drivers]
            // so we can differentiate between user and system drivers
            //
            // This is tested by the function UserInstalled when
            // the user tries to remove a driver and merely
            // affects which message the user gets when being
            // asked to confirm removal (non user-installed drivers
            // are described as being necessary to the system).
            //
            WritePrivateProfileString(szUserDrivers,
                                      pIDriver->szAlias,
                                      pIDriver->szFile,
                                      szControlIni
                                     );

            //
            // Update [related.desc] section of control.ini :
            //
            // ALIAS=driver name list
            //
            // When the driver whose alias is ALIAS is removed
            // the drivers in the name list will also be removed.
            // These were the drivers in the related drivers list
            // when the driver is installed.
            //
            WritePrivateProfileString(szRelatedDesc,
                                      pIDriver->szAlias,
                                      pIDriver->szRemove,
                                      szControlIni
                                     );

            //
            // Cache the description string in control.ini in the
            // drivers description section.
            //
            // The key is the driver file name + extension.
            //
            WritePrivateProfileString(szDriversDesc,
                                      pIDriver->szFile,
                                      pIDriver->szDesc,
                                      szControlIni
                                     );

#ifdef DOBOOT // We don't do the boot section on NT

            if (bInstallBootLine)
            {
                szTemp[MAXSTR];

                GetPrivateProfileString(szBoot,
                                        szDrivers,
                                        szTemp,
                                        szTemp,
                                        sizeof(szTemp) / sizeof(TCHAR),
                                        szSysIni);
                wcscat(szTemp, TEXT(" "));
                wcscat(szTemp, pIDriver->szAlias);
                WritePrivateProfileString(szBoot,
                                          szDrivers,
                                          szTemp,
                                          szSysIni);
                bInstallBootLine = FALSE;
            }
#endif // DOBOOT

            //
            // Update our "CurrentFilename" pointer, so that we'll know when we
            // move from one driver filename to another.
            //
            CurrentFilename = pIDriver->szFile;

            //
            // Move on to the next IDriver node IN THE ORIGINAL LIST.  We can't simply
            // move on the 'related' pointer in our node anymore, since we moved it
            // into our clean-up list.
            //
            if (pPrevIDriver)
            {
                pIDriver = pPrevIDriver->related;
            }
            else
            {
                pIDriver = IDriverList;
            }

        }
        else
        {
            //
            // We've already configured this driver.  Leave it in its original list,
            // and move on to the next node.
            //
            pPrevIDriver = pIDriver;
            pIDriver = pIDriver->related;
        }
    }

    clean1:

    DestroyIDriverNodeList(IDriverListToCleanUp, (Err != NO_ERROR), TRUE);
    DestroyIDriverNodeList(IDriverList, (Err != NO_ERROR), FALSE);

    clean0:

    RegCloseKey(hDriversKey);

    return Err;
}


void
    InsertNewIDriverNodeInList(
                              IN OUT PIDRIVER *IDriverList,
                              IN     PIDRIVER  NewIDriverNode
                              )
/*++

Routine Description:

    This routine inserts a new IDriver node into the specified linked list of IDriver
    nodes.  The list is sorted by driver filename, and this node will be placed after
    any existing nodes having this same driver filename.

Arguments:

    IDriverList - Supplies the address of the variable that points to the head of the
        linked list.  If the new node is inserted at the head of the list, this variable
        will be updated upon return to reflect the new head of the list.

    NewIDriverNode - Supplies the address of the new driver node to be inserted into the
        list.

Return Value:

    None.

--*/
{
    PIDRIVER CurNode, PrevNode;

    for (CurNode = *IDriverList, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->related)
    {
        if (_wcsicmp(CurNode->szFile, NewIDriverNode->szFile) > 0)
        {
            break;
        }
    }

    //
    // Insert the new IDriver node in front of the current one.
    //
    NewIDriverNode->related = CurNode;
    if (PrevNode)
    {
        PrevNode->related = NewIDriverNode;
    }
    else
    {
        *IDriverList = NewIDriverNode;
    }
}


void
    DestroyIDriverNodeList(
                          IN PIDRIVER IDriverList,
                          IN BOOL     CleanRegistryValues,
                          IN BOOL     NotifyDriverOfCleanUp
                          )
/*++

Routine Description:

    This routine frees all memory associated with the nodes in the specified IDriver
    linked list.  It also optionally cleans up any modifications that were previously
    made as a result of an attempted install.

Arguments:

    IDriverList - Points to the head of the linked list of IDriver nodes.

    CleanRegistryValues - If TRUE, then the multimedia registry values previously
        created (e.g., Drivers32 aliases) will be deleted.

    NotifyDriverOfCleanUp - If TRUE, then the driver will be notified of its removal.
        This only applies to non-kernel (i.e., installable) drivers, and this flag is
        ignored if CleanRegistryValues is FALSE.

Return Value:

    None.

--*/
{
    PIDRIVER NextNode;
    HANDLE hDriver;

    while (IDriverList)
    {
        NextNode = IDriverList->related;
        if (CleanRegistryValues)
        {
            if (NotifyDriverOfCleanUp && !IDriverList->KernelDriver)
            {
                if (hDriver = OpenDriver(IDriverList->wszAlias, IDriverList->wszSection, 0L))
                {
                    SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
                    CloseDriver(hDriver, 0L, 0L);
                }
            }
            WritePrivateProfileString(IDriverList->szSection,
                                      IDriverList->szAlias,
                                      NULL,
                                      szSysIni
                                     );

            WriteProfileString(IDriverList->szFile, IDriverList->szAlias, NULL);
        }
        LocalFree((HANDLE)IDriverList);
        IDriverList = NextNode;
    }
}


BOOL DriverNodeSupportsNt(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData,
                          IN PSP_DRVINFO_DATA DriverInfoData
                         )
/*++

Routine Description:

    This routine determines whether the driver node specified is capable of
    installing on Windows NT (as opposed to being a Win95-only driver node).
    This determination is made based upon whether or not there is a corresponding
    service install section for this device install section.

Return Value:

    If the driver node supports Windows NT, the return value is TRUE, otherwise
    it is FALSE.

--*/
{
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    DWORD Err;
    TCHAR ActualSectionName[255];
    DWORD ActualSectionNameLen;
    LONG LineCount;
    CONST TCHAR szServiceInstallSuffix[] = TEXT(".") INFSTR_SUBKEY_SERVICES;

    // Get name and section to install from
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL) &&
        ((Err = GetLastError()) != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if ((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName, NULL, INF_STYLE_WIN4, NULL)) == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    // Retrieve the actual name of the install section to be used for this
    // driver node.
    //
    SetupDiGetActualSectionToInstall(hInf,
                                     DriverInfoDetailData.SectionName,
                                     ActualSectionName,
                                     sizeof(ActualSectionName) / sizeof(TCHAR),
                                     &ActualSectionNameLen,
                                     NULL
                                    );

    //
    // Generate the service install section name, and see if it exists.
    //
    CopyMemory(&(ActualSectionName[ActualSectionNameLen - 1]),
               szServiceInstallSuffix,
               sizeof(szServiceInstallSuffix)
              );

    LineCount = SetupGetLineCount(hInf, ActualSectionName);

    SetupCloseInfFile(hInf);

    return (LineCount != -1);
}

// Go through the list of drivers and try to keep from installing or displaying any non-NT drivers
// Warning: If you call this function with DeviceInfoData NULL, it will have to enumerate and open
// every media inf there is, which may take awhile.
BOOL FilterOutNonNTInfs(IN HDEVINFO         DeviceInfoSet,
                        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                        DWORD DriverType
                       )
{
    DWORD MemberIndex;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    MemberIndex = 0;
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    while (SetupDiEnumDriverInfo(DeviceInfoSet,DeviceInfoData,DriverType,MemberIndex,&DriverInfoData))
    {
        if (!DriverNodeSupportsNt(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
        {
            // If driver doesn't support NT, try to exclude from list & max out rank
            DriverInstallParams.cbSize=sizeof(DriverInstallParams);
            if (SetupDiGetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams))
            {
                DriverInstallParams.Flags |= DNF_EXCLUDEFROMLIST | DNF_BAD_DRIVER;
                DriverInstallParams.Rank = 10000;
                SetupDiSetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams);
            }
        }
        MemberIndex++;
    }

    return TRUE;
}

DWORD Media_SelectBestCompatDrv(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               )
{
    DWORD DriverType = (DeviceInfoData ? SPDIT_COMPATDRIVER : SPDIT_CLASSDRIVER);

    FilterOutNonNTInfs(DeviceInfoSet, DeviceInfoData, DriverType);
    return ERROR_DI_DO_DEFAULT;
}

DWORD Media_AllowInstall(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
    DWORD Err;
    SP_DRVINFO_DATA DriverInfoData;

    // Verify that the driver node selected for this device supports NT.
    // It will probably be a pretty common scenario for users to try to
    // give us their Win95 INFs.
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
    {
        // NULL driver?
        return ERROR_DI_DO_DEFAULT;
    }

    if (!DriverNodeSupportsNt(DeviceInfoSet,
                              DeviceInfoData,
                              &DriverInfoData))
    {
        dlog("Media_AllowInstall: Not an NT driver");
        return ERROR_DI_DONT_INSTALL;
    }

    return ERROR_DI_DO_DEFAULT;
}

DWORD Media_InstallDevice(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )
{
    DWORD Err, ConfigFlags;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HWND hWnd;
    SC_HANDLE schScm;

    //
    // if we are in setup then let's ensure the
    // SetupPreferredAudioDevicesCount value is in the driver registry for
    // devices that already have MME drivers installed.  This is so audiosrv's
    // MigrateAutoSetupPreferredAudio logic does not interpret this as a new
    // device installation.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
    	if (DI_FLAGSEX_IN_SYSTEM_SETUP & DeviceInstallParams.FlagsEx)
    	{
    	   HKEY hkDriver;
    	   hkDriver = SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE);
    	   if (INVALID_HANDLE_VALUE != hkDriver)
    	   {
    	   	HKEY hkMmeDrivers;
    	        LONG l;
    	        l = RegOpenKeyEx(hkDriver, TEXT("Drivers"), 0, KEY_QUERY_VALUE, &hkMmeDrivers);
    	        if (ERROR_FILE_NOT_FOUND != l)
    	        {
        	    l = RegQueryValueEx(hkDriver, TEXT("SetupPreferredAudioDevicesCount"), NULL, NULL, NULL, NULL);
        	    if (ERROR_FILE_NOT_FOUND == l)
        	    {
        	        DWORD dw = 0;
        	        RegSetValueEx(hkDriver, TEXT("SetupPreferredAudioDevicesCount"), 0, REG_DWORD, (PBYTE)&dw, sizeof(dw));
        	    }
        	    RegCloseKey(hkMmeDrivers);
    	        }
    	   	RegCloseKey(hkDriver);
    	   }
    	}
    }

    // First remove any driver that was already installed
    Media_RemoveDevice(DeviceInfoSet,DeviceInfoData);

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
    {
        //
        // The NULL driver is to be installed for this device.  We don't need to
        // do anything special in that case.
        //
        dlog("Media_InstallDevice: Null driver");
        return ERROR_DI_DO_DEFAULT;
    }

    dlog("Media_InstallDevice: Calling SetupDiInstallDevice");
    if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData))
    {

        Err = GetLastError();

        dlog("Media_InstallDevice: SetupDiInstallDevice failed");
        //
        // In certain circumstances, we have INFs that control some of the functions on the
        // card, but not all (e.g., our sndblst driver controls wave, midi, aux, mixer but
        // not the fancy 3D stuff).  In order to give the user a descriptive name that lets
        // them know what we're trying to install, the INF contains driver nodes for devices
        // it can't support.  If this is the case, then SetupDiInstallDevice will fail with
        // ERROR_NO_ASSOCIATED_SERVICE.  If this happens, we want to clear the
        // CONFIGFLAG_REINSTALL that got set, so we don't keep hounding the user about this.
        // While we're at it, we go ahead and store the driver node's device description as
        // the device instance's description, so that we know what the device instances are
        // later on (for diagnostic purposes, mainly).
        //
        if (Err == ERROR_NO_ASSOCIATED_SERVICE)
        {

            // Clear reinstall flag
            if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_CONFIGFLAGS,
                                                 NULL,
                                                 (PBYTE)&ConfigFlags,
                                                 sizeof(ConfigFlags),
                                                 NULL))
            {
                ConfigFlags &= ~CONFIGFLAG_REINSTALL;
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_CONFIGFLAGS,
                                                 (PBYTE)&ConfigFlags,
                                                 sizeof(ConfigFlags)
                                                );
            }

            // Save description of device
            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_DEVICEDESC,
                                             (PBYTE)DriverInfoData.Description,
                                             (lstrlen(DriverInfoData.Description) + 1) * sizeof(TCHAR)
                                            );
        }

        goto Media_InstallDevice_exit;
    }

    //
    // Get the device install parameters, so we'll know what parent window to use for any
    // UI that occurs during configuration of this device.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
        hWnd = DeviceInstallParams.hwndParent;
    }
    else
    {
        hWnd = NULL;
    }

    //
    // The INF will have created a "Drivers" subkey under the device's software key.
    // This tree, in turn, contains subtrees for each type of driver (aux, midi, etc.)
    // applicable for this device.  We must now traverse this tree, and create entries
    // in Drivers32 for each function alias.
    //
    dlog("Media_InstallDevice: Calling InstallDriversForPnPDevice");
    if ((Err = InstallDriversForPnPDevice(hWnd, DeviceInfoSet, DeviceInfoData)) != NO_ERROR)
    {
        //
        // The device is in an unknown state.  Disable it by setting the
        // CONFIGFLAG_DISABLED config flag, and mark it as needing a reinstall.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_CONFIGFLAGS,
                                              NULL,
                                              (PBYTE)&ConfigFlags,
                                              sizeof(ConfigFlags),
                                              NULL))
        {
            ConfigFlags = 0;
        }

        ConfigFlags |= (CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL);

        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags)
                                        );

        //
        // Delete the Driver= entry from the Dev Reg Key and delete the
        // DrvRegKey.
        //
        SetupDiDeleteDevRegKey(DeviceInfoSet,
                               DeviceInfoData,
                               DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                               0,
                               DIREG_DRV
                              );

        SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER, NULL, 0);

        //
        // Also, delete the service property, so we'll know this device instance needs to be
        // cleaned up if we later reboot and don't find the device.
        //
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_SERVICE, NULL, 0);

        goto Media_InstallDevice_exit;
    }
    
    //
    // Attempt to start the AudioSrv Win32 service
    //
    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (schScm) {
        SC_HANDLE schAudioSrv;
        schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_QUERY_STATUS | SERVICE_START);
        if (schAudioSrv) {
            SERVICE_STATUS AudioSrvStatus;
            if (QueryServiceStatus(schAudioSrv, &AudioSrvStatus)) {
                if (SERVICE_STOPPED == AudioSrvStatus.dwCurrentState) {
                    if (!StartService(schAudioSrv, 0, NULL)) {
                        dlog("Media_InstallDevice: StartService on AudioSrv failed");
                    }
                }
            } else {
                dlog("Media_InstallDevice: QueryServiceStatus on AudioSrv failed");
            }
            CloseServiceHandle(schAudioSrv);
        } else {
            dlog("Media_InstallDevice: OpenService on AudioSrv failed");
        }
        CloseServiceHandle(schScm);
    } else {
        dlog("Media_InstallDevice: OpenSCManager failed");
    }

    Err = NO_ERROR;

    Media_InstallDevice_exit:

    dlog("Media_InstallDevice: Returning");
    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmcpl.c ===
/*==========================================================================*/
//
//  mmcpl.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
//
//    06/94    -Created- VijR
//
/*==========================================================================*/

#pragma warning( disable: 4103)
#include "mmcpl.h"
#include <cpl.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <infstr.h>
#include <devguid.h>

#include "draw.h"
#include "utils.h"
#include "drivers.h"
#include "sulib.h"
#include <tchar.h>
#include <hwtab.h>
#include "debug.h"

#ifndef cchRESOURCE
    #define cchRESOURCE 256
#endif

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */
HINSTANCE   ghInstance  = NULL;
BOOL        gfNukeExt   = -1;
HWND        ghwndMsgBox = NULL;
HWND        ghwndAdvProp = NULL;
BOOL        gfVoiceTab  = FALSE;

#ifdef FIX_BUG_15451
static TCHAR cszFORKLINE[] = TEXT("RUNDLL32.EXE MMSYS.CPL,ShowDriverSettingsAfterFork %s");
#endif // FIX_BUG_15451

SZCODE cszAUDIO[] = AUDIO;
SZCODE cszVIDEO[] = VIDEO;
SZCODE cszCDAUDIO[] = CDAUDIO;
SZCODE cszMIDI[] = MIDI;
SZCODE cszVOICE[]    = VOICE;
SZCODE cszVOLUME[]    = VOLUME;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

typedef struct _ExtPropSheetCBParam //Callback Parameter
{
    HTREEITEM hti;
    LPPROPSHEETHEADER    ppsh;
    LPARAM lParam1;    //PIRESOURCE/PINSTRUMENT etc. depending on node. (OR) Simple propsheet class
    LPARAM lParam2; //hwndTree (OR) Simple propsheet name
} EXTPROPSHEETCBPARAM, *PEXTPROPSHEETCBPARAM;

typedef struct _MBInfo
{
    LPTSTR szTitle;
    LPTSTR szMsg;
    UINT  uStyle;
} MBINFO, *PMBINFO;


/*
 ***************************************************************
 * Defines
 ***************************************************************
 */

#define    MAXPAGES    8    // MAX number of sheets allowed
#define    MAXMODULES    32    // MAX number of external modules allowed
#define    MAXCLASSSIZE    64

#define cComma    TEXT(',')
#define PROPTABSIZE 13

#define GetString(_str,_id,_hi)  LoadString (_hi, _id, _str, sizeof(_str)/sizeof(TCHAR))

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE    aszSimpleProperties[] = REGSTR_PATH_MEDIARESOURCES TEXT("\\MediaExtensions\\shellx\\SimpleProperties\\");
static SZCODE    aszShellName[]    = TEXT("ShellName");

static UINT     g_cRefCnt;            // keeps track of the ref count
static int      g_cProcesses        = 0;
static int      g_nStartPage        = 0;

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
INT_PTR CALLBACK AudioDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK VideoDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CDDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ACMDlg(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SoundDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK VolumeDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK HardwareDlgProc(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK VoiceDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
//INT_PTR CALLBACK EffectDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


//
// This is the dialog procedure for the "Hardware" page.
//


INT_PTR CALLBACK HardwareDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndHW = NULL;

    switch (uMessage)
    {
        case WM_NOTIFY:
        {
            NMHDR * pnmhdr = (NMHDR *) lParam;
            int code = pnmhdr->code;

            switch (code)
            {
                case HWN_FILTERITEM:
                {
                    NMHWTAB *pnmht = (NMHWTAB *) lParam;
                    BOOL fFilter = FALSE;

                    if (!pnmht->fHidden)    // Let's not bother looking at devices already hidden
                    {
                        fFilter = FALSE;
                    }

                    return(TRUE);
                }
                break;

                case HWN_SELECTIONCHANGED:
                {
                    NMHWTAB *pnmht = (NMHWTAB *) lParam;

                    if (pnmht)
                    {
                        if (pnmht->pdinf)
                        {
                            if (IsEqualGUID(&(pnmht->pdinf->ClassGuid),&GUID_DEVCLASS_CDROM))
                            {
                                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/hdw_drives.htm"));
                            }
                            else
                            {
                                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/tssound.htm"));
                            }
                        }
                    }
                }
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            GUID guidClass[2];

            guidClass[0] = GUID_DEVCLASS_CDROM;
            guidClass[1] = GUID_DEVCLASS_MEDIA;

            s_hwndHW = DeviceCreateHardwarePageEx(hDlg, (const GUID *) &guidClass, 2, HWTAB_LARGELIST );

            if (s_hwndHW)
            {
                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/tssound.htm"));
            }
            else
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }

    return FALSE;
}



INT_PTR CALLBACK CD_HardwareDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            HWND hwndHW;

            hwndHW = DeviceCreateHardwarePageEx(hDlg, &GUID_DEVCLASS_CDROM, 1, HWTAB_SMALLLIST);

            if (hwndHW)
            {
                SetWindowText(hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/hdw_multi.htm"));
            }
            else
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }

    return FALSE;
}



/*
 ***************************************************************
 ***************************************************************
 */

INT_PTR FAR PASCAL mmse_MessageBoxProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        {
            PMBINFO pmbInfo = (PMBINFO)lParam;
            UINT uStyle = pmbInfo->uStyle;

            SetWindowText(hDlg, pmbInfo->szTitle);
            SetWindowText(GetDlgItem(hDlg, MMSE_TEXT), pmbInfo->szMsg);
            if (IsFlagClear(uStyle, MMSE_OK))
                DestroyWindow(GetDlgItem(hDlg, MMSE_OK));
            if (IsFlagClear(uStyle, MMSE_YES))
                DestroyWindow(GetDlgItem(hDlg, MMSE_YES));
            if (IsFlagClear(uStyle, MMSE_NO))
                DestroyWindow(GetDlgItem(hDlg, MMSE_NO));
            ghwndMsgBox = hDlg;
            break;
        }
    case WM_DESTROY:
        ghwndMsgBox = NULL;
        break;
    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case MMSE_YES:
                EndDialog(hDlg, MMSE_YES);
                break;
            case MMSE_NO:
                EndDialog(hDlg, MMSE_NO);
                break;
            case MMSE_OK:
                EndDialog(hDlg, MMSE_OK);
                break;
            }
            break;
        }
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR mmse_MessageBox(HWND hwndP,  LPTSTR szMsg, LPTSTR szTitle, UINT uStyle)
{
    MBINFO mbInfo;

    mbInfo.szMsg = szMsg;
    mbInfo.szTitle = szTitle;
    mbInfo.uStyle = uStyle;

    return DialogBoxParam(ghInstance, MAKEINTRESOURCE(DLG_MESSAGE_BOX), hwndP, mmse_MessageBoxProc, (LPARAM)&mbInfo);
}

/*==========================================================================*/
int FAR PASCAL lstrncmpi(
                        LPCTSTR    lszKey,
                        LPCTSTR    lszClass,
                        int    iSize)
{
    TCHAR    aszKey[64];

    lstrcpyn(aszKey, lszKey, iSize);
    return lstrcmpi(aszKey, lszClass);
}

int StrByteLen(LPTSTR sz)
{
    LPTSTR psz;

    if (!sz)
        return 0;
    for (psz = sz; *psz; psz = CharNext(psz))
        ;
    return (int)(psz - sz);
}

static void NukeExt(LPTSTR sz)
{
    int len;

    len = StrByteLen(sz);

    if (len > 4 && sz[len-4] == TEXT('.'))
        sz[len-4] = 0;
}

static LPTSTR NukePath(LPTSTR sz)
{
    LPTSTR pTmp, pSlash;

    for (pSlash = pTmp = sz; *pTmp; pTmp = CharNext(pTmp))
    {
        if (*pTmp == TEXT('\\'))
            pSlash = pTmp;
    }
    return (pSlash == sz ? pSlash : pSlash+1);
}

void    CheckNukeExtOption(LPTSTR sz)
{
    SHFILEINFO sfi;

    SHGetFileInfo(sz, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME);
    if (lstrcmpi((LPTSTR)(sfi.szDisplayName+lstrlen(sfi.szDisplayName)-4), cszWavExt))
        gfNukeExt = TRUE;
    else
        gfNukeExt = FALSE;
}

LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath)
{
    SHFILEINFO sfi;

    if (gfNukeExt == -1)
        CheckNukeExtOption(sz);

    if (!SHGetFileInfo(sz, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
        return sz;

    if (fNukePath)
    {
        lstrcpy(sz, sfi.szDisplayName);
    }
    else
    {
        LPTSTR lpszFileName;

        lpszFileName = NukePath(sz);
        lstrcpy(lpszFileName, sfi.szDisplayName);
        if (lpszFileName != sz)
            CharUpperBuff(sz, 1);
    }
    return sz;
}



/*
 ***************************************************************
 * ErrorBox
 *
 * Description:
 *        Brings up error Dialog displaying error
 *
 * Parameters:
 *        HWND    hDlg  - Window handle
 *        int        iResource    - id of the resource to be loaded
 *        LPTSTR    lpszDesc - The string to be inserted in the resource string
 *
 * Returns:            BOOL
 *
 ***************************************************************
 */
BOOL PASCAL ErrorBox(HWND hDlg, int iResource, LPTSTR lpszDesc)
{
    TCHAR szBuf[MAXMSGLEN];
    TCHAR szTitle[MAXSTR];
    TCHAR szResource[MAXMSGLEN];

    LoadString(ghInstance, iResource, szResource, MAXSTR);
    LoadString(ghInstance, IDS_ERROR, szTitle, MAXSTR);
    wsprintf(szBuf, szResource, lpszDesc);
    MessageBox(hDlg, szBuf, szTitle, MB_APPLMODAL | MB_OK |MB_ICONSTOP);
    return TRUE;
}

int PASCAL DisplayMessage(HWND hDlg, int iResTitle, int iResMsg, UINT uStyle)
{
    TCHAR szBuf[MAXMSGLEN];
    TCHAR szTitle[MAXSTR];
    UINT uAddStyle = MB_APPLMODAL;

    if (!LoadString(ghInstance, iResTitle, szTitle, MAXSTR))
        return FALSE;
    if (!LoadString(ghInstance, iResMsg, szBuf, MAXSTR))
        return FALSE;
    if (uStyle & MB_OK)
        uAddStyle |= MB_ICONASTERISK;
    else
        uAddStyle |= MB_ICONQUESTION;
    return MessageBox(hDlg, szBuf, szTitle,  uStyle | uAddStyle);
}


//Adds spaces around Tab Names to make them all approx. same size.
STATIC void PadWithSpaces(LPTSTR szName, LPTSTR szPaddedName)
{
    static SZCODE cszFmt[] = TEXT("%s%s%s");
    TCHAR szPad[8];
    int i;

    i = PROPTABSIZE - lstrlen(szName);

    i = (i <= 0) ? 0 : i/2;
    for (szPad[i] = TEXT('\0');i; i--)
        szPad[i-1] =  TEXT(' ');
    wsprintf(szPaddedName, cszFmt, szPad, szName, szPad);
}

/*==========================================================================*/
UINT CALLBACK  CallbackPage(
                           HWND        hwnd,
                           UINT        uMsg,
                           LPPROPSHEETPAGE    ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        DPF_T("* RelasePage %s *", (LPTSTR)ppsp->pszTitle);
    }
    return 1;
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddPage(
                               LPPROPSHEETHEADER    ppsh,
                               LPCTSTR            pszTitle,
                               DLGPROC            pfnDialog,
                               UINT            idTemplate,
                               LPARAM            lParam)
{
    if (ppsh->nPages < MAXPAGES)
    {

        if (pfnDialog)
        {
            PROPSHEETPAGE    psp;
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USECALLBACK;
            psp.hInstance = ghInstance;
            psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
            psp.pszIcon = NULL;
            psp.pszTitle = pszTitle;
            psp.pfnDlgProc = pfnDialog;
            psp.lParam = (LPARAM)lParam;
            psp.pfnCallback = CallbackPage;
            psp.pcRefParent = NULL;
            if (ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp))
            {
                ppsh->nPages++;
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*==========================================================================*/
BOOL CALLBACK MMExtPropSheetCallback(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance)
{
    PEXTPROPSHEETCBPARAM pcbp = (PEXTPROPSHEETCBPARAM)dwInstance;

    if (!pcbp && dwFunc != MM_EPS_BLIND_TREECHANGE)
        return FALSE;
    switch (dwFunc)
    {
    case MM_EPS_GETNODEDESC:
        {
            if (!dwParam1)
                return FALSE;
            if (pcbp->hti == NULL)
                lstrcpy((LPTSTR)dwParam1, (LPTSTR)pcbp->lParam2);
            else
            {
                GetTreeItemNodeDesc ((LPTSTR)dwParam1,
                                     (PIRESOURCE)pcbp->lParam1);
            }
            break;
        }
    case MM_EPS_GETNODEID:
        {
            if (!dwParam1)
                return FALSE;
            if (pcbp->hti == NULL)
                lstrcpy((LPTSTR)dwParam1, (LPTSTR)pcbp->lParam2);
            else
            {
                GetTreeItemNodeID ((LPTSTR)dwParam1,
                                   (PIRESOURCE)pcbp->lParam1);
            }
            break;
        }
    case MM_EPS_ADDSHEET:
        {
            HPROPSHEETPAGE    hpsp = (HPROPSHEETPAGE)dwParam1;

            if (hpsp && (pcbp->ppsh->nPages < MAXPAGES))
            {
                pcbp->ppsh->phpage[pcbp->ppsh->nPages++] = hpsp;
                return TRUE;
            }
            return FALSE;
        }
    case MM_EPS_TREECHANGE:
        {
            RefreshAdvDlgTree ();
            break;
        }
    case MM_EPS_BLIND_TREECHANGE:
        {
            RefreshAdvDlgTree ();
            break;
        }
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK SpeechDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/*==========================================================================*/
static BOOL PASCAL NEAR AddSpeechPage(LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    LoadString(ghInstance, IDS_SPEECH_NAME, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, SpeechDlgProc, IDD_SPEECH, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddAdvancedPage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    LoadString(ghInstance, IDS_ADVANCED, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, AdvDlg, ADVDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddHardwarePage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    // Don't add a hardware tab if the admin restricted it
    if (SHRestricted(REST_NOHARDWARETAB))
        return FALSE;

    LoadString(ghInstance, IDS_HARDWARE, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, HardwareDlgProc, HWDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddSchemesPage(
                                      LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];

    LoadString(ghInstance, IDS_EVENTSNAME, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    return AddPage(ppsh, aszTitleRes, SoundDlg, SOUNDDIALOG, (LPARAM)NULL);
}

/*==========================================================================*/

static void PASCAL NEAR AddInternalPages (LPPROPSHEETHEADER ppsh)
{
    static EXTPROPSHEETCBPARAM cbp;
    TCHAR  szText[ cchRESOURCE ];
    TCHAR  szPadded[ cchRESOURCE ];


    // Add the Volume page
    //
    GetString (szText, IDS_VOLUMENAME, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, VolumeDlg, IDD_VOLUME, (LPARAM)NULL);

    // Add the Sound Scheme page
    //
    GetString (szText, IDS_EVENTSNAME, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, SoundDlg, SOUNDDIALOG, (LPARAM)NULL);

    // Add the Audio page
    //
    GetString (szText, IDS_AUDIO_TAB, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, AudioDlg, AUDIODLG, (LPARAM)NULL);

    // Add the Voice page
    //
    GetString (szText, IDS_VOICE, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, VoiceDlg, VOICEDLG, (LPARAM)NULL);

    // Add the Video page
    //
 /*   GetString (szText, IDS_VIDEO_TAB, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, VideoDlg, VIDEODLG, (LPARAM)NULL); */

    // Add the MIDI page
    //
 /*   GetString (szText, IDS_MIDI_TAB, ghInstance);
    PadWithSpaces (szText, szPadded);
    cbp.ppsh = ppsh;
    cbp.hti = NULL;
    cbp.lParam1 = (LPARAM)cszMIDI;
    cbp.lParam2 = (LPARAM)szPadded;
    AddSimpleMidiPages ((LPVOID)szPadded, MMExtPropSheetCallback, (LPARAM)&cbp);
*/

    // Add the CD Audio page
    //
 /*   GetString (szText, IDS_CDAUDIO_TAB, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, CDDlg, CDDLG, (LPARAM)NULL);
*/
}


static void InitPSH(LPPROPSHEETHEADER ppsh, HWND hwndParent, LPTSTR pszCaption, HPROPSHEETPAGE    FAR * phpsp)
{
    ppsh->dwSize = sizeof(PROPSHEETHEADER);
    ppsh->dwFlags = PSH_PROPTITLE;
    ppsh->hwndParent = hwndParent;
    ppsh->hInstance = ghInstance;
    ppsh->pszCaption = pszCaption;
    ppsh->nPages = 0;
    ppsh->nStartPage = 0;
    ppsh->phpage = phpsp;
}


/*==========================================================================*/
#ifdef FIX_BUG_15451
static void PASCAL cplMMDoubleClick (HWND hCPlWnd, int nStartPage)
#else // FIX_BUG_15451
static void PASCAL cplMMDoubleClick (HWND hCPlWnd)
#endif // FIX_BUG_15451
{
    PROPSHEETHEADER   psh;
    HPROPSHEETPAGE    hpsp[MAXPAGES];
    TCHAR strOldDir[MAX_PATH], strSysDir[MAX_PATH];

    strOldDir[0] = TEXT('\0');
    strSysDir[0] = TEXT('\0');

    GetSystemDirectory(strSysDir, MAX_PATH);
    GetCurrentDirectory(MAX_PATH, strOldDir);
    SetCurrentDirectory(strSysDir);
    wsInfParseInit();

    InitCommonControls();
    OleInitialize(NULL);

    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);
    InitPSH(&psh,hCPlWnd,(LPTSTR)MAKEINTRESOURCE(IDS_MMNAME),hpsp);

#ifdef FIX_BUG_15451
    psh.nStartPage = nStartPage;
#else // FIX_BUG_15451
    psh.nStartPage = g_nStartPage;
#endif // FIX_BUG_15451
    g_nStartPage = 0;
    AddInternalPages(&psh);
    //AddSpeechPage(&psh);
    //AddAdvancedPage(&psh);
    AddHardwarePage(&psh);
    PropertySheet(&psh);

    OleUninitialize();

    infClose(NULL);
    SetCurrentDirectory(strOldDir);
}

/*==========================================================================*/
static void PASCAL cplEventsDoubleClick (HWND hCPlWnd)
{
    PROPSHEETHEADER    psh;
    HPROPSHEETPAGE    hpsp[MAXPAGES];

    InitCommonControls();
    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);
    InitPSH(&psh,hCPlWnd,(LPTSTR)MAKEINTRESOURCE(IDS_EVENTSNAME),hpsp);
    AddSchemesPage(&psh);
    PropertySheet(&psh);
}

#ifdef FIX_BUG_15451
/*==========================================================================*/
/*
 * ShowDriverSettings
 * ShowDriverSettingsAfterFork
 *
 * When the user selects DevicesTab.<anydevice>.Properties.Settings, a
 * DRV_CONFIGURE message is sent to the selected user-mode driver, to cause
 * it to display its configuration dialog.  The sound drivers shipped with
 * NT (SNDBLST,MVAUDIO,SNDSYS) exhibit a bug in this condition: when the
 * configuration dialog is complete (regardless of whether OK or CANCEL was
 * selected), these drivers attempt to unload-and-reload their kernel-mode
 * component in order to begin using the new (or restore the original)
 * driver settings.  The unload request fails, because both the Audio tab
 * and SNDVOL.EXE have open mixer handles and pending IRPs within the kernel
 * driver (the latter are used to provide notifications of volume changes).
 * Worse, when the unload fails, it leaves the driver useless: its state
 * remains STOP_PENDING, and it cannot be resurrected without logging off
 * and back on.
 *
 * These routines have been provided as a temporary workaround for bug 15451,
 * which describes the problem mentioned above.  The theory behind this
 * solution is two-fold:
 *   1- close SNDVOL.EXE as soon as a driver's configuration dialog is
 *      to be displayed, and restart it directly thereafter.  This prevents
 *      it from maintaining any open handles to and/or pending IRPs within the
 *      kernel driver.
 *   2- if the Audio tab has ever been displayed, it will have open mixers
 *      which must be closed.  Because a bug/design flaw within these sound
 *      drivers prevents the mixers from being closed without killing this
 *      process (the sound drivers each cache open mixer handles), the
 *      routine ShowDriverSettings forks a new MMSYS.CPL process, which is
 *      then used to display the driver's settings dialog.
 *
 * The flow of this solution follows:
 *
 * 1- MMSYS.CPL starts on Audio tab, setting fHaveStartedAudioDialog to TRUE.
 * 2- User selects Devices tab.
 * 3- User selects a device driver.
 * 4- User selects Properties+Settings; control reaches ShowDriverSettings().
 * 5- ShowDriverSettings() determines if there is a need to fork a new process:
 *    this will be the case if the Audio tab has been displayed, and the
 *    device for which it is to display settings contains mixers.  If either
 *    of these conditions is false, ShowDriverSettings displays the driver's
 *    settings dialog directly (via ConfigureDriver()).
 * 6- ShowDriverSettings() uses WinExec() to fork a new process, using
 *    the routine ShowDriverSettingsAfterFork() as an entry point.  If the
 *    exec fails, ShowDriverSettings() displays the driver's settings dialog
 *    directly (via ConfigureDriver()).
 * PROCESS 1:                           PROCESS 2:
 * 7- Enters WaitForNewCPLWindow(),     1- ShowDriverSettingsAfterFork() will
 *    which will wait up to 5 seconds      receive on its command-line the
 *    for the new MMSYS.CPL process        name of the driver for which
 *    to open a driver Properties          settings have been requested.  It
 *    dialog which matches its own:        opens the primary dialog, using the
 *    if it finds such a dialog,           Devices tab as the initial tab--
 *    WaitForNewCPLWindow() will post      so that the Advanced tab is never
 *    IDCANCEL messages to both the        displayed, and because the Devices
 *    current driver Properties dialog,    tab is the active tab on the other
 *    and to this process's main           process.
 *    dialog, terminating this process. 2- During WM_INITDIALOG of the Devices
 *                                         dialog, this process searches for
 *                                       the previous process' MMSYS.CPL dialog.
 *                                     If successful, it moves this MMSYS.CPL
 *                                   dialog directly behind the previous dialog.
 *                              3- During ID_INIT of the Devices dialog, this
 *                               process searches the TreeView for the driver
 *                             which was named on the comand-line: if found,
 *                           it highlights the TreeItem and simulates a press
 *                         of the Properties button
 *                    4- During WM_INITDIALOG of the device's Properties dialog,
 *                     this process searches for the previous process' device's
 *                   properties dialog.  If successful, it moves this dialog
 *                 directly behind its counterpart.
 *            5- During ID_INIT of the device's Properties dialog, this process
 *             simulates a press of the Settings button
 *        6- When the Settings button is pressed, this process recognizes that
 *         it has been forked and skips the call to ShowDriverSettings(),
 *       instead simply displaying the driver's settings dialog (via
 *     ConfigureDriver()).
 *
 * Let it be known that this is a hack, and should be removed post-beta.
 *
 */

extern BOOL fHaveStartedAudioDialog;    // in MSACMCPL.C

void ShowDriverSettings (HWND hDlg, LPTSTR pszName)
{
    if (fHaveStartedAudioDialog && fDeviceHasMixers (pszName))
    {
        TCHAR  szForkLine[ cchRESOURCE *2 ];

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        wsprintf (szForkLine, cszFORKLINE, pszName);

        if (CreateProcess(NULL,szForkLine,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
        {
            (void)WaitForNewCPLWindow (hDlg);
        }
        else
        {
            ConfigureDriver (hDlg, pszName);
        }
    }
    else
    {
        ConfigureDriver (hDlg, pszName);
    }
}


void WINAPI ShowDriverSettingsAfterFork (
                                        HWND hwndStub,
                                        HINSTANCE hAppInstance,
                                        LPTSTR lpszCmdLine,
                                        int nCmdShow)
{
    #ifdef UNICODE
    WCHAR szCmdLine[ cchRESOURCE ];
    #else
        #define szCmdLine lpszCmdLine
    #endif

    lstrcpy (szDriverWhichNeedsSettings, szCmdLine);
    cplMMDoubleClick (NULL, 4); // 4==Start on Advanced ("Devices") tab
}

void WINAPI ShowDriverSettingsAfterForkW (
                                         HWND hwndStub,
                                         HINSTANCE hAppInstance,
                                         LPWSTR lpwszCmdLine,
                                         int nCmdShow)
{
    #ifdef UNICODE
        #define szCmdLine lpwszCmdLine
    #else
    CHAR szCmdLine[ cchRESOURCE ];
    wcstombs(szCmdLine, lpwszCmdLine, cchRESOURCE);
    #endif

    lstrcpy (szDriverWhichNeedsSettings, szCmdLine);
    cplMMDoubleClick (NULL, 4); // 4==Start on Advanced ("Devices") tab
}

#endif // FIX_BUG_15451

// Globals to support sound event command line parameters.

#define MAX_SND_EVNT_CMD_LINE 32
TCHAR    gszCmdLineApp[MAX_SND_EVNT_CMD_LINE];
TCHAR    gszCmdLineEvent[MAX_SND_EVNT_CMD_LINE];

/*==========================================================================*/
LONG CPlApplet(
              HWND    hCPlWnd,
              UINT    Msg,
              LPARAM  lParam1,
              LPARAM  lParam2)
{
    switch (Msg)
    {
    case CPL_INIT:
        wHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
        DPF_T("*CPL_INIT*");
        g_cRefCnt++;
        return (LRESULT)TRUE;

    case CPL_GETCOUNT:
        return (LRESULT)1;

    case CPL_INQUIRE:
        DPF_T("*CPL_INQUIRE*");
        switch (lParam1)
        {
        case 0:
            ((LPCPLINFO)lParam2)->idIcon = IDI_MMICON;
            ((LPCPLINFO)lParam2)->idName = IDS_MMNAME;
            ((LPCPLINFO)lParam2)->idInfo = IDS_MMINFO;
            break;
        default:
            return FALSE;
        }
        ((LPCPLINFO)lParam2)->lData = 0L;
        return TRUE;

    case CPL_NEWINQUIRE:
        switch (lParam1)
        {
        case 0:
            ((LPNEWCPLINFO)lParam2)->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_MMICON));
            LoadString(ghInstance, IDS_MMNAME, ((LPNEWCPLINFO)lParam2)->szName, sizeof(((LPNEWCPLINFO)lParam2)->szName)/sizeof(TCHAR));
            LoadString(ghInstance, IDS_MMINFO, ((LPNEWCPLINFO)lParam2)->szInfo, sizeof(((LPNEWCPLINFO)lParam2)->szInfo)/sizeof(TCHAR));
            break;
        default:
            return FALSE;
        }
        ((LPNEWCPLINFO)lParam2)->dwHelpContext = 0;
        ((LPNEWCPLINFO)lParam2)->dwSize = sizeof(NEWCPLINFO);
        ((LPNEWCPLINFO)lParam2)->lData = 0L;
        ((LPNEWCPLINFO)lParam2)->szHelpFile[0] = 0;
        return TRUE;

    case CPL_DBLCLK:
        DPF_T("* CPL_DBLCLICK*");
        // Do the applet thing.
        switch (lParam1)
        {
        case 0:
            // Check for obsolete command line (see comments
            // under CPL_STARTWPARAMS)
            if ((-1) == g_nStartPage) break;

#ifdef FIX_BUG_15451
            lstrcpy (szDriverWhichNeedsSettings, TEXT(""));
            cplMMDoubleClick(hCPlWnd, g_nStartPage);
#else // FIX_BUG_15451
            cplMMDoubleClick(hCPlWnd);
#endif // FIX_BUG_15451
            break;
        }
        break;

    case CPL_STARTWPARMS:
        switch (lParam1)
        {
        case 0:
            if (lParam2 && *((LPTSTR)lParam2))
            {
                TCHAR c;

                c = *((LPTSTR)lParam2);
                if (c > TEXT('0') && c < TEXT('5'))
                {
                    g_nStartPage = c - TEXT('0');
                    break;
                }

                // The "S" command line was used on Windows 98 and Windows 98
                // SE.  The command line was written to the Active Setup
                // registry to run logic to setup preferred devices on a
                // specific PnP device instance.  It is obsolete and handled in
                // winmm.dll itself.  This cpl should do nothing for this
                // command line.
                if ((c == TEXT('S')) || (c == TEXT('s'))) {
                    g_nStartPage = (-1);
                    break;
                }
            }
            g_nStartPage = 0;
            break;

            // For sound events, the passed in parameter indicates a module
            // name and event. If a name is passed only show it's sound events.
            // If a name and event are passed only show the event.
            /*        case 1:

                        if (lParam2 && *((LPTSTR)lParam2))
                        {
                            TCHAR *psz;

                            if ((psz = wcschr((LPTSTR)lParam2, TEXT(','))) != NULL)
                            {
                                *psz++ = TEXT('\0');
                                wcsncpy(gszCmdLineEvent, psz, MAX_SND_EVNT_CMD_LINE/sizeof(TCHAR));
                                gszCmdLineEvent[MAX_SND_EVNT_CMD_LINE-sizeof(TCHAR)] = TEXT('\0');
                            }
                            wcsncpy(gszCmdLineApp, (LPTSTR)lParam2,
                                    MAX_SND_EVNT_CMD_LINE/sizeof(TCHAR));
                            gszCmdLineApp[MAX_SND_EVNT_CMD_LINE-sizeof(TCHAR)] = TEXT('\0');
                        }
                        break; */
        }

        break;

    case CPL_EXIT:
        DPF_T("* CPL_EXIT*");
        g_cRefCnt--;
        break;
    }
    return 0;
}


void PASCAL ShowPropSheet(LPCTSTR            pszTitle,
                          DLGPROC            pfnDialog,
                          UINT            idTemplate,
                          HWND            hWndParent,
                          LPTSTR            pszCaption,
                          LPARAM lParam)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];


    InitPSH(&psh,hWndParent,pszCaption,hpsp);
    AddPage(&psh, pszTitle,  pfnDialog, idTemplate, lParam);
    PropertySheet(&psh);

}

void PASCAL ShowMidiPropSheet(LPPROPSHEETHEADER ppshExt,
                              LPCTSTR    pszTitle,
                              HWND      hWndParent,
                              short     iMidiPropType,
                              LPTSTR     pszCaption,
                              HTREEITEM hti,
                              LPARAM    lParam1,
                              LPARAM    lParam2)
{
    PROPSHEETHEADER psh;
    LPPROPSHEETHEADER ppsh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];
    static EXTPROPSHEETCBPARAM cbp;

    if (!ppshExt)
    {
        ppsh = &psh;
        InitPSH(ppsh,hWndParent,pszCaption,hpsp);
    }
    else
        ppsh = ppshExt;

    cbp.lParam1 = lParam1;
    cbp.lParam2 = lParam2;
    cbp.hti = hti;
    cbp.ppsh = ppsh;

    if (iMidiPropType == MIDI_CLASS_PROP)
    {
        if (AddMidiPages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
    else if (iMidiPropType == MIDI_INSTRUMENT_PROP)
    {
        if (AddInstrumentPages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
    else
    {
        if (AddDevicePages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
}

void PASCAL ShowWithMidiDevPropSheet(LPCTSTR            pszTitle,
                                     DLGPROC            pfnDialog,
                                     UINT            idTemplate,
                                     HWND            hWndParent,
                                     LPTSTR            pszCaption,
                                     HTREEITEM    hti,
                                     LPARAM lParam, LPARAM lParamExt1, LPARAM lParamExt2)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];


    InitPSH(&psh,hWndParent,pszCaption,hpsp);
    AddPage(&psh, pszTitle,  pfnDialog, idTemplate, lParam);
    PropertySheet(&psh);
    // Disabling the details sheet - obsolete 01/10/2001
    //ShowMidiPropSheet(&psh, pszCaption, hWndParent,MIDI_DEVICE_PROP,pszCaption,hti,lParamExt1,lParamExt2);
}

BOOL WINAPI ShowMMCPLPropertySheetW(HWND hwndParent, LPCTSTR pszPropSheetID, LPTSTR pszTabName, LPTSTR pszCaption)
{
    DLGPROC pfnDlgProc;
    UINT    idTemplate;
    HWND    hwndP;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];

    if (GetWindowLongPtr(hwndParent, GWL_EXSTYLE) & WS_EX_TOPMOST)
        hwndP = NULL;
    else
        hwndP = hwndParent;

    InitPSH(&psh,hwndP,pszCaption,hpsp);
    psh.dwFlags = 0;

    if (!lstrcmpi(pszPropSheetID, cszAUDIO))
    {
        pfnDlgProc = AudioDlg;
        idTemplate = AUDIODLG;
        goto ShowSheet;
    }
	if (!lstrcmpi(pszPropSheetID, cszVOICE))
    {
        pfnDlgProc = VoiceDlg;
        idTemplate = VOICEDLG;
        goto ShowSheet;
    } 
	if (!lstrcmpi(pszPropSheetID, cszVOLUME))
    {
        pfnDlgProc = VolumeDlg;
        idTemplate = IDD_VOLUME;
        goto ShowSheet;
    } 
    if (!lstrcmpi(pszPropSheetID, cszVIDEO))
    {
        pfnDlgProc = VideoDlg;
        idTemplate = VIDEODLG;
        goto ShowSheet;
    }
    if (!lstrcmpi(pszPropSheetID, cszCDAUDIO))
    {
        pfnDlgProc = CD_HardwareDlgProc;
        idTemplate = HWDLG;
        goto ShowSheet;
    }
    if (!lstrcmpi(pszPropSheetID, cszMIDI))
    {
    /*
        static EXTPROPSHEETCBPARAM cbpMIDI;

        cbpMIDI.ppsh = &psh;
        cbpMIDI.hti = NULL;
        cbpMIDI.lParam1 = (LPARAM)pszPropSheetID;
        cbpMIDI.lParam2 = (LPARAM)pszTabName;
        AddSimpleMidiPages((LPVOID)pszTabName, MMExtPropSheetCallback, (LPARAM)&cbpMIDI);
        PropertySheet(&psh);
        return TRUE;
      */

        pfnDlgProc = AudioDlg;
        idTemplate = AUDIODLG;
        goto ShowSheet;

    }

    return FALSE;
    ShowSheet:
    AddPage(&psh, pszTabName,  pfnDlgProc, idTemplate, (LPARAM)NULL);
    PropertySheet(&psh);
    return TRUE;
}

BOOL WINAPI ShowMMCPLPropertySheet(HWND hwndParent, LPCSTR pszPropSheetID, LPSTR pszTabName, LPSTR pszCaption)
{
    DLGPROC pfnDlgProc;
    UINT    idTemplate;
    HWND    hwndP;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];
    TCHAR szPropSheetID[MAX_PATH];
    TCHAR szTabName[MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    //convert three params into UNICODE strings
    MultiByteToWideChar( GetACP(), 0, pszPropSheetID, -1, szPropSheetID, sizeof(szPropSheetID) / sizeof(TCHAR) );
    MultiByteToWideChar( GetACP(), 0, pszTabName,     -1, szTabName,     sizeof(szTabName)     / sizeof(TCHAR) );
    MultiByteToWideChar( GetACP(), 0, pszCaption,     -1, szCaption,     sizeof(szCaption)     / sizeof(TCHAR) );

    return (ShowMMCPLPropertySheetW(hwndParent,szPropSheetID,szTabName,szCaption));
}

//allows you to show control panel from RUNDLL32
DWORD WINAPI ShowFullControlPanel(HWND hwndP, HINSTANCE hInst, LPTSTR szCmd, int nShow)
{
    cplMMDoubleClick(hwndP, 0);
    return 0;
}

DWORD WINAPI ShowAudioPropertySheet(HWND hwndP, HINSTANCE hInst, LPTSTR szCmd, int nShow)
{
    TCHAR szAudio[MAXLNAME];
    TCHAR szAudioProperties[MAXLNAME];
    char mbcszAUDIO[MAXLNAME];
    char mbszAudio[MAXLNAME];
    char mbszAudioProperties[MAXLNAME];
    HWND hwndPrev;

    LoadString(ghInstance, IDS_AUDIOPROPERTIES, szAudioProperties, sizeof(szAudioProperties)/sizeof(TCHAR));
    hwndPrev = FindWindow(NULL,szAudioProperties);
    if (hwndPrev)
    {
        SetForegroundWindow(hwndPrev);
    }
    else
    {
        LoadString(ghInstance, IDS_WAVE_HEADER, szAudio, sizeof(szAudio)/sizeof(TCHAR));
        ShowMMCPLPropertySheetW(hwndP, cszAUDIO, szAudio, szAudioProperties);
    }
    return 0;
}


DWORD WINAPI mmseRunOnce(HWND hwnd, HINSTANCE hInst, LPSTR lpszCmdLine, int nShow)
{
    // This is an obsolete function formerly used to migrate
    // registry and driver information.  We leave the export
    // in place in case an old installation has left a RunOnce
    // command in place to execute this function.
    return 0;
}

DWORD WINAPI mmseRunOnceW(HWND hwnd, HINSTANCE hInst, LPWSTR lpwszCmdLine, int nShow)
{
    // This is an obsolete function formerly used to migrate
    // registry and driver information.  We leave the export
    // in place in case an old installation has left a RunOnce
    // command in place to execute this function.
    return 0;
}

extern BOOL DriversDllInitialize (IN PVOID, IN DWORD, IN PCONTEXT OPTIONAL);

BOOL DllInitialize (IN PVOID hInstance,
                    IN DWORD ulReason,
                    IN PCONTEXT pctx OPTIONAL)
{
    // patch in the old DRIVERS.DLL code (see DRIVERS.C)
    //
    DriversDllInitialize (hInstance, ulReason, pctx);

    if (ulReason == DLL_PROCESS_ATTACH)
    {
        ++g_cProcesses;
        ghInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        return TRUE;
    }

    if (ulReason == DLL_PROCESS_DETACH)
    {
        --g_cProcesses;
        return TRUE;
    }

    return TRUE;
}

DWORD
    WINAPI
    MediaClassInstaller(
                       IN DI_FUNCTION      InstallFunction,
                       IN HDEVINFO         DeviceInfoSet,
                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                       )
/*++

Routine Description:

    This routine acts as the class installer for Media devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD dwRet=ERROR_DI_DO_DEFAULT;

    switch (InstallFunction)
    {

    case DIF_SELECTBESTCOMPATDRV:
        dwRet = Media_SelectBestCompatDrv(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_ALLOW_INSTALL:
        dwRet = Media_AllowInstall(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_INSTALLDEVICE :
        dwRet = Media_InstallDevice(DeviceInfoSet, DeviceInfoData);
        break;

    case DIF_REMOVE:
        dwRet = Media_RemoveDevice(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_SELECTDEVICE:
        dwRet = Media_SelectDevice(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_FIRSTTIMESETUP:
        // Fall through

    case DIF_DETECT:
        dwRet = Media_MigrateLegacy(DeviceInfoSet,DeviceInfoData);
        break;

    }

    return dwRet;

}

DWORD WINAPI mmWOW64MediaInstallDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HWND hWnd;

    //
    // Get the device install parameters, so we'll know what parent window to use for any
    // UI that occurs during configuration of this device.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
        hWnd = DeviceInstallParams.hwndParent;
    }
    else
    {
        hWnd = NULL;
    }

    //
    // The INF will have created a "Drivers" subkey under the device's software key.
    // This tree, in turn, contains subtrees for each type of driver (aux, midi, etc.)
    // applicable for this device.  We must now traverse this tree, and create entries
    // in Drivers32 for each function alias.
    //
    return InstallDriversForPnPDevice(hWnd, DeviceInfoSet, DeviceInfoData);
}


DWORD WINAPI mmWOW64MediaRemoveDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    if( RemoveDriver(DeviceInfoSet, DeviceInfoData) )
    {
        return NO_ERROR;
    }
    else
    {
        return ERROR_BAD_DRIVER;
    }
}


DWORD WINAPI mmWOW64MediaClassInstallerA(HWND hwnd, HINSTANCE hInst, LPSTR lpszCmdLine, int nShow)
/*++

Routine Description:

    This routine acts as a thunking layer for calling the 32-bit
        installation functions from the 64-bit setup via RunDLL32.exe.

Arguments:

    hwnd - not used

    hInst - not used

    lpwszCmdLine - command line arguments: "Instance ID (string)" DI_FUNCTION (as an integer)

    nShow - not used

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    LPSTR strInstanceID = NULL;
    LPSTR strInstallIndex = NULL;
    DWORD dwInstallIndex = 0;
    LPSTR strTemp = NULL;
    HDEVINFO DeviceInfoSet = NULL;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwResult = NO_ERROR;

    // Find first quote
    strTemp = strchr( lpszCmdLine, '\"' );
    if( !strTemp )
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Instance ID

    // Skip first quote
    strInstanceID = ++strTemp;

    // Find second quote
    strTemp = strchr( strTemp, '\"' );
    if( !strTemp )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // NULL-terminate the InstanceID
    *strTemp = 0;


    // Install Index

    // Skip the NULL
    strInstallIndex = ++strTemp;


    // Convert the installation index
    dwInstallIndex = atoi( strInstallIndex );


    // Create a device handle
    DeviceInfoSet = SetupDiCreateDeviceInfoList( NULL, NULL );
    if( INVALID_HANDLE_VALUE == DeviceInfoSet )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Create the device info structure
    ZeroMemory( &DeviceInfoData, sizeof(SP_DEVINFO_DATA) );
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if( 0 == SetupDiOpenDeviceInfoA( DeviceInfoSet, strInstanceID, NULL, 0, &DeviceInfoData ) )
    {
        dwResult = GetLastError();
    }

    // Do the installation task
    if( NO_ERROR == dwResult )
    {
        switch( dwInstallIndex )
        {
        case DIF_INSTALLDEVICE:
            dwResult = mmWOW64MediaInstallDevice(DeviceInfoSet, &DeviceInfoData);
            break;
        case DIF_REMOVE:
            dwResult = mmWOW64MediaRemoveDevice(DeviceInfoSet, &DeviceInfoData);
            break;
        default:
            dwResult = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    SetupDiDestroyDeviceInfoList( DeviceInfoSet );

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmcpl.h ===
/*
 ***************************************************************
 *  mmcpl.h
 *
 *  Header file for mm control applet.
 *
 *
 *  History:
 *
 *      January -by- VijR
 *          Created.
 ***************************************************************
 */

#ifndef MMCPL_H
#define MMCPL_H

#define _INC_OLE
#ifndef STRICT
#define STRICT
#endif

#pragma warning( disable: 4103)
#include <windows.h>        // also includes windowsx.h
#include <shellapi.h>       // for registration functions
#include <windowsx.h>
#include <ole2.h>
#include <mmsystem.h>
#include <setupapi.h>

#include <shlobj.h>         // Shell OLE interfaces
#include <string.h>
#ifndef INITGUID
#include <shlobjp.h>
#endif
#include <commdlg.h>

#include "rcids.h"          // Resource declaration

#define PUBLIC          FAR PASCAL
#define CPUBLIC         FAR _cdecl
#define PRIVATE         NEAR PASCAL

//#include "utils.h"          // Common macros


/* Temporarily here until someone defines these for 16 bit side again. */
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS            0L
#endif

/*
 ***************************************************************
 * Constants and Definitions
 ***************************************************************
 */
#define     MIDI        TEXT("MIDI")
#define     ACM         TEXT("ACM")
#define     MSACM       TEXT("MSACM.")
#define     WAVE        TEXT("Wave")
#define     MIDIMAP     TEXT("MidiMapper")
#define     WAVEMAP     TEXT("WaveMapper")
#define     AUX         TEXT("Aux")
#define     MIXER       TEXT("Mixer")
#define     JOYSTICK    TEXT("Joystick")
#define     MCI         TEXT("MCI")
#define     ICM         TEXT("ICM")
#define     ICMSTR      TEXT("VIDC.")
#define     ICMSTR2     TEXT("VIDS.")
#define     VIDCAP      TEXT("MSVIDEO")

#define     AUDIO       TEXT("Audio")
#define     CDAUDIO     TEXT("CDAudio")
#define     VIDEO       TEXT("Video")
#define     VOICE       TEXT("Voice")
#define     VOLUME      TEXT("Volume")


#define MAXSTR                  256    // maximum size of a string or filename
#define SZCODE                  const TCHAR
#define INTCODE                 const int
#define WINDOWS_DEFAULTENTRY    1
#define NONE_ENTRY              0

#define MAXNAME                 32      // Maximum name length
#define MAXLNAME                64
#define MAXMESSAGE              128     // Maximum resource string message
#define MAXSTRINGLEN            256     // Maximum output string length
#define MAXINTLEN               7       // Maximum interger string length
#define MAXLONGLEN              11      // Maximum long string length
#define MAXMSGLEN               512     // Maximum message length



#define WAVE_ID         0
#define MIDI_ID         1
#define MIXER_ID        2
#define AUX_ID          3
#define MCI_ID          4
#define ACM_ID          5
#define ICM_ID          6
#define VIDCAP_ID       7
#define JOYSTICK_ID     8

DEFINE_GUID(CLSID_mmsePropSheetHandler, 0x00022613L, 0x0000, 0x0000, 0xC0, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x46);

#define HWAVEOUT_MAPPER       ((HWAVEOUT)IntToPtr(WAVE_MAPPER))
#define HWAVEIN_MAPPER        ((HWAVEIN)IntToPtr(WAVE_MAPPER))
#define HMIDIOUT_MAPPER       ((HMIDIOUT)IntToPtr(WAVE_MAPPER))

#define HWAVEOUT_INDEX(i)     ((HWAVEOUT)IntToPtr(i))
#define HWAVEIN_INDEX(i)      ((HWAVEIN)IntToPtr(i))
#define HMIDIOUT_INDEX(i)     ((HMIDIOUT)IntToPtr(i))
#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))
#define HMIXEROBJ_INDEX(i)    ((HMIXEROBJ)IntToPtr(i))


/*
 ***************************************************************
 * Internal STRUCTS used by mm.cpl
 ***************************************************************
 */

typedef struct _ClassNode
{
    short iNode;    //1 if class, 2 if device , 3-> ACM, 4->instrument
    TCHAR szClassName[64];
    TCHAR szClass[16];
    HICON hIcon;
} CLASSNODE, * PCLASSNODE;


typedef struct iResources
{
    short   iNode;
    TCHAR    szFriendlyName[MAXSTR];
    TCHAR    szDesc[MAXSTR];
    TCHAR    szParam[64];
    TCHAR    szFile[MAXSTR];
    TCHAR    szDrvEntry[64];
    TCHAR    szClass[16];
    HDRVR   hDriver;
    DWORD   dnDevNode;
    short   fQueryable;     // 0 -> can't, 1 -> can, -1 -> need to check
    short   iClassID;
    int     fStatus; //0 -> Disabled, 1-> Enabled and entry in reg, 2->Enabled but no entry in reg (i.e.old dev), 3->Enabled and ACTIVE, 4->inactive
    PCLASSNODE  pcn;
}IRESOURCE, *PIRESOURCE;

typedef struct _Instrument
{
    short   iNode;
    TCHAR    szFriendlyName[MAXSTR];
    TCHAR    szInstr[64];
    PIRESOURCE     pDev;
}INSTRUMENT, * PINSTRUMENT;

typedef struct event
{
    short   iNode;    //1 if module 2 if event
    short   fHasSound;
    LPTSTR    pszEvent;
    LPTSTR    pszEventLabel;
    LPTSTR    pszPath;
    struct event *npNextEvent;
} EVENT,  *PEVENT;

typedef struct module
{
    short   iNode;    //1 if module 2 if event
    LPTSTR    pszKey;
    LPTSTR    pszLabel;
    BOOL    fChange;
    PEVENT  npList;
} MODULE, *PMODULE;

typedef struct _AudioDlgInfo
{
    UINT    uPrefIn;
    UINT    uPrefOut;
    UINT    uPrefMIDIOut;
    UINT    cNumOutDevs;
    UINT    cNumInDevs;
    UINT    cNumMIDIOutDevs;
    BOOL    fPrefOnly;
} AUDIODLGINFO, * PAUDIODLGINFO;


typedef struct
{
    HDEVINFO            hDevInfo;
    PSP_DEVINFO_DATA    pDevInfoData;

} ALLDEVINFO, *PALLDEVINFO;

/*
 ***************************************************************
 * Globals and Strings used to loadstring resources at startup
 ***************************************************************
 */
#ifdef __cplusplus
extern "C" {
#endif

extern TCHAR        gszNone[];
extern TCHAR        gszRemoveScheme[];
extern TCHAR        gszChangeScheme[];
extern SZCODE      gszWindowsHlp[];
extern SZCODE      gszNull[];

extern SZCODE      cszWavExt[];
extern SZCODE      cszMIDIExt[];
extern SZCODE      cszRMIExt[];
extern SZCODE      cszAVIExt[];
extern SZCODE      cszSlash[];

extern SZCODE      cszAUDIO[];
extern SZCODE      cszVIDEO[];
extern SZCODE      cszCDAUDIO[];
extern SZCODE      cszMIDI[];

extern TCHAR       gszDevEnabled[];
extern TCHAR       gszDevDisabled[];
extern TCHAR       gszGeneral[];

extern HINSTANCE ghInstance;
extern BOOL gfVoiceTab;
extern HWND ghVocDlg;

extern INT_PTR PASCAL GetVerDesc (LPCTSTR pstrFile, LPTSTR pstrDesc);
extern BOOL PASCAL GetExeDesc (LPTSTR szFile, LPTSTR pszBuff, int cchBuff);
extern BOOL PASCAL LoadDesc(LPCTSTR pstrFile, LPTSTR pstrDesc);
extern void AddExt(LPTSTR pszFile, LPCTSTR cszExt);
extern BOOL PASCAL ValidateRegistry(void);


#define GEI_MODNAME         0x01
#define GEI_DESCRIPTION     0x02
#define GEI_FLAGS           0x03
#define GEI_EXEHDR          0x04
#define GEI_FAPI            0x05

MMRESULT GetWaveID(UINT *puWaveID);

void PASCAL ShowPropSheet(LPCTSTR            pszTitle,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    LPTSTR               pszCaption,
    LPARAM              lParam);

void PASCAL ShowMidiPropSheet(LPPROPSHEETHEADER ppshExt, LPCTSTR pszTitle,
    HWND                hWndParent,
    short               iMidiPropType,
    LPTSTR               pszCaption,
    HTREEITEM           hti,
    LPARAM              lParam1,
    LPARAM              lParam2);

void PASCAL ShowWithMidiDevPropSheet(LPCTSTR            pszTitle,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    LPTSTR               pszCaption,
    HTREEITEM           hti,
    LPARAM lParam, LPARAM lParamExt1, LPARAM lParamExt2);

#define MT_WAVE 1
#define MT_MIDI 2
#define MT_AVI  3
#define MT_ASF  4
#define MT_ERROR 0
BOOL mmpsh_ShowFileDetails(LPTSTR pszCaption, HWND hwndParent, LPTSTR pszFile, short iMediaType);

int FAR PASCAL lstrncmpi(LPCTSTR    lszKey,
    LPCTSTR    lszClass,
    int    iSize);


INT_PTR mmse_MessageBox(HWND hwndP,  LPTSTR szMsg, LPTSTR szTitle, UINT uStyle);


void PASCAL GetPropSheet(LPCTSTR            pszTitle,
    LPCTSTR              pszClass,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    HICON               hClassIcon,
    LPPROPSHEETHEADER ppsh, HPROPSHEETPAGE  * lphpsp);

BOOL      PASCAL ErrorBox               (HWND, int, LPTSTR);
int       PASCAL DisplayMessage(HWND hDlg, int iResTitle, int iResMsg, UINT uStyle);


BOOL ACMEnumCodecs(void);
void ACMCleanUp(void);
void ACMNodeChange(HWND hDlg);

BOOL CALLBACK MMExtPropSheetCallback(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance);
typedef BOOL (CALLBACK FAR * LPFNMMEXTPROPSHEETCALLBACK)(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance);

//Following are functions currently supported by the callback functions:
//dwInstance parameter which is passed to the external module when its entry point
//is called MUST always be passed back along with all the functions.

#define MM_EPS_GETNODEDESC      0x00000001
    //Gets the description displayed in the tree for the node for which the External Prop. Sheet is up.
    //For 'simple' property sheet this just returns a sheet Name
    //dwParam1 is a pointer to a string buffer in which the description is returned

#define MM_EPS_GETNODEID        0x00000002
    //Gets the Reg. Key Path offset from the MediaResources key
    //For 'simple' property sheet this just returns a sheet class
    //dwParam1 is a pointer to a string buffer in which the Key Path is returned

#define MM_EPS_ADDSHEET         0x00000003
    //Adds a property sheet for the current node in the tree.
    //dwParam1 = HPROPSHEETPAGE for the page being added.

#define MM_EPS_TREECHANGE       0x00000004
    //Notifies the CPL that the tree styructure has change. On receiving this function
    //the CPL rebuilds the subtree at this level and all levels below it.

#define MM_EPS_BLIND_TREECHANGE    0x00000005
    //Notification from MIDI sheet that something has changed in the MIDI subtree.
    //BLIND because the sheet was not launched from the Adv. Tab, so we dont know
    //what the heck he is talking about.

BOOL CALLBACK  AddSimpleMidiPages (LPTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddMidiPages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddDevicePages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddInstrumentPages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);

#ifdef FIX_BUG_15451
void ShowDriverSettings (HWND hDlg, LPTSTR pszName);
#endif // FIX_BUG_15451

#ifdef __cplusplus
} // extern "C"
#endif

#define MIDI_CLASS_PROP 1
#define MIDI_DEVICE_PROP 2
#define MIDI_INSTRUMENT_PROP 3


#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

/*
 ***************************************************************
 * DEBUG Definitions
 ***************************************************************
 */
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef DEBUG
#define STATIC
#ifdef DEBUG_TRACE
#define DPF_T    dprintf
#else
#define DPF_T 1 ? (void)0 : (void)
#endif
void FAR cdecl dprintf(LPSTR szFormat, ...);
#define DPF    dprintf
#define ddd    dprintf
#define ASSERT(f)                                                       \
    {                                                                   \
        if (!(f))                                                       \
            DPF("ERROR-ERROR#####: Assertion failed in %s on line %d @@@@@",__FILE__, __LINE__);                          \
    }


#else
#define STATIC static
#define ASSERT(f)
#define DPF 1 ? (void)0 : (void)
#define DPF_T 1 ? (void)0 : (void)
#endif

#endif // MMCPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmdriver.c ===
/*----------------------------------------------------------------------------
 | mmdriver.c - Install Multimedia Drivers
 |
 | Copyright (C) Microsoft, 1989, 1990.  All Rights Reserved
 |
 |  History:
 |      09/11/90    davidle     created
 |          Install Multimedia Drivers
 |
 |      Tue Jan 29 1991 -by- MichaelE
 |          Redesigned installing installable drivers so additional drivers
 |        can be installed by adding them to setup.inf's [installable.drivers]
 |
 |      Wed Mar 20 1991 -by- MichaelE
 |          Changed mmAddInstallableDriver to accept multiple VxDs.
 |          Changed and WriteNextPrivateProfileString to check if the profile
 |          being concatenated is already there.
 |
 |      Sun Apr 14 1991 -by- MichaelE
 |          WriteNextPrivateProfileString -> Next386EnhDevice.
 |
 |      Sun Apr 14 1991 -by- JohnYG
 |          Taken from setup for drivers applet.
 |
 |      Wed Jun 05 1991 -by- MichaelE
 |          Added FileCopy of associated file list to windows system dir.
 |
 *----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*
 *  Local functions
 */

 static BOOL mmAddInstallableDriver         (PINF, LPTSTR, LPTSTR, PIDRIVER );
 static void GetDrivers                     (PINF, LPTSTR, LPTSTR);

/**************************************************************************
 *
 *  AccessServiceController()
 *
 *  Check we will be able to access the service controller to install
 *  a driver
 *
 *  returns FALSE if we can't get access - otherwise TRUE
 *
 **************************************************************************/
 BOOL AccessServiceController(void)
 {

     SC_HANDLE SCManagerHandle;

     SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
     if (SCManagerHandle == NULL) {
         return FALSE;
     }

     CloseServiceHandle(SCManagerHandle);

     return TRUE;
 }


/**************************************************************************
 *
 *  mmAddNewDriver() - only exported function in this file.
 *
 *  This function installs (copies) a driver
 *
 *  returns FALSE if no drivers could be installed.
 *          TRUE if at least one driver installation was sucessful.
 *          All added types in lpszNewTypes buffer.
 *
 **************************************************************************/

 BOOL mmAddNewDriver( LPTSTR lpstrDriver, LPTSTR lpstrNewTypes, PIDRIVER pIDriver )
 {
     PINF pinf;

     if ((pinf = FindInstallableDriversSection(NULL)) == NULL)
         return FALSE;

     return mmAddInstallableDriver(pinf, lpstrDriver, lpstrNewTypes, pIDriver);
 }


/**************************************************************************
 * mmAddInstallableDriver() - Do the dirty work looking for VxD's copying them
 *     looking for drivers, copying them, and returning the best type names.
 *
 *
 **************************************************************************/

BOOL mmAddInstallableDriver( PINF pInfIDrivers,
                             LPTSTR pstrDriver,
                             LPTSTR lpstrNewTypes,
                             PIDRIVER pIDriver)
{
    LPTSTR pstr, pstrSection;
    static TCHAR szTemp[10];
    PINF pInfSection= pInfIDrivers;
    int  i;
    TCHAR szBuffer[MAX_INF_LINE_LEN],
         szFilename[MAXSTR],
         szType[MAX_SECT_NAME_LEN];

   /*
    *  format of a line in [installable.drivers] of setup.inf:
    *  driver profile =                            [0]
    *                   filename,                  [1]
    *                   "type(s)",                 [2]
    *                   "description",             [3]
    *                   "VxD and .sys filename(s)",[4]
    *                   "default config params"    [5]
    *                   "Related drivers"          [6]
    *
    *  find the driver profile line in szMDrivers we are installing
    */

    while ( TRUE )
    {
        infParseField( pInfIDrivers, 0, szBuffer );
        if ( lstrcmpi( szBuffer, pstrDriver ) == 0 )
            break;
        else if ( ! (pInfIDrivers = infNextLine( pInfIDrivers )) )
            return FALSE;
    }

   /*
    *  copy the driver file and add driver type(s) to the installable
    *  driver section
    */

    if ( !infParseField( pInfIDrivers, 1, szFilename ))
        return FALSE;


   /*
    *  Ignore the disk number
    */

    wcscpy(szDrv, RemoveDiskId(szFilename));

   /*
    *  Cache whether it's a kernel driver
    */

    pIDriver->KernelDriver = IsFileKernelDriver(szFilename);

   /*
    *  Can't install kernel drivers if don't have privilege
    */

    if (pIDriver->KernelDriver && !AccessServiceController()) {

        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];
        TCHAR szTitle[50];

        LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szDrv);
        MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

        return FALSE;
    }

   /*
    *  Do the file copying
    */

    if (FileCopy( szFilename,
                  szSystem,
                  (FPFNCOPY)wsCopySingleStatus,
                  FC_FILE ) != NO_ERROR) {
        return FALSE;
    }

   /*
    *  Add options
    */

    if (infParseField (pInfIDrivers,5,szBuffer+1))
    {
       szBuffer[0]=TEXT(' ');
       lstrcat(szFilename,szBuffer);
    }

   /*
    *  copy filename and options
    */

    wcsncpy(pIDriver->szFile, FileName(szFilename), sizeof(pIDriver->szFile)/sizeof(TCHAR));
    pIDriver->szFile[sizeof(pIDriver->szFile)/sizeof(TCHAR) - 1] = 0;

   /*
    *  copy description
    */

    infParseField( pInfIDrivers, 3, pIDriver->szDesc );

   /*
    *  determine the section from the description.  A kernel driver
    *  will appear as a driver of type 'KERNEL' in system.ini
    *
    *  If the description contains [MCI] then it's MCI.
    */

    if (wcsstr(pIDriver->szDesc, TEXT("MCI")))
        pstrSection = szMCI;
    else
        pstrSection = szDrivers;

   /*
    *  Copy name plus parameters to our driver data
    */

    wcsncpy(pIDriver->szSection, pstrSection, sizeof(pIDriver->szSection)/sizeof(TCHAR));
    pIDriver->szSection[sizeof(pIDriver->szSection)/sizeof(TCHAR) - 1] = TEXT('\0');
    wcscpy(pIDriver->wszSection, pIDriver->szSection);

   /*
    *  We return all types in a parseable, contcatentated string
    */

    for ( i = 1, infParseField( pInfIDrivers, 2, szBuffer );
          infParseField( szBuffer, i, szType );
          i++ )
    {
        pstr = &(szType[lstrlen(szType)]);
        *pstr++ = TEXT(',');
        *pstr = 0;
        lstrcat(lpstrNewTypes, szType );
    }

    if (!*lpstrNewTypes)

      /*
       *  We weren't able to return any types.
       */
       return FALSE;

   /*
    *  copy an associated file list (if it exists) to windows system dir
    */

    if (FileCopy(pstrDriver,
                 szSystem,
                 (FPFNCOPY)wsCopySingleStatus,
                 FC_SECTION) != ERROR_SUCCESS)

        return(FALSE);


   /*
    *  if there are system driver files copy them to the system
    *  drivers directory.
    *
    *  NOTE that it is assumed here that any installation and
    *  configuration for these drivers is performed by the main
    *  (.drv) driver being installed.
    *
    */

    if (infParseField( pInfIDrivers, 4, szBuffer ) && szBuffer[0])
    {
        for ( i = 1; infParseField( szBuffer, i, szFilename ); i++ )
        {
            wcscpy(szDrv, RemoveDiskId(szFilename));

           /*
            *  FileCopy will adjust the 'system' directory to
            *  system\drivers.  It's done this way because FileCopy
            *  must anyway look for old files in the same directory.
            */

            if (FileCopy(szFilename,
                         szSystem,
                         (FPFNCOPY)wsCopySingleStatus,
                         FC_FILE )
                != ERROR_SUCCESS)
            {
                return FALSE;
            }
        }
    }

#ifdef DOBOOT // Don't do boot section on NT

    infParseField(pInfIDrivers, 7, szTemp);

    if (!_strcmpi(szTemp, szBoot))
        bInstallBootLine = TRUE;

#endif // DOBOOT


   /*
    *  Read the related drivers list (drivers which must/can also be
    *  be installed).
    */

    if (bRelated == FALSE)
    {
       infParseField(pInfIDrivers, 6, pIDriver->szRelated);
       if (wcslen(pIDriver->szRelated))
       {
          GetDrivers(pInfSection, pIDriver->szRelated, pIDriver->szRemove);
          pIDriver->bRelated = TRUE;
          bRelated = TRUE;
       }
    }
    return TRUE;
}

/*
 *  Used to get the list of the related driver filenames
 *
 *  pInfIDrivers - Pointer to the [installable.drivers] section or equivalent
 *  szAliasList  - List of driver aliases (ie key values - eg msalib).
 *  szDriverList - List of drivers file names found
 */

void GetDrivers(PINF pInfIDrivers, LPTSTR szAliasList, LPTSTR szDriverList)
{
    TCHAR szBuffer[50];
    TCHAR szAlias[50];
    TCHAR szFileName[50];
    PINF pInfILocal;
    BOOL bEnd;
    int i;

    for ( i = 1; infParseField(szAliasList, i, szAlias); i++ )
    {
        pInfILocal = pInfIDrivers;
        bEnd = FALSE;
        while (!bEnd)
        {
            infParseField( pInfILocal, 0, szBuffer);
            if (lstrcmpi( szBuffer, szAlias) == 0 )
            {
                if (infParseField(pInfILocal, 1, szFileName))
                {
                    lstrcat(szDriverList, RemoveDiskId(szFileName));
                    lstrcat(szDriverList, TEXT(","));
                }
                break;
            }
            else
                if ( ! (pInfILocal = infNextLine( pInfILocal )) )
                    bEnd = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifdef _WIN32								/* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS
{
    DWORD           dwStartPage;
    DWORD           dwPageCount;
    DWORD           fdwOperation;
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{
    DWORD           fnCallback;
    DWORD_PTR       dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD					
#define MM_STOP 	0					
#define MM_START 	1					
#define MM_MMDEVLDR_UP  3			


#define CONFIG_QUERYSTART	0x01000

#define MAXLEN	256 					

typedef struct tagMMDEVNODE
{
   DEVNODE      dn ;
   DWORD        dwDevStatus ;
   VMMLIST      hlDrivers ;

} MMDEVNODE, *PMMDEVNODE ;


typedef struct tagMMDRVNODE
{
   CMCONFIGHANDLER  pConfigHandler ;
   DWORD            dwRefData ;

} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define	DBG_TRACE(strings) {\
	_Debug_Printf_Service( "MMDEVLDR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#ifdef DEBUG
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");\
	{_asm	int	3}}
#else
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;
#else
#define DPF( strings )
#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//

void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)		// turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID	MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else								/* ;EndInternal */


#define Multimedia_OEM_ID   0x0440	//            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10 	//;MMDEVLDR's device ID

#ifdef Begin_Service_Table		// define only if vmm.h is included

#define	MMDEVLDR_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service	(MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service	(MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS

#pragma warning (default:4003)		// turn on not enough params warning

#pragma warning (disable:4035)		// turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD_PTR       dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    Touch_Register(edx)
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)		// turn on no return code warning

#endif // Begin_Service_Table

#endif 			/* ;Internal */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\msacmcpl.c ===
//==========================================================================;
//
//  cpl.c
//
//  Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/94        VijR (Vij Rajarajan);
//
//      10/95        R Jernigan - removed link to Adv tab's treeview control
//
//==========================================================================;
#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */

#ifndef DRV_F_ADD
#define DRV_F_ADD              0x00000000         // TODO: Should be in MMDDK.H
#define DRV_F_REMOVE           0x00000001
#define DRV_F_CHANGE           0x00000002
#define DRV_F_PROP_INSTR       0x00000004
#define DRV_F_NEWDEFAULTS      0x00000008
#define DRV_F_PARAM_IS_DEVNODE 0x10000000
#endif

#ifndef ACMHELPMSGCONTEXTMENU                                  // TODO: Should
#define ACMHELPMSGCONTEXTMENU   TEXT("acmchoose_contextmenu")  // be in MSACM.H
#define ACMHELPMSGCONTEXTHELP   TEXT("acmchoose_contexthelp")
#endif

#ifndef ACMFORMATCHOOSE_STYLEF_CONTEXTHELP    // TODO: Should be in MSACM.H
#define ACMFORMATCHOOSE_STYLEF_CONTEXTHELP    0x00000080L
#endif

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

BOOL        gfLoadedACM;
UINT        giDevChange = 0;
WNDPROC     gfnPSProc = NULL;
HWND        ghDlg;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef struct tACMDRIVERSETTINGS
    {
    HACMDRIVERID        hadid;
    DWORD               fdwSupport;
    DWORD               dwPriority;
    } ACMDRIVERSETTINGS, FAR *LPACMDRIVERSETTINGS;

typedef struct _CplCodecInfo
    {
    TCHAR szDesc[128];
    ACMDRIVERSETTINGS ads;
    HICON hIcon;
    BOOL  fMadeIcon;
    }CPLCODECINFO, * PCPLCODECINFO;



/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static CONST TCHAR      aszFormatNumber[]       = TEXT("%lu");

//
//  These hold Window Message IDs for the two messages sent from the
//  Customize dialog (acmFormatChoose) for context-sensitive help.
//
UINT guCustomizeContextMenu = WM_NULL;
UINT guCustomizeContextHelp = WM_NULL;
BOOL fHaveStartedAudioDialog = FALSE;


/*
 ***************************************************************
 * extern
 ***************************************************************
 */

//
//  this string variable must be large enough to hold the IDS_TXT_DISABLED
//  resource string.. for USA, this is '(disabled)'--which is 11 bytes
//  including the NULL terminator.
//
TCHAR gszDevEnabled[256];
TCHAR gszDevDisabled[256];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoACMPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL DoAudioCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL CustomizeDialog(HWND hDlg, LPTSTR szNewFormat, DWORD cbSize);
void DoAdvancedSetup(HWND hwnd);

void WAVEOUTInit(HWND hDlg, PAUDIODLGINFO pai);
void WAVEINInit(HWND hDlg, PAUDIODLGINFO pai);


PCPLCODECINFO acmFindCodecInfo         (WORD, WORD);
BOOL CALLBACK acmFindCodecInfoCallback (HACMDRIVERID, DWORD_PTR, DWORD);
void          acmFreeCodecInfo         (PCPLCODECINFO);

UINT          acmCountCodecs           (void);
BOOL CALLBACK acmCountCodecsEnum       (HACMDRIVERID, DWORD_PTR, DWORD);


#ifndef ACM_DRIVERREMOVEF_UNINSTALL
#define ACM_DRIVERREMOVEF_UNINSTALL 0x00000001L
#endif

/*
 ***************************************************************
 ***************************************************************
 */

void acmDeleteCodec (WORD wMid, WORD wPid)
{
    PCPLCODECINFO pci;

    if ((pci = acmFindCodecInfo (wMid, wPid)) != NULL)
    {
        acmDriverRemove (pci->ads.hadid, ACM_DRIVERREMOVEF_UNINSTALL);
        acmFreeCodecInfo (pci);
    }
}




//--------------------------------------------------------------------------;
//
//  INT_PTR DlgProcACMAboutBox
//
//  Description:
//
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

INT_PTR CALLBACK DlgProcACMAboutBox
(
    HWND                hwnd,
    UINT                uMsg,
    WPARAM              wParam,
    LPARAM              lParam
)
{
    TCHAR               ach[80];
    TCHAR               szFormat[80];
    LPACMDRIVERDETAILS  padd;
    DWORD               dw1;
    DWORD               dw2;
    UINT                uCmdId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            padd = (LPACMDRIVERDETAILSW)lParam;

            if (NULL == padd)
            {
                DPF(0, "!DlgProcACMAboutBox: NULL driver details passed!");
                return (TRUE);
            }

            //
            //  fill in all the static text controls with the long info
            //  returned from the driver
            //
            LoadString(ghInstance, IDS_ABOUT_TITLE, szFormat, sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(ach, szFormat, (LPTSTR)padd->szShortName);
            SetWindowText(hwnd, ach);

            //
            //  if the driver supplies an icon, then use it..
            //
            if (NULL != padd->hicon)
            {
                Static_SetIcon(GetDlgItem(hwnd, IDD_ABOUT_ICON_DRIVER), padd->hicon);
            }

            SetDlgItemText(hwnd, IDD_ABOUT_TXT_DESCRIPTION, padd->szLongName);

            dw1 = padd->vdwACM;
            dw2 = padd->vdwDriver;
            LoadString(ghInstance, IDS_ABOUT_VERSION, szFormat, sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(ach, szFormat, HIWORD(dw2) >> 8, (BYTE)HIWORD(dw2), HIWORD(dw1) >> 8, (BYTE)HIWORD(dw1));
            SetDlgItemText(hwnd,IDD_ABOUT_TXT_VERSION, ach);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_COPYRIGHT, padd->szCopyright);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_LICENSING, padd->szLicensing);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_FEATURES, padd->szFeatures);
            return (TRUE);
        }
        break;

        case WM_COMMAND:
        {
            uCmdId = GET_WM_COMMAND_ID(wParam,lParam);

            if ((uCmdId == IDOK) || (uCmdId == IDCANCEL))
            EndDialog(hwnd, wParam == uCmdId);
            return (TRUE);
        }
        break;

    }

    return (FALSE);
} // DlgProcACMAboutBox()


//--------------------------------------------------------------------------;
//
//  void ControlAboutDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

STATIC void  ControlAboutDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    PACMDRIVERDETAILSW   padd;
    MMRESULT             mmr;

    if (NULL == pads)
    {
        return;
    }

    //
    //  if the driver returns MMSYSERR_NOTSUPPORTED, then we need to
    //  display the info--otherwise, it supposedly displayed a dialog
    //  (or had a critical error?)
    //
    mmr = (MMRESULT)acmDriverMessage((HACMDRIVER)pads->hadid, ACMDM_DRIVER_ABOUT, (LPARAM)hwnd, 0L);

    if ((MMRESULT)MMSYSERR_NOTSUPPORTED != mmr)
    {
        return;
    }

    //
    //  alloc some zero-init'd memory to hold the about box info
    //
    padd = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd)
    {
        DPF("!PACMDRIVERDETAILSA LocalAlloc failed");
        return;
    }
    //
    //  get info and bring up a generic about box...
    //
    padd->cbStruct = sizeof(*padd);
    mmr = (MMRESULT)acmDriverDetails(pads->hadid, padd, 0L);
    if (MMSYSERR_NOERROR == mmr)
    {
        DialogBoxParam(ghInstance, MAKEINTRESOURCE(DLG_ABOUT_MSACM), hwnd, DlgProcACMAboutBox, (LPARAM)(LPVOID)padd);
    }

    LocalFree((HLOCAL)padd);
} // ControlAboutDriver()


//--------------------------------------------------------------------------;
//
//  BOOL ControlConfigureDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (BOOL):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

STATIC BOOL  ControlConfigureDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    if (NULL == pads)
    {
        return (FALSE);
    }

    if (acmDriverMessage((HACMDRIVER)pads->hadid,DRV_CONFIGURE,(LPARAM)hwnd,0L) == DRVCNF_RESTART)
    {
        DisplayMessage(hwnd, IDS_CHANGESAVED, IDS_RESTART, MB_OK);
    }

    return (TRUE);
} // ControlConfigureDriver()




STATIC void CommitCodecChanges(LPACMDRIVERSETTINGS pads)
{
    MMRESULT            mmr;
    BOOL                fDisabled;
    DWORD               fdwPriority;

    mmr = (MMRESULT)acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_BEGIN);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(end) failed! mmr=%u", mmr);
        return;
    }

    fDisabled = (0 != (ACMDRIVERDETAILS_SUPPORTF_DISABLED & pads->fdwSupport));

    fdwPriority = fDisabled ? ACM_DRIVERPRIORITYF_DISABLE : ACM_DRIVERPRIORITYF_ENABLE;

    mmr = (MMRESULT)acmDriverPriority(pads->hadid, pads->dwPriority, fdwPriority);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(%.04Xh, %lu, %.08lXh) failed! mmr=%u",
        pads->hadid, pads->dwPriority, fdwPriority, mmr);
    }

    mmr = (MMRESULT)acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_END);
}


const static DWORD aACMDlgHelpIds[] = {  // Context Help IDs
    ID_DEV_SETTINGS,              IDH_MMCPL_DEVPROP_SETTINGS,
    IDD_CPL_BTN_ABOUT,            IDH_MMCPL_DEVPROP_ABOUT,
    IDC_ENABLE,                   IDH_MMCPL_DEVPROP_ENABLE,
    IDC_DISABLE,                  IDH_MMCPL_DEVPROP_DISABLE,
    IDC_DEV_ICON,                 NO_HELP,
    IDC_DEV_DESC,                 NO_HELP,
    IDC_DEV_STATUS,               NO_HELP,
    IDD_PRIORITY_TXT_FROMTO,      IDH_MMCPL_DEVPROP_CHANGE_PRI,
    IDD_PRIORITY_COMBO_PRIORITY,  IDH_MMCPL_DEVPROP_CHANGE_PRI,

    0, 0
};

INT_PTR CALLBACK ACMDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    static PCPLCODECINFO pci = NULL;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;

            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    //FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            HWND hwndS = GetDlgItem(hDlg, IDC_DEV_STATUS);
            LPARAM lpUser = ((LPPROPSHEETPAGE)lParam)->lParam;

            if ((pci = acmFindCodecInfo (LOWORD(lpUser), HIWORD(lpUser))) == NULL)
            {
                FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }

            acmMetrics((HACMOBJ)pci->ads.hadid, ACM_METRIC_DRIVER_PRIORITY, &(pci->ads.dwPriority));
            acmMetrics((HACMOBJ)pci->ads.hadid, ACM_METRIC_DRIVER_SUPPORT, &(pci->ads.fdwSupport));


            SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pci->hIcon, 0L);

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pci);
            SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pci->szDesc);

            LoadString (ghInstance, IDS_DEVENABLEDOK, gszDevEnabled, sizeof(gszDevEnabled)/sizeof(TCHAR));
            LoadString (ghInstance, IDS_DEVDISABLED, gszDevDisabled, sizeof(gszDevDisabled)/sizeof(TCHAR));

            if(pci->ads.fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED)
            {
                SetWindowText(hwndS, gszDevDisabled);
                CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
            }
            else
            {
                SetWindowText(hwndS, gszDevEnabled);
                CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
            }

            EnableWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS), (MMRESULT)acmDriverMessage((HACMDRIVER)pci->ads.hadid,DRV_QUERYCONFIGURE,0,0));

            FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
        }
        break;

        case WM_DESTROY:
        {
            FORWARD_WM_COMMAND(hDlg, ID_REBUILD, 0, 0, SendMessage);

            if (pci != NULL)
            {
                acmFreeCodecInfo (pci);
                pci = NULL;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR) (LPTSTR) aACMDlgHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR) (LPTSTR) aACMDlgHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoACMPropCommand);
        }
        break;
    }
    return FALSE;
}


BOOL PASCAL DoACMPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PCPLCODECINFO           pci;
    LPACMDRIVERSETTINGS     pads;
    static int              iPriority = 0;
    static BOOL             fDisabled = TRUE;
    static BOOL             fRebuild;
    HWND hwndS =            GetDlgItem(hDlg, IDC_DEV_STATUS);

    if ((pci = (PCPLCODECINFO)GetWindowLongPtr(hDlg,DWLP_USER)) == NULL)
    {
        return FALSE;
    }

    pads = &(pci->ads);

    switch (id)
    {
        case ID_APPLY:
        {
            HWND hcb = GetDlgItem(hDlg, IDD_PRIORITY_COMBO_PRIORITY);
            if ((fDisabled != Button_GetCheck(GetDlgItem(hDlg, IDC_DISABLE))) || (iPriority != ComboBox_GetCurSel(hcb)+1))
            {
                pads->fdwSupport ^= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
                fDisabled = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));
                iPriority = pads->dwPriority  = ComboBox_GetCurSel(hcb)+1;
                CommitCodecChanges(pads);
                fRebuild = TRUE;
            }
            return TRUE;
        }

        case ID_REBUILD:
        {
            if (fRebuild && pci)
            {
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)0);
                fRebuild = FALSE;
            }
        }
        break;

        case ID_INIT:
        {
            TCHAR achFromTo[80];
            TCHAR ach[80];
            HWND hcb;
            UINT u;
            UINT nCodecs;

            iPriority = (int)pads->dwPriority;
            fDisabled = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));
            fRebuild = FALSE;

            LoadString(ghInstance, IDS_PRIORITY_FROMTO, achFromTo, sizeof(achFromTo)/sizeof(TCHAR));

            wsprintf(ach, achFromTo, iPriority);
            SetDlgItemText(hDlg, IDD_PRIORITY_TXT_FROMTO, ach);

            hcb = GetDlgItem(hDlg, IDD_PRIORITY_COMBO_PRIORITY);

            nCodecs = acmCountCodecs();

            for (u = 1; u <= (UINT)nCodecs; u++)
            {
                wsprintf(ach, aszFormatNumber, (DWORD)u);
                ComboBox_AddString(hcb, ach);
            }

            ComboBox_SetCurSel(hcb, iPriority - 1);
        }
        break;

        case IDD_PRIORITY_COMBO_PRIORITY:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                break;
            }
        }
        break;


        case IDC_ENABLE:
        {
            SetWindowText(hwndS, gszDevEnabled);
            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case IDC_DISABLE:
        {
            SetWindowText(hwndS, gszDevDisabled);
            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case ID_DEV_SETTINGS:
        {
            ControlConfigureDriver(hDlg, pads);
        }
        break;

        case IDD_CPL_BTN_ABOUT:
        {
            ControlAboutDriver(hDlg, pads);
        }
        break;
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD_PTR       dwWaveID = 0;
    DWORD           dwFlags = 0;

    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(DWORD)(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetWaveOutID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, dwFlags);
}



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveInID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD_PTR       dwWaveID = 0;
    DWORD           dwFlags = 0;

    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(DWORD)(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetWaveInID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, dwFlags);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetMIDIOutID(void)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;

    mmr = midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    return(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetMIDIOutID(DWORD dwWaveID)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;

    mmr = midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, 0);
}




void GetPrefInfo(PAUDIODLGINFO pai, HWND hDlg )
{
    MMRESULT        mmr;

    // Load WaveOut Info
	pai->cNumOutDevs = waveOutGetNumDevs();
    pai->uPrefOut = GetWaveOutID(&pai->fPrefOnly);


    // Load WaveIn Info
    pai->cNumInDevs  = waveInGetNumDevs();
    pai->uPrefIn = GetWaveInID(NULL);


    // Load MIDI Out info
    pai->cNumMIDIOutDevs  = midiOutGetNumDevs();
    pai->uPrefMIDIOut = GetMIDIOutID();
}



STATIC void EnablePlayVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_SNDVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_PLAYBACK_ADVSETUP) , fEnable);
}

STATIC void EnableRecVolCtrls(HWND hDlg, BOOL fEnable, BOOL fControl)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_RECVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_RECORD_ADVSETUP) , fControl);
}


STATIC void EnableMIDIVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_MUSICVOL) , fEnable);
}


STATIC void SetDeviceOut(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    pai->uPrefOut = uID;     // New device, lets setup buttons for this device

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefOut), &uMixID, MIXER_OBJECTF_WAVEOUT))
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
	}

	EnablePlayVolCtrls(hDlg, fEnabled);
}



DWORD CountInputs(DWORD dwMixID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    DWORD dwCount = 0;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;
        DWORD       cDestinations;

        cDestinations = mc.cDestinations;

        for (dwDestination = 0; dwDestination < cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_WAVEIN ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
                {
                    DWORD cConnections = mlDst.cConnections;

                    dwCount += mlDst.cControls;

                    if (cConnections)
                    {
                        DWORD dwSource;

                        for (dwSource = 0; dwSource < cConnections; dwSource++)
                        {
                            mlDst.dwDestination = dwDestination;
                            mlDst.dwSource = dwSource;

                            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_SOURCE ) == MMSYSERR_NOERROR)
                            {
                                dwCount += mlDst.cControls;
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwCount);
}


STATIC void SetDeviceIn(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    BOOL    fControl = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    pai->uPrefIn = uID;     // New device, lets setup buttons for this device

    if( (MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefIn),&uMixID, MIXER_OBJECTF_WAVEIN)))
    {
        if( MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))  
        {
            if (CountInputs(uMixID))
            {
		        fEnabled = TRUE;

                // If the capture device is not GFX capable, then there are no tabs to display
                fControl = GFXUI_CheckDevice(uMixID, GFXTYPE_CAPTURE);
            }

            mixerClose(hMixer);
        }
    }

    EnableRecVolCtrls(hDlg, fEnabled, fControl);
}


STATIC void SetMIDIDeviceOut(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL        fEnabled = FALSE;
    HMIXER      hMixer = NULL;
    UINT        uMixID;
    MIDIOUTCAPS moc;
    MMRESULT    mmr;
    UINT        mid;

    pai->uPrefMIDIOut = uID;     // New device, lets setup buttons for this device

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefMIDIOut), &uMixID, MIXER_OBJECTF_MIDIOUT))
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
    }

    EnableMIDIVolCtrls(hDlg, fEnabled);

    fEnabled = FALSE;
    mmr = midiOutGetDevCaps(pai->uPrefMIDIOut, &moc, sizeof(moc));

    if (MMSYSERR_NOERROR == mmr)
    {
        if ((moc.wMid == MM_MICROSOFT) && (moc.wPid == MM_MSFT_WDMAUDIO_MIDIOUT) && (moc.wTechnology == MOD_SWSYNTH))
        {
            fEnabled = TRUE;
        }
    }

    EnableWindow( GetDlgItem(hDlg, IDC_MUSIC_ABOUT) , fEnabled);
}


STDAPI_(void) DoRolandAbout(HWND hWnd)
{
    UINT uWaveID = 0;

    if (GetWaveID(&uWaveID) != (MMRESULT)MMSYSERR_ERROR)
    {
        WAVEOUTCAPS woc;

        if (waveOutGetDevCaps(uWaveID, &woc, sizeof(woc)) == MMSYSERR_NOERROR)
        {
            RolandProp(hWnd, ghInstance, woc.szPname);
        }
    }
}


STATIC void SetPrefInfo(PAUDIODLGINFO pai, HWND hDlg )
{
    HWND    hwndCBPlay   = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    HWND    hwndCBRec    = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    HWND    hwndCBMIDI   = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    HKEY    hkeyAcm;
    UINT    item, deviceID;
    TCHAR   szPref[MAXSTR];

    pai->fPrefOnly = Button_GetCheck(GetDlgItem(hDlg, IDC_AUDIO_PREF));

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);

        if(deviceID != pai->uPrefOut)             // Make sure device changed
        {
            SetDeviceOut(pai, deviceID, hDlg);    // Configure controls for this device
        }
    }

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        if( deviceID != pai->uPrefIn )            // Make sure device changed
        {
            SetDeviceIn(pai, deviceID, hDlg);     // Configure controls for this device
        }
    }

    item = (UINT)ComboBox_GetCurSel(hwndCBMIDI);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBMIDI, item);

        if(deviceID != pai->uPrefMIDIOut)         // Make sure device changed
        {
            SetMIDIDeviceOut(pai, deviceID, hDlg);    // Configure controls for this device
        }
    }

    SetWaveOutID(pai->uPrefOut, pai->fPrefOnly);
    SetWaveInID(pai->uPrefIn, pai->fPrefOnly);
    SetMIDIOutID(pai->uPrefMIDIOut);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);

    //  MIDI Devices are not remapped...
}



STATIC void MSACM_NotifyMapper(void)
{
    waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
    waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
    midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
}



STATIC void WAVEOUTInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwndCBPlay = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    szNoAudio[0] = TEXT('\0');

    ComboBox_ResetContent(hwndCBPlay);

    if (pai->cNumOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOPLAY, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBPlay, szNoAudio);
        ComboBox_SetItemData(hwndCBPlay, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBPlay, 0);
        EnableWindow( hwndCBPlay, FALSE );
        EnablePlayVolCtrls(hDlg, FALSE);
	}
    else
    {
        EnableWindow( hwndCBPlay, TRUE );

        for (device = 0; device < pai->cNumOutDevs; device++)
        {
            WAVEOUTCAPS     woc;
            int newItem;

            woc.szPname[0]  = TEXT('\0');

            if (waveOutGetDevCapsW(device, &woc, sizeof(woc)))
            {
                continue;
            }

            woc.szPname[sizeof(woc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBPlay, woc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBPlay, newItem, (LPARAM)device);

                if (device == pai->uPrefOut)
                {
                    ComboBox_SetCurSel(hwndCBPlay, newItem);
                    SetDeviceOut(pai, device, hDlg);
                }
            }
        }
    }
}

STATIC void WAVEINInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwndCBRec = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    ComboBox_ResetContent(hwndCBRec);

    if (pai->cNumInDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOREC, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBRec, szNoAudio);
        ComboBox_SetItemData(hwndCBRec, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBRec, 0);
        EnableWindow( hwndCBRec, FALSE );
        EnableRecVolCtrls(hDlg, FALSE, FALSE);
    }
    else
    {
        EnableWindow( hwndCBRec, TRUE );

        for (device = 0; device < pai->cNumInDevs; device++)
        {
            WAVEINCAPSW     wic;
            int newItem;

            wic.szPname[0]  = TEXT('\0');

            if (waveInGetDevCapsW(device, &wic, sizeof(wic)))
            {
                continue;
            }

            wic.szPname[sizeof(wic.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBRec, wic.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBRec, newItem, (LPARAM)device);

                if (device == pai->uPrefIn)
                {
                    ComboBox_SetCurSel(hwndCBRec, newItem);
                    SetDeviceIn(pai, device, hDlg);
                }
            }
        }
    }
}


STATIC void MIDIInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwnd  = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    ComboBox_ResetContent(hwnd);

    szNoAudio[0] = TEXT('\0');

    EnableWindow( GetDlgItem(hDlg, IDC_MUSIC_ABOUT) , FALSE);

    if (pai->cNumMIDIOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOMIDIPLAY, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwnd, szNoAudio);
        ComboBox_SetItemData(hwnd, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwnd, 0);
        EnableWindow( hwnd, FALSE );
        EnableMIDIVolCtrls(hDlg, FALSE);
    }
    else
    {
        EnableWindow( hwnd, TRUE );
        for (device = 0; device < pai->cNumMIDIOutDevs; device++)
        {
            MIDIOUTCAPS moc;
            int newItem;

            moc.szPname[0]  = TEXT('\0');

            if (midiOutGetDevCapsW(device, &moc, sizeof(moc)))
            {
                continue;
            }

            moc.szPname[sizeof(moc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwnd, moc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwnd, newItem, (LPARAM)device);

                if (device == pai->uPrefMIDIOut)
                {
                    ComboBox_SetCurSel(hwnd, newItem);
                    SetMIDIDeviceOut(pai, device, hDlg);
                }
            }
        }
    }
}



STATIC void AudioDlgInit(HWND hDlg)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));

	if (!pai) return;

    //
    //  Register context-sensitive help messages from the Customize dialog.
    //
    guCustomizeContextMenu = RegisterWindowMessage( ACMHELPMSGCONTEXTMENU );
    guCustomizeContextHelp = RegisterWindowMessage( ACMHELPMSGCONTEXTHELP );

    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pai);

    GetPrefInfo(pai, hDlg);
    CheckDlgButton(hDlg, IDC_AUDIO_PREF, pai->fPrefOnly);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);
    MIDIInit(hDlg, pai);

    if (!(pai->cNumInDevs || pai->cNumOutDevs || pai->cNumMIDIOutDevs))
    {
        CheckDlgButton(hDlg, IDC_AUDIO_PREF, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_AUDIO_PREF), FALSE);
    }

}


const static DWORD aAudioHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,            IDH_COMM_GROUPBOX,
    IDI_SPEAKERICON,         IDH_COMM_GROUPBOX,
    IDC_ICON_6,              IDH_COMM_GROUPBOX,
    IDC_TEXT_4,              IDH_AUDIO_PLAY_PREFER_DEV,
    IDC_AUDIO_CB_PLAY,       IDH_AUDIO_PLAY_PREFER_DEV,
    IDC_LAUNCH_SNDVOL,       IDH_AUDIO_PLAY_VOL,
    IDC_PLAYBACK_ADVSETUP,   IDH_ADV_AUDIO_PLAY_PROP,

    IDC_GROUPBOX_2,          IDH_COMM_GROUPBOX,
    IDI_RECORDICON,          IDH_COMM_GROUPBOX,
    IDC_ICON_7,              IDH_COMM_GROUPBOX,
    IDC_TEXT_8,              IDH_AUDIO_REC_PREFER_DEV,
    IDC_AUDIO_CB_REC,        IDH_AUDIO_REC_PREFER_DEV,
    IDC_LAUNCH_RECVOL,       IDH_AUDIO_REC_VOL,
    IDC_RECORD_ADVSETUP,     IDH_ADV_AUDIO_REC_PROP,

    IDC_GROUPBOX_3,          IDH_COMM_GROUPBOX,
    IDI_MUSICICON,           IDH_COMM_GROUPBOX,
    IDC_ICON_8,              IDH_COMM_GROUPBOX,
    IDC_TEXT_9,              IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_MUSIC_CB_PLAY,       IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_LAUNCH_MUSICVOL,     IDH_AUDIO_MIDI_VOL,
    IDC_MUSIC_ABOUT,         IDH_ABOUT,

    IDC_AUDIO_PREF,          IDH_AUDIO_USE_PREF_ONLY,

    0, 0
};

const static DWORD aCustomizeHelpIds[] = {
    IDD_ACMFORMATCHOOSE_CMB_FORMAT,     IDH_AUDIO_CUST_ATTRIB,
    IDD_ACMFORMATCHOOSE_CMB_FORMATTAG,  IDH_AUDIO_CUST_FORMAT,
    IDD_ACMFORMATCHOOSE_CMB_CUSTOM,     IDH_AUDIO_CUST_NAME,
    IDD_ACMFORMATCHOOSE_BTN_DELNAME,    IDH_AUDIO_CUST_REMOVE,
    IDD_ACMFORMATCHOOSE_BTN_SETNAME,    IDH_AUDIO_CUST_SAVEAS,

    0, 0
};



void WinMMDeviceChange(HWND hDlg)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

//    MSACM_NotifyMapper();

    GetPrefInfo(pai, hDlg);
    CheckDlgButton(hDlg, IDC_AUDIO_PREF, pai->fPrefOnly);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);
    MIDIInit(hDlg, pai);

    if (!(pai->cNumInDevs || pai->cNumOutDevs || pai->cNumMIDIOutDevs))
    {
        CheckDlgButton(hDlg, IDC_AUDIO_PREF, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_AUDIO_PREF), FALSE);
    }
}



LRESULT CALLBACK AudioTabProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == giDevChange)
    {
        WinMMDeviceChange(ghDlg);
    }

    return CallWindowProc(gfnPSProc,hwnd,iMsg,wParam,lParam);
}


void InitDeviceChange(HWND hDlg)
{
    gfnPSProc = (WNDPROC) SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LONG_PTR)AudioTabProc);
    giDevChange = RegisterWindowMessage(TEXT("winmm_devicechange"));
}

void UninitDeviceChange(HWND hDlg)
{
    SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LONG_PTR)gfnPSProc);
}




BOOL CALLBACK AudioDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    PAUDIODLGINFO pai;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            ghDlg = hDlg;

            InitDeviceChange(hDlg);

            if (!gfLoadedACM)
            {
                if (LoadACM())
                {
                    gfLoadedACM = TRUE;
                }
                else
                {
                    DPF("****Load ACM failed**\r\n");
                    ASSERT(FALSE);
                    ErrorBox(hDlg, IDS_CANTLOADACM, NULL);
                    ExitThread(0);
                }
            }

            AudioDlgInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            UninitDeviceChange(hDlg);

            pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

            LocalFree((HLOCAL)pai);

            if (gfLoadedACM)
            {
                if (!FreeACM())
                {
                    DPF("****Free ACM failed**\r\n");
                    ASSERT(FALSE);
                }

                gfLoadedACM = FALSE;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR) (LPTSTR) aAudioHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR) (LPTSTR) aAudioHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoAudioCommand);
        }
        break;

        default:
        {
            //
            //  Handle context-sensitive help messages from Customize dlg.
            //
            if( uMsg == guCustomizeContextMenu )
            {
                WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aCustomizeHelpIds );
            }
            else if( uMsg == guCustomizeContextHelp )
            {
                WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aCustomizeHelpIds);
            }
        }
        break;
    }
    return FALSE;
}

void ErrorMsgBox(HWND hDlg, UINT uTitle, UINT uMessage)
{
    TCHAR szMsg[MAXSTR];
    TCHAR szTitle[MAXSTR];

    LoadString(ghInstance, IDS_ERROR_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_ERROR_NOSNDVOL, szMsg, sizeof(szMsg)/sizeof(TCHAR));
    MessageBox(hDlg, szMsg,szTitle,MB_OK);
}


void LaunchPlaybackVolume(HWND hDlg)
{
    HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}


void LaunchRecordVolume(HWND hDlg)
{
    HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEIN);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -R -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

void LaunchMIDIVolume(HWND hDlg)
{
    HWND    hwndCBMIDI  = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBMIDI);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        DWORD dwDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        dwDeviceID = (UINT)ComboBox_GetItemData(hwndCBMIDI, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(dwDeviceID), &dwDeviceID, MIXER_OBJECTF_MIDIOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),dwDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

BOOL PASCAL DoAudioCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!gfLoadedACM)
    {
        return FALSE;
    }

    switch (id)
    {
        case ID_APPLY:
        {
            SetPrefInfo(pai, hDlg);
        }
        break;

        case IDC_AUDIO_CB_PLAY:
        case IDC_AUDIO_CB_REC:
        case IDC_MUSIC_CB_PLAY:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);

                    if ((id ==  IDC_AUDIO_CB_PLAY) || (id ==  IDC_AUDIO_CB_REC) || id == IDC_MUSIC_CB_PLAY)
                    {
                        int iIndex;
                        AUDIODLGINFO aiTmp;
                        PAUDIODLGINFO paiTmp = &aiTmp;

                        iIndex = ComboBox_GetCurSel(hwndCtl);

                        if (iIndex != CB_ERR)
                        {
                            if (id == IDC_AUDIO_CB_PLAY)
                            {
                                paiTmp->uPrefOut = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetDeviceOut(paiTmp, paiTmp->uPrefOut, hDlg);
                            }
                            else if (id == IDC_AUDIO_CB_REC)
                            {
                                paiTmp->uPrefIn = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetDeviceIn(paiTmp, paiTmp->uPrefIn, hDlg);
                            }
                            else if (id == IDC_MUSIC_CB_PLAY)
                            {
                                paiTmp->uPrefMIDIOut = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetMIDIDeviceOut(paiTmp, paiTmp->uPrefMIDIOut, hDlg);
                            }
                        }
                    }
                }
                break;
            }
        }
        break;


        case IDC_AUDIO_PREF:
        {
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case IDC_MUSIC_ABOUT:
        {
            DoRolandAbout(hDlg);
        }
        break;

        case IDC_LAUNCH_SNDVOL:
        {
            LaunchPlaybackVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_RECVOL:
        {
            LaunchRecordVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_MUSICVOL:
        {
            LaunchMIDIVolume(hDlg);
        }
        break;

        case IDC_PLAYBACK_ADVSETUP:
        {
            HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefOut[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndCBPlay);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndCBPlay, u, (LPARAM)(LPVOID)szPrefOut);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndCBPlay, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefOut, FALSE);
            }
        }
        break;

        case IDC_RECORD_ADVSETUP:
        {
            HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefIn[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndCBRec);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndCBRec, u, (LPARAM)(LPVOID)szPrefIn);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndCBRec, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefIn, TRUE);
            }
        }
        break;
    }

    return FALSE;
}



BOOL PASCAL CustomizeDialog(HWND hDlg, LPTSTR szNewFormat, DWORD cbSize)
{
    BOOL                fRet = FALSE;  // assume the worse
    ACMFORMATCHOOSE     cwf;
    LRESULT             lr;
    DWORD               dwMaxFormatSize;
    PWAVEFORMATEX       spWaveFormat;
    TCHAR               szCustomize[64];

    lr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT,(LPVOID)&dwMaxFormatSize);

    if (lr != 0)
    {
        goto CustomizeOut;
    }

    /* This LocalAlloc is freed in WAVE.C: DestroyWave() */
    spWaveFormat = (PWAVEFORMATEX)LocalAlloc(LPTR, (UINT)dwMaxFormatSize);

    _fmemset(&cwf, 0, sizeof(cwf));

     LoadString(ghInstance, IDS_CUSTOMIZE, szCustomize, sizeof(szCustomize)/sizeof(TCHAR));
    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hDlg;
    cwf.fdwStyle    = ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;
    cwf.fdwEnum     = ACM_FORMATENUMF_INPUT;
    cwf.pszTitle    = (LPTSTR)szCustomize;
    cwf.pwfx        = (LPWAVEFORMATEX)spWaveFormat;
    cwf.cbwfx       = dwMaxFormatSize;

    cwf.pszName =     szNewFormat;
    cwf.cchName = cbSize;

    lr = acmFormatChooseW(&cwf);
    if (lr == MMSYSERR_NOERROR)
    {
        fRet = TRUE;
    }
#ifdef DEBUG
    else
    {
        TCHAR a[200];
        wsprintf(a,TEXT("MSACMCPL: acmFormatChoose failed (lr=%u).\n"),lr);
        OutputDebugString(a);
    }
#endif

CustomizeOut:
    return fRet;                // return our result
} /* NewSndDialog() */


///////////////////////////////////////////////////////////////////////////////

void acmFreeCodecInfo (PCPLCODECINFO pcci)
{
    if (pcci->fMadeIcon && pcci->hIcon)
    {
        DestroyIcon (pcci->hIcon);
        pcci->hIcon = NULL;
        pcci->fMadeIcon = FALSE;
    }

   LocalFree ((HANDLE)pcci);
}


typedef struct // FindCodecData
    {
    BOOL              fFound;
    ACMDRIVERDETAILSW add;
    WORD              wMid, wPid;
    HACMDRIVERID      hadid;
    DWORD             fdwSupport;
    } FindCodecData;

PCPLCODECINFO acmFindCodecInfo (WORD wMidMatch, WORD wPidMatch)
{
    MMRESULT      mmr;
    FindCodecData fcd;
    PCPLCODECINFO pcci;

    fcd.fFound = FALSE;
    fcd.wMid = wMidMatch;
    fcd.wPid = wPidMatch;
//  fcd.add is filled in by acmFindCodecCallback during the following enum:

    mmr = (MMRESULT)acmDriverEnum (acmFindCodecInfoCallback,
             (DWORD_PTR)&fcd,   // (data passed as arg2 to callback)
             ACM_DRIVERENUMF_NOLOCAL |
             ACM_DRIVERENUMF_DISABLED);

    if (MMSYSERR_NOERROR != mmr)
    {
        return NULL;
    }

    if (!fcd.fFound)
    {
        return NULL;
    }

     // Congratulations--we found a matching ACM driver.  Now
     // we need to create a CPLCODECINFO structure to describe it,
     // so the rest of the code in this file will work without
     // mods.  <<sigh>>  A CPLCODECINFO structure doesn't have
     // anything special--it's just a place to track info about
     // an ACM driver.  The most important thing is the HACMDRIVERID.
     //
    if ((pcci = (PCPLCODECINFO)LocalAlloc(LPTR, sizeof(CPLCODECINFO))) == NULL)
    {
        return NULL;
    }

    lstrcpy (pcci->szDesc, fcd.add.szLongName);
    pcci->ads.hadid = fcd.hadid;
    pcci->ads.fdwSupport = fcd.fdwSupport;

    pcci->fMadeIcon = FALSE;

    if ((pcci->hIcon = fcd.add.hicon) == NULL)
    {
       int cxIcon, cyIcon;
       cxIcon = (int)GetSystemMetrics (SM_CXICON);
       cyIcon = (int)GetSystemMetrics (SM_CYICON);
       pcci->hIcon = LoadImage (myInstance,
                MAKEINTRESOURCE( IDI_ACM ),
                IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);
       pcci->fMadeIcon = TRUE;
    }

    acmMetrics ((HACMOBJ)pcci->ads.hadid,
        ACM_METRIC_DRIVER_PRIORITY,
        &(pcci->ads.dwPriority));

    return pcci;
}



BOOL CALLBACK acmFindCodecInfoCallback (HACMDRIVERID hadid,
                    DWORD_PTR dwUser,
                    DWORD fdwSupport)
{
    FindCodecData *pfcd;

        // dwUser is really a pointer to a FindCodecData
        // structure, supplied by the guy who called acmDriverEnum.
        //
    if ((pfcd = (FindCodecData *)dwUser) == NULL)
    {
        return FALSE;
    }

        // No details?  Try the next driver.
        //
    pfcd->add.cbStruct = sizeof(pfcd->add);
    if (acmDriverDetailsW (hadid, &pfcd->add, 0L) != MMSYSERR_NOERROR)
    {
        return TRUE;
    }

        // Great.  Now see if the driver we found matches
        // pfcd->wMid/wPad; if so we're done, else keep searching.
        //
    if ((pfcd->wMid == pfcd->add.wMid) && (pfcd->wPid == pfcd->add.wPid) )
    {
        pfcd->hadid = hadid;
        pfcd->fFound = TRUE;
        pfcd->fdwSupport = fdwSupport;
        return FALSE; // found it! leave pfcd->add intact and leave.
    }

    return TRUE; // not the right driver--keep looking
}


UINT acmCountCodecs (void)
{
    MMRESULT      mmr;
    UINT          nCodecs = 0;

    mmr = (MMRESULT)acmDriverEnum (acmCountCodecsEnum,
             (DWORD_PTR)&nCodecs,
             ACM_DRIVERENUMF_NOLOCAL |
             ACM_DRIVERENUMF_DISABLED);

    if (MMSYSERR_NOERROR != mmr)
    {
        return 0;
    }

    return nCodecs;
}



BOOL CALLBACK acmCountCodecsEnum (HACMDRIVERID hadid,
                  DWORD_PTR dwUser,
                  DWORD fdwSupport)
{
    UINT *pnCodecs;

        // dwUser is really a pointer to a UINT being used to
        // count the number of codecs we encounter.
        //
    if ((pnCodecs = (UINT *)dwUser) == NULL)
    {
        return FALSE;
    }

    ++ (*pnCodecs);

    return TRUE; // keep counting
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) TEXT(#num)
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ----")
    #define DEBUGLINE TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ")

    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") TEXT(#exp) TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

      #define STATICFN

    #else // defined(DEBUG)

      #define AuxDebugEx  1 ? (void)0 :
      #define AuxDebugDump(a,b,c)

      #define assert(a)          ((void)0)
      #define assert2(a,b)       ((void)0)
      #define assert3(a,b,c)     ((void)0)
      #define assert4(a,b,c,d)   ((void)0)
      #define assert5(a,b,c,d,e) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
      #define STATICFN static

   #endif // defined(DEBUG)

   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"))
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"), (a))

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE

    #include <stdarg.h>

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    mmdebug_OutputLevel = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/

    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
       TCHAR     szBuf[1024];
       int      cb;
       va_list  va;
       TCHAR   * psz;

       if (mmdebug_OutputLevel >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintf (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == TEXT('.') && psz[1] == TEXT('.') && psz[2] == TEXT('\\'))
             psz += 3;

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (psz);
          }

       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/

    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = NULL;
       TCHAR     szBuf[128];
       LPTSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];

       if (mmdebug_OutputLevel <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, TEXT("\t%08X: "), lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = TEXT('.');
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, TEXT(".. "));
             else
                {
                wsprintf (psz, TEXT("%02X "), lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, TEXT("\r\n"));

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/

    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {
        int nOldLevel = mmdebug_OutputLevel;
        mmdebug_OutputLevel = nLevel;
        return nOldLevel;
        }

    void FAR cdecl dprintf(LPSTR szFormat, ...)
    {
        TCHAR ach[MAXSTRINGLEN];
        TCHAR szUniFormat[MAXSTRINGLEN];
        
        int  s,d;
        va_list arg;

        MultiByteToWideChar(GetACP(), 0,
                        szFormat, -1,
                        szUniFormat, sizeof(szUniFormat)/sizeof(TCHAR));

        va_start (arg, szUniFormat);

        s = wvsprintf (ach,szUniFormat,arg);
        va_end(arg);

        for (d=sizeof(ach)-1; s>=0; s--)
        {
            if ((ach[d--] = ach[s]) == TEXT('\n'))
                ach[d--] = TEXT('\r');
        }

       va_end(arg);

        OutputDebugStr(TEXT("MMSYS.CPL: "));
        OutputDebugStr(ach+d+1);
    }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\mmse.c ===
//****************************************************************************
//
//  Module:     MMSE.DLL
//  File:       mmse.c
//  Content:    This file contains the moudle initialization.
//  History:
//      06/1994    -By-    Vij Rajarajan (VijR)
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#define INITGUID
#include "mmcpl.h"
#include <coguid.h>
#include <oleguid.h>
#include <shlguid.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <vfw.h>

#include <shlobj.h>
#undef INITGUID
#include <shlobjp.h>
//****************************************************************************
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//****************************************************************************

#include <commctrl.h>
#include <prsht.h>
#include "draw.h"
#include "utils.h"
#include "medhelp.h"

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef HWND (VFWAPIV * FN_MCIWNDCREATE)();

//---------------------------------------------------------------------------
// MMPSH class
//---------------------------------------------------------------------------

typedef struct _mmInfoList MMINFOLIST;
typedef MMINFOLIST * PMMINFOLIST;

typedef struct _mmInfoList
{
    TCHAR szInfoDesc[80];
    LPSTR pszInfo;
    FOURCC ckid;
    PMMINFOLIST  pNext;
};


// mmse class structure.  This is used for instances of
// IPersistFolder, IShellFolder, and IShellDetails.
typedef struct _mmpsh
    {
    // We use the pf also as our IUnknown interface
    IShellExtInit          sei;             // 1st base class
    IShellPropSheetExt  pse;             // 2nd base class
    LPDATAOBJECT        pdtobj;
    UINT                cRef;           // reference count
    LPTSTR    pszFileObj;
    UINT uLen;
    short iMediaType;
    PVOID    pAudioFormatInfo;
    PVOID    pVideoFormatInfo;
    HPALETTE    hPal;
    HBITMAP     hDispBMP;
    HICON        hIcon;
    PMMINFOLIST pInfoList;
    } mmpsh, * PMMPSH;

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
#define MIDICOPYRIGHTSTR    pAudioFormatInfo
#define MIDISEQNAMESTR      pVideoFormatInfo

#define MAXNUMSTREAMS   50

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
int       g_cRef          = 0;

SZCODE cszWavExt[]  = TEXT(".WAV");
SZCODE cszMIDIExt[] = TEXT(".MID");
SZCODE cszRMIExt[]  = TEXT(".RMI");
SZCODE cszAVIExt[]  = TEXT(".AVI");
SZCODE cszASFExt[]  = TEXT(".ASF");
SZCODE cszSlash[]   = TEXT("\\");

static SZCODE aszMIDIDev[] = TEXT("sequencer");

static TCHAR szDetailsTab[64];
static TCHAR szPreviewTab[64];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath);

/*
 ***************************************************************
 ***************************************************************
 */

DWORD mmpshGetFileSize(LPTSTR szFile)
{
    HANDLE hFile;
    OFSTRUCT of;
    DWORD dwSize = 0;

    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        dwSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
    }
    return dwSize;
}

STATIC void ReleaseInfoList(PMMPSH pmmpsh)
{
    PMMINFOLIST pCur;

    pCur = pmmpsh->pInfoList;
    while (pCur)
    {
        PMMINFOLIST pTmp;

        pTmp = pCur;
        pCur = pCur->pNext;
        LocalFree((HLOCAL)pTmp->pszInfo);
        LocalFree((HLOCAL)pTmp);
    }
    pmmpsh->pInfoList = NULL;
}


STATIC BOOL AddInfoToList(PMMPSH pmmpsh, LPSTR pInfo, FOURCC ckid)
{
    PMMINFOLIST pCur;
    int idStr;

    for (pCur = pmmpsh->pInfoList; pCur && pCur->pNext ; pCur = pCur->pNext)
        if (pCur->ckid == ckid)
            return TRUE;

    if (!pCur)
    {
        pCur = pmmpsh->pInfoList = (PMMINFOLIST)LocalAlloc(LPTR, sizeof(MMINFOLIST));
    }
    else
    {
        pCur->pNext = (PMMINFOLIST)LocalAlloc(LPTR, sizeof(MMINFOLIST));
        pCur = pCur->pNext;
    }
    if (!pCur)
        return FALSE;

    pCur->ckid = ckid;
    pCur->pszInfo = pInfo;

    switch (ckid)
    {
        case FOURCC_INAM:
            idStr = IDS_FOURCC_INAM;
            break;
        case FOURCC_ICOP:
            idStr = IDS_FOURCC_ICOP;
            break;
        case FOURCC_ICMT:
            idStr = IDS_FOURCC_ICMT;
            break;
        case FOURCC_ISBJ:
            idStr = IDS_FOURCC_ISBJ;
            break;
        case FOURCC_ICRD:
            idStr = IDS_FOURCC_ICRD;
            break;
        case FOURCC_IART:
            idStr = IDS_FOURCC_IART;
            break;
        case FOURCC_DISP:
            idStr = IDS_FOURCC_DISP;
            break;
        case FOURCC_ICMS:
            idStr = IDS_FOURCC_ICMS;
            break;
        case FOURCC_ICRP:
            idStr = IDS_FOURCC_ICRP;
            break;
        case FOURCC_IDIM:
            idStr = IDS_FOURCC_IDIM;
            break;
        case FOURCC_IDPI:
            idStr = IDS_FOURCC_IDPI;
            break;
        case FOURCC_IENG:
            idStr = IDS_FOURCC_IENG;
            break;
        case FOURCC_IGNR:
            idStr = IDS_FOURCC_IGNR;
            break;
        case FOURCC_IKEY:
            idStr = IDS_FOURCC_IKEY;
            break;
        case FOURCC_ILGT:
            idStr = IDS_FOURCC_ILGT;
            break;
        case FOURCC_IARL:
            idStr = IDS_FOURCC_IARL;
            break;
        case FOURCC_IMED:
            idStr = IDS_FOURCC_IMED;
            break;
        case FOURCC_IPLT:
            idStr = IDS_FOURCC_IPLT;
            break;
        case FOURCC_IPRD:
            idStr = IDS_FOURCC_IPRD;
            break;
        case FOURCC_ISFT:
            idStr = IDS_FOURCC_ISFT;
            break;
        case FOURCC_ISHP:
            idStr = IDS_FOURCC_ISHP;
            break;
        case FOURCC_ISRC:
            idStr = IDS_FOURCC_ISRC;
            break;
        case FOURCC_ISRF:
            idStr = IDS_FOURCC_ISRF;
            break;
        case FOURCC_ITCH:
            idStr = IDS_FOURCC_ITCH;
            break;
    }
    if (idStr)
        LoadString(ghInstance, idStr, pCur->szInfoDesc, sizeof(pCur->szInfoDesc)/sizeof(TCHAR));
    return TRUE;
}


typedef    struct tagWaveDesc
{
    DWORD    dSize;
    WORD    wFormatSize;
    NPWAVEFORMATEX    pwavefmt;
}    WAVEDESC,* PWAVEDESC;


STATIC BOOL PASCAL NEAR ReadWaveHeader(HMMIO hmmio,
    PWAVEDESC    pwd)
{
    MMCKINFO    mmckRIFF;
    MMCKINFO    mmck;
    MMRESULT    wError;

    mmckRIFF.fccType = mmioWAVE;
    if (wError = mmioDescend(hmmio, &mmckRIFF, NULL, MMIO_FINDRIFF))
    {
        return FALSE;
    }
    mmck.ckid = mmioFMT;
    if (wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))
    {
        return FALSE;
    }
    if (mmck.cksize < sizeof(WAVEFORMAT))
    {
        return FALSE;
    }
    pwd->wFormatSize = (WORD)mmck.cksize;
    pwd->pwavefmt = (NPWAVEFORMATEX)LocalAlloc(LPTR, pwd->wFormatSize);
    if (!pwd->pwavefmt)
    {
        return FALSE;
    }
    if ((DWORD)mmioRead(hmmio, (HPSTR)pwd->pwavefmt, mmck.cksize) != mmck.cksize)
    {
        goto RetErr;
    }
    if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
    {
        if (pwd->wFormatSize < sizeof(PCMWAVEFORMAT))
        {
            goto RetErr;
        }
    }
    else if ((pwd->wFormatSize < sizeof(WAVEFORMATEX)) || (pwd->wFormatSize < sizeof(WAVEFORMATEX) + pwd->pwavefmt->cbSize))
    {
        goto RetErr;
    }
    if (wError = mmioAscend(hmmio, &mmck, 0))
    {
        goto RetErr;
    }
    mmck.ckid = mmioDATA;
    if (wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))
    {
        goto RetErr;
    }
    pwd->dSize = mmck.cksize;
    return TRUE;
RetErr:
    LocalFree((HLOCAL)pwd->pwavefmt);
    pwd->pwavefmt = NULL;
    return FALSE;
}



STATIC void GetWaveInfo(HMMIO hmmio, PMMPSH pmmpsh)
{
    WAVEDESC wd;

    if (!ReadWaveHeader(hmmio, &wd))
        return;

    pmmpsh->uLen = (UINT)MulDiv(wd.dSize, 1000, wd.pwavefmt->nAvgBytesPerSec);
    pmmpsh->pAudioFormatInfo = (PVOID)wd.pwavefmt;
}

STATIC void GetMCIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    TCHAR    szMIDIInfo[MAXSTR];
    MCI_OPEN_PARMS      mciOpen;    /* Structure for MCI_OPEN command */
    DWORD dwFlags;
    DWORD dw;
    UINT wDevID;
    MCI_STATUS_PARMS        mciStatus;
    MCI_SET_PARMS           mciSet;        /* Structure for MCI_SET command */
    MCI_INFO_PARMS          mciInfo;
        /* Open a file with an explicitly specified device */

    memset(&mciOpen, 0x00, sizeof(mciOpen));

    mciOpen.lpstrDeviceType = aszMIDIDev;
    mciOpen.lpstrElementName = pszFile;
    dwFlags = MCI_WAIT | MCI_OPEN_ELEMENT | MCI_OPEN_TYPE;
    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, dwFlags,(DWORD_PTR)(LPVOID)&mciOpen);
    if (dw)
        return;
    wDevID = mciOpen.wDeviceID;

    mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

    dw = mciSendCommand(wDevID, MCI_SET, MCI_SET_TIME_FORMAT,
        (DWORD_PTR) (LPVOID) &mciSet);
    if (dw)
    {
        mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD_PTR)0);
        return;
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dw = mciSendCommand(wDevID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR) (LPTSTR) &mciStatus);
    if (dw)
        pmmpsh->uLen = 0;
    else
        pmmpsh->uLen = (UINT)mciStatus.dwReturn;

    mciInfo.dwCallback  = 0;
    mciInfo.lpstrReturn = szMIDIInfo;
    mciInfo.dwRetSize   = sizeof(szMIDIInfo);

    szMIDIInfo[0] = TEXT('\0');

    dw = mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_COPYRIGHT, (DWORD_PTR)(LPVOID)&mciInfo);

    if (dw == 0 && lstrlen(szMIDIInfo))
    {
        pmmpsh->MIDICOPYRIGHTSTR = LocalAlloc(LPTR, lstrlen(szMIDIInfo) + 1);
        if (pmmpsh->MIDICOPYRIGHTSTR)
        {
            lstrcpy((LPTSTR)pmmpsh->MIDICOPYRIGHTSTR, szMIDIInfo);
        }
    }

    mciInfo.lpstrReturn = szMIDIInfo;
    mciInfo.dwRetSize   = sizeof(szMIDIInfo);

    szMIDIInfo[0] = TEXT('\0');

    dw = mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_NAME, (DWORD_PTR)(LPVOID)&mciInfo);

    if (dw == 0 && lstrlen(szMIDIInfo))
    {
        pmmpsh->MIDISEQNAMESTR = LocalAlloc(LPTR, lstrlen(szMIDIInfo) + 1);
        if (pmmpsh->MIDISEQNAMESTR)
        {
            lstrcpy((LPTSTR)pmmpsh->MIDISEQNAMESTR, szMIDIInfo);
        }
    }

    mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD)0);

}

STATIC void GetMIDIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    GetMCIInfo(pszFile, pmmpsh);
}

STATIC void ReadAviStreams(LPTSTR pszFile, PMMPSH pmmpsh)
{
    HRESULT     hr;
    PAVIFILE    pfile;
    int         i;
    PAVISTREAM  pavi;
    PAVISTREAM  apavi[MAXNUMSTREAMS];    // the current streams
    AVISTREAMINFO  avis;
    LONG        timeStart;            // cached start, end, length
    LONG        timeEnd;
    int         cpavi;
    TCHAR szDecSep[10];
    TCHAR szListSep[10];

    hr = (HRESULT)AVIFileOpen(&pfile, pszFile, 0, 0L);

    if (FAILED(hr))
    {
        DPF("Unable to open %s", pszFile);
        return;
    }

    for (i = 0; i <= MAXNUMSTREAMS; i++)
    {
        if (AVIFileGetStream(pfile, &pavi, 0L, i) != AVIERR_OK)
            break;
        if (i == MAXNUMSTREAMS)
        {
            AVIStreamRelease(pavi);
            DPF("Exceeded maximum number of streams");
            break;
        }
        apavi[i] = pavi;
    }

    //
    // Couldn't get any streams out of this file
    //
    if (i == 0)
    {
        DPF("Unable to open any streams in %s", pszFile);
        if (pfile)
            AVIFileRelease(pfile);
        return;
    }

    cpavi = i;

    //
    // Start with bogus times
    //
    timeStart = 0x7FFFFFFF;
    timeEnd   = 0;

    //bug 141733, get the local decimal and list separators
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(TCHAR) );
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SLIST, szListSep, sizeof(szListSep)/sizeof(TCHAR) );

    //
    // Walk through and init all streams loaded
    //
    for (i = 0; i < cpavi; i++)
    {

        AVIStreamInfo(apavi[i], &avis, sizeof(avis));

        switch(avis.fccType)
        {
            case streamtypeVIDEO:
            {
                LONG cbFormat;
                LPVOID lpFormat;
                ICINFO icInfo;
                HIC hic;
                DWORD dwTimeLen;
                DWORD dwSize;
                int iFrameRate;
                TCHAR szFormat[MAXSTR];

                if (pmmpsh->pVideoFormatInfo)
                    break;

                AVIStreamFormatSize(apavi[i], 0, &cbFormat);
                pmmpsh->pVideoFormatInfo = (PVOID)LocalAlloc(LPTR, MAX_PATH);
                if (!pmmpsh->pVideoFormatInfo)
                    break;
                dwSize = mmpshGetFileSize(pszFile);
                dwTimeLen =  (DWORD)(AVIStreamEndTime(apavi[i]) - AVIStreamStartTime(apavi[i]));
                iFrameRate = MulDiv(avis.dwLength, 1000000, dwTimeLen);
                lpFormat = (LPVOID)LocalAlloc(LPTR, cbFormat);
                if (!lpFormat)
                {
                    goto BadFormat;
                }
                AVIStreamReadFormat(apavi[i], 0, lpFormat, &cbFormat);
                hic = (HIC)ICLocate(FOURCC_VIDC, avis.fccHandler, lpFormat, NULL, (WORD)ICMODE_DECOMPRESS);
                if (hic || ((LPBITMAPINFOHEADER)lpFormat)->biCompression == 0)
                {
                    TCHAR szName[48];

                    if (((LPBITMAPINFOHEADER)lpFormat)->biCompression)
                    {
                        ICGetInfo(hic, &icInfo, sizeof(ICINFO));
                        ICClose(hic);
                        //WideCharToMultiByte(CP_ACP, 0, icInfo.szName, -1, szName, sizeof(szName), NULL, NULL);
                        wcscpy(szName,icInfo.szName);
                    }
                    else
                    {
                        LoadString(ghInstance, IDS_UNCOMPRESSED, szName, sizeof(szName)/sizeof(TCHAR));
                    }
                    LoadString(ghInstance, IDS_GOODFORMAT, szFormat, sizeof(szFormat)/sizeof(TCHAR));

                    wsprintf((LPTSTR)pmmpsh->pVideoFormatInfo, szFormat, (avis.rcFrame.right - avis.rcFrame.left),
                                (avis.rcFrame.bottom - avis.rcFrame.top), szListSep, ((LPBITMAPINFOHEADER)lpFormat)->biBitCount, szListSep,
                                avis.dwLength, szListSep, (UINT)(iFrameRate/1000), szDecSep, (UINT)(iFrameRate%1000), szListSep, MulDiv(dwSize, 1000,dwTimeLen)/1024, szListSep, szName);

                    goto GoodFormat;

                }
BadFormat:
                LoadString(ghInstance, IDS_BADFORMAT, szFormat, sizeof(szFormat)/sizeof(TCHAR));
                wsprintf((LPTSTR)pmmpsh->pVideoFormatInfo, szFormat, (avis.rcFrame.right - avis.rcFrame.left),
                                (avis.rcFrame.bottom - avis.rcFrame.top), szListSep,
                                avis.dwLength, szListSep, (UINT)(iFrameRate/1000), szDecSep, (UINT)(iFrameRate%1000), szListSep, MulDiv(dwSize, 1000,dwTimeLen)/1024, szListSep);
GoodFormat:
                LocalFree((HLOCAL)lpFormat);
                break;
            }
            case streamtypeAUDIO:
            {
                LONG        cbFormat;

                AVIStreamFormatSize(apavi[i], 0, &cbFormat);
                pmmpsh->pAudioFormatInfo = (LPVOID)LocalAlloc(LPTR, cbFormat);
                if (!pmmpsh->pAudioFormatInfo)
                    break;
                AVIStreamReadFormat(apavi[i], 0, pmmpsh->pAudioFormatInfo, &cbFormat);
                break;
            }
            default:
                break;
        }

    //
    // We're finding the earliest and latest start and end points for
    // our scrollbar.
    //
        timeStart = (LONG)min(timeStart, AVIStreamStartTime(apavi[i]));
        timeEnd   = (LONG)max(timeEnd, AVIStreamEndTime(apavi[i]));
    }
    pmmpsh->uLen = (UINT)(timeEnd - timeStart);
    DPF("The file length is %d \r\n", pmmpsh->uLen);

    for (i = 0; i < cpavi; i++)
    {
        AVIStreamRelease(apavi[i]);
    }
    AVIFileRelease(pfile);
}


STATIC void GetAVIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    if (!LoadAVI())
    {
        DPF("****Load AVI failed**\r\n");
        ASSERT(FALSE);
        return;
    }
    if (!LoadVFW())
    {
        DPF("****Load VFW failed**\r\n");
        ASSERT(FALSE);
        FreeAVI();
        return;
    }
    AVIFileInit();
    ReadAviStreams(pszFile, pmmpsh);
    AVIFileExit();
    if (!FreeVFW())
    {
        DPF("****Free VFW failed**\r\n");
        ASSERT(FALSE);
    }
    if (!FreeAVI())
    {
        DPF("****Free AVI failed**\r\n");
        ASSERT(FALSE);
    }
}

STATIC void GetASFInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
}




STATIC void GetMediaInfo(HMMIO hmmio, PMMPSH pmmpsh)
{
    switch (pmmpsh->iMediaType)
    {
        case MT_WAVE:
            GetWaveInfo(hmmio, pmmpsh);
            break;
        case MT_MIDI:
            GetMIDIInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
        case MT_AVI:
            GetAVIInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
        case MT_ASF:
            GetASFInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
    }
}

STATIC HANDLE PASCAL GetRiffAll(PMMPSH pmmpsh)
{
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE    h = NULL;
    LONG        lSize;
    DWORD       dw;
    HMMIO   hmmio;
    BOOL     fDoneDISP;
    BOOL     fDoneINFO;
    BOOL    fDoneName;
    LPSTR pInfo;

    hmmio = mmioOpen(pmmpsh->pszFileObj, NULL, MMIO_ALLOCBUF | MMIO_READ);

    if (!hmmio)
        goto error;

    GetMediaInfo(hmmio, pmmpsh);
    if (pmmpsh->uLen == 0)
        goto error;
    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    fDoneDISP = fDoneINFO = fDoneName = FALSE;
    while (!(fDoneDISP && fDoneINFO) && !mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != (LONG)sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);
            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and
                    lock it down */

                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;

                fDoneDISP = TRUE;
            }
            else if ((int)dw == CF_TEXT)
            {
                pInfo = (LPSTR)LocalAlloc(LPTR, lSize+1);//+1 not required I think
                if (!pInfo)
                    goto error;

                if (!mmioRead(hmmio, pInfo,  lSize))
                    goto error;

                AddInfoToList(pmmpsh, pInfo, ck.ckid );
                fDoneName = TRUE;

            }

        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 !fDoneINFO)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_ISBJ:
                    case FOURCC_INAM:
                    case FOURCC_ICOP:
                    case FOURCC_ICRD:
                    case FOURCC_IART:
                    case FOURCC_ICMS:
                    case FOURCC_ICMT:
                    case FOURCC_ICRP:
                    case FOURCC_IDIM:
                    case FOURCC_IARL:
                    case FOURCC_IDPI:
                    case FOURCC_IENG:
                    case FOURCC_IGNR:
                    case FOURCC_IKEY:
                    case FOURCC_ILGT:
                    case FOURCC_IMED:
                    case FOURCC_IPLT:
                    case FOURCC_IPRD:
                    case FOURCC_ISFT:
                    case FOURCC_ISHP:
                    case FOURCC_ISRC:
                    case FOURCC_ISRF:
                    case FOURCC_ITCH:
                        pInfo = (LPSTR)LocalAlloc(LPTR, ck.cksize+1);//+1 not required I think
                        if (!pInfo)
                            goto error;

                        if (!mmioRead(hmmio, pInfo,  ck.cksize))
                            goto error;

                        AddInfoToList(pmmpsh, pInfo, ckINFO.ckid);
                        if (ckINFO.ckid == FOURCC_INAM)
                            fDoneName = TRUE;
                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }


        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
    {
        GlobalUnlock(h);
        GlobalFree(h);
    }
    h = NULL;
    ReleaseInfoList(pmmpsh);

exit:
    if (hmmio)
        mmioClose(hmmio,0);
    return h;
}

STATIC BOOL PASCAL WaveGetFormatDescription
(
    LPWAVEFORMATEX          pwfx,
    LPTSTR                   pszDesc
)
{
    UINT_PTR             mmr;
    TCHAR                pszFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR                pszFormat[ACMFORMATDETAILS_FORMAT_CHARS];
    BOOL                bRet = FALSE;
    TCHAR                szListSep[10];
    //
    //  get the name for the format tag of the specified format
    //

    if (!pwfx)
    {
        pszDesc[0] = TEXT('\0');
        return TRUE;
    }
    if (!LoadACM())
    {
        DPF("****Load ACM failed**\r\n");
        ASSERT(FALSE);
        return FALSE;
    }
    if (NULL != pszFormatTag)
    {
       PACMFORMATTAGDETAILSW paftd;

        //
        //  initialize all unused members of the ACMFORMATTAGDETAILS
        //  structure to zero
        //
        paftd = (PACMFORMATTAGDETAILSW)LocalAlloc(LPTR, sizeof(ACMFORMATTAGDETAILSW));
        if (!paftd)
            goto RetErr;
        //
        //  fill in the required members of the ACMFORMATTAGDETAILS
        //  structure for the ACM_FORMATTAGDETAILSF_FORMATTAG query
        //
        paftd->cbStruct    = sizeof(ACMFORMATTAGDETAILSW);
        paftd->dwFormatTag = pwfx->wFormatTag;

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format tag
        //
        mmr = acmFormatTagDetails(NULL,
                                  paftd,
                                  ACM_FORMATTAGDETAILSF_FORMATTAG);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format tag name into the caller's buffer
            //
            lstrcpy(pszFormatTag, paftd->szFormatTag);
        }
        else
        {
            static const struct _wfm_names {
                UINT   uFormatTag;
                UINT   uIDS;
                } aWaveFmtNames[] = {
                WAVE_FORMAT_PCM,                 IDS_FORMAT_PCM,
                WAVE_FORMAT_ADPCM,               IDS_FORMAT_ADPCM,
                WAVE_FORMAT_IBM_CVSD,            IDS_FORMAT_IBM_CVSD,
                WAVE_FORMAT_ALAW,                IDS_FORMAT_ALAW,
                WAVE_FORMAT_MULAW,               IDS_FORMAT_MULAW,
                WAVE_FORMAT_OKI_ADPCM,           IDS_FORMAT_OKI_ADPCM,
                WAVE_FORMAT_IMA_ADPCM,           IDS_FORMAT_IMA_ADPCM,
                WAVE_FORMAT_MEDIASPACE_ADPCM,    IDS_FORMAT_MEDIASPACE_ADPCM,
                WAVE_FORMAT_SIERRA_ADPCM,        IDS_FORMAT_SIERRA_ADPCM,
                WAVE_FORMAT_G723_ADPCM,          IDS_FORMAT_G723_ADPCM,
                WAVE_FORMAT_DIGISTD,             IDS_FORMAT_DIGISTD,
                WAVE_FORMAT_DIGIFIX,             IDS_FORMAT_DIGIFIX,
                WAVE_FORMAT_YAMAHA_ADPCM,        IDS_FORMAT_YAMAHA_ADPCM,
                WAVE_FORMAT_SONARC,              IDS_FORMAT_SONARC,
                WAVE_FORMAT_DSPGROUP_TRUESPEECH, IDS_FORMAT_DSPGROUP_TRUESPEECH,
                WAVE_FORMAT_ECHOSC1,             IDS_FORMAT_ECHOSC1,
                WAVE_FORMAT_AUDIOFILE_AF36,      IDS_FORMAT_AUDIOFILE_AF36,
                WAVE_FORMAT_APTX,                IDS_FORMAT_APTX,
                WAVE_FORMAT_AUDIOFILE_AF10,      IDS_FORMAT_AUDIOFILE_AF10,
                WAVE_FORMAT_DOLBY_AC2,           IDS_FORMAT_DOLBY_AC2,
                WAVE_FORMAT_GSM610,              IDS_FORMAT_GSM610,
                WAVE_FORMAT_G721_ADPCM,          IDS_FORMAT_G721_ADPCM,
                WAVE_FORMAT_CREATIVE_ADPCM,      IDS_FORMAT_CREATIVE_ADPCM,
                0,                               IDS_UNKFORMAT,
                };
                UINT ii;

            //
            // no ACM driver is available that supports the
            // specified format tag. look up the tag id
            // in our table of tag names (above)
            //
            for (ii = 0; aWaveFmtNames[ii].uFormatTag; ii++)
                if (pwfx->wFormatTag == aWaveFmtNames[ii].uFormatTag)
                    break;
            LoadString(ghInstance, aWaveFmtNames[ii].uIDS, pszFormatTag, ACMFORMATTAGDETAILS_FORMATTAG_CHARS);
        }
        LocalFree((HLOCAL)paftd);
    }

    //
    //  get the description of the attributes for the specified
    //  format
    //
    if (NULL != pszFormat)
    {
        PACMFORMATDETAILSW    pafd;

        //
        //  initialize all unused members of the ACMFORMATDETAILS
        //  structure to zero
        //
        pafd = (PACMFORMATDETAILSW)LocalAlloc(LPTR, sizeof(ACMFORMATDETAILSW));
        if (!pafd)
            goto RetErr;

        //
        //  fill in the required members of the ACMFORMATDETAILS
        //  structure for the ACM_FORMATDETAILSF_FORMAT query
        //
        pafd->cbStruct    = sizeof(ACMFORMATDETAILSW);
        pafd->dwFormatTag = pwfx->wFormatTag;
        pafd->pwfx        = pwfx;

        //
        //  the cbwfx member must be initialized to the total size
        //  in bytes needed for the specified format. for a PCM
        //  format, the cbSize member of the WAVEFORMATEX structure
        //  is not valid.
        //
        if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
        {
            pafd->cbwfx   = sizeof(PCMWAVEFORMAT);
        }
        else
        {
            pafd->cbwfx   = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        }

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format
        //
        mmr = acmFormatDetails(NULL, pafd, ACM_FORMATDETAILSF_FORMAT);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format attributes description into the caller's
            //  buffer
            //
            lstrcpy(pszFormat, pafd->szFormat);
        }
        else
        {
            pszFormat[0] = TEXT('\0');
        }
        LocalFree((HLOCAL)pafd);
    }
    //bug 141733, get the local decimal and list separators
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SLIST, szListSep, sizeof(szListSep)/sizeof(TCHAR) );
    wsprintf(pszDesc, TEXT("%s%s %s"), pszFormatTag, szListSep, pszFormat);
    bRet = TRUE;

RetErr:
    if (!FreeACM())
    {
        DPF("****Free ACM failed**\r\n");
        ASSERT(FALSE);
    }
    return bRet;
} // AcmAppGetFormatDescription()



STATIC void ShowInfoList(PMMPSH pmmpsh, HWND hDlg)
{
    PMMINFOLIST pCur;
    TCHAR* szTemp;
    HWND hwndLB = GetDlgItem(hDlg, IDD_INFO_NAME);
    TCHAR szNoCopyRight[MAXSTR];
    int iIndex;

    LoadString(ghInstance, IDS_NOCOPYRIGHT, szNoCopyRight, sizeof(szNoCopyRight)/sizeof(TCHAR));
    SetDlgItemText(hDlg, IDD_COPYRIGHT, szNoCopyRight);
    if (!pmmpsh->pInfoList)
    {
        DestroyWindow(GetDlgItem(hDlg, IDC_DETAILSINFO_GRP));
        DestroyWindow(GetDlgItem(hDlg, IDC_ITEMSLABEL));
        DestroyWindow(GetDlgItem(hDlg, IDC_DESCLABEL));
        DestroyWindow(GetDlgItem(hDlg, IDD_INFO_NAME));
        DestroyWindow(GetDlgItem(hDlg, IDD_INFO_VALUE));
        return;
    }
    for (pCur = pmmpsh->pInfoList; pCur; pCur = pCur->pNext)
    {
        int nTempSize = (strlen(pCur->pszInfo)*sizeof(TCHAR))+sizeof(TCHAR);
        szTemp = (LPTSTR)LocalAlloc(LPTR, nTempSize);
		if (!szTemp) return;

        MultiByteToWideChar(GetACP(), 0,
                            pCur->pszInfo, -1,
                            szTemp, nTempSize);

        if (pCur->ckid == FOURCC_ICOP)
        {
            SetDlgItemText(hDlg, IDD_COPYRIGHT, szTemp);
            LocalFree(szTemp);
            continue;
        }
        iIndex = ListBox_AddString(hwndLB, pCur->szInfoDesc);
        if (iIndex != LB_ERR)
        {
            //reassigning wide pointer back into "info" so it will get cleaned up later
            pCur->pszInfo = (LPSTR)szTemp;
            ListBox_SetItemData(hwndLB, iIndex, (LPARAM)pCur->pszInfo);
        }
    }
    SetFocus(hwndLB);
    if (ListBox_SetCurSel(hwndLB, 0) != LB_ERR)
        FORWARD_WM_COMMAND(hDlg, IDD_INFO_NAME, hwndLB, LBN_SELCHANGE, PostMessage);
}

BOOL PASCAL DoDetailsCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {

    case ID_APPLY:
        return TRUE;

    case IDOK:
        break;

    case IDCANCEL:
        break;

    case ID_INIT:
    {
        PMMPSH pmmpsh = (PMMPSH)GetWindowLongPtr(hDlg, DWLP_USER);


        if (pmmpsh->hDispBMP)
        {
            HWND hwndDisp = GetDlgItem(hDlg,IDD_DISPFRAME);
            HDC hdc;
            HPALETTE hpalT;
            int i;

            SendMessage(hwndDisp, (UINT)DF_PM_SETBITMAP, (WPARAM)pmmpsh->hDispBMP,
                                                                (LPARAM)pmmpsh->hPal);

            /*
            * If realizing the palette causes the palette to change,
            * redraw completely.
            */

            hdc = GetDC(hwndDisp);
            hpalT = SelectPalette (hdc, pmmpsh->hPal, FALSE);

            i = RealizePalette(hdc); /* i == entries that changed  */

            SelectPalette (hdc, hpalT, FALSE);
            ReleaseDC(hwndDisp, hdc);


            /* If any palette entries changed, repaint the window. */

            if (i > 0)
            {
                InvalidateRect(hwndDisp, NULL, TRUE);
            }
        }
        break;
    }

    case IDD_INFO_NAME:
        if (codeNotify == LBN_SELCHANGE)
        {
            int iIndex = ListBox_GetCurSel(hwndCtl);
            LPTSTR pszInfo = (LPTSTR)ListBox_GetItemData(hwndCtl, iIndex);

            SetDlgItemText(hDlg, IDD_INFO_VALUE, pszInfo);
        }
        break;
    }
    return FALSE;
}


STATIC void ShowMediaLen(PMMPSH pmmpsh, HWND hwnd)
{
    TCHAR szBuf[MAXSTR];
    TCHAR szFmt[MAXSTR];
    UINT uMin;
    UINT uSec;
    UINT umSec;
    UINT uLen;
    TCHAR szDecSep[10];

    uLen = pmmpsh->uLen;

    if ((!uLen && pmmpsh->iMediaType != MT_WAVE) || (!pmmpsh->pAudioFormatInfo && pmmpsh->iMediaType != MT_MIDI && pmmpsh->iMediaType != MT_AVI && pmmpsh->iMediaType != MT_ASF))
    {
        LoadString(ghInstance, IDS_BADFILE, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        SetWindowText(hwnd, szBuf);
        return;
    }
    uMin = (UINT)(uLen/60000);
    uSec = (UINT)((uLen/1000) % 60);
    umSec = (UINT)(uLen % 1000);

    //bug 141733, get the local decimal separator
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(TCHAR) );

    if (uMin)
    {

        LoadString(ghInstance, IDS_MINFMT, szFmt, sizeof(szFmt)/sizeof(TCHAR));
        wsprintf(szBuf, szFmt, uMin, uSec, szDecSep, umSec);
    }
    else
    {

        LoadString(ghInstance, IDS_SECFMT, szFmt, sizeof(szFmt)/sizeof(TCHAR));
        wsprintf(szBuf, szFmt, uSec, szDecSep, umSec);
    }
    SetWindowText(hwnd, szBuf);
}


STATIC void ShowMediaFormat(PMMPSH pmmpsh, HWND hDlg)
{
    switch (pmmpsh->iMediaType)
    {
        case MT_WAVE:
        {
            TCHAR szDesc[MAX_PATH];

            szDesc[0] = TEXT('\0');
            WaveGetFormatDescription((LPWAVEFORMATEX)pmmpsh->pAudioFormatInfo, szDesc);
            SetDlgItemText(hDlg, IDD_AUDIOFORMAT, szDesc);
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMATLABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));
            break;
        }
        case MT_MIDI:
            DestroyWindow(GetDlgItem(hDlg, IDD_AUDIOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_AUDIOFORMATLABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMATLABEL));
            if (pmmpsh->MIDICOPYRIGHTSTR)
                SetDlgItemText(hDlg, IDD_COPYRIGHT, (LPTSTR)pmmpsh->MIDICOPYRIGHTSTR);
            if (pmmpsh->MIDISEQNAMESTR)
                SetDlgItemText(hDlg, IDD_MIDISEQUENCENAME, (LPTSTR)pmmpsh->MIDISEQNAMESTR);
            else
            {
                DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
                DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));
            }
            break;
        case MT_AVI:
        {
            TCHAR szDesc[MAX_PATH];

            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));

            szDesc[0] = TEXT('\0');
            if (pmmpsh->pVideoFormatInfo)
                SetDlgItemText(hDlg, IDD_VIDEOFORMAT, (LPTSTR)pmmpsh->pVideoFormatInfo);
            else
                SetDlgItemText(hDlg, IDD_VIDEOFORMAT, (LPTSTR)szDesc);
            WaveGetFormatDescription((LPWAVEFORMATEX)pmmpsh->pAudioFormatInfo, szDesc);
            SetDlgItemText(hDlg, IDD_AUDIOFORMAT, szDesc);
            break;
        }
        case MT_ASF:
        {
            break;
        }
    }
}

const static DWORD aFileDetailsIds[] = {  // Context Help IDs
    IDD_DISPFRAME,          NO_HELP,
    IDD_DISP_ICON,          IDH_FPROP_GEN_ICON,
    IDD_FILENAME,           IDH_FPROP_GEN_NAME,
    IDD_CRLABEL,            IDH_FCAB_MM_COPYRIGHT,
    IDD_COPYRIGHT,          IDH_FCAB_MM_COPYRIGHT,
    IDD_LENLABEL,           IDH_FCAB_MM_FILELEN,
    IDD_FILELEN,            IDH_FCAB_MM_FILELEN,
    IDD_AUDIOFORMATLABEL,   IDH_FCAB_MM_AUDIOFORMAT,
    IDD_AUDIOFORMAT,        IDH_FCAB_MM_AUDIOFORMAT,
    IDD_MIDISEQUENCELABEL,  IDH_FCAB_MM_MIDISEQUENCENAME,
    IDD_MIDISEQUENCENAME,   IDH_FCAB_MM_MIDISEQUENCENAME,
    IDD_VIDEOFORMATLABEL,   IDH_FCAB_MM_VIDEOFORMAT,
    IDD_VIDEOFORMAT,        IDH_FCAB_MM_VIDEOFORMAT,
    IDC_DETAILSINFO_GRP,    IDH_FCAB_MM_DETAILSINFO,
    IDC_ITEMSLABEL,         IDH_FCAB_MM_DETAILSINFO,
    IDC_DESCLABEL,          IDH_FCAB_MM_DETAILSINFO,
    IDD_INFO_NAME,          IDH_FCAB_MM_DETAILSINFO,
    IDD_INFO_VALUE,         IDH_FCAB_MM_DETAILSINFO,

    0, 0
};

INT_PTR CALLBACK FileDetailsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                                            LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            PMMPSH pmmpsh = (PMMPSH)(((LPPROPSHEETPAGE)lParam)->lParam);
            TCHAR szFile[MAX_PATH];
            HANDLE hDib = NULL;
            HCURSOR hCursor;

            hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pmmpsh);

            if (!pmmpsh->pInfoList)
            {
                hDib = GetRiffAll(pmmpsh);
            }

			if (!hDib)
				break;

            pmmpsh->hPal = bmfCreateDIBPalette(hDib);
            pmmpsh->hDispBMP = bmfBitmapFromDIB(hDib, pmmpsh->hPal);
            if (hDib)
            {
                GlobalUnlock(hDib);
                hDib = GlobalFree(hDib);
            }
            if (!pmmpsh->hDispBMP)
            {
                int iIconID;

                switch (pmmpsh->iMediaType)
                {
                    case MT_WAVE:
                        iIconID = IDI_DWAVE;
                        break;
                    case MT_MIDI:
                        iIconID = IDI_DMIDI;
                        break;
                    case MT_AVI:
                    case MT_ASF:
                        iIconID = IDI_DVIDEO;
                        break;
                }
                DestroyWindow(GetDlgItem(hDlg,IDD_DISPFRAME));
                pmmpsh->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(iIconID));
                Static_SetIcon(GetDlgItem(hDlg, IDD_DISP_ICON), pmmpsh->hIcon);
            }
            else
            {
                DestroyWindow(GetDlgItem(hDlg,IDD_DISP_ICON));
                //SendDlgItemMessage(hDlg, (int)IDD_DISPFRAME, (UINT)DF_PM_SETBITMAP, (WPARAM)pmmpsh->hDispBMP,
                //                                                (LPARAM)pmmpsh->hPal);
            }

            lstrcpy(szFile, pmmpsh->pszFileObj);
            NiceName(szFile, TRUE);
            SetDlgItemText(hDlg, IDD_FILENAME, szFile);

            ShowMediaLen(pmmpsh, GetDlgItem(hDlg, IDD_FILELEN));
            ShowInfoList(pmmpsh, hDlg);
            ShowMediaFormat(pmmpsh, hDlg);
            SetCursor(hCursor);
            break;
        }

        case WM_DESTROY:
        {
            PMMPSH pmmpsh = (PMMPSH)GetWindowLongPtr(hDlg, DWLP_USER);

            if (pmmpsh->hDispBMP)
                DeleteObject(pmmpsh->hDispBMP);
            if (pmmpsh->hIcon)
                DestroyIcon(pmmpsh->hIcon);
            if (pmmpsh->hPal)
                DeleteObject(pmmpsh->hPal);
            if (pmmpsh->pAudioFormatInfo)
                LocalFree((HLOCAL)pmmpsh->pAudioFormatInfo);
            if (pmmpsh->pVideoFormatInfo)
                LocalFree((HLOCAL)pmmpsh->pVideoFormatInfo);
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aFileDetailsIds);
            return TRUE;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aFileDetailsIds);
            return TRUE;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoDetailsCommand);
            break;
    }
    return FALSE;
}


static DWORD aPreviewIds[] = {  // Context Help IDs
    0,                      IDH_FCAB_MM_PREVIEW_CONTROL,
    IDD_DISP_ICON,          IDH_FPROP_GEN_ICON,
    IDD_FILENAME,           IDH_FPROP_GEN_NAME,

    0, 0
};

INT_PTR CALLBACK PreviewDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                                            LPARAM lParam)
{
    static BOOL fLoadedVFW;
    static HICON hIcon;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR FAR   *lpnm;

            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                {
                    HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

                    DPF("***PSN_KILLACTIVE***\r\n");
                    if (IsWindow(hwndMCI))
                         MCIWndStop(hwndMCI);
                    break;
                }

                case PSN_APPLY:
                    DPF("***PSN_APPLY***\r\n");
                    return TRUE;

            }
            break;
        }

        case WM_INITDIALOG:
        {
            PMMPSH pmmpsh = (PMMPSH)(((LPPROPSHEETPAGE)lParam)->lParam);
            HCURSOR hCursor;
            HWND     hwndMCI;
            HWND    hwndTitle;
            RECT    rcWnd;
            RECT     rcDlg;
            TCHAR     szFile[MAX_PATH];
            TCHAR    szTitle[MAXSTR];
            TCHAR    szTmp[MAXSTR];
#ifndef DEBUG_BUILT_LINKED
            FN_MCIWNDCREATE fnMCIWndCreate;
#endif

            hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));
            lstrcpy(szFile, pmmpsh->pszFileObj);
            NiceName(szFile, TRUE);
            LoadString(ghInstance, IDS_PREVIEWOF, szTmp, sizeof(szTmp)/sizeof(TCHAR));
            wsprintf(szTitle, szTmp, szFile);
            hwndTitle = GetDlgItem(hDlg, IDD_FILENAME);
            SetWindowText(hwndTitle, szTitle);

            fLoadedVFW = FALSE;
            if (!LoadVFW())
            {
                DPF("****Load VFW failed**\r\n");
                ASSERT(FALSE);
                break;
            }
            fLoadedVFW = TRUE;
#ifndef DEBUG_BUILT_LINKED
            fnMCIWndCreate = (FN_MCIWNDCREATE)MCIWndCreateW;
            hwndMCI = fnMCIWndCreate(hDlg, ghInstance, (DWORD)MCIWNDF_NOMENU, (LPCTSTR)pmmpsh->pszFileObj);
#else
            hwndMCI = MCIWndCreateW(hDlg, ghInstance, (DWORD)MCIWNDF_NOMENU, (LPCTSTR)pmmpsh->pszFileObj);
#endif
            aPreviewIds[0] = GetDlgCtrlID(hwndMCI);
            GetWindowRect(hwndMCI, &rcWnd);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWnd, 2);
            GetWindowRect(hDlg, &rcDlg);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcDlg, 2);
            hIcon = NULL;
            switch (pmmpsh->iMediaType)
            {
                case MT_WAVE:
                case MT_MIDI:
                {
                    int ircWndTop;

                    ircWndTop = (int)((rcDlg.bottom - rcDlg.top)/2) - 50;
                    rcWnd.top +=  ircWndTop;
                    rcWnd.bottom += ircWndTop;
                    rcWnd.left = 20;
                    rcWnd.right = rcDlg.right - 20;

                    MoveWindow(hwndMCI,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    GetWindowRect(hwndTitle, &rcWnd);
                    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWnd, 2);
                    OffsetRect(&rcWnd, 52, 36);
                    MoveWindow(hwndTitle,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_DWAVE+pmmpsh->iMediaType-1));
                    Static_SetIcon(GetDlgItem(hDlg, IDD_DISP_ICON),hIcon);

                    break;
                }
                case MT_AVI:
                {
                     int iDlgHt = rcDlg.bottom - rcDlg.top -15;     //15 for the title
                    int iDlgWth = rcDlg.right - rcDlg.left;
                    int iWndHt = rcWnd.bottom - rcWnd.top;
                    int iWndWth = rcWnd.right - rcWnd.left;

                    DestroyWindow(GetDlgItem(hDlg, IDD_DISP_ICON));
                    if (iWndWth < iDlgWth && iWndHt < iDlgHt)
                    {
                        int ixOff = (int)((iDlgWth - iWndWth)/2);
                        int iyOff = (int)((iDlgHt - iWndHt)/2) + 15;

                        OffsetRect(&rcWnd, ixOff, iyOff);
                        MoveWindow(hwndMCI,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    }
                    else
                    {
                        int ixExcess = iWndWth - iDlgWth;
                        int iyExcess = iWndHt - (iDlgHt - 15); //Take another 15 off
                        int ixOff;
                        int iyOff;
                        RECT     rcSource;
                        RECT    rcDest;
                        RECT    rcDestWnd;

                        MCIWndGetDest(hwndMCI, &rcSource);
                        //DPF("The Video Window is too big: SHRINKING\r\nrcSource = %d,%d,%d%d ** rcWnd=%d,%d,%d,%d ** rcDlg=%d,%d,%d,%d\r\n",
                        //    rcSource.left,rcSource.top,rcSource.right,rcSource.bottom,
                        //    rcWnd.left,rcWnd.top,rcWnd.right,rcWnd.bottom,
                        //    rcDlg.left,rcDlg.top,rcDlg.right,rcDlg.bottom);
                        rcDest.top = rcSource.top;          // new boundaries
                        rcDest.left = rcSource.left;
                        if (ixExcess > iyExcess)
                        {
                            rcDest.right = rcSource.left +
                                (((rcSource.right - rcSource.left)*(iDlgWth - 20))/iWndWth);
                            rcDest.bottom = rcSource.top +
                                (((rcSource.bottom - rcSource.top)*(iDlgWth - 20))/iWndWth);
                            //DPF("rcDest =  %d,%d,%d,%d\r\n",rcDest.left,rcDest.top,rcDest.right,rcDest.bottom);
                        }
                        else
                        {
                            rcDest.right = rcSource.left +
                                (((rcSource.right - rcSource.left)*(iDlgHt - 20))/iWndHt);
                            rcDest.bottom = rcSource.top +
                                (((rcSource.bottom - rcSource.top)*(iDlgHt - 20))/iWndHt);
                        }
                        rcDestWnd.top = rcWnd.top;
                        rcDestWnd.left = rcWnd.left;
                        rcDestWnd.right = rcWnd.left + (rcDest.right - rcDest.left);
                        rcDestWnd.bottom = rcWnd.top + (rcDest.bottom - rcDest.top)
                                            + (iWndHt - (rcSource.bottom - rcSource.top));
                        //DPF("rcDestWnd =  %d,%d,%d,%d\r\n",rcDestWnd.left,rcDestWnd.top,rcDestWnd.right,rcDestWnd.bottom);

                        ixOff = (int)((iDlgWth - (rcDestWnd.right - rcDestWnd.left))/2);
                        iyOff = (int)((iDlgHt - (rcDestWnd.bottom - rcDestWnd.top))/2) + 15;
                        //DPF("ixOff = %, iyOff = %d\r\n", ixOff, iyOff);
                        OffsetRect(&rcDestWnd, ixOff, iyOff);
                        MCIWndPutDest(hwndMCI, &rcDest);
                        MoveWindow(hwndMCI,  rcDestWnd.left, rcDestWnd.top, (rcDestWnd.right - rcDestWnd.left),
                                        (rcDestWnd.bottom - rcDestWnd.top), FALSE);

                    }
                    break;

                case MT_ASF: 
                    break;
                }
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)hwndMCI);
            SetCursor(hCursor);
            break;
        }

        case WM_CLOSE:
            DPF("***WM_CLOSE***\r\n");
            break;


        case WM_DESTROY:
        {
            HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

            DPF("***WM_DESTROY***\r\n");
            if (hIcon)
            {
                DestroyIcon(hIcon);
                hIcon = NULL;
            }
            if (IsWindow(hwndMCI))
                MCIWndDestroy(hwndMCI);
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)NULL);

            if (!fLoadedVFW)
                break;
            if (!FreeVFW())
            {
                DPF("****Free VFW failed**\r\n");
                ASSERT(FALSE);
            }
            fLoadedVFW = FALSE;
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aPreviewIds);
            return TRUE;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aPreviewIds);
            return TRUE;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        {
            HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

            SendMessage(hwndMCI, uMsg, wParam, lParam);
            break;
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// mmse IUnknown base member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_QueryInterface(
    LPUNKNOWN punk,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);
    HRESULT hres = ResultFromScode(E_NOINTERFACE);
    *ppvOut = NULL;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IShellExtInit))
    {
        // We use the sei field as our IUnknown as well
        *ppvOut = &this->sei;
        this->cRef++;
        hres = NOERROR;
    }
    else if (IsEqualIID(riid, &IID_IShellPropSheetExt))
    {
        (LPSHELLPROPSHEETEXT)*ppvOut = &this->pse;
        this->cRef++;
        hres = NOERROR;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_AddRef(
    LPUNKNOWN punk)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);

    return ++this->cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_Release(
    LPUNKNOWN punk)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);

    if (--this->cRef)
    {
        return this->cRef;
    }

    DPF_T("*^*^*^*^*^*^*^*^*^MMPSH nuked , RefCnt = %d *^*^*^*^ \r\n", (g_cRef - 1));
    if (this->pdtobj)
    {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
    }

    if (this->pszFileObj)
    {
        LocalFree((HLOCAL)this->pszFileObj);
    }
    ReleaseInfoList(this);

    LocalFree((HLOCAL)this);
    --g_cRef;
    return 0;
}



/*----------------------------------------------------------
Purpose: IShellExtInit::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_SEI_QueryInterface(
    LPSHELLEXTINIT psei,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);

    return mmpsh_QueryInterface((LPUNKNOWN)&this->sei, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_SEI_AddRef(
    LPSHELLEXTINIT psei)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);

    return mmpsh_AddRef((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_SEI_Release(
    LPSHELLEXTINIT psei)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);
    return mmpsh_Release((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: MMPSHReleaseStgMedium

Returns: NOERROR
Cond:    --
*/
HRESULT MMPSHReleaseStgMedium(LPSTGMEDIUM pmedium)
{
    //
    // Double-check pUnkForRelease in case we're not supposed to
    // release the medium.
    //
    if (NULL == pmedium->pUnkForRelease)
    {
        switch(pmedium->tymed)
        {
            case TYMED_HGLOBAL:
                GlobalFree(pmedium->hGlobal);
                break;

            case TYMED_ISTORAGE:
                pmedium->pstg->lpVtbl->Release(pmedium->pstg);
                break;

            case TYMED_ISTREAM:
                pmedium->pstm->lpVtbl->Release(pmedium->pstm);
                break;

            default:
                ASSERT(FALSE);  // unknown type
                break;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Initialize

Returns: noerror
Cond:    --
*/
STDMETHODIMP mmpsh_SEI_Initialize(
    LPSHELLEXTINIT psei,
    LPCITEMIDLIST pidlObj,
    LPDATAOBJECT pdtobj,
    HKEY hkeyProgID)
{
    HRESULT hres = NOERROR;
    PMMPSH this = IToClass(mmpsh, sei, psei);
DPF("mmpsh_SEI_Initialize called\n");

    if (pdtobj)
    {
        STGMEDIUM    medium;
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        if (this->pdtobj)
        {
            this->pdtobj->lpVtbl->Release(this->pdtobj);
        }
        this->pdtobj = pdtobj;
        pdtobj->lpVtbl->AddRef(pdtobj);

        hres = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
        if(SUCCEEDED(hres))
        {
            if (DragQueryFile(medium.hGlobal, (UINT)-1, NULL, 0))
            {
                TCHAR szPath[MAX_PATH];
                int iIndex;
                DWORD dwSize = 0;

				szPath[0] = '\0';

                DragQueryFile(medium.hGlobal, 0, szPath, sizeof(szPath)/sizeof(TCHAR));

                dwSize = mmpshGetFileSize(szPath);
                if (dwSize != 0)
                {
                    iIndex = lstrlen(szPath) - 4;
                    if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszWavExt))
                        this->iMediaType = MT_WAVE;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszMIDIExt))
                        this->iMediaType = MT_MIDI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszRMIExt))
                        this->iMediaType = MT_MIDI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszAVIExt))
                        this->iMediaType = MT_AVI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszASFExt))
                        this->iMediaType = MT_ASF;
                    else
                        this->iMediaType = MT_ERROR;

                    if (!this->pszFileObj || lstrcmpi(this->pszFileObj, szPath))
                    {
                        if (this->pszFileObj)
                            LocalFree((HLOCAL)this->pszFileObj);
                        ReleaseInfoList(this);
                        if (this->iMediaType)
                        {
                            this->pszFileObj = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szPath)*sizeof(TCHAR))+sizeof(TCHAR));
                            if (this->pszFileObj) lstrcpy(this->pszFileObj , szPath);
                        }
                        else
                            hres = ResultFromScode(E_FAIL);
                    }
                }
                else
                    hres = ResultFromScode(E_FAIL);
            }
            //
            // Release STGMEDIUM if we're responsible for doing that.
            //
            if (NULL == medium.pUnkForRelease)
                MMPSHReleaseStgMedium(&medium);
        }
        else
            return hres;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_QueryInterface(
    LPSHELLPROPSHEETEXT ppse,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);

    return mmpsh_QueryInterface((LPUNKNOWN)&this->sei, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_PSE_AddRef(
    LPSHELLPROPSHEETEXT ppse)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);

    return mmpsh_AddRef((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_PSE_Release(
    LPSHELLPROPSHEETEXT ppse)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);
    return mmpsh_Release((LPUNKNOWN)&this->sei);
}

/*==========================================================================*/
UINT CALLBACK DetailsPageCallback(
    HWND        hwnd,
    UINT        uMsg,
    LPPROPSHEETPAGE    ppsp)
{
    if (uMsg == PSPCB_RELEASE)
        if (((PMMPSH)(ppsp->lParam))->pse.lpVtbl)
            ((PMMPSH)(ppsp->lParam))->pse.lpVtbl->Release(&(((PMMPSH)(ppsp->lParam))->pse));
        else
        {
            LocalFree((HLOCAL)((PMMPSH)(ppsp->lParam))->pszFileObj);
            LocalFree((HLOCAL)ppsp->lParam);
        }
    return 1;
}


BOOL AddDetailsPage(
    LPTSTR pszTitle,
    LPFNADDPROPSHEETPAGE    lpfnAddPropSheetPage,
    LPARAM            lDlgParam,
    LPARAM            lParam)
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE    hpsp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_FILE_DETAILS);
    psp.pszIcon = NULL;
    psp.pszTitle = pszTitle;
    psp.pfnDlgProc = FileDetailsDlg;
    psp.lParam = lDlgParam;
    psp.pfnCallback = DetailsPageCallback;
    psp.pcRefParent = NULL;
    if (hpsp = CreatePropertySheetPage(&psp))
    {
        if (lpfnAddPropSheetPage(hpsp, lParam))
            return TRUE;
        DestroyPropertySheetPage(hpsp);
    }
    return FALSE;
}

UINT CALLBACK PreviewPageCallback(
    HWND        hwnd,
    UINT        uMsg,
    LPPROPSHEETPAGE    ppsp)
{
    return 1;
}



BOOL AddPreviewPage(
    LPTSTR pszTitle,
    LPFNADDPROPSHEETPAGE    lpfnAddPropSheetPage,
    LPARAM            lDlgParam,
    LPARAM            lParam)
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE    hpsp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(PREVIEW_DLG);
    psp.pszIcon = NULL;
    psp.pszTitle = pszTitle;
    psp.pfnDlgProc = PreviewDlg;
    psp.lParam = lDlgParam;
    psp.pfnCallback = PreviewPageCallback;
    psp.pcRefParent = NULL;
    if (hpsp = CreatePropertySheetPage(&psp))
    {
        if (lpfnAddPropSheetPage(hpsp, lParam))
            return TRUE;
        DestroyPropertySheetPage(hpsp);
    }
    return FALSE;
}



/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddPages

Returns: NOERROR
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_AddPages(
    LPSHELLPROPSHEETEXT ppse,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);
/*  BOOL fAddPreview = FALSE;

    LoadString(ghInstance, IDS_DETAILS, szDetailsTab, sizeof(szDetailsTab)/sizeof(TCHAR));
    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);
    AddDetailsPage(szDetailsTab,lpfnAddPage,(LPARAM)this, lParam);
    switch (this->iMediaType)
    {
        case MT_AVI:
            fAddPreview = TRUE;
            break;
        case MT_WAVE:
            if (waveOutGetNumDevs() > 0)
                fAddPreview = TRUE;
            break;
        case MT_MIDI:
            if (midiOutGetNumDevs() > 0)
                fAddPreview = TRUE;
            break;
    }
    if (fAddPreview)
    {
        LoadString(ghInstance, IDS_PREVIEW, szPreviewTab, sizeof(szPreviewTab)/sizeof(TCHAR));
        AddPreviewPage(szPreviewTab,lpfnAddPage,(LPARAM)this, lParam);
    } */
    ppse->lpVtbl->AddRef(ppse);
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::ReplacePage

Returns: E_NOTIMPL
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_ReplacePage(
    LPSHELLPROPSHEETEXT ppse,
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam)
{
        return ResultFromScode(E_NOTIMPL);
}



IShellExtInitVtbl c_mmpshSEIVtbl =
{
    mmpsh_SEI_QueryInterface,
    mmpsh_SEI_AddRef,
    mmpsh_SEI_Release,
    mmpsh_SEI_Initialize
};

IShellPropSheetExtVtbl c_mmpshPSEVtbl =
{
    mmpsh_PSE_QueryInterface,
    mmpsh_PSE_AddRef,
    mmpsh_PSE_Release,
    mmpsh_PSE_AddPages,
    mmpsh_PSE_ReplacePage
} ;


HRESULT CALLBACK mmpsh_CreatePSHInstance(
    LPUNKNOWN punkOuter,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    HRESULT hres;
    PMMPSH this;

    DPF_T("*^*^*^*^*^*^*^*^mmpsh_CreatePSHInstance*^*^*^*^*^*^*^*^\r\n");

    // The  handler does not support aggregation.
    if (punkOuter)
    {
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
        goto Leave;
    }

    this = LocalAlloc(LPTR, sizeof(*this));
    if (!this)
    {
        hres = ResultFromScode(E_OUTOFMEMORY);
        goto Leave;
    }
    this->sei.lpVtbl = &c_mmpshSEIVtbl;
    this->pse.lpVtbl = &c_mmpshPSEVtbl;
    this->cRef = 1;

    ++g_cRef;

    // Note that the Release member will free the object, if
    // QueryInterface failed.
    hres = this->sei.lpVtbl->QueryInterface(&this->sei, riid, ppvOut);
    this->sei.lpVtbl->Release(&this->sei);

Leave:

    return hres;        // S_OK or E_NOINTERFACE
}

BOOL mmpsh_ShowFileDetails(LPTSTR pszCaption,
        HWND hwndParent,
        LPTSTR pszFile,
        short iMediaType)
{
    PMMPSH pmmpsh;
    TCHAR     szTabName[64];

    pmmpsh = (PMMPSH)LocalAlloc(LPTR, sizeof(*pmmpsh));

    if (!pmmpsh)
        return FALSE;

    pmmpsh->pszFileObj = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pszFile)*sizeof(TCHAR))+sizeof(TCHAR));

    if (!pmmpsh->pszFileObj)
	{
		LocalFree((HLOCAL)pmmpsh);
        return FALSE;
	}

    lstrcpy(pmmpsh->pszFileObj , pszFile);
    pmmpsh->iMediaType = iMediaType;
    LoadString(ghInstance, IDS_DETAILS, szTabName, sizeof(szTabName)/sizeof(TCHAR));
    ShowPropSheet(szTabName,FileDetailsDlg,DLG_FILE_DETAILS,hwndParent,pszCaption,(LPARAM)pmmpsh);

    return TRUE;
}

BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    hres = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, &IID_IShellLink, &psl);
    if (SUCCEEDED(hres))
    {
        WCHAR wszPath[MAX_PATH];
        IPersistFile *ppf;

        psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);
        if (ppf)
        {

            wcscpy(wszPath, szPath);
            hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
            ppf->lpVtbl->Release(ppf);

            if (FAILED(hres))
            {
                psl->lpVtbl->Release(psl);
                psl = NULL;
            }
        }
        else
        {
             psl = NULL;
        }
    }
    if (psl)
    {
        // this reslve could fail.. should we really do NOUI?
        psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
        psl->lpVtbl->GetPath(psl, szResolved, cbSize, NULL,
                                SLGP_SHORTPATH);
        psl->lpVtbl->Release(psl);
    }
    if (SUCCEEDED(hres))
        return TRUE;
    return FALSE;
}



//---------------------------------------------------------------------------
// EXPORTED API
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Standard shell entry-point

Returns: standard
Cond:    --
*/
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppv)
{

    // We are supposed return the class object for this class.  Instead
    // of fully implementing it in this DLL, we just call a helper
    // function in the shell DLL which creates a default class factory
    // object for us. When its CreateInstance member is called, it
    // will call back our create instance function.
    //

    if (IsEqualIID(rclsid, &CLSID_mmsePropSheetHandler))
    {
        return SHCreateDefClassObject(
                    riid,                   // Interface ID
                    ppv,                    // Non-null to aggregate
                    mmpsh_CreatePSHInstance,  // Callback function
                    &g_cRef,                // Reference count of this DLL
                    &IID_IShellExtInit);   // Init interface
    }
    return ResultFromScode(REGDB_E_CLASSNOTREG);
}


//****************************************************************************
// STDAPI DllCanUnLoadNow()
//
// This function is called by shell
//
//****************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (0 == g_cRef)
    {
        DPF("DllCanUnloadNow says OK (Ref=%d)",
            g_cRef);

        hr = ResultFromScode(S_OK);
    }
    else
    {
        DPF("DllCanUnloadNow says FALSE (Ref=%d)",
            g_cRef);

        hr = ResultFromScode(S_FALSE);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\multchan.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  multchan.c
//
//      This file defines the functions that drive the multichannel 
//      volume tab of the Sounds & Multimedia control panel.
//
//  History:
//      13 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <regstr.h>
#include <dbt.h>
#include "medhelp.h"
#include "mmcpl.h"
#include "multchan.h"
#include "speakers.h"
#include "dslevel.h"

// Externals
extern BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice);
extern HRESULT DSGetGuidFromName(LPTSTR szName, BOOL fRecord, LPGUID pGuid);
extern HRESULT DSGetCplValues(GUID guid, BOOL fRecord, LPCPLDATA pData);

// Globals
UINT                g_uiMCMixID            = 0;
HMIXER              g_hMCMixer             = NULL;
UINT                g_uiMCPageStringID     = 0;
UINT                g_uiMCDescStringID     = 0;
LPVOID              g_paPrevious           = NULL;
BOOL                g_fInternalMCGenerated = FALSE;
BOOL                g_fMCChanged           = FALSE;
MIXERCONTROLDETAILS g_mcdMC;
MIXERLINE           g_mlMCDst;
WNDPROC             g_fnMCPSProc           = NULL;
UINT                g_uiMCDevChange        = 0;
HWND                g_hWndMC               = NULL;
static HDEVNOTIFY   g_hMCDeviceEventContext= NULL;

// Constants
#define VOLUME_TICS (500) // VOLUME_TICS * VOLUME_MAX must be less than 0xFFFFFFFF
#define VOLUME_MAX  (0xFFFF)
#define VOLUME_MIN  (0)
#define MC_SLIDER_COUNT (8) // Update Code & Dialog Template if change this value!
static INTCODE  aKeyWordIds[] =
{
    IDC_MC_DESCRIPTION,      NO_HELP,
    IDC_MC_ZERO_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO,             IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE,              IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO,              IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_LOW,        IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE,            IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_VOLUME,     IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_HIGH,       IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR,             IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE,             IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX,              IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_LOW,        IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN,            IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_VOLUME,     IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_HIGH,       IDH_MC_ALL_SLIDERS,
    IDC_MC_MOVE_TOGETHER,    IDH_MC_MOVE_TOGETHER,
    IDC_MC_RESTORE,          IDH_MC_RESTORE,
    0,0
};

///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: MCTabProc
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for multichannel control panel page device change
//               message.
//
//
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MCTabProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == g_uiMCDevChange)
    {
        InitMCVolume (g_hWndMC);
    }
        
    return CallWindowProc (g_fnMCPSProc, hwnd, iMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: MultichannelDlg
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for multichannel volume control panel page.
//
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK MultichannelDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            OnNotifyMC (hDlg, (LPNMHDR) lParam);
        }
        break;

        case WM_INITDIALOG:
        {
            HANDLE_WM_INITDIALOG (hDlg, wParam, lParam, OnInitDialogMC);
        }
        break;

        case WM_DESTROY:
        {
            HANDLE_WM_DESTROY (hDlg, wParam, lParam, OnDestroyMC);
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND (hDlg, wParam, lParam, OnCommandMC);
        }
        break;

	    case WM_HSCROLL:
        {
	        HANDLE_WM_HSCROLL (hDlg, wParam, lParam, MCVolumeScroll);
	    }
        break;

        case WM_POWERBROADCAST:
        {
            HandleMCPowerBroadcast (hDlg, wParam, lParam);
        }
        break;

        case MM_MIXM_LINE_CHANGE:
        case MM_MIXM_CONTROL_CHANGE:
        {
            if (!g_fInternalMCGenerated)
            {
                DisplayMCVolumeControl (hDlg);
            }

            g_fInternalMCGenerated = FALSE;
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;
        
        case WM_DEVICECHANGE:
        {
            MCDeviceChange_Change (hDlg, wParam, lParam);
        }
        break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE :
        {
            int iLastSliderID = IDC_MC_ZERO_VOLUME + (MC_SLIDER_COUNT - 1) * 4;
            int indx = IDC_MC_ZERO_VOLUME;
            for (; indx <= iLastSliderID; indx += 4)
                SendDlgItemMessage (hDlg, indx, uMsg, wParam, lParam);
        }
        break;

    }

    return FALSE;

}


void InitMCVolume (HWND hDlg)
{
    FreeMCMixer ();

    if (MMSYSERR_NOERROR == mixerOpen (&g_hMCMixer, g_uiMCMixID, (DWORD_PTR) hDlg, 0L, CALLBACK_WINDOW))
    {
        if (SUCCEEDED (GetMCVolume ()) && g_paPrevious && g_mcdMC.paDetails)
        {
            // Copy data so can undo volume changes
            memcpy (g_paPrevious, g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            DisplayMCVolumeControl (hDlg);
        }
        MCDeviceChange_Init (hDlg, g_uiMCMixID);
    }
}


BOOL OnInitDialogMC (HWND hDlg, HWND hwndFocus, LPARAM lParam)
{

    TCHAR szDescription [255];
    LoadString (ghInstance, g_uiMCDescStringID, szDescription, sizeof (szDescription)/sizeof (TCHAR));
    SetWindowText (GetDlgItem (hDlg, IDC_MC_DESCRIPTION), szDescription);

    // Init Globals
    g_fInternalMCGenerated = FALSE;
    g_fMCChanged           = FALSE;
    g_hWndMC               = hDlg;
    // Set Device Change Notification
    g_fnMCPSProc = (WNDPROC) SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) MCTabProc);
    g_uiMCDevChange = RegisterWindowMessage (_T("winmm_devicechange"));

    // Init Volume
    InitMCVolume (hDlg);

    return FALSE;
}


void OnDestroyMC (HWND hDlg)
{
    // Unregister from notifications
    MCDeviceChange_Cleanup ();
    SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) g_fnMCPSProc);  

    FreeAll ();
}


void OnNotifyMC (HWND hDlg, LPNMHDR pnmh)
{
    if (!pnmh)
    {
        DPF ("bad WM_NOTIFY pointer\n");            
        return;
    }

    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
            break;

        case PSN_APPLY:
            FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
            break;

        case PSN_RESET:
            FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
            break;
    }
}


BOOL PASCAL OnCommandMC (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_MC_RESTORE:
        {
            // Move all sliders to center
            UINT  uiIndx;
            for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
            {
                ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue = VOLUME_MAX/2;
            }
            g_fInternalMCGenerated = FALSE;
            mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);

            if (!g_fMCChanged)
            {
                g_fMCChanged = TRUE;
                PropSheet_Changed (GetParent (hDlg), hDlg);
            }
        }
        break;

        case ID_APPLY:
        {
            if (SUCCEEDED (GetMCVolume ()) && g_paPrevious && g_mcdMC.paDetails)
            {
                // Copy data so can undo volume changes
                memcpy (g_paPrevious, g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
                DisplayMCVolumeControl (hDlg);
            }

            g_fMCChanged = FALSE;
            return TRUE;
        }
        break;

        case IDOK:
        {
        }
        break;

        case IDCANCEL:
        {
            if (g_paPrevious && g_mcdMC.paDetails)
            {
                // Undo volume changes
                memcpy (g_mcdMC.paDetails, g_paPrevious, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
                g_fInternalMCGenerated = TRUE;
                mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);
            }
            WinHelp (hDlg, gszWindowsHlp, HELP_QUIT, 0L);
        }
        break;

    }


   return FALSE;

}


void HandleMCPowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
	    case PBT_APMQUERYSUSPEND:
        {
            FreeMCMixer ();
        }
	    break;

	    case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            InitMCVolume (hWnd);
        }
	    break;
    }
}


BOOL SliderIDtoChannel (UINT uiSliderID, DWORD* pdwChannel)
{

    if (!pdwChannel)
        return FALSE;

    // Determine channel number (index)
    switch (uiSliderID)
    {
        case IDC_MC_ZERO_VOLUME:    // Left 
            *pdwChannel = 0; 
            break;
        case IDC_MC_ONE_VOLUME:     // Right 
            *pdwChannel = 1;
            break;
        case IDC_MC_TWO_VOLUME:     // Center 
            *pdwChannel = 2;
            break;
        case IDC_MC_THREE_VOLUME:   // Back Left
            *pdwChannel = 3;
            break;
        case IDC_MC_FOUR_VOLUME:    // Back Right 
            *pdwChannel = 4;
            break;
        case IDC_MC_FIVE_VOLUME:    // Low Frequency
            *pdwChannel = 5;
            break;
        case IDC_MC_SIX_VOLUME:     // Left of Center
            *pdwChannel = 6;
            break;
        case IDC_MC_SEVEN_VOLUME:   // Right of Center
            *pdwChannel = 7;
            break;
        default:
            return FALSE;
    }

    return ((*pdwChannel) < g_mlMCDst.cChannels);

}


// Called in response to slider movement, computes new volume level and sets it
// it also controls the apply state (changed or not)
void MCVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    
    BOOL  fSet;
    BOOL  fMoveTogether;
    DWORD dwChannel; 
    DWORD dwSliderVol;
    DWORD dwNewMixerVol;
    DWORD dwOldMixerVol;
    DWORD dwVolume;

    fMoveTogether = IsDlgButtonChecked (hwnd, IDC_MC_MOVE_TOGETHER);
    if (SliderIDtoChannel (GetDlgCtrlID (hwndCtl), &dwChannel))
    {
        // Set the new volume
        dwSliderVol   = (DWORD) SendMessage (hwndCtl, TBM_GETPOS, 0, 0);
        dwNewMixerVol = (VOLUME_MAX * dwSliderVol + VOLUME_TICS / 2) / VOLUME_TICS;
        dwOldMixerVol = (g_paPrevious ? ((MIXERCONTROLDETAILS_UNSIGNED*)g_paPrevious + dwChannel) -> dwValue : 0);
        fSet          = SetMCVolume (dwChannel, dwNewMixerVol, fMoveTogether);

        if (!fSet)
        {
            // Restore the correct thumb position.
            dwVolume = (VOLUME_TICS * ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue + VOLUME_MAX / 2) / VOLUME_MAX;
            SendMessage (hwndCtl, TBM_SETPOS, TRUE, dwVolume);
        }

        if ((fMoveTogether || dwOldMixerVol != dwNewMixerVol) && !g_fMCChanged)
        {
            g_fMCChanged = TRUE;
            PropSheet_Changed (GetParent (hwnd), hwnd);
        }
    }
    
}

// Sets the volume level
//
BOOL SetMCVolume (DWORD dwChannel, DWORD dwVol, BOOL fMoveTogether)
{

    BOOL  fReturn;
    UINT  uiIndx;
    DWORD dwValue;
    long lMoveValue;
    long lMoveValueActual;

    fReturn = TRUE;
    if (dwChannel < g_mlMCDst.cChannels && g_mcdMC.paDetails && g_hMCMixer)
    {
        if (fMoveTogether)
        {
            // Note: Do not set g_fInternalMCGenerated = TRUE here because we are relying
            //       on the change notification to update the other sliders.
            lMoveValue = (long)((double)dwVol - (double)(((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue));
            lMoveValueActual = lMoveValue;

            // Don't bother if no move requested.
            if (lMoveValue == 0)
                return TRUE; // Already Set

            // Ensure that the new value is within the range of all the sliders that are
            // being used. This will ensure that we maintain the distance between sliders 
            // as they are being moved.
            for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
            {
                dwValue = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue;
                if (VOLUME_MIN > ((long)dwValue+lMoveValueActual))
                {
                    lMoveValueActual = VOLUME_MIN - dwValue;
                }
                else
                {
                    if (VOLUME_MAX < ((long)dwValue+lMoveValueActual))
                        lMoveValueActual = VOLUME_MAX - dwValue;
                }
            }

            if (lMoveValueActual != 0)
            {
                // Update the values
                for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
                {
                    dwValue = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue;
                    ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue = (DWORD)((long) dwValue + lMoveValueActual);
                }
            }
            else
            {
                // Let user know that they can move no farther in the current direction.
                // Note: We use the PC Speaker instead of the mixer because this is an
                //       indicator that they are at either min or max volume for one of
                //       the sliders. Since these are channel volume sliders, if we used
                //       the mixer, the user would either not hear anything (min volume)
                //       or get blown away (max volume).
                MessageBeep (-1 /*PC Speaker*/);
                fReturn = FALSE;
            }
        }
        else
        {
            g_fInternalMCGenerated = TRUE;
            ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue = dwVol;
        }
        
        mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);
    }

    return fReturn;

}


void ShowAndEnableWindow (HWND hwnd, BOOL fEnable)
{
    EnableWindow (hwnd, fEnable);
    ShowWindow (hwnd, fEnable ? SW_SHOW : SW_HIDE);
}


void DisplayMCVolumeControl (HWND hDlg)
{
    
    HWND hwndVol = NULL;
    HWND hwndLabel = NULL;
    WCHAR szLabel[MAX_PATH];
    BOOL fEnabled;
    UINT uiIndx;
    DWORD dwSpeakerType = TYPE_STEREODESKTOP;
    BOOL fPlayback = (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == g_mlMCDst.dwComponentType);
    ZeroMemory (szLabel, sizeof (szLabel));

    // Get Speaker Configuration Type
    if (fPlayback)
        GetSpeakerType (&dwSpeakerType);

    for (uiIndx = 0; uiIndx < MC_SLIDER_COUNT; uiIndx++)
    {

        fEnabled = (uiIndx < g_mlMCDst.cChannels);

        // Set up the volume slider
        hwndVol = GetDlgItem (hDlg, IDC_MC_ZERO_VOLUME + uiIndx * 4);
        SendMessage (hwndVol, TBM_SETTICFREQ, VOLUME_TICS / 10, 0);
        SendMessage (hwndVol, TBM_SETRANGE, FALSE, MAKELONG (0, VOLUME_TICS));

        // Enable/Disable sliders
        hwndLabel = GetDlgItem (hDlg, IDC_MC_ZERO + uiIndx * 4);
        ShowAndEnableWindow (hwndVol, fEnabled);
        ShowAndEnableWindow (hwndLabel, fEnabled);
        ShowAndEnableWindow (GetDlgItem (hDlg, IDC_MC_ZERO_LOW + uiIndx * 4), fEnabled);
        ShowAndEnableWindow (GetDlgItem (hDlg, IDC_MC_ZERO_HIGH + uiIndx * 4), fEnabled);

        if (fPlayback)
        {
            GetSpeakerLabel (dwSpeakerType, uiIndx, szLabel, sizeof(szLabel)/sizeof(TCHAR));
        }
        else
        {
            LoadString (ghInstance, IDS_MC_CHANNEL_ZERO + uiIndx, szLabel, MAX_PATH);
        }
        SetWindowText (hwndLabel, szLabel);

    }

    if (0 < g_mlMCDst.cChannels)
    {
        UpdateMCVolumeSliders (hDlg);
    }

}


BOOL GetSpeakerType (DWORD* pdwSpeakerType)
{

    BOOL fReturn = FALSE;

    if (pdwSpeakerType)
    {
        MIXERCAPS mc;

        *pdwSpeakerType = TYPE_STEREODESKTOP; // Init Value
        if (MMSYSERR_NOERROR == mixerGetDevCaps (g_uiMCMixID, &mc, sizeof (mc)))
        {
            GUID guid;
            if (SUCCEEDED (DSGetGuidFromName (mc.szPname, FALSE, &guid)))
            {
                CPLDATA cpldata;
                if (SUCCEEDED (DSGetCplValues (guid, FALSE, &cpldata)))
                {
                    *pdwSpeakerType = cpldata.dwSpeakerType;
                    fReturn = TRUE;
                }
            }
        }
    }

    return fReturn;

}

BOOL GetSpeakerLabel (DWORD dwSpeakerType, UINT uiSliderIndx, WCHAR* szLabel, int nSize)
{

    if (uiSliderIndx >= MC_SLIDER_COUNT || !szLabel || nSize <= 0)
        // Invalid
        return FALSE;

    switch (dwSpeakerType)
    {
        //
        // Mono
        //
        case TYPE_NOSPEAKERS:
        case TYPE_MONOLAPTOP:
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            break;

        //
        // Stereo
        //
        case TYPE_HEADPHONES:
        case TYPE_STEREODESKTOP:
        case TYPE_STEREOLAPTOP:
        case TYPE_STEREOMONITOR:
        case TYPE_STEREOCPU:
        case TYPE_MOUNTEDSTEREO:
        case TYPE_STEREOKEYBOARD:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            break;

        //
        // Greater than Stereo
        //
        case TYPE_SURROUND:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            // Center Front & Back
            else if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            else if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKCENTER, szLabel, nSize));
            break;

        case TYPE_QUADRAPHONIC:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            // Back Left & Back Right Channel ...
            else if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKLEFT, szLabel, nSize));
            else if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKRIGHT, szLabel, nSize));
            break;

        case TYPE_SURROUND_5_1:
        case TYPE_SURROUND_7_1:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));

            // Center Channel ...
            if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            // Low Frequency ...
            if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LOWFREQUENCY, szLabel, nSize));

            // Back Left & Back Right Channel ...
            if (4 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKLEFT, szLabel, nSize));
            else if (5 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKRIGHT, szLabel, nSize));

            if (TYPE_SURROUND_5_1 == dwSpeakerType)
                break;

            // Left of Center & Right of Center Channel ...
            if (6 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT_OF_CENTER, szLabel, nSize));
            else if (7 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT_OF_CENTER, szLabel, nSize));

            break;

    }

    // If we are here, we don't know the speaker type or we have too many 
    // channels for a known type, just use the generic channel text ...
    return (LoadString (ghInstance, IDS_MC_CHANNEL_ZERO + uiSliderIndx, szLabel, nSize));

}


// Called to update the slider when the volume is changed externally
//
void UpdateMCVolumeSliders (HWND hDlg)
{
    if (g_hMCMixer && g_mcdMC.paDetails && SUCCEEDED (GetMCVolume ()))
    {
        UINT uiIndx;
        DWORD dwVolume;
        MIXERCONTROLDETAILS_UNSIGNED mcuVolume;
        for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
        {
            mcuVolume = *((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx);
            dwVolume = (VOLUME_TICS * mcuVolume.dwValue + VOLUME_MAX / 2) / VOLUME_MAX;
            SendMessage (GetDlgItem (hDlg, IDC_MC_ZERO_VOLUME + uiIndx * 4), TBM_SETPOS, TRUE, dwVolume);
        }
    }
}


void FreeAll ()
{
    FreeMCMixer ();
    if (g_mcdMC.paDetails)
    {
        LocalFree (g_mcdMC.paDetails);
        g_mcdMC.paDetails = NULL;
    }
    if (g_paPrevious)
    {
        LocalFree (g_paPrevious);
        g_paPrevious = NULL;
    }
    ZeroMemory (&g_mcdMC, sizeof (g_mcdMC));
    ZeroMemory (&g_mlMCDst, sizeof (g_mlMCDst));
}

void FreeMCMixer ()
{
    if (g_hMCMixer)
    {
        mixerClose (g_hMCMixer);
        g_hMCMixer = NULL;
    }
}


HRESULT SetDevice (UINT uiMixID, DWORD dwDest, DWORD dwVolID)
{

    HMIXER hMixer = NULL;
    HRESULT hr = E_FAIL;

    // Free any current mixer stuff
    FreeAll ();

    if (MMSYSERR_NOERROR == mixerOpen (&hMixer, uiMixID, 0, 0, MIXER_OBJECTF_MIXER))
    {
        g_mlMCDst.cbStruct      = sizeof (g_mlMCDst);
        g_mlMCDst.dwDestination = dwDest;
    
        if (MMSYSERR_NOERROR == mixerGetLineInfo ((HMIXEROBJ) hMixer, &g_mlMCDst, MIXER_GETLINEINFOF_DESTINATION))
        {
            g_mcdMC.cbStruct     = sizeof (g_mcdMC);
            g_mcdMC.dwControlID    = dwVolID;
            g_mcdMC.cChannels      = g_mlMCDst.cChannels;
            g_mcdMC.hwndOwner      = 0;
            g_mcdMC.cMultipleItems = 0;
            g_mcdMC.cbDetails      = sizeof (DWORD); // seems like it would be sizeof(g_mcd),
                                                     // but actually, it is the size of a single value
                                                     // and is multiplied by channel in the driver.
            g_mcdMC.paDetails = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            g_paPrevious = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            if (g_mcdMC.paDetails && g_paPrevious)
            {
                hr = S_OK;

                // Init our other globals
                g_uiMCMixID = uiMixID;
                switch (g_mlMCDst.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                        g_uiMCPageStringID = IDS_MC_PLAYBACK;
                        g_uiMCDescStringID = IDS_MC_PLAYBACK_DESC;
                        break;

                    case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                    case MIXERLINE_COMPONENTTYPE_DST_VOICEIN:
                        g_uiMCPageStringID = IDS_MC_RECORDING;
                        g_uiMCDescStringID = IDS_MC_RECORDING_DESC;
                        break;

                    default:
                        g_uiMCPageStringID = IDS_MC_OTHER;
                        g_uiMCDescStringID = IDS_MC_OTHER_DESC;
                        break;

                }
            }
        }

        mixerClose (hMixer);
    }

    return hr;

}


HRESULT GetMCVolume ()
{
    HRESULT hr = E_FAIL;
    if (g_hMCMixer && g_mcdMC.paDetails)
    {
        ZeroMemory (g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
        hr = mixerGetControlDetails ((HMIXEROBJ)g_hMCMixer, &g_mcdMC, MIXER_GETCONTROLDETAILSF_VALUE);
    }
    return hr;
}


UINT GetPageStringID () 
{ 
    return g_uiMCPageStringID; 
}


void MCDeviceChange_Cleanup ()
{
   if (g_hMCDeviceEventContext) 
   {
       UnregisterDeviceNotification (g_hMCDeviceEventContext);
       g_hMCDeviceEventContext = NULL;
   }
}


void MCDeviceChange_Init (HWND hWnd, DWORD dwMixerID)
{
	DEV_BROADCAST_HANDLE DevBrodHandle;
	HANDLE hMixerDevice=NULL;

	//If we had registered already for device notifications, unregister ourselves.
	MCDeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(DeviceChange_GetHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		g_hMCDeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
	}
}


// Handle the case where we need to dump mixer handle so PnP can get rid of a device
// We assume we will get the WINMM_DEVICECHANGE handle when the dust settles after a remove or add
// except for DEVICEQUERYREMOVEFAILED which will not generate that message.
//
void MCDeviceChange_Change (HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

	if(!g_hMCDeviceEventContext || !bh || bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
	{
		return;
	}
	
    switch (wParam)
    {
	    case DBT_DEVICEQUERYREMOVE:     // Must free up Mixer if they are trying to remove the device           
        {
            FreeMCMixer ();
        }
        break;

	    case DBT_DEVICEQUERYREMOVEFAILED:   // Didn't happen, need to re-acquire mixer
        {
            InitMCVolume (hDlg);
        }
        break; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

#define FOPEN(sz)                _lopen(sz,OF_READ)
#define FCREATE(sz)              _lcreat(sz,0)
#define FCLOSE(fh)               _lclose(fh)
#define FREAD(fh,buf,len)        _lread(fh,buf,len)
#define FWRITE(fh,buf,len)       _lwrite(fh,buf,len)
#define FSEEK(fh,off,i)          _llseek(fh,(DWORD)off,i)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\multchan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  multchan.c
//
//      This file defines the functions that drive the multichannel 
//      volume tab of the Sounds & Multimedia control panel.
//
//  History:
//      13 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

// Prototypes
INT_PTR CALLBACK MultichannelDlg (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT SetDevice (UINT uiMixID, DWORD dwDest, DWORD dwVolID);
UINT GetPageStringID ();

BOOL OnInitDialogMC (HWND hDlg, HWND hwndFocus, LPARAM lParam);
void OnDestroyMC (HWND hDlg);
void OnNotifyMC (HWND hDlg, LPNMHDR pnmh);
BOOL PASCAL OnCommandMC (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
void FreeMCMixer ();
HRESULT GetMCVolume ();
void DisplayMCVolumeControl (HWND hDlg);
void ShowAndEnableWindow (HWND hwnd, BOOL fEnable);
void UpdateMCVolumeSliders (HWND hDlg);
void MCVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos);
BOOL SetMCVolume (DWORD dwChannel, DWORD dwVol, BOOL fMoveTogether);
BOOL SliderIDtoChannel (UINT uiSliderID, DWORD* pdwChannel);
void HandleMCPowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam);
void InitMCVolume (HWND hDlg);
void FreeAll ();
BOOL GetSpeakerLabel (DWORD dwSpeakerType, UINT uiSliderIndx, WCHAR* szLabel, int nSize);
BOOL GetSpeakerType (DWORD* pdwSpeakerType);

void MCDeviceChange_Cleanup ();
void MCDeviceChange_Init (HWND hWnd, DWORD dwMixerID);
void MCDeviceChange_Change (HWND hDlg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\rcids.h ===
//****************************************************************************
//
//  Module:     MMSE.DLL
//  File:       rcids.h
//  Content:    This file contains all the constant declaration for the
//              MMSE resources.
//  History:
//      06/1994    -By-    Vij Rajarajan (VijR)
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************


//*****************************************************************************
// Icon ID number section
//*****************************************************************************

#include <cphelp.h>

#define ID_BASE_START                   0x1000
                                                         
#define ID_BASE_CONTROL                 (ID_BASE_START + 0x0500)    // 0x0100 - 0x0400 reserved
#define ID_BASE_STRINGS                 (ID_BASE_START + 0x0600)
#define ID_BASE_FILEPROP_STRINGS        (ID_BASE_START + 0x0700)
#define ID_BASE_EVENTS_STRINGS          (ID_BASE_START + 0x0800)
#define ID_BASE_MIDI_STRINGS            (ID_BASE_START + 0x0900)
#define ID_SIMPLE_PROP                  (ID_BASE_START + 0x0A00)
#define ID_ADVANCED_PROP                (ID_BASE_START + 0x1000)
#define ID_MIDI_PROP                    (ID_BASE_START + 0x1100)
#define ID_FILE_DETAILS                 (ID_BASE_START + 0x1200)
#define ID_EVENTS_START                 (ID_BASE_START + 0x1300)
#define ID_VOICE_PROP                   (ID_BASE_START + 0x1400)
#define ID_MULTICHANNEL_PROP            (ID_BASE_START + 0x1500)
#define ID_EFFECT_PROP                  (ID_BASE_START + 0x1600)
#define ID_BASE_CHANNEL_STRINGS         (ID_BASE_START + 0x1700)


#define IDC_STATIC                      -1

/////////////////////////////////////////////////////////////////////
// ICONS
/////////////////////////////////////////////////////////////////////
#define IDI_MMICON                      3004    //DO NOT CHANGE THIS ID. Other files depend on this number
#define IDI_IDFICON                     0x1101
#define IDI_WAVE                        0x1102
#define IDI_MIDI                        0x1103
#define IDI_MIXER                       0x1104
#define IDI_AUX                         0x1105
#define IDI_MCI                         0x1106
#define IDI_ICM                         0x1107
#define IDI_ACM                         0x1108
#define IDI_JOYSTICK                    0x1109
#define IDI_SOUNDSCHEMES                0x110A
#define IDI_AUDIO                       0x110B
#define IDI_VIDEO                       0x110C
#define IDI_CDAUDIO                     0x110D
#define IDI_PROGRAM                     0x110E
#define IDI_MSACM                       0x110F
#define IDI_PLAYBACK                    0x1110
#define IDI_RECORD                      0x1111
#define IDI_DWAVE                       0x1112
#define IDI_DMIDI                       0x1113
#define IDI_DVIDEO                      0x1114
#define IDI_INSTRUMENT                  0x1115
#define IDI_CHANNEL                     0x1116
#define IDI_BLANK                       0x1117
#define IDI_SELECTED_IDF                0x1118
#define IDI_NONSEL_IDF                  0x1119
#define IDI_MICROPHONE                  0x111A
#define IDI_SPEAKERICON                 0x111B
#define IDI_RECORDICON                  0x111C
#define IDI_MUSICICON                   0x111D
#define IDI_VOLUME                      0x111E
#define IDI_VOLUP                       0x111F
#define IDI_VOLDOWN                     0x1120
#define IDI_VOLMUTE                     0x1121
#define IDI_VOLMUTEUP                   0x1122
#define IDI_VOLMUTEDOWN                 0x1123
#define IDI_VOLTRANS                    0x1124
#define IDI_GS                          0x1125
#define IDI_MIDIKEY                     0x1126

#define IDI_VOC_SPEAKERICON             0x1127
#define IDI_VOC_RECORDICON              0x1128
#define IDI_MUTESPEAKERICON             0x1129


////////////////////////////////////////////////////////////////////
//BITMAPS
////////////////////////////////////////////////////////////////////

#define IDB_PLAY                        0x1200
#define IDB_STOP                        0x1201
#define IDB_WIZBMP                      0x1202
#define IDB_MONITOR                     0x1203
#define IDB_HEADPHONES                  0x1204
#define IDB_STEREODESKTOP               0x1205
#define IDB_MONOLAPTOP                  0x1206
#define IDB_STEREOLAPTOP                0x1207
#define IDB_STEREOMONITOR               0x1208
#define IDB_STEREOCPU                   0x1209
#define IDB_MOUNTEDSTEREO               0x120A
#define IDB_STEREOKEYBOARD              0x120B
#define IDB_QUADRAPHONIC                0x120C
#define IDB_SURROUND                    0x120D
#define IDB_SURROUND_5_1                0x120E
#define IDB_ROLAND                      0x120F
#define IDB_MULTICHANNEL_SPKR           0x1210
#define IDB_VOLUME_BRAND                0x1211
#define IDB_NOSPEAKERS                  0x1212
#define IDB_SURROUND_7_1                0x1213

////////////////////////////////////////////////////////////////////
// DIALOGS
////////////////////////////////////////////////////////////////////

#define CDDLG                           0x1300
#define VIDEODLG                        0x1301
#define AUDIODLG                        0x1302
#define EVENTSDLG                       0x1303
#define DLG_DEV_PROP                    0x1304
#define DLG_CPL_MSACM                   0x1305
#define DLG_ABOUT_MSACM                 0x1306
#define DLG_PRIORITY_SET                0x1307
#define DLG_WAVDEV_PROP                 0x1308
#define DLG_ACMDEV_PROP                 0x1309
#define DLG_FILE_DETAILS                0x130A
#define DLG_MESSAGE_BOX                 0x130B
#define SOUNDDIALOG                     0x130C
#define SAVESCHEMEDLG                   0x130D
#define PREVIEW_DLG                     0x130E
#define IDD_CPL_MIDI                    0x130F
#define IDD_MIDICHANGE                  0x1310
#define IDD_MIDICONFIG                  0x1311
#define IDD_SAVENAME                    0x1312
#define IDD_CPL_MIDI2                   0x1313
#define IDD_MIDICLASS_GEN               0x1314
#define IDD_DEVICE_DETAIL               0x1315
#define IDD_INSTRUMENT_GEN              0x1316
#define IDD_INSTRUMENT_DETAIL           0x1317
#define IDD_MIDIWIZ01                   0x1318
#define IDD_MIDIWIZ02                   0x1319
#define IDD_MIDIWIZ03                   0x131A
#define IDD_MIDIWIZ04                   0x131B
#define ADVVIDEODLG                     0x131C
#define ID_ADVVIDEO_COMPAT              0x131D
#define ID_VIDEO_ADVANCED               0x131E
#define IDD_ROLAND                      0x131F
#define BROWSEDLGTEMPLATE               0x1320
#define IDD_SPEAKERS                    0x1321
#define IDD_PLAYBACKPERF                0x1322
#define IDD_CAPTUREPERF                 0x1323
#define DLG_PP_DRIVERSETTINGS           0x1324
#define IDD_SPEECH                      0x1325
#define HWDLG                           0x1326
#define DM_ADVDLG                       0x1327
#define DM_CDDLG                        0x1328
#define IDD_VOLUME                      0x1329
#define VOICEDLG                        0x132A
#define IDD_MULTICHANNEL                0x132B
#define EFFECTSDLG                      0x132C
#define IDD_ADDEFFECTSDLG               0x132D

////////////////////////////////////////////////////////////////////
// MENUS
////////////////////////////////////////////////////////////////////

#define POPUP_TREE_CONTEXT              0x1400
#define MMSE_YES                        0x1401
#define MMSE_NO                         0x1402
#define MMSE_CANCEL                     0x1403
#define MMSE_OK                         0x1404
#define MMSE_YESNO                      0x1405
#define MMSE_YESNOCANCEL                0x1406
#define MMSE_TEXT                       0x1407



////////////////////////////////////////////////////////////////////
// STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_EVENTSNAME                  (ID_BASE_STRINGS + 0x0000)
#define IDS_EVENTSINFO                  (ID_BASE_STRINGS + 0x0001)
#define IDS_AUDIOPROPERTIES             (ID_BASE_STRINGS + 0x0002)
#define IDS_ADVAUDIOTITLE               (ID_BASE_STRINGS + 0x0003)
#define IDS_ABOUT_TITLE                 (ID_BASE_STRINGS + 0x0004)
#define IDS_ABOUT_VERSION               (ID_BASE_STRINGS + 0x0005)
#define IDS_PRIORITY_FROMTO             (ID_BASE_STRINGS + 0x0006)
#define IDS_TXT_DISABLED                (ID_BASE_STRINGS + 0x0007)
#define IDS_CUSTOMIZE                   (ID_BASE_STRINGS + 0x0008)
#define IDS_HIGHQUALITY                 (ID_BASE_STRINGS + 0x0009)
#define IDS_MEDIUMQUALITY               (ID_BASE_STRINGS + 0x000A)
#define IDS_LOWQUALITY                  (ID_BASE_STRINGS + 0x000B)
#define IDS_1QSCREENSIZE                (ID_BASE_STRINGS + 0x000C)
#define IDS_2QSCREENSIZE                (ID_BASE_STRINGS + 0x000D)
#define IDS_3QSCREENSIZE                (ID_BASE_STRINGS + 0x000E)
#define IDS_VIDEOMAXIMIZED              (ID_BASE_STRINGS + 0x000F)
#define IDS_NOAUDIOPLAY                 (ID_BASE_STRINGS + 0x0010)
#define IDS_NOAUDIOREC                  (ID_BASE_STRINGS + 0x0011)
#define IDS_TRAYVOLLNK                  (ID_BASE_STRINGS + 0x0012)
#define IDS_NORMALSIZE                  (ID_BASE_STRINGS + 0x0013)
#define IDS_ZOOMEDSIZE                  (ID_BASE_STRINGS + 0x0014)
#define IDS_NOMIDIPLAY                  (ID_BASE_STRINGS + 0x0015)
#define IDS_SYSREMOVE                   (ID_BASE_STRINGS + 0x0017)
#define IDS_REMOVED                     (ID_BASE_STRINGS + 0x0018)
#define IDS_RESTART                     (ID_BASE_STRINGS + 0x0019)
#define IDS_DELETE                      (ID_BASE_STRINGS + 0x001A)
#define IDS_MMDRIVERS                   (ID_BASE_STRINGS + 0x001B)
#define IDS_GENERAL                     (ID_BASE_STRINGS + 0x001C)
#define IDS_NOPROP                      (ID_BASE_STRINGS + 0x001D)
#define IDS_DEVDISABLEDOK               (ID_BASE_STRINGS + 0x001E)
#define IDS_DEVDISABLED                 (ID_BASE_STRINGS + 0x001F)
#define IDS_REMOVEWARN                  (ID_BASE_STRINGS + 0x0020)
#define IDS_REINSTALL                   (ID_BASE_STRINGS + 0x0021)
#define IDS_ADVANCED                    (ID_BASE_STRINGS + 0x0022)
#define IDS_DEVENABLEDOK                (ID_BASE_STRINGS + 0x0023)
#define IDS_DEVENABLEDNOTOK             (ID_BASE_STRINGS + 0x0024)
#define IDS_CHANGESAVED                 (ID_BASE_STRINGS + 0x0025)
#define IDS_COLLAPSE                    (ID_BASE_STRINGS + 0x0026)
#define IDS_DEVFRIENDLYYESNO            (ID_BASE_STRINGS + 0x0027)
#define IDS_FRIENDLYWARNING             (ID_BASE_STRINGS + 0x0028)
#define IDS_FRIENDLYNAME                (ID_BASE_STRINGS + 0x0029)
#define IDS_INSTRFRIENDLYYESNO          (ID_BASE_STRINGS + 0x002A)
#define IDS_NODEVS                      (ID_BASE_STRINGS + 0x002B)
#define IDS_NONE                        (ID_BASE_STRINGS + 0x002C)
#define IDS_ACMREMOVEFAIL               (ID_BASE_STRINGS + 0x002D)
#define IDS_AUDIOFOR                    (ID_BASE_STRINGS + 0x002E)
#define IDS_MIDIFOR                     (ID_BASE_STRINGS + 0x002F)
#define IDS_MIXERFOR                    (ID_BASE_STRINGS + 0x0030)
#define IDS_AUXFOR                      (ID_BASE_STRINGS + 0x0031)
#define IDS_ENABLEAUDIO                 (ID_BASE_STRINGS + 0x0032)
#define IDS_ENABLEMIDI                  (ID_BASE_STRINGS + 0x0033)
#define IDS_ENABLEMIXER                 (ID_BASE_STRINGS + 0x0034)
#define IDS_ENABLEAUX                   (ID_BASE_STRINGS + 0x0035)
#define IDS_ENABLEMCI                   (ID_BASE_STRINGS + 0x0036)
#define IDS_ENABLEACM                   (ID_BASE_STRINGS + 0x0037)
#define IDS_ENABLEICM                   (ID_BASE_STRINGS + 0x0038)
#define IDS_ENABLECAP                   (ID_BASE_STRINGS + 0x0039)
#define IDS_ENABLEJOY                   (ID_BASE_STRINGS + 0x003A)
#define IDS_DISABLEAUDIO                (ID_BASE_STRINGS + 0x003B)
#define IDS_DISABLEMIDI                 (ID_BASE_STRINGS + 0x003C)
#define IDS_DISABLEMIXER                (ID_BASE_STRINGS + 0x003D)
#define IDS_DISABLEAUX                  (ID_BASE_STRINGS + 0x003E)
#define IDS_DISABLEMCI                  (ID_BASE_STRINGS + 0x003F)
#define IDS_DISABLEACM                  (ID_BASE_STRINGS + 0x0040)
#define IDS_DISABLEICM                  (ID_BASE_STRINGS + 0x0041)
#define IDS_DISABLECAP                  (ID_BASE_STRINGS + 0x0042)
#define IDS_DISABLEJOY                  (ID_BASE_STRINGS + 0x0043)
#define IDS_CANTLOADACM                 (ID_BASE_STRINGS + 0x0044)
#define IDS_REMOVEHARDWAREWARN          (ID_BASE_STRINGS + 0x0045)
#define IDS_AUDIO                       (ID_BASE_STRINGS + 0x0046)
#define IDS_MIDI                        (ID_BASE_STRINGS + 0x0047)
#define IDS_MIXER                       (ID_BASE_STRINGS + 0x0048)
#define IDS_AUX                         (ID_BASE_STRINGS + 0x0049)
#define IDS_ACM                         (ID_BASE_STRINGS + 0x004A)
#define IDS_ICM                         (ID_BASE_STRINGS + 0x004B)
#define IDS_CAP                         (ID_BASE_STRINGS + 0x004C)
#define IDS_JOY                         (ID_BASE_STRINGS + 0x004D)
#define IDS_SYSREMOVEINFO               (ID_BASE_STRINGS + 0x004E)
#define IDS_REMOVEPNPWARN               (ID_BASE_STRINGS + 0x004F)
#define IDS_REMOVEMULTIPORTMIDI         (ID_BASE_STRINGS + 0x0050)
#define IDS_DISABLE                     (ID_BASE_STRINGS + 0x0051)
#define IDS_DISABLEMULTIPORTMIDI        (ID_BASE_STRINGS + 0x0052)
#define IDS_ENABLE                      (ID_BASE_STRINGS + 0x0053)
#define IDS_ENABLEMULTIPORTMIDI         (ID_BASE_STRINGS + 0x0054)
#define IDS_DEVENABLEDNODRIVER          (ID_BASE_STRINGS + 0x0055)
#define IDS_PNPPROBLEM                  (ID_BASE_STRINGS + 0x0056)
#define IDS_NOSNDVOL                    (ID_BASE_STRINGS + 0x0057)
#define IDS_RESTART_NOSOUND             (ID_BASE_STRINGS + 0x0058)
#define IDS_SPEECH_NAME                 (ID_BASE_STRINGS + 0x0059)
#define IDS_DESCRIPTION                 (ID_BASE_STRINGS + 0x005A)
#define IDS_CAPTION                     (ID_BASE_STRINGS + 0x005B)
#define IDS_E_INSTALL                   (ID_BASE_STRINGS + 0x005C)
#define IDS_E_ENGINE                    (ID_BASE_STRINGS + 0x005D)
#define IDS_MM_HEADER                   (ID_BASE_STRINGS + 0x005E)
#define IDS_AUX_HEADER                  (ID_BASE_STRINGS + 0x005F)
#define IDS_MIDI_HEADER                 (ID_BASE_STRINGS + 0x0060)
#define IDS_MIXER_HEADER                (ID_BASE_STRINGS + 0x0061)
#define IDS_WAVE_HEADER                 (ID_BASE_STRINGS + 0x0062)
#define IDS_MCI_HEADER                  (ID_BASE_STRINGS + 0x0063)
#define IDS_ACM_HEADER                  (ID_BASE_STRINGS + 0x0064)
#define IDS_ICM_HEADER                  (ID_BASE_STRINGS + 0x0065)
#define IDS_OTHER_HEADER                (ID_BASE_STRINGS + 0x0066)
#define IDS_VIDCAP_HEADER               (ID_BASE_STRINGS + 0x0067)
#define IDS_JOYSTICK_HEADER             (ID_BASE_STRINGS + 0x0068)
#define IDS_AUDIO_TAB                   (ID_BASE_STRINGS + 0x0069)
#define IDS_VIDEO_TAB                   (ID_BASE_STRINGS + 0x006A)
#define IDS_CDAUDIO_TAB                 (ID_BASE_STRINGS + 0x006B)
#define IDS_MIDI_TAB                    (ID_BASE_STRINGS + 0x006C)
#define IDS_VIDEO                       (ID_BASE_STRINGS + 0x006D)
#define IDS_CDMUSIC                     (ID_BASE_STRINGS + 0x006E)
#define IDS_AUDHW1                      (ID_BASE_STRINGS + 0x006F)
#define IDS_AUDHW2                      (ID_BASE_STRINGS + 0x0070)
#define IDS_AUDHW3                      (ID_BASE_STRINGS + 0x0071)
#define IDS_AUDHW4                      (ID_BASE_STRINGS + 0x0072)
#define IDS_SRCQUALITY1                 (ID_BASE_STRINGS + 0x0073)
#define IDS_SRCQUALITY2                 (ID_BASE_STRINGS + 0x0074)
#define IDS_SRCQUALITY3                 (ID_BASE_STRINGS + 0x0075)
#define IDS_SPEAKER1                    (ID_BASE_STRINGS + 0x0076)
#define IDS_SPEAKER2                    (ID_BASE_STRINGS + 0x0077)
#define IDS_SPEAKER3                    (ID_BASE_STRINGS + 0x0078)
#define IDS_SPEAKER4                    (ID_BASE_STRINGS + 0x0079)
#define IDS_SPEAKER5                    (ID_BASE_STRINGS + 0x007A)
#define IDS_SPEAKER6                    (ID_BASE_STRINGS + 0x007B)
#define IDS_SPEAKER7                    (ID_BASE_STRINGS + 0x007C)
#define IDS_SPEAKER8                    (ID_BASE_STRINGS + 0x007D)
#define IDS_SPEAKER9                    (ID_BASE_STRINGS + 0x007E)
#define IDS_SPEAKER10                   (ID_BASE_STRINGS + 0x007F)
#define IDS_SPEAKER11                   (ID_BASE_STRINGS + 0x0080)
#define IDS_SPEAKER12                   (ID_BASE_STRINGS + 0x0081)
#define IDS_SPEAKER13                   (ID_BASE_STRINGS + 0x0082)
#define IDS_ERROR_TITLE                 (ID_BASE_STRINGS + 0x0083)
#define IDS_ERROR_NOSNDVOL              (ID_BASE_STRINGS + 0x0084)
#define IDS_ERROR_NOMIXER               (ID_BASE_STRINGS + 0x0085)
#define IDS_USEANYDEVICE                (ID_BASE_STRINGS + 0x0086)
#define IDS_ERROR_DSPRIVS               (ID_BASE_STRINGS + 0x0087)
#define IDS_ERROR_DSGENERAL             (ID_BASE_STRINGS + 0x0088)
#define IDS_E_MICWIZARD                 (ID_BASE_STRINGS + 0x0089)
#define IDS_HARDWARE                    (ID_BASE_STRINGS + 0x008A)
#define IDS_MMNAME                      (ID_BASE_STRINGS + 0x008B)
#define IDS_MMINFO                      (ID_BASE_STRINGS + 0x008C)
#define IDS_MMHELP                      (ID_BASE_STRINGS + 0x008D)
#define IDS_VOLUMENAME                  (ID_BASE_STRINGS + 0x008E)
#define IDS_VOICE                       (ID_BASE_STRINGS + 0x008F)
#define IDS_ERROR_NOVOCVOL              (ID_BASE_STRINGS + 0x0090)
#define IDS_ERROR_NOVOCDIAG             (ID_BASE_STRINGS + 0x0091)
#define IDS_ERROR_VOICE_TITLE           (ID_BASE_STRINGS + 0x0092)
// Other Strings (mostly for Multichannel page)
#define IDS_MC_PLAYBACK                 (ID_BASE_STRINGS + 0x0093)
#define IDS_MC_RECORDING                (ID_BASE_STRINGS + 0x0094)
#define IDS_MC_OTHER                    (ID_BASE_STRINGS + 0x0095)
#define IDS_MC_PLAYBACK_DESC            (ID_BASE_STRINGS + 0x0096)
#define IDS_MC_RECORDING_DESC           (ID_BASE_STRINGS + 0x0097)
#define IDS_MC_OTHER_DESC               (ID_BASE_STRINGS + 0x0098)
#define IDS_OLD_CHANNEL_ZERO            (ID_BASE_STRINGS + 0x0099)
#define IDS_OLD_CHANNEL_ONE             (ID_BASE_STRINGS + 0x009A)
#define IDS_OLD_CHANNEL_TWO             (ID_BASE_STRINGS + 0x009B)
#define IDS_OLD_CHANNEL_THREE           (ID_BASE_STRINGS + 0x009C)
#define IDS_OLD_CHANNEL_FOUR            (ID_BASE_STRINGS + 0x009D)
#define IDS_OLD_CHANNEL_FIVE            (ID_BASE_STRINGS + 0x009E)
#define IDS_TIP_PLAY                    (ID_BASE_STRINGS + 0x009F)
#define IDS_MC_SPEAKER_LEFT             (ID_BASE_STRINGS + 0x00A0)
#define IDS_MC_SPEAKER_RIGHT            (ID_BASE_STRINGS + 0x00A1)
#define IDS_MC_SPEAKER_CENTER           (ID_BASE_STRINGS + 0x00A2)
#define IDS_MC_SPEAKER_BACKLEFT         (ID_BASE_STRINGS + 0x00A3)
#define IDS_MC_SPEAKER_BACKRIGHT        (ID_BASE_STRINGS + 0x00A4)
#define IDS_MC_SPEAKER_LOWFREQUENCY     (ID_BASE_STRINGS + 0x00A5)
#define IDS_NOGFXSET                    (ID_BASE_STRINGS + 0x00A7)
#define IDS_NOGFXFOUND                  (ID_BASE_STRINGS + 0x00A8)
#define IDS_MC_SPEAKER_BACKCENTER       (ID_BASE_STRINGS + 0x00A9)
#define IDS_MC_SPEAKER_LEFT_OF_CENTER   (ID_BASE_STRINGS + 0x00AA)
#define IDS_MC_SPEAKER_RIGHT_OF_CENTER  (ID_BASE_STRINGS + 0x00AB)
#define IDS_EFFECTS_PROPERTY_CAPTION    (ID_BASE_STRINGS + 0x00AC)

////////////////////////////////////////////////////////////////////
// Display names for Sound Events
// DO NOT CHANGE THESE - THEY ARE IN HIVEDEF.INX!!!!!!!!!!
////////////////////////////////////////////////////////////////////

#define IDS_REG_DEFAULT                 (ID_BASE_STRINGS + 0x00C0)
#define IDS_REG_APPGPF                  (ID_BASE_STRINGS + 0x00C1)
#define IDS_REG_CLOSE                   (ID_BASE_STRINGS + 0x00C2)
#define IDS_REG_CRITBATT                (ID_BASE_STRINGS + 0x00C3)
#define IDS_REG_DEVCONN                 (ID_BASE_STRINGS + 0x00C4)
#define IDS_REG_DEVDISCONN              (ID_BASE_STRINGS + 0x00C5)
#define IDS_REG_DEVFAIL                 (ID_BASE_STRINGS + 0x00C6)
#define IDS_REG_EMPTY                   (ID_BASE_STRINGS + 0x00C7)
#define IDS_REG_LOWBATT                 (ID_BASE_STRINGS + 0x00C8)
#define IDS_REG_MAX                     (ID_BASE_STRINGS + 0x00C9)
#define IDS_REG_MENUCMD                 (ID_BASE_STRINGS + 0x00CA)
#define IDS_REG_MENUPOP                 (ID_BASE_STRINGS + 0x00CB)
#define IDS_REG_MIN                     (ID_BASE_STRINGS + 0x00CC)
#define IDS_REG_MAIL                    (ID_BASE_STRINGS + 0x00CD)
#define IDS_REG_NAV                     (ID_BASE_STRINGS + 0x00CE)
#define IDS_REG_OPEN                    (ID_BASE_STRINGS + 0x00CF)
#define IDS_REG_PRINT                   (ID_BASE_STRINGS + 0x00D0)
#define IDS_REG_RESDOWN                 (ID_BASE_STRINGS + 0x00D1)
#define IDS_REG_RESUP                   (ID_BASE_STRINGS + 0x00D2)
#define IDS_REG_SYSAST                  (ID_BASE_STRINGS + 0x00D3)
#define IDS_REG_SYSDEF                  (ID_BASE_STRINGS + 0x00D4)
#define IDS_REG_SYSEXCL                 (ID_BASE_STRINGS + 0x00D5)
#define IDS_REG_SYSEXIT                 (ID_BASE_STRINGS + 0x00D6)
#define IDS_REG_SYSHAND                 (ID_BASE_STRINGS + 0x00D7)
#define IDS_REG_SYSNOT                  (ID_BASE_STRINGS + 0x00D8)
#define IDS_REG_SYSQUEST                (ID_BASE_STRINGS + 0x00D9)
#define IDS_REG_SYSSTART                (ID_BASE_STRINGS + 0x00DA)
#define IDS_REG_SYSMENU                 (ID_BASE_STRINGS + 0x00DB)
#define IDS_REG_LOGOFF                  (ID_BASE_STRINGS + 0x00DC)
#define IDS_REG_LOGON                   (ID_BASE_STRINGS + 0x00DD)

#define IDS_REG_EXPLORE                 (ID_BASE_STRINGS + 0x00DE)
#define IDS_REG_HARDWARE                (ID_BASE_STRINGS + 0x00DF)
#define IDS_REG_WINDOWS                 (ID_BASE_STRINGS + 0x00E0)

////////////////////////////////////////////////////////////////////
// CHANNEL STRINGS (Must be in sequential order)
////////////////////////////////////////////////////////////////////

#define IDS_MC_CHANNEL_ZERO             (ID_BASE_CHANNEL_STRINGS + 0x0000)
#define IDS_MC_CHANNEL_ONE              (ID_BASE_CHANNEL_STRINGS + 0x0001)
#define IDS_MC_CHANNEL_TWO              (ID_BASE_CHANNEL_STRINGS + 0x0002)
#define IDS_MC_CHANNEL_THREE            (ID_BASE_CHANNEL_STRINGS + 0x0003)
#define IDS_MC_CHANNEL_FOUR             (ID_BASE_CHANNEL_STRINGS + 0x0004)
#define IDS_MC_CHANNEL_FIVE             (ID_BASE_CHANNEL_STRINGS + 0x0005)
#define IDS_MC_CHANNEL_SIX              (ID_BASE_CHANNEL_STRINGS + 0x0006)
#define IDS_MC_CHANNEL_SEVEN            (ID_BASE_CHANNEL_STRINGS + 0x0007)


////////////////////////////////////////////////////////////////////
// FILE PROPERTY STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_FOURCC_IARL                 (ID_BASE_FILEPROP_STRINGS + 0x0000)
#define IDS_FOURCC_IART                 (ID_BASE_FILEPROP_STRINGS + 0x0001)
#define IDS_FOURCC_ICMS                 (ID_BASE_FILEPROP_STRINGS + 0x0002)
#define IDS_FOURCC_ICMT                 (ID_BASE_FILEPROP_STRINGS + 0x0003)
#define IDS_FOURCC_ICOP                 (ID_BASE_FILEPROP_STRINGS + 0x0004)
#define IDS_FOURCC_ICRD                 (ID_BASE_FILEPROP_STRINGS + 0x0005)
#define IDS_FOURCC_ICRP                 (ID_BASE_FILEPROP_STRINGS + 0x0006)
#define IDS_FOURCC_IDIM                 (ID_BASE_FILEPROP_STRINGS + 0x0007)
#define IDS_FOURCC_IDPI                 (ID_BASE_FILEPROP_STRINGS + 0x0008)
#define IDS_FOURCC_IENG                 (ID_BASE_FILEPROP_STRINGS + 0x0009)
#define IDS_FOURCC_IGNR                 (ID_BASE_FILEPROP_STRINGS + 0x000A)
#define IDS_FOURCC_IKEY                 (ID_BASE_FILEPROP_STRINGS + 0x000B)
#define IDS_FOURCC_ILGT                 (ID_BASE_FILEPROP_STRINGS + 0x000C)
#define IDS_FOURCC_IMED                 (ID_BASE_FILEPROP_STRINGS + 0x000D)
#define IDS_FOURCC_INAM                 (ID_BASE_FILEPROP_STRINGS + 0x000E)
#define IDS_FOURCC_IPLT                 (ID_BASE_FILEPROP_STRINGS + 0x000F)
#define IDS_FOURCC_IPRD                 (ID_BASE_FILEPROP_STRINGS + 0x0010)
#define IDS_FOURCC_ISBJ                 (ID_BASE_FILEPROP_STRINGS + 0x0011)
#define IDS_FOURCC_ISFT                 (ID_BASE_FILEPROP_STRINGS + 0x0012)
#define IDS_FOURCC_ISHP                 (ID_BASE_FILEPROP_STRINGS + 0x0013)
#define IDS_FOURCC_ISRC                 (ID_BASE_FILEPROP_STRINGS + 0x0014)
#define IDS_FOURCC_ISRF                 (ID_BASE_FILEPROP_STRINGS + 0x0015)
#define IDS_FOURCC_ITCH                 (ID_BASE_FILEPROP_STRINGS + 0x0016)
#define IDS_FOURCC_DISP                 (ID_BASE_FILEPROP_STRINGS + 0x0017)
#define IDS_NOCOPYRIGHT                 (ID_BASE_FILEPROP_STRINGS + 0x0018)
#define IDS_UNKFORMAT                   (ID_BASE_FILEPROP_STRINGS + 0x0019)
#define IDS_BADFILE                     (ID_BASE_FILEPROP_STRINGS + 0x001A)
#define IDS_MINFMT                      (ID_BASE_FILEPROP_STRINGS + 0x001B)
#define IDS_SECFMT                      (ID_BASE_FILEPROP_STRINGS + 0x001C)
#define IDS_DETAILS                     (ID_BASE_FILEPROP_STRINGS + 0x001D)
#define IDS_PREVIEW                     (ID_BASE_FILEPROP_STRINGS + 0x001E)
#define IDS_PREVIEWOF                   (ID_BASE_FILEPROP_STRINGS + 0x001F)
#define IDS_GOODFORMAT                  (ID_BASE_FILEPROP_STRINGS + 0x0020)
#define IDS_BADFORMAT                   (ID_BASE_FILEPROP_STRINGS + 0x0021)
#define IDS_UNCOMPRESSED                (ID_BASE_FILEPROP_STRINGS + 0x0022)
#define IDS_FORMAT_PCM                  (ID_BASE_FILEPROP_STRINGS + 0x0023)
#define IDS_FORMAT_ADPCM                (ID_BASE_FILEPROP_STRINGS + 0x0024)
#define IDS_FORMAT_IBM_CVSD             (ID_BASE_FILEPROP_STRINGS + 0x0025)
#define IDS_FORMAT_ALAW                 (ID_BASE_FILEPROP_STRINGS + 0x0026)
#define IDS_FORMAT_MULAW                (ID_BASE_FILEPROP_STRINGS + 0x0027)
#define IDS_FORMAT_OKI_ADPCM            (ID_BASE_FILEPROP_STRINGS + 0x0028)
#define IDS_FORMAT_IMA_ADPCM            (ID_BASE_FILEPROP_STRINGS + 0x0029)
#define IDS_FORMAT_MEDIASPACE_ADPCM     (ID_BASE_FILEPROP_STRINGS + 0x002A)
#define IDS_FORMAT_SIERRA_ADPCM         (ID_BASE_FILEPROP_STRINGS + 0x002B)
#define IDS_FORMAT_G723_ADPCM           (ID_BASE_FILEPROP_STRINGS + 0x002C)
#define IDS_FORMAT_DIGISTD              (ID_BASE_FILEPROP_STRINGS + 0x002D)
#define IDS_FORMAT_DIGIFIX              (ID_BASE_FILEPROP_STRINGS + 0x002E)
#define IDS_FORMAT_YAMAHA_ADPCM         (ID_BASE_FILEPROP_STRINGS + 0x002F)
#define IDS_FORMAT_SONARC               (ID_BASE_FILEPROP_STRINGS + 0x0030)
#define IDS_FORMAT_DSPGROUP_TRUESPEECH  (ID_BASE_FILEPROP_STRINGS + 0x0031)
#define IDS_FORMAT_ECHOSC1              (ID_BASE_FILEPROP_STRINGS + 0x0032)
#define IDS_FORMAT_AUDIOFILE_AF36       (ID_BASE_FILEPROP_STRINGS + 0x0033)
#define IDS_FORMAT_APTX                 (ID_BASE_FILEPROP_STRINGS + 0x0034)
#define IDS_FORMAT_AUDIOFILE_AF10       (ID_BASE_FILEPROP_STRINGS + 0x0035)
#define IDS_FORMAT_DOLBY_AC2            (ID_BASE_FILEPROP_STRINGS + 0x0036)
#define IDS_FORMAT_GSM610               (ID_BASE_FILEPROP_STRINGS + 0x0037)
#define IDS_FORMAT_G721_ADPCM           (ID_BASE_FILEPROP_STRINGS + 0x0038)
#define IDS_FORMAT_CREATIVE_ADPCM       (ID_BASE_FILEPROP_STRINGS + 0x0039)


////////////////////////////////////////////////////////////////////
// EVENT STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_BROWSEFORSOUND              (ID_BASE_EVENTS_STRINGS + 0x0000)
#define IDS_UNKNOWN                     (ID_BASE_EVENTS_STRINGS + 0x0001)
#define IDS_REMOVESCHEME                (ID_BASE_EVENTS_STRINGS + 0x0002)
#define IDS_CHANGESCHEME                (ID_BASE_EVENTS_STRINGS + 0x0003)
#define IDS_SOUND                       (ID_BASE_EVENTS_STRINGS + 0x0004)
#define IDS_WINDOWSDEFAULT              (ID_BASE_EVENTS_STRINGS + 0x0005)
#define IDS_ERRORFILEPLAY               (ID_BASE_EVENTS_STRINGS + 0x0006)
#define IDS_ERRORUNKNOWNPLAY            (ID_BASE_EVENTS_STRINGS + 0x0007)
#define IDS_ERRORFORMATPLAY             (ID_BASE_EVENTS_STRINGS + 0x0008)
#define IDS_ERRORPLAY                   (ID_BASE_EVENTS_STRINGS + 0x0009)
#define IDS_NOWAVEDEV                   (ID_BASE_EVENTS_STRINGS + 0x000A)
#define IDS_NODESC                      (ID_BASE_EVENTS_STRINGS + 0x000B)
#define IDS_SAVESCHEME                  (ID_BASE_EVENTS_STRINGS + 0x000C)
#define IDS_CONFIRMREMOVE               (ID_BASE_EVENTS_STRINGS + 0x000D)
#define IDS_NOOVERWRITEDEFAULT          (ID_BASE_EVENTS_STRINGS + 0x000E)
#define IDS_SAVECHANGE                  (ID_BASE_EVENTS_STRINGS + 0x000F)
#define IDS_OVERWRITESCHEME             (ID_BASE_EVENTS_STRINGS + 0x0010)
#define IDS_ERRORDEVBUSY                (ID_BASE_EVENTS_STRINGS + 0x0011)
#define IDS_NONECHOSEN                  (ID_BASE_EVENTS_STRINGS + 0x0012)
#define IDS_DEFAULTAPP                  (ID_BASE_EVENTS_STRINGS + 0x0013)
#define IDS_INVALIDFILE                 (ID_BASE_EVENTS_STRINGS + 0x0014)
#define IDS_NULLCHAR                    (ID_BASE_EVENTS_STRINGS + 0x0015)
#define IDS_WAVFILES                    (ID_BASE_EVENTS_STRINGS + 0x0016)
#define IDS_NOSNDFILE                   (ID_BASE_EVENTS_STRINGS + 0x0017)
#define IDS_NOSNDFILETITLE              (ID_BASE_EVENTS_STRINGS + 0x0018)
#define IDS_OK                          (ID_BASE_EVENTS_STRINGS + 0x0019)
#define IDS_INVALIDFILEQUERY            (ID_BASE_EVENTS_STRINGS + 0x001A)
#define IDS_ISNOTSNDFILE                (ID_BASE_EVENTS_STRINGS + 0x001B)
#define IDS_SCHEMENOTSAVED              (ID_BASE_EVENTS_STRINGS + 0x001C)
#define IDS_PREVSCHEME                  (ID_BASE_EVENTS_STRINGS + 0x001D)

////////////////////////////////////////////////////////////////////
// MIDI STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_MMPROP                      (ID_BASE_MIDI_STRINGS + 0x0000)
#define IDS_NOCHAN                      (ID_BASE_MIDI_STRINGS + 0x0001)
#define IDS_CHANPLURAL                  (ID_BASE_MIDI_STRINGS + 0x0002)
#define IDS_CHANSINGULAR                (ID_BASE_MIDI_STRINGS + 0x0003)
#define IDS_MIDIDETAILS                 (ID_BASE_MIDI_STRINGS + 0x0004)
#define IDS_MIDI_DEV_AND_INST           (ID_BASE_MIDI_STRINGS + 0x0005)
#define IDS_UNSPECIFIED                 (ID_BASE_MIDI_STRINGS + 0x0006)
#define IDS_DEFAULT_SCHEME_NAME         (ID_BASE_MIDI_STRINGS + 0x0007)
#define IDS_RUNONCEWIZLABEL             (ID_BASE_MIDI_STRINGS + 0x0008)
#define IDS_DEF_DEFINITION              (ID_BASE_MIDI_STRINGS + 0x0009)
#define IDS_DEF_INSTRNAME               (ID_BASE_MIDI_STRINGS + 0x000A)
#define IDS_QUERY_DELETESCHEME          (ID_BASE_MIDI_STRINGS + 0x000B)
#define IDS_DEF_CAPTION                 (ID_BASE_MIDI_STRINGS + 0x000C)
#define IDS_QUERY_OVERSCHEME            (ID_BASE_MIDI_STRINGS + 0x000D)
#define IDS_WIZNAME                     (ID_BASE_MIDI_STRINGS + 0x000E)
#define IDS_IDFFILES                    (ID_BASE_MIDI_STRINGS + 0x000F)
#define IDS_IDF_CAPTION                 (ID_BASE_MIDI_STRINGS + 0x0010)
#define IDS_QUERY_OVERIDF               (ID_BASE_MIDI_STRINGS + 0x0011)
#define IDS_MAPPER_BUSY                 (ID_BASE_MIDI_STRINGS + 0x0012)

////////////////////////////////////////////////////////////////////
// SOME CONTROL ID's
////////////////////////////////////////////////////////////////////

#define IDC_CD_TB_VOLUME                (ID_SIMPLE_PROP + 0x0000)
#define IDC_CD_CB_SELECT                (ID_SIMPLE_PROP + 0x0001)
#define IDC_VIDEO_INWINDOW              (ID_SIMPLE_PROP + 0x0002)
#define IDC_VIDEO_FULLSCREEN            (ID_SIMPLE_PROP + 0x0003)
#define IDC_VIDEO_CB_SIZE               (ID_SIMPLE_PROP + 0x0004)
#define IDC_SCREENSAMPLE                (ID_SIMPLE_PROP + 0x0005)
#define IDC_AUDIO_CB_PLAY               (ID_SIMPLE_PROP + 0x0006)
#define IDC_AUDIO_CB_REC                (ID_SIMPLE_PROP + 0x0007)
#define IDC_MUSIC_CB_PLAY               (ID_SIMPLE_PROP + 0x0008)
#define IDC_AUDIO_PREF                  (ID_SIMPLE_PROP + 0x0009)
#define IDC_TASKBAR_VOLUME              (ID_SIMPLE_PROP + 0x000A)
#define IDC_LAUNCH_SNDVOL               (ID_SIMPLE_PROP + 0x000B)
#define IDC_LAUNCH_RECVOL               (ID_SIMPLE_PROP + 0x000C)
#define IDC_LAUNCH_MUSICVOL             (ID_SIMPLE_PROP + 0x000D)
#define IDC_PLAYBACK_ADVSETUP           (ID_SIMPLE_PROP + 0x000E)
#define IDC_MASTERVOLUME                (ID_SIMPLE_PROP + 0x000F)
#define IDC_RECORD_ADVSETUP             (ID_SIMPLE_PROP + 0x0010)
#define IDC_MUSIC_ABOUT                 (ID_SIMPLE_PROP + 0x0011)
#define IDC_VOLUME_LOW                  (ID_SIMPLE_PROP + 0x0012)
#define IDC_VOLUME_HIGH                 (ID_SIMPLE_PROP + 0x0013)
#define ID_APPLY                        (ID_SIMPLE_PROP + 0x0014)
#define ID_INIT                         (ID_SIMPLE_PROP + 0x0015)
#define ID_REMOVE                       (ID_SIMPLE_PROP + 0x0016)
#define ID_REBUILD                      (ID_SIMPLE_PROP + 0x0017)
#define IDC_CDEN_DIGAUDIO               (ID_SIMPLE_PROP + 0x0018)
#define IDC_SOUND_FILES                 (ID_SIMPLE_PROP + 0x0019)
#define IDC_EVENT_TREE                  (ID_SIMPLE_PROP + 0x001A)
#define IDD_INPUT                       (ID_SIMPLE_PROP + 0x001B)
#define IDC_TTS_ABOUT                   (ID_SIMPLE_PROP + 0x001C)
#define IDC_SR_MIC                      (ID_SIMPLE_PROP + 0x001D)
#define IDC_SRLIST                      (ID_SIMPLE_PROP + 0x001E)
#define IDC_SR_GENERAL                  (ID_SIMPLE_PROP + 0x001F)
#define IDC_SR_ABOUT                    (ID_SIMPLE_PROP + 0x0020)
#define IDC_SR_TRAIN                    (ID_SIMPLE_PROP + 0x0021)
#define IDC_SR_PRONUNCIATION            (ID_SIMPLE_PROP + 0x0022)
#define IDC_TTSLIST                     (ID_SIMPLE_PROP + 0x0023)
#define IDC_TTS_TRANSLATE               (ID_SIMPLE_PROP + 0x0024)
#define IDC_TTS_GENERAL                 (ID_SIMPLE_PROP + 0x0025)
#define IDC_TTS_PRONUNCIATION           (ID_SIMPLE_PROP + 0x0026)
#define IDD_OUTPUT                      (ID_SIMPLE_PROP + 0x0027)
#define IDC_VOLUME_MIXER                (ID_SIMPLE_PROP + 0x0028)
#define IDC_VOLUME_MUTE                 (ID_SIMPLE_PROP + 0x0029)
#define IDC_LAUNCH_MULTICHANNEL         (ID_SIMPLE_PROP + 0x0030)
#define IDC_STATIC_EVENT                (ID_SIMPLE_PROP + 0x0031)

////////////////////////////////////////////////////////////////////
// ADVANCED PROPERTY CONTROLS
////////////////////////////////////////////////////////////////////

#define IDD_CPL_BTN_ABOUT               (ID_ADVANCED_PROP + 0x0000)
#define IDD_ABOUT_TXT_DESCRIPTION       (ID_ADVANCED_PROP + 0x0001)
#define IDD_ABOUT_TXT_VERSION           (ID_ADVANCED_PROP + 0x0002)
#define IDD_ABOUT_TXT_COPYRIGHT         (ID_ADVANCED_PROP + 0x0003)
#define IDD_ABOUT_TXT_LICENSING         (ID_ADVANCED_PROP + 0x0004)
#define IDD_ABOUT_TXT_FEATURES          (ID_ADVANCED_PROP + 0x0005)
#define IDD_PRIORITY_TXT_FROMTO         (ID_ADVANCED_PROP + 0x0006)
#define IDD_PRIORITY_COMBO_PRIORITY     (ID_ADVANCED_PROP + 0x0007)
#define IDD_ABOUT_ICON_DRIVER           (ID_ADVANCED_PROP + 0x0008)
#define IDC_DONOTMAP                    (ID_ADVANCED_PROP + 0x0009)
#define ID_TOGGLE                       (ID_ADVANCED_PROP + 0x000A)
#define ID_ADV_REMOVE                   (ID_ADVANCED_PROP + 0x000B)
#define IDC_ENABLE                      (ID_ADVANCED_PROP + 0x000C)
#define IDC_DISABLE                     (ID_ADVANCED_PROP + 0x000D)
#define IDC_DEV_ICON                    (ID_ADVANCED_PROP + 0x000E)
#define IDC_DEV_DESC                    (ID_ADVANCED_PROP + 0x000F)
#define IDC_DEV_STATUS                  (ID_ADVANCED_PROP + 0x0010)
#define ID_DEV_SETTINGS                 (ID_ADVANCED_PROP + 0x0011)
#define ID_WHATSTHIS                    (ID_ADVANCED_PROP + 0x0012)
#define IDC_ADV_TREE                    (ID_ADVANCED_PROP + 0x0013)
#define IDC_DEVICECLASS                 (ID_ADVANCED_PROP + 0x0014)



////////////////////////////////////////////////////////////////////
// CONTROL IDS
////////////////////////////////////////////////////////////////////

#define IDC_IMAGEFRAME                  (ID_BASE_CONTROL + 0x0000)
#define IDD_DISPFRAME                   (ID_BASE_CONTROL + 0x0001)
#define IDD_FILENAME                    (ID_BASE_CONTROL + 0x0002)
#define IDD_CRLABEL                     (ID_BASE_CONTROL + 0x0003)
#define IDD_COPYRIGHT                   (ID_BASE_CONTROL + 0x0004)
#define IDD_LENLABEL                    (ID_BASE_CONTROL + 0x0005)
#define IDD_FILELEN                     (ID_BASE_CONTROL + 0x0006)
#define IDD_AUDIOFORMAT                 (ID_BASE_CONTROL + 0x0007)
#define IDD_AUDIOFORMATLABEL            (ID_BASE_CONTROL + 0x0008)
#define IDD_VIDEOFORMAT                 (ID_BASE_CONTROL + 0x0009)
#define IDD_VIDEOFORMATLABEL            (ID_BASE_CONTROL + 0x000A)
#define IDD_INFO_NAME                   (ID_BASE_CONTROL + 0x000B)
#define IDD_INFO_VALUE                  (ID_BASE_CONTROL + 0x000C)
#define IDD_DISP_ICON                   (ID_BASE_CONTROL + 0x000D)
#define IDC_DETAILSINFO_GRP             (ID_BASE_CONTROL + 0x000E)
#define IDC_ITEMSLABEL                  (ID_BASE_CONTROL + 0x000F)
#define IDC_DESCLABEL                   (ID_BASE_CONTROL + 0x0010)
#define IDD_MIDISEQUENCELABEL           (ID_BASE_CONTROL + 0x0011)
#define IDD_MIDISEQUENCENAME            (ID_BASE_CONTROL + 0x0012)
#define IDC_ACCELERATION                (ID_BASE_CONTROL + 0x0013)
#define IDC_SRCQUALITY                  (ID_BASE_CONTROL + 0x0014)
#define IDC_PREFERREDONLY               (ID_BASE_CONTROL + 0x0015)
#define IDC_HWMESSAGE                   (ID_BASE_CONTROL + 0x0016)
#define IDC_SRCMSG                      (ID_BASE_CONTROL + 0x0017)
#define IDC_DEFAULTS                    (ID_BASE_CONTROL + 0x0018)
#define IDC_SPEAKERCONFIG               (ID_BASE_CONTROL + 0x0019)
#define IDAPPLY                         (ID_BASE_CONTROL + 0x001A)
#define IDC_VOLUME_BRAND                (ID_BASE_CONTROL + 0x001B)
#define IDC_VOLUME_ICON                 (ID_BASE_CONTROL + 0x001C)
#define IDC_VOLUME_SPEAKER_BITMAP       (ID_BASE_CONTROL + 0x001D)
#define IDC_VOLUME_ICON_BRAND           (ID_BASE_CONTROL + 0x001E)


////////////////////////////////////////////////////////////////////
// MIDI CONTROL IDS
////////////////////////////////////////////////////////////////////

#define IDC_INSTRUMENTS                 (ID_MIDI_PROP + 0x0000)
#define IDC_SCHEMES                     (ID_MIDI_PROP + 0x0001)
#define IDL_CHANNELS                    (ID_MIDI_PROP + 0x0002)
#define IDE_SHOW_CHANNELS               (ID_MIDI_PROP + 0x0003)
#define IDE_SCHEMENAME                  (ID_MIDI_PROP + 0x0004)
#define IDB_DETAILS                     (ID_MIDI_PROP + 0x0005)
#define IDC_RADIO_SINGLE                (ID_MIDI_PROP + 0x0006)
#define IDC_RADIO_CUSTOM                (ID_MIDI_PROP + 0x0007)
#define IDB_CONFIGURE                   (ID_MIDI_PROP + 0x0008)
#define IDB_DELETE                      (ID_MIDI_PROP + 0x0009)
#define IDB_SAVE_AS                     (ID_MIDI_PROP + 0x000A)
#define IDB_CHANGE                      (ID_MIDI_PROP + 0x000B)
#define IDB_REMOVE                      (ID_MIDI_PROP + 0x000C)
#define IDE_ALIAS                       (ID_MIDI_PROP + 0x000D)
#define IDC_TYPES                       (ID_MIDI_PROP + 0x000E)
#define IDC_DEVICES                     (ID_MIDI_PROP + 0x000F)
#define IDL_INSTRUMENTS                 (ID_MIDI_PROP + 0x0010)
#define IDC_CLASS_ICON                  (ID_MIDI_PROP + 0x0011)
#define IDC_INSTRUMENT_LABEL            (ID_MIDI_PROP + 0x0012)
#define IDC_CLASS_LABEL                 (ID_MIDI_PROP + 0x0013)
#define IDC_DEVICE_TYPE                 (ID_MIDI_PROP + 0x0014)
#define IDC_MANUFACTURER                (ID_MIDI_PROP + 0x0015)
#define IDB_NEWTYPE                     (ID_MIDI_PROP + 0x0016)
#define IDB_ADDWIZ                      (ID_MIDI_PROP + 0x0017)
#define IDC_WIZBMP                      (ID_MIDI_PROP + 0x0018)
#define IDC_GROUPBOX                    (ID_MIDI_PROP + 0x0019)
#define IDC_SCHEMESLABEL                (ID_MIDI_PROP + 0x001A)
#define IDC_TEXT_1                      (ID_MIDI_PROP + 0x001B)
#define IDC_TEXT_2                      (ID_MIDI_PROP + 0x001C)
#define IDC_TEXT_3                      (ID_MIDI_PROP + 0x001D)
#define IDC_TEXT_4                      (ID_MIDI_PROP + 0x001E)
#define IDC_TEXT_5                      (ID_MIDI_PROP + 0x001F)
#define IDC_TEXT_6                      (ID_MIDI_PROP + 0x0020)
#define IDC_TEXT_7                      (ID_MIDI_PROP + 0x0021)
#define IDC_TEXT_8                      (ID_MIDI_PROP + 0x0022)
#define IDC_TEXT_9                      (ID_MIDI_PROP + 0x0023)
#define IDC_GROUPBOX_2                  (ID_MIDI_PROP + 0x0024)
#define IDC_ICON_1                      (ID_MIDI_PROP + 0x0025)
#define IDC_ICON_2                      (ID_MIDI_PROP + 0x0026)
#define IDE_TYPES                       (ID_MIDI_PROP + 0x0027)
#define IDC_TEXT_10                     (ID_MIDI_PROP + 0x0028)
#define IDC_TEXT_11                     (ID_MIDI_PROP + 0x0029)
#define IDC_TEXT_12                     (ID_MIDI_PROP + 0x002A)
#define IDC_TEXT_13                     (ID_MIDI_PROP + 0x002B)
#define IDC_TEXT_14                     (ID_MIDI_PROP + 0x002C)
#define IDC_TEXT_15                     (ID_MIDI_PROP + 0x002E)
#define IDC_TEXT_16                     (ID_MIDI_PROP + 0x002F)
#define IDC_TEXT_17                     (ID_MIDI_PROP + 0x0030)
#define IDC_TEXT_18                     (ID_MIDI_PROP + 0x0031)
#define IDC_TEXT_19                     (ID_MIDI_PROP + 0x0032)
#define IDC_TEXT_20                     (ID_MIDI_PROP + 0x0033)
#define IDC_TEXT_21                     (ID_MIDI_PROP + 0x0034)
#define IDC_TEXT_22                     (ID_MIDI_PROP + 0x0035)
#define IDC_TEXT_23                     (ID_MIDI_PROP + 0x0036)
#define IDC_TEXT_24                     (ID_MIDI_PROP + 0x0037)
#define IDC_TEXT_25                     (ID_MIDI_PROP + 0x0038)
#define IDC_TEXT_26                     (ID_MIDI_PROP + 0x0039)
#define IDC_TEXT_27                     (ID_MIDI_PROP + 0x003A)
#define IDC_TEXT_28                     (ID_MIDI_PROP + 0x003B)
#define IDC_TEXT_29                     (ID_MIDI_PROP + 0x003C)
#define IDC_TEXT_30                     (ID_MIDI_PROP + 0x003D)
#define IDC_TEXT_31                     (ID_MIDI_PROP + 0x003E)
#define IDC_TEXT_32                     (ID_MIDI_PROP + 0x003F)
#define IDC_ICON_3                      (ID_MIDI_PROP + 0x0040)
#define IDC_ICON_4                      (ID_MIDI_PROP + 0x0041)
#define IDC_ICON_5                      (ID_MIDI_PROP + 0x0042)
#define IDC_ICON_6                      (ID_MIDI_PROP + 0x0043)
#define IDC_ICON_7                      (ID_MIDI_PROP + 0x0044)
#define IDC_ICON_8                      (ID_MIDI_PROP + 0x0045)
#define IDC_ABOUTSYNTH                  (ID_MIDI_PROP + 0x0046)
#define IDC_LOGO_FRAME                  (ID_MIDI_PROP + 0x0047)
#define IDC_RENDERER                    (ID_MIDI_PROP + 0x0048)
#define IDC_GROUPBOX_3                  (ID_MIDI_PROP + 0x0049)
#define IDC_TEXT_33                     (ID_MIDI_PROP + 0x004A)


////////////////////////////////////////////////////////////////////
// EVENTS IDS
////////////////////////////////////////////////////////////////////

#define ID_SCHEMENAME                   (ID_EVENTS_START + 0x0000)
#define LB_INSTALLED                    (ID_EVENTS_START + 0x0001)
#define ID_PLAY                         (ID_EVENTS_START + 0x0002)
#define ID_REMOVE_SCHEME                (ID_EVENTS_START + 0x0004)
#define ID_SAVE_SCHEME                  (ID_EVENTS_START + 0x0005)
#define CB_SCHEMES                      (ID_EVENTS_START + 0x0006)
#define ID_INSTALL                      (ID_EVENTS_START + 0x0007)
#define ID_CONFIGURE                    (ID_EVENTS_START + 0x0008)
#define ID_STOP                         (ID_EVENTS_START + 0x0009)
#define ID_BROWSE                       (ID_EVENTS_START + 0x000B)
#define IDC_STATIC_PREVIEW              (ID_EVENTS_START + 0x000C)
#define IDC_STATIC_NAME                 (ID_EVENTS_START + 0x000D)
#define IDC_SOUNDGRP                    (ID_EVENTS_START + 0x000E)
#define ID_DESC                         (ID_EVENTS_START + 0x000F)
#define ID_SAVEAS_HELP                  (ID_EVENTS_START + 0x0010)

////////////////////////////////////////////////////////////////////
// Multichannel Page ID's
////////////////////////////////////////////////////////////////////

#define IDC_MC_ZERO                     (ID_MULTICHANNEL_PROP + 0x0000)
#define IDC_MC_ZERO_LOW                 (ID_MULTICHANNEL_PROP + 0x0001)
#define IDC_MC_ZERO_HIGH                (ID_MULTICHANNEL_PROP + 0x0002)
#define IDC_MC_ZERO_VOLUME              (ID_MULTICHANNEL_PROP + 0x0003)
#define IDC_MC_ONE                      (ID_MULTICHANNEL_PROP + 0x0004)
#define IDC_MC_ONE_LOW                  (ID_MULTICHANNEL_PROP + 0x0005)
#define IDC_MC_ONE_HIGH                 (ID_MULTICHANNEL_PROP + 0x0006)
#define IDC_MC_ONE_VOLUME               (ID_MULTICHANNEL_PROP + 0x0007)
#define IDC_MC_TWO                      (ID_MULTICHANNEL_PROP + 0x0008)
#define IDC_MC_TWO_LOW                  (ID_MULTICHANNEL_PROP + 0x0009)
#define IDC_MC_TWO_HIGH                 (ID_MULTICHANNEL_PROP + 0x000A)
#define IDC_MC_TWO_VOLUME               (ID_MULTICHANNEL_PROP + 0x000B)
#define IDC_MC_THREE                    (ID_MULTICHANNEL_PROP + 0x000C)
#define IDC_MC_THREE_LOW                (ID_MULTICHANNEL_PROP + 0x000D)
#define IDC_MC_THREE_HIGH               (ID_MULTICHANNEL_PROP + 0x000E)
#define IDC_MC_THREE_VOLUME             (ID_MULTICHANNEL_PROP + 0x000F)
#define IDC_MC_FOUR                     (ID_MULTICHANNEL_PROP + 0x0010)
#define IDC_MC_FOUR_LOW                 (ID_MULTICHANNEL_PROP + 0x0011)
#define IDC_MC_FOUR_HIGH                (ID_MULTICHANNEL_PROP + 0x0012)
#define IDC_MC_FOUR_VOLUME              (ID_MULTICHANNEL_PROP + 0x0013)
#define IDC_MC_FIVE                     (ID_MULTICHANNEL_PROP + 0x0014)
#define IDC_MC_FIVE_LOW                 (ID_MULTICHANNEL_PROP + 0x0015)
#define IDC_MC_FIVE_HIGH                (ID_MULTICHANNEL_PROP + 0x0016)
#define IDC_MC_FIVE_VOLUME              (ID_MULTICHANNEL_PROP + 0x0017)
#define IDC_MC_SIX                      (ID_MULTICHANNEL_PROP + 0x0018)
#define IDC_MC_SIX_LOW                  (ID_MULTICHANNEL_PROP + 0x0019)
#define IDC_MC_SIX_HIGH                 (ID_MULTICHANNEL_PROP + 0x001A)
#define IDC_MC_SIX_VOLUME               (ID_MULTICHANNEL_PROP + 0x001B)
#define IDC_MC_SEVEN                    (ID_MULTICHANNEL_PROP + 0x001C)
#define IDC_MC_SEVEN_LOW                (ID_MULTICHANNEL_PROP + 0x001D)
#define IDC_MC_SEVEN_HIGH               (ID_MULTICHANNEL_PROP + 0x001E)
#define IDC_MC_SEVEN_VOLUME             (ID_MULTICHANNEL_PROP + 0x001F)
#define IDC_MC_MOVE_TOGETHER            (ID_MULTICHANNEL_PROP + 0x0020)
#define IDC_MC_RESTORE                  (ID_MULTICHANNEL_PROP + 0x0021)
#define IDC_MC_DESCRIPTION              (ID_MULTICHANNEL_PROP + 0x0022)

/*
 ***************************************************************
 * Defines for Voice CPL.
 ***************************************************************     
 */     
#define IDC_ICON_VOC_1                   (ID_VOICE_PROP + 0x0001) 
#define IDC_ICON_VOC_2                   (ID_VOICE_PROP + 0x0002) 
#define IDC_GROUPBOX_VOC_1               (ID_VOICE_PROP + 0x0003) 
#define IDC_GROUPBOX_VOC_2               (ID_VOICE_PROP + 0x0004) 
#define IDC_TEXT_VOC_1                   (ID_VOICE_PROP + 0x0005)
#define IDC_TEXT_VOC_2                   (ID_VOICE_PROP + 0x0006)
#define IDC_VOICE_CB_PLAY                (ID_VOICE_PROP + 0x0007)
#define IDC_VOICE_CB_REC                 (ID_VOICE_PROP + 0x0008)
#define IDC_LAUNCH_VOCVOL                (ID_VOICE_PROP + 0x0009)
#define IDC_PLAYBACK_ADVVOC              (ID_VOICE_PROP + 0x000A)
#define IDC_CAPTURE_ADVVOL               (ID_VOICE_PROP + 0x000B)
#define IDC_LAUNCH_CAPVOL                (ID_VOICE_PROP + 0x000C)
#define IDC_ADVANCED_DIAG                (ID_VOICE_PROP + 0x000D)

/*
 ***************************************************************
 * Defines for Effects CPL.
 ***************************************************************     
 */     
#define IDC_EFFECT_LIST                  (ID_EFFECT_PROP + 0x0001) 
#define IDB_EFFECT_PROP                  (ID_EFFECT_PROP + 0x0004) 
#define IDC_EFFECT_STATIC                (ID_EFFECT_PROP + 0x0005) 
#define IDB_EFFECT_PLAY                  (ID_EFFECT_PROP + 0x0008) 
#define IDC_EFFECT_HELPTEXT              (ID_EFFECT_PROP + 0x000B) 


////////////////////////////////////////////////////////////////////
// mmioFOURCC
////////////////////////////////////////////////////////////////////

#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_IARL mmioFOURCC('I','A','R','L')
#define FOURCC_IART mmioFOURCC('I','A','R','T')
#define FOURCC_ICMS mmioFOURCC('I','C','M','S')
#define FOURCC_ICMT mmioFOURCC('I','C','M','T')
#define FOURCC_ICOP mmioFOURCC('I','C','O','P')
#define FOURCC_ICRD mmioFOURCC('I','C','R','D')
#define FOURCC_ICRP mmioFOURCC('I','C','R','P')
#define FOURCC_IDIM mmioFOURCC('I','D','I','M')
#define FOURCC_IDPI mmioFOURCC('I','D','P','I')
#define FOURCC_IENG mmioFOURCC('I','E','N','G')
#define FOURCC_IGNR mmioFOURCC('I','G','N','R')
#define FOURCC_IKEY mmioFOURCC('I','K','E','Y')
#define FOURCC_ILGT mmioFOURCC('I','L','G','T')
#define FOURCC_IMED mmioFOURCC('I','M','E','D')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_IPLT mmioFOURCC('I','P','L','T')
#define FOURCC_IPRD mmioFOURCC('I','P','R','D')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')
#define FOURCC_ISFT mmioFOURCC('I','S','F','T')
#define FOURCC_ISHP mmioFOURCC('I','S','H','P')
#define FOURCC_ISRC mmioFOURCC('I','S','R','C')
#define FOURCC_ISRF mmioFOURCC('I','S','R','F')
#define FOURCC_ITCH mmioFOURCC('I','T','C','H')
#define FOURCC_VIDC mmioFOURCC('V','I','D','C')

#define mmioWAVE    mmioFOURCC('W','A','V','E')
#define mmioFMT     mmioFOURCC('f','m','t',' ')
#define mmioDATA    mmioFOURCC('d','a','t','a')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\perfpage.h ===
//--------------------------------------------------------------------------;
//
//  File: perfpage.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef PERFPAGE_HEADER
#define PERFPAGE_HEADER


#define MAX_HW_LEVEL			(3)
#define MAX_SRC_LEVEL			(2)
#define DEFAULT_HW_LEVEL		(2)
#define DEFAULT_SRC_LEVEL		(2)


INT_PTR CALLBACK PerformanceHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


#endif // PERFPAGE_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\roland.cpp ===
//--------------------------------------------------------------------------;
//
//  File: Roland.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#include <cpl.h>
#include <commctrl.h>
#include <string.h>
#include <memory.h>

////////////
// Functions
////////////


INT_PTR CALLBACK RolandDlgHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = FALSE;
	static HBITMAP hLogo = NULL;
    	
    switch (msg)
    {
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_SYSCOLORCHANGE:
        {
            if (hLogo)
            {
                DeleteObject( (HGDIOBJ) hLogo);
                hLogo = NULL;
            }

            hLogo = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_ROLAND), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);

            if (hLogo)
            {
                SendDlgItemMessage(hDlg, IDC_LOGO_FRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hLogo);
            }

            fReturnVal = TRUE;
        }
        break;

        case WM_DESTROY:
        {
            if (hLogo)
            {
                DeleteObject( (HGDIOBJ) hLogo);
                hLogo = NULL;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            if (lParam)
            {
                SetWindowText(GetDlgItem(hDlg, IDC_RENDERER), (TCHAR *) lParam);
            }

            hLogo = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_ROLAND), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);

            if (hLogo)
            {
                SendDlgItemMessage(hDlg, IDC_LOGO_FRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hLogo);
            }

            fReturnVal = TRUE;
        }		
		break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                case IDOK:
	            	EndDialog(hDlg, TRUE);
				break;
            }
            break;
        }
    }

    return fReturnVal;
}

STDAPI_(void) RolandProp(HWND hwnd, HINSTANCE hInst, TCHAR *szName)
{
	DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_ROLAND),hwnd, RolandDlgHandler, (LPARAM) szName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\perfpage.cpp ===
//--------------------------------------------------------------------------;
//
//  File: perfpage.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"


#include "advaudio.h"
#include "perfpage.h" 

////////////
// Defines
////////////


//////////////
// Help ID's
//////////////


#pragma data_seg(".text")
const static DWORD aAdvAudioHelp[] = {
    IDC_ACCELERATION,       IDH_ADV_AUDIO_ACCELERATION,
    IDC_HWMESSAGE,          IDH_ADV_AUDIO_ACCELERATION,
    IDC_SRCQUALITY,         IDH_ADV_AUDIO_SRCQUALITY,
    IDC_SRCMSG,             IDH_ADV_AUDIO_SRCQUALITY,
    IDC_DEFAULTS,           IDH_ADV_AUDIO_RESTOREDEFAULTS,
    IDC_ICON_3,             IDH_COMM_GROUPBOX,
    IDC_TEXT_14,            IDH_COMM_GROUPBOX,
    IDC_TEXT_15,            IDH_COMM_GROUPBOX,
    IDC_TEXT_16,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_17,            IDH_ADV_AUDIO_SRCQUALITY,
    IDC_TEXT_18,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_19,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_20,            IDH_ADV_AUDIO_SRCQUALITY,
    IDC_TEXT_21,            IDH_ADV_AUDIO_SRCQUALITY,

    0, 0
};
#pragma data_seg()


//////////////
// Functions
//////////////

void SetHardwareLevel(HWND hwnd, DWORD dwHWLevel)
{
    TCHAR str[255];

    SendDlgItemMessage( hwnd, IDC_ACCELERATION, TBM_SETPOS, TRUE, dwHWLevel);
    LoadString( ghInst, IDS_AUDHW1 + dwHWLevel, str, sizeof( str )/sizeof(TCHAR) );
    SetDlgItemText(hwnd, IDC_HWMESSAGE, str);

    gAudData.current.dwHWLevel = dwHWLevel;

    ToggleApplyButton(hwnd);
}



void SetSRCLevel(HWND hwnd, DWORD dwSRCLevel)
{
    TCHAR str[255];

    SendDlgItemMessage( hwnd, IDC_SRCQUALITY, TBM_SETPOS, TRUE, dwSRCLevel);
    LoadString( ghInst, IDS_SRCQUALITY1 + dwSRCLevel, str, sizeof( str )/sizeof(TCHAR) );
    SetDlgItemText(hwnd, IDC_SRCMSG, str);

    gAudData.current.dwSRCLevel = dwSRCLevel;

    ToggleApplyButton(hwnd);
}




void RestoreDefaults(HWND hwnd)
{
    // Check if we can set the acceleration level
    if (SUCCEEDED(CheckDSAccelerationPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        SetHardwareLevel(hwnd,gAudData.dwDefaultHWLevel);
    }

    // Check if we can set the quality level
    if (SUCCEEDED(CheckDSSrcQualityPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        SetSRCLevel(hwnd,DEFAULT_SRC_LEVEL);
    }
}




BOOL InitAdvDialog(HWND hwnd)
{
    HWND     hwndDlgItem;
    BOOL     fEnableAcceleration;
    BOOL     fEnableSrcQuality;
    DWORD    dwHWLevel = gAudData.current.dwHWLevel;
    DWORD    dwSRCLevel = gAudData.current.dwSRCLevel;

    SendDlgItemMessage( hwnd, IDC_ACCELERATION, TBM_SETRANGE, TRUE, MAKELONG( 0, MAX_HW_LEVEL ) );
    SendDlgItemMessage( hwnd, IDC_SRCQUALITY, TBM_SETRANGE, TRUE, MAKELONG( 0, MAX_SRC_LEVEL ) );

    SetHardwareLevel(hwnd,dwHWLevel);
    SetSRCLevel(hwnd,dwSRCLevel);

    // Check if we can set the acceleration level
    if (FAILED(CheckDSAccelerationPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        // No - disable the slider
        fEnableAcceleration = FALSE;
    }
    else
    {
        // Yes - enable the slider
        fEnableAcceleration = TRUE;
    }
    
    // Enable/disable the acceleration slider appropriately
    hwndDlgItem = GetDlgItem( hwnd, IDC_ACCELERATION );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableAcceleration );
    }
    
    // Check if we can set the quality level
    if (FAILED(CheckDSSrcQualityPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        // No - disable the slider
        fEnableSrcQuality = FALSE;
    }
    else
    {
        // Yes - enable the slider
        fEnableSrcQuality = TRUE;
    }

    // Enable/disable the quality slider appropriately
    hwndDlgItem = GetDlgItem( hwnd, IDC_SRCQUALITY );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableSrcQuality );
    }

    // Enable/disable the defaults button
    hwndDlgItem = GetDlgItem( hwnd, IDC_DEFAULTS );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableAcceleration || fEnableSrcQuality );
    }
                
    return(TRUE);
}



INT_PTR CALLBACK PerformanceHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturnVal = FALSE;
        
    switch (msg) 
    { 
        default:
            fReturnVal = FALSE;
        break;
        
        case WM_INITDIALOG:
        {
            fReturnVal = InitAdvDialog(hDlg);
        }        
        break;

        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aAdvAudioHelp);
            fReturnVal = TRUE;
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvAudioHelp);
            fReturnVal = TRUE;
        }
        break;

        case WM_HSCROLL:
        {
            HWND hScroll = (HWND) lParam;

            if (hScroll == GetDlgItem(hDlg,IDC_ACCELERATION))
            {
                SetHardwareLevel(hDlg,(DWORD) SendDlgItemMessage( hDlg, IDC_ACCELERATION, TBM_GETPOS, 0, 0 ));
            }
            else if (hScroll == GetDlgItem(hDlg, IDC_SRCQUALITY))
            {
                SetSRCLevel(hDlg, (DWORD) SendDlgItemMessage( hDlg, IDC_SRCQUALITY, TBM_GETPOS, 0, 0 ));
            }
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_DEFAULTS:
                    RestoreDefaults(hDlg);
                break;

                default:
                    fReturnVal = FALSE;
                break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings(&gAudData);
                }
            }
        }
    }

    return fReturnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\remove.c ===
/*  REMOVE.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Thu Oct 17 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>
#include <regstr.h>

#include "drivers.h"
#include "sulib.h"

BOOL     SetValidAlias      (LPTSTR, LPTSTR);

static CONST TCHAR gszRunDLL32Path[]    = TEXT("\"%s\\RUNDLL32.EXE\" \"%s\\MMSYS.CPL\",mmWOW64MediaClassInstallerA \"%s\"%d");
static CONST TCHAR gszAliasValue[]      = TEXT("Alias");
static CONST TCHAR gszAliasWOW64Value[] = TEXT("AliasWOW64");
static CONST TCHAR gszWaveWOW64Value[]  = TEXT("WOW64");

#ifdef DOBOOT
BOOL     FindBootDriver     (TCHAR *);
PSTR     strstri            (LPTSTR, LPTSTR);
#endif // DOBOOT

/*
 *  RemoveService(szFile)
 *
 *  Remove the service corresponding to the file szFile
 *
 *  returns TRUE if successful, FALSE otherwise
 */

BOOL RemoveService(LPTSTR szFile)
{
    SC_HANDLE SCManagerHandle;
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    BOOL Status = FALSE;

    /*
     *  Extract the service name from the file name
     */

    {
        TCHAR drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
        lsplitpath(szFile, drive, directory, ServiceName, ext);
    }

    /*
     *  First try and obtain a handle to the service controller
     */

    SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (SCManagerHandle == NULL)
    {

        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];

        LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szFile);
        MessageBox(hMesgBoxParent, szMesg2, szRemove, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
        return FALSE;
    }


    ServiceHandle = OpenService(SCManagerHandle,
                                ServiceName,
                                SERVICE_ALL_ACCESS);
    if (ServiceHandle != NULL)
    {
        SERVICE_STATUS ServiceStatus;
        SC_LOCK ServicesDatabaseLock;

        /*
         *  Stop the service if possible.
         */

        ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

        /*
         *  Delete the service.
         *  We aren't detecting if we can just carry on.
         */

        /*
         *  Lock the service controller database to avoid deadlocks
         *  we have to loop because we can't wait
         */


        for (ServicesDatabaseLock = NULL;
            (ServicesDatabaseLock =
             LockServiceDatabase(SCManagerHandle))
            == NULL;
            Sleep(100))
        {
        }

        Status = DeleteService(ServiceHandle);

        UnlockServiceDatabase(ServicesDatabaseLock);

        CloseServiceHandle(ServiceHandle);
    }
    else
    {

        /*
         *  It's possible there was no services entry so the driver
         *  wasn't really installed after all.
         */

        LONG Error = GetLastError();

        if (Error == ERROR_FILE_NOT_FOUND ||
            Error == ERROR_PATH_NOT_FOUND ||
            Error == ERROR_SERVICE_DOES_NOT_EXIST)
        {
            Status = TRUE;
        }
    }

    CloseServiceHandle(SCManagerHandle);

    return Status;
}

/*
**  PostRemove()
**
**  Mark an installed driver for removal later AND remove the driver's entry
**  in SYSTEM.INI to avoid conflicts when we add or remove later.
*/
LONG_PTR PostRemove(PIDRIVER pIDriver, BOOL bLookAtRelated)
{

    TCHAR *keystr;
    TCHAR allkeystr[MAXSTR];
    TCHAR szfile[MAX_PATH];
    HANDLE hDriver;
    LONG_PTR Status = DRVCNF_CANCEL;
    LPTSTR pstr;


    GetPrivateProfileString(pIDriver->szSection,
                            pIDriver->szAlias,
                            pIDriver->szFile,
                            pIDriver->szFile,
                            MAX_PATH,
                            szSysIni);


    /*
     *  Remove parameters from file name
     */


    if (pIDriver->szFile)
    {
        for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
            (*pstr!=SPACE); pstr++ )
            ;
        *pstr = TEXT('\0');
    }

    if (bLookAtRelated && (!bRelated || pIDriver->bRelated))
        wcscpy(szRestartDrv,  pIDriver->szDesc);

    /*
     *  If it's a kernel driver remove it from the config registry
     *  and services controller
     */

    if (pIDriver->KernelDriver)
    {

        Status = RemoveService(pIDriver->szFile) ? DRVCNF_RESTART : DRVCNF_CANCEL;

        if (Status == DRVCNF_CANCEL)
        {
            return DRVCNF_CANCEL;
        }

    }
    else
    {

        hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

        if (hDriver)
        {

            /*
             *  Removal can fail so don't mark as deleted in this case
             */

            Status = SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
            CloseDriver(hDriver, 0L, 0L);

            if (Status == DRVCNF_CANCEL)
            {
                return DRVCNF_CANCEL;
            }
        }
    }

    // Remove the driver from the treeview,
    //  but don't free its structure
    //
    RemoveIDriver (hAdvDlgTree, pIDriver, FALSE);

    if (bLookAtRelated)
    {
        TCHAR allkeystr[MAXSTR];

        if (GetPrivateProfileString(szRelatedDesc, pIDriver->szAlias,
                                    allkeystr, allkeystr, sizeof(allkeystr) / sizeof(TCHAR), szControlIni))
        {
            int  i;
            TCHAR szTemp[MAXSTR];

            for (i = 1; infParseField(allkeystr, i, szTemp);i++)
            {
                PIDRIVER pid;

                if ((pid = FindIDriverByName (szTemp)) != NULL)
                {
                    if (PostRemove (pid, FALSE) == DRVCNF_RESTART)
                    {
                        Status = DRVCNF_RESTART;
                    }
                }
            }
        }
    }

    // Remove the driver entry from SYSTEM.INI so you don't
    // conflict with other drivers.

    GetPrivateProfileString(pIDriver->szSection, NULL, NULL,
                            allkeystr, sizeof(allkeystr) / sizeof(TCHAR), szSysIni);
    keystr = allkeystr;
    while (wcslen(keystr) > 0)
    {
        GetPrivateProfileString(pIDriver->szSection, keystr, NULL, szfile, sizeof(szfile) / sizeof(TCHAR), szSysIni);
        if (!FileNameCmp(pIDriver->szFile, szfile))
            RemoveDriverEntry(keystr, pIDriver->szFile, pIDriver->szSection, bLookAtRelated);
        keystr = &keystr[wcslen(keystr) + sizeof(TCHAR)];
    }
    return Status;
}



void RemoveDriverEntry (LPTSTR szKey, LPTSTR szFile, LPTSTR szSection, BOOL bLookAtRelated)
{

    /*
     *  Remove entry for loading driver
     */

    WritePrivateProfileString(szSection, szKey, NULL, szSysIni);

    /*
     *  Delete entry for parameters for this driver
     */

    WriteProfileString(szFile, szKey, NULL);

    /*
     *  Remove entry which says this is a user driver (as opposed to
     *  a pre-installed one).
     */

    WritePrivateProfileString(szUserDrivers, szKey, NULL, szControlIni);

    /*
     *  Remove description
     */

    WritePrivateProfileString(szDriversDesc, szFile, NULL, szControlIni);

    /*
     *  Remove links to related drivers
     */

    WritePrivateProfileString(szRelatedDesc, szKey, NULL, szControlIni);

#ifdef DOBOOT
    FindBootDriver(szKey);
#endif // DOBOOT

    if (bLookAtRelated)
        SetValidAlias(szKey, szSection);
}


/*
 *  SetValidAlias()
 *
 * Check to see if the alias removed would create a hole in the device
 * numbering scheme. If so switch the last device number with the deleted one.
 */
BOOL SetValidAlias(LPTSTR pstrType, LPTSTR pstrSection)
{
    TCHAR *keystr;
    static TCHAR allkeystr[MAXSTR];
    static TCHAR szExKey[MAXSTR], szExFile[MAXSTR], szExDesc[MAXSTR];
    BOOL bfound = FALSE, bExchange = FALSE;
    int val, maxval = 0, typelen, len;

    /*
     *  Getting length of alias
     */

    len = typelen = wcslen(pstrType);

    // If the last TCHAR on the type is a number don't consider it

    if (pstrType[typelen - 1] > TEXT('0') && pstrType[typelen - 1] <= TEXT('9'))
        typelen--;

    // Get all the aliases in the drivers section

    GetPrivateProfileString(pstrSection, NULL, NULL, allkeystr,
                            sizeof(allkeystr) / sizeof(TCHAR), szSysIni);
    keystr = allkeystr;
    while (*keystr != TEXT('\0'))
    {
        // Compare the root of the aliases
        if (!_wcsnicmp(keystr, pstrType, typelen) && ((keystr[typelen] <= TEXT('9') && keystr[typelen] > TEXT('0')) || keystr[typelen] == TEXT('\0')))
        {

            //We found a common alias
            bfound = TRUE;
            val = _wtoi(&keystr[typelen]);
            if (val > maxval)
            {
                maxval = val;
                wcscpy(szExKey, keystr);
            }
        }
        //Pointer to next alias
        keystr = &keystr[wcslen(keystr) + sizeof(TCHAR)];
    }
    //If we found one
    if (bfound)
    {
        if (len == typelen)
            bExchange = TRUE;
        else
            if (_wtoi(&pstrType[typelen]) < maxval)
            bExchange = TRUE;

        // We need to exchange it with the one we found
        if (bExchange)
        {
            //Exchanging the one in the drivers section in system.ini
            GetPrivateProfileString(pstrSection, szExKey, NULL, szExFile,
                                    sizeof(szExFile) / sizeof(TCHAR), szSysIni);
            WritePrivateProfileString(pstrSection, szExKey, NULL, szSysIni);
            WritePrivateProfileString(pstrSection, pstrType, szExFile, szSysIni);

#ifdef TRASHDRIVERDESC
            //Exchanging the one in the drivers description section of control.ini
            GetPrivateProfileString(szDriversDesc, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);
            WritePrivateProfileString(szDriversDesc, szExKey, NULL, szControlIni);
            WritePrivateProfileString(szDriversDesc, pstrType, szExDesc, szControlIni);
#endif

            //If any related drivers were present under old alias switch them
            GetPrivateProfileString(szRelatedDesc, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);

            if (wcslen(szExDesc))
            {
                WritePrivateProfileString(szRelatedDesc, szExKey, NULL, szControlIni);
                WritePrivateProfileString(szRelatedDesc, pstrType, szExDesc, szControlIni);
            }

            //If user installed driver under old alias switch them
            GetPrivateProfileString(szUserDrivers, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);

            if (wcslen(szExDesc))
            {
                WritePrivateProfileString(szUserDrivers, szExKey, NULL, szControlIni);
                WritePrivateProfileString(szUserDrivers, pstrType, szExDesc, szControlIni);
            }

#ifdef DOBOOT
            if (FindBootDriver(szExKey))
            {
                static TCHAR szTemp[MAXSTR];

                GetPrivateProfileString(szBoot, szDrivers, szTemp, szTemp,
                                        sizeof(szTemp) / sizeof(TCHAR), szSysIni);
                strcat(szTemp, TEXT(" "));
                strcat(szTemp, pstrType);
                WritePrivateProfileString(szBoot, szDrivers, szTemp, szSysIni);
            }
#endif // DOBOOT

        }
    }
    return(bExchange);
}

int FileNameCmp(TCHAR far *pch1, TCHAR far *pch2)
{
    LPTSTR pchEOS;

    while (*pch1 == TEXT(' ')) pch1++; // eat spaces
    while (*pch2 == TEXT(' ')) pch2++; // eat spaces

    for (pchEOS = pch1; *pchEOS && *pchEOS != TEXT(' '); pchEOS++);

    return _wcsnicmp(pch1, pch2, (size_t)(pchEOS - pch1));
}

#ifdef DOBOOT

PSTR strstri(LPTSTR pszStr, LPTSTR pszKey)
{
    while (pszStr)
        if (!_strnicmp(pszStr, pszKey, lstrlen(pszKey)))
            return(pszStr);
        else
            pszStr++;
    return(NULL);
}

/*
 *   FindBootDriver()
 *  Checks to see if the driver alias is on the drivers line of the
 *  boot section. If so the alias is removed from the line.
 */

BOOL FindBootDriver(TCHAR *szKey)
{
    TCHAR *ptr;
    int wKeyLen = (int)wcslen(szKey);
    TCHAR *endkey;
    static TCHAR szDriverline[MAXSTR];

    GetPrivateProfileString(TEXT("boot"), TEXT("drivers"), szDriverline, szDriverline,
                            MAX_PATH, szSysIni);
    ptr = strstri(szDriverline, szKey);
    if (ptr)
    {

        if ((((ptr != szDriverline) && (*(ptr - 1) == TEXT(' ') )) ||
             (ptr == szDriverline)) &&
            (*(ptr + wKeyLen) == TEXT(' ') || *(ptr + wKeyLen) == NULL))
        {
            endkey = ptr + wKeyLen;
            while (*endkey)
                *ptr++ = *endkey++;
            *ptr = NULL;
            WritePrivateProfileString(TEXT("boot"), TEXT("drivers"), szDriverline,
                                      szSysIni);
            return(TRUE);
        }
    }
    return(FALSE);
}

#endif // DOBOOT

// Steal use of function in midi.c to delete a reg subtree.
LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey);

//****************************************************************************
// Function: mystrtok()
//
// Purpose: Returns a pointer to the next token in a string.
//
// Parameters:
//      SrcString   String containing token(s)
//      Seps        Set of delimiter characters
//      State       Pointer to a char* to hold state info
// Return Code:
//      Ptr to next token, or NULL if no tokens left
//
// Comments:
//      Fixes problem with standard strtok, which can't be called recursively.
//
//****************************************************************************
LPTSTR mystrtok(LPTSTR SrcString, LPCTSTR Seps, LPTSTR FAR *State)
{
    LPTSTR ThisString;
    LPTSTR NextString;

    // If Seps is NULL, use default separators
    if (!Seps)
    {
        Seps = TEXT(" ,\t");  // space, comma, tab chars
    }

    if (SrcString)
        ThisString = SrcString;
    else
        ThisString = *State;

    // Find beginning of the current string
    ThisString = ThisString + wcsspn(ThisString,Seps);
    if (ThisString[0]==TEXT('\0'))
        return NULL;

    // Find the end of the current string
    NextString = ThisString + wcscspn(ThisString,Seps);
    if (NextString[0]!=TEXT('\0'))
    {
        *NextString++=TEXT('\0');
    }

    *State = NextString;
    return ThisString;
}

BOOL RemoveDriver(IN HDEVINFO         DeviceInfoSet,
                  IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                 )
{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers32 = NULL;    // Key to Drivers32 portion of registry
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szAlias[64];           // Alias in Drivers32 (e.g. wave1)
    TCHAR szDriver[64];          // Name of driver

    DWORD cbLen;

    LPCTSTR szAliasStringToUse;  // Pointer to the Alias value name to use
    BOOL bIsWOW64Process = FALSE;// TRUE if we're running under WOW64

    //
    // If we're running in WOW64, we need to use a different Alias string so that
    // we don't overwrite the 64-bit alias string
    //
    if( IsWow64Process(GetCurrentProcess(), &bIsWOW64Process)
    &&  bIsWOW64Process )
    {
        szAliasStringToUse = gszAliasWOW64Value;
    }
    else
    {
        szAliasStringToUse = gszAliasValue;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = wcsrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveDrivers32_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Open the Drivers32 section of the registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32"),
                   &hkDrivers32))
    {
        goto RemoveDrivers32_exit;
    }

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveDrivers32_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
#ifdef _WIN64
        //
        // Check for magic WaveWOW64 value
        if( 0 == _wcsnicmp( pszClass, gszWaveWOW64Value, wcslen(gszWaveWOW64Value) ) )
        {
            // Thunk the installation to the 32-bit mmsys.cpl installer
            mmWOW64ThunkMediaClassInstaller(DIF_REMOVE, DeviceInfoSet, DeviceInfoData);

            continue;
        }
#endif //_WIN64

        // Open up each subclass
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                // Send the driver a DRV_REMOVE message to the driver
                HANDLE hDriver;

                hDriver = OpenDriver(szDriver, NULL, 0L);

                if (hDriver)
                {
                    SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
                    CloseDriver(hDriver, 0L, 0L);
                }
            }

            // Get the value of Alias under the driver name key
            cbLen = sizeof(szAlias);
            if (!RegQueryValueEx(hkR3DriverName, szAliasStringToUse, NULL, NULL, (LPBYTE)szAlias, &cbLen))
            {
                // Delete the corresponding entry in Drivers32
                RegDeleteValue(hkDrivers32,szAlias);
            }

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveDrivers32_exit:

    if (hkDrivers32)    RegCloseKey(hkDrivers32);
    if (hkDevReg)       RegCloseKey(hkDevReg);
    if (hkDrivers)      RegCloseKey(hkDrivers);

    return bRet;
}

// The driver's private registry section is located in something like:
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\xxxx
// where xxxx is the device instance (e.g. 0000, 0001, etc.)
// These last four digits are used to index into the driver's MediaResources section.

// For example, suppose a device has a driver instance
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\0001
// and under that entry there is a Drivers\wave\foo.drv, meaning that the foo.drv driver supports a wave
// API.
// In this case, there would be an entry in
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MediaResources\wave\foo.drv<0001>
//
// On removal, we need to delete that entry.
BOOL RemoveMediaResources(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )


{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkMR      = NULL;      // Handle to MediaResources section

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szDriver[64];          // Driver name (e.g. foo.drv)
    DWORD cbLen;                // Size of szDriver

    TCHAR szDevNode[MAX_PATH+1];         // Path to driver's reg entry
    TCHAR szSoftwareKey[MAX_PATH+1];     // Value of SOFTWAREKEY

    // Open Media Resources section of registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES, &hkMR))
    {
        goto RemoveMediaResources_exit;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = wcsrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveMediaResources_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Get full path to driver key
    wsprintf(szDevNode,
             TEXT("%s\\%s"),
             REGSTR_PATH_CLASS_NT,
             (LPTSTR)szDriverKey);

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveMediaResources_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver in under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                TCHAR szR3Path[256];

                // Create a path to the MediaResources entry to be deleted
                wsprintf(szR3Path,
                         TEXT("%s\\%s\\%s<%s>"),
                         REGSTR_PATH_MEDIARESOURCES,
                         (LPTSTR)pszClass,
                         (LPTSTR)szDriver,
                         (LPTSTR)pszDrvInst);
                // Delete the key
                SHRegDeleteKey(HKEY_LOCAL_MACHINE, szR3Path);
            }
            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }

        // Close the class key in the devnode
        RegCloseKey(hkClass);

        // Backup mechanism, in case we missed something.
        // This shouldn't be necessary, but Win98 does it.

        // Open the class key in MediaResources
        if (RegOpenKey(hkMR, pszClass, &hkClass))
        {
            continue;
        }
        // Count the number of subkeys under the class key
        // We're gonna do this backwards because we'll be deleting keys later
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {
            ;
        }

        // For each driver subkey, working backwards.
        // Subkeys are e.g. msacm.iac2, msacm.imaadpcm, etc.
        for (idxR3DriverName--;
            ((int)idxR3DriverName >= 0) &&
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName--)
        {
            // Open the driver key
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Query the value of "SOFTWAREKEY"
            szSoftwareKey[0]=TEXT('\0');      // Init to safe value in case call fails

            cbLen = sizeof(szSoftwareKey);
            RegQueryValueEx(hkR3DriverName, TEXT("SOFTWAREKEY"), NULL, NULL, (LPBYTE)szSoftwareKey, &cbLen);

            // Close now, since we might delete in next line
            RegCloseKey(hkR3DriverName);

            // If the value of "SOFTWAREKEY" matches the path to the devnode, delete the key
            if (!lstrcmpi(szSoftwareKey, szDevNode))
            {
                SHRegDeleteKey(hkClass, szR3DriverName);
            }
        }

        // Close the class key in MediaResources
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveMediaResources_exit:
    if (hkDevReg)   RegCloseKey(hkDevReg);
    if (hkDrivers)  RegCloseKey(hkDrivers);
    if (hkMR)       RegCloseKey(hkMR);

    return bRet;
}

// Clear out entries in the Driver's branch of the registry, e.g. in {4D36E96C-E325-11CE-BFC1-08002BE10318}\0000
BOOL RemoveDriverInfo(IN HDEVINFO         DeviceInfoSet,
                      IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                     )
{
    HKEY hkDevReg;      // Key to Driver portion of registry (e.g. classguid\0000)

    // Remove entries in the driver's reg section
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Delete any entries that might cause trouble
    RegDeleteValue(hkDevReg,REGSTR_VAL_DEVLOADER);
    RegDeleteValue(hkDevReg,REGSTR_VAL_DRIVER);
    RegDeleteValue(hkDevReg,REGSTR_VAL_ENUMPROPPAGES);
    RegDeleteValue(hkDevReg,TEXT("NTMPDriver"));
    RegDeleteValue(hkDevReg,TEXT("AssociatedFilters"));
    RegDeleteValue(hkDevReg,TEXT("FDMA"));
    RegDeleteValue(hkDevReg,TEXT("DriverType"));

    // Blow away the Drivers subtree
    SHRegDeleteKey(hkDevReg,TEXT("Drivers"));

    // For future use, allow a key under which everything gets blown away
    SHRegDeleteKey(hkDevReg,TEXT("UnretainedSettings"));

    RegCloseKey(hkDevReg);

    return TRUE;
}

// Clear out entries in the Device's Enum branch of the registry:
BOOL RemoveDeviceInfo(IN HDEVINFO         DeviceInfoSet,
                      IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                     )
{
    // Remove the Driver key. It looks something like "Driver = {4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    // !!NO don't remove driver key, or else on driver upgrade system loses track of node & creates a new one
    //    SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER , NULL, 0);

    // Remove the Service key.
    // Make sure before doing anything else that there is no service property for
    // this device instance.  This allows us to know whether we should clean up the
    // device instance if we boot and find that it's no longer present.
    SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_SERVICE, NULL, 0);

    return TRUE;
}


/* 5/14/98 andyraf for NT5 */
/* Media_RemoveDevice
 *
 * This function gets called on driver removal (DIF_REMOVE) and driver installation (DIF_INSTALL).
 * It cleans up all the registry entries associated with the driver.
 */
DWORD Media_RemoveDevice(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
#if 0
    // Don't know how to do this on NT5
    if ((diFunction == DIF_REMOVE) &&
        (lpdi->Flags & DI_CLASSINSTALLPARAMS) &&
        (((LPREMOVEDEVICE_PARAMS)lpdi->lpClassInstallParams)->dwFlags & DI_REMOVEDEVICE_CONFIGSPECIFIC))
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // Not needed on NT5??
    CleanupDummySysIniDevs();           //remove the wave=*.drv and midi=*.drv dummy devices.
#endif

#if 0   // We'll allow people to remove these drivers for now
    if (IsSpecialDriver(DeviceInfoSet, DeviceInfoData))
    {
        return NO_ERROR;
    }
#endif

    // Send DRV_REMOVE to each driver and clean out Drivers32 section of registry
    RemoveDriver        (DeviceInfoSet, DeviceInfoData);

    // Clean out MediaResources section of registry
    RemoveMediaResources(DeviceInfoSet, DeviceInfoData);

    // Clean out driver's classguid\instance section of registry
    RemoveDriverInfo    (DeviceInfoSet, DeviceInfoData);

    // Clean out device's enum section of registry
    RemoveDeviceInfo    (DeviceInfoSet, DeviceInfoData);

    return ERROR_DI_DO_DEFAULT;
}

#if 0   // Unused at present
BOOL AddDrivers32(IN HDEVINFO         DeviceInfoSet,
                  IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                 )
{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers32 = NULL;    // Key to Drivers32 portion of registry
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkDriversDesc = NULL;  // Key to drivers.desc portion of registry

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szAlias[64];           // Alias in Drivers32 (e.g. wave1)

    TCHAR szDriver[64];          // Name of driver
    TCHAR szDescription[MAX_PATH];

    DWORD cbLen;

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = strrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveDrivers32_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Open the Drivers32 section of the registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32"),
                   &hkDrivers32))
    {
        goto RemoveDrivers32_exit;
    }

    // If we're adding a driver, need to open key to drivers.desc also
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc"),
                   &hkDriversDesc))
    {
        goto RemoveDrivers32_exit;
    }

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveDrivers32_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        // Open up each subclass
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get driver name
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                // Create the alias
                wsprintf(szAlias,TEXT("%s.%s<%s>"),(LPTSTR)pszClass,(LPTSTR)szDriver,(LPTSTR)pszDrvInst);

                // Write into Drivers32
                RegSetValueExA(hkDrivers32,szAlias,0,REG_SZ,(PBYTE)szDriver,(wcslen(szDriver)*sizeof(TCHAR)) + sizeof(TCHAR));

                // Write alias back into driver's reg area
                RegSetValueExA(hkR3DriverName,TEXT("Alias"),0,REG_SZ,(PBYTE)szAlias,(wcslen(szAlias)*sizeof(TCHAR)) + sizeof(TCHAR));
            }

            // Write out Description
            // Get driver description
            cbLen = sizeof(szDescription);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Description"), NULL, NULL, (LPBYTE)szDescription, &cbLen))
            {
                RegSetValueExA(hkDriversDesc,szDriver,0,REG_SZ,(PBYTE)szDescription,(wcslen(szDescription)*sizeof(TCHAR)) + sizeof(TCHAR));
            }

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveDrivers32_exit:

    if (hkDrivers32)    RegCloseKey(hkDrivers32);
    if (hkDevReg)       RegCloseKey(hkDevReg);
    if (hkDrivers)      RegCloseKey(hkDrivers);
    if (hkDriversDesc)  RegCloseKey(hkDriversDesc);

    return bRet;
}
#endif

#if 0 // Unused at present
// The driver's private registry section is located in something like:
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\xxxx
// where xxxx is the device instance (e.g. 0000, 0001, etc.)
// These last four digits are used to index into the driver's MediaResources section.

// For example, suppose a device has a driver instance
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\0001
// and under that entry there is a Drivers\wave\foo.drv, meaning that the foo.drv driver supports a wave
// API.
// In this case, there would be an entry in
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MediaResources\wave\foo.drv<0001>
//
// On removal, we need to delete that entry.
BOOL AddMediaResources(IN HDEVINFO         DeviceInfoSet,
                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                      )


{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkMR      = NULL;      // Handle to MediaResources section

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szDriver[64];          // Driver name (e.g. foo.drv)
    DWORD cbLen;                // Size of szDriver

    TCHAR szDevNode[MAX_PATH+1];         // Path to driver's reg entry
    TCHAR szSoftwareKey[MAX_PATH+1];     // Value of SOFTWAREKEY

    // Open Media Resources section of registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES, &hkMR))
    {
        goto RemoveMediaResources_exit;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = strrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveMediaResources_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Get full path to driver key
    wsprintf(szDevNode,
             TEXT("%s\\%s"),
             REGSTR_PATH_CLASS_NT,
             (LPTSTR)szDriverKey);

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveMediaResources_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver in under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                HKEY hkMRClass;
                HKEY hkMRDriver;
                TCHAR szMRDriver[256];

                // Create the class key if it doesn't already exist
                if (!RegCreateKey(hkMR,pszClass,&hkMRClass))
                {
                    continue;
                }

                // Create the driver key if it doesn't already exist
                wsprintf(szMRDriver,
                         TEXT("%s<%s>"),
                         (LPTSTR)szDriver,
                         (LPTSTR)pszDrvInst);

                if (!RegCreateKey(hkMRClass,szMRDriver,&hkMRDriver))
                {
                    RegCloseKey(hkMRClass);
                    continue;
                }

                // Migrate the values from the driver into the MediaResources key
                // First write out driver name
                // FEATURE: Not implemented yet.

                RegCloseKey(hkMRClass);
                RegCloseKey(hkMRDriver);
            }
            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }

        // Close the class key in the devnode
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveMediaResources_exit:
    if (hkDevReg)   RegCloseKey(hkDevReg);
    if (hkDrivers)  RegCloseKey(hkDrivers);
    if (hkMR)       RegCloseKey(hkMR);

    return bRet;
}
#endif

#ifdef _WIN64
void mmWOW64ThunkMediaClassInstaller(DWORD dwInstallationFlag, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    DWORD dwInstanceIDSize = 0;
    DWORD dwWow64DirSize = 0;
    LPTSTR tcstrDeviceInstanceId = NULL;
    LPTSTR tcstrWow64Directory = NULL;
    LPTSTR tcstrRunDLL32Path = NULL;
    PROCESS_INFORMATION processInformation;
    STARTUPINFO startupInfo;

    // Get the device instance ID
    SetupDiGetDeviceInstanceId( DeviceInfoSet, DeviceInfoData, NULL, 0, &dwInstanceIDSize );
    if( 0 == dwInstanceIDSize )
    {
        // Unable to retrieve required size - return
        return;
    }

    tcstrDeviceInstanceId = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwInstanceIDSize);
    if( NULL == tcstrDeviceInstanceId
    ||  0 == SetupDiGetDeviceInstanceId( DeviceInfoSet, DeviceInfoData, tcstrDeviceInstanceId, dwInstanceIDSize, NULL ) )
    {
        // Unable to retrieve device instance ID - return
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    dwWow64DirSize = GetSystemWow64Directory( NULL, 0 );
    if( 0 == dwWow64DirSize )
    {
        // Unable to retrieve the Wow64Directory size - return
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    tcstrWow64Directory = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwWow64DirSize);
    if( NULL == tcstrWow64Directory
    ||  0 == GetSystemWow64Directory( tcstrWow64Directory, dwWow64DirSize ) )
    {
        // Unable to retrieve the Wow64Directory - return
        LocalFree((HANDLE)tcstrWow64Directory);
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    // The full path is the size of the format string, plus two times the length of the system path,
    // plus the length of the instance ID, plus 10 (maximum length of a DWORD)
    tcstrRunDLL32Path = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (wcslen(gszRunDLL32Path) +
        dwWow64DirSize * 2 + dwInstanceIDSize + 10));
    if( NULL == tcstrRunDLL32Path )
    {
        // Unable to allocate RunDLL32 path - return
        LocalFree((HANDLE)tcstrWow64Directory);
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    // Create the command line
    wsprintf( tcstrRunDLL32Path, gszRunDLL32Path, tcstrWow64Directory, tcstrWow64Directory, tcstrDeviceInstanceId, dwInstallationFlag );

    // Initialize the CreateProcess structures
    ZeroMemory( &processInformation, sizeof(PROCESS_INFORMATION) );
    ZeroMemory( &startupInfo, sizeof(STARTUPINFO) );
    startupInfo.cb = sizeof(STARTUPINFO);

    if( CreateProcess( NULL, tcstrRunDLL32Path, NULL, NULL, FALSE,
	    CREATE_NO_WINDOW, NULL, NULL, &startupInfo, &processInformation ) )
    {
        // Wait for the process to end
	    WaitForSingleObject( processInformation.hProcess, 5000 );

	    // Close process and thread handles. 
	    CloseHandle( processInformation.hProcess );
	    CloseHandle( processInformation.hThread );
    }

    // Free up the strings we allocated
    LocalFree((HANDLE)tcstrRunDLL32Path);
    LocalFree((HANDLE)tcstrWow64Directory);
    LocalFree((HANDLE)tcstrDeviceInstanceId);
}
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\scheme.c ===
/*
 ***************************************************************
 *
 *  This file contains the routines to read and write to the reg database
 *
 *  Copyright 1993, Microsoft Corporation
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "mmcpl.h"
#include "draw.h"
#include "medhelp.h"

/*
 ***************************************************************
 * Definitions
 ***************************************************************
 */
#define KEYLEN  8           //length of artificially created key
#define MAXSCHEME  37      //max length of scheme name



/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE   aszDefaultScheme[]      = TEXT("Appevents\\schemes");
static SZCODE   aszDefaultApp[]         = TEXT("Appevents\\schemes\\apps\\.default");
static SZCODE   aszApps[]               = TEXT("Appevents\\schemes\\apps");
static SZCODE   aszLabels[]             = TEXT("Appevents\\eventlabels");
static SZCODE   aszDisplayLabels[]      = TEXT("DispFileName");
static SZCODE   aszNames[]              = TEXT("Appevents\\schemes\\Names");
static SZCODE   aszDefault[]            = TEXT(".default");
static SZCODE   aszCurrent[]            = TEXT(".current");
static SZCODE   aszMMTask[]             = TEXT("MMTask");
static INTCODE  aKeyWordIds[]           =
{
    ID_SCHEMENAME, IDH_SAVEAS_SCHEMENAME,
    0,0
};
static SZCODE   cszSslashS[] = TEXT("%s\\%s");

/*
 ***************************************************************
 * extern
 ***************************************************************
 */
extern HWND         ghWnd;
extern BOOL         gfChanged;
extern BOOL         gfNewScheme;
extern BOOL         gfDeletingTree;
extern int          giScheme;
extern TCHAR         gszDefaultApp[];
extern TCHAR         gszNullScheme[];
extern TCHAR         gszCmdLineApp[];
extern TCHAR         gszCmdLineEvent[];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL RemoveScheme            (HWND);
BOOL PASCAL RegAddScheme            (HWND, LPTSTR);
BOOL PASCAL RegNewScheme            (HWND, LPTSTR, LPTSTR, BOOL);
BOOL PASCAL RegSetDefault           (LPTSTR);
BOOL PASCAL RegDeleteScheme         (HWND, int);
BOOL PASCAL LoadEvents              (HWND, HTREEITEM, PMODULE);
BOOL PASCAL LoadModules             (HWND, LPTSTR);
BOOL PASCAL ClearModules            (HWND, HWND, BOOL);
BOOL PASCAL NewModule               (HWND, LPTSTR, LPTSTR, LPTSTR, int);
BOOL PASCAL FindEventLabel          (LPTSTR, LPTSTR);
BOOL PASCAL AddScheme               (HWND, LPTSTR, LPTSTR, BOOL, int);
void PASCAL GetMediaPath            (LPTSTR, size_t);
void PASCAL RemoveMediaPath         (LPTSTR, LPTSTR);
void PASCAL AddMediaPath            (LPTSTR, LPTSTR);

int ExRegQueryValue (HKEY, LPTSTR, LPBYTE, DWORD *);

//sndfile.c
BOOL PASCAL ShowSoundMapping        (HWND, PEVENT);
int StrByteLen                      (LPTSTR);

//drivers.c
int lstrnicmp (LPTSTR, LPTSTR, size_t);
LPTSTR lstrchr (LPTSTR, TCHAR);

/*
 ***************************************************************
 ***************************************************************
 */

static void AppendRegKeys (
    LPTSTR  szBuf,
    LPCTSTR szLeft,
    LPCTSTR szRight)
{
    static SZCODE cszSlash[] = TEXT("\\");
    lstrcpy (szBuf, szLeft);
    lstrcat (szBuf, cszSlash);
    lstrcat (szBuf, szRight);
}




/*
 ***************************************************************
 *  SaveSchemeDlg
 *
 *  Description: Dialog handler for save schemes dialog.
 *        checks if given scheme name exists and if so
 *        whether it should be overwritten.
 *        if yes then delete current scheme.
 *        scheme under a new name, else just add a new scheme
 *        The user can choose to cancel
 *
 *  Arguments:
 *      HWND    hDlg    -    window handle of dialog window
 *      UINT    uiMessage -  message number
 *      WPARAM    wParam  -  message-dependent
 *      LPARAM    lParam  -  message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************************
 */
INT_PTR CALLBACK SaveSchemeDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR    szBuf[MAXSTR];
    TCHAR    szTemp[MAXSTR];
    TCHAR    szMesg[MAXSTR];
    int        iResult;
    int        iIndex;
    HWND    hDlgParent = ghWnd;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            szBuf[0] = TEXT('\0');
            DPF("IN Init\n");
            Edit_LimitText(GetDlgItem(hDlg, ID_SCHEMENAME), MAXSCHEME);

            Edit_SetText(GetDlgItem(hDlg, ID_SCHEMENAME), (LPTSTR)lParam);
            // dump the text from lparam into the edit control.
                
            break;

        case WM_COMMAND:

        switch (wParam)
        {
            case IDOK:
            {
                LPTSTR pszKey;

                Edit_GetText(GetDlgItem(hDlg, ID_SCHEMENAME), szBuf, MAXSTR);

                //prevent null-string names
                if (lstrlen(szBuf) == 0)
                {
                    LoadString(ghInstance, IDS_INVALIDFILE, szTemp, MAXSTR);
                    MessageBox(hDlg, szTemp, gszChangeScheme, MB_ICONERROR | MB_OK);
                    break;
                }

                iIndex = ComboBox_FindStringExact(GetDlgItem(hDlgParent,
                                                    CB_SCHEMES), 0, szBuf);
                pszKey = (LPTSTR)ComboBox_GetItemData(GetDlgItem(hDlgParent,CB_SCHEMES), iIndex);

                if (iIndex != CB_ERR)
                {
                    if (!lstrcmpi((LPTSTR)pszKey, aszDefault) || !lstrcmpi((LPTSTR)pszKey, gszNullScheme))
                    {
                        LoadString(ghInstance, IDS_NOOVERWRITEDEFAULT, szTemp,
                                                                    MAXSTR);
                        wsprintf(szMesg, szTemp, (LPTSTR)szBuf);
                        iResult = MessageBox(hDlg, szMesg, gszChangeScheme,
                            MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OKCANCEL);

                        if (iResult == IDOK)
                        {
                            break;
                        }

                    }
                    else
                    {
                        LoadString(ghInstance, IDS_OVERWRITESCHEME, szTemp,
                                                                    MAXSTR);
                        wsprintf(szMesg, szTemp, (LPTSTR)szBuf);
                        iResult = MessageBox(hDlg, szMesg, gszChangeScheme,
                        MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNOCANCEL);

                        if (iResult == IDYES)
                        {
                            RegDeleteScheme(GetDlgItem(hDlgParent,
                                                    CB_SCHEMES), iIndex);
                            RegAddScheme(hDlgParent, szBuf);
                            PropSheet_Changed(GetParent(hDlg),hDlg);
                        }
                        else
                        {
                            if (iResult == IDNO)
                                break;

                            if (iResult == IDCANCEL)
                            {
                                EndDialog(hDlg, FALSE);
                                break;
                            }
                        }
                    }
                }
                else
                {

                    RegAddScheme(hDlgParent, szBuf);
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                gfChanged = TRUE;
                EndDialog(hDlg, TRUE);
                DPF("Done save\n");
                break;
            }

            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                DPF("Done save\n");
                break;


            case ID_SCHEMENAME:

                if ((HIWORD(lParam) == EN_ERRSPACE) ||
                                            (HIWORD(lParam) == EN_MAXTEXT))
                    MessageBeep(MB_OK);

                else
                    if (HIWORD(lParam) == EN_CHANGE)
                    {

                        GetWindowText(GetDlgItem(hDlg, ID_SCHEMENAME), szBuf,
                                                                MAXSTR - 1);
                        EnableWindow(GetDlgItem(hDlg, IDOK), *szBuf);
                    }
                break;

            default:
                break;
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                    (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;
    }
    return FALSE;
}

/*
 ***************************************************************
 *  RegNewScheme
 *
 *  Description:
 *        Saves the scheme in the reg database. If the fQuery flag is
 *        set then a messages box is brought up, asking if the schem should
 *        be saved
 *
 *  Arguments:
 *        HWND    hDlg    -    Handle to the dialog
 *      LPTSTR    lpszScheme -    pointer to scheme name.
 *      BOOL    fQuery -  If TRUE and lpszScheme is in reg.db bring up msgbox.
 *
 *  Returns:    BOOL
 *      TRUE if the new scheme is succesfully added or if the user chooses
 *        not to save
 *
 ***************************************************************
 */
BOOL PASCAL RegNewScheme(HWND hDlg, LPTSTR lpszKey, LPTSTR lpszLabel,
                                                                BOOL fQuery)
{
    PMODULE npModule;
    PEVENT  npPtr;
    TCHAR     szBuf[MAXSTR];
    TCHAR     szLabel[MAXSTR];
    HTREEITEM hti;
    TV_ITEM    tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    if (fQuery)
    {
        LoadString(ghInstance, IDS_SAVECHANGE, szBuf, MAXSTR);
        LoadString(ghInstance, IDS_SAVESCHEME, szLabel, MAXSTR);
        if (MessageBox(hDlg, szBuf, szLabel,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDNO)
            return TRUE;
    }

    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
    {
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(hwndTree, &tvi);

        npModule = (PMODULE)tvi.lParam;
        if ((npPtr = npModule->npList) == NULL)
            break;

        for (; npPtr != NULL; npPtr = npPtr->npNextEvent)
        {
            HKEY hk = NULL;
            DWORD dwType;
            static SZCODE cszFmt[] = TEXT("%s\\%s\\%s\\%s");
            wsprintf(szBuf, cszFmt, (LPTSTR)aszApps,
                    (LPTSTR)npModule->pszKey, (LPTSTR)npPtr->pszEvent, lpszKey);
            DPF("setting  %s to %s\n", (LPTSTR)szBuf, (LPTSTR)npPtr->pszPath);

            RemoveMediaPath (szLabel, npPtr->pszPath);
            dwType = (lstrchr (szLabel, TEXT('%'))) ? REG_EXPAND_SZ : REG_SZ;

            // Set file name
            if ((RegCreateKey (HKEY_CURRENT_USER, szBuf, &hk) == ERROR_SUCCESS) && hk)
            {
               if (RegSetValueEx (hk, NULL, 0, dwType, (LPBYTE)szLabel,
                                  (1+lstrlen(szLabel))*sizeof(TCHAR)) != ERROR_SUCCESS)
               {
                   DPF("fail %s for %s,\n", (LPTSTR)szLabel, (LPTSTR)szBuf);
               }

               RegCloseKey (hk);
            }

        }
    }
    return TRUE;
}

/*
 ***************************************************************
 *  RegAddScheme
 *
 *  Description:
 *        Adds the given scheme to the reg database by creating a key using
 *        upto the first KEYLEN letters of the schemename. If the strlen
 *        id less than KEYLEN, '0's are added till the key is KEYLEN long.
 *        This key is checked for uniqueness and then RegNewScheme is called.
 *
 *  Arguments:
 *      HWND    hDlg     -   Handle to the dialog
 *      LPTSTR    lpszScheme  -  pointer to scheme name.
 *
 *  Returns:    BOOL
 *      TRUE if message successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegAddScheme(HWND hDlg, LPTSTR lpszScheme)
{
    TCHAR    szKey[32];
    LPTSTR    pszKey;
    int     iIndex;
    int     iLen;
    int     iStrLen;
    HWND    hWndC;
    HKEY    hkScheme;
    HKEY    hkBase;

    hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    iLen = StrByteLen(lpszScheme);
    iStrLen = lstrlen(lpszScheme);

    if (iStrLen < KEYLEN)
    {
        lstrcpy(szKey, lpszScheme);
        iIndex = iLen;
        szKey[iIndex] = TEXT('0');
        szKey[iIndex+sizeof(TCHAR)] = TEXT('\0');
    }
    else
    {
        lstrcpyn(szKey, lpszScheme, KEYLEN-1);
        iIndex = StrByteLen(szKey);
        szKey[iIndex] = TEXT('0');
        szKey[iIndex+sizeof(TCHAR)] = TEXT('\0');
    }
    if (RegOpenKey(HKEY_CURRENT_USER, aszNames, &hkBase) != ERROR_SUCCESS)
    {
        DPF("Failed to open asznames\n");
        return FALSE;
    }
    gfNewScheme = FALSE;
    while (RegOpenKey(hkBase, szKey, &hkScheme) == ERROR_SUCCESS)
    {
        szKey[iIndex]++;
        RegCloseKey(hkScheme);
    }

    if (RegSetValue(hkBase, szKey, REG_SZ, lpszScheme, 0) != ERROR_SUCCESS)
    {
        static SZCODE cszFmt[] = TEXT("%lx");
        wsprintf((LPTSTR)szKey, cszFmt, GetCurrentTime());    //High chance of unique ness. This is to deal with some
                                                            //DBCS problems.
        if (RegSetValue(hkBase, szKey, REG_SZ, lpszScheme, 0) != ERROR_SUCCESS)
        {
            DPF("Couldn't set scheme value %s\n", lpszScheme);
            RegCloseKey(hkBase);
            return FALSE;
        }
    }
    RegCloseKey(hkBase);

    if (RegNewScheme(hDlg, szKey, lpszScheme, FALSE))
    {
        iIndex = ComboBox_GetCount(hWndC);
        ComboBox_InsertString(hWndC, iIndex, lpszScheme);

        pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szKey)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (pszKey == NULL)
        {
            DPF("Failed Alloc\n");
            return FALSE;
        }
        lstrcpy(pszKey, szKey);


        ComboBox_SetItemData(hWndC, iIndex, (LPVOID)pszKey);
        ComboBox_SetCurSel(hWndC, iIndex);

        giScheme =     ComboBox_GetCurSel(hWndC);
        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), TRUE);
    }

    return TRUE;
}

/*
 ***************************************************************
 *  RemoveScheme(hDlg)
 *
 *  Description:
 *          Deletes current scheme; removes it from dialog
 *        combo box, sets the current scheme to <None>,
 *        if it is set to be default. removes it as default
 *          The remove and save buttons
 *        are disabled since the <none> scheme is selected
 *
 *  Arguments:
 *      HWND    hDlg    window handle of dialog window
 *
 *  Returns:    BOOL
 *      TRUE if message successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RemoveScheme(HWND hDlg)
{
    TCHAR szBuf[MAXSTR];
    TCHAR szScheme[MAXSTR];
    TCHAR szMsg[MAXSTR];
    int  i;
    HWND hWndC;
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    /* first confirm that this scheme is really to be deleted.
    */
    i = ComboBox_GetCurSel(hWndC);
    if (i == CB_ERR)
        return FALSE;

    LoadString(ghInstance, IDS_CONFIRMREMOVE, szMsg, MAXSTR);
    ComboBox_GetLBText(hWndC, i, szScheme);
    wsprintf(szBuf, szMsg, (LPTSTR)szScheme);

    if (MessageBox(hDlg, szBuf, gszRemoveScheme,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDYES)
    {
        static SZCODE  aszControlIniSchemeFormat[] = TEXT("SoundScheme.%s");
        static SZCODE  aszControlIni[] = TEXT("control.ini");
        static SZCODE  aszSoundSchemes[] = TEXT("SoundSchemes");
        TCHAR  szControlIniScheme[MAXSTR];

        /* Remove from the list of schemes, and select none */

        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), FALSE);

        ClearModules(hDlg, hwndTree, TRUE);
        RegDeleteScheme(hWndC, i);
        wsprintf(szControlIniScheme, aszControlIniSchemeFormat, szScheme);
        WritePrivateProfileString(szControlIniScheme, NULL, NULL, aszControlIni);
        WritePrivateProfileString(aszSoundSchemes, szScheme, NULL, aszControlIni);
        return TRUE;
    }
    return FALSE;
}

/*
 ***************************************************************
 *  RegSetDefault
 *
 *  Description: Sets the given scheme as the default scheme in the reg
 *               database
 *
 *  Arguments:
 *      LPTSTR    lpKey - name of default scheme
 *
 *  Returns:    BOOL
 *      TRUE if value set successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegSetDefault(LPTSTR lpszKey)
{
    if (RegSetValue(HKEY_CURRENT_USER, aszDefaultScheme, REG_SZ, lpszKey,
                                                0) != ERROR_SUCCESS)
    {
        DPF("Failed to set Value %s,\n", lpszKey);
        return FALSE;
    }
    return TRUE;
}

/*
 ***************************************************************
 *  RegDeleteScheme
 *
 *  Description: Deletes the given scheme from the reg database.
 *
 *  Arguments:
 *        HWND    hDlg    - Dialog window handle
 *        int        iIndex   - Index in Combobox
 *
 *  Returns:    BOOL
 *      TRUE if deletion is successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegDeleteScheme(HWND hWndC, int iIndex)
{
    LPTSTR    pszKey;
    TCHAR    szKey[MAXSTR];
    TCHAR    szBuf[MAXSTR];
    TCHAR    szEvent[MAXSTR];
    TCHAR    szApp[MAXSTR];
    HKEY    hkApp;
    HKEY    hkAppList;
    LONG    cbSize;
    int        iEvent;
    int        iApp;

    if (hWndC)
    {
        pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);
        lstrcpy(szKey, pszKey);
        if (ComboBox_DeleteString(hWndC, iIndex) == CB_ERR)
        {
            DPF("Couldn't delete string %s,\n", (LPTSTR)szKey);
            return FALSE;
        }
        //ComboBox_SetCurSel(hWndC, 0);

        AppendRegKeys (szBuf, aszNames, szKey);
        if (RegDeleteKey(HKEY_CURRENT_USER, szBuf) != ERROR_SUCCESS)
        {
            DPF("Failed to delete %s key\n", (LPTSTR)szBuf);
            //return FALSE;
        }

        cbSize = sizeof(szBuf);
        if ((RegQueryValue(HKEY_CURRENT_USER, aszDefaultScheme, szBuf, &cbSize)
                                    != ERROR_SUCCESS) || (cbSize < 2))
        {
            DPF("Failed to get value of default scheme\n");
            RegSetDefault(gszNullScheme);
        }
        else
            if (!lstrcmpi(szBuf, szKey))
            {
                RegSetDefault(gszNullScheme);
                RegDeleteScheme(NULL, 0);
            }
    }
    else
    {
        lstrcpy(szKey, (LPTSTR)aszCurrent);
    }
    if (RegOpenKey(HKEY_CURRENT_USER, aszApps, &hkAppList) != ERROR_SUCCESS)
    {
        DPF("Failed to open that %s key\n", (LPTSTR)aszApps);
        return FALSE;
    }
    for (iApp = 0; RegEnumKey(hkAppList, iApp, szApp, sizeof(szApp)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iApp++)
    {
        if (RegOpenKey(hkAppList, szApp, &hkApp) != ERROR_SUCCESS)
        {
            DPF("Failed to open the %s key\n", (LPTSTR)szApp);
            continue;
        }
        for (iEvent = 0; RegEnumKey(hkApp, iEvent, szEvent, sizeof(szEvent)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iEvent++)
        {
            AppendRegKeys (szBuf, szEvent, szKey);
            if (RegDeleteKey(hkApp, szBuf) != ERROR_SUCCESS)
                DPF("No entry for scheme %s under event %s\n", (LPTSTR)szKey,
                                                            (LPTSTR)szEvent);
        }
        RegCloseKey(hkApp);
    }
    RegCloseKey(hkAppList);

    return TRUE;
}

/*
 ***************************************************************
 * LoadEvents
 *
 * Description:
 *      Adds all the events to the CB_EVENTS Combobox, corresponding to
 *        the selected module.
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *        int        iIndex    - The index of the selected module in the Combobox.
 *
 * Returns:    BOOL
 *      TRUE if all the events for the selected module were read from the reg
 *        database, else FALSE
 ***************************************************************
 */
BOOL PASCAL LoadEvents(HWND hwndTree, HTREEITEM htiParent, PMODULE npModule)
{
    PEVENT  npPtr;
    HTREEITEM hti;
    TV_INSERTSTRUCT ti;

    if (npModule == NULL)
    {
        DPF("Couldn't find module\n");
        return FALSE;
    }
    npPtr = npModule->npList;

    for (; npPtr != NULL; npPtr = npPtr->npNextEvent)
    {
        if (!gszCmdLineEvent[0])
        {
            npPtr->iNode = 2;
            ti.hParent = htiParent;
            ti.hInsertAfter = TVI_SORT;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            if (npPtr->fHasSound)
                ti.item.iImage = ti.item.iSelectedImage  = 1;
            else
                ti.item.iImage = ti.item.iSelectedImage  = 2;
            ti.item.pszText = npPtr->pszEventLabel;
            ti.item.lParam = (LPARAM)npPtr;
            hti = TreeView_InsertItem(hwndTree, &ti);

            if (!hti)
            {
                DPF("Couldn't add event Dataitem\n");
                return FALSE;
            }
        }
        else
        {
            // If a command line event was specified, only show this event.
            if (!lstrcmpi(npPtr->pszEventLabel, gszCmdLineEvent))
            {
                npPtr->iNode = 2;
                ti.hParent = htiParent;
                ti.hInsertAfter = TVI_SORT;
                ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                if (npPtr->fHasSound)
                    ti.item.iImage = ti.item.iSelectedImage  = 1;
                else
                    ti.item.iImage = ti.item.iSelectedImage  = 2;
                ti.item.pszText = npPtr->pszEventLabel;
                ti.item.lParam = (LPARAM)npPtr;
                hti = TreeView_InsertItem(hwndTree, &ti);

                if (!hti)
                {
                    DPF("Couldn't add event Dataitem\n");
                    return FALSE;
                }
                break;
            }
        }
    }
    return TRUE;
}

/*
 ***************************************************************
 *  LoadModules
 *
 *  Description: Adds all the strings and event data items to the
 *              list box for the given scheme
 *
 *  Arguments:
 *      HWND    hDlg   -    window handle of dialog window
 *      LPTSTR    lpszScheme  -   The current scheme
 *
 *  Returns:    BOOL
 *      TRUE if the modules for the scheme were read from reg db else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL LoadModules(HWND hDlg, LPTSTR lpszScheme)
{
    TCHAR     szLabel[MAXSTR];
    TCHAR     szApp[MAXSTR];
    TCHAR     szBuf[MAXSTR];
    HWND      hwndTree;
    HKEY      hKeyDisplayName;
    HKEY      hkAppList;
    int       iApp;
    DWORD     cbSize;
    HTREEITEM hti;
    HWND      hWndC =   GetDlgItem(hDlg, CB_SCHEMES);

    hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    ClearModules(hDlg, hwndTree, FALSE);

    if (RegOpenKey(HKEY_CURRENT_USER, aszApps, &hkAppList) != ERROR_SUCCESS)
    {
        DPF("Failed to open %s key\n", (LPTSTR)aszApps);
        return FALSE;
    }

    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);

    for (iApp = 0; RegEnumKey(hkAppList, iApp, szApp, sizeof(szApp)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iApp++)
    {

        AppendRegKeys (szBuf, aszApps, szApp);
        if (RegOpenKey (HKEY_CURRENT_USER, szBuf, &hKeyDisplayName) != ERROR_SUCCESS)
        {
            DPF("Failed to open key %s for event %s\n", (LPTSTR)szBuf, (LPTSTR)szApp);
            // If Key is not found, Display event name
            lstrcpy((LPTSTR)szLabel, szApp);
        }
        else
        {
            cbSize = sizeof(szLabel)/sizeof(TCHAR);
            if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, aszDisplayLabels, szLabel, cbSize))
            {
                // Load Default String if Localized String is not found
                if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, TEXT(""), szLabel, cbSize))
                {
                    // If Default String is not found, load Event name
                    DPF("Failed to get Display value for %s key\n", (LPTSTR)szApp);
                    lstrcpy((LPTSTR)szLabel, szApp);
                }
            }
            RegCloseKey (hKeyDisplayName);
        }

        if(!lstrcmpi((LPTSTR)szLabel, (LPTSTR)aszMMTask))
            continue;

        if (!NewModule(hwndTree, lpszScheme, szLabel, szApp, iApp))
        {
            DPF("failed in new module for %s module\n", (LPTSTR)szApp);
            RegCloseKey(hkAppList);
            return FALSE;
        }
    }
    hti = NULL;

    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
        TreeView_Expand(hwndTree, hti, TVE_EXPAND);

    SendMessage(hwndTree, WM_VSCROLL, (WPARAM)SB_TOP, 0L);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);

    // Select the event if one was passed on the command line.
    if (gszCmdLineEvent[0])
    {
        if ((hti = TreeView_GetRoot(hwndTree)) != NULL) {
            if ((hti = TreeView_GetChild(hwndTree, hti)) != NULL) {
                TreeView_SelectItem(hwndTree, hti);
            }
        }
    }

    RegCloseKey(hkAppList);
    if (iApp == 0)
        return FALSE;

    return TRUE;
}

/***************************************************************
 * NewModule
 *
 * Description:
 *      Adds a data item associated with the module in the CB_MODULE
 *      Combobox control.
 *
 * Parameters:
 *      HWND    hDlg - Dialog window handle.
 *      LPTSTR    lpszScheme - the handle to the key of the current scheme
 *      LPTSTR    lpszLabel - the string to be added to the Combobox
 *      LPTSTR    lpszKey - a string to be added as a data item
 *      int        iVal  - Combobox index where the data item should go

 *
 * returns: BOOL
 *        TRUE if data item is successfully added
 *
 ***************************************************************
 */
BOOL PASCAL NewModule(HWND hwndTree, LPTSTR  lpszScheme, LPTSTR  lpszLabel,
                                                    LPTSTR lpszKey, int iVal)
{
    //int      iIndex;
    int      iEvent;
    LONG     cbSize;
    HKEY     hkApp;
    PMODULE npModule;
    PEVENT  npPtr = NULL;
    PEVENT  npNextPtr = NULL;
    TCHAR     szEvent[MAXSTR];
    TCHAR     szBuf[MAXSTR];
    TCHAR     szTemp[MAXSTR];
    HTREEITEM hti;
    TV_INSERTSTRUCT ti;
    DWORD dwType;
    HKEY hkEvent;
    HKEY hKeyDisplayName;

    npModule = (PMODULE)LocalAlloc(LPTR, sizeof(MODULE));
    if (npModule == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    npModule->pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpszKey)*sizeof(TCHAR)) + sizeof(TCHAR));
    npModule->pszLabel = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpszLabel)*sizeof(TCHAR)) + sizeof(TCHAR));

    if (npModule->pszKey == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    if (npModule->pszLabel == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    lstrcpy(npModule->pszKey, lpszKey);
    lstrcpy(npModule->pszLabel, lpszLabel);

    AppendRegKeys (szBuf, aszApps, lpszKey);
    if (RegOpenKey(HKEY_CURRENT_USER, szBuf, &hkApp) != ERROR_SUCCESS)
    {
        DPF("Failed to open %s key\n", (LPTSTR)szBuf);
        return FALSE;
    }

    for (iEvent = 0; RegEnumKey(hkApp, iEvent, szEvent, sizeof(szEvent)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iEvent++)
    {
        npPtr = (PEVENT)LocalAlloc(LPTR, sizeof(EVENT));
        if (npPtr == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        npPtr->npNextEvent = NULL;
        npPtr->pszEvent = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szEvent)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszEvent == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszEvent, szEvent);

        AppendRegKeys (szBuf, aszLabels, szEvent);
        if (RegOpenKey (HKEY_CURRENT_USER, szBuf, &hKeyDisplayName) != ERROR_SUCCESS)
        {
            DPF("Failed to open key %s for event %s\n", (LPTSTR)szBuf, (LPTSTR)szEvent);
            // If Key is not found, Display event name
            lstrcpy(szTemp, szEvent);
        }
        else
        {
            cbSize = sizeof(szTemp)/sizeof(TCHAR);
            if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, aszDisplayLabels, szTemp, cbSize))
            {
                // Load Default String if Localized String is not found
                if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, TEXT(""), szTemp, cbSize))
                {
                    // If Default String is not found, load Event name
                    DPF("Failed to get Display value for %s key\n", (LPTSTR)szEvent);
                    lstrcpy(szTemp, szEvent);
                }
            }
            RegCloseKey (hKeyDisplayName);
        }
 
        npPtr->pszEventLabel = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTemp)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszEventLabel == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszEventLabel, szTemp);

        // Query name of file; key is szEvent

        AppendRegKeys (szBuf, szEvent, lpszScheme);

        cbSize = sizeof(szTemp);
        if (ExRegQueryValue(hkApp, szBuf, (LPBYTE)szTemp, &cbSize) != ERROR_SUCCESS)
        {
            TCHAR szCurrentScheme[MAX_PATH];

            AppendRegKeys (szCurrentScheme, szEvent, aszCurrent);
            if (lstrcmpi(gszNullScheme, lpszScheme) && !ExRegQueryValue(hkApp, szCurrentScheme, (LPBYTE)szTemp, &cbSize))
            {
                HKEY hkNew;

                if (!RegCreateKey(hkApp, szBuf, &hkNew))
                {
                    if (!RegSetValue(hkNew, NULL, REG_SZ, szTemp, lstrlen(szTemp)+sizeof(TCHAR)) && cbSize >= 5)
                        npPtr->fHasSound = TRUE;
                    else
                        szTemp[0] = TEXT('\0');
                    RegCloseKey(hkNew);
                }
            }
            else
                szTemp[0] = TEXT('\0');
        }
        else if(cbSize < 5)
            szTemp[0] = TEXT('\0');
        else
            npPtr->fHasSound = TRUE;
        npPtr->pszPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTemp)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszPath == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszPath, szTemp);

        npPtr->npNextEvent = NULL;
        if (!npModule->npList)
        {
            npModule->npList = npPtr;
            npNextPtr = npPtr;
        }
        else
        {
            npNextPtr->npNextEvent = npPtr;
            npNextPtr = npNextPtr->npNextEvent;
        }
    }

    RegCloseKey(hkApp);
    npModule->iNode = 1;
    ti.hParent = TVI_ROOT;
    if (!gszCmdLineApp[0])
    {
        if (!lstrcmpi((LPTSTR)npModule->pszLabel, (LPTSTR)gszDefaultApp))
            ti.hInsertAfter = TVI_FIRST;
        else
            ti.hInsertAfter = TVI_LAST;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        ti.item.iImage = ti.item.iSelectedImage = 0;
        ti.item.pszText = npModule->pszLabel;
        ti.item.lParam = (LPARAM)npModule;
        hti = TreeView_InsertItem(hwndTree, &ti);

        if (!hti)
        {
            DPF("Couldn't add module dataitem\n");
            return FALSE;
        }
        LoadEvents(hwndTree, hti, npModule);
    }
    else
    {
        // If a command line app was specified, only show it's events.
        if (!lstrcmpi((LPTSTR)npModule->pszLabel, (LPTSTR)gszCmdLineApp))
        {
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = ti.item.iSelectedImage = 0;
            ti.item.pszText = npModule->pszLabel;
            ti.item.lParam = (LPARAM)npModule;
            hti = TreeView_InsertItem(hwndTree, &ti);

            if (!hti)
            {
                DPF("Couldn't add module dataitem\n");
                return FALSE;
            }
            LoadEvents(hwndTree, hti, npModule);
        }
    }

    return TRUE;
}

/*
 ***************************************************************
 * ClearModules
 *
 * Description:
 *      Frees the storage used for mappings, and removes the
 *      entries in the list box
 *
 * Parameters:
 *      HWND hDlg - Dialog window handle.
 *        BOOL fDisable - If true disable  save, remove and browse controls
 *
 * returns: BOOL
 *
 ***************************************************************
 */
BOOL PASCAL ClearModules(HWND hDlg, HWND hwndTree, BOOL fDisable)
{
    PMODULE npModule;
    PEVENT  npPtr;
    PEVENT  pEvent;
    HTREEITEM hti;
    TV_ITEM    tvi;


    hti = NULL;
    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
    {
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(hwndTree, &tvi);

        npModule = (PMODULE)tvi.lParam;
        if (npModule)
        {
            for (npPtr = npModule->npList; npPtr != NULL;)
            {
                pEvent = npPtr;
                npPtr = npPtr->npNextEvent;
                if (pEvent)
                {
                    LocalFree((HLOCAL)pEvent->pszEvent);
                    LocalFree((HLOCAL)pEvent->pszEventLabel);
                    if (pEvent->pszPath)
                        LocalFree((HLOCAL)pEvent->pszPath);
                    LocalFree((HLOCAL)pEvent);
                }
            }
            LocalFree((HLOCAL)npModule->pszKey);
            LocalFree((HLOCAL)npModule->pszLabel);
            LocalFree((HLOCAL)npModule);
        }
    }
    gfDeletingTree = TRUE;
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);
    TreeView_DeleteAllItems(hwndTree);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);
    gfDeletingTree = FALSE;

    //if (hti)
    //    LocalFree((HLOCAL)szScheme);
    return TRUE;
}

/*
 ***************************************************************
 * AddScheme
 *
 * Description:
 *    Adds a scheme to the CB_SCHEME combobox
 *
 * Parameters:
 *      HWND hDlg - Dialog window handle.
 *        LPTSTR    szLabel        -- Printable name of scheme
 *        LPTSTR    szScheme    -- registry key for scheme
 *        BOOL    fInsert        -- Insert or add
 *        int        iInsert        -- position to insert if finsert is set
 *
 * returns: BOOL
 *
 ***************************************************************
 */
BOOL PASCAL AddScheme(HWND hWndC, LPTSTR szLabel, LPTSTR szScheme,
                                                    BOOL fInsert, int iInsert)
{
    int      iIndex        = 0;
    LPTSTR     pszKey;

    pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szScheme)*sizeof(TCHAR)) + sizeof(TCHAR));
    if (pszKey == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    lstrcpy(pszKey, szScheme);

    if (fInsert)
    {
        if (ComboBox_InsertString(hWndC, iInsert, szLabel) != CB_ERR)
        {
            if (ComboBox_SetItemData(hWndC, iInsert,(LPVOID)pszKey) == CB_ERR)
            {
                DPF("couldn't set itemdata %s\n", (LPTSTR)pszKey);
                return FALSE;
            }
        }
        else
        {
            DPF("couldn't insert %s\n", (LPTSTR)szLabel);
            return FALSE;
        }
    }
    else
    {
        if ((iIndex = ComboBox_AddString(hWndC, szLabel)) != CB_ERR)
        {
            if (ComboBox_SetItemData(hWndC, iIndex, (LPVOID)pszKey) == CB_ERR)
            {
                DPF("couldn't set itemdata %s\n", (LPTSTR)pszKey);
                return FALSE;
            }
        }
        else
        {
            DPF("couldn't add %s\n", (LPTSTR)szLabel);
            return FALSE;
        }
    }
    return TRUE;
}


/*
 ***************************************************************
 * GetMediaPath
 *
 * Description:
 *      Fills in a buffer with the current setting for MediaPath,
 *      with a trailing backslash (usually "c:\windows\media\" etc).
 *      If there's no setting (very unlikely), the return buffer
 *      will be given "".
 *
 ***************************************************************
 */
void PASCAL GetMediaPath (LPTSTR pszMediaPath, size_t cchMax)
{
    static TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

    if (szMediaPath[0] == TEXT('\0'))
    {
        HKEY hk;

        if (RegOpenKey (HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &hk) == 0)
        {
            DWORD dwType;
            DWORD cb = sizeof(szMediaPath);

            if (RegQueryValueEx (hk, REGSTR_VAL_MEDIA, NULL,
                                 &dwType, (LPBYTE)szMediaPath, &cb) != 0)
            {
                szMediaPath[0] = TEXT('\0');
            }

            if ( (szMediaPath[0] != TEXT('\0')) &&
                 (szMediaPath[ lstrlen(szMediaPath)-1 ] != TEXT('\\')) )
            {
                lstrcat (szMediaPath, TEXT("\\"));
            }

            RegCloseKey (hk);
        }
    } 

    lstrcpyn (pszMediaPath, szMediaPath, cchMax-1);
}


/*
 ***************************************************************
 * RemoveMediaPath
 *
 * Description:
 *      Checks to see if a given filename resides within MediaPath;
 *      if so, yanks its parent path ("c:\win\media\ding.wav" becomes
 *      just "ding.wav", etc)
 *
 ***************************************************************
 */
void PASCAL RemoveMediaPath (LPTSTR pszTarget, LPTSTR pszSource)
{
    TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

    GetMediaPath (szMediaPath, MAX_PATH);

    if (szMediaPath[0] == TEXT('\0'))
    {
        lstrcpy (pszTarget, pszSource);
    }
    else
    {
        size_t cch = lstrlen (szMediaPath);

        if (!lstrnicmp (pszSource, szMediaPath, cch))
        {
            lstrcpy (pszTarget, &pszSource[ cch ]);
        }
        else
        {
            lstrcpy (pszTarget, pszSource);
        }
    }
}


/*
 ***************************************************************
 * AddMediaPath
 *
 * Description:
 *      If the given filename doesn't have a path, prepends the
 *      current setting of MediaPath to it ("ding.wav"->"c:\win\media\ding.wav")
 *
 ***************************************************************
 */
void PASCAL AddMediaPath (LPTSTR pszTarget, LPTSTR pszSource)
{
    if (lstrchr (pszSource, TEXT('\\')) != NULL)
    {
        lstrcpy (pszTarget, pszSource);
    }
    else
    {
        TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

        GetMediaPath (szMediaPath, MAX_PATH);

        if (szMediaPath[0] == TEXT('\0'))
        {
            lstrcpy (pszTarget, pszSource);
        }
        else
        {
            lstrcpy (pszTarget, szMediaPath);
            lstrcat (pszTarget, pszSource);
        }
    }
}


/*
 ***************************************************************
 * ExRegQueryValue
 *
 * Description:
 *      Just a wrapper for RegQueryValue(); this one doesn't choke
 *      on REG_EXPAND_SZ's.
 *
 ***************************************************************
 */
int ExRegQueryValue (HKEY hkParent, LPTSTR szSubKey, LPBYTE pszBuffer, DWORD *pdwSize)
{
   HKEY hkSubKey;
   int rc;

   if ((rc = RegOpenKey (hkParent, szSubKey, &hkSubKey)) == ERROR_SUCCESS)
   {
       DWORD dwType;

       rc = RegQueryValueEx (hkSubKey, NULL, NULL, &dwType, pszBuffer, pdwSize);

       RegCloseKey (hkSubKey);
   }

   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\sndfile.c ===
/*
 ***************************************************************
 *  sndfile.c
 *
 *  This file contains the code to fill up the list and combo boxes,
 *  show the RIFF Dibs and the current sound mappings 
 *
 *  Copyright 1993, Microsoft Corporation     
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *        
 ***************************************************************
 */
#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <ole2.h>
#include <prsht.h>
#include <cpl.h>
#include "mmcpl.h"
#include "draw.h"
#include "sound.h"

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */
HSOUND ghse;


/*
 ***************************************************************
 * extern
 ***************************************************************
 */
extern TCHAR        gszMediaDir[];
extern TCHAR        gszCurDir[];
extern BOOL        gfWaveExists;   // indicates wave device in system.
extern BOOL        gfChanged;      // Is set TRUE if any changes are made
extern BOOL        gfNewScheme;  

//Globals used in painting disp chunk display.
extern HTREEITEM   ghOldItem;

/*
 ***************************************************************
 * Defines 
 ***************************************************************
 */                                                
#define DF_PM_SETBITMAP    (WM_USER+1)   
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')
#define MAXDESCLEN    220

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
HANDLE PASCAL GetRiffDisp        (HMMIO);
BOOL PASCAL ShowSoundMapping    (HWND, PEVENT);
BOOL PASCAL ChangeSoundMapping  (HWND, LPTSTR, PEVENT);
BOOL PASCAL PlaySoundFile       (HWND, LPTSTR);
BOOL PASCAL ChangeSetting        (LPTSTR*, LPTSTR);
LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath);

// Stuff in dib.c
//
HPALETTE WINAPI  bmfCreateDIBPalette(HANDLE);
HBITMAP  WINAPI  bmfBitmapFromDIB(HANDLE, HPALETTE);

// Stuff in drivers.c
//
LPTSTR lstrchr (LPTSTR, TCHAR);
int lstrnicmp (LPTSTR, LPTSTR, size_t);

// Stuff in scheme.c
//
void PASCAL AddMediaPath        (LPTSTR, LPTSTR);

/*
 ***************************************************************
 ***************************************************************
 */
STATIC void NEAR PASCAL ChopPath(LPTSTR lpszFile)
{
    TCHAR szTmp[MAX_PATH];
    size_t cchTest = lstrlen (gszCurDir);

    szTmp[0] = TEXT('\0');

    ExpandEnvironmentStrings(lpszFile, (LPTSTR)szTmp, MAXSTR);
    lstrcpy(lpszFile,szTmp);

    if (gszCurDir[ cchTest-1 ] == TEXT('\\'))
       --cchTest;
    
    lstrcpy((LPTSTR)szTmp, lpszFile);
    if (!lstrnicmp((LPTSTR)szTmp, (LPTSTR)gszCurDir, cchTest))
    {
        if (szTmp[ cchTest ] == TEXT('\\'))
        {
            lstrcpy(lpszFile, (LPTSTR)(szTmp+cchTest+1));
        }
    }
}
/*
 ***************************************************************
 * QualifyFileName
 *
 * Description:
 *    Verifies the existence and readability of a file.
 *
 * Parameters:
 *    LPTSTR    lpszFile    - name of file to check.
 *    LPTSTR    lpszPath    - returning full pathname of file.     
 *  int        csSize        - Size of return buffer
 *
 * Returns:    BOOL
 *         True if absolute path exists
 *
 ***************************************************************
 */

BOOL PASCAL QualifyFileName(LPTSTR lpszFile, LPTSTR lpszPath, int cbSize, BOOL fTryCurDir)
{
    BOOL     fErrMode;
    BOOL     f = FALSE;
    BOOL     fHadEnvStrings;
    TCHAR     szTmpFile[MAXSTR];
    int len;
    BOOL fTriedCurDir;
    TCHAR*      pszFilePart;
    HFILE   hFile;

    if (!lpszFile)
        return FALSE;

    fHadEnvStrings = (lstrchr (lpszFile, TEXT('%')) != NULL) ? TRUE : FALSE;

    ExpandEnvironmentStrings (lpszFile, (LPTSTR)szTmpFile, MAXSTR);
    len =  lstrlen((LPTSTR)szTmpFile)+1;

    fErrMode = SetErrorMode(TRUE);  // we will handle errors

    AddExt (szTmpFile, cszWavExt);

    fTriedCurDir = FALSE;

TryOpen:
    hFile = (HFILE)HandleToUlong(CreateFile(szTmpFile,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    if (-1 != hFile)
    {
        if (fHadEnvStrings)
            lstrcpyn(lpszPath, lpszFile, cbSize);
        else
            GetFullPathName(szTmpFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
        f = TRUE;

        CloseHandle(LongToHandle(hFile));
    }
    else
    /*
    ** If the test above failed, we try converting the name to OEM
    ** character set and try again.
    */
    {
        /*
        ** First, is it in MediaPath?
        **
        */
        if (lstrchr (lpszFile, TEXT('\\')) == NULL)
        {
            TCHAR szCurDirFile[MAXSTR];
            AddMediaPath (szCurDirFile, lpszFile);
            if (-1 != (HFILE)HandleToUlong(CreateFile(szCurDirFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
            {
                GetFullPathName(szCurDirFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
                f = TRUE;
                goto DidOpen;
            }
        }

        //AnsiToOem((LPTSTR)szTmpFile, (LPTSTR)szTmpFile);
        if (-1 != (HFILE)HandleToUlong(CreateFile(szTmpFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
        {
            if (fHadEnvStrings)
                lstrcpyn(lpszPath, lpszFile, cbSize);
            else
                GetFullPathName(szTmpFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
            f = TRUE;
        }
        else if (fTryCurDir && !fTriedCurDir)
        {
            TCHAR szCurDirFile[MAXSTR];

            //OemToAnsi((LPTSTR)szTmpFile, (LPTSTR)szTmpFile);
            lstrcpy (szCurDirFile, gszCurDir);
            lstrcat (szCurDirFile, cszSlash);
            lstrcat (szCurDirFile, szTmpFile);
            lstrcpy((LPTSTR)szTmpFile, (LPTSTR)szCurDirFile);
            fTriedCurDir = TRUE;
            goto  TryOpen;
        }
    }

DidOpen:
    SetErrorMode(fErrMode);
    return f;
}



/*
 ***************************************************************
 * ChangeSoundMapping
 *
 * Description:
 *      Change the sound file associated with a sound
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *      LPTSTR    lpszFile    - New filename for current event
 *      LPTSTR    lpszDir    - New foldername for current event     
 *      LPTSTR    lpszPath    - New absolute path for file
 *
 * Returns:        BOOL
 *      
 ***************************************************************
 */
BOOL PASCAL ChangeSoundMapping(HWND hDlg, LPTSTR lpszPath, PEVENT pEvent)
{
    TCHAR    szValue[MAXSTR];    
    
    if (!pEvent)
    {
        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);            
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);
        ShowSoundMapping(hDlg,NULL);
        return TRUE;
    }
    szValue[0] = TEXT('\0');
    if (!ChangeSetting((LPTSTR *)&(pEvent->pszPath), lpszPath))
        return FALSE;        
    if(!ghse)
        EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);            
    EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), TRUE);            
    ShowSoundMapping(hDlg,pEvent);
    gfChanged = TRUE;
    gfNewScheme = TRUE;
    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}

STATIC void SetTreeStateIcon(HWND hDlg, int iImage)
{
    TV_ITEM tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    HTREEITEM hti;

    if (ghOldItem)
        hti = ghOldItem;
    else
        hti = TreeView_GetSelection(hwndTree);
    if (hti)
    {
        tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvi.hItem = hti;
        tvi.iImage = tvi.iSelectedImage = iImage;
        TreeView_SetItem(hwndTree, &tvi);
        RedrawWindow(hwndTree, NULL, NULL, RDW_ERASE|RDW_ERASENOW|RDW_INTERNALPAINT|RDW_INVALIDATE | RDW_UPDATENOW);
    }
}

/*
 ***************************************************************
 * ShowSoundMapping
 *
 * Description:
 *      Highlights the label and calls ShowSoundDib to display the Dib 
 *        associated with the current event.
 *
 * Parameters:
 *    HWND    hDlg   - handle to dialog window.
 *
 * Returns:    BOOL
 *      
 ***************************************************************
 */
BOOL PASCAL ShowSoundMapping(HWND hDlg, PEVENT pEvent)
{
    TCHAR    szOut[MAXSTR];            

    if (!pEvent)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);            
        EnableWindow(GetDlgItem(hDlg, ID_BROWSE), FALSE);            
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), FALSE);    
    //    wsprintf((LPTSTR)szCurSound, (LPTSTR)gszSoundGrpStr, (LPTSTR)gszNull);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), TRUE);            
        EnableWindow(GetDlgItem(hDlg, ID_BROWSE), TRUE);            
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), TRUE);    
    //    wsprintf((LPTSTR)szCurSound, (LPTSTR)gszSoundGrpStr, (LPTSTR)pEvent->pszEventLabel);
    }
    //SetWindowText(GetDlgItem(hDlg, IDC_SOUNDGRP), (LPTSTR)szCurSound);
    //RedrawWindow(GetDlgItem(hDlg, IDC_EVENT_TREE), NULL, NULL, RDW_ERASE|RDW_ERASENOW|RDW_INTERNALPAINT|RDW_INVALIDATE | RDW_UPDATENOW);

    if (!pEvent || !QualifyFileName(pEvent->pszPath, szOut, sizeof(szOut), FALSE))
    {
        int iLen;

        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
        
        if(pEvent)
            iLen = lstrlen(pEvent->pszPath);
        if (pEvent && iLen > 0)
        {
            if (iLen < 5)
            {
                lstrcpy(pEvent->pszPath, gszNull);
                gfChanged = TRUE;
                gfNewScheme = TRUE;
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
            else
            {
                TCHAR szMsg[MAXSTR];
                TCHAR szTitle[MAXSTR];

                LoadString(ghInstance, IDS_NOSNDFILE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                wsprintf(szMsg, szTitle, pEvent->pszPath);
                LoadString(ghInstance, IDS_NOSNDFILETITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                if (MessageBox(hDlg, szMsg, szTitle, MB_YESNO) == IDNO)
                {
                    lstrcpy(pEvent->pszPath, gszNull);
                    ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), gszNone);                
                    gfChanged = TRUE;
                    gfNewScheme = TRUE;
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                    if (pEvent && pEvent->fHasSound)
                    {
                        SetTreeStateIcon(hDlg, 2);
                        pEvent->fHasSound = FALSE;
                    }
                }
                else
                {
                    lstrcpy(szOut ,pEvent->pszPath); 
                    ChopPath((LPTSTR)szOut);
                    NiceName((LPTSTR)szOut, FALSE);
                    ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szOut);
                    if (!pEvent->fHasSound)
                    {
                        SetTreeStateIcon(hDlg, 1);
                        pEvent->fHasSound = TRUE;
                    }
                }
            }
        }
        else
        {
            ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), gszNone);                
            if (pEvent && pEvent->fHasSound)
            {
                SetTreeStateIcon(hDlg, 2);
                pEvent->fHasSound = FALSE;
            }
        }
    }
    else
    {
        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY),gfWaveExists);
        ChopPath((LPTSTR)szOut);
        NiceName((LPTSTR)szOut, FALSE);
        ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szOut);
        if (!pEvent->fHasSound)
        {
            SetTreeStateIcon(hDlg, 1);
            pEvent->fHasSound = TRUE;
        }

    }
    return TRUE;
}

/*
 ***************************************************************
 * PlaySoundFile
 *
 * Description:
 *        Plays the given sound file.
 *
 * Parameters:
 *    HWND  hDlg   - Window handle
 *      LPTSTR    lpszFile - absolute path of File to play.
 *
 * Returns:    BOOL 
 *  
 ***************************************************************
 */
BOOL PASCAL PlaySoundFile(HWND hDlg, LPTSTR lpszFile)
{
        
    TCHAR     szOut[MAXSTR];            
    TCHAR     szTemp[MAXSTR]; 
	BOOL      rb = TRUE;
        
    if (!QualifyFileName(lpszFile, szTemp, sizeof(szTemp), FALSE))
	{
        ErrorBox(hDlg, IDS_ERRORPLAY, lpszFile);
		rb = FALSE;
	}
    else{
        MMRESULT err = MMSYSERR_NOERROR;

        ExpandEnvironmentStrings (szTemp, szOut, MAXSTR);

        if((soundOpen(szOut, hDlg, &ghse) != MMSYSERR_NOERROR) || ((err = soundPlay(ghse)) != MMSYSERR_NOERROR))
        {
            if (err >= (MMRESULT)MMSYSERR_LASTERROR)
                ErrorBox(hDlg, IDS_ERRORUNKNOWNPLAY, lpszFile);
            else if (err ==  (MMRESULT)MMSYSERR_ALLOCATED)
                ErrorBox(hDlg, IDS_ERRORDEVBUSY, lpszFile);
            else
                ErrorBox(hDlg, IDS_ERRORFILEPLAY, lpszFile);
            ghse = NULL;
			rb = FALSE;
        }
    }
    return rb;    
}

/*
 ***************************************************************
 * ChangeSetting
 *
 * Description:
 *        Displays the labels of all the links present in the lpszDir folder
 *        in the LB_SOUNDS listbox
 *
 * Parameters:
 *    HWND  hDlg   - Window handle
 *      LPTSTR lpszDir -  Name of sound folder whose files must be displayed.
 *
 * Returns:    BOOL
 *  
 ***************************************************************
 */
BOOL PASCAL ChangeSetting(LPTSTR *npOldString, LPTSTR lpszNew)
{
    int len =  (lstrlen(lpszNew)*sizeof(TCHAR))+sizeof(TCHAR);

    if (*npOldString)
    {
        *npOldString = (LPTSTR)LocalReAlloc((HLOCAL)*npOldString, 
                                    len, LMEM_MOVEABLE);
    }
    else
    {
        DPF("Current file Does not exist\n");        
        *npOldString = (LPTSTR)LocalAlloc(LPTR, len);
    }

    if (*npOldString == NULL)
    {
        DPF("ReAlloc Failed\n");        
        return FALSE;            
    }                                                
    lstrcpy(*npOldString, lpszNew);
    DPF("New file is %s\n", (LPTSTR)*npOldString);    
    return TRUE;
}



STATIC HANDLE PASCAL GetRiffDisp(HMMIO hmmio)
{
    MMCKINFO    ck;
    MMCKINFO    ckRIFF;
    HANDLE    h = NULL;
    LONG        lSize;
    DWORD       dw;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != (LONG)sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and 
                    lock it down */
                
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
        }
        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
    {
        GlobalUnlock(h);
        GlobalFree(h);
    }
    h = NULL;

exit:
    return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\roland.h ===
//--------------------------------------------------------------------------;
//
//  File: Roland.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

STDAPI_(void) RolandProp(HWND hwnd, HINSTANCE hInst, TCHAR *szName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\sound.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//	sound.h
//
//	Copyright (C) 1994 Microsoft Corporation.  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

DECLARE_HANDLE(HSOUND);
typedef HSOUND * PHSOUND;

/*	-	-	-	-	-	-	-	-	*/
void FAR PASCAL soundOnDone(
	HSOUND	hs);
MMRESULT FAR PASCAL soundOpen(
	LPCTSTR	pszSound,
	HWND	hwndNotify,
	PHSOUND	phs);
MMRESULT FAR PASCAL soundClose(
	HSOUND	hs);
MMRESULT FAR PASCAL soundPlay(
	HSOUND	hs);
MMRESULT FAR PASCAL soundStop(
	HSOUND	hs);

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\subobj.h ===
//****************************************************************************
//
//  Module:     mmsys.cpl
//  File:       subobj.h
//  Content:    This file contains the subobject (our own object)
//              storage space and manipulation mechanisms.
//
//  History:
//  06/94	VijR      Created
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#ifndef _SUBOBJ_H_
#define _SUBOBJ_H_

// This structure is used as the LPITEMIDLIST that
// the shell uses to identify objects in a folder.  The
// first two bytes are required to indicate the size,
// the rest of the data is opaque to the shell.
typedef struct _SUBOBJ
    {
    USHORT  cbSize;             // Size of this struct
    UINT    uFlags;             // One of SOF_ values
	short nIconIndex;
	short iSort;
	short iOffsetIconFile;
	short iOffsetDesc;
	short iOffsetClass;
	short iOffsetExtPropFile;
	short iOffsetExtPropFunc;
	short iOffsetExtCLSID;
	short iOffsetPlayCmdLn;
	short iOffsetOpenCmdLn;
	short iOffsetNewCmdLn;
	HICON	hClassIcon;
    struct _SUBOBJ FAR * psoNext;
    TCHAR    szName[1];          // Display name
    } SUBOBJ, FAR * PSUBOBJ;


//  LPCTSTR Subobj_GetName(PSUBOBJ pso);
//
//   Gets the subobject name.
//
#define Subobj_GetName(pso)     ((pso)->szName)

//  UINT Subobj_GetFlags(PSUBOBJ pso);
//
//   Gets the subobject flags.
//
#define Subobj_GetFlags(pso)     ((pso)->uFlags)


//  int Subobj_GetIconIndex(PSUBOBJ pso);
//
//   Gets the subobject icon.
//
#define Subobj_GetIconIndex(pso)     ((pso)->nIconIndex)

//  LPTSTR Subobj_GetIconFile(PSUBOBJ pso);
//
//   Gets the subobject icon Index in file.
//
#define Subobj_GetIconFile(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetIconFile))

//  LPTSTR Subobj_GetDesc(PSUBOBJ pso);
//
//   Gets the subobject IconFile name.
//
#define Subobj_GetDesc(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetDesc))

//  LPTSTR Subobj_GetClass(PSUBOBJ pso);
//
//   Gets the subobject Clas Name
//
#define Subobj_GetClass(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetClass))

//  int Subobj_GetSortIndex(PSUBOBJ pso);
//
//   Gets the subobject Sort order.
//
#define Subobj_GetSortIndex(pso)     ((pso)->iSort)

//  HICON Subobj_GetClassIcon(PSUBOBJ pso);
//
//   Gets the subobject Object Icon.
//
#define Subobj_GetClassIcon(pso)     ((pso)->hClassIcon)

//  LPTSTR Subobj_GetExtPropFile(PSUBOBJ pso);
//
//   Gets the subobject External Class File.
//
#define Subobj_GetExtPropFile(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtPropFile))

//  LPTSTR Subobj_GetExtPropFunc(PSUBOBJ pso);
//
//   Gets the subobject External Class Func.
//
#define Subobj_GetExtPropFunc(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtPropFunc))

//  LPTSTR Subobj_GetExtCLSID(PSUBOBJ pso);
//
//   Gets the subobject external CLSID.
//
#define Subobj_GetExtCLSID(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtCLSID))

//  LPTSTR Subobj_GetPlayCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line
//
#define Subobj_GetPlayCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetPlayCmdLn))

//  LPTSTR Subobj_GetOpenCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line
//
#define Subobj_GetOpenCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetOpenCmdLn))

//  LPTSTR Subobj_GetNewCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line.
//
#define Subobj_GetNewCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetNewCmdLn))

// Some other Subobj functions...
//
BOOL    PUBLIC Subobj_New(PSUBOBJ FAR * ppso, LPCTSTR pszClass, LPCTSTR pszName, 	LPCTSTR pszDesc, LPCTSTR pszIconFile, 	LPCTSTR pszExtPropFile, 
							LPCTSTR pszExtPropFunc,LPCTSTR pszExtCLSID, LPCTSTR pszPlayCmdLn, LPCTSTR pszOpenCmdLn,
							LPCTSTR pszNewCmdLn,short nIconIndex, UINT uFlags, short iSort);
void    PUBLIC Subobj_Destroy(PSUBOBJ pso);
BOOL    PUBLIC Subobj_Dup(PSUBOBJ FAR * ppso, PSUBOBJ psoArgs);

#ifdef DEBUG

void PUBLIC Subobj_Dump(PSUBOBJ pso);

#endif

typedef struct _SUBOBJSPACE
    {
    PSUBOBJ     psoFirst;
    PSUBOBJ     psoLast;
    int         cItems;
	int			cRef;

    } SUBOBJSPACE, FAR * PSUBOBJSPACE;

//  PSUBOBJ Sos_FirstItem(void);
//
//   Returns the first object in the subobject space.  NULL if empty.
//
#define Sos_FirstItem(psos)         (psos->psoFirst)

//  PSUBOBJ Sos_NextItem(PSUBOBJ pso);
//
//   Returns the next object in the subobject space.  NULL if no more 
//   objects.
//
#define Sos_NextItem(pso)       (pso ? pso->psoNext : NULL)


// Other subobject space functions
//
PSUBOBJ PUBLIC Sos_FindItem(PSUBOBJSPACE psos, LPCTSTR pszName);
BOOL    PUBLIC Sos_AddItem(PSUBOBJSPACE psos, PSUBOBJ pso);
USHORT  PUBLIC Sos_GetMaxSize(PSUBOBJSPACE psos);
PSUBOBJ PUBLIC Sos_RemoveItem(PSUBOBJSPACE psos, LPCTSTR pszName);
void    PUBLIC Sos_Destroy(PSUBOBJSPACE psos);
int     PUBLIC Sos_FillFromRegistry(PSUBOBJSPACE psos, LPITEMIDLIST pidl);
BOOL    PUBLIC Sos_Init(PSUBOBJSPACE psos, LPITEMIDLIST pidl, BOOL fAdvancedFolder);
HRESULT PUBLIC Sos_AddRef(PSUBOBJSPACE psos, LPITEMIDLIST pidl, BOOL fAdvancedFolder);
void    PUBLIC Sos_Release(PSUBOBJSPACE psos);


#define SOF_ISFOLDER		0x0001
#define SOF_ISDROPTARGET	0x0002
#define SOF_CANDELETE		0x0004
#define SOF_HASEXTPROPSHEET	0x0008
#define SOF_ISEXTOBJECT		0x0010
#define SOF_DOESPLAY		0x0020
#define SOF_DOESOPEN		0x0040
#define SOF_DOESNEW			0x0080


#define SOUNDEVENTS TEXT("Sound Events")
#define WAVE		TEXT("Wave")
#define MIDI		TEXT("MIDI")
#define MIXER		TEXT("Mixer")
#define AUX			TEXT("Aux")
#define ACM			TEXT("ACM")
#define ICM			TEXT("ICM")
#define MCI			TEXT("MCI")
#define AUDIO		TEXT("Audio")
#define CDAUDIO		TEXT("CDAudio")
#define VIDEO		TEXT("Video")
#define VOICE		TEXT("Voice")
#define ADVANCEDFOLDER TEXT("Advanced Folder")

#ifdef DEBUG

void PUBLIC Sos_DumpList(void);

#endif

//extern SUBOBJSPACE g_sos;

//
// Other prototypes...
//

HRESULT PUBLIC mmseObj_CreateInstance(LPSHELLFOLDER psf, UINT cidl, BOOL fInAdvancedFolder, LPCITEMIDLIST FAR * ppidl, LPCITEMIDLIST pidlRoot, LPSHELLVIEW csv, REFIID riid, LPVOID FAR * ppvOut);
HRESULT NEAR PASCAL mmseView_Command(LPSHELLVIEW psv, HWND hwnd,  UINT uID);


LPTSTR   PUBLIC lmemset(LPTSTR dst, char val, UINT count);
LPTSTR   PUBLIC lmemmove(LPTSTR dst, LPTSTR src, int count);
int     PUBLIC AnsiToInt(LPCTSTR pszString);

int     PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);

HMENU   PUBLIC LoadPopupMenu(UINT id, UINT uSubOffset);
UINT    PUBLIC MergePopupMenu(HMENU FAR *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
HMENU   PUBLIC GetMenuFromID(HMENU hmMain, UINT uID);

#endif // _SUBOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\speakers.h ===
//--------------------------------------------------------------------------;
//
//  File: speakers.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef SPEAKERS_HEADER
#define SPEAKERS_HEADER

#define TYPE_NOSPEAKERS        0
#define TYPE_HEADPHONES        1
#define TYPE_STEREODESKTOP     2
#define TYPE_MONOLAPTOP        3
#define TYPE_STEREOLAPTOP      4
#define TYPE_STEREOMONITOR     5
#define TYPE_STEREOCPU         6
#define TYPE_MOUNTEDSTEREO     7
#define TYPE_STEREOKEYBOARD    8
#define TYPE_QUADRAPHONIC      9
#define TYPE_SURROUND          10
#define TYPE_SURROUND_5_1      11
#define TYPE_SURROUND_7_1      12
#define MAX_SPEAKER_TYPE       TYPE_SURROUND_7_1


INT_PTR CALLBACK SpeakerHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void VerifySpeakerConfig(DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType);
DWORD GetSpeakerConfigFromType(DWORD dwType);

#define SPEAKERS_DEFAULT_CONFIG      DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE)
#define SPEAKERS_DEFAULT_TYPE        TYPE_STEREODESKTOP


#endif // SPEAKERS_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\sound.c ===
/*    -    -    -    -    -    -    -    -    */
//
//    sound.c
//
//    Copyright (C) 1994 Microsoft Corporation.  All Rights Reserved.
//
/*    -    -    -    -    -    -    -    -    */

#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "sound.h"
#include <tchar.h>

/*    -    -    -    -    -    -    -    -    */
typedef struct tagSOUND FAR *PSOUND;
typedef struct tagSOUND 
{
    WAVEHDR        header;
    LPBYTE        pbData;
    DWORD        cbLength;
    LPWAVEFORMATEX    lpwfx;
    HGLOBAL        hgData;
    HWAVEOUT    hwave;
    HWND        hwndNotify;
} SOUND;

typedef struct 
{
    FOURCC    fccRiff;
    DWORD    cbSize;
    FOURCC    fccWave;
} FILEHEADER,  *LPFILEHEADER;


typedef struct 
{
    DWORD    dwCKID;
    DWORD    dwSize;
} CHUNKHEADER,  *LPCHUNKHEADER;

#define    RIFF_FILE    MAKEFOURCC('R','I','F','F')
#define    RIFF_WAVE    MAKEFOURCC('W','A','V','E')
#define    RIFF_FORMAT    MAKEFOURCC('f','m','t',' ')
#define    RIFF_DATA    MAKEFOURCC('d','a','t','a')

/*    -    -    -    -    -    -    -    -    */
#ifdef DEBUG
#define    STATIC
#else
#define    STATIC    static
#endif

typedef CHUNKHEADER UNALIGNED FAR *ULPCHUNKHEADER;
typedef WAVEFORMATEX UNALIGNED FAR *ULPWAVEFORMATEX;

/*    -    -    -    -    -    -    -    -    */
STATIC MMRESULT NEAR PASCAL soundInitWaveHeader(
    PSOUND    ps)
{
    size_t cbWFX;
    ULPWAVEFORMATEX    pwfx;
    ULPCHUNKHEADER    pckhdr;
    LPFILEHEADER    pfhdr;
    LPBYTE        pbData;
    DWORD        dwFileSize;
    DWORD        dwCurPos;

    if (ps->cbLength < sizeof(FILEHEADER))
        return MMSYSERR_INVALPARAM;
    pfhdr = (LPFILEHEADER)ps->pbData;
    if ((pfhdr->fccRiff != RIFF_FILE) || (pfhdr->fccWave != RIFF_WAVE))
        return MMSYSERR_NOTSUPPORTED;
    dwFileSize = pfhdr->cbSize;
    dwCurPos = sizeof(FILEHEADER);
    pbData = (LPBYTE)ps->pbData + sizeof(FILEHEADER);
    if (ps->cbLength < dwFileSize)
        return MMSYSERR_INVALPARAM;
    for (;;) 
    {
        pckhdr = (ULPCHUNKHEADER)pbData;
        if (pckhdr->dwCKID == RIFF_FORMAT)
            break;
        dwCurPos += pckhdr->dwSize + sizeof(CHUNKHEADER);
        if (dwCurPos >= dwFileSize)
            return MMSYSERR_INVALPARAM;
        pbData += pckhdr->dwSize + sizeof(CHUNKHEADER);
    }
    pwfx = (ULPWAVEFORMATEX)(pbData + sizeof(CHUNKHEADER));
    
    cbWFX = sizeof(WAVEFORMATEX);
    if (pwfx->wFormatTag!=WAVE_FORMAT_PCM)
    {
        cbWFX += pwfx->cbSize;
    }

    if ((ps->lpwfx = (LPWAVEFORMATEX)GlobalAlloc (GMEM_FIXED, cbWFX)) == 0)
        return MMSYSERR_NOMEM;

    memcpy ((char *)ps->lpwfx, pwfx, cbWFX);

    pbData = pbData + ((ULPCHUNKHEADER)pbData)->dwSize + sizeof(CHUNKHEADER);
    for (;;) 
    {
        pckhdr = (ULPCHUNKHEADER)pbData;
        if (pckhdr->dwCKID == RIFF_DATA)
            break;
        dwCurPos += pckhdr->dwSize + sizeof(CHUNKHEADER);
        if (dwCurPos >= dwFileSize) 
        {
            GlobalFree ((HGLOBAL)ps->lpwfx);
            ps->lpwfx = NULL;
            return MMSYSERR_INVALPARAM;
        }
        pbData += pckhdr->dwSize + sizeof(CHUNKHEADER);
    }
    ps->header.lpData = pbData + sizeof(CHUNKHEADER);
    ps->header.dwBufferLength = pckhdr->dwSize;
    ps->header.dwBytesRecorded = 0;
    ps->header.dwUser = (DWORD_PTR)ps;
    ps->header.dwFlags = 0;
    ps->header.dwLoops = 0;
    ps->header.lpNext = NULL;
    ps->header.reserved = 0;
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
STATIC MMRESULT NEAR PASCAL soundLoadFile(
    LPCTSTR    pszSound,
    HWND    hwndNotify,
    PSOUND    ps)
{
    HFILE        hf;
    MMRESULT    mmr;

    if ((hf = HandleToUlong(CreateFile(pszSound,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) != HFILE_ERROR) 
    {
        ps->cbLength = _llseek(hf, 0L, SEEK_END);
        _llseek(hf, 0L, SEEK_SET);
        if (ps->hgData = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, ps->cbLength)) 
        {
            if (ps->pbData = GlobalLock(ps->hgData)) 
            {
                if (_hread(hf, ps->pbData, ps->cbLength) == (LONG)ps->cbLength) 
                {
                    if (!(mmr = soundInitWaveHeader(ps))) 
                    {
                        _lclose(hf);
                        ps->hwndNotify = hwndNotify;
                        return MMSYSERR_NOERROR;
                    }
                } 
                else
                    mmr = MMSYSERR_ERROR;
                GlobalUnlock(ps->hgData);
            } 
            else
                mmr = MMSYSERR_ERROR;
            GlobalFree(ps->hgData);
        } 
        else
            mmr = MMSYSERR_NOMEM;
        _lclose(hf);
    } 
    else
        mmr = MMSYSERR_ERROR;

    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
void FAR PASCAL soundOnDone(
    HSOUND    hs)
{
    PSOUND        ps;

    ps = (PSOUND)hs;
    waveOutUnprepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR));
    waveOutClose(ps->hwave);
    ps->hwave = NULL;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundOpen(
    LPCTSTR    pszSound,
    HWND    hwndNotify,
    PHSOUND    phs)
{
    MMRESULT    mmr;

    if (!(*phs = (HSOUND)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(SOUND))))
        return MMSYSERR_NOMEM;
    if (mmr = soundLoadFile(pszSound, hwndNotify, (PSOUND)*phs))
        LocalFree((HLOCAL)*phs);
    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundClose(
    HSOUND    hs)
{
    PSOUND        ps;
    MMRESULT    mmr;

    if (mmr = soundStop(hs))
        return mmr;
    ps = (PSOUND)hs;
    if (ps->lpwfx != NULL) {
        GlobalFree ((HGLOBAL)ps->lpwfx);
        ps->lpwfx = NULL;
    }
    GlobalUnlock(ps->hgData);
    GlobalFree(ps->hgData);
    LocalFree((HLOCAL)hs);
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundPlay(
    HSOUND    hs)
{
    PSOUND        ps;
    MMRESULT    mmr;

    if (mmr = soundStop(hs))
        return mmr;
    ps = (PSOUND)hs;
    if (!(mmr = waveOutOpen(&ps->hwave, WAVE_MAPPER, ps->lpwfx, (DWORD_PTR)ps->hwndNotify, (DWORD_PTR)ps, CALLBACK_WINDOW | WAVE_ALLOWSYNC))) 
    {
        ps->header.dwFlags &= ~WHDR_DONE;
        if (!(mmr = waveOutPrepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR)))) 
        {
            if (!(mmr = waveOutWrite(ps->hwave, &ps->header, sizeof(WAVEHDR))))
                return MMSYSERR_NOERROR;
            waveOutUnprepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR));
        }
        waveOutClose(ps->hwave);
        ps->hwave = NULL;
    }
    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundStop(
    HSOUND    hs)
{
    PSOUND        ps;
    MSG        msg;

    ps = (PSOUND)hs;
    if (ps->hwave)
        waveOutReset(ps->hwave);
    if (IsWindow(ps->hwndNotify))
    while (PeekMessage(&msg, ps->hwndNotify, MM_WOM_OPEN, MM_WOM_DONE, PM_REMOVE))
    {
        DispatchMessage(&msg);
    }
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\speakers.cpp ===
//--------------------------------------------------------------------------;
//
//  File: speakers.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"

#include <dsound.h>
#include "advaudio.h"
#include "speakers.h" 
#include "dslevel.h"

/////////////
// defines
/////////////

#define NUMCONFIG   (MAX_SPEAKER_TYPE + 1)


//////////                                           
// Globals
//////////

DWORD gdwSpeakerTable[NUMCONFIG] =
{ 
    DSSPEAKER_DIRECTOUT,
    DSSPEAKER_HEADPHONE,
    SPEAKERS_DEFAULT_CONFIG,
    DSSPEAKER_MONO,
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_QUAD,
    DSSPEAKER_SURROUND,
    DSSPEAKER_5POINT1,
    DSSPEAKER_7POINT1
};

DWORD gdwImageID[NUMCONFIG] =     
{ 
    IDB_NOSPEAKERS,
    IDB_HEADPHONES,
    IDB_STEREODESKTOP,
    IDB_MONOLAPTOP,
    IDB_STEREOLAPTOP,
    IDB_STEREOMONITOR, 
    IDB_STEREOCPU,
    IDB_MOUNTEDSTEREO,
    IDB_STEREOKEYBOARD,
    IDB_QUADRAPHONIC,
    IDB_SURROUND,
    IDB_SURROUND_5_1,
    IDB_SURROUND_7_1
};

HBITMAP ghBitmaps[NUMCONFIG];



//////////////
// Help ID's
//////////////


#pragma data_seg(".text")
const static DWORD aAdvSpeakerHelp[] = 
{
    IDC_SPEAKERCONFIG,      IDH_SPEAKERS_PICKER,
    IDC_IMAGEFRAME,         IDH_SPEAKERS_IMAGE,
    IDC_ICON_4,             IDH_COMM_GROUPBOX,
    IDC_TEXT_22,            IDH_COMM_GROUPBOX,
    IDC_TEXT_23,            IDH_SPEAKERS_PICKER,
    0, 0
};
#pragma data_seg()



//////////////
// Functions
//////////////

// 
// Verifies that the speakers type and config match, if not, change type to match config using default type
//
void VerifySpeakerConfig(DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType)
{
    if (pdwSpeakerType)
    {
        DWORD dwType = *pdwSpeakerType;

        if (gdwSpeakerTable[dwType] != dwSpeakerConfig)     // the type doesn't match the config, pick a default type
        {
            switch (dwSpeakerConfig)
            {
                case DSSPEAKER_DIRECTOUT:
                    *pdwSpeakerType = TYPE_NOSPEAKERS;
                break;

                case DSSPEAKER_HEADPHONE:
                    *pdwSpeakerType = TYPE_HEADPHONES;
                break;

                case DSSPEAKER_MONO:
                    *pdwSpeakerType = TYPE_MONOLAPTOP;
                break;

                case DSSPEAKER_STEREO:
                    *pdwSpeakerType = TYPE_STEREODESKTOP;
                break;

                case DSSPEAKER_QUAD:
                    *pdwSpeakerType = TYPE_QUADRAPHONIC;
                break;

                case DSSPEAKER_SURROUND:
                    *pdwSpeakerType = TYPE_SURROUND;
                break;

                case DSSPEAKER_5POINT1:
                    *pdwSpeakerType = TYPE_SURROUND_5_1;
                break;

                case DSSPEAKER_7POINT1:
                    *pdwSpeakerType = TYPE_SURROUND_7_1;
                break;

                default:
                {
                    if (DSSPEAKER_CONFIG(dwSpeakerConfig) == DSSPEAKER_STEREO)
                    {
                        DWORD dwAngle = DSSPEAKER_GEOMETRY(dwSpeakerConfig);
                        DWORD dwMiddle = DSSPEAKER_GEOMETRY_NARROW + 
                                        ((DSSPEAKER_GEOMETRY_WIDE - DSSPEAKER_GEOMETRY_NARROW) >> 1);
                        if (dwAngle <= dwMiddle)
                        {
                            *pdwSpeakerType = TYPE_STEREOCPU;        
                        }
                        else
                        {
                            *pdwSpeakerType = TYPE_STEREODESKTOP;        
                        }
                    }
                }

                break;
            }
        }
    }
}

//
// Given a speaker type, returns the DirectSound config for it
//

DWORD GetSpeakerConfigFromType(DWORD dwType)
{
    DWORD dwConfig = SPEAKERS_DEFAULT_CONFIG;

    if (dwType < (DWORD)NUMCONFIG)
    {
        dwConfig = gdwSpeakerTable[dwType];     
    }

    return(dwConfig);
}



//
// Called when first started up, it determines the current state of the device's speaker state
// and fills out the controls as appropriate
//

BOOL InitSpeakerDlg(HWND hwnd, BOOL fImagesOnly)
{
    TCHAR    str[255];
    int     item;
    DWORD   dwIndex;
    HWND    hwndCombo;

    if (!fImagesOnly)
    {
        SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_RESETCONTENT,0,0);
    }

    for (item = 0; item < NUMCONFIG; item++)
    {
        if (!fImagesOnly)
        {
            LoadString( ghInst, IDS_SPEAKER1 + item, str, sizeof( str )/sizeof(TCHAR) );
            SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) str); 
        }
         
        if (ghBitmaps[item] != NULL)
        {
            DeleteObject( (HGDIOBJ) ghBitmaps[item]);
            ghBitmaps[item] = NULL; 
        }
        
        ghBitmaps[item] = (HBITMAP) LoadImage(ghInst,MAKEINTATOM(gdwImageID[item]), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    }
    
    dwIndex = gAudData.current.dwSpeakerType;
                    
    SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_SETCURSEL,  (WPARAM) dwIndex, 0);                
    SendDlgItemMessage(hwnd, IDC_IMAGEFRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghBitmaps[dwIndex]);
    
    // Enable/disable the combo box appropriately
    hwndCombo = GetDlgItem( hwnd, IDC_SPEAKERCONFIG );
    if (hwndCombo)
    {
        // Check if we can set the speaker configuration
        if (FAILED(CheckDSSpeakerConfigPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
        {
            // No - disable the combo box
            EnableWindow( hwndCombo, FALSE );
        }
        else
        {
            // Yes - enable the combo box
            EnableWindow( hwndCombo, TRUE );
        }
    }

    return(TRUE);
}

//
// called to delete all loaded bitmaps
//

void DumpBitmaps(void)
{
    int item;

    for (item = 0; item < NUMCONFIG; item++)
    {         
        if (ghBitmaps[item] != NULL)
        {
            DeleteObject( (HGDIOBJ) ghBitmaps[item]);
            ghBitmaps[item] = NULL; 
        }
    }
}


//
// called by dialog handler when speaker type is changed
//

void ChangeSpeakers(HWND hwnd)
{
    DWORD dwIndex;

    dwIndex = (DWORD)SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_GETCURSEL,0,0);

	if (dwIndex != CB_ERR)
    {
        gAudData.current.dwSpeakerType = dwIndex;
        gAudData.current.dwSpeakerConfig = GetSpeakerConfigFromType(gAudData.current.dwSpeakerType);
    
        SendDlgItemMessage(hwnd, IDC_IMAGEFRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghBitmaps[dwIndex]);

        ToggleApplyButton(hwnd);
    }
}


//
// Dialog event handler
//

INT_PTR CALLBACK SpeakerHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturnVal = TRUE;
        
    switch (msg) 
    { 
        default:
            fReturnVal = FALSE;
        break;
        
        case WM_INITDIALOG:
        {
            fReturnVal = InitSpeakerDlg(hDlg, FALSE);
        }        
        break;

        case WM_DESTROY:
        {
            DumpBitmaps();
        }
        break;

        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aAdvSpeakerHelp);
            fReturnVal = TRUE;
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvSpeakerHelp);
            fReturnVal = TRUE;
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
            fReturnVal = InitSpeakerDlg(hDlg, TRUE);
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_SPEAKERCONFIG:
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeSpeakers(hDlg);
                    }
                }
                break;
                
                default:
                    fReturnVal = FALSE;
                break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings(&gAudData);
                }
            }
        }
    }

    return fReturnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\sndsel.c ===
/*
 ***************************************************************
 *  sndsel.c
 *
 *  This file contains the dialogproc and the dialog initialization code
 *
 *  Copyright 1993, Microsoft Corporation
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#include <commdlg.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <dbt.h>

#include <mmddkp.h>

#include <ks.h>
#include <ksmedia.h>
#include "mmcpl.h"
#include "medhelp.h"
#include "sound.h"
#include "utils.h"
#include "rcids.h"

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
#define DF_PM_SETBITMAP    (WM_USER+1)

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

SZCODE      gszWindowsHlp[]    = TEXT("windows.hlp");
SZCODE      gszNull[2]         = TEXT("\0");
SZCODE      gszNullScheme[]    = TEXT(".none");

TCHAR        gszCurDir[MAXSTR]     = TEXT("\0");
TCHAR        gszNone[32];
TCHAR        gszRemoveScheme[MAXSTR];
TCHAR        gszChangeScheme[MAXSTR];
TCHAR        gszMediaDir[MAXSTR];
TCHAR        gszDefaultApp[32];

int                             giScheme;
BOOL                            gfChanged;                    //set to TRUE if sound info change
BOOL                            gfNewScheme;
BOOL                            gfDeletingTree;
HWND                            ghWnd;
OPENFILENAME                    ofn;

/*
 ***************************************************************
 * Globals used in painting disp chunk display.
 ***************************************************************
*/
BOOL        gfWaveExists = FALSE;   // indicates wave device in system.

HTREEITEM ghOldItem = NULL;

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */

static TCHAR        aszFileName[MAXSTR] = TEXT("\0");
static TCHAR        aszPath[MAXSTR]     = TEXT("\0");

static TCHAR        aszBrowse[MAXSTR];
static TCHAR        aszBrowseStr[64];
static TCHAR        aszNullSchemeLabel[MAXSTR];

static TCHAR        aszFilter[MAXSTR];
static TCHAR        aszNullChar[2];

static SZCODE   aszLnk[] = TEXT(".lnk");
static SZCODE   aszWavFilter[] = TEXT("*.wav");
static SZCODE   aszDefaultScheme[]    = TEXT("Appevents\\schemes");
static SZCODE   aszNames[]            = TEXT("Appevents\\schemes\\Names");
static SZCODE   aszDefault[]        = TEXT(".default");
static SZCODE   aszCurrent[]        = TEXT(".current");
static INTCODE  aKeyWordIds[] =
{
    CB_SCHEMES,         IDH_EVENT_SCHEME,
    IDC_TEXT_14,        IDH_EVENT_SCHEME,
    ID_SAVE_SCHEME,     IDH_EVENT_SAVEAS_BUTTON,
    ID_REMOVE_SCHEME,   IDH_EVENT_DELETE_BUTTON,
    IDC_EVENT_TREE,     IDH_EVENT_EVENT,
    IDC_SOUNDGRP,       IDH_COMM_GROUPBOX,
    ID_PLAY,            IDH_EVENT_PLAY,
    IDC_STATIC_EVENT,   IDH_COMM_GROUPBOX,
    IDC_STATIC_NAME,    IDH_EVENT_FILE,
    IDC_SOUND_FILES,    IDH_EVENT_FILE,
    ID_BROWSE,          IDH_EVENT_BROWSE,
    0,0
};

BOOL        gfEditBoxChanged;
BOOL        gfSubClassedEditWindow;
BOOL        gfSoundPlaying;

HBITMAP     hBitmapPlay;
HBITMAP     hBitmapStop;

HIMAGELIST  hSndImagelist;

/*
 ***************************************************************
 * extern
 ***************************************************************
 */

extern      HSOUND ghse;
extern      BOOL    gfNukeExt;
/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
BOOL PASCAL DoCommand           (HWND, int, HWND, UINT);
BOOL PASCAL InitDialog          (HWND);
BOOL PASCAL InitStringTable     (void);
BOOL PASCAL InitFileOpen        (HWND, LPOPENFILENAME);
BOOL PASCAL SoundCleanup        (HWND);
LPTSTR PASCAL NiceName           (LPTSTR, BOOL);
BOOL ResolveLink                (LPTSTR, LPTSTR, LONG);
void CreateTooltip (HWND hwnd, LPTSTR lpszTip);

// stuff in sndfile.c
//
BOOL PASCAL ShowSoundMapping    (HWND, PEVENT);
BOOL PASCAL ChangeSoundMapping  (HWND, LPTSTR, PEVENT);
BOOL PASCAL PlaySoundFile       (HWND, LPTSTR);
BOOL PASCAL QualifyFileName     (LPTSTR, LPTSTR, int, BOOL);

// Stuff in scheme.c
//
INT_PTR CALLBACK  SaveSchemeDlg(HWND, UINT, WPARAM, LPARAM);
BOOL PASCAL RegNewScheme        (HWND, LPTSTR, LPTSTR, BOOL);
BOOL PASCAL RegSetDefault       (LPTSTR);
BOOL PASCAL ClearModules        (HWND, HWND, BOOL);
BOOL PASCAL LoadModules         (HWND, LPTSTR);
BOOL PASCAL RemoveScheme        (HWND);
BOOL PASCAL AddScheme           (HWND, LPTSTR, LPTSTR, BOOL, int);
BOOL PASCAL RegDeleteScheme(HWND hWndC, int iIndex);

/*
 ***************************************************************
 ***************************************************************
 */


void AddExt(LPTSTR sz, LPCTSTR x)
{
    UINT  cb;

    for (cb = lstrlen(sz); cb; --cb)
    {
        if (TEXT('.') == sz[cb])
            return;

        if (TEXT('\\') == sz[cb])
            break;
    }
    lstrcat (sz, x);
}


static void AddFilesToLB(HWND hwndList, LPTSTR pszDir, LPCTSTR szSpec)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    TCHAR szBuf[256];

    ComboBox_ResetContent(hwndList);

    lstrcpy(szBuf, pszDir);
    lstrcat(szBuf, cszSlash);
    lstrcat(szBuf, szSpec);

    h = FindFirstFile(szBuf, &fd);

    if (h != INVALID_HANDLE_VALUE)
    {
        // If we have only a short name, make it pretty.
        do {
            //if (fd.cAlternateFileName[0] == 0 ||
            //    lstrcmp(fd.cFileName, fd.cAlternateFileName) == 0)
            //{
                NiceName(fd.cFileName, TRUE);
            //}
            SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)fd.cFileName);
        }
        while (FindNextFile(h, &fd));

        FindClose(h);
    }
    ComboBox_InsertString(hwndList, 0, (LPARAM)(LPTSTR)gszNone);
}

static void SetCurDir(HWND hDlg, LPTSTR lpszPath, BOOL fParse, BOOL fChangeDir)
{
    TCHAR szTmp[MAX_PATH];
    TCHAR szOldDir[MAXSTR];
    LPTSTR lpszTmp;

    lstrcpy (szOldDir, gszCurDir);
    if (!fParse)
    {
        lstrcpy(gszCurDir, lpszPath);
        goto AddFiles;
    }
    lstrcpy(szTmp, lpszPath);
    for (lpszTmp = (LPTSTR)(szTmp + lstrlen(szTmp)); lpszTmp > szTmp; lpszTmp = CharPrev(szTmp, lpszTmp))
    {
        if (*lpszTmp == TEXT('\\'))
        {
            *lpszTmp = TEXT('\0');
            lstrcpy(gszCurDir, szTmp);
            break;
        }
    }
    if (lpszTmp <= szTmp)
        lstrcpy(gszCurDir, gszMediaDir);
AddFiles:
    if (fChangeDir)
    {
        if (!SetCurrentDirectory(gszCurDir))
        {
            if (lstrcmp (gszMediaDir, lpszPath))
                SetCurrentDirectory (gszMediaDir);
            else
            {
                if (GetWindowsDirectory (gszCurDir, sizeof(gszCurDir)/sizeof(TCHAR)))
					SetCurrentDirectory (gszCurDir);
            }
        }
    }
    if (lstrcmpi (szOldDir, gszCurDir))
    {
        AddFilesToLB(GetDlgItem(hDlg, IDC_SOUND_FILES),gszCurDir, aszWavFilter);
    }
}

static BOOL TranslateDir(HWND hDlg, LPTSTR pszPath)
{
    TCHAR szCurDir[MAX_PATH];
    int nFileOffset = lstrlen(pszPath);

    lstrcpy(szCurDir, pszPath);
    if (szCurDir[nFileOffset - 1] == TEXT('\\'))
        szCurDir[--nFileOffset] = 0;
    if (SetCurrentDirectory(szCurDir))
    {
        if (GetCurrentDirectory(sizeof(szCurDir)/sizeof(TCHAR), szCurDir))
        {
            SetCurDir(hDlg, szCurDir, FALSE, FALSE);
            return TRUE;
        }
    }
    return FALSE;
}





///HACK ALERT!!!! HACK ALERT !!! HACK ALERT !!!!
// BEGIN (HACKING)

HHOOK gfnKBHookScheme = NULL;
HWND ghwndDlg = NULL;
WNDPROC gfnEditWndProc = NULL;

#define WM_NEWEVENTFILE (WM_USER + 1000)
#define WM_RESTOREEVENTFILE (WM_USER + 1001)

LRESULT CALLBACK SchemeKBHookProc(int code, WPARAM wParam, LPARAM lParam)
{
    if (wParam == VK_RETURN || wParam == VK_ESCAPE)
    {
        HWND hwndFocus = GetFocus();
        if (IsWindow(hwndFocus))
        {
            if (lParam & 0x80000000) //Key Up
            {
                DPF("*****WM_KEYUP for VK_RETURN/ESC\r\n");
                if (wParam == VK_RETURN)
                {
                    if (SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 0L))
                    {
                        SetFocus(hwndFocus);
                        gfEditBoxChanged = TRUE;
                        return 1;
                    }
                }
                else
                    SendMessage(ghwndDlg, WM_RESTOREEVENTFILE, 0, 0L);
            }
        }
        if (gfnKBHookScheme && (lParam & 0x80000000))
        {
            UnhookWindowsHookEx(gfnKBHookScheme);
            gfnKBHookScheme = NULL;
        }
        return 1;       //remove message
    }
    return CallNextHookEx(gfnKBHookScheme, code, wParam, lParam);
}

STATIC void SetSchemesKBHook(HWND hwnd)
{
    if (gfnKBHookScheme)
        return;
    gfnKBHookScheme = SetWindowsHookEx(WH_KEYBOARD, (HOOKPROC)SchemeKBHookProc, ghInstance,0);
}

LRESULT CALLBACK SubClassedEditWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
        case WM_SETFOCUS:
            DPF("*****WM_SETFOCUS\r\n");
            SetSchemesKBHook(hwnd);
            gfEditBoxChanged = FALSE;
            break;
        case WM_KILLFOCUS:
            if (gfnKBHookScheme)
            {
                DPF("*****WM_KILLFOCUS\r\n");
                UnhookWindowsHookEx(gfnKBHookScheme);
                gfnKBHookScheme = NULL;
                if (gfEditBoxChanged)
                    SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 1L);
            }
            break;
    }
    return CallWindowProc((WNDPROC)gfnEditWndProc, hwnd, wMsg, wParam, lParam);
}

STATIC void SubClassEditWindow(HWND hwndEdit)
{
    gfnEditWndProc = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)SubClassedEditWndProc);
}



// END (HACKING)

STATIC void EndSound(HSOUND * phse)
{
    if (*phse)
    {
        HSOUND hse = *phse;

        *phse = NULL;
        soundStop(hse);
        soundOnDone(hse);
        soundClose(hse);
    }
}

// Create a tooltip for the passed window
void CreateTooltip (HWND hwnd, LPTSTR lpszTip)
{

    HWND hwndTT;
    TOOLINFO ti;
    INITCOMMONCONTROLSEX iccex; 

    // Init Common Controls
    iccex.dwICC = ICC_WIN95_CLASSES;
    iccex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    InitCommonControlsEx (&iccex);
	
    // Create Window
    hwndTT = CreateWindowEx (WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd,
        NULL, ghInstance, NULL);
    SetWindowPos (hwndTT, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    // Get Tip Area (entire window)
    GetClientRect (hwnd, &(ti.rect));
	
    // Init Tip
    ti.cbSize   = sizeof(TOOLINFO);
    ti.uFlags   = TTF_SUBCLASS;
    ti.hwnd     = hwnd;
    ti.hinst    = ghInstance;
    ti.uId      = 0;
    ti.lpszText = lpszTip;
    
    // Add Tip
    SendMessage (hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
    
} 

/*
 ***************************************************************
 *  SoundDlg
 *
 *  Description:
 *        DialogProc for sound control panel applet.
 *
 *  Parameters:
 *   HWND        hDlg            window handle of dialog window
 *   UINT        uiMessage       message number
 *   WPARAM        wParam          message-dependent
 *   LPARAM        lParam          message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
BOOL CALLBACK  SoundDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    NMHDR FAR       *lpnm;
    TCHAR           szBuf[MAXSTR];
    static BOOL     fClosingDlg = FALSE;
    PEVENT          pEvent;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

                case TVN_SELCHANGED:
                {
                    TV_ITEM tvi;
                    LPNM_TREEVIEW lpnmtv = (LPNM_TREEVIEW)lParam;

                    if (fClosingDlg || gfDeletingTree)
                        break;
                    if (gfnKBHookScheme)
                    {
                        UnhookWindowsHookEx(gfnKBHookScheme);
                        gfnKBHookScheme = NULL;
                        if (gfEditBoxChanged)
                        {
                            ghOldItem = lpnmtv->itemOld.hItem;
                            SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 1L);
                            ghOldItem = NULL;
                        }
                    }

                    tvi = lpnmtv->itemNew;
                    if (tvi.lParam)
                    {
                        if (*((short NEAR *)tvi.lParam) == 2)
                        {
                            pEvent =  (PEVENT)tvi.lParam;
                            ShowSoundMapping(hDlg, pEvent);
                            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)tvi.lParam);
                        }
                        else
                        {
                            ShowSoundMapping(hDlg, NULL);
                            SetWindowLongPtr(hDlg, DWLP_USER, 0L);
                        }
                    }
                    else
                    {
                        ShowSoundMapping(hDlg, NULL);
                        SetWindowLongPtr(hDlg, DWLP_USER, 0L);
                    }
                    break;
                }

                case TVN_ITEMEXPANDING:
                {
                    LPNM_TREEVIEW lpnmtv = (LPNM_TREEVIEW)lParam;

                    if (lpnmtv->action == TVE_COLLAPSE)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                        return TRUE;
                    }
                    break;
                }


            }
            break;

        case WM_INITDIALOG:
        {
            InitStringTable();

            giScheme = 0;
            ghWnd = hDlg;
            gfChanged = FALSE;
            gfNewScheme = FALSE;
            
            hBitmapStop = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_STOP));
            if (!hBitmapStop)
                DPF("loadbitmap failed\n");
            hBitmapPlay = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_PLAY));
            if (!hBitmapPlay)
                DPF("loadbitmap failed\n");

            SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
            ShowSoundMapping(hDlg, NULL);
            gfSoundPlaying = FALSE;
            // Add tool tip
            LoadString (ghInstance, IDS_TIP_PLAY, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            CreateTooltip (GetDlgItem (hDlg, ID_PLAY), szBuf);

            /* Determine if there is a wave device
             */
            FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
            InitFileOpen(hDlg, &ofn);
            ghwndDlg = hDlg;
            DragAcceptFiles(hDlg, TRUE);
            gfSubClassedEditWindow = FALSE;
            fClosingDlg = FALSE;
            gfDeletingTree = FALSE;

       }
        break;

        case WM_DESTROY:
        {
            DWORD i = 0;
            LPTSTR pszKey = NULL;
            fClosingDlg = TRUE;
            if (gfnKBHookScheme)
            {
                UnhookWindowsHookEx(gfnKBHookScheme);
                gfnKBHookScheme = NULL;
            }
            SoundCleanup(hDlg);
            
            //delete item data in tree
            ClearModules(hDlg,GetDlgItem(hDlg, IDC_EVENT_TREE),TRUE);

            //delete item data in combobox
            for (i = 0; i < ComboBox_GetCount(GetDlgItem(hDlg, CB_SCHEMES)); i++)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(GetDlgItem(hDlg, CB_SCHEMES), i);
                if (pszKey)
                {
                    //can't free a couple of these, as they point to static mem
                    if ((pszKey != aszDefault) && (pszKey != aszCurrent))
                    {
                        LocalFree(pszKey);
                    }
                }
            }

            break;
        }

        case WM_DROPFILES:
        {
            TV_HITTESTINFO ht;
            HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

            DragQueryFile((HDROP)wParam, 0, szBuf, MAXSTR - 1);

            if (IsLink(szBuf, aszLnk))
                if (!ResolveLink(szBuf, szBuf, sizeof(szBuf)))
                    goto EndDrag;

            if (lstrcmpi((LPTSTR)(szBuf+lstrlen(szBuf)-4), cszWavExt))
                goto EndDrag;

            GetCursorPos((LPPOINT)&ht.pt);
            MapWindowPoints(NULL, hwndTree,(LPPOINT)&ht.pt, 2);
            TreeView_HitTest( hwndTree, &ht);
            if (ht.hItem && (ht.flags & TVHT_ONITEM))
            {
                TV_ITEM tvi;

                tvi.mask = TVIF_PARAM;
                   tvi.hItem = ht.hItem;
                   TreeView_GetItem(hwndTree, &tvi);

                if (*((short NEAR *)tvi.lParam) == 2)
                {
                    TreeView_SelectItem(hwndTree, ht.hItem);
                    pEvent =  (PEVENT)(tvi.lParam);
                    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)tvi.lParam);
                    SetFocus(hwndTree);
                }
            }
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));

            ChangeSoundMapping(hDlg, szBuf,pEvent);
            DragFinish((HDROP) wParam);
            break;
EndDrag:
            ErrorBox(hDlg, IDS_ISNOTSNDFILE, szBuf);
            DragFinish((HDROP) wParam);
            break;
        }
        case WM_NEWEVENTFILE:
        {
            DPF("*****WM_NEWEVENT\r\n");
            gfEditBoxChanged = FALSE;
            ComboBox_GetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szBuf, sizeof(szBuf)/sizeof(TCHAR));
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            if (!lstrcmp (szBuf, gszNone))  // Selected "(None)" with keyboard?
            {
                lstrcpy(szBuf, gszNull);
                ChangeSoundMapping(hDlg, szBuf, pEvent);
                goto ReturnFocus;
            }

            if (TranslateDir(hDlg, szBuf))
            {
                ShowSoundMapping(hDlg, pEvent);
                goto ReturnFocus;
            }
            if (QualifyFileName((LPTSTR)szBuf, (LPTSTR)szBuf,    sizeof(szBuf), TRUE))
            {
                SetCurDir(hDlg, szBuf, TRUE, TRUE);
                ChangeSoundMapping(hDlg, szBuf,pEvent);
            }
            else
            {
                if (lParam)
                {
                    ErrorBox(hDlg, IDS_INVALIDFILE, NULL);
                    ShowSoundMapping(hDlg, pEvent);
                    goto ReturnFocus;
                }
                if (DisplayMessage(hDlg, IDS_NOSNDFILETITLE, IDS_INVALIDFILEQUERY, MB_YESNO) == IDYES)
                {
                    ShowSoundMapping(hDlg, pEvent);
                }
                else
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                    return TRUE;
                }
            }
ReturnFocus:
            SetFocus(GetDlgItem(hDlg,IDC_EVENT_TREE));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)FALSE);
            return TRUE;
        }

        case WM_RESTOREEVENTFILE:
        {
            DPF("*****WM_RESTOREEVENT\r\n");
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            ShowSoundMapping(hDlg, pEvent);
            if (lParam == 0) //Don't keep focus
                SetFocus(GetDlgItem(hDlg,IDC_EVENT_TREE));
            break;
        }


        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case MM_WOM_DONE:
        {
            HWND hwndFocus = GetFocus();
            HWND hwndPlay =  GetDlgItem(hDlg, ID_PLAY);

            gfSoundPlaying = FALSE;
            SendMessage(hwndPlay, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);

            if (ghse)
            {
                soundOnDone(ghse);
                soundClose(ghse);
                ghse = NULL;
            }
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            ShowSoundMapping(hDlg, pEvent);

            if (hwndFocus == hwndPlay)
                if (IsWindowEnabled(hwndPlay))
                    SetFocus(hwndPlay);
                else
                    SetFocus(GetDlgItem(hDlg, IDC_EVENT_TREE));
            break;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoCommand);
            break;

        default:
            break;
    }
    return FALSE;
}


/*
 ***************************************************************
 *  doCommand
 *
 *  Description:
 *        Processes Control commands for main sound
 *      control panel dialog.
 *
 *  Parameters:
 *        HWND    hDlg  -   window handle of dialog window
 *        int        id     - Message ID
 *        HWND    hwndCtl - Handle of window control
 *        UINT    codeNotify - Notification code for window
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL DoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    WAVEOUTCAPS woCaps;
    TCHAR        szBuf[MAXSTR];
    LPTSTR        pszKey;
    int         iIndex;
    HCURSOR     hcur;
    HWND        hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    HWND        hWndF = GetDlgItem(hDlg, IDC_SOUND_FILES);
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    PEVENT        pEvent;
    static      BOOL fSchemeCBDroppedDown = FALSE;
    static      BOOL fFilesCBDroppedDown = FALSE;
    static      BOOL fSavingPrevScheme = FALSE;

    switch (id)
    {
        case ID_APPLY:
        {

            EndSound(&ghse);
            if (!gfChanged)
                break;
            hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
            if (gfNewScheme)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                if (lstrcmpi(pszKey, aszCurrent))
                {
                    ComboBox_InsertString(hWndC, NONE_ENTRY, gszNull);
                    ComboBox_SetItemData(hWndC, NONE_ENTRY, aszCurrent);
                    ComboBox_SetCurSel(hWndC, NONE_ENTRY);
                    giScheme = NONE_ENTRY;
                }
                gfNewScheme = FALSE;
            }
            iIndex = ComboBox_GetCurSel(hWndC);
            if (iIndex != CB_ERR)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);
                if (pszKey)
                {
                    RegNewScheme(hDlg, (LPTSTR)aszCurrent, NULL, FALSE);
                }
                RegSetDefault(pszKey);
            }

            gfChanged = FALSE;
            SetCursor(hcur);

            return TRUE;
        }
        break;

        case IDOK:
        {
            EndSound(&ghse);
            break;
        }
        case IDCANCEL:
        {
            EndSound(&ghse);
            WinHelp(hDlg, gszWindowsHlp, HELP_QUIT, 0L);
            break;
        }
        case ID_INIT:
            hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
            gfWaveExists = waveOutGetNumDevs() > 0 &&
                            (waveOutGetDevCaps(WAVE_MAPPER,&woCaps,sizeof(woCaps)) == 0) &&
                                                    woCaps.dwFormats != 0L;
            ComboBox_ResetContent(hWndC);
            ComboBox_SetText(hWndF, gszNone);
            InitDialog(hDlg);
            giScheme = ComboBox_GetCurSel(hWndC);
            ghWnd = hDlg;
            SetCursor(hcur);
            break;

        case ID_BROWSE:
            aszFileName[0] = aszPath[0] = TEXT('\0');
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));

            wsprintf((LPTSTR)aszBrowse, (LPTSTR)aszBrowseStr, (LPTSTR)pEvent->pszEventLabel);
            if (GetOpenFileName(&ofn))
            {
                SetCurDir(hDlg, ofn.lpstrFile,TRUE, TRUE);
                ChangeSoundMapping(hDlg, ofn.lpstrFile, pEvent);
            }
            break;

        case ID_PLAY:
        {
            if (!gfSoundPlaying)
            {
                pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
                if (pEvent)
                {
                    if (PlaySoundFile(hDlg, pEvent->pszPath))
					{
                        SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapStop);
                        gfSoundPlaying = TRUE;
					}
                }
            }
            else
            {
                SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
                gfSoundPlaying = FALSE;

                EndSound(&ghse);
                SetFocus(GetDlgItem(hDlg, ID_PLAY));
            }
        }
        break;

        case CB_SCHEMES:
            switch (codeNotify)
            {
            case CBN_DROPDOWN:
                fSchemeCBDroppedDown = TRUE;
                break;

            case CBN_CLOSEUP:
                fSchemeCBDroppedDown = FALSE;
                break;

            case CBN_SELCHANGE:
                if (fSchemeCBDroppedDown)
                    break;
            case CBN_SELENDOK:
                if (fSavingPrevScheme)
                    break;
                iIndex = ComboBox_GetCurSel(hWndC);
                if (iIndex != giScheme)
                {
                    TCHAR szScheme[MAXSTR];
                    BOOL fDeletedCurrent = FALSE;

                    ComboBox_GetLBText(hWndC, iIndex, (LPTSTR)szScheme);
                    if (giScheme == NONE_ENTRY)
                    {
                        pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, giScheme);
                        if (!lstrcmpi(pszKey, aszCurrent))
                        {
                            int i;

                            i = DisplayMessage(hDlg, IDS_SAVESCHEME, IDS_SCHEMENOTSAVED, MB_YESNOCANCEL);
                            if (i == IDCANCEL)
                            {
                                ComboBox_SetCurSel(hWndC, giScheme);
                                break;
                            }
                            if (i == IDYES)
                            {
                                fSavingPrevScheme = TRUE;
                                if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(SAVESCHEMEDLG),
                                    GetParent(hDlg), SaveSchemeDlg, (LPARAM)(LPTSTR)gszNull))
                                {
                                    fSavingPrevScheme = FALSE;
                                    ComboBox_SetCurSel(hWndC, iIndex);
                                }
                                else
                                {
                                    fSavingPrevScheme = FALSE;
                                    ComboBox_SetCurSel(hWndC, NONE_ENTRY);
                                    break;
                                }
                            }
                        }
                    }
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                    if (!lstrcmpi(pszKey, aszCurrent))
                    {
                        ComboBox_DeleteString(hWndC, NONE_ENTRY);
                        fDeletedCurrent = TRUE;
                    }
                    iIndex = ComboBox_FindStringExact(hWndC, 0, szScheme);
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);

                    giScheme = iIndex;
                    EndSound(&ghse);
                    ShowSoundMapping(hDlg, NULL);
                    hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
                    if (LoadModules(hDlg, pszKey))
                    {
                        EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), TRUE);
                    }
                    SetCursor(hcur);
                    if (!lstrcmpi((LPTSTR)pszKey, aszDefault) || !lstrcmpi((LPTSTR)pszKey, gszNullScheme))
                        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME),
                                                                    FALSE);
                    else
                        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME),TRUE);
                    gfChanged = TRUE;
                    gfNewScheme = FALSE;
                    if (fDeletedCurrent)
                        ComboBox_SetCurSel(hWndC, giScheme);
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                break;
            }
            break;

        case IDC_SOUND_FILES:
            switch (codeNotify)
            {
            case  CBN_SETFOCUS:
            {
                if (!gfSubClassedEditWindow)
                {
                    HWND hwndEdit = GetFocus();

                    SubClassEditWindow(hwndEdit);
                    gfSubClassedEditWindow = TRUE;
                    SetFocus(GetDlgItem(hDlg, IDC_EVENT_TREE)); //This setfocus hack is needed
                    SetFocus(hwndEdit);                         //to activate the hook.
                }
            }
            break;

            case CBN_EDITCHANGE:
                DPF("CBN_EDITCHANGE \r\n");
                if (!gfEditBoxChanged)
                    gfEditBoxChanged = TRUE;
                break;

            case CBN_DROPDOWN:
                DPF("CBN_DD\r\n");
                fFilesCBDroppedDown = TRUE;
                break;

            case CBN_CLOSEUP:
                DPF("CBN_CLOSEUP\r\n");
                fFilesCBDroppedDown = FALSE;
                break;

            case CBN_SELCHANGE:
                DPF("CBN_SELCHANGE\r\n");
                if (fFilesCBDroppedDown)
                    break;
            case CBN_SELENDOK:
            {
                HWND hwndS = GetDlgItem(hDlg, IDC_SOUND_FILES);
                DPF("CBN_SELENDOK\r\n");
                iIndex = ComboBox_GetCurSel(hwndS);
                if (iIndex >= 0)
                {
                    TCHAR szFile[MAX_PATH];

                    if (gfEditBoxChanged)
                        gfEditBoxChanged = FALSE;
                    lstrcpy(szFile, gszCurDir);
                    lstrcat(szFile, cszSlash);
                    ComboBox_GetLBText(hwndS, iIndex, (LPTSTR)(szFile + lstrlen(szFile)));
                    if (iIndex)
                    {
                        if (gfNukeExt)
                            AddExt(szFile, cszWavExt);
                    }
                    else
                    {
                        TCHAR szTmp[64];

                        ComboBox_GetText(hwndS, szTmp, sizeof(szTmp)/sizeof(TCHAR));
                        iIndex = ComboBox_FindStringExact(hwndS, 0, szTmp);
                        if (iIndex == CB_ERR)
                        {
                            if (DisplayMessage(hDlg, IDS_SOUND, IDS_NONECHOSEN, MB_YESNO) == IDNO)
                            {
                                PostMessage(ghwndDlg, WM_RESTOREEVENTFILE, 0, 1L);
                                break;
                            }
                        }
                        lstrcpy(szFile, gszNull);
                    }
                    pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
                    ChangeSoundMapping(hDlg, szFile, pEvent);
                    SetFocus(GetDlgItem(hDlg, ID_PLAY));
                }
                break;
            }

        }
        break;

        case ID_SAVE_SCHEME:
            // Retrieve current scheme and pass it to the savescheme dialog.
            iIndex = ComboBox_GetCurSel(hWndC);
            if (iIndex != CB_ERR)
            {
                ComboBox_GetLBText(hWndC, iIndex, szBuf);
                if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(SAVESCHEMEDLG),
                    GetParent(hDlg), SaveSchemeDlg, (LPARAM)(LPTSTR)szBuf))
                {
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                    if (!lstrcmpi(pszKey, aszCurrent))
                    {
                        ComboBox_DeleteString(hWndC, NONE_ENTRY);
                    }
                }
            }
            break;

        case ID_REMOVE_SCHEME:
            if (RemoveScheme(hDlg))
            {
                iIndex = ComboBox_FindStringExact(hWndC, 0, aszNullSchemeLabel);
                ComboBox_SetCurSel(hWndC, iIndex);
                giScheme = -1;
                FORWARD_WM_COMMAND(hDlg, CB_SCHEMES, hWndC, CBN_SELENDOK,SendMessage);
            }
            SetFocus(GetDlgItem(hDlg, CB_SCHEMES));
            break;

    }
    return FALSE;
}

void InitImageList(HWND hwndTree)
{
    HICON hIcon = NULL;
    UINT  uFlags;
    int  cxMiniIcon;
    int  cyMiniIcon;
    DWORD dwLayout;

    if (hSndImagelist)
    {
        TreeView_SetImageList(hwndTree, NULL, TVSIL_NORMAL);
        ImageList_Destroy(hSndImagelist);
        hSndImagelist = NULL;
    }
    cxMiniIcon = GetSystemMetrics(SM_CXSMICON);
    cyMiniIcon = GetSystemMetrics(SM_CYSMICON);

    uFlags = ILC_MASK | ILC_COLOR32;


    if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
    {
        uFlags |= ILC_MIRROR;
    }
 

    hSndImagelist = ImageList_Create(cxMiniIcon,cyMiniIcon, uFlags, 4, 2);
    if (!hSndImagelist)
        return;

    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_PROGRAM),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_AUDIO),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_BLANK),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    TreeView_SetImageList(hwndTree, hSndImagelist, TVSIL_NORMAL);

}

/*
 ***************************************************************
 *  InitDialog
 *
 * Description:
 *        Reads the current event names and mappings from  reg.db
 *
 *        Each entry in the [reg.db] section is in this form:
 *
 *        AppEvents
 *            |
 *            |___Schemes  = <SchemeKey>
 *                    |
 *                    |______Names
 *                    |         |
 *                    |         |______SchemeKey = <Name>
 *                    |
 *                    |______Apps
 *                             |
 *                             |______Module
 *                                      |
 *                                      |_____Event
 *                                             |
 *                                             |_____SchemeKey = <Path\filename>
 *                                                     |
 *                                                     |____Active = <1\0
 *
 *        The Module, Event and the file label are displayed in the
 *        comboboxes.
 *
 * Parameters:
 *      HWND hDlg - parent window.
 *
 * Return Value: BOOL
 *        True if entire initialization is ok.
 *
 ***************************************************************
 */
BOOL PASCAL InitDialog(HWND hDlg)
{
    TCHAR     szDefKey[MAXSTR];
    TCHAR     szScheme[MAXSTR];
    TCHAR     szLabel[MAXSTR];
    int      iVal;
    int         i;
    int      cAdded;
    HWND     hWndC;
    LONG     cbSize;
    HKEY     hkNames;
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    hWndC = GetDlgItem(hDlg, CB_SCHEMES);

    InitImageList(hwndTree);

    EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_BROWSE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), FALSE);

    SetCurDir(hDlg, gszMediaDir, FALSE, TRUE);

    if (RegOpenKey(HKEY_CURRENT_USER, aszNames, &hkNames) != ERROR_SUCCESS)
        DPF("Failed to open aszNames\n");
    else
        DPF("Opened HKEY_CURRENT_USERS\n");
    cAdded = 0;
    for (i = 0; !RegEnumKey(hkNames, i, szScheme, sizeof(szScheme)/sizeof(TCHAR)); i++)
    {
            // Don't add the windows default key yet
        if (lstrcmpi(szScheme, aszDefault))
        {
            cbSize = sizeof(szLabel);
            if ((RegQueryValue(hkNames, szScheme, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
                lstrcpy(szLabel, szScheme);
            if (!lstrcmpi(szScheme, gszNullScheme))
                lstrcpy(aszNullSchemeLabel, szLabel);
            ++cAdded;
            AddScheme(hWndC, szLabel, szScheme, FALSE, 0);
        }
    }
    // Add the windows default key in the second position in the listbox
    cbSize = sizeof(szLabel);
    if ((RegQueryValue(hkNames, aszDefault, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
    {
        LoadString(ghInstance, IDS_WINDOWSDEFAULT, szLabel, MAXSTR);
        if (RegSetValue(hkNames, aszDefault, REG_SZ, szLabel, 0) != ERROR_SUCCESS)
            DPF("Failed to add printable name for default\n");
    }

    if (cAdded == 0)
       AddScheme(hWndC, szLabel, (LPTSTR)aszDefault, TRUE, 0);
    else
       AddScheme(hWndC, szLabel, (LPTSTR)aszDefault, TRUE, WINDOWS_DEFAULTENTRY);

    cbSize = sizeof(szDefKey);
    if ((RegQueryValue(HKEY_CURRENT_USER, aszDefaultScheme, szDefKey,
                                &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
    {
        ComboBox_SetCurSel(hWndC, 0);
        DPF("No default scheme found\n");
    }
    else
    {
        if (!lstrcmpi(szDefKey, aszCurrent))
        {
            ComboBox_InsertString(hWndC, NONE_ENTRY, gszNull);
            ComboBox_SetItemData(hWndC, NONE_ENTRY, aszCurrent);
            iVal = NONE_ENTRY;
            ComboBox_SetCurSel(hWndC, iVal);
        }
        else
        {
            cbSize = sizeof(szLabel);
            if ((RegQueryValue(hkNames, szDefKey, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
            {
                DPF("No Name for default scheme key %s found\n", (LPTSTR)szDefKey);
                lstrcpy(szLabel, szDefKey);
            }

            if ((iVal = ComboBox_FindStringExact(hWndC, 0, szLabel)) != CB_ERR)
                ComboBox_SetCurSel(hWndC, iVal);
            else
                if (lstrcmpi(aszDefault, szDefKey))
                    ComboBox_SetCurSel(hWndC, iVal);
                else
                {
                    iVal = ComboBox_GetCount(hWndC);
                    AddScheme(hWndC, szLabel, szDefKey, TRUE, iVal);
                    ComboBox_SetCurSel(hWndC, iVal);
                }
        }
        giScheme = iVal;        //setting the current global scheme;
        if (LoadModules(hDlg, (LPTSTR)aszCurrent))
        {
            EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), TRUE);
        }
        else
        {
            ClearModules(hDlg,  hwndTree, TRUE);
            ComboBox_SetCurSel(hWndC, 0);
            DPF("LoadModules failed\n");
            RegCloseKey(hkNames);
            return FALSE;
        }

        if (!lstrcmpi(szDefKey, aszDefault))
            EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
        else
            EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), TRUE);
//        DPF("Finished doing init\n");
    }
    RegCloseKey(hkNames);
    return TRUE;
}


const static DWORD aOpenHelpIDs[] = {  // Context Help IDs
    IDC_STATIC_PREVIEW, IDH_EVENT_BROWSE_PREVIEW,
    ID_PLAY,            IDH_EVENT_PLAY,
    ID_STOP,            IDH_EVENT_STOP,

    0, 0
};

INT_PTR CALLBACK OpenDlgHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HSOUND hse;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szOK[16];
            TCHAR szBuf[MAXSTR];
            LPTSTR   lpszFile;

            // lParam is lpOFN
            DPF("****WM_INITDIALOG in HOOK **** \r\n");
            LoadString(ghInstance, IDS_OK, szOK, sizeof(szOK)/sizeof(TCHAR));
            SetDlgItemText(GetParent(hDlg), IDOK, szOK);
            hse = NULL;

            if (gfWaveExists)
            {
                HWND hwndPlay = GetDlgItem(hDlg, ID_PLAY);
                HWND hwndStop = GetDlgItem(hDlg, ID_STOP);

                SendMessage(hwndStop, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapStop);
                SendMessage(hwndPlay, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
                EnableWindow(hwndStop, FALSE);
                EnableWindow(hwndPlay, FALSE);

                lpszFile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH+sizeof(TCHAR));
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpszFile);

                LoadString (ghInstance, IDS_TIP_PLAY, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                CreateTooltip (GetDlgItem (hDlg, ID_PLAY), szBuf);
            }
            break;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                HELP_WM_HELP, (UINT_PTR)(LPTSTR) aOpenHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (UINT_PTR)(LPVOID) aOpenHelpIDs);
            break;

        case WM_COMMAND:
            if (!gfWaveExists)
                break;
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ID_PLAY:
                {
                    LPTSTR lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
                    MMRESULT err = MMSYSERR_NOERROR;

                    DPF("*****ID_PLAY in Dlg Hook ***\r\n");
                    if((soundOpen(lpszFile, hDlg, &hse) != MMSYSERR_NOERROR) || ((err = soundPlay(hse)) != MMSYSERR_NOERROR))
                    {
                        if (err == (MMRESULT)MMSYSERR_NOERROR || err != (MMRESULT)MMSYSERR_ALLOCATED)
                            ErrorBox(hDlg, IDS_ERRORFILEPLAY, lpszFile);
                        else
                            ErrorBox(hDlg, IDS_ERRORDEVBUSY, lpszFile);
                        hse = NULL;
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
                        EnableWindow(GetDlgItem(hDlg, ID_STOP), TRUE);
                    }
                    break;
                }
                case ID_STOP:
                {
                    DPF("*****ID_STOP in Dlg Hook ***\r\n");
                    EndSound(&hse);
                    EnableWindow(GetDlgItem(hDlg, ID_STOP), FALSE);
                    EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);

                    break;
                }
                default:
                    return(FALSE);
            }
            break;

        case MM_WOM_DONE:
            EnableWindow(GetDlgItem(hDlg, ID_STOP), FALSE);
            if (hse)
            {
                soundOnDone(hse);
                soundClose(hse);
                hse = NULL;
            }
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);
            break;

        case WM_DESTROY:
        {
            LPTSTR lpszFile;

            if (!gfWaveExists)
                break;

            lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
            DPF("**WM_DESTROY in Hook **\r\n");
            if (lpszFile)
                LocalFree((HLOCAL)lpszFile);
            EndSound(&hse);

            break;
        }
        case WM_NOTIFY:
        {
            LPOFNOTIFY pofn;

            if (!gfWaveExists)
                break;

            pofn = (LPOFNOTIFY)lParam;
            switch (pofn->hdr.code)
            {
                case CDN_SELCHANGE:
                {
                    TCHAR szCurSel[MAX_PATH];
                    HWND hwndPlay = GetDlgItem(hDlg, ID_PLAY);
                    LPTSTR lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
                    HFILE hFile;

                    EndSound(&hse);
                    if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg),szCurSel, sizeof(szCurSel)/sizeof(TCHAR)) <= (int)(sizeof(szCurSel)/sizeof(TCHAR)))
                    {
                        OFSTRUCT of;

                        if (!lstrcmpi(szCurSel, lpszFile))
                            break;

                        DPF("****The current selection is %s ***\r\n", szCurSel);
                        hFile = (HFILE)HandleToUlong(CreateFile(szCurSel,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
                        if (lstrcmpi((LPTSTR)(szCurSel+lstrlen(szCurSel)-4), cszWavExt) || (-1 == hFile))
                        {
                            if (lpszFile[0] == TEXT('\0'))
                                break;
                            lpszFile[0] = TEXT('\0');
                            EnableWindow(hwndPlay, FALSE);
                        }
                        else
                        {
                            CloseHandle(LongToHandle(hFile));
                            EnableWindow(hwndPlay, TRUE);
                            lstrcpy(lpszFile, szCurSel);
                        }
                    }
                    break;
                }

                case CDN_FOLDERCHANGE:
                {
                    EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
                    break;
                }
                default:
                    break;
            }
            break;
        }

        default:
            return FALSE;

    }
    return TRUE;
}


/*
 ***************************************************************
 * InitFileOpen
 *
 * Description:
 *        Sets up the openfilestruct to read display .wav and .mid files
 *        and sets up global variables for the filename and path.
 *
 * Parameters:
 *    HWND            hDlg  - Window handle
 *    LPOPENFILENAME lpofn - pointer to openfilename struct
 *
 * Returns:            BOOL
 *
 ***************************************************************
 */
STATIC BOOL PASCAL InitFileOpen(HWND hDlg, LPOPENFILENAME lpofn)
{

    lpofn->lStructSize = sizeof(OPENFILENAME);
    lpofn->hwndOwner = hDlg;
    lpofn->hInstance = ghInstance;
    lpofn->lpstrFilter = aszFilter;
    lpofn->lpstrCustomFilter = NULL;
    lpofn->nMaxCustFilter = 0;
    lpofn->nFilterIndex = 0;
    lpofn->lpstrFile = aszPath;
    lpofn->nMaxFile = sizeof(aszPath)/sizeof(TCHAR);
    lpofn->lpstrFileTitle = aszFileName;
    lpofn->nMaxFileTitle = sizeof(aszFileName)/sizeof(TCHAR);
    lpofn->lpstrInitialDir = gszCurDir;
    lpofn->lpstrTitle = aszBrowse;
    lpofn->Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST |OFN_HIDEREADONLY |OFN_EXPLORER |OFN_ENABLEHOOK;
    if (gfWaveExists)
        lpofn->Flags |= OFN_ENABLETEMPLATE;
    lpofn->nFileOffset = 0;
    lpofn->nFileExtension = 0;
    lpofn->lpstrDefExt = NULL;
    lpofn->lCustData = 0;
    lpofn->lpfnHook = OpenDlgHook;
    if (gfWaveExists)
        lpofn->lpTemplateName = MAKEINTRESOURCE(BROWSEDLGTEMPLATE);
    else
        lpofn->lpTemplateName = NULL;
    return TRUE;
}

/* FixupNulls(chNull, p)
 *
 * To facilitate localization, we take a localized string with non-NULL
 * NULL substitutes and replacement with a real NULL.
 */
STATIC void NEAR PASCAL FixupNulls(
    TCHAR chNull,
    LPTSTR p)
{
    while (*p) {
        if (*p == chNull)
            *p++ = 0;
        else
            p = CharNext(p);
    }
} /* FixupNulls */


/* GetDefaultMediaDirectory
 *
 * Returns C:\WINNT\Media, or whatever it's called.
 *
 */
BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory)
{
    static SZCODE szSetup[] = REGSTR_PATH_SETUP;
    static SZCODE szMedia[] = REGSTR_VAL_MEDIA;
    HKEY          hkeySetup;
    LONG          Result;

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSetup,
                          REG_OPTION_RESERVED,
                          KEY_QUERY_VALUE, &hkeySetup);

    if (Result == ERROR_SUCCESS)
    {
        Result = RegQueryValueEx(hkeySetup, szMedia, NULL, REG_NONE,
                                 (LPBYTE)pDirectory, &cbDirectory);

        RegCloseKey(hkeySetup);
    }

    return (Result == ERROR_SUCCESS);
}


/*
 ***************************************************************
 * InitStringTable
 *
 * Description:
 *      Load the RC strings into the storage for them
 *
 * Parameters:
 *      void
 *
 * Returns:        BOOL
 ***************************************************************
 */
STATIC BOOL PASCAL InitStringTable(void)
{
    static SZCODE cszSetup[] = REGSTR_PATH_SETUP;
    static SZCODE cszMedia[] = REGSTR_VAL_MEDIA;

    LoadString(ghInstance, IDS_NONE, gszNone, sizeof(gszNone)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_BROWSEFORSOUND, aszBrowseStr, sizeof(aszBrowseStr)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_REMOVESCHEME, gszRemoveScheme,sizeof(gszRemoveScheme)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_CHANGESCHEME, gszChangeScheme,sizeof(gszChangeScheme)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_DEFAULTAPP, gszDefaultApp, sizeof(gszDefaultApp)/sizeof(TCHAR));

    LoadString(ghInstance, IDS_WAVFILES, aszFilter, sizeof(aszFilter)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_NULLCHAR, aszNullChar, sizeof(aszNullChar)/sizeof(TCHAR));
    FixupNulls(*aszNullChar, aszFilter);

    gszMediaDir[0] = TEXT('\0');

    if (!GetDefaultMediaDirectory(gszMediaDir, sizeof(gszMediaDir)/sizeof(TCHAR)))
    {
        if (!GetWindowsDirectory (gszMediaDir, sizeof(gszMediaDir)/sizeof(TCHAR)))
			return FALSE;
    }

    return TRUE;
}

/*
 ***************************************************************
 * SoundCleanup
 *
 * Description:
 *      Cleanup all the allocs and bitmaps when the sound page exists
 *
 * Parameters:
 *      void
 *
 * Returns:        BOOL
 ***************************************************************
 */
STATIC BOOL PASCAL SoundCleanup(HWND hDlg)
{

    DeleteObject(hBitmapStop);
    DeleteObject(hBitmapPlay);

    TreeView_SetImageList(GetDlgItem(hDlg, IDC_EVENT_TREE), NULL, TVSIL_NORMAL);
    ImageList_Destroy(hSndImagelist);
    hSndImagelist = NULL;

    DPF("ending sound cleanup\n");
    return TRUE;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\sulib.h ===
/*
 * SULIB.H - Windows/DOS Setup common code
 *
 *  Modification History:
 *
 *
 *  3/23/89  Toddla   combined common.h and prototypes into this file
 *  1/28/91  MichaelE Added AUDIO_CARDS_SECT for different audio card choices.
 *  4/17/91  Removed some DOS.ASM routines not used anywhere.
 *  5/29/91  JKLin added prototype for IsCDROMDrive function
 *
 */

#define FALLOC(n)                ((VOID *)GlobalAlloc(GPTR, n))
#define FFREE(n)                 GlobalFree(n)

#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
#define FREE(p)                  LocalFree(p)
#define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)


/* flags for _llseek */

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define MAXFILESPECLEN       MAX_PATH /* drive: + path length max + Null Byte */
#define MAX_INF_LINE_LEN     256      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      256      /* ##: + 8.3 + NULL */
#define MAX_SECT_NAME_LEN    40       /* Max length of a section Name. */
#define MAX_FILE_SPEC        MAX_PATH // 8.3 + X: + NULL.

#define DISK_SECT              TEXT("disks")
#define OEMDISK_SECT           TEXT("oemdisks")



/* Return codes from 'file exists' dialog */

enum {
    CopyNeither,            // User wants to cancel if file exists
    CopyCurrent,            // User wants to use current file
    CopyNew                 // User wants to copy new file
};

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))
#define CHSEPSTR                TEXT("\\")
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')

/* Globals and routines for .inf file parsing */

typedef LPTSTR    PINF;

extern PINF infOpen(LPTSTR szInf);
extern void infClose(PINF pinf);
extern PINF infSetDefault(PINF pinf);
extern PINF infFindSection(PINF pinf, LPTSTR szSection);
extern BOOL infGetProfileString(PINF pinf, LPTSTR szSection, LPTSTR szItem,LPTSTR szBuf);
extern BOOL infParseField(PINF szData, int n, LPTSTR szBuf);
extern PINF infNextLine(PINF pinf);
extern int  infLineCount(PINF pinf);
extern BOOL infLookup(LPTSTR szInf, LPTSTR szBuf);
extern PINF FindInstallableDriversSection(PINF pinf);

/* Message types for FileCopy callback function */

typedef BOOL (*FPFNCOPY) (int,DWORD_PTR,LPTSTR);
#define COPY_ERROR          0x0001
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006
#define COPY_EXISTS         0x0007

extern UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy);

/* Option Flag values for FileCopy */

#define FC_FILE              0x0000
#define FC_LIST              0x0001
#define FC_SECTION           0x0002
#define FC_QUALIFIED         0x0008
#define FC_DEST_QUALIFIED    0x0010
#define FC_LISTTYPE          0x0020
#define FC_CALLBACK_WITH_VER 0x0040

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2
#define FC_ERROR_LOADED_DRIVER  0x80

/* External functions from copy.c */

extern BOOL ExpandFileName(LPTSTR szFile, LPTSTR szPath);
extern void catpath(LPTSTR path, LPTSTR sz);
extern BOOL fnFindFile(TCHAR *);
extern LPTSTR FileName(LPTSTR szPath);
extern LPTSTR RemoveDiskId(LPTSTR szPath);
extern LPTSTR StripPathName(LPTSTR szPath);
extern BOOL IsFileKernelDriver(LPTSTR szPath);


/*******************************************************************
 *
 * Global Variables
 *
 *******************************************************************/

 // Path to the directory where we found the .inf file

 extern TCHAR szSetupPath[MAX_PATH];

 // Path to the user's disk(s)

 extern TCHAR szDiskPath[MAX_PATH];   // Path to the default drive -
                                     //
 extern BOOL bRetry;

 // Name of the driver being installed

 extern TCHAR szDrv[120];

 //

 extern TCHAR szFileError[50];

 // Parent window for file copy dialogues

 HWND hMesgBoxParent;

 // TRUE on copying first file to prompt user if file already exists
 // FALSE for subsequent copies

 extern BOOL bQueryExist;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\systrayp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:	SYSTRAY.H
*
*  VERSION:	2.1
*
*  AUTHOR:	Tracy Sharpe / RAL
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the system tray applet (battery meter, PCMCIA, etc).
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*  11/8/94     RAL Converted to systray
*
*******************************************************************************/

#ifndef _INC_SYSTRAY
#define _INC_SYSTRAY

#define SYSTRAY_CLASSNAME	   TEXT("SystemTray_Main")

//  Private tray icon notification message sent to the BatteryMeter window.
#define STWM_NOTIFYPOWER		(WM_USER + 201)
#define STWM_NOTIFYPCMCIA		(WM_USER + 202)
#define STWM_NOTIFYVOLUME		(WM_USER + 203)

//  Private tray icon notification messages sent to the BatteryMeter window.
#define STWM_ENABLESERVICE		(WM_USER + 220)
#define STWM_GETSTATE			(WM_USER + 221)


_inline BOOL SysTray_EnableService(int idSTService, BOOL fEnable)
{
    if (fEnable)
    {
        STARTUPINFO si;
        PROCESS_INFORMATION pi;
	    static const TCHAR szSTExecFmt[] = TEXT("SYSTRAY.EXE %i");
	    TCHAR szEnableCmd[sizeof(szSTExecFmt)+10];
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOWNOACTIVATE;
        si.dwFlags = STARTF_USESHOWWINDOW;
	    wsprintf(szEnableCmd, szSTExecFmt, idSTService);
	    if (CreateProcess(NULL,szEnableCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
        {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
	    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
	    if (hwndST)
        {
	        SendMessage(hwndST, STWM_ENABLESERVICE, idSTService, FALSE);
	    }
    }
    return TRUE;
}


_inline BOOL SysTray_IsServiceEnabled(WPARAM idSTService)
{
    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hwndST) {
	return((BOOL)SendMessage(hwndST, STWM_GETSTATE, idSTService, 0));
    } else {
	return(FALSE);
    }
}

#define STSERVICE_POWER 		1
#define STSERVICE_PCMCIA		2
#define STSERVICE_VOLUME		4
#define STSERVICE_ALL			7   // Internal

//
//  Flags for the PCMCIA registry entry
//
#define PCMCIA_REGFLAG_NOWARN		1

#endif // _INC_SYSTRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\volume.h ===
typedef enum
{
    sndvolNotChecked,
	sndvolNotPresent,
	sndvolPresent,
} enumSndVol;

#define MAXMIXERLEN            256     // Maximum output string length

// Prototypes
STDAPI_(void) Multichannel (HWND hWnd, UINT uiMixID, DWORD dwDest, DWORD dwVolID);

BOOL OnInitDialog (HWND hDlg, HWND hwndFocus, LPARAM lParam);
void OnDestroy (HWND hDlg);
void OnNotify (HWND hDlg, LPNMHDR pnmh);

void InitVolume (HWND hDlg);
BOOL PASCAL OnCommand (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL SndVolPresent ();
void MasterVolumeConfig (HWND hWnd, UINT* puiMixID);
BOOL SearchDevice (DWORD dwMixID, LPDWORD pdwDest, LPDWORD pdwVolID, LPDWORD pdwMuteID);
void SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, BOOL *pfFound);
void DisplayVolumeControl (HWND hDlg);
void UpdateVolumeSlider(HWND hWnd, DWORD dwLine);
DWORD GetMaxVolume ();
HRESULT GetVolume ();
void SetVolume(DWORD dwVol);
BOOL GetMute ();
void SetMute(BOOL fMute);
void FreeMixer ();
void DeviceChange_Cleanup ();
BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice);
void DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void DeviceChange_Change(HWND hDlg, WPARAM wParam, LPARAM lParam);
void MasterVolumeScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
void HandlePowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam);
void SetBranding (HWND hwnd, UINT uiMixID);
void ResetBranding (HWND hwnd);
void FreeBrandBmp ();
void CreateHotLink (BOOL fHotLink);
BOOL ValidateURL ();
HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam);
PTCHAR GetInterfaceName (DWORD dwMixerID);
HKEY OpenDeviceBrandRegKey (UINT uiMixID);
void RefreshMixCache ();

// Globals
UINT                g_uiVolDevChange = 0;
WNDPROC             g_fnVolPSProc   = NULL;
HWND                g_hWnd          = NULL;
HMIXER              g_hMixer        = NULL;
enumSndVol          g_sndvolPresent = sndvolNotChecked;
BOOL                g_fMasterVolume = FALSE; // True if the master volume slider is enabled
BOOL                g_fMasterMute   = FALSE; // True if the master mute button is enabled
BOOL                g_fTrayIcon     = FALSE; // Current state of tray icon button
DWORD               g_dwVolID       = (DWORD) -1;
DWORD               g_dwMuteID      = (DWORD) -1;
LPVOID              g_pvPrevious    = NULL;
double*             g_pdblCacheMix  = NULL;
BOOL                g_fCacheCreated = FALSE;
BOOL                g_fPreviousMute = FALSE;
MIXERCONTROLDETAILS g_mcd;
static HDEVNOTIFY   g_hDeviceEventContext = NULL;
BOOL                g_fChanged            = FALSE;
BOOL                g_fInternalGenerated  = FALSE;
UINT                g_uiMixID             = 0;
DWORD               g_dwDest              = 0;
HBITMAP             g_hbmBrand            = NULL;
WCHAR*              g_szHotLinkURL        = NULL;
WCHAR               g_szDeviceName[MAX_PATH] = { L"\0" };
WCHAR               g_szNoAudioDevice[MAX_PATH] = { L"\0" };
MIXERLINE           g_mlDst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\utils.h ===
//
// utils.h: Declares data, defines and struct types for common code
//            module.
//
//

#ifndef __UTILS_H__
#define __UTILS_H__



/////////////////////////////////////////////////////  DEFINES

#define BLOCK        
#define Unref(x)     x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif


/////////////////////////////////////////////////////  MACROS

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        lmemset((LPTSTR)pobj, 0, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    lmemmove((LPTSTR)pdest, (LPTSTR)psrc, cb)

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, GMEM_MOVEABLE | GMEM_ZEROINIT, cbNewSize)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

//      void Free(void _huge * pb);                      (macro)
//          Free pb if it is nonzero.  Set pb to zero.  (Overrides Free above.)
//
#define Free(pb)        do { (pb) ? Free(pb) : (void)0;  pb = NULL; } while (0)


// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

// Sets the dialog handle in the given data struct on first
//  message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);



#endif // __UTILS_H__
#ifndef __STRING_H__
#define __STRING_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  MACROS

#define Bltbyte(rgbSrc,rgbDest,cb)  _fmemmove(rgbDest, rgbSrc, cb)

// Model independent, language-independent (DBCS aware) macros
//  taken from rcsys.h in Pen project and modified.
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsCaseSzEqual(sz1, sz2)     (BOOL)(lstrcmp(sz1, sz2) == 0)
#define SzFromInt(sz, n)            (wsprintf((LPTSTR)sz, (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)

#define IsLink(sz, szLnk)			(!lstrcmpi((LPTSTR)(sz+lstrlen(sz)-4), szLnk))


/////////////////////////////////////////////////////  PROTOTYPES

LPTSTR PUBLIC SzStrTok(LPTSTR string, LPCTSTR control);
LPCTSTR PUBLIC SzStrCh(LPCTSTR string, char ch);

LPTSTR PUBLIC SzFromIDS (UINT ids, LPTSTR pszBuf, int cbBuf);

/////////////////////////////////////////////////////  MORE INCLUDES

#endif // __STRING_H__


typedef struct _PROC_INFO
{
    LPCSTR  Name;
    FARPROC Address;
}
PROC_INFO, *PPROC_INFO;

#define PROCS_LOADED( pProcInfo ) ( (pProcInfo)[0].Address != NULL )
#define LOAD_IF_NEEDED( Library, ProcInfo ) ( PROCS_LOADED( ProcInfo ) ||   \
                                    LoadLibraryAndProcs( Library, ProcInfo ) )


extern PROC_INFO ACMProcs[];
extern PROC_INFO VFWProcs[];
extern PROC_INFO AVIProcs[];
extern PROC_INFO VERSIONProcs[];

BOOL LoadACM();
BOOL FreeACM();
BOOL LoadAVI();
BOOL FreeAVI();
BOOL LoadVFW();
BOOL FreeVFW();
BOOL LoadVERSION();
BOOL FreeVERSION();

//#define DEBUG_BUILT_LINKED
#ifndef DEBUG_BUILT_LINKED

#define acmFormatDetailsW            	(*ACMProcs[0].Address)
#define acmFormatTagDetailsW         	(*ACMProcs[1].Address)
#define acmDriverDetailsW            	(*ACMProcs[2].Address)
#define acmDriverMessage            	(*ACMProcs[3].Address)
#define acmDriverAddW            		(*ACMProcs[4].Address)
#define acmDriverEnum            		(*ACMProcs[5].Address)
#define acmDriverPriority            	(*ACMProcs[6].Address)
#define acmDriverRemove            		(*ACMProcs[7].Address)
#define acmMetrics            			(*ACMProcs[8].Address)
#define acmFormatChooseW            	(*ACMProcs[9].Address)

#define ICClose			            	(*VFWProcs[0].Address)
#define ICGetInfo		            	(*VFWProcs[1].Address)
#define ICLocate		            	(*VFWProcs[2].Address)
#define MCIWndCreateW	            	(*VFWProcs[3].Address)

#define AVIFileRelease 	            	(*AVIProcs[0].Address)
#define AVIStreamRelease	           	(*AVIProcs[1].Address)
#define AVIStreamSampleToTime			(*AVIProcs[2].Address)
#define AVIStreamStart					(*AVIProcs[3].Address)
#define AVIStreamLength					(*AVIProcs[4].Address)
#define AVIStreamReadFormat				(*AVIProcs[5].Address)
#define AVIStreamInfoW					(*AVIProcs[6].Address)
#define AVIFileGetStream				(*AVIProcs[7].Address)
#define AVIFileOpenW   	            	(*AVIProcs[8].Address)
#define AVIFileInit   	            	(*AVIProcs[9].Address)
#define AVIFileExit   	            	(*AVIProcs[10].Address)

#define VerQueryValueW	            	(*VERSIONProcs[0].Address)
#define GetFileVersionInfoW            	(*VERSIONProcs[1].Address)
#define GetFileVersionInfoSizeW        	(*VERSIONProcs[2].Address)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\trayvol.h ===
#ifndef _systray_h_
#define _systray_h_
BOOL SetTrayVolumeEnabled(BOOL bEnable);
BOOL GetTrayVolumeEnabled(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\trayvol.c ===
#include <windows.h>
#include "systrayp.h"
#include "trayvol.h"

#define MMSYS_UPDATEMIXER	3000	//This message tells the systray that the preferred device has
									//changed.

// Helper functions for things we care about
BOOL SetTrayVolumeEnabled(BOOL bEnable)
{
    return SysTray_EnableService(STSERVICE_VOLUME,bEnable);
}

BOOL GetTrayVolumeEnabled(void)
{
    return SysTray_IsServiceEnabled(STSERVICE_VOLUME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\video.c ===
/*
 ***************************************************************
 *  video.c
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Displays the Simple media properties
 *
 *  History:
 *
 *  July 1994 -by- VijR (Created)
 *
 ***************************************************************
 */

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include "utils.h"
#include "medhelp.h"

#include "profile.key" // For ROOTKEY and KEYNAME etc

#define Assert(f)

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
//
// !!! These actually live in mciavi\graphic.h
// !!! If MCIAVI changes these, we're hosed!
//
#define MCIAVIO_ZOOMBY2             0x00000100
#define MCIAVIO_USEVGABYDEFAULT     0x00000200
#define MCIAVIO_1QSCREENSIZE        0x00010000
#define MCIAVIO_2QSCREENSIZE        0x00020000
#define MCIAVIO_3QSCREENSIZE        0x00040000
#define MCIAVIO_MAXWINDOWSIZE       0x00080000
#define MCIAVIO_DEFWINDOWSIZE       0x00000000
#define MCIAVIO_WINDOWSIZEMASK      0x000f0000

// This bit is set in dwOptions if f16BitCompat, but doesn't get written back
// directly into the registry's version of that DWORD.
//
#define MCIAVIO_F16BITCOMPAT        0x00000001

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE aszMCIAVIOpt[] =    TEXT("Software\\Microsoft\\Multimedia\\Video For Windows\\MCIAVI");
static SZCODE aszDefVideoOpt[] = TEXT("DefaultOptions");
static SZCODE aszReject[] = TEXT("RejectWOWOpenCalls");
static SZCODE aszRejectSection[] = TEXT("MCIAVI");

HBITMAP g_hbmMonitor = NULL;    // monitor bitmap (original)
HBITMAP g_hbmScrSample = NULL;  // bitmap used for IDC_SCREENSAMPLE
HBITMAP g_hbmDefault = NULL;
HDC g_hdcMem = NULL;

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
BOOL PASCAL DoVideoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);

/*
 ***************************************************************
 ***************************************************************
 */

// mmGetProfileInt/mmWriteProfileInt snitched from MCIAVI32
UINT
mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT uDefault)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbData = sizeof(dwData);
        if (RegQueryValueEx(
            hkey,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD) {
                    value = (INT)dwData;
                }
        }

        RegCloseKey(hkey);
    }

    return((UINT)value);
}


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
VOID
mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT Value)
{
    // If we would write the same as already there... return.
    if (mmGetProfileInt(appname, valuename, !Value) == (UINT)Value) {
        return;
    }

    {
        TCHAR achName[MAX_PATH];
        HKEY hkey = NULL;

        lstrcpy(achName, KEYNAME);
        lstrcat(achName, appname);
        if ((RegCreateKey (ROOTKEY, achName, &hkey) == ERROR_SUCCESS) && hkey)
        {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof(Value)
            );

            RegCloseKey(hkey);
        }
    }

}

/*
 ***************************************************************
 ***************************************************************
 */

STATIC void WriteVideoOptions(DWORD dwOpt)
{
    HKEY hkVideoOpt;
    BOOL f16BitCompat;

    f16BitCompat = (dwOpt & MCIAVIO_F16BITCOMPAT) ? TRUE : FALSE;
    dwOpt &= ~MCIAVIO_F16BITCOMPAT;

    if(RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hkVideoOpt, NULL ))
        return;
    RegSetValueEx( hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,(LPBYTE)&dwOpt, sizeof(DWORD) );
    mmWriteProfileInt (aszRejectSection, aszReject, (int)f16BitCompat);

	RegCloseKey(hkVideoOpt);
}

STATIC DWORD ReadVideoOptions(void)
{
    HKEY hkVideoOpt;
    DWORD dwType;
    DWORD dwOpt;
    DWORD cbSize;

    if(RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hkVideoOpt, NULL ))
        return 0 ;

    cbSize = sizeof(DWORD);
    if (RegQueryValueEx( hkVideoOpt,(LPTSTR)aszDefVideoOpt,NULL,&dwType,(LPBYTE)&dwOpt,&cbSize ))
    {
        dwOpt = 0;
        RegSetValueEx( hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,(LPBYTE)&dwOpt, sizeof(DWORD) );
    }

    if (mmGetProfileInt (aszRejectSection, aszReject, 0))
    {
        dwOpt |= MCIAVIO_F16BITCOMPAT;
    }

	RegCloseKey(hkVideoOpt);

    return dwOpt;
}

STATIC void FillWindowSizeCB(DWORD dwOptions, HWND hCBWinSize)
{
    TCHAR sz1QScreenSize[64];
    TCHAR sz2QScreenSize[64];
    TCHAR sz3QScreenSize[64];
    TCHAR szMaxSize[64];
    TCHAR szOriginalSize[64];
    TCHAR szZoomedSize[64];
    int iIndex;
    LPTSTR  lpszCurDefSize;

    LoadString(ghInstance, IDS_NORMALSIZE, szOriginalSize, sizeof(szOriginalSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_ZOOMEDSIZE, szZoomedSize, sizeof(szZoomedSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_1QSCREENSIZE, sz1QScreenSize, sizeof(sz1QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_2QSCREENSIZE, sz2QScreenSize, sizeof(sz2QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_3QSCREENSIZE, sz3QScreenSize, sizeof(sz3QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_VIDEOMAXIMIZED, szMaxSize, sizeof(szMaxSize)/sizeof(TCHAR));

    iIndex = ComboBox_AddString(hCBWinSize, szOriginalSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_DEFWINDOWSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, szZoomedSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_ZOOMBY2);
    iIndex = ComboBox_AddString(hCBWinSize, sz1QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_1QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, sz2QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_2QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, sz3QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_3QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, szMaxSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_MAXWINDOWSIZE);

    switch(dwOptions & MCIAVIO_WINDOWSIZEMASK)
    {
        case MCIAVIO_DEFWINDOWSIZE:
            if (dwOptions & MCIAVIO_ZOOMBY2)
                lpszCurDefSize = szZoomedSize;
            else
                lpszCurDefSize = szOriginalSize;
            break;
        case MCIAVIO_1QSCREENSIZE:
            lpszCurDefSize =  sz1QScreenSize;
            break;
        case MCIAVIO_2QSCREENSIZE:
            lpszCurDefSize =  sz2QScreenSize;
            break;
        case MCIAVIO_3QSCREENSIZE:
            lpszCurDefSize =  sz3QScreenSize;
            break;
        case MCIAVIO_MAXWINDOWSIZE:
            lpszCurDefSize =  szMaxSize;
            break;
    }

    //
    // We should select string that matches exactly.
    //
    iIndex = ComboBox_FindStringExact(hCBWinSize, 0, lpszCurDefSize);
    ComboBox_SetCurSel(hCBWinSize, iIndex);

}

/*---------------------------------------------------------
**
**---------------------------------------------------------*/
// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X    16
#define MON_Y    17
#define MON_DX    152
#define MON_DY    112

#define MON_IMAGE_X (MON_X + 46)
#define MON_IMAGE_Y (MON_Y + 33)
#define MON_IMAGE_DX 59
#define MON_IMAGE_DY 44

#define MON_TITLE 10
#define MON_BORDER 2

#define MON_TRAY 8


STATIC HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop )
{
    HBITMAP hbm;

    hbm = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MONITOR), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);

    Assert(hbm);

    return hbm;
}

/*------------------------pixel resolution---------------------------
**
** show the sample screen with proper sizing
*/
STATIC void NEAR PASCAL ShowSampleScreen(HWND hDlg, int iMCIWindowSize)
{
    HBITMAP hbmOld;
    HBRUSH hbr;
    HDC hdcMem2;
    SIZE    dSrc = {MON_IMAGE_DX, MON_IMAGE_DY};
    POINT   ptSrc = {MON_IMAGE_X, MON_IMAGE_Y};
    SIZE    dDst;
    POINT   ptDst;
    RECT    rcImage = {MON_IMAGE_X, MON_IMAGE_Y, MON_IMAGE_X + MON_IMAGE_DX, MON_IMAGE_Y + MON_IMAGE_DY};

    if (!g_hbmMonitor || !g_hbmScrSample)
        return;

    switch(iMCIWindowSize)
    {
        case MCIAVIO_DEFWINDOWSIZE:
            dDst = dSrc;
            ptDst = ptSrc;
            break;

        case MCIAVIO_ZOOMBY2:
            dDst.cx = 2 * dSrc.cx;
            dDst.cy = 2 * dSrc.cy;
            ptDst.x = ptSrc.x - (int)(dSrc.cx/2);
            ptDst.y = ptSrc.y - (int)(dSrc.cy/2);
            break;

        case MCIAVIO_MAXWINDOWSIZE:
            ptDst.x = MON_X;
            ptDst.y = MON_Y;
            dDst.cx = MON_DX;
            dDst.cy = MON_DY - MON_TRAY;
            break;

        case MCIAVIO_1QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 1, 4);
            dDst.cy = MulDiv(MON_DY, 1, 4);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_2QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 1, 2);
            dDst.cy = MulDiv(MON_DY, 1, 2);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_3QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 3, 4);
            dDst.cy = MulDiv(MON_DY, 3, 4);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_USEVGABYDEFAULT:
            dDst.cx = MON_DX;
            dDst.cy = MON_DY;
            ptDst.x = MON_X;
            ptDst.y = MON_Y;


            dSrc.cx = MON_IMAGE_DX - (2 * MON_BORDER);
            dSrc.cy = MON_IMAGE_DY - MON_TITLE - MON_BORDER;
            ptSrc.x = MON_IMAGE_X + MON_BORDER;
            ptSrc.y = MON_IMAGE_Y + MON_TITLE + MON_BORDER;
            break;

    }

    // set up a work area to play in
    hdcMem2 = CreateCompatibleDC(g_hdcMem);
    if (!hdcMem2)
        return;
    SelectObject(hdcMem2, g_hbmScrSample);
    hbmOld = SelectObject(g_hdcMem, g_hbmMonitor);

    //copy the whole bmp first and then start stretching
    BitBlt(hdcMem2, MON_X, MON_Y, MON_DX, MON_DY, g_hdcMem, MON_X, MON_Y, SRCCOPY);

    //Wipe out the existing Image
    hbr =   CreateSolidBrush( GetPixel( g_hdcMem, MON_X + 1, MON_Y + 1 ) );

	if (!hbr) 
	{
		DeleteObject( hdcMem2 );
		return;
	}
	
	FillRect(hdcMem2, &rcImage, hbr);
	DeleteObject( hbr );

    // stretch the image to reflect the new size
    SetStretchBltMode( hdcMem2, COLORONCOLOR );

    StretchBlt( hdcMem2, ptDst.x, ptDst.y, dDst.cx, dDst.cy,
        g_hdcMem, ptSrc.x, ptSrc.y, dSrc.cx, dSrc.cy, SRCCOPY );

    SelectObject( hdcMem2, g_hbmDefault );
    DeleteObject( hdcMem2 );
    SelectObject( g_hdcMem, hbmOld );
    InvalidateRect(GetDlgItem(hDlg, IDC_SCREENSAMPLE), NULL, FALSE);
}


STATIC void DoMonitorBmp(HWND hDlg)
{
    HDC hdc = GetDC(NULL);
    HBITMAP hbm;

    g_hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!g_hdcMem)
        return;

    hbm = CreateBitmap(1,1,1,1,NULL);

	if (!hbm) return;

    g_hbmDefault = SelectObject(g_hdcMem, hbm);
    SelectObject(g_hdcMem, g_hbmDefault);
    DeleteObject(hbm);

    // set up bitmaps for sample screen
    g_hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
    SendDlgItemMessage(hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (DWORD_PTR)g_hbmScrSample);

    // get a base copy of the bitmap for when the "internals" change
    g_hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop
}



const static DWORD aAdvVideoDlgHelpIds[] = {  // Context Help IDs
    (DWORD)IDC_STATIC,         IDH_VIDEO_ADVANCED_COMPAT,
    ID_ADVVIDEO_COMPAT,        IDH_VIDEO_ADVANCED_COMPAT,

    0, 0
};

INT_PTR AdvancedVideoDlgProc (HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL *pfCompat = NULL;

    switch (wMsg)
    {
        case WM_INITDIALOG:
        {
            if ((pfCompat = (BOOL *)lParam) == NULL)
                return -1;

            CheckDlgButton (hDlg, ID_ADVVIDEO_COMPAT, (*pfCompat));
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    *pfCompat = IsDlgButtonChecked (hDlg, ID_ADVVIDEO_COMPAT);
                    // fall through

                case IDCANCEL:
                    EndDialog (hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                     (UINT_PTR)aAdvVideoDlgHelpIds);
            return TRUE;
        }

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL,
                     HELP_WM_HELP, (UINT_PTR)aAdvVideoDlgHelpIds);
            return TRUE;
        }
    }

    return FALSE;
}


const static DWORD aVideoDlgHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,              IDH_COMM_GROUPBOX,
    IDC_SCREENSAMPLE,          IDH_VIDEO_GRAPHIC,
    IDC_VIDEO_FULLSCREEN,      IDH_VIDEO_FULL_SCREEN,
    IDC_VIDEO_INWINDOW,        IDH_VIDEO_FIXED_WINDOW,
    IDC_VIDEO_CB_SIZE,         IDH_VIDEO_FIXED_WINDOW,
    ID_VIDEO_ADVANCED,         IDH_VIDEO_ADVANCED_BUTTON,

    0, 0
};

BOOL CALLBACK VideoDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            DWORD dwOptions;

            dwOptions = ReadVideoOptions();
            FillWindowSizeCB(dwOptions, GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE));
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)dwOptions);
            DoMonitorBmp(hDlg);
            if (IsFlagSet(dwOptions, MCIAVIO_USEVGABYDEFAULT))
            {
                CheckRadioButton(hDlg, IDC_VIDEO_INWINDOW, IDC_VIDEO_FULLSCREEN, IDC_VIDEO_FULLSCREEN);
                EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), FALSE);
                ShowSampleScreen(hDlg, MCIAVIO_USEVGABYDEFAULT);
                break;
            }
            else
            {
                CheckRadioButton(hDlg, IDC_VIDEO_INWINDOW, IDC_VIDEO_FULLSCREEN, IDC_VIDEO_INWINDOW);
                EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), TRUE);
            }
            ShowSampleScreen(hDlg, dwOptions & (MCIAVIO_WINDOWSIZEMASK|MCIAVIO_ZOOMBY2));
            break;
        }
        case WM_DESTROY:
            if (g_hbmScrSample)
            {
                DeleteObject(g_hbmScrSample);
                g_hbmScrSample = NULL;
            }
            if (g_hbmMonitor)
            {
                DeleteObject(g_hbmMonitor);
                g_hbmMonitor = NULL;
            }
            if (g_hbmDefault)
            {
                DeleteObject(g_hbmDefault);
                g_hbmDefault = NULL;
            }
            if (g_hdcMem)
            {
                DeleteDC(g_hdcMem);
                g_hdcMem = NULL;
            }

            break;

        case WM_DROPFILES:
            break;

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aVideoDlgHelpIds);
            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aVideoDlgHelpIds);
            return TRUE;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoVideoCommand);
            break;

    }
    return FALSE;
}

BOOL PASCAL DoVideoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {

    case ID_APPLY:
    {
        int iIndex;
        HWND hCBWinSize = GetDlgItem(hDlg,IDC_VIDEO_CB_SIZE);
        DWORD dwOldOpt;
        DWORD dwNewOpt;

        dwOldOpt = (DWORD)GetWindowLongPtr(hDlg, DWLP_USER);
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_VIDEO_FULLSCREEN)))
        {
            dwNewOpt = MCIAVIO_USEVGABYDEFAULT;
        }
        else
        {
            iIndex = ComboBox_GetCurSel(hCBWinSize);
            dwNewOpt = (DWORD)ComboBox_GetItemData(hCBWinSize, iIndex);
        }

        ClearFlag(dwOldOpt,MCIAVIO_WINDOWSIZEMASK|MCIAVIO_USEVGABYDEFAULT|MCIAVIO_ZOOMBY2);
        SetFlag(dwOldOpt, dwNewOpt);
        WriteVideoOptions(dwOldOpt);
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)dwOldOpt);
        return TRUE;
    }

    case IDOK:
        break;

    case IDCANCEL:
        break;

    case IDC_VIDEO_FULLSCREEN:
        EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), FALSE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        ShowSampleScreen(hDlg, MCIAVIO_USEVGABYDEFAULT);
        break;

    case IDC_VIDEO_INWINDOW:
    {
        HWND hwndCB = GetDlgItem(hDlg,IDC_VIDEO_CB_SIZE);
        int iIndex = ComboBox_GetCurSel(hwndCB);
        int iOpt  = (int)ComboBox_GetItemData(hwndCB, iIndex);

        EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), TRUE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        ShowSampleScreen(hDlg, iOpt);
        break;
    }

    case IDC_VIDEO_CB_SIZE:
        switch (codeNotify)
        {
            case CBN_SELCHANGE:
            {

                int iIndex = ComboBox_GetCurSel(hwndCtl);
                int iOpt  = (int)ComboBox_GetItemData(hwndCtl, iIndex);

                PropSheet_Changed(GetParent(hDlg),hDlg);
                ShowSampleScreen(hDlg, iOpt);
                break;
            }
            default:
                break;
        }
        break;

    case ID_VIDEO_ADVANCED:
    {
        INT_PTR  f16BitCompat;
        f16BitCompat = (GetWindowLongPtr(hDlg, DWLP_USER) & MCIAVIO_F16BITCOMPAT);

        if (DialogBoxParam (ghInstance,
                            MAKEINTRESOURCE(ADVVIDEODLG),
                            hDlg,
                            AdvancedVideoDlgProc,
                            (LPARAM)&f16BitCompat) == IDOK)
        {
            SetWindowLongPtr (hDlg, DWLP_USER,
                           GetWindowLongPtr (hDlg, DWLP_USER)
                               & (~MCIAVIO_F16BITCOMPAT)
                               | ((f16BitCompat) ? (MCIAVIO_F16BITCOMPAT) : 0));
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;
    }

    case ID_INIT:
        break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\voicecpl.c ===
//==========================================================================;
//
//  cpl.c
//
//  Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/94        VijR (Vij Rajarajan);
//
//      10/95        R Jernigan - removed link to Adv tab's treeview control
//      09/99        tsharp - Ported back from W2K
//
//==========================================================================;

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"

/****************************************************************************
 * WARNING - Hack Alert
 * The following declares are for DPLAY Voice
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )	MAKE_HRESULT( 1, _FACDPV, code )

#define DV_FULLDUPLEX		MAKE_HRESULT( 0, _FACDPV,   5 )
#define DV_HALFDUPLEX		MAKE_HRESULT( 0, _FACDPV,  10 )
#define DVERR_COMMANDALREADYPENDING		MAKE_DVHRESULT( 371 )
#define DVERR_SOUNDINITFAILURE			MAKE_DVHRESULT( 372 )
#define DVERR_USERCANCEL				MAKE_DVHRESULT( 384 )


// {D26AF734-208B-41da-8224-E0CE79810BE1}
DEFINE_GUID(IID_IDirectPlayVoiceSetup, 
0xd26af734, 0x208b, 0x41da, 0x82, 0x24, 0xe0, 0xce, 0x79, 0x81, 0xb, 0xe1);

// {948CE83B-C4A2-44b3-99BF-279ED8DA7DF5}
DEFINE_GUID(CLSID_DIRECTPLAYVOICE, 
0x948ce83b, 0xc4a2, 0x44b3, 0x99, 0xbf, 0x27, 0x9e, 0xd8, 0xda, 0x7d, 0xf5);

// {0F0F094B-B01C-4091-A14D-DD0CD807711A}
DEFINE_GUID(CLSID_DirectPlayVoiceTest, 
0xf0f094b, 0xb01c, 0x4091, 0xa1, 0x4d, 0xdd, 0xc, 0xd8, 0x7, 0x71, 0x1a);


typedef struct IDirectPlayVoiceSetup FAR *LPDIRECTPLAYVOICESETUP, *PDIRECTPLAYVOICESETUP;

#define DVFLAGS_WAVEIDS						0x80000000

#define IDirectPlayVoiceSetup_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceSetup_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceSetup_Release(p)               (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceSetup_CheckAudioSetup(p,a,b,c,d)   (p)->lpVtbl->CheckAudioSetup(p,a,b,c,d)

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceSetup
DECLARE_INTERFACE_( IDirectPlayVoiceSetup, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceSetup methods ***/
    STDMETHOD_(HRESULT, CheckAudioSetup) (THIS_ LPGUID, LPGUID, HWND, DWORD ) PURE;
};

/****************************************************************************
 * WARNING - Hack Alert End
 ****************************************************************************/

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

BOOL        gfVocLoadedACM;
BOOL        gbVocSelectChanged = FALSE;
BOOL        gbVocCapPresent = FALSE;
BOOL        gbVocPlayPresent = FALSE;
UINT        giVocChange = 0;
WNDPROC     gfnVocPSProc = NULL;
HWND        ghVocDlg;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */


/*
 ***************************************************************
 * extern
 ***************************************************************
 */


/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoVocPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL DoVoiceCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);

void VOICEOUTInit(HWND hDlg, PAUDIODLGINFO paiVoc);
void VOICECAPInit(HWND hDlg, PAUDIODLGINFO paiVoc);



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVoiceOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
BOOL SetVoiceOutID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_SET, dwWaveID, dwFlags);
    return (!FAILED (mmr)); // TRUE;
}



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVoiceCapID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
BOOL SetVoiceCapID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_SET, dwWaveID, dwFlags);
    return (!FAILED (mmr)); // TRUE;
}


void GetVocPrefInfo(PAUDIODLGINFO paiVoc, HWND hDlg )
{

    // Load VoiceOut Info
	paiVoc->cNumOutDevs = waveOutGetNumDevs();
    paiVoc->uPrefOut = GetVoiceOutID(&paiVoc->fPrefOnly);


    // Load VoiceCap Info
    paiVoc->cNumInDevs  = waveInGetNumDevs();
    paiVoc->uPrefIn = GetVoiceCapID(NULL);

}



STATIC void EnablePlayVoiceVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_VOCVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_PLAYBACK_ADVVOC) , fEnable);
}

STATIC void EnableRecVoiceVolCtrls(HWND hDlg, BOOL fEnable, BOOL fControl)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_CAPVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_CAPTURE_ADVVOL) , fControl);
}


STATIC void SetVoiceOut(UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(uID), &uMixID, MIXER_OBJECTF_WAVEOUT)) 
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
	}

	EnablePlayVoiceVolCtrls(hDlg, fEnabled);
    gbVocPlayPresent = fEnabled;
}



DWORD CountVocInputs(DWORD dwMixID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    DWORD dwCount = 0;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;
        DWORD       cDestinations;

        cDestinations = mc.cDestinations;

        for (dwDestination = 0; dwDestination < cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_WAVEIN ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
                {
                    DWORD cConnections = mlDst.cConnections;

                    dwCount += mlDst.cControls;

                    if (cConnections)
                    {
                        DWORD dwSource; 

                        for (dwSource = 0; dwSource < cConnections; dwSource++)
                        {
                            mlDst.dwDestination = dwDestination;
                            mlDst.dwSource = dwSource;

                            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_SOURCE ) == MMSYSERR_NOERROR)
                            {
                                dwCount += mlDst.cControls;
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwCount);
}


STATIC void SetVoiceCap(UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    BOOL    fControl = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    gbVocCapPresent = FALSE;

    if( (MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(uID),&uMixID, MIXER_OBJECTF_WAVEIN)))
    {
        if( MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            gbVocCapPresent = TRUE; // Even if the device has no inputs still enable test wizard
            if (CountVocInputs(uMixID))
            {
                fEnabled = TRUE;
                // If the capture device is not GFX capable, then there are no tabs to display
                fControl = GFXUI_CheckDevice(uMixID, GFXTYPE_CAPTURE);
            }

            mixerClose(hMixer);
        }
    }

    EnableRecVoiceVolCtrls(hDlg, fEnabled, fControl);
}


STATIC void SetVocPrefInfo(PAUDIODLGINFO paiVoc, HWND hDlg )
{
    HWND    hwndCBPlay   = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    HWND    hwndCBRec    = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT    item, deviceID;

	GetVocPrefInfo(paiVoc, hDlg);

    if (gbVocSelectChanged == TRUE)
	{
		gbVocSelectChanged = FALSE;
        item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

        if (item != CB_ERR)
		{
            deviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        
		    if(deviceID != paiVoc->uPrefOut)             // Make sure device changed
			{
                if (SetVoiceOutID(deviceID, paiVoc->fPrefOnly))
                {
                    paiVoc->uPrefOut = deviceID;
                }
			}
		}

        item = (UINT)ComboBox_GetCurSel(hwndCBRec);

        if (item != CB_ERR)
		{
            deviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

            if( deviceID != paiVoc->uPrefIn )            // Make sure device changed
			{
			    if (SetVoiceCapID(deviceID, paiVoc->fPrefOnly))
                {
                    paiVoc->uPrefIn = deviceID;
                }
			}
		}
	}

 
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);

    //  MIDI Devices are not remapped...
}



STATIC void VOICEOUTInit(HWND hDlg, PAUDIODLGINFO paiVoc)
{
    HWND        hwndCBPlay = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    UINT        device;
    TCHAR       szNoVoice[128];

    szNoVoice[0] = TEXT('\0');

	GetVocPrefInfo(paiVoc, hDlg);

    ComboBox_ResetContent(hwndCBPlay);
    gbVocPlayPresent = FALSE;

    if (paiVoc->cNumOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOPLAY, szNoVoice, sizeof(szNoVoice)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBPlay, szNoVoice);
        ComboBox_SetItemData(hwndCBPlay, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBPlay, 0);
        EnableWindow( hwndCBPlay, FALSE );
        EnablePlayVoiceVolCtrls(hDlg, FALSE);
	}
    else
    {
        EnableWindow( hwndCBPlay, TRUE );

        for (device = 0; device < paiVoc->cNumOutDevs; device++)
        {
            WAVEOUTCAPS     woc;
            int newItem;

            woc.szPname[0]  = TEXT('\0');

            if (waveOutGetDevCaps(device, &woc, sizeof(woc)))
            {
                continue;
            }

            woc.szPname[sizeof(woc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

	        newItem = ComboBox_AddString(hwndCBPlay, woc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBPlay, newItem, (LPARAM)device);  

                if (device == paiVoc->uPrefOut)
                {
                    ComboBox_SetCurSel(hwndCBPlay, newItem);
                    SetVoiceOut(device, hDlg);
                }
            }
        }
    }
}

STATIC void VOICECAPInit(HWND hDlg, PAUDIODLGINFO paiVoc)
{
    HWND        hwndCBRec = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT        device;
    TCHAR       szNoVoice[128];

    ComboBox_ResetContent(hwndCBRec);
    gbVocCapPresent = FALSE;

    if (paiVoc->cNumInDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOREC, szNoVoice, sizeof(szNoVoice)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBRec, szNoVoice);
        ComboBox_SetItemData(hwndCBRec, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBRec, 0);
        EnableWindow( hwndCBRec, FALSE );
        EnableRecVoiceVolCtrls(hDlg, FALSE, FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , FALSE);
    }
    else
    {
        EnableWindow( hwndCBRec, TRUE );

        for (device = 0; device < paiVoc->cNumInDevs; device++)
        {
            WAVEINCAPS     wic;
            int newItem;

            wic.szPname[0]  = TEXT('\0');

            if (waveInGetDevCaps(device, &wic, sizeof(wic)))
            {
                continue;
            }

            wic.szPname[sizeof(wic.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBRec, wic.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBRec, newItem, (LPARAM)device);

                if (device == paiVoc->uPrefIn)
                {   
                    ComboBox_SetCurSel(hwndCBRec, newItem);
                    SetVoiceCap(device, hDlg);
                }  
            }
        }
    }
}



STATIC void VoiceDlgInit(HWND hDlg)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));

	if (!paiVoc) return;
    
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)paiVoc);

    VOICEOUTInit(hDlg, paiVoc);
    VOICECAPInit(hDlg, paiVoc);
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
}


const static DWORD aVoiceHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX_VOC_1,        IDH_COMM_GROUPBOX,
    IDC_VOICE_CB_PLAY,         IDH_VOICE_SPEAKERICON,
    IDC_LAUNCH_VOCVOL,         IDH_VOICE_LAUNCH_VOCVOL,
	IDC_PLAYBACK_ADVVOC,       IDH_VOICE_PLAYBACK_ADVVOC,
    IDC_ICON_VOC_1,            IDH_VOICE_SPEAKERICON,
    IDC_TEXT_32,               NO_HELP,
    IDC_TEXT_VOC_1,            IDH_VOICE_SPEAKERICON,
    IDC_TEXT_VOC_2,            IDH_VOICE_RECORDICON,
    IDC_GROUPBOX_VOC_2,        IDH_COMM_GROUPBOX,
    IDC_VOICE_CB_REC,          IDH_VOICE_RECORDICON,
    IDC_LAUNCH_CAPVOL,         IDH_VOICE_LAUNCH_CAPVOL,
	IDC_CAPTURE_ADVVOL,        IDH_VOICE_CAPTURE_ADVVOL,
    IDC_ICON_VOC_2,            IDH_VOICE_RECORDICON,
	IDC_ADVANCED_DIAG,         IDH_VOICE_ADVANCED_TEST,
    
    0, 0
};


void WinMMVoiceChange(HWND hDlg)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    VOICEOUTInit(hDlg, paiVoc);
    VOICECAPInit(hDlg, paiVoc);
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
}



LRESULT CALLBACK VoiceTabProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == giVocChange)
    {
        WinMMVoiceChange(ghVocDlg);
    }
        
    return CallWindowProc(gfnVocPSProc,hwnd,iMsg,wParam,lParam);
}


void InitVoiceChange(HWND hDlg)
{
    gfnVocPSProc = (WNDPROC) SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LPARAM)VoiceTabProc);  
    giVocChange = RegisterWindowMessage(TEXT("winmm_devicechange"));
}

void UninitVoiceChange(HWND hDlg)
{
    SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LPARAM)gfnVocPSProc);  
}




BOOL CALLBACK VoiceDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    PAUDIODLGINFO paiVoc;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            ghVocDlg = hDlg;
			gfVoiceTab  = TRUE;

            InitVoiceChange(hDlg);

            if (!gfVocLoadedACM)
            {
                if (LoadACM())
                {
                    gfVocLoadedACM = TRUE;
                }
                else
                {
                    DPF("****Load ACM failed**\r\n");
                    ASSERT(FALSE);
                    ErrorBox(hDlg, IDS_CANTLOADACM, NULL);
                    ExitThread(0);
                }
            }

            VoiceDlgInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            UninitVoiceChange(hDlg);

            paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

            LocalFree((HLOCAL)paiVoc);

            if (gfVocLoadedACM)
            {
                if (!FreeACM())
                {
                    DPF("****Free ACM failed**\r\n");
                    ASSERT(FALSE);
                }

                gfVocLoadedACM = FALSE;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aVoiceHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aVoiceHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoVoiceCommand);
        }
        break;

        default:
        {
        }
        break;
    }
    return FALSE;
}

void ErrorVocMsgBox(HWND hDlg, UINT uTitle, UINT uMessage)
{
    TCHAR szMsg[MAXSTR];
    TCHAR szTitle[MAXSTR];

    LoadString(ghInstance, uTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR));
    LoadString(ghInstance, uMessage, szMsg, sizeof(szMsg)/sizeof(TCHAR));
    MessageBox(hDlg, szMsg,szTitle,MB_OK);
}


void LaunchVocPlaybackVolume(HWND hDlg)
{
    HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOVOCVOL);
            }
        }
        else
        {
            ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}


void LaunchCaptureVolume(HWND hDlg)
{
    HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEIN);


        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -R -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOVOCVOL);
            }
        }
        else
        {
            ErrorVocMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

void LaunchVoiceTest(HWND hDlg)
{
	HRESULT hr;
    GUID guidCapture;
    GUID guidPlayback;
    UINT    item;

    HWND    hwndVocPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    HWND    hwndVocCap  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    LPDIRECTPLAYVOICESETUP lpdpvs;

	item = (UINT)ComboBox_GetCurSel(hwndVocPlay);
    if (item != CB_ERR)
    {
        guidPlayback.Data1 = item;
    }
    else
    {
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        return;
	}

	item = (UINT)ComboBox_GetCurSel(hwndVocCap);
    if (item != CB_ERR)
    {
        guidCapture.Data1 = item;
    }
    else
    {
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        return;
	}

	if (FAILED(CoInitialize(NULL))) return;

	if (FAILED(CoCreateInstance(&CLSID_DirectPlayVoiceTest, 0, CLSCTX_ALL, &IID_IDirectPlayVoiceSetup, (void**)&lpdpvs)))
	{
		CoUninitialize();
		ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE, IDS_ERROR_NOVOCDIAG); 
		return;
	}

    hr = IDirectPlayVoiceSetup_CheckAudioSetup(lpdpvs, &guidPlayback, &guidCapture, hDlg, DVFLAGS_WAVEIDS );

    if (FAILED(hr) && hr != DVERR_COMMANDALREADYPENDING && hr != DVERR_SOUNDINITFAILURE && hr != DVERR_USERCANCEL)
	{
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE, IDS_ERROR_NOVOCDIAG);
    }

	IDirectPlayVoiceSetup_Release(lpdpvs);
	CoUninitialize();

}


BOOL PASCAL DoVoiceCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!gfVocLoadedACM)
    {
        return FALSE;
    }

    switch (id)
    {
        case ID_APPLY:
        {            
			SetVocPrefInfo(paiVoc, hDlg);
        }
        break;

        case IDC_VOICE_CB_PLAY:
        case IDC_VOICE_CB_REC:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);

                    if ((id ==  IDC_VOICE_CB_PLAY) || (id ==  IDC_VOICE_CB_REC))
                    {
                        int iIndex;

                        iIndex = ComboBox_GetCurSel(hwndCtl);

                        if (iIndex != CB_ERR)
                        {
							gbVocSelectChanged = TRUE;
                            if (id ==  IDC_VOICE_CB_REC)
                                SetVoiceCap(iIndex, hDlg);
                            if (id ==  IDC_VOICE_CB_PLAY)
                                SetVoiceOut(iIndex, hDlg);
                            if (gbVocCapPresent && gbVocPlayPresent) 
                                EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
                            else
                                EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , FALSE);
                        }
                    }
                }
                break;
            }
        }
        break;

        
        case IDC_ADVANCED_DIAG:
        {
            LaunchVoiceTest(hDlg);
        }
        break;

        case IDC_LAUNCH_VOCVOL:
        {
            LaunchVocPlaybackVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_CAPVOL:
        {
            LaunchCaptureVolume(hDlg);
        }
        break;

        case IDC_PLAYBACK_ADVVOC:
        {
            HWND    hwndVocPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefOut[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndVocPlay);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndVocPlay, u, (LPARAM)(LPVOID)szPrefOut);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndVocPlay, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefOut, FALSE);
            }
        }
        break;

        case IDC_CAPTURE_ADVVOL:
        {
            HWND    hwndVocCap  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefIn[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndVocCap);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndVocCap, u, (LPARAM)(LPVOID)szPrefIn);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndVocCap, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefIn, TRUE);
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\volume.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  volume.c
//
//      This file defines the functions that drive the volume
//      tab of the Sounds & Multimedia control panel.
//
//  History:
//      06 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <regstr.h>
#include <dbt.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <shlwapi.h>
#include "volume.h"
#include "mmcpl.h"
#include "trayvol.h"
#include "advaudio.h"
#include "medhelp.h"
#include "multchan.h"

// Constants
const SIZE ksizeBrandMax = { 32, 32 }; // Max Branding Bitmap Size
static SZCODE     aszSndVolOptionKey[] = REGSTR_PATH_SETUP TEXT("\\SETUP\\OptionalComponents\\Vol");
static SZCODE     aszInstalled[]       = TEXT("Installed");
static const char aszSndVol32[]        = "sndvol32.exe";
#define     VOLUME_TICS         (500)
static INTCODE  aKeyWordIds[] =
{
    IDC_VOLUME_BRAND,           IDH_VOLUME_BRAND,
    IDC_VOLUME_MIXER,           IDH_VOLUME_MIXER,
    IDC_GROUPBOX,               IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_VOLUME_ICON,            IDH_COMM_GROUPBOX,
	IDC_VOLUME_LOW,		        IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_MASTERVOLUME,           IDH_SOUNDS_SYS_VOL_CONTROL,
	IDC_VOLUME_HIGH,	        IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_VOLUME_MUTE,            IDH_SOUNDS_VOL_MUTE_BUTTON,
    IDC_TASKBAR_VOLUME,         IDH_AUDIO_SHOW_INDICATOR,
    IDC_LAUNCH_SNDVOL,          IDH_AUDIO_PLAY_VOL,
    IDC_GROUPBOX_2,             IDH_COMM_GROUPBOX,
    IDC_VOLUME_SPEAKER_BITMAP,  IDH_COMM_GROUPBOX,
    IDC_LAUNCH_MULTICHANNEL,    IDH_LAUNCH_MULTICHANNEL,
    IDC_PLAYBACK_ADVSETUP,      IDH_ADV_AUDIO_PLAY_PROP,
    IDC_TEXT_31,                NO_HELP,
    0,0
};

// TODO: Move to "regstr.h"
#define REGSTR_KEY_BRANDING TEXT("Branding")
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")
#define REGSTR_VAL_AUDIO_URL TEXT("url")

HBITMAP ghSpkBitmap;

///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: VolumeTabProc
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for volume control panel page device change
//               message.
//
//
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK VolumeTabProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == g_uiVolDevChange)
    {
        InitVolume (g_hWnd);
    }
        
    return CallWindowProc (g_fnVolPSProc, hwnd, iMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: VolumeDlg
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for volume control panel page.
//
//
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK VolumeDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            OnNotify (hDlg, (LPNMHDR) lParam);
        }
        break;

        case WM_INITDIALOG:
        {
            HANDLE_WM_INITDIALOG (hDlg, wParam, lParam, OnInitDialog);
        }
        break;

        case WM_DESTROY:
        {
            HANDLE_WM_DESTROY (hDlg, wParam, lParam, OnDestroy);
        }
        break;
         
        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND (hDlg, wParam, lParam, OnCommand);
        }
        break;

        case WM_POWERBROADCAST:
        {
            HandlePowerBroadcast (hDlg, wParam, lParam);
        }
        break;

        case MM_MIXM_LINE_CHANGE:
        case MM_MIXM_CONTROL_CHANGE:
        {
            if (!g_fInternalGenerated)
            {
                RefreshMixCache ();
                DisplayVolumeControl(hDlg);
            }

            g_fInternalGenerated = FALSE;
        }
        break;

	    case WM_HSCROLL:
        {
	        HANDLE_WM_HSCROLL (hDlg, wParam, lParam, MasterVolumeScroll);
	    }
        break;
        
        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_DEVICECHANGE:
        {
            DeviceChange_Change (hDlg, wParam, lParam);
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
            if (ghSpkBitmap)
            {
                DeleteObject(ghSpkBitmap);
                ghSpkBitmap = NULL;
            }
            
            ghSpkBitmap = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MULTICHANNEL_SPKR), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    
            SendDlgItemMessage(hDlg, IDC_VOLUME_SPEAKER_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghSpkBitmap);

        }
        break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE :
        {
            SendDlgItemMessage (hDlg, IDC_MASTERVOLUME, uMsg, wParam, lParam);
        }
        break;

        default:
        break;

    }

    return FALSE;

}



void OnNotify (HWND hDlg, LPNMHDR pnmh)
{
    if (!pnmh)
    {
        DPF ("bad WM_NOTIFY pointer\n");            
        return;
    }

    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
            break;

        case PSN_APPLY:
            FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
            break;

        case PSN_RESET:
            FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
            break;
                
    }
}


void OnDestroy (HWND hDlg)
{
    // Unregister from notifications
    DeviceChange_Cleanup();
    SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) g_fnVolPSProc);  
    // Free any mixer we have
    FreeMixer ();
    // Free any branding bitmap
    FreeBrandBmp ();
    // Free detail memory

    DeleteObject( ghSpkBitmap );

    if (g_mcd.paDetails)
    {
        LocalFree (g_mcd.paDetails);
        g_mcd.paDetails = NULL;
    }
    if (g_pvPrevious)
    {
        LocalFree (g_pvPrevious);
        g_pvPrevious = NULL;
    }
    if (g_pdblCacheMix)
    {
        LocalFree (g_pdblCacheMix);
        g_pdblCacheMix = NULL;
    }
    // Free URL memory
    if( g_szHotLinkURL )
    {
        LocalFree( g_szHotLinkURL );
        g_szHotLinkURL = NULL;
    }

    ZeroMemory (&g_mcd, sizeof (g_mcd));
    ZeroMemory (&g_mlDst, sizeof (g_mlDst));
}

void CreateHotLink (BOOL fHotLink)
{
    WCHAR   szMixerName[MAXMIXERLEN];
    WCHAR*  szLinkName;
    UINT    uiLinkSize = 0;

    // Underline the mixer name to appear like a browser hot-link.
    HWND hWndMixerName = GetDlgItem (g_hWnd, IDC_VOLUME_MIXER);
	DWORD dwStyle      = GetWindowLong (hWndMixerName, GWL_STYLE);

    if (fHotLink)
    {
        GetDlgItemText( g_hWnd, IDC_VOLUME_MIXER, szMixerName, MAXMIXERLEN);

        uiLinkSize = ((lstrlen(g_szHotLinkURL) * sizeof(WCHAR)) + (lstrlen(szMixerName) * sizeof(WCHAR)) 
            + (17 * sizeof(WCHAR))); //  The 17 is for extra characters plus a NULL

        szLinkName = (WCHAR *)LocalAlloc (LPTR, uiLinkSize);
        if (szLinkName)
        {
            wsprintf(szLinkName, TEXT("<A HREF=\"%s\">%s</A>"), g_szHotLinkURL, szMixerName);
            SetDlgItemText( g_hWnd, IDC_VOLUME_MIXER, szLinkName);
        
            LocalFree(szLinkName);
        }

        EnableWindow(hWndMixerName, TRUE);
        dwStyle |= WS_TABSTOP;
    }
    else
    {
        EnableWindow(hWndMixerName, FALSE);
        dwStyle &= ~WS_TABSTOP;
    }

    // Apply new style (remove/add tab stop)
	SetWindowLong (hWndMixerName, GWL_STYLE, dwStyle);

}


BOOL OnInitDialog (HWND hDlg, HWND hwndFocus, LPARAM lParam)
{

    // Init Globals
    g_hWnd               = hDlg;
    g_fChanged           = FALSE;
    g_fInternalGenerated = FALSE;
    // Set Device Change Notification
    g_fnVolPSProc = (WNDPROC) SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) VolumeTabProc);
    g_uiVolDevChange = RegisterWindowMessage (_T("winmm_devicechange"));
    // Save the default "No Audio Device" string
    GetDlgItemText (hDlg, IDC_VOLUME_MIXER, g_szNoAudioDevice, sizeof(g_szNoAudioDevice)/sizeof(g_szNoAudioDevice[0]));

    // Init Volume
    InitVolume (hDlg);

    if (ghSpkBitmap)
    {
        DeleteObject(ghSpkBitmap);
        ghSpkBitmap = NULL;
    }

    ghSpkBitmap = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MULTICHANNEL_SPKR), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    SendDlgItemMessage(hDlg, IDC_VOLUME_SPEAKER_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghSpkBitmap);


    return FALSE;

}


BOOL PASCAL OnCommand (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_TASKBAR_VOLUME:
        {
            if (Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME)) && (!SndVolPresent ()))
            {
                CheckDlgButton (hDlg, IDC_TASKBAR_VOLUME, FALSE);
                ErrorBox (hDlg, IDS_NOSNDVOL, NULL);
                g_sndvolPresent = sndvolNotChecked; // Reset
            }
            else
            {
                g_fTrayIcon = Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME));

                PropSheet_Changed(GetParent(hDlg),hDlg);
                g_fChanged = TRUE;
            }
        }
        break;

        case IDC_VOLUME_MUTE:
        {
            BOOL fMute = !GetMute ();
            SetMute(fMute);

            if ((g_fPreviousMute != fMute) && !g_fChanged)
            {
                g_fChanged = TRUE;
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }
        break;

        case ID_APPLY:
        {
            // Update Tray Icon
            BOOL fTrayIcon = Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME));
            if (fTrayIcon != GetTrayVolumeEnabled ())
            {
                g_fTrayIcon = fTrayIcon;
                SetTrayVolumeEnabled(g_fTrayIcon);
            }

            if (SUCCEEDED (GetVolume ()) && g_pvPrevious && g_mcd.paDetails)
            {
                // Copy data so can undo volume changes
                memcpy (g_pvPrevious, g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                DisplayVolumeControl (hDlg);
            }
            g_fPreviousMute = GetMute ();

            g_fChanged = FALSE;

            return TRUE;
        }
        break;

        case IDOK:
        {
            // OK processing handled in ID_APPLY because it is always
            // called from the property sheet's IDOK processing.
        }
        break;

        case IDCANCEL:
        {
            if (g_hMixer)
            {
                SetMute (g_fPreviousMute);
                if (g_pvPrevious && g_mcd.paDetails)
                {
                    // Undo volume changes
                    memcpy (g_mcd.paDetails, g_pvPrevious, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                    g_fInternalGenerated = TRUE;
                    mixerSetControlDetails ((HMIXEROBJ) g_hMixer, &g_mcd, MIXER_SETCONTROLDETAILSF_VALUE);
                    g_fInternalGenerated = FALSE;
                }
            }
            WinHelp (hDlg, gszWindowsHlp, HELP_QUIT, 0L);

        }
        break;

        case IDC_LAUNCH_SNDVOL:
        {
            TCHAR szCmd[MAXSTR];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            memset(&si, 0, sizeof(si));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;
            si.dwFlags = STARTF_USESHOWWINDOW;
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"), g_uiMixID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorBox (hDlg, IDS_NOSNDVOL, NULL);
            }
        }
        break;

        case IDC_LAUNCH_MULTICHANNEL:
        {
            Multichannel (hDlg, g_uiMixID, g_dwDest, g_dwVolID);
        }
        break;

        case IDC_PLAYBACK_ADVSETUP: 
        {
            MIXERCAPS mc;
            DWORD   dwDeviceID = g_uiMixID;


            if (MMSYSERR_NOERROR == mixerGetDevCaps (g_uiMixID, &mc, sizeof (mc)))
            {
                AdvancedAudio (hDlg, ghInstance, gszWindowsHlp, dwDeviceID, mc.szPname, FALSE);
            }
        }
        break;
    }


   return FALSE;

}


void InitVolume (HWND hDlg)
{

    FreeMixer ();

    // Get the master volume & display
    MasterVolumeConfig (hDlg, &g_uiMixID);

    if (SUCCEEDED (GetVolume ()) && g_pvPrevious && g_mcd.paDetails)
    {
        RefreshMixCache ();
        // Copy data so can undo volume changes
        memcpy (g_pvPrevious, g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);

        g_fPreviousMute = GetMute ();
    }
    DisplayVolumeControl (hDlg);

    DeviceChange_Init (hDlg, g_uiMixID);

 }

// returns current mute state
BOOL GetMute ()
{
    BOOL fMute = FALSE;

    if (g_hMixer && (g_dwMuteID != (DWORD) -1))
    {
        MIXERCONTROLDETAILS_UNSIGNED mcuMute;
        MIXERCONTROLDETAILS mcd = g_mcd;

        // Modify local copy for mute ...
        mcd.dwControlID = g_dwMuteID;
        mcd.cChannels = 1;
        mcd.paDetails = &mcuMute;
        mixerGetControlDetails ((HMIXEROBJ) g_hMixer, &mcd, MIXER_GETCONTROLDETAILSF_VALUE);

        fMute = (BOOL) mcuMute.dwValue;
    }

    return fMute;
}

BOOL SndVolPresent ()
{

    if (g_sndvolPresent == sndvolNotChecked)
    {
        OFSTRUCT of;
        if (HFILE_ERROR != OpenFile (aszSndVol32, &of, OF_EXIST | OF_SHARE_DENY_NONE))
        {
            g_sndvolPresent = sndvolPresent;
        }
        else
        {
            HKEY hkSndVol;
            g_sndvolPresent = sndvolNotPresent;

            if (!RegOpenKey (HKEY_LOCAL_MACHINE, aszSndVolOptionKey, &hkSndVol))
            {
                RegSetValueEx (hkSndVol, (LPTSTR) aszInstalled, 0L, REG_SZ, (LPBYTE)(TEXT("0")), 4);
                RegCloseKey (hkSndVol);
            }
        }
    }

    return (sndvolPresent == g_sndvolPresent);

}

void FreeMixer ()
{
    if (g_hMixer)
    {
        mixerClose (g_hMixer);
        g_hMixer = NULL;
    }
}

// Gets the primary audio device ID and find the mixer line for it
// It leaves it open so the slider can respond to other changes outside this app
//
void MasterVolumeConfig (HWND hWnd, UINT* puiMixID)
{

    UINT  uiWaveID;

    // Init
    g_fMasterVolume = g_fTrayIcon = g_fMasterMute = FALSE;
    g_dwDest = g_dwVolID = g_dwMuteID = 0;

    ResetBranding (hWnd);

    if (puiMixID && GetWaveID (&uiWaveID) == MMSYSERR_NOERROR)
    {
        if (MMSYSERR_NOERROR == mixerGetID (HMIXEROBJ_INDEX(uiWaveID), puiMixID, MIXER_OBJECTF_WAVEOUT))
        {
            SetBranding (hWnd, *puiMixID);

            if (SearchDevice (*puiMixID, &g_dwDest, &g_dwVolID, &g_dwMuteID))
            {
                FreeMixer ();

                if (MMSYSERR_NOERROR == mixerOpen (&g_hMixer, *puiMixID, (DWORD_PTR) hWnd, 0L, CALLBACK_WINDOW))
                {

                    ZeroMemory (&g_mlDst, sizeof (g_mlDst));
                    g_mlDst.cbStruct      = sizeof (g_mlDst);
                    g_mlDst.dwDestination = g_dwDest;
    
                    if (MMSYSERR_NOERROR == mixerGetLineInfo ((HMIXEROBJ)g_hMixer, &g_mlDst, MIXER_GETLINEINFOF_DESTINATION))
                    {
                        g_mcd.cbStruct       = sizeof (g_mcd);
                        g_mcd.dwControlID    = g_dwVolID;
                        g_mcd.cChannels      = g_mlDst.cChannels;
                        g_mcd.hwndOwner      = 0;
                        g_mcd.cMultipleItems = 0;
                        g_mcd.cbDetails      = sizeof (DWORD); // seems like it would be sizeof(g_mcd),
                                                               // but actually, it is the size of a single value
                                                               // and is multiplied by channel in the driver.
                        // TODO: Should Return Error on failure!
                        g_mcd.paDetails = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                        g_pvPrevious = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                        g_pdblCacheMix = (double*) LocalAlloc (LPTR, sizeof (double) * g_mlDst.cChannels);

                        g_fMasterVolume = TRUE;
                        g_fMasterMute = (g_dwMuteID != (DWORD) -1);
                        g_fTrayIcon = GetTrayVolumeEnabled ();
                    }
                }
            }
        }
    }
}

// Locates the master volume and mute controls for this mixer line
//
void SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, BOOL *pfFound)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) GlobalAlloc(GMEM_FIXED, sizeof(MIXERCONTROL) * pml->cControls);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls(HMIXEROBJ_INDEX(mxid), &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls && !(*pfFound); dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                {
                    DWORD dwIndex;
                    DWORD dwVolID = (DWORD) -1;
                    DWORD dwMuteID = (DWORD) -1;

                    dwVolID = mlc.pamxctrl[dwControl].dwControlID;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    *pfFound = TRUE;
                    *pdwVolID = dwVolID;
                    *pdwMuteID = dwMuteID;
                }
            }
        }

        GlobalFree((HGLOBAL) mlc.pamxctrl);
    }
}


// Locates the volume slider control for this mixer device
//
BOOL SearchDevice (DWORD dwMixID, LPDWORD pdwDest, LPDWORD pdwVolID, LPDWORD pdwMuteID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    BOOL        fFound = FALSE;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;

        for (dwDestination = 0; dwDestination < mc.cDestinations && !fFound; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    if (!fFound && mlDst.cControls)     // If there are controls, we'll take the master
                    {
                        SearchControls(dwMixID, &mlDst, pdwVolID, pdwMuteID, &fFound);
                        *pdwDest = dwDestination;
                    }
                }
            }
        }
    }

    return(fFound);
}


// Call this function to configure to the current preferred device and reflect master volume
// settings on the slider
//
void DisplayVolumeControl (HWND hDlg)
{
    HWND hwndVol        = GetDlgItem(hDlg, IDC_MASTERVOLUME);
    BOOL fMute          = g_fMasterMute && GetMute ();

    SendMessage(hwndVol, TBM_SETTICFREQ, VOLUME_TICS / 10, 0);
    SendMessage(hwndVol, TBM_SETRANGE, FALSE, MAKELONG(0,VOLUME_TICS));

    EnableWindow(GetDlgItem(hDlg, IDC_MASTERVOLUME) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_LOW) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_HIGH) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_TASKBAR_VOLUME),g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_MUTE), g_fMasterMute);
    EnableWindow(GetDlgItem(hDlg, IDC_LAUNCH_SNDVOL), g_fMasterVolume && SndVolPresent ());
    EnableWindow(GetDlgItem(hDlg, IDC_LAUNCH_MULTICHANNEL), g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_PLAYBACK_ADVSETUP), g_fMasterVolume);

    if (g_fMasterVolume)
    {
        UpdateVolumeSlider (hDlg, g_dwVolID);
    }
    else
    {
        SendMessage(GetDlgItem(hDlg, IDC_MASTERVOLUME), TBM_SETPOS, TRUE, 0 );
    }

    // Show if we are muted
    Button_SetCheck (GetDlgItem (hDlg, IDC_VOLUME_MUTE), fMute);

    // This displays the appropriate volume icon for the master mute state
    // This looks like a memory leak, but it's not.  LoadIcon just gets a handle to the already-loaded
    // icon if it was previously loaded.  See the docs for LoadIcon and DestroyIcon (which specifically
    // should not be called with a handle to an icon loaded via LoadIcon).
    if( fMute )
    {
        SendMessage (GetDlgItem (hDlg, IDC_VOLUME_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(ghInstance, MAKEINTRESOURCE (IDI_MUTESPEAKERICON)) );
    }
    else
    {
        SendMessage (GetDlgItem (hDlg, IDC_VOLUME_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(ghInstance, MAKEINTRESOURCE (IDI_SPEAKERICON)) );
    }
    CheckDlgButton (hDlg, IDC_TASKBAR_VOLUME, g_fTrayIcon);

}

// Called to update the slider when the volume is changed externally
//
void UpdateVolumeSlider(HWND hWnd, DWORD dwLine)
{
    if ((g_hMixer != NULL) && (g_dwVolID != (DWORD) -1) && (dwLine == g_dwVolID))
    {
        double volume = ((double) GetMaxVolume () / (double) 0xFFFF) * ((double) VOLUME_TICS);
        // The 0.5f forces rounding (instead of truncation)
        SendMessage(GetDlgItem(hWnd, IDC_MASTERVOLUME), TBM_SETPOS, TRUE, (DWORD) (volume+0.5f) );
    }
}


// returns current volume level
//
DWORD GetMaxVolume ()
{
    DWORD dwVol = 0;

    if (SUCCEEDED (GetVolume ()))
    {
        UINT uiIndx;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            dwVol = max (dwVol, pmcuVolume -> dwValue); 
        }
    }

    return dwVol;
}

HRESULT GetVolume ()
{
    HRESULT hr = E_FAIL;
    if (g_hMixer && g_mcd.paDetails)
    {
        g_mcd.dwControlID = g_dwVolID;
        ZeroMemory (g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
        hr = mixerGetControlDetails ((HMIXEROBJ)g_hMixer, &g_mcd, MIXER_GETCONTROLDETAILSF_VALUE);
    }
    return hr;
}


void DeviceChange_Cleanup ()
{
   if (g_hDeviceEventContext) 
   {
       UnregisterDeviceNotification (g_hDeviceEventContext);
       g_hDeviceEventContext = NULL;
   }
}


BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return FALSE;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	//Get an handle on the device interface name.
	*phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	GlobalFreePtr(szInterfaceName);
	if(INVALID_HANDLE_VALUE == *phDevice)
	{
		return FALSE;
	}

	return TRUE;
}

void DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{
	DEV_BROADCAST_HANDLE DevBrodHandle;
	HANDLE hMixerDevice=NULL;

	//If we had registered already for device notifications, unregister ourselves.
	DeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(DeviceChange_GetHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		g_hDeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
	}
}


// Handle the case where we need to dump mixer handle so PnP can get rid of a device
// We assume we will get the WINMM_DEVICECHANGE handle when the dust settles after a remove or add
// except for DEVICEQUERYREMOVEFAILED which will not generate that message.
//
void DeviceChange_Change(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

	if(!g_hDeviceEventContext || !bh || bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
	{
		return;
	}
	
    switch (wParam)
    {
	    case DBT_DEVICEQUERYREMOVE:     // Must free up Mixer if they are trying to remove the device           
        {
            FreeMixer ();
        }
        break;

	    case DBT_DEVICEQUERYREMOVEFAILED:   // Didn't happen, need to re-acquire mixer
        {
            InitVolume (hDlg);
        }
        break; 
    }
}

// Sets the mute state
void SetMute(BOOL fMute)
{
    if (g_hMixer)
    {
        MIXERCONTROLDETAILS_UNSIGNED mcuMute;
        MIXERCONTROLDETAILS mcd = g_mcd;

        // Modify local copy for mute ...
        mcuMute.dwValue = (DWORD) fMute;
        mcd.dwControlID = g_dwMuteID;
        mcd.cChannels = 1;
        mcd.paDetails = &mcuMute;

        mixerSetControlDetails ((HMIXEROBJ)g_hMixer, &mcd, MIXER_SETCONTROLDETAILSF_VALUE);
    }
}


// Called in response to slider movement, computes new volume level and sets it
// it also controls the apply state (changed or not)
//
void MasterVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    DWORD dwVol = (DWORD) SendMessage(GetDlgItem(hwnd, IDC_MASTERVOLUME), TBM_GETPOS, 0, 0);

    dwVol = (DWORD) (((double) dwVol / (double) VOLUME_TICS) * (double) 0xFFFF);
    SetVolume(dwVol);

    if (!g_fChanged && (memcmp (g_pvPrevious, g_mcd.paDetails, 
                        sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels)))
    {
        g_fChanged = TRUE;
        PropSheet_Changed(GetParent(hwnd),hwnd);
    }

    // Play a sound on for the master volume slider when the 
    // user ends the scroll and we are still in focus and the topmost app.
    if (code == SB_ENDSCROLL && hwndCtl == GetFocus() && GetParent (hwnd) == GetForegroundWindow ())
    {
        static const TCHAR cszDefSnd[] = TEXT(".Default");
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
    }

}

// Sets the volume level
//
void SetVolume (DWORD dwVol)
{

    if (g_hMixer && g_pdblCacheMix && g_mcd.paDetails)
    {
        UINT uiIndx;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

        // Caculate the new volume level for each of the channels. For volume levels 
        // at the current max, we simply set the newly requested level (in this case
        // the cache value is 1.0). For those less than the max, we set a value that 
        // is a percentage of the max. This maintains the relative distance of the 
        // channel levels from each other.
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            // The 0.5f forces rounding (instead of truncation)
            pmcuVolume -> dwValue = (DWORD)(*(g_pdblCacheMix + uiIndx) * (double) dwVol + 0.5f);
        }

        g_fInternalGenerated = TRUE;
        mixerSetControlDetails ((HMIXEROBJ)g_hMixer, &g_mcd, MIXER_SETCONTROLDETAILSF_VALUE);
        g_fInternalGenerated = FALSE;
    }

}


void HandlePowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
	    case PBT_APMQUERYSUSPEND:
        {
            FreeMixer ();
        }
	    break;

	    case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            InitVolume (hWnd);
        }
	    break;
    }
}



BOOL ChannelsAllMinimum()
{
    MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

    if (g_hMixer && g_mcd.paDetails)
    {
        UINT uiIndx;
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
           pmcuVolume =  (MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx;
           if ( pmcuVolume->dwValue  != 0)
           {
               return (FALSE);
           }
        }
        return (TRUE);      // Volume of all channels equals zero since we haven't returned yet.
    }
    else return (FALSE);


}


void RefreshMixCache ()
{
    if (g_fCacheCreated && ChannelsAllMinimum())
    {
        return;
    }

    if (g_pdblCacheMix && g_hMixer && g_mcd.paDetails)
    {

        UINT uiIndx;
        double* pdblMixPercent;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;
        // Note: This call does a GetVolume(), so no need to call it again...
        DWORD dwMaxVol = GetMaxVolume ();

        // Caculate the percentage distance each channel is away from the max
        // value. Creating this cache allows us to maintain the relative distance 
        // of the channel levels from each other as the user adjusts the master
        // volume level.
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume     = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            pdblMixPercent = (g_pdblCacheMix + uiIndx);

            // Caculate the percentage this value is from the max ...
            if (dwMaxVol == pmcuVolume -> dwValue)
            {
                *pdblMixPercent = 1.0F;
            }
            else
            {
                *pdblMixPercent = ((double) pmcuVolume -> dwValue / (double) dwMaxVol);
            }
        }
        g_fCacheCreated = TRUE;
    }
}


void FreeBrandBmp ()
{
    if (g_hbmBrand)
    {
        DeleteObject (g_hbmBrand);
        g_hbmBrand = NULL;
    }
}

void ResetBranding (HWND hwnd)
{
    FreeBrandBmp ();
    if( g_szHotLinkURL )
    {
        LocalFree( g_szHotLinkURL );
        g_szHotLinkURL = NULL;
    }

    // Initialize the Device Name Text
    SetDlgItemText (hwnd, IDC_VOLUME_MIXER, g_szNoAudioDevice);
    EnableWindow (GetDlgItem (hwnd, IDC_VOLUME_MIXER), FALSE);

    // Show the default icon window, and hide the custom bitmap window
    ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_SHOW);
    ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_HIDE);
}

void SetBranding (HWND hwnd, UINT uiMixID)
{
    
    HKEY hkeyBrand = NULL;
    MIXERCAPS mc;

    if (MMSYSERR_NOERROR != mixerGetDevCaps (uiMixID, &mc, sizeof (mc)))
        return; // bail

    ResetBranding (hwnd);

    // Device Name Text
    SetDlgItemText(hwnd, IDC_VOLUME_MIXER, mc.szPname);


    // Get Device Bitmap, if any.
    hkeyBrand = OpenDeviceBrandRegKey (uiMixID);
    if (hkeyBrand)
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cb     = sizeof (szBuffer);

        // Get Any Branding Bitmap
        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_BITMAP, NULL, &dwType, (LPBYTE)szBuffer, &cb))
        {
            BITMAP bm;
            WCHAR* pszComma = wcschr (szBuffer, L',');
            if (pszComma)
            {
                WCHAR* pszResourceID = pszComma + 1;
                HANDLE hResource;

                // Remove comma delimeter
                *pszComma = L'\0';

                // Should be a resource module and a resource ID
                hResource = LoadLibrary (szBuffer);
                if (!hResource)
                {
                    WCHAR szDriversPath[MAX_PATH+1];
                    szDriversPath[MAX_PATH] = 0;

                    // If we didn't find it on the normal search path, try looking
                    // in the "drivers" directory.
                    if (GetSystemDirectory (szDriversPath, MAX_PATH))
                    {
                        wcsncat (szDriversPath, TEXT("\\drivers\\"), MAX_PATH - wcslen(szDriversPath));
                        wcsncat (szDriversPath, szBuffer, MAX_PATH - wcslen(szDriversPath));
                        hResource = LoadLibrary (szDriversPath);
                    }

                }
                if (hResource)
                {
                    g_hbmBrand = LoadImage (hResource, MAKEINTRESOURCE(_wtoi (pszResourceID)), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);
                    FreeLibrary (hResource);
                }
            }
            else
                // Should be an *.bmp file
                g_hbmBrand = LoadImage (NULL, szBuffer, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);

            // Verify that this bitmap is not larger than our defined maximum. Do NOT
            // use GetBitmapDimensionEx() here as it not set or used by the system.
            if (g_hbmBrand && GetObject (g_hbmBrand, sizeof (BITMAP), &bm))
            {
                if (bm.bmWidth > ksizeBrandMax.cx ||
                    bm.bmHeight > ksizeBrandMax.cy)
                {
                    // Too big, we will just show the standard one below
                    FreeBrandBmp ();
                }
            }
        }

        // Get Any Branding URL

        // Get the size of the URL
        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_URL, NULL, &dwType, NULL, &cb))
        {
            // Allocate a buffer to store the URL in, ensuring it is an integer number of WCHARs
            g_szHotLinkURL = (WCHAR *)LocalAlloc (LPTR, sizeof(WCHAR) * (cb + (sizeof(WCHAR)-1) / sizeof(WCHAR)));

            // Now, get the branding URL
            if (ERROR_SUCCESS != RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_URL, NULL, &dwType, (LPBYTE)g_szHotLinkURL, &cb))
            {
                // If we failed, free up g_szHotLinkURL
                LocalFree( g_szHotLinkURL );
                g_szHotLinkURL = NULL;
            }
        }

        // Close the Branding key
        RegCloseKey (hkeyBrand);
    }

    // Apply any bitmap we have now.
    if (g_hbmBrand)
    {
        // Show the custom bitmap window, and hide the default icon window
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_SHOW);
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_HIDE);

        SendMessage (GetDlgItem (hwnd, IDC_VOLUME_BRAND), STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)g_hbmBrand);
    }
    else
    {
        // Show the default icon window, and hide the custom bitmap window
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_SHOW);
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_HIDE);
    }

    // Create HotLink text if we have a valid internet address
    CreateHotLink (ValidateURL ());

}


BOOL ValidateURL ()
{

    BOOL fValid = FALSE;

    // Test basic validity
    if (g_szHotLinkURL && (0 < lstrlen (g_szHotLinkURL)))
    {
        // Test URL validity
        if (UrlIsW (g_szHotLinkURL, URLIS_URL))
        {

            WIN32_FIND_DATA fd;
            HANDLE hFile;

            // Make certain that the URL is not a local file!
            hFile = FindFirstFileW (g_szHotLinkURL, &fd);
            if (INVALID_HANDLE_VALUE == hFile)
                fValid = TRUE;
            else
                FindClose (hFile);
        }
    }

    // Clear any bogus info...
    if (!fValid && g_szHotLinkURL)
    {
        LocalFree (g_szHotLinkURL);
        g_szHotLinkURL = NULL;
    }

    return fValid;

}

STDAPI_(void) Multichannel (HWND hwnd, UINT uiMixID, DWORD dwDest, DWORD dwVolID)
{

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    TCHAR szWindowTitle[255];
    TCHAR szPageTitle[255];
    UINT uiTitle;

    // Save multichannel parameters for the multichannel page
    if (SUCCEEDED (SetDevice (uiMixID, dwDest, dwVolID))) 
    {
        // Load Page Title
        LoadString (ghInstance, GetPageStringID (), szPageTitle, sizeof (szPageTitle)/sizeof (TCHAR));

        ZeroMemory (&psp, sizeof (PROPSHEETPAGE));
        psp.dwSize      = sizeof (PROPSHEETPAGE);
        psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE | PSP_USECALLBACK;
        psp.hInstance   = ghInstance;
        psp.pszTemplate = MAKEINTRESOURCE (IDD_MULTICHANNEL);
        psp.pszTitle    = szPageTitle;
        psp.pfnDlgProc  = MultichannelDlg;

        // Load Window Title (Same as page name now!)
        LoadString (ghInstance, GetPageStringID (), szWindowTitle, sizeof (szWindowTitle)/sizeof (TCHAR));

        ZeroMemory (&psh, sizeof (psh));
        psh.dwSize     = sizeof (psh);
        psh.dwFlags    = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
        psh.hwndParent = hwnd;
        psh.hInstance  = ghInstance;
        psh.pszCaption = szWindowTitle;
        psh.nPages     = 1;
        psh.nStartPage = 0;
        psh.ppsp       = &psp;

        PropertySheet (&psh);
    }
}


HKEY OpenDeviceBrandRegKey (UINT uiMixID)
{

    HKEY hkeyBrand = NULL;
    HKEY hkeyDevice = OpenDeviceRegKey (uiMixID, KEY_READ);

    if (hkeyDevice)
    {
        if (ERROR_SUCCESS != RegOpenKey (hkeyDevice, REGSTR_KEY_BRANDING, &hkeyBrand))
            hkeyBrand = NULL; // Make sure NULL on failure

        // Close the Device key
        RegCloseKey (hkeyDevice);
    }

    return hkeyBrand;

}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return NULL;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return NULL;
		}
	}

    return szInterfaceName;
}


HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam)
{

    HKEY hkeyDevice = NULL;
    PTCHAR szInterfaceName = GetInterfaceName (uiMixID);

    if (szInterfaceName)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL); 
        
        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, szInterfaceName, 
                                            0, &DeviceInterfaceData))
            {
                DWORD dwRequiredSize;
                SP_DEVINFO_DATA DeviceInfoData;
                DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

                // Ignore error, it always returns "ERROR_INSUFFICIENT_BUFFER" even though
                // the "SP_DEVICE_INTERFACE_DETAIL_DATA" parameter is supposed to be optional.
                (void) SetupDiGetDeviceInterfaceDetail (DeviceInfoSet, &DeviceInterfaceData,
                                                        NULL, 0, &dwRequiredSize, &DeviceInfoData);
                // Open device reg key
                hkeyDevice = SetupDiOpenDevRegKey (DeviceInfoSet, &DeviceInfoData,
                                                   DICS_FLAG_GLOBAL, 0,
                                                   DIREG_DRV, sam);

            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
        GlobalFreePtr (szInterfaceName);
    }

    return hkeyDevice;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\utils.c ===
#include "mmcpl.h"
#include "utils.h"

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef struct _DYNLOAD_INFO
{
    LPCTSTR  pszLib;
    HMODULE hLib;
    short   iRefCnt;
}
DYNLOAD_INFO, *PDYNLOAD_INFO;

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE aszMSACM32[] = TEXT("MSACM32.DLL");
static SZCODE aszAVIFIL32[] = TEXT("AVIFIL32.DLL");
static SZCODE aszMSVFW32[] = TEXT("MSVFW32.DLL");
static SZCODE aszVERSION[] = TEXT("VERSION.DLL");


DYNLOAD_INFO DynLoadInfo[] =
{
    aszMSACM32,   0, 0,
    aszAVIFIL32,  0, 0,
    aszMSVFW32,   0, 0,
    aszVERSION,   0, 0,
    NULL,         0, 0
};

static const char cszTacmFormatDetailsW[] = "acmFormatDetailsW";
static const char cszTacmFormatTagDetailsW[] = "acmFormatTagDetailsW";
static const char cszTacmDriverDetailsW[] = "acmDriverDetailsW";
static const char cszTacmDriverMessage[]  = "acmDriverMessage";
static const char cszTacmDriverAddW[]     = "acmDriverAddW";
static const char cszTacmDriverEnum[]     = "acmDriverEnum";
static const char cszTacmDriverPriority[] = "acmDriverPriority";
static const char cszTacmDriverRemove[]   = "acmDriverRemove";
static const char cszTacmMetrics[]        = "acmMetrics";
static const char cszTacmFormatChooseW[]  = "acmFormatChooseW";

PROC_INFO ACMProcs[] =
{
    cszTacmFormatDetailsW,    0,
    cszTacmFormatTagDetailsW, 0,
    cszTacmDriverDetailsW,    0,
    cszTacmDriverMessage,     0,
    cszTacmDriverAddW,        0,
    cszTacmDriverEnum,        0,
    cszTacmDriverPriority,    0,
    cszTacmDriverRemove,      0,
    cszTacmMetrics,           0,
    cszTacmFormatChooseW,     0,

    NULL, 0
};

static const char cszICClose[]       = "ICClose";
static const char cszICGetInfo[]     = "ICGetInfo";
static const char cszICLocate[]      = "ICLocate";
static const char cszMCIWndCreateW[] = "MCIWndCreateW";

PROC_INFO VFWProcs[] =
{
    cszICClose,             0,
    cszICGetInfo,           0,
    cszICLocate,            0,
    cszMCIWndCreateW,       0,

    NULL, 0
};

static const char cszAVIFileRelease[]         = "AVIFileRelease";
static const char cszAVIStreamRelease[]       = "AVIStreamRelease";
static const char cszAVIStreamSampleToTime[]  = "AVIStreamSampleToTime";
static const char cszAVIStreamStart[]         = "AVIStreamStart";
static const char cszAVIStreamLength[]        = "AVIStreamLength";
static const char cszAVIStreamReadFormat[]    = "AVIStreamReadFormat";
static const char cszAVIStreamInfoW[]         = "AVIStreamInfoW";
static const char cszAVIFileGetStream[]       = "AVIFileGetStream";
static const char cszAVIFileOpenW[]           = "AVIFileOpenW";
static const char cszAVIFileInit[]            = "AVIFileInit";
static const char cszAVIFileExit[]            = "AVIFileExit";


PROC_INFO AVIProcs[] =
{
    cszAVIFileRelease,          0,
    cszAVIStreamRelease,        0,
    cszAVIStreamSampleToTime,   0,
    cszAVIStreamStart,          0,
    cszAVIStreamLength,         0,
    cszAVIStreamReadFormat,     0,
    cszAVIStreamInfoW,          0,
    cszAVIFileGetStream,        0,
    cszAVIFileOpenW,            0,
    cszAVIFileInit,             0,
    cszAVIFileExit,             0,

    NULL, 0
};

static const char cszVerQueryValueW[]          = "VerQueryValueW";
static const char cszGetFileVersionInfoW[]     = "GetFileVersionInfoW";
static const char cszGetFileVersionInfoSizeW[] = "GetFileVersionInfoSizeW";

PROC_INFO VERSIONProcs[] =
{
    cszVerQueryValueW,          0,
    cszGetFileVersionInfoW,     0,
    cszGetFileVersionInfoSizeW, 0,

    NULL, 0
};

/*
 ***************************************************************
 ***************************************************************
 */
STATIC BOOL LoadLibraryAndProcs(LPCTSTR pLibrary, PPROC_INFO pProcInfo)
{
    HMODULE    hLibrary;
    PPROC_INFO p;
	PDYNLOAD_INFO pLib;
	BOOL	fPrevLoaded = FALSE;

#ifdef DEBUG_BUILT_LINKED
	return TRUE;
#endif

	if (pProcInfo->Address)	//Already loaded
	{
		fPrevLoaded = TRUE;
		goto UpdateDynLoadInfo;
	}	
    hLibrary = LoadLibrary(pLibrary);

    if (hLibrary == NULL)
    {
		DPF("LoadLibrary failed for %s \r\n", pLibrary);
		return FALSE;
    }

    p = pProcInfo;

    while (p->Name)
    {
        p->Address = GetProcAddress(hLibrary, p->Name);

        if (p->Address == NULL)
        {
			DPF("GetProcAddress failed for %s \r\n", p->Name);
			FreeLibrary(hLibrary);
			return FALSE;
        }

        p++;
    }

UpdateDynLoadInfo:
	pLib = DynLoadInfo;

	while (pLib->pszLib)
	{
		if (!lstrcmpi(pLib->pszLib, pLibrary))
		{
			pLib->iRefCnt++;
			if (!fPrevLoaded)
			{
				pLib->hLib = hLibrary;
			}
			break;
		}
		pLib++;
	}


    return TRUE;
}

STATIC BOOL FreeLibraryAndProcs(LPCTSTR pLibrary, PPROC_INFO pProcInfo)
{
	PDYNLOAD_INFO p;

#ifdef DEBUG_BUILT_LINKED    
	return TRUE;
#endif

	p = DynLoadInfo;

	while (p->pszLib)
	{
		if (!lstrcmpi(p->pszLib, pLibrary))
		{
		    PPROC_INFO ppi;

			p->iRefCnt--;
			if (p->iRefCnt > 0)
				return TRUE;
			if (!p->hLib)
				return FALSE;
			DPF("Freeing Library %s \r\n",p->pszLib);
			FreeLibrary(p->hLib);
			p->hLib = 0;
			
			ppi = pProcInfo;
			while (ppi->Name)
			{
				ppi->Address = 0;
				ppi++;
			}
			return TRUE;
		}
		p++;
	}
	return FALSE;
}

BOOL LoadACM()
{
	DPF("***LOADING ACM***\r\n");
	return LoadLibraryAndProcs(aszMSACM32, ACMProcs);	
}

BOOL FreeACM()
{
	DPF("***FREEING ACM***\r\n");
	return FreeLibraryAndProcs(aszMSACM32, ACMProcs);	
}


BOOL LoadAVI()
{
	DPF("***LOADING AVI***\r\n");
	return LoadLibraryAndProcs(aszAVIFIL32, AVIProcs);	
}

BOOL FreeAVI()
{
	DPF("***FREEING AVI***\r\n");
	return FreeLibraryAndProcs(aszAVIFIL32, AVIProcs);	
}

BOOL LoadVFW()
{
	DPF("***LOADING VFW***\r\n");
	return LoadLibraryAndProcs(aszMSVFW32, VFWProcs);	
}

BOOL FreeVFW()						 
{
	DPF("***FREEING VFW***\r\n");
	return FreeLibraryAndProcs(aszMSVFW32, VFWProcs);	
}

BOOL LoadVERSION()
{
	DPF("***LOADING VERSION***\r\n");
	return LoadLibraryAndProcs(aszVERSION, VERSIONProcs);	
}

BOOL FreeVERSION()
{
	DPF("***FREEING VERSION***\r\n");
	return FreeLibraryAndProcs(aszVERSION, VERSIONProcs);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\idl\makefile.inc ===
mmsys.rc : $(O)\mmsys.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\hardware.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Hardware.h
//
//      This file defines the CHardware class that provides 
//      the IHardware interface to give the multimedia control
//      panel the hardware information it needs.
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

//=============================================================================
//                            Include files
//=============================================================================
#include "resource.h"       // main symbols
#include "DirectSound.h"

/////////////////////////////////////////////////////////////////////////////
// CHardware
class ATL_NO_VTABLE CHardware : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHardware, &CLSID_Hardware>,
	public IDispatchImpl<IHardware, &IID_IHardware, &LIBID_MMSYSLib>
{
public:
	CHardware()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_HARDWARE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHardware)
	COM_INTERFACE_ENTRY(IHardware)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IHardware
public:
	STDMETHOD(GetSpeakerType)(/*[in]*/ UINT uiMixID, /*[out, retval]*/ VARIANT* pvarType);
	STDMETHOD(SetSpeakerType)(/*[in]*/ UINT uiMixID, /*[in]*/ DWORD dwType);
	STDMETHOD(GetAcceleration)(/*[in]*/ UINT uiMixID, /*[in]*/ BOOL fRecord, /*[out, retval]*/ VARIANT* pvarHWLevel);
	STDMETHOD(SetAcceleration)(/*[in]*/ UINT uiMixID, /*[in]*/ BOOL fRecord, /*[in]*/ DWORD dwHWLevel);
	STDMETHOD(GetSrcQuality)(/*[in]*/ UINT uiMixID, /*[in]*/ BOOL fRecord, /*[out, retval]*/ VARIANT* pvarSRCLevel);
	STDMETHOD(SetSrcQuality)(/*[in]*/ UINT uiMixID, /*[in]*/ BOOL fRecord, /*[in]*/ DWORD dwSRCLevel);

private:
    CDirectSound m_DirectSound;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mixers.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Mixers.cpp
//
//      This file defines the CMixers class that provides 
//      access to much of the mixerline functionality used
//      by the multimedia control panel.
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include "stdafx.h"
#include "Mmsys.h"
#include "Mixers.h"
#include "shellapi.h"
#include "systrayp.h"
#include <Mmsystem.h>


/////////////////////////////////////////////////////////////////////////////
// CMixers


STDMETHODIMP CMixers::get_TaskBarVolumeIcon (BOOL* pfTaskBar)
{

    HRESULT hr = S_OK;
    if (VERIFYPTR (pfTaskBar))
    {
        *pfTaskBar = SysTray_IsServiceEnabled (STSERVICE_VOLUME);
    }
    else
    {
        hr = E_INVALIDARG;
        assert2 (FALSE, L"Bad param passed to get_TaskBarVolumeIcon()!");
    }

	return hr;

}

STDMETHODIMP CMixers::put_TaskBarVolumeIcon (BOOL fEnable)
{

    HRESULT hr  = S_OK;
    BOOL fError = SysTray_EnableService (STSERVICE_VOLUME, fEnable);
    if (fError)
    {
        hr = E_FAIL;
        assert2 (FALSE, L"Unable to enable/disable volume icon!");
    }

	return hr;

}

STDMETHODIMP CMixers::get_NumDevices (UINT* puiNumDevices)
{

    HRESULT hr = S_OK;
    if (VERIFYPTR (puiNumDevices))
    {
        *puiNumDevices = mixerGetNumDevs ();
    }
    else
    {
        hr = E_INVALIDARG;
        assert2 (FALSE, L"Bad param passed to get_NumDevices()!");
    }

	return hr;

}

STDMETHODIMP CMixers::QueryMixerProperty (UINT uiMixID, BSTR bstrProp, VARIANT* pvarValue)
{

    HRESULT hr = E_INVALIDARG;
    if (VERIFYPTR (pvarValue) && VERIFYPTR (bstrProp))
    {
        // Get the mixer info
        MIXERCAPS mc;
        ZeroMemory (&mc, sizeof (MIXERCAPS));
        if (SUCCEEDED (hr = mixerGetDevCaps (uiMixID, &mc, sizeof (MIXERCAPS))))
        {
            // Return the requested property
            if (0 == _wcsicmp (bstrProp, kwszMixPropName))
            {
                V_VT (pvarValue)   = VT_BSTR;
                V_BSTR (pvarValue) = SysAllocString (mc.szPname);
                if (BADPTR (V_BSTR (pvarValue)))
                {
                    V_VT (pvarValue) = VT_EMPTY;
                    hr = E_OUTOFMEMORY;
                }
            }
            else if (0 == _wcsicmp (bstrProp, kwszMixPropDestCount))
            {
                V_VT (pvarValue)  = VT_UI4;
                V_UI4 (pvarValue) = mc.cDestinations;
            }
            else
            {
                // Invalid Property
                hr = E_INVALIDARG;
            }
        }
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to get mixer property!");
    }
	return hr;

}

STDMETHODIMP CMixers::QueryDestinationProperty (UINT uiMixID, UINT uiDestID, BSTR bstrProp, VARIANT* pvarValue)
{

    HRESULT hr = E_INVALIDARG;
    if (VERIFYPTR (pvarValue) && VERIFYPTR (bstrProp))
    {
        MIXERLINE ml;
        ZeroMemory (&ml, sizeof (MIXERLINE));
        ml.cbStruct = sizeof (MIXERLINE);
        ml.dwDestination = uiDestID;

        // Open the specified mixer
        HMIXER hmx;
        if (SUCCEEDED (hr = mixerOpen (&hmx, uiMixID, 0, 0, MIXER_OBJECTF_HMIXER)))
        {
            // Get the destination info
            if (SUCCEEDED (hr = mixerGetLineInfo ((HMIXEROBJ)hmx, &ml, MIXER_GETLINEINFOF_DESTINATION)))
            {
                // Return the requested property
                if (0 == _wcsicmp (bstrProp, kwszDestPropName))
                {
                    V_VT (pvarValue)   = VT_BSTR;
                    V_BSTR (pvarValue) = SysAllocString (ml.szName);
                    if (BADPTR (V_BSTR (pvarValue)))
                    {
                        V_VT (pvarValue) = VT_EMPTY;
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    // Invalid Property
                    hr = E_INVALIDARG;
                }
            }

            // Don't let mixerClose() overwrite any previous error.
            if (SUCCEEDED (hr))
                hr = mixerClose (hmx);
            else
                (void) mixerClose (hmx);
        }
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to get destination property!");
    }
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\barf.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Barf.h
//
//      This file defines macros for pointer checking and
//      other useful stuff.
//
//  History:
//      25 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

//=============================================================================
//                            Include files
//=============================================================================
#include "mmdebug.h"

#ifdef _DEBUG

// Magic 'invalid pointer' values used by various memory allocaters
SHARED_CONST DWORD grgBadPtrVals[] = 
{
    0x00000000L,    // NULL
    0xcdcdcdcdL,    // fresh memory
    0xccccccccL,    // uninitialized local
    0xbaadf00dL,    // MFCism?
    0xddddddddL,    // freed memory
    0xababababL,    // ??
    0xfdfdfdfdL     // No Man's Land - debug memory allocator pads real blocks with this pattern
};
#define BADPTRVALS (sizeof(grgBadPtrVals)/sizeof(grgBadPtrVals[0]))

BOOL inline BADPTR(const void* p)  
{
    for (int ii=0; ii < BADPTRVALS; ii++)
        if ((const void *)grgBadPtrVals[ii] == p) return TRUE;
    return FALSE;

}
#else
BOOL inline BADPTR(const void* p)  
{
    return (NULL == p);
}
#endif
#define VERIFYPTR(p) (!BADPTR(p))

// Verify Read & Write ptrs
#define VERIFYREADPTR(p,cb) (VERIFYPTR(p) && !::IsBadReadPtr (p,cb))
#define VERIFYWRITEPTR(p,cb) (VERIFYPTR(p) && !::IsBadWritePtr (p,cb))
#define BADREADPTR(p,cb) (!VERIFYREADPTR(p,cb))
#define BADWRITEPTR(p,cb) (!VERIFYWRITEPTR(p,cb))


//////////////////////////////////////////////////////////////////////
// HR Macros
//////////////////////////////////////////////////////////////////////
#define RTN_HR_IF_BADNEW(px)\
    do {\
    LPVOID pvTmp = (void*) (px);\
    if ( BADPTR(pvTmp) ){assert2(FALSE,_T(#px));return ERROR_NOT_ENOUGH_MEMORY;}\
    } while(0)

#define RTN_HR_IF_BADPTR(px)\
    do {\
    LPVOID pvTmp = (void*) (px);\
    if ( BADPTR(pvTmp) ) {assert2(FALSE,_T(#px));return E_INVALIDARG;}\
    } while(0)

#define RTN_HR_IF_FAILED(hrExp)\
    do {\
    HRESULT hrTmp = (hrExp);\
	if ( FAILED(hrTmp) ){assert3(FALSE, _T(" HRESULT returned = %s "), #hrExp);return hrTmp;}\
    } while(0)

#define RTN_HR_IF_ZERO(fExp)\
    do {\
    if ( (!(fExp)) ){assert2(FALSE,_T(#fExp));return E_FAIL;}\
    } while(0)

#define RTN_HR_IF_FALSE RTN_HR_IF_ZERO
#define RTN_HR_IF_TRUE(fExp) RTN_HR_IF_FALSE(!(fExp))

//////////////////////////////////////////////////////////////////////
// Void Macros
//////////////////////////////////////////////////////////////////////
#define RTN_VOID_IF_BADPTR(px)\
    do {\
    LPVOID pvTmp = (void*) (px);\
	if ( BADPTR(pvTmp) ) {assert2(FALSE,_T(#px));return;}\
    } while(0)

#define RTN_VOID_IF_FAILED(hrExp)\
    do {\
    HRESULT hrTmp = (hrExp);\
	if ( FAILED(hrTmp) ){assert3(FALSE, _T(" HRESULT returned = %s "), #hrExp);return;}\
    } while(0)

#define RTN_VOID_IF_ZERO(fExp)\
    do {\
    if ( (!(fExp)) ){assert2(FALSE,_T(#fExp));return;}\
    } while(0)

#define RTN_VOID_IF_FALSE RTN_VOID_IF_ZERO
#define RTN_VOID_IF_TRUE(fExp) RTN_VOID_IF_FALSE(!(fExp))

//////////////////////////////////////////////////////////////////////
// Ptr Macros
//////////////////////////////////////////////////////////////////////
#define RTN_NULL_IF_FAILED(hrExp)\
    do {\
    HRESULT hrTmp = (hrExp);\
	if ( FAILED(hrTmp) ){assert3(FALSE, _T(" HRESULT returned = %s "), #hrExp);return NULL;}\
    } while(0)

#define RTN_NULL_IF_BADPTR(px)\
    do {\
    LPVOID pvTmp = (void*) (px);\
    if ( BADPTR(pvTmp) ){assert2(FALSE,_T(#px));return NULL;}\
    } while(0)


#define RTN_NULL_IF_ZERO(fExp)\
    do {\
    if ( (!(fExp)) ){assert2(FALSE,_T(#fExp));return NULL;}\
    } while(0)


#define RTN_NULL_IF_FALSE RTN_NULL_IF_ZERO
#define RTN_NULL_IF_TRUE(fExp) RTN_NULL_IF_FALSE(!(fExp))

//////////////////////////////////////////////////////////////////////
// BOOL Macros
//////////////////////////////////////////////////////////////////////

#define RTN_FALSE_IF_BADPTR(px)\
    do {\
    LPVOID pvTmp = (void*) (px);\
	if ( BADPTR(pvTmp) ){assert2(FALSE,_T(#px));return FALSE;}\
    } while(0)

#define RTN_FALSE_IF_FAILED(hrExp)\
    do {\
    HRESULT hrTmp = (hrExp);\
	if ( FAILED(hrTmp) ){assert3(FALSE, _T(" HRESULT returned = %s "), #hrExp);return FALSE;}\
    } while(0)

#define RTN_FALSE_IF_ZERO(fExp)\
    do {\
    if ( (!(fExp)) ){assert2(FALSE,_T(#fExp));return FALSE;}\
    } while(0)

#define RTN_FALSE_IF_FALSE RTN_FALSE_IF_ZERO
#define RTN_FALSE_IF_TRUE(fExp) RTN_FALSE_IF_FALSE(!(fExp))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\directsound.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  DirectSound.h
//
//      This file defines the CDirectSound class that provides 
//      access to all DSound functionality used by the
//      multimedia control panel
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once


/////////////////////////////////////////////////////////////////////////////
// CDirectSound Class

class CMixerList
{
public:
    CMixerList (BOOL fRecord) { m_pList = NULL; m_fRecord = fRecord; }
    ~CMixerList () { FreeList (); }

    HRESULT Add (LPCWSTR lpcszDeviceName, LPGUID lpGuid);
    HRESULT GetGUIDFromName (LPTSTR lpszDeviceName, GUID& guid);
    HRESULT RefreshList ();
    void FreeList ();

private:
    struct MixDevice
    {
        GUID guid;
        CComBSTR bstrName;
        MixDevice* pNext;
    };
    MixDevice* m_pList;
    BOOL       m_fRecord;

};

// Forwards
interface IKsPropertySet;

class CDirectSound
{
public:
    CDirectSound ();

    HRESULT SetDevice (UINT uiMixID, BOOL fRecord);
    HRESULT SetDevice (LPTSTR lpszDeviceName, BOOL fRecord) 
        { return SetGuidFromName (lpszDeviceName, fRecord); }

    HRESULT GetSpeakerType (DWORD& dwSpeakerType);
    HRESULT SetSpeakerType (DWORD dwSpeakerType);
    HRESULT GetBasicAcceleration (DWORD& dwHWLevel);
    HRESULT SetBasicAcceleration (DWORD dwHWLevel);
    HRESULT GetSrcQuality (DWORD& dwSRCLevel);
    HRESULT SetSrcQuality (DWORD dwSRCLevel);

private:
    GUID       m_guid;
    BOOL       m_fRecord;

    CMixerList m_mlPlay;
    CMixerList m_mlRecord;

    HRESULT SetGuidFromName (LPTSTR lpszDeviceName, BOOL fRecord);
    CMixerList& GetList () { return (m_fRecord ? m_mlRecord : m_mlPlay); }

    HRESULT GetPrivatePropertySet (IKsPropertySet** ppIKsPropertySet);

    // Speaker Functions
    DWORD GetSpeakerConfigFromType (DWORD dwType);
    void VerifySpeakerConfig (DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mixers.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Mixers.h
//
//      This file defines the CMixers class that provides 
//      access to much of the mixerline functionality used
//      by the multimedia control panel.
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

//=============================================================================
//                            Include files
//=============================================================================
#include "resource.h"       // main symbols


// Constants
// Mixer Properties
const WCHAR kwszMixPropName      [] = L"Name";
const WCHAR kwszMixPropDestCount [] = L"Count";
// Destination Properties
const WCHAR kwszDestPropName     [] = L"Name";


/////////////////////////////////////////////////////////////////////////////
// CMixers
class ATL_NO_VTABLE CMixers : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMixers, &CLSID_Mixers>,
	public IDispatchImpl<IMixers, &IID_IMixers, &LIBID_MMSYSLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MIXERS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMixers)
	COM_INTERFACE_ENTRY(IMixers)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMixers
public:
	STDMETHOD(QueryDestinationProperty)(/*[in]*/ UINT uiMixID, /*[in]*/ UINT uiDestID, /*[in]*/ BSTR bstrProp, /*[out, retval]*/ VARIANT* pvarValue);
	STDMETHOD(QueryMixerProperty)(/*[in]*/ UINT uiMixID, /*[in]*/ BSTR bstrProp, /*[out, retval]*/ VARIANT* pvarValue);
	STDMETHOD(get_NumDevices)(/*[out, retval]*/ UINT* puiNumDevices);
	STDMETHOD(get_TaskBarVolumeIcon)(/*[out, retval]*/ BOOL* pfTaskBar);
	STDMETHOD(put_TaskBarVolumeIcon)(/*[in]*/ BOOL fTaskBar);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\hardware.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  Hardware.cpp
//
//      This file defines the CHardware class that provides 
//      the IHardware interface to give the multimedia control
//      panel the hardware information it needs.
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include "stdafx.h"
#include "Mmsys.h"
#include "Hardware.h"


/////////////////////////////////////////////////////////////////////////////
// CHardware


STDMETHODIMP CHardware::GetSpeakerType (UINT uiMixID, VARIANT* pvarType)
{

    HRESULT hr = E_INVALIDARG;
    if (VERIFYPTR (pvarType))
    {
        if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, FALSE)))
        {
            DWORD dwSpeakerType;
            if (SUCCEEDED (hr = m_DirectSound.GetSpeakerType (dwSpeakerType)))
            {
                V_VT (pvarType)  = VT_UI4;
                V_UI4 (pvarType) = dwSpeakerType;
            }
        }
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to get speaker type!");
    }
	return hr;

}

STDMETHODIMP CHardware::SetSpeakerType (UINT uiMixID, DWORD dwType)
{

    HRESULT hr = S_OK;
    if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, FALSE)))
    {
        hr = m_DirectSound.SetSpeakerType (dwType);
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to set speaker type!");
    }
	return hr;

}

STDMETHODIMP CHardware::GetAcceleration (UINT uiMixID, BOOL fRecord, VARIANT* pvarHWLevel)
{

    HRESULT hr = E_INVALIDARG;
    if (VERIFYPTR (pvarHWLevel))
    {
        if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, fRecord)))
        {
            DWORD dwHWLevel;
            if (SUCCEEDED (hr = m_DirectSound.GetBasicAcceleration (dwHWLevel)))
            {
                V_VT (pvarHWLevel)  = VT_UI4;
                V_UI4 (pvarHWLevel) = dwHWLevel;
            }
        }
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to get acceleration!");
    }
	return hr;

}

STDMETHODIMP CHardware::SetAcceleration (UINT uiMixID, BOOL fRecord, DWORD dwHWLevel)
{

    HRESULT hr = S_OK;
    if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, fRecord)))
    {
        hr = m_DirectSound.SetBasicAcceleration (dwHWLevel);
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to set acceleration!");
    }
	return hr;

}

STDMETHODIMP CHardware::GetSrcQuality (UINT uiMixID, BOOL fRecord, VARIANT* pvarSRCLevel)
{

    HRESULT hr = E_INVALIDARG;
    if (VERIFYPTR (pvarSRCLevel))
    {
        if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, fRecord)))
        {
            DWORD dwSRCLevel;
            if (SUCCEEDED (hr = m_DirectSound.GetSrcQuality (dwSRCLevel)))
            {
                V_VT (pvarSRCLevel)  = VT_UI4;
                V_UI4 (pvarSRCLevel) = dwSRCLevel;
            }
        }
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to get source quality!");
    }
	return hr;

}

STDMETHODIMP CHardware::SetSrcQuality (UINT uiMixID, BOOL fRecord, DWORD dwSRCLevel)
{

    HRESULT hr = S_OK;
    if (SUCCEEDED (hr = m_DirectSound.SetDevice (uiMixID, fRecord)))
    {
        hr = m_DirectSound.SetSrcQuality (dwSRCLevel);
    }

    // Assert if failed
    if (FAILED (hr))
    {
        assert2 (FALSE, L"Unable to set source quality!");
    }
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\directsound.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  DirectSound.cpp
//
//      This file defines the CDirectSound class that provides 
//      access to all DSound functionality used by the
//      multimedia control panel
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include "stdafx.h"
#include "DirectSound.h"
#include "MMUtil.h"
#include "SpeakerType.h"
#include <mmsystem.h>
#include <initguid.h>
#include <dsound.h>
#include <dsprv.h>

// Constants
#define NUMCONFIG (MAX_SPEAKER_TYPE + 1)
DWORD gdwSpeakerTable[NUMCONFIG] =
{ 
    DSSPEAKER_HEADPHONE,
    SPEAKERS_DEFAULT_CONFIG,
    DSSPEAKER_MONO,
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_QUAD,
    DSSPEAKER_SURROUND,
    DSSPEAKER_5POINT1 
};
#define MAX_HW_LEVEL			(3)
#define MAX_SRC_LEVEL			(2)
#define DEFAULT_HW_LEVEL		(2)
#define DEFAULT_SRC_LEVEL		(0)


/////////////////////////////////////////////////////////////////////////////
// CMixerList Class
BOOL CALLBACK DSEnumCallback (LPGUID lpGuid, LPCWSTR lpcstrDescription,  
                              LPCWSTR lpcstrModule, LPVOID lpContext)
{
    if (VERIFYPTR (lpcstrDescription) && 
        VERIFYPTR (lpGuid) && GUID_NULL != *lpGuid)
    {
        RTN_FALSE_IF_BADPTR (lpContext);
        RTN_FALSE_IF_FAILED (((CMixerList*) lpContext) -> Add (lpcstrDescription, lpGuid));
    }
    return TRUE;
}

HRESULT CMixerList::GetGUIDFromName (LPTSTR lpszDeviceName, GUID& guid)
{

    // Init Params
    guid = GUID_NULL;
    RTN_HR_IF_BADPTR (lpszDeviceName);

    // See if this device is in the list
    MixDevice* pSeek = m_pList;
    while (VERIFYPTR (pSeek))
    {
        if (0 == _wcsicmp (pSeek -> bstrName, lpszDeviceName))
        {
            guid = pSeek -> guid;
            return S_OK; // Found it!
        }
        pSeek = pSeek -> pNext;
    }

    return S_FALSE; // Not found.

}

HRESULT CMixerList::Add (LPCWSTR lpcszDeviceName, LPGUID lpGuid)
{

    // Check Params
    RTN_HR_IF_BADPTR (lpcszDeviceName);
    RTN_HR_IF_BADPTR (lpGuid);

    // Create a new list element
    MixDevice* pNew = new MixDevice;
    RTN_HR_IF_BADNEW (pNew);

    // Copy the values
    pNew -> guid     = *lpGuid;
    pNew -> bstrName = lpcszDeviceName;
    pNew -> pNext    = NULL;

    // Add to list
    if (BADPTR (m_pList))
        m_pList = pNew;
    else
        m_pList -> pNext = pNew;

    return S_OK;

}

void CMixerList::FreeList ()
{ 
    MixDevice* pDelete = NULL;
    while (VERIFYPTR (m_pList))
    {
        pDelete = m_pList;
        m_pList = m_pList -> pNext;
        delete pDelete;
    }
}

HRESULT CMixerList::RefreshList ()
{

    // Free the list
    FreeList ();

    // Recreate it
    if (m_fRecord)
    {
        RTN_HR_IF_FAILED (DirectSoundCaptureEnumerate (&DSEnumCallback, this));
    }
    else
    {
        RTN_HR_IF_FAILED (DirectSoundEnumerate (&DSEnumCallback, this));
    }

    return S_OK;

}


/////////////////////////////////////////////////////////////////////////////
// CDirectSound Class
CDirectSound::CDirectSound () : m_mlPlay (FALSE),
                                m_mlRecord (TRUE)
{ 
    m_guid    = GUID_NULL; 
    m_fRecord = FALSE; 
}

HRESULT CDirectSound::SetDevice (UINT uiMixID, BOOL fRecord)
{

    // Get the name for this mixer device
    MIXERCAPS mc;
    ZeroMemory (&mc, sizeof (MIXERCAPS));
    RTN_HR_IF_FAILED (mixerGetDevCaps (uiMixID, &mc, sizeof (MIXERCAPS)));
    RTN_HR_IF_BADPTR (mc.szPname);

    // Set the device using the mixer name
    RTN_HR_IF_FAILED (SetGuidFromName (mc.szPname, fRecord));

    return S_OK;

}


HRESULT CDirectSound::SetGuidFromName (LPTSTR lpszDeviceName, BOOL fRecord)
{

    // Init members
    m_guid    = GUID_NULL;
    m_fRecord = fRecord;
    
    // See if we have this device in the list
    RTN_HR_IF_FAILED (GetList ().GetGUIDFromName (lpszDeviceName, m_guid));

    if (GUID_NULL == m_guid)
    {
        // No device in the list, the list may not be created yet,
        // or this device may be newly added
        RTN_HR_IF_FAILED (GetList ().RefreshList ());
        RTN_HR_IF_FAILED (GetList ().GetGUIDFromName (lpszDeviceName, m_guid));
    }

    return (GUID_NULL == m_guid ? E_FAIL : S_OK);

}

HRESULT CDirectSound::GetPrivatePropertySet (IKsPropertySet** ppIKsPropertySet)
{

    // Init Param
    RTN_HR_IF_BADPTR (ppIKsPropertySet);
    *ppIKsPropertySet= NULL;

    RTN_HR_IF_FAILED (PrivateDllCoCreateInstance (L"dsound.dll",
                      CLSID_DirectSoundPrivate, NULL,
                      IID_IKsPropertySet, (void**) ppIKsPropertySet));
    RTN_HR_IF_BADPTR (*ppIKsPropertySet);

    return S_OK;

}

HRESULT CDirectSound::GetSpeakerType (DWORD& dwSpeakerType)
{

    // Init Params
    dwSpeakerType   = 0;

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);
    RTN_HR_IF_TRUE (TRUE == m_fRecord);

    // Get the needed interfaces
    CComPtr <IDirectSound> pIDirectSound;
    RTN_HR_IF_FAILED (DirectSoundCreate (&m_guid, &pIDirectSound, NULL));
    RTN_HR_IF_BADPTR (pIDirectSound);
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Get the speaker type.  This property will return failure
    // if the registry value doesn't exist.
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerType;
    SpeakerType.DeviceId         = m_guid;
    SpeakerType.SubKeyName       = REG_KEY_SPEAKERTYPE;
    SpeakerType.ValueName        = REG_KEY_SPEAKERTYPE;
    SpeakerType.RegistryDataType = REG_DWORD;
    SpeakerType.Data             = &dwSpeakerType;
    SpeakerType.DataSize         = sizeof (dwSpeakerType);

    HRESULT hr = pIKsPropertySet -> Get (
                    DSPROPSETID_DirectSoundPersistentData, 
                    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                    NULL, 0, &SpeakerType, sizeof (SpeakerType), NULL);
    if (DS_OK != hr)
        dwSpeakerType = SPEAKERS_DEFAULT_TYPE;

    // Get Speaker Config & Verify
    DWORD dwSpeakerConfig;
    RTN_HR_IF_FAILED (pIDirectSound -> GetSpeakerConfig (&dwSpeakerConfig));
    VerifySpeakerConfig (dwSpeakerConfig, &dwSpeakerType);

    return S_OK;

}

HRESULT CDirectSound::SetSpeakerType (DWORD dwSpeakerType)
{

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);
    RTN_HR_IF_TRUE (TRUE == m_fRecord);

    // Get the needed interfaces
    CComPtr <IDirectSound> pIDirectSound;
    RTN_HR_IF_FAILED (DirectSoundCreate (&m_guid, &pIDirectSound, NULL));
    RTN_HR_IF_BADPTR (pIDirectSound);
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Set the speaker type
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerType;
    SpeakerType.DeviceId         = m_guid;
    SpeakerType.SubKeyName       = REG_KEY_SPEAKERTYPE;
    SpeakerType.ValueName        = REG_KEY_SPEAKERTYPE;
    SpeakerType.RegistryDataType = REG_DWORD;
    SpeakerType.Data             = &dwSpeakerType;
    SpeakerType.DataSize         = sizeof (dwSpeakerType);

    RTN_HR_IF_FAILED (pIKsPropertySet-> Set (
                         DSPROPSETID_DirectSoundPersistentData, 
                         DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                         NULL, 0, &SpeakerType, sizeof (SpeakerType)));

    // Set Speaker Config from type
    DWORD dwSpeakerConfig = GetSpeakerConfigFromType (dwSpeakerType);
    RTN_HR_IF_FAILED (pIDirectSound -> SetSpeakerConfig (dwSpeakerConfig));

    return S_OK;

}

HRESULT CDirectSound::GetBasicAcceleration (DWORD& dwHWLevel)
{

    // Init Param
    dwHWLevel = 0;

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);

    // Get the needed interface
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Get the basic HW acceleration level.  This property will return
    // S_FALSE if no error occurred, but the registry value did not exist.
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    BasicAcceleration.DeviceId = m_guid;
        
    HRESULT hr = pIKsPropertySet -> Get (
                    DSPROPSETID_DirectSoundBasicAcceleration, 
                    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, NULL, 
                    0, &BasicAcceleration, sizeof (BasicAcceleration), NULL);
    if(DS_OK == hr)
        dwHWLevel = BasicAcceleration.Level;
    else
        dwHWLevel = DEFAULT_HW_LEVEL;

    return S_OK;

}

HRESULT CDirectSound::SetBasicAcceleration (DWORD dwHWLevel)
{

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);

    // Get the needed interface
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Set the basic acceleration level
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    BasicAcceleration.DeviceId = m_guid;
    BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL) dwHWLevel;

    RTN_HR_IF_FAILED (pIKsPropertySet -> Set ( 
                         DSPROPSETID_DirectSoundBasicAcceleration, 
                         DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
                         NULL, 0, &BasicAcceleration, sizeof (BasicAcceleration)));

    return S_OK;

}

HRESULT CDirectSound::GetSrcQuality (DWORD& dwSRCLevel)
{

    // Init Param
    dwSRCLevel = 0;

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);

    // Get the needed interface
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Get the mixer SRC quality.  This property will return S_FALSE 
    // if no error occurred, but the registry value did not exist.
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    SrcQuality.DeviceId = m_guid;
        
    HRESULT hr = pIKsPropertySet -> Get (
                    DSPROPSETID_DirectSoundMixer, 
                    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                    NULL, 0, &SrcQuality, sizeof (SrcQuality), NULL);

    if (DS_OK == hr)
    {
        // The CPL only uses the 3 highest of 4 possible SRC values
        dwSRCLevel = SrcQuality.Quality;
        if(dwSRCLevel > 0)
            dwSRCLevel--;
    }
    else
    {
        dwSRCLevel = DEFAULT_SRC_LEVEL;
    }

    return S_OK;

}

HRESULT CDirectSound::SetSrcQuality (DWORD dwSRCLevel)
{

    // Make sure SetDevice() succeeded.
    RTN_HR_IF_TRUE (GUID_NULL == m_guid);

    // Get the needed interface
    CComPtr <IKsPropertySet> pIKsPropertySet;
    RTN_HR_IF_FAILED (GetPrivatePropertySet (&pIKsPropertySet));
    RTN_HR_IF_BADPTR (pIKsPropertySet);

    // Set the source Quality
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    SrcQuality.DeviceId = m_guid;

    // The CPL only uses the 3 highest of 4 possible SRC values
    SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)(dwSRCLevel + 1);
        
    RTN_HR_IF_FAILED (pIKsPropertySet -> Set ( 
                         DSPROPSETID_DirectSoundMixer, 
                         DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                         NULL, 0, &SrcQuality, sizeof (SrcQuality)));

    return S_OK;

}

// 
// Verifies that the speakers type and config match, if not, change type to match config using default type
//
void CDirectSound::VerifySpeakerConfig (DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType)
{
    if (pdwSpeakerType)
    {
        DWORD dwType = *pdwSpeakerType;

        if (gdwSpeakerTable[dwType] != dwSpeakerConfig)     // the type doesn't match the config, pick a default type
        {
            switch (dwSpeakerConfig)
            {
                case DSSPEAKER_HEADPHONE:
                    *pdwSpeakerType = TYPE_HEADPHONES;
                break;

                case DSSPEAKER_MONO:
                    *pdwSpeakerType = TYPE_MONOLAPTOP;
                break;

                case DSSPEAKER_STEREO:
                    *pdwSpeakerType = TYPE_STEREODESKTOP;
                break;

                case DSSPEAKER_QUAD:
                    *pdwSpeakerType = TYPE_QUADRAPHONIC;
                break;

                case DSSPEAKER_SURROUND:
                    *pdwSpeakerType = TYPE_SURROUND;
                break;

                case DSSPEAKER_5POINT1:
                    *pdwSpeakerType = TYPE_SURROUND_5_1;
                break;

                default:
                {
                    if (DSSPEAKER_CONFIG(dwSpeakerConfig) == DSSPEAKER_STEREO)
                    {
                        DWORD dwAngle = DSSPEAKER_GEOMETRY(dwSpeakerConfig);
                        DWORD dwMiddle = DSSPEAKER_GEOMETRY_NARROW + 
                                        ((DSSPEAKER_GEOMETRY_WIDE - DSSPEAKER_GEOMETRY_NARROW) >> 1);
                        if (dwAngle <= dwMiddle)
                        {
                            *pdwSpeakerType = TYPE_STEREOCPU;        
                        }
                        else
                        {
                            *pdwSpeakerType = TYPE_STEREODESKTOP;        
                        }
                    }
                }

                break;
            }
        }
    }
}

//
// Given a speaker type, returns the DirectSound config for it
//
DWORD CDirectSound::GetSpeakerConfigFromType (DWORD dwType)
{
    DWORD dwConfig = SPEAKERS_DEFAULT_CONFIG;

    if (dwType < (DWORD) NUMCONFIG)
    {
        dwConfig = gdwSpeakerTable[dwType];     
    }

    return (dwConfig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mmutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  MMUtil.h
//
//      This file defines utilities used by the
//      multimedia control panel
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include "stdafx.h"

// Include Debug source here too
#define MAXSTRINGLEN       256 // Maximum output string length
#define _INC_MMDEBUG_CODE_ TRUE
#include "mmdebug.h"

/////////////////////////////////////////////////////////////////////////////
// Multimedia Control Panel Utilities

typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

HRESULT PrivateDllCoCreateInstance (LPCTSTR lpszDllName, // Dll Name
                                    REFCLSID rclsid,     //Class identifier (CLSID) of the object
                                    LPUNKNOWN pUnkOuter, //Pointer to controlling IUnknown
                                    REFIID riid,         //Reference to the identifier of the interface
                                    LPVOID * ppv)        // the interface pointer requested in riid
{

    // Get the library
    HINSTANCE hinstLib = /*LoadLibrary*/ GetModuleHandle (lpszDllName);
    if (!hinstLib)
        return E_FAIL;

    // Find DllGetClassObject
    LPFNDLLGETCLASSOBJECT pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
                          GetProcAddress (hinstLib, "DllGetClassObject");
    if (!pfnDllGetClassObject)
        return E_FAIL;

    // Create a class factory object    
    CComPtr <IClassFactory> pIClassFactory;
    HRESULT hr = pfnDllGetClassObject (rclsid, IID_IClassFactory, 
                                      (void**)&pIClassFactory);
    if (FAILED (hr) || !pIClassFactory)
        return hr;

    // Get the requested interface
    hr = pIClassFactory -> CreateInstance (pUnkOuter, riid, ppv);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) TEXT(#num)
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ----")
    #define DEBUGLINE TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ")

    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") TEXT(#exp) TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

      #define STATICFN

    #else // defined(DEBUG)

      #define AuxDebugEx  1 ? (void)0 :
      #define AuxDebugDump(a,b,c)

      #define assert(a)          ((void)0)
      #define assert2(a,b)       ((void)0)
      #define assert3(a,b,c)     ((void)0)
      #define assert4(a,b,c,d)   ((void)0)
      #define assert5(a,b,c,d,e) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
      #define STATICFN static

   #endif // defined(DEBUG)

   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"))
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"), (a))

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE

    #include <stdarg.h>

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    mmdebug_OutputLevel = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/

    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
       TCHAR     szBuf[1024];
       int      cb;
       va_list  va;
       TCHAR   * psz;

       if (mmdebug_OutputLevel >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintf (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == TEXT('.') && psz[1] == TEXT('.') && psz[2] == TEXT('\\'))
             psz += 3;

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (psz);
          }

       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/

    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       TCHAR     szBuf[128];
       LPTSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];

       if (mmdebug_OutputLevel <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, TEXT("\t%08X: "), lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = TEXT('.');
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, TEXT(".. "));
             else
                {
                wsprintf (psz, TEXT("%02X "), lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, TEXT("\r\n"));

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/

    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {
        int nOldLevel = mmdebug_OutputLevel;
        mmdebug_OutputLevel = nLevel;
        return nOldLevel;
        }

    void FAR cdecl dprintf(LPSTR szFormat, ...)
    {
        TCHAR ach[MAXSTRINGLEN];
        TCHAR szUniFormat[MAXSTRINGLEN];
        
        int  s,d;
        va_list arg;

        MultiByteToWideChar(GetACP(), 0,
                        szFormat, -1,
                        szUniFormat, sizeof(szUniFormat)/sizeof(TCHAR));

        va_start (arg, szUniFormat);

        s = wvsprintf (ach,szUniFormat,arg);
        va_end(arg);

        for (d=sizeof(ach)-1; s>=0; s--)
        {
            if ((ach[d--] = ach[s]) == TEXT('\n'))
                ach[d--] = TEXT('\r');
        }

       va_end(arg);

        OutputDebugStr(TEXT("MMSYS.CPL: "));
        OutputDebugStr(ach+d+1);
    }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\preferreddevices.cpp ===
// PreferredDevices.cpp : Implementation of CPreferredDevices
#include "stdafx.h"
#include "Mmsys.h"
#include "PreferredDevices.h"

/////////////////////////////////////////////////////////////////////////////
// CPreferredDevices


STDMETHODIMP CPreferredDevices::get_PreferredOnly(BOOL *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CPreferredDevices::put_PreferredOnly(BOOL newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\preferreddevices.h ===
// PreferredDevices.h : Declaration of the CPreferredDevices

#ifndef __PREFERREDDEVICES_H_
#define __PREFERREDDEVICES_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPreferredDevices
class ATL_NO_VTABLE CPreferredDevices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPreferredDevices, &CLSID_PreferredDevices>,
	public IDispatchImpl<IPreferredDevices, &IID_IPreferredDevices, &LIBID_MMSYSLib>
{
public:
	CPreferredDevices()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PREFERREDDEVICES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPreferredDevices)
	COM_INTERFACE_ENTRY(IPreferredDevices)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPreferredDevices
public:
	STDMETHOD(get_PreferredOnly)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PreferredOnly)(/*[in]*/ BOOL newVal);
};

#endif //__PREFERREDDEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmsys.rc
//
#define IDS_PROJNAME                    100
#define IDR_MIXERS                      101
#define IDR_SCHEMES                     102
#define IDR_PREFERREDDEVICES            103
#define IDR_HARDWARE                    104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mmutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  MMUtil.h
//
//      This file defines utilities used by the
//      multimedia control panel
//
//  History:
//      23 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once


/////////////////////////////////////////////////////////////////////////////
// Multimedia Control Panel Utilities

HRESULT PrivateDllCoCreateInstance (LPCTSTR lpszDllName, // Dll Name
                                    REFCLSID rclsid,     //Class identifier (CLSID) of the object
                                    LPUNKNOWN pUnkOuter, //Pointer to controlling IUnknown
                                    REFIID riid,         //Reference to the identifier of the interface
                                    LPVOID * ppv);       // the interface pointer requested in riid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\mmsys.cpp ===
// mmsys.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mmsysps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "mmsys.h"

#include "mmsys_i.c"
#include "Mixers.h"
#include "Schemes.h"
#include "PreferredDevices.h"
#include "Hardware.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Mixers, CMixers)
OBJECT_ENTRY(CLSID_Schemes, CSchemes)
OBJECT_ENTRY(CLSID_PreferredDevices, CPreferredDevices)
OBJECT_ENTRY(CLSID_Hardware, CHardware)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MMSYSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\schemes.cpp ===
// Schemes.cpp : Implementation of CSchemes
#include "stdafx.h"
#include "Mmsys.h"
#include "Schemes.h"

/////////////////////////////////////////////////////////////////////////////
// CSchemes


STDMETHODIMP CSchemes::get_Default (BSTR* pbstrDefault)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSchemes::put_Default (BSTR bstrDefault)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSchemes::get_NumSchemes (UINT* puiSchemes)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSchemes::SaveScheme (BSTR bstrOldScheme, BOOL fReplace, BSTR bstrNewScheme)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSchemes::DeleteScheme (BSTR bstrDeleteScheme)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CSchemes::GetSchemeName (UINT uiSchemeID, VARIANT* pvarSchemeName)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\speakertype.h ===
//--------------------------------------------------------------------------;
//
//  File: speakers.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;
#pragma once

// Registry Key
#define REG_KEY_SPEAKERTYPE _T("Speaker Type")

// Values
#define TYPE_HEADPHONES        0
#define TYPE_STEREODESKTOP     1
#define TYPE_MONOLAPTOP        2
#define TYPE_STEREOLAPTOP      3
#define TYPE_STEREOMONITOR     4
#define TYPE_STEREOCPU         5
#define TYPE_MOUNTEDSTEREO     6
#define TYPE_STEREOKEYBOARD    7
#define TYPE_QUADRAPHONIC      8
#define TYPE_SURROUND          9
#define TYPE_SURROUND_5_1      10
#define MAX_SPEAKER_TYPE       TYPE_SURROUND_5_1


#define SPEAKERS_DEFAULT_CONFIG      DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE)
#define SPEAKERS_DEFAULT_TYPE        TYPE_STEREODESKTOP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__71ED05D2_52A9_49AD_9907_8CBAFD6453FC__INCLUDED_)
#define AFX_STDAFX_H__71ED05D2_52A9_49AD_9907_8CBAFD6453FC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "mmdebug.h"
#include "SharedConst.h"
#include "Barf.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__71ED05D2_52A9_49AD_9907_8CBAFD6453FC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\sharedconst.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  SharedConst.h
//
//      This file defines SHARED_CONST
//
//  History:
//      25 February 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

#ifndef SHARED_CONST
#define SHARED_CONST extern const _declspec(selectany)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\multimed\multimed.h ===
/****************************************************************************
 *
 *   File : multimed.h
 *
 *   Description :
 *        Top level control panel applet structures for multimedia for
 *        Windows NT
 *
 *   Copyright (c) 1993  Microsoft Corporation
 *
 *****************************************************************************/

/*
 *  Resource id for applet icons
 */

 #define ID_ICON         3004

/*
 *  String resource id for name and applet info
 */

 #define IDS_NAME         3001
 #define IDS_INFO         3002
 #define IDS_CONTROL_HLP  3003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys_5.1\src\schemes.h ===
// Schemes.h : Declaration of the CSchemes

#ifndef __SCHEMES_H_
#define __SCHEMES_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSchemes
class ATL_NO_VTABLE CSchemes : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSchemes, &CLSID_Schemes>,
	public IDispatchImpl<ISchemes, &IID_ISchemes, &LIBID_MMSYSLib>
{
public:
	CSchemes()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SCHEMES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSchemes)
	COM_INTERFACE_ENTRY(ISchemes)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISchemes
public:
	STDMETHOD(get_Default)(/*[out, retval]*/ BSTR* pbstrDefault);
	STDMETHOD(put_Default)(/*[in]*/ BSTR bstrDefault);
	STDMETHOD(get_NumSchemes)(/*[out, retval]*/ UINT* puiSchemes);
	STDMETHOD(SaveScheme)(/*[in]*/ BSTR bstrOldScheme, /*[in]*/ BOOL fReplace, /*[in]*/ BSTR bstrNewScheme);
	STDMETHOD(DeleteScheme)(/*[in]*/ BSTR bstrDeleteScheme);
	STDMETHOD(GetSchemeName)(/*[in]*/ UINT uiSchemeID, /*[out, retval]*/ VARIANT* pvarSchemeName);
};

#endif //__SCHEMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\multimed\multimed.c ===
/****************************************************************************
 *
 *   File : multimed.c
 *
 *   Description :
 *        Top level control panel applet code for multimedia for
 *        Windows NT
 *
 *   Copyright (c) 1993  Microsoft Corporation
 *
 *****************************************************************************/

/*****************************************************************************

    Design

    This module contains the code and data (apart from the icons for
    the 3 applets) to support 3 control panel applets for multi-media :

    sound   - Setting system sounds

    midimap - Midi mapper

    drivers - Installation and configuration of installable drivers through
              installable drivers interface

    The interface in is as for all control panel applets.  This (super)
    applet returns a number of internal applets to the CPL_GETCOUNT
    message depending on :

    waveOutGetNumDevs returns non-zero - then sound is supported.

    midiOutGetNumDevs returns non-zero or midiInGetNumDevs returns
    non-zero - then midimap is supported.

    Interface to sub-applets.  For packaging and historical reasons the
    other applets are separate files :

    sound - sound.dll
    midimap - midimap.dll  - is also a midi driver
    drivers - drivers.dll

    When an applet (which is supported for the current configuration of
    the system as determined above) is run (and ONLY THEN) via the
    CPL_DBLCLK message we call LoadLibrary for the (sub) applet and
    call its entry point (usually a 'cut-down' CplApplet).

    To do this each sub-applet's icon and string have fixed ids defined in
    multimed.h.

*****************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <cpl.h>
#include <cphelp.h>
#include "multimed.h"

   // This applet has been neutered to provide only MIDIMAP.DLL's CPL
   // interface; the others are now supported by MMSYS.CPL.
   //
// #define EXTRA_APPLETS
#ifdef EXTRA_APPLETS
 enum {
    SoundsApplet = 0,
    DriversApplet,
    MidiMapApplet,
    ACMApplet,
    NumberOfApplets
 };

 struct {
    LPCTSTR     AppletFileName;
    DWORD       dwHelpContext;
    HINSTANCE   ActiveHandle;
    APPLET_PROC AppletEntryPoint;
    BOOL        AppInUse;
    NEWCPLINFO  CplInfo;
 }
 AppletInfo[] = { { TEXT("sound.dll"), IDH_CHILD_SND },
                  { TEXT("drivers.dll"), IDH_CHILD_DRIVERS },
                  { TEXT("midimap.dll"), IDH_CHILD_MIDI },
                  { TEXT("msacm32.drv"), 0 } };  // No context for ACM
#else
 enum {
    MidiMapApplet = 0,
    NumberOfApplets
 };

 struct {
    LPCTSTR     AppletFileName;
    DWORD       dwHelpContext;
    HINSTANCE   ActiveHandle;
    APPLET_PROC AppletEntryPoint;
    BOOL        AppInUse;
    NEWCPLINFO  CplInfo;
 }
 AppletInfo[] = { { TEXT("midimap.dll"), IDH_CHILD_MIDI } };
#endif


 int IdMapping[NumberOfApplets];
 int TotalApplets;

 BOOL LoadDataPart(int AppletIndex)
 {
     UINT          OldErrorMode;
     LPNEWCPLINFO  lpCplInfo;
     HINSTANCE     DataOnlyHandle;

     OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

     DataOnlyHandle =
         LoadLibraryEx(AppletInfo[AppletIndex].AppletFileName,
                       NULL,
                       DONT_RESOLVE_DLL_REFERENCES);

     SetErrorMode(OldErrorMode);

     if (DataOnlyHandle == NULL) {
         return FALSE;
     }

    /*
     *  Cache all Cpl data now so we're not embarrassed by errors later
     */

     lpCplInfo = &AppletInfo[AppletIndex].CplInfo;

     lpCplInfo->dwSize = sizeof(NEWCPLINFO);
     lpCplInfo->lData = 0; // Applets we use expect this
     lpCplInfo->dwHelpContext = AppletInfo[AppletIndex].dwHelpContext;
     lpCplInfo->hIcon =
         LoadIcon(DataOnlyHandle,
                  MAKEINTRESOURCE(ID_ICON));

     if (lpCplInfo->hIcon == NULL ||
         !LoadString(DataOnlyHandle,
                     IDS_NAME,
                     lpCplInfo->szName,
                     sizeof(lpCplInfo->szName)) ||
         !LoadString(DataOnlyHandle,
                     IDS_INFO,
                     lpCplInfo->szInfo,
                     sizeof(lpCplInfo->szInfo)) ||
         !LoadString(DataOnlyHandle,
                     IDS_CONTROL_HLP,
                     lpCplInfo->szHelpFile,
                     sizeof(lpCplInfo->szHelpFile))) {

         FreeLibrary(DataOnlyHandle);
         return FALSE;
     }

     FreeLibrary(DataOnlyHandle);
     return TRUE;
 }

 LONG CPlApplet(HWND hCplWnd, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
 {
    LONG ReturnCode = 0L;    // The default apparently
    int                i;

    switch (uMsg) {
    case CPL_INIT:

      /*
       *  I've no idea why this is a better place to initialize than
       *  CPL_GETCOUNT but why not?
       *
       */

      /*
       *   Check there's somebody home
       */

       for (i = 0; i < NumberOfApplets; i++) {

           /*
           **  Don't put up useless junk!
           */

           if (i == MidiMapApplet && midiOutGetNumDevs() == 0
#ifdef EXTRA_APPLETS
            || i == ACMApplet && waveOutGetNumDevs() == 0
#endif
              )
           {
               continue;
           }

           if (LoadDataPart(i)) {
               IdMapping[TotalApplets++] = i;
           }
       }

      /*
       *  Only succeed if we support something
       */

       ReturnCode = TotalApplets != 0;

       break;

    case CPL_GETCOUNT:
       return TotalApplets;
       break;

    case CPL_NEWINQUIRE:
        {
            LPNEWCPLINFO lpCplInfo;
            int iApplet;

            iApplet = IdMapping[lParam1];

            lpCplInfo = (LPNEWCPLINFO)lParam2;

            *lpCplInfo = AppletInfo[iApplet].CplInfo;
        }

        break;

    case CPL_DBLCLK:

       /*
        *  The job here is to
        *  1. If the applet is not already loaded
        *     -- load it
        *     -- Pass it a cpl_init message - this will do for our applets(!)
        *
        *  2. Pass it a CPL_DBLCLK message with the parameters we got
        *
        */
        {
            int iApplet;

            iApplet = IdMapping[lParam1];


            if (AppletInfo[iApplet].ActiveHandle == NULL) {

                UINT OldErrorMode;

                OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                AppletInfo[iApplet].ActiveHandle =
                    LoadLibrary(AppletInfo[iApplet].AppletFileName);

                SetErrorMode(OldErrorMode);

                if (AppletInfo[iApplet].ActiveHandle != NULL) {
                    AppletInfo[iApplet].AppletEntryPoint =
                        (APPLET_PROC)GetProcAddress(
                            AppletInfo[iApplet].ActiveHandle,
                            "CPlApplet");
                }
                if (AppletInfo[iApplet].AppletEntryPoint != NULL) {
                    (*AppletInfo[iApplet].AppletEntryPoint)
                        (hCplWnd, CPL_INIT, 0, 0);
                }
            }

            if (AppletInfo[iApplet].AppletEntryPoint != NULL) {
                (*AppletInfo[iApplet].AppletEntryPoint)
                    (hCplWnd, uMsg, lParam1, lParam2);
            }
        }

        break;

    case CPL_EXIT:

       /*
        *  Unload all our friends
        */


        {
            int i;
            for (i = 0; i < NumberOfApplets; i++) {

                if (AppletInfo[i].ActiveHandle != NULL) {
                    if (AppletInfo[i].AppletEntryPoint != NULL) {
                        (*AppletInfo[i].AppletEntryPoint)
                            (hCplWnd, CPL_EXIT, 0, 0);
                    }
                    FreeLibrary(AppletInfo[i].ActiveHandle);
                }
            }
        }


        break;

    }

    return ReturnCode;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\profile\profile.h ===
//*************************************************************
//  File name:    PROFILE.H
//
//  Description:  Header file for profile control panel applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1994
//  All rights reserved
//
//*************************************************************

//
// Misc. constants
//

#define NUM_APPLETS 1
#define MAX_DOMAIN_NAME             128
#define MAX_USER_NAME               128
#define MAX_COMPUTER_NAME           128
#define MAX_TEMP_BUFFER            (128 + MAX_DOMAIN_NAME + MAX_USER_NAME)
#define MAX_NUM_COMPUTERS           256
#define PROFILE_NAME_LEN             30
#define MAX_ERROR_MSG               350
#define NAMES_HELP_CONTEXT            1
#define UNKNOWN_LEN                  30

#define LOCAL_PROFILE_TYPE          TEXT('0')
#define PERSONAL_PROFILE_TYPE       TEXT('1')
#define MANDITORY_PROFILE_TYPE      TEXT('2')


//
// Icon ID
//

#define ID_ICON 1

//
// String table constants
//

#define IDS_NAME                      1
#define IDS_INFO                      2
#define IDS_UNABLETOSAVE              3
#define IDS_BASEERRORMSG              4
#define IDS_NAMEINDONTLIST            5
#define IDS_NONAMEANDDONOTSAVE        6
#define IDS_LOGOFFNOTICE              7
#define IDS_DUPLICATENAME             8
#define IDS_ADDNAME                   9
#define IDS_UNKNOWN                  10
#define IDS_FORMAT                   11

//
// Dialog box constants
//
#define IDD_PROFILE                 100
#define IDD_USERNAME                101
#define IDD_PATH                    102
#define IDD_DONTSAVECHANGE          103
#define IDD_SAVELIST                104
#define IDD_DEFAULTSAVE             105
#define IDD_DEFAULTDONTSAVE         106
#define IDD_HELP                    107
#define IDD_SAVECHANGE              108
#define IDD_DONTSAVELIST            109
#define IDD_COMPUTERNAME            110

#define IDD_COMPUTERNAMES           200
#define IDD_DELETE                  201
#define IDD_CLEARALL                202
#define IDD_NAMESHELP               203
#define IDD_NAMESLIST               204
#define IDD_NEWNAME                 205
#define IDD_ADD                     206

//
// Global Variables
//

extern HINSTANCE hInstance;
extern LPTSTR    glpList;
extern TCHAR     szProfileRegInfo[];
extern TCHAR     szProfileType[];
extern UINT      uiShellHelp;
extern TCHAR     szShellHelp[];
extern TCHAR     szHelpFileName[];


//
// Function prototypes
//

void   RunApplet(HWND);
BOOL   InitializeDialog (HWND);
void   ParseAndAddComputerNames(HWND, WORD, LPTSTR);
LPTSTR CreateList (HWND, WORD, LPTSTR, LPBOOL);
BOOL   SaveSettings (HWND);
BOOL   CompareLists (HWND, WORD, WORD);
BOOL   CheckProfileType (void);
void   SetDefButton(HWND, INT);

INT_PTR CALLBACK ProfileDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK NamesDlgProc(HWND, UINT, WPARAM, LPARAM);


//
// Macros
//

#if DBG

#define KdPrint(_x_) \
         OutputDebugStringA ("PROFILE:  "); \
         OutputDebugStringA _x_; \
         OutputDebugStringA ("\r\n");

#else

#define KdPrint(_x_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\profile\init.c ===
//*************************************************************
//  File name:    INIT.C
//
//  Description:  Initialization code for Profile control panel
//                applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1994
//  All rights reserved
//
//*************************************************************
#include <windows.h>
#include <cpl.h>
#include "profile.h"


//*************************************************************
//
//  DllInitialize()
//
//  Purpose:    Main entry point
//
//
//  Parameters: HINSTANCE hInstDLL    - Instance handle of DLL
//              DWORD     dwReason    - Reason DLL was called
//              LPVOID    lpvReserved - NULL
//      
//
//  Return:     BOOL
//
//*************************************************************

BOOL DllInitialize(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    hInstance = hInstDLL;

    DisableThreadLibraryCalls(hInstDLL);

    return TRUE;
}


//*************************************************************
//
//  CPlApplet()
//
//  Purpose:    Control Panel entry point
//
//
//  Parameters: HWND hwnd      - Window handle
//              WORD wMsg      - Control Panel message
//              LPARAM lParam1 - Long parameter
//              LPARAM lParam2 - Long parameter
//
//
//  Return:     LONG
//
//*************************************************************

LONG CPlApplet( HWND hwnd, WORD wMsg, LPARAM lParam1, LPARAM lParam2)
{

    LPNEWCPLINFO lpNewCplInfo;
    LPCPLINFO lpCplInfo;

    switch (wMsg) {

        case CPL_INIT:
            if (CheckProfileType()) {
                uiShellHelp = RegisterWindowMessage (szShellHelp);
                return TRUE;

            } else {
                return FALSE;
            }
            break;

        case CPL_GETCOUNT:
            return (LONG)NUM_APPLETS;

        case CPL_INQUIRE:

            lpCplInfo = (LPCPLINFO)lParam2;

            lpCplInfo->idIcon = ID_ICON;
            lpCplInfo->idName = IDS_NAME;
            lpCplInfo->idInfo = IDS_INFO;
            lpCplInfo->lData  = 0L;

            return (LONG)TRUE;

        case CPL_NEWINQUIRE:

            lpNewCplInfo = (LPNEWCPLINFO)lParam2;

            lpNewCplInfo->hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(ID_ICON));

            if (!LoadString( hInstance, IDS_NAME, lpNewCplInfo->szName,
                            sizeof(lpNewCplInfo->szName))) {
               lpNewCplInfo->szName[0] = TEXT('\0');
            }

            if(!LoadString( hInstance, IDS_INFO, lpNewCplInfo->szInfo,
                            sizeof(lpNewCplInfo->szInfo))) {
               lpNewCplInfo->szInfo[0] = TEXT('\0');
            }

            lpNewCplInfo->dwSize = sizeof(NEWCPLINFO);
            lpNewCplInfo->dwHelpContext = HELP_CONTEXT;
            if(!LoadString( hInstance, IDS_INFO, lpNewCplInfo->szHelpFile,
                            sizeof(lpNewCplInfo->szHelpFile))) {
               lpNewCplInfo->szHelpFile[0] = TEXT('\0');
            }

            return (LONG)TRUE;

        case CPL_DBLCLK:
            RunApplet(hwnd);
            break;
    }
    return (LONG)0;

}

//*************************************************************
//
//  CheckProfileType()
//
//  Purpose:    Checks to see if this user has a floating
//              personal profile.   This is done by looking
//              in the registry for the "ProfileType" entry.
//
//              0 = local non-floating profile
//              1 = personal floating (.usr) profile
//              2 = manditory profile
//
//  Parameters: void
//      
//
//  Return:     BOOL - TRUE if this applet should load
//                     FALSE if not
//
//*************************************************************

BOOL CheckProfileType (void)
{
    LONG  lResult;
    HKEY  hKey;
    DWORD dwType, dwMaxBufferSize;
    TCHAR szTempBuffer [MAX_TEMP_BUFFER];

    //
    // Open the registry key
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, szProfileRegInfo, 0,
                            KEY_ALL_ACCESS, &hKey);

    if (lResult != ERROR_SUCCESS) {
       return FALSE;
    }

    //
    // Query for the profile path
    //

    dwMaxBufferSize = MAX_TEMP_BUFFER;
    szTempBuffer[0] = TEXT('\0');
    lResult = RegQueryValueEx (hKey, szProfileType, NULL, &dwType,
                              (LPBYTE) szTempBuffer, &dwMaxBufferSize);

    //
    // Close the registry key and return the appropriate response.
    //

    RegCloseKey (hKey);

    if (lResult != ERROR_SUCCESS) {
       return FALSE;
    }

    if (szTempBuffer[0] == PERSONAL_PROFILE_TYPE) {
       return TRUE;

    } else {
       return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\schemes\dialogs.h ===
#define DLG_CURSORS                 100
#define ID_CURSORLIST               101
#define ID_BROWSE                   102
#define ID_DEFAULT                  103
#define ID_TITLEH                   104
#define ID_CREATORH                 105
#define ID_FILEH                    106
#define ID_TITLE                    107
#define ID_CREATOR                  108
#define ID_FILE                     109
#define ID_PREVIEW                  110

#define ID_SAVESCHEME               111
#define ID_REMOVESCHEME             112
#define ID_SCHEMECOMBO              113

#define DLG_FILEOPEN                200

#define DLG_SCHEMESAVE              201

#define ID_SCHEMEFILENAME           300



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\profile\profile.c ===
//*************************************************************
//  File name:    PROFILE.C
//
//  Description:  Profile control panel applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1994
//  All rights reserved
//
//*************************************************************
#include <windows.h>
#include <cpl.h>
#include "profile.h"


//
// Global Variables
//

HINSTANCE hInstance;
LPTSTR    glpList;
TCHAR szEnvDomainName[]   = TEXT("USERDOMAIN");
TCHAR szEnvUserName[]     = TEXT("USERNAME");
TCHAR szEnvComputerName[] = TEXT("COMPUTERNAME");
TCHAR szProfileRegInfo[]  = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
TCHAR szProfileType[]     = TEXT("ProfileType");
TCHAR szProfilePath[]     = TEXT("ProfilePath");
TCHAR szSaveList[]        = TEXT("SaveList");
TCHAR szDontSaveList[]    = TEXT("DontSaveList");
TCHAR szSaveOnUnlisted[]  = TEXT("SaveOnUnlisted");
TCHAR szComma[]           = TEXT(",");
TCHAR szOne[]             = TEXT("1");
TCHAR szZero[]            = TEXT("0");
TCHAR szShellHelp[]       = TEXT("ShellHelp");
TCHAR szHelpFileName[]    = TEXT("profile.hlp");
UINT  uiShellHelp;
BOOL  bUserMadeAChange;

//*************************************************************
//
//  RunApplet()
//
//  Purpose:    Called when the user runs the Profile Applet
//
//  Parameters: HWND hwnd - Window handle
//
//
//  Return:     void
//
//*************************************************************

void RunApplet(HWND hwnd)
{
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_PROFILE), hwnd,
             ProfileDlgProc);
}

//*************************************************************
//
//  ProfileDlgProc()
//
//  Purpose:    Dialog box procedure
//
//  Parameters: HWND hDlg     - Window handle of dialog box
//              UINT message  - Window message
//              WPARAM wParam - WORD parameter
//              LPARAM lParam - LONG parameter
//      
//
//  Return:     (BOOL) TRUE if message was processed
//                     FALSE if not
//
//*************************************************************

LRESULT CALLBACK ProfileDlgProc(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam)
{
        switch (message)
           {
           case WM_INITDIALOG:
              return (InitializeDialog(hDlg));

           case WM_COMMAND:
              switch (LOWORD(wParam)) {
                 case IDD_DONTSAVECHANGE:
                 case IDD_SAVECHANGE:
                     {
                     WORD   wListBoxID, wIndex;
                     BOOL   bFound;

                     //
                     // Determine which "change" button the user pressed.
                     //

                     if (LOWORD(wParam) == IDD_DONTSAVECHANGE) {
                        wListBoxID = IDD_DONTSAVELIST;

                     } else {
                        wListBoxID = IDD_SAVELIST;
                     }

                     //
                     // Create a list of names to pass to the edit dialog box.
                     // NamesDlgProc will free this memory for us.
                     //

                     glpList = CreateList (hDlg, wListBoxID, NULL, &bFound);

                     if (!glpList) {
                        KdPrint(("Received a null pointer from CreateList"));
                        break;
                     }

                     //
                     // Find index of highlighted name so it is highlighted
                     // in the change dialog box also.
                     //

                     wIndex = (WORD) SendDlgItemMessage (hDlg, wListBoxID,
                                                         LB_GETCURSEL, 0, 0);

                     if (wIndex == (WORD)LB_ERR) {
                        wIndex = 0;
                     }

                     //
                     //  Display the Computer Names dialog box.
                     //

                     if (DialogBoxParam (hInstance,
                                         MAKEINTRESOURCE(IDD_COMPUTERNAMES),
                                         hDlg, (DLGPROC)NamesDlgProc, wIndex)) {
                        //
                        // User pressed OK button, so update the list box.
                        //

                        ParseAndAddComputerNames(hDlg, wListBoxID, glpList);

                        //
                        // Free the memory allocated by CreateList inside of
                        // NamesDlgProc
                        //

                        GlobalFree (glpList);

                        //
                        // Update the global state.
                        //

                        bUserMadeAChange = TRUE;
                     }

                     }
                     break;

                 case IDD_SAVELIST:
                 case IDD_DONTSAVELIST:
                     {
                     WORD   wButtonID;

                     //
                     // We are only interested in double click messages.
                     //

                     if (HIWORD (wParam) != LBN_DBLCLK) {
                        break;
                     }

                     //
                     // Determine which listbox was double clicked.
                     //

                     if (LOWORD(wParam) == IDD_SAVELIST) {
                        wButtonID = IDD_SAVECHANGE;

                     } else {
                        wButtonID = IDD_DONTSAVECHANGE;
                     }

                     //
                     // Post a message to post up the change dialog box.
                     //

                     PostMessage (hDlg, WM_COMMAND, MAKELONG (wButtonID,0), 0);
                     }
                     break;

                 case IDD_DEFAULTSAVE:
                 case IDD_DEFAULTDONTSAVE:
                     bUserMadeAChange = TRUE;
                     break;

                 case IDOK:

                     //
                     //  Notify winhelp that we are leaving, save settings
                     //  and leave if appropriate.
                     //

                     WinHelp (hDlg, szHelpFileName, HELP_QUIT, 0);

                     //
                     // If the user didn't make any changes, then
                     // return FALSE through EndDialog.
                     //

                     if (!bUserMadeAChange) {
                         EndDialog(hDlg, FALSE);
                     } else {
                         if (SaveSettings(hDlg)) {
                            EndDialog(hDlg, TRUE);
                         }
                     }
                     return TRUE;

                 case IDCANCEL:

                     //
                     //  Notify winhelp that we are leaving and exit
                     //

                     WinHelp (hDlg, szHelpFileName, HELP_QUIT, 0);
                     EndDialog(hDlg, FALSE);
                     return TRUE;

                 case IDD_HELP:

                     //
                     // User requested help.
                     //

                     WinHelp (hDlg, szHelpFileName, HELP_CONTENTS, 0);
                     break;

                 default:
                     break;
              }
              break;

           default:

              //
              // User requested help via the F1 key.
              //

              if (message == uiShellHelp) {
                  WinHelp (hDlg, szHelpFileName, HELP_CONTENTS, 0);
              }
              break;
           }

        return FALSE;
}

//*************************************************************
//
//  InitializeDialog()
//
//  Purpose:    Initializes the profile dialog box
//
//  Parameters: HWND hDlg - Dialog box window handle
//      
//
//  Return:     TRUE - successfully initialized
//              FALSE - failed to initialize
//
//*************************************************************
BOOL InitializeDialog (HWND hDlg)
{
    TCHAR szDomainName [MAX_DOMAIN_NAME];
    TCHAR szUserName [MAX_USER_NAME];
    TCHAR szTempBuffer [MAX_TEMP_BUFFER];
    TCHAR szUnknown [UNKNOWN_LEN];
    TCHAR szFormatBuffer [MAX_TEMP_BUFFER];
    LONG  lResult;
    HKEY  hKey;
    DWORD dwDisp, dwType, dwMaxBufferSize;


    //
    // Initialize the save changes global.
    //

    bUserMadeAChange = FALSE;

    //
    // Load the "unknown" string from the resources
    //

    if (!LoadString (hInstance, IDS_UNKNOWN, szUnknown, UNKNOWN_LEN)) {
        KdPrint(("Failed to load 'unknown' string."));
        return FALSE;
    }

    //
    // Retrieve the domain name
    //

    if (!GetEnvironmentVariable (szEnvDomainName, szDomainName,
                                 MAX_DOMAIN_NAME)){
        //
        // Failed to get the domain name.  Initalize to Unknown.
        //

        lstrcpy (szDomainName, szUnknown);
    }

    //
    // Retrieve the user name
    //

    if (!GetEnvironmentVariable (szEnvUserName, szUserName,
                                 MAX_USER_NAME)){
        //
        // Failed to get the user name.  Initalize to Unknown.
        //

        lstrcpy (szUserName, szUnknown);
    }


    //
    // Load the format string from the resources
    //

    if (!LoadString (hInstance, IDS_FORMAT, szFormatBuffer, MAX_TEMP_BUFFER)) {
        KdPrint(("Failed to load format string."));
        return FALSE;
    }


    //
    // Build the name field, and add it to the dialog box
    //

    wsprintf (szTempBuffer, szFormatBuffer, szDomainName, szUserName);
    SetDlgItemText (hDlg, IDD_USERNAME, szTempBuffer);

    //
    // Retrieve the local computer name
    //

    if (!GetEnvironmentVariable (szEnvComputerName, szTempBuffer,
                                 MAX_TEMP_BUFFER)){
        //
        // Failed to get the computer name.  Initalize to Unknown.
        //

        lstrcpy (szTempBuffer, szUnknown);
    }
    SetDlgItemText (hDlg, IDD_COMPUTERNAME, szTempBuffer);


    //
    // Now query the registry
    //
    // First we need a key
    //

    lResult = RegCreateKeyEx (HKEY_CURRENT_USER, szProfileRegInfo, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
       KdPrint(("Failed to open registry key."));
       return FALSE;
    }


    //
    // Query and set the profile path
    //

    dwMaxBufferSize = MAX_TEMP_BUFFER;
    szTempBuffer[0] = TEXT('\0');
    RegQueryValueEx (hKey, szProfilePath , NULL, &dwType,
                    (LPBYTE) szTempBuffer, &dwMaxBufferSize);

    if (szTempBuffer[0] == TEXT('\0')) {
       lstrcpy (szTempBuffer, szUnknown);
    }

    SetDlgItemText (hDlg, IDD_PATH, szTempBuffer);


    //
    // Query and set the computer names to save the profile from
    //

    dwMaxBufferSize = MAX_TEMP_BUFFER;
    szTempBuffer[0] = TEXT('\0');
    RegQueryValueEx (hKey, szSaveList , NULL, &dwType,
                    (LPBYTE) szTempBuffer, &dwMaxBufferSize);

    if (szTempBuffer[0] != TEXT('\0')) {
       ParseAndAddComputerNames(hDlg, IDD_SAVELIST, szTempBuffer);
    }


    //
    // Query and set the computer names to not save the profile from
    //

    dwMaxBufferSize = MAX_TEMP_BUFFER;
    szTempBuffer[0] = TEXT('\0');
    RegQueryValueEx (hKey, szDontSaveList , NULL, &dwType,
                    (LPBYTE) szTempBuffer, &dwMaxBufferSize);

    if (szTempBuffer[0] != TEXT('\0')) {
       ParseAndAddComputerNames(hDlg, IDD_DONTSAVELIST, szTempBuffer);
    }


    //
    // Query and set the default choice
    //

    dwMaxBufferSize = MAX_TEMP_BUFFER;
    szTempBuffer[0] = TEXT('\0');
    RegQueryValueEx (hKey, szSaveOnUnlisted , NULL, &dwType,
                    (LPBYTE) szTempBuffer, &dwMaxBufferSize);

    //
    // If the buffer still has NULL or one in it, then the default
    // case is to always save the profile.
    //

    if ( (szTempBuffer[0] == TEXT('\0')) || (szTempBuffer[0] == TEXT('1')) ) {
       CheckDlgButton (hDlg, IDD_DEFAULTSAVE, 1);
    } else {
       CheckDlgButton (hDlg, IDD_DEFAULTDONTSAVE, 1);
    }


    //
    // Close the registry key
    //

    RegCloseKey (hKey);


    //
    // Return success
    //

    return TRUE;

}

//*************************************************************
//
//  ParseAndAddComputerNames()
//
//  Purpose:    Parse the list of computer names, and add them
//              to the list box.
//
//  Parameters: HWND hDlg      - Window handle of dialog box
//              WORD idListBox - ListBox id
//              LPTSTR szNames - List of names separated by commas
//      
//
//  Return:     void
//
//*************************************************************

void ParseAndAddComputerNames(HWND hDlg, WORD idListBox, LPTSTR szNames)
{
    LPTSTR lpHead, lpTail;
    TCHAR  chLetter;

    //
    // Turn off redraw, and empty the listbox.
    //

    SendDlgItemMessage (hDlg, idListBox, WM_SETREDRAW, 0, 0);
    SendDlgItemMessage (hDlg, idListBox, LB_RESETCONTENT, 0, 0);

    lpHead = lpTail = szNames;

    while (*lpHead) {

        //
        // Search for the comma, or the end of the list.
        //

        while (*lpHead != TEXT(',') && *lpHead) {
            lpHead++;
        }

        //
        // If the head pointer is not pointing at the
        // tail pointer, then we have something to add
        // to the list.
        //

        if (lpHead != lpTail) {

            //
            // Store the letter pointed to by lpHead in a temporary
            // variable (chLetter).  Replace that letter with NULL,
            // and add the string to the list box starting from
            // lpTail.  After the string is added, replace the letter
            // we used.
            //

            chLetter = *lpHead;
            *lpHead = TEXT('\0');
            SendDlgItemMessage (hDlg, idListBox, LB_ADDSTRING, 0,
                                (LPARAM) lpTail);
            *lpHead = chLetter;
        }

        //
        // If we are not at the end of the list, then move the
        // head pointer forward one character.
        //

        if (*lpHead) {
           lpHead++;
        }


        //
        // Move the tail pointer to the head pointer
        //

        lpTail = lpHead;
    }

    //
    // Turn redraw back on, and display the results.
    //

    SendDlgItemMessage (hDlg, idListBox, WM_SETREDRAW, 1, 0);
    InvalidateRect (GetDlgItem(hDlg, idListBox), NULL, TRUE);

}

//*************************************************************
//
//  SaveSettings()
//
//  Purpose:    Saves the current selections to the registry
//
//  Parameters: HWND hDlg - Handle to dialog box
//      
//
//  Return:     BOOL - TRUE ok to exit dialog box
//                     FALSE do not exit dialog box
//
//*************************************************************
BOOL SaveSettings (HWND hDlg)
{
    LONG   lResult;
    HKEY   hKey = 0;
    DWORD  dwDisp;
    TCHAR  szProfile [PROFILE_NAME_LEN];
    TCHAR  szTempBuffer [MAX_TEMP_BUFFER];
    TCHAR  szTempBuffer2 [MAX_TEMP_BUFFER];
    TCHAR  szComputerName [MAX_COMPUTER_NAME];
    TCHAR  szSpecificErrorMsg [MAX_ERROR_MSG];
    LPTSTR lpSaveList, lpDoNotSaveList;
    WORD   wError, wMBStyle;
    INT    iMBResult;
    BOOL   bFound = FALSE;
    BOOL   bSaveOnUnlisted;

    //
    // Check for computer names that exist in both listboxs.
    //

    if (!CompareLists (hDlg, IDD_SAVELIST, IDD_DONTSAVELIST)) {
       KdPrint(("One or more computer names exist in both lists."));
       wError = IDS_DUPLICATENAME;
       goto AbortSave;
    }

    //
    // Retreive the computer name from the dialog box
    //

    GetDlgItemText (hDlg, IDD_COMPUTERNAME, szComputerName, MAX_COMPUTER_NAME);


    //
    // Check the default flag
    //

    bSaveOnUnlisted = IsDlgButtonChecked (hDlg, IDD_DEFAULTSAVE);


    //
    // Create the list of computer names on which the profile will not be saved.
    //

    lpDoNotSaveList = CreateList (hDlg, IDD_DONTSAVELIST, szComputerName,
                                  &bFound);


    //
    // Check for NULL pointer
    //

    if (!lpDoNotSaveList) {
       KdPrint(("Don't save list:  Received a null pointer from CreateList"));
       wError = IDS_UNABLETOSAVE;
       goto AbortSave;
    }


    //
    // Check to see if the computer was in the list.  If so, this is
    // an error case.
    //

    if (bFound) {
       KdPrint(("This computer is in the Do Not Save Profile List"));
       wError = IDS_NAMEINDONTLIST;
       goto AbortSave;
    }


    //
    // Create the list of computer names on which the profile will be saved.
    //

    lpSaveList = CreateList (hDlg, IDD_SAVELIST, szComputerName, &bFound);


    //
    // Check for NULL pointer
    //

    if (!lpSaveList) {
       KdPrint(("Do save list:  Received a null pointer from CreateList"));
       wError = IDS_UNABLETOSAVE;
       goto AbortSave;
    }

    //
    // Check to see if the computer was in the list.  If not and the
    // user has "Do Not save on unlisted computer" turned on, then this
    // is an error case.
    //

    if (!bFound && !bSaveOnUnlisted) {
       KdPrint(("This computer is not in the Save Profile List and Do Not save on Unlisted computer is turned on"));
       wError = IDS_NONAMEANDDONOTSAVE;
       goto AbortSave;
    }


    //
    // Open the registry key
    //

    lResult = RegCreateKeyEx (HKEY_CURRENT_USER, szProfileRegInfo, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
       KdPrint(("Failed to open registry key."));
       wError = IDS_UNABLETOSAVE;
       goto AbortSave;
    }


    //
    // Write the Do Not Save list to the registry
    //

    RegSetValueEx (hKey, szDontSaveList, 0, REG_SZ,
                  (LPBYTE) lpDoNotSaveList,
                  sizeof (TCHAR) * lstrlen (lpDoNotSaveList) + 1);


    //
    // Write the Save list to the registry
    //

    RegSetValueEx (hKey, szSaveList, 0, REG_SZ,
                  (LPBYTE) lpSaveList,
                  sizeof (TCHAR) * lstrlen (lpSaveList) + 1);


    //
    // Write the default setting to the registry
    //

    if (bSaveOnUnlisted) {
        lstrcpy (szTempBuffer, szOne);
    } else {
        lstrcpy (szTempBuffer, szZero);
    }

    RegSetValueEx (hKey, szSaveOnUnlisted, 0, REG_SZ,
                  (LPBYTE) szTempBuffer,
                  sizeof (TCHAR) * lstrlen (szTempBuffer) + 1);


    //
    // Close the registry key
    //

    RegCloseKey (hKey);


    //
    // Success.  Now we need to tell the user to log off all other computers,
    // and then log off of this one.
    //

    wError = IDS_LOGOFFNOTICE;

AbortSave:


    //
    // Free up the memory allocated by CreateList
    //

    GlobalFree (lpSaveList);
    GlobalFree (lpDoNotSaveList);


    //
    // Load the error string and message box title
    //

    if (LoadString (hInstance, IDS_NAME, szProfile, PROFILE_NAME_LEN) &&
        LoadString (hInstance, IDS_BASEERRORMSG, szTempBuffer, MAX_TEMP_BUFFER) &&
        LoadString (hInstance, wError, szSpecificErrorMsg, MAX_ERROR_MSG)) {

        //
        // If it is a user error, then we want to prompt with Yes/No buttons
        // otherwise offer an OK button.
        //

        if (wError == IDS_UNABLETOSAVE) {
            wMBStyle = MB_OK | MB_ICONEXCLAMATION;
            lstrcpy (szTempBuffer2, szSpecificErrorMsg);

        } else if (wError == IDS_LOGOFFNOTICE) {
            wMBStyle = MB_OK | MB_ICONASTERISK;
            lstrcpy (szTempBuffer2, szSpecificErrorMsg);

        } else {
            wMBStyle = MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION;
            wsprintf (szTempBuffer2, szTempBuffer, szSpecificErrorMsg);
        }

        //
        // Display the message
        //

        iMBResult = MessageBox (hDlg, szTempBuffer2, szProfile,
                                wMBStyle);


        //
        // If the user chooses NO, the we don't want to exit the
        // dialog box.
        //

        if (iMBResult == IDNO) {
            return FALSE;
        } else {
            return TRUE;
        }
    }
    // If out of memory, assume user hit OK
    return TRUE;
}

//*************************************************************
//
//  CreateList()
//
//  Purpose:    Creates a list of computer names from the
//              given listbox.  Each name is seperated by
//              a comma.  Also, if the given computer name
//              is found in the list, the bool variable is
//              set.
//
//  Parameters: HWND   hDlg           - Window handle
//              WORD   idListBox      - ID of listbox
//              LPTSTR szComputerName - Name of computer to watch for
//              LPBOOL lpFound        - Flag to set if found
//      
//
//  Return:     LPTSTR - Pointer to buffer if successful
//                       NULL if not
//
//*************************************************************

LPTSTR CreateList (HWND hDlg, WORD idListBox, LPTSTR szComputerName,
                   LPBOOL lpFound)
{
    LPTSTR lpList;
    WORD   wCount, wIndex;
    TCHAR  szName[MAX_COMPUTER_NAME];

    //
    // Initialize the flag
    //

    *lpFound = FALSE;

    //
    // Get the number of items in the listbox
    //

    wCount = (WORD) SendDlgItemMessage (hDlg, idListBox, LB_GETCOUNT, 0, 0);

    //
    // Allocate a buffer to use
    //

    lpList = GlobalAlloc (GPTR, (wCount ? wCount : 1) * (MAX_COMPUTER_NAME * sizeof(TCHAR)));

    if (!lpList) {
        KdPrint(("CreateList:  Received a null pointer from GlobalAlloc"));
        return NULL;
    }

    //
    // Null terminate
    //

    lpList[0] = TEXT('\0');

    for (wIndex = 0; wIndex < wCount; wIndex++) {

        //
        // Retreive and item from the list
        //

        SendDlgItemMessage (hDlg, idListBox, LB_GETTEXT, wIndex,
                           (LPARAM) szName);

        //
        // Check to see if we found the requested name.
        //

        if (!lstrcmpi (szComputerName, szName)) {
            *lpFound = TRUE;
        }

        //
        // Add name to the end of the buffer
        //
        lstrcat (lpList, szName);

        //
        // If we are not adding the last item, then insert a comma
        //

        if (wIndex != (wCount - 1)) {
           lstrcat (lpList, szComma);
        }
    }

    //
    // Success
    //

    return (lpList);
}

//*************************************************************
//
//  CompareLists()
//
//  Purpose:    Compares one listbox to the other listbox
//              looking for names that appear in both.
//
//  Parameters: HWND hDlg - Window handle of dialog box
//              WORD idList1 - ID of first listbox
//              WORD idList2 - ID of second listbox
//      
//
//  Return:     BOOL - TRUE if not duplicates exist
//                     FALSE if a duplicate does exist
//
//*************************************************************

BOOL CompareLists (HWND hDlg, WORD idList1, WORD idList2)
{
    WORD wList1Count, wIndex;
    TCHAR szName[MAX_COMPUTER_NAME];

    //
    // Get the number of items in the first listbox
    //

    wList1Count = (WORD)SendDlgItemMessage (hDlg, idList1, LB_GETCOUNT, 0, 0);

    if (wList1Count == LB_ERR) {
       return TRUE;
    }

    //
    // Loop through listbox 1 comparing with listbox 2
    //

    for (wIndex=0; wIndex < wList1Count; wIndex++) {

        SendDlgItemMessage (hDlg, idList1, LB_GETTEXT, wIndex, (LPARAM)szName);

        if (SendDlgItemMessage (hDlg, idList2, LB_FINDSTRINGEXACT,
                                0, (LPARAM)szName) != LB_ERR) {
           return FALSE;
       }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\profile\names.c ===
//*************************************************************
//  File name:    NAMES.C
//
//  Description:  Profile control panel applet
//                This file contains the source code for
//                "Computer Names" dialog box.
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1994
//  All rights reserved
//
//*************************************************************
#include <windows.h>
#include "profile.h"


//*************************************************************
//
//  NamesDlgProc()
//
//  Purpose:    Dialog box procedure
//
//  Parameters: HWND hDlg     - Window handle of dialog box
//              UINT message  - Window message
//              WPARAM wParam - WORD parameter
//              LPARAM lParam - LONG parameter
//      
//
//  Return:     (BOOL) TRUE if message was processed
//                     FALSE if not
//
//*************************************************************

INT_PTR CALLBACK NamesDlgProc(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam)
{
        TCHAR szNewName [MAX_COMPUTER_NAME];
        LPTSTR lpNewName;
        BOOL  bEnableAdd;


        switch (message)
           {
           case WM_INITDIALOG:

              //
              // Add the names to the list box.
              //

              ParseAndAddComputerNames(hDlg, IDD_NAMESLIST, glpList);

              //
              // Find out if anything was added to the list.
              // If so, then highlight the selected item.  Otherwise,
              // disable the delete buttons.
              //

              if (SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_GETCOUNT, 0,0)) {
                 SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_SETSEL, 1, lParam);
              } else {
                 EnableWindow(GetDlgItem(hDlg, IDD_DELETE), FALSE);
                 EnableWindow(GetDlgItem(hDlg, IDD_CLEARALL), FALSE);
              }

              //
              // Disable the "Add" button, and free the buffer.  It will
              // be created again if the users presses the OK button.
              //

              EnableWindow (GetDlgItem(hDlg, IDD_ADD), FALSE);
              GlobalFree (glpList);

              //
              // Post ourselves a message so we can set the focus
              // appropriately.
              //

              PostMessage (hDlg, WM_USER+1, 0, 0);

              return TRUE;

           case WM_USER+1:

              //
              // Set the focus to the new computer name edit control
              // since most people will be starting from here.
              //

              SetFocus (GetDlgItem(hDlg, IDD_NEWNAME));

              break;

           case WM_COMMAND:
              switch (LOWORD(wParam)) {
                 case IDD_NEWNAME:

                    //
                    // Enable the Add button if appropriate.
                    //

                    if (HIWORD(wParam) == EN_UPDATE) {
                       bEnableAdd = GetDlgItemText(hDlg, IDD_NEWNAME,
                                     szNewName, MAX_COMPUTER_NAME);

                       EnableWindow (GetDlgItem (hDlg, IDD_ADD), bEnableAdd);

                       if (bEnableAdd) {
                          SetDefButton (hDlg, IDD_ADD);
                       } else {
                          SetDefButton (hDlg, IDOK);
                       }
                    }
                    break;

                 case IDD_ADD:

                    //
                    // Retrieve the new name from the edit control
                    //

                    GetDlgItemText(hDlg, IDD_NEWNAME,
                                   szNewName, MAX_COMPUTER_NAME);

                    //
                    // Check to see if the user entered the new computer
                    // name with a \\ infront of it.  If so, remove it.
                    //

                    lpNewName = szNewName;

                    if ( (szNewName[0] == TEXT('\\')) &&
                         (szNewName[1] == TEXT('\\')) ) {
                       lpNewName += 2;
                    }

                    //
                    // Add the new name if it doesn't already exist.
                    //

                    if (SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_FINDSTRINGEXACT,
                                            0, (LPARAM) lpNewName) == LB_ERR) {
                        SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_ADDSTRING,
                                            0, (LPARAM) lpNewName);
                    }

                    //
                    // Erase the contents of the edit control, and set the
                    // focus back to the edit control for quick entry of
                    // names.
                    //

                    SetWindowText (GetDlgItem(hDlg, IDD_NEWNAME), NULL);
                    SetFocus (GetDlgItem(hDlg, IDD_NEWNAME));
                    SetDefButton (hDlg, IDOK);

                    //
                    // Enable the delete buttons.
                    //

                    EnableWindow (GetDlgItem(hDlg, IDD_DELETE), TRUE);
                    EnableWindow (GetDlgItem(hDlg, IDD_CLEARALL), TRUE);

                    break;

                 case IDD_DELETE:
                    {
                    INT iSel [MAX_NUM_COMPUTERS];
                    INT iCount, i;

                    //
                    // Retrieve an array of selected items.
                    //

                    iCount = (int)SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_GETSELITEMS,
                                                 MAX_NUM_COMPUTERS, (LPARAM) iSel);

                    if (iCount == LB_ERR) {
                       break;
                    }

                    //
                    // Now loop through the array and delete the items.
                    // Note that we have to do this from the bottom up,
                    // or the index's would be wrong as items are deleted
                    // from the top of the list.
                    //

                    for (i = iCount-1; i >= 0; i--) {
                        SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_DELETESTRING,
                                            iSel[i], 0);
                    }

                    //
                    // Find out if anything is left in the list.
                    // If not, then disable the delete buttons.
                    //

                    if (!SendDlgItemMessage (hDlg, IDD_NAMESLIST,
                                             LB_GETCOUNT, 0,0)) {
                       EnableWindow(GetDlgItem(hDlg, IDD_DELETE), FALSE);
                       EnableWindow(GetDlgItem(hDlg, IDD_CLEARALL), FALSE);
                    }

                    }
                    break;

                 case IDD_CLEARALL:

                    //
                    //  User requested to empty the entire list.
                    //

                    SendDlgItemMessage (hDlg, IDD_NAMESLIST, LB_RESETCONTENT,
                                        0, 0);

                    EnableWindow(GetDlgItem(hDlg, IDD_DELETE), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDD_CLEARALL), FALSE);

                    break;

                 case IDOK:
                    {
                    BOOL bFound;
                    TCHAR szProfile[MAX_ERROR_MSG];
                    TCHAR szErrorMsg [MAX_ERROR_MSG];

                    //
                    // Make sure the user doesn't still have a name
                    // in the "New Name" field that he forgot to "add"
                    //

                    if (GetDlgItemText(hDlg, IDD_NEWNAME,
                                   szNewName, MAX_COMPUTER_NAME)) {
                        LoadString (hInstance, IDS_NAME, szProfile, MAX_ERROR_MSG);
                        LoadString (hInstance, IDS_ADDNAME, szErrorMsg, MAX_ERROR_MSG);

                        if (MessageBox (hDlg, szErrorMsg, szProfile,
                                        MB_YESNO | MB_ICONQUESTION) == IDYES) {

                            //
                            // User would like to add the name before leaving.
                            // Check to see if the user entered the new computer
                            // name with a \\ infront of it.  If so, remove it.
                            //

                            lpNewName = szNewName;

                            if ( (szNewName[0] == TEXT('\\')) &&
                                 (szNewName[1] == TEXT('\\')) ) {
                               lpNewName += 2;
                            }

                            //
                            // Check for duplicates first, then add the name
                            // if it doesn't exist.
                            //

                            if (SendDlgItemMessage (hDlg, IDD_NAMESLIST,
                                                    LB_FINDSTRINGEXACT,
                                                    0,
                                                    (LPARAM) lpNewName) == LB_ERR) {
                                SendDlgItemMessage (hDlg, IDD_NAMESLIST,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM) lpNewName);
                            }

                        }

                    }


                    //
                    // Create the list of names to be passed back.
                    //

                    glpList = CreateList (hDlg, IDD_NAMESLIST, NULL, &bFound);

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    }

                 case IDCANCEL:

                    //
                    // Close the dialog box.
                    //

                    EndDialog(hDlg, FALSE);
                    return TRUE;

                 case IDD_NAMESHELP:

                     //
                     // User requested help
                     //

                     WinHelp (hDlg, szHelpFileName, HELP_CONTEXT,
                              NAMES_HELP_CONTEXT);
                     break;


                 default:
                    break;
              }
              break;

           default:

              //
              // User requested help via the F1 key.
              //

              if (message == uiShellHelp) {
                  WinHelp (hDlg, szHelpFileName, HELP_CONTENTS, 0);
              }
              break;
           }

        return FALSE;
}

//*************************************************************
//
//  SetDefButton()
//
//  Purpose:    Sets the default button
//
//  Parameters: HWND hDlg     - Window handle of dialog box
//              INT  idButton - ID of button
//
//  Return:     void
//
//*************************************************************

void SetDefButton(HWND hwndDlg, INT  idButton)
{
    LRESULT lr;

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        //
        // If we are setting the default button to the button which is
        // already default, then exit now.
        //

        if (LOWORD(lr) == idButton) {
            return;
        }

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\schemes\init.c ===
#include <windows.h>
#include <cpl.h>

//
// Marks code that will need to be modified if this module is ever
// incorporated into MAIN.CPL instead of being a separate applet.
//
#define NOTINMAIN


#ifdef NOTINMAIN
#include "..\main\cphelp.h"         //For the help id's.
#endif //NOTINMAIN


#include "cursors.h"

#define szPREVIEW   "SPreviewWndClass"

HANDLE ghmod;
int gcxCursor, gcyCursor;


LONG APIENTRY CPlApplet(
    HWND  hwnd,
    WORD  message,
    DWORD wParam,
    LONG  lParam)
{
    LPCPLINFO lpCPlInfo;
    LPNEWCPLINFO lpNCPlInfo;
    WNDCLASS cls;

    switch (message) {
    case CPL_INIT:              // Is any one there ?
        gcxCursor = GetSystemMetrics(SM_CXCURSOR);
        gcyCursor = GetSystemMetrics(SM_CYCURSOR);

        /*
         * Load ONE string for emergencies.
         */
        LoadString(ghmod, IDS_CUR_NOMEM, gszNoMem,
                sizeof(gszNoMem) / sizeof(TCHAR));

        /*
         * Register a new window class to handle the cursor preview.
         */
        cls.style = CS_GLOBALCLASS;
        cls.lpfnWndProc = PreviewWndProc;
        cls.cbClsExtra = 0;
        cls.cbWndExtra = 0;
        cls.hInstance = ghmod;
        cls.hIcon = NULL;
        cls.hCursor = NULL;
        cls.hbrBackground = NULL;
        cls.lpszMenuName = NULL;
        cls.lpszClassName = szPREVIEW;
        RegisterClass(&cls);
        return TRUE;

    case CPL_GETCOUNT :         // How many applets do you support ?
        return 1;

    case CPL_INQUIRE :          // Fill CplInfo structure
        lpCPlInfo = (LPCPLINFO)lParam;

        lpCPlInfo->idIcon = CURSORSICON;
        lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->idInfo = IDS_INFO;
        lpCPlInfo->lData  = 0;
        break;

    case CPL_NEWINQUIRE:

        lpNCPlInfo = (LPNEWCPLINFO)lParam;

        lpNCPlInfo->hIcon = LoadIcon(ghmod, MAKEINTRESOURCE(CURSORSICON));
        LoadString(ghmod, IDS_NAME, lpNCPlInfo->szName, sizeof(lpNCPlInfo->szName));

        if (!LoadString(ghmod, IDS_INFO, lpNCPlInfo->szInfo, sizeof(lpNCPlInfo->szInfo)))
            lpNCPlInfo->szInfo[0] = 0;

        lpNCPlInfo->dwSize = sizeof(NEWCPLINFO);
        lpNCPlInfo->lData  = 0;
        lpNCPlInfo->dwHelpContext = IDH_CHILD_CURSORS;
        strcpy(lpNCPlInfo->szHelpFile, xszControlHlp);

        return TRUE;

    case CPL_DBLCLK:            // You have been chosen to run
        /*
         * One of your applets has been double-clicked.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        DialogBox(ghmod, MAKEINTRESOURCE(DLG_CURSORS), hwnd, (DLGPROC)CursorsDlgProc);
        break;

    case CPL_EXIT:              // You must really die
    case CPL_STOP:              // You must die
        UnregisterClass(szPREVIEW, ghmod);
        break;

    case CPL_SELECT:            // You have been selected
        /*
         * Sent once for each applet prior to the CPL_EXIT msg.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        break;
    }

    return 0L;
}


BOOL DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);

    if (ulReason != DLL_PROCESS_ATTACH)
        return TRUE;

    ghmod = hmod;

    return TRUE;
}


#ifdef CAIROBLD
// hacks for Cairo build environment
// 4/08/93 - ErikGav
BOOL DllEntryPoint(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL)
{
    return DllInitialize(hmod,ulReason,pctx);
}

void CDECL RegisterWithCommnot(void)
{
}

void CDECL DeRegisterWithCommnot(void)
{
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\schemes\cursors.h ===
/** FILE: cursors.h ********** Module Header *******************************
 *
 *  Control panel applet for Cursors configuration.  This file holds
 *  definitions and other common include file items that deal with the
 *  Cursors Dialog of Control Panel.
 *
 * History:
 *  12:30 on Tues  23 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *      Took base code from Win 3.1 source
 * 12-22-91 DarrinM     Created from MOUSE.H
 * 29-Apr-1993 JonPa    added string definitions
 *
 *  Copyright (C) 1990-1991 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                              Include files
//==========================================================================

#include "dialogs.h"

//==========================================================================
//                          Definitions and Typedefs
//==========================================================================

#define IDS_NAME        1
#define IDS_INFO        2
#define IDS_CUR_NOMEM   3
#define IDS_CUR_BADFILE 4
#define IDS_CUR_BROWSE  5
#define IDS_CUR_FILTER  6
#define IDS_ARROW       7
#define IDS_WAIT        8
#define IDS_APPSTARTING 9
#define IDS_NO          10
#define IDS_IBEAM       11
#define IDS_CROSS       12
#define IDS_SIZENS      13
#define IDS_SIZEWE      14
#define IDS_SIZENWSE    15
#define IDS_SIZENESW    16
#define IDS_SIZEALL     17

#define IDS_REMOVESCHEME 20
#define IDS_DEFAULTSCHEME   21

#define IDS_FIRSTSCHEME 1000
#define IDS_LASTSCHEME  1017

#define CURSORSICON     1

/* Help stuff */
#define IDH_DLG_CURSORS (IDH_DLGFIRST + DLG_CURSORS)


//==========================================================================
//                          External Declarations
//==========================================================================

extern TCHAR gszNoMem[256];
extern char xszControlHlp[];

//==========================================================================
//                              Macros
//==========================================================================


//==========================================================================
//                          Function Prototypes
//==========================================================================

INT_PTR CALLBACK CursorsDlgProc(HWND hwnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
LRESULT CALLBACK PreviewWndProc(HWND hwnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\schemes\cursors.c ===
/** FILE: cursors.c ********** Module Header ********************************
 *
 *  Control panel applet for Cursors configuration.  This file holds
 *  everything to do with the "Cursors" dialog box in the Control Panel.
 *
 *  If this applet gets incorporated into the MAIN.CPL module, look
 *  for the define NOTINMAIN below.  This marks some code that will
 *  need to be modified.
 *
 * History:
 *  12:30 on Tues  23 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *      Took base code from Win 3.1 source
 * 12-22-91 DarrinM     Created from MOUSE.C
 * 07-31-92 DarrinM     Revived.
 * 01-04-93 ByronD      Cleaned up, etc.
 * 03-25-93 JonPa       Changed .ANI file format from RAD to RIFF
 * 04-29-93 JonPa       Pull strings out of resource file
 * 05-20-93 ErikGav     Added schemes
 *
 *  Copyright (C) 1990-1993 Microsoft Corporation
 *
 *************************************************************************/

//
// Marks code that will need to be modified if this module is ever
// incorporated into MAIN.CPL instead of being a separate applet.
//
#define NOTINMAIN


//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Windows SDK
/* cut out unnec stuff from windows.h */
#define NOCLIPBOARD
#define NOMETAFILE
#define NOSYSCOMMANDS
#define NOGDICAPMASKS

#include <windows.h>

// Common dialog includes.
#include <dlgs.h>
#include <commdlg.h>

// Utility library
#include <cplib.h>

// Application specific
#include "cursors.h"
#include <winuserp.h>

#ifdef NOTINMAIN
#include "..\main\cphelp.h"         //For the help id's.
#endif //NOTINMAIN

#ifndef RAD_FORMAT
#include <asdf.h>
#endif

//==========================================================================
//                          Local Definitions
//==========================================================================

#ifndef LATER
// darrinm - 07/31/92
// Replace with something good

#define gcxAvgChar              8
#endif

#define CCURSORS                11
#define MAX_SCHEME_NAME_LEN     32

#define PM_NEWCURSOR            (WM_USER + 1)
#define PM_PAUSEANIMATION       (WM_USER + 2)
#define PM_UNPAUSEANIMATION     (WM_USER + 3)

#define ID_PREVIEWTIMER         1

typedef struct _CURSORINFO {    // curi
    DWORD fl;
    HCURSOR hcur;
    int ccur;
    int icur;
    char szFile[FILENAME_MAX];
    char szTitle[80];
    char szCreator[80];
} CURSORINFO, *PCURSORINFO;

#define CIF_FILE        0x0001
#define CIF_ANICURSOR   0x0002
#define CIF_MODIFIED    0x0004
#define CIF_TITLE       0x0008
#define CIF_CREATOR     0x0010

#pragma pack(2)
typedef struct tagNEWHEADER {
    WORD reserved;
    WORD rt;
    WORD cResources;
} NEWHEADER, *LPNEWHEADER;
#pragma pack()

typedef struct
{
    UINT  idVisName;
    LPSTR idResource;
    LPSTR pszIniName;
    LPSTR pszVisName;
} CURSORDESC, *PCURSORDESC;

//
// Structure that contains data used within a preview window.  This
// data is unique for each preview window, and is used to optimize
// the painting.
//
typedef struct
{
    HDC hdcMem;
    HBITMAP hbmMem;
    HBITMAP hbmOld;
    PCURSORINFO pcuri;
} PREVIEWDATA, *PPREVIEWDATA;


//==========================================================================
//                          Local Data Declarations
//==========================================================================

extern HANDLE ghmod;                // These guys are defined in INIT.C
extern int gcxCursor, gcyCursor;

HWND ghwndDlg, ghwndFile, ghwndFileH, ghwndTitle, ghwndTitleH;
HWND ghwndCreator, ghwndCreatorH, ghwndLB, ghwndPreview;
HWND ghwndSchemeCB;
HBRUSH ghbrHighlight, ghbrHighlightText, ghbrWindow;
COLORREF gcrHighlightText;
TCHAR gszFileName[MAX_PATH];
TCHAR gszFileName2[MAX_PATH];
HFONT ghfontLabels;
UINT gnMsgLBSelChString;
UINT gnMsgFileOK;
UINT wBrowseHelpMessage;
LPTSTR gszFileNotFound = NULL;
LPTSTR gszBrowse = NULL;
LPTSTR gszFilter = NULL;
TCHAR gszNoMem[256] = "No Memory";
HHOOK ghhkMsgFilter;                // Hook handle for message filter func.

CURSORDESC gacd[] =
{
    { IDS_ARROW,    IDC_ARROW,    "Arrow",    NULL },
    { IDS_WAIT,     IDC_WAIT,     "Wait",     NULL },
    { IDS_APPSTARTING, IDC_APPSTARTING, "AppStarting", NULL },
    { IDS_NO,       IDC_NO,       "No",       NULL },
    { IDS_IBEAM,    IDC_IBEAM,    "IBeam",    NULL },
    { IDS_CROSS,    IDC_CROSS,    "CrossHair",NULL },
    { IDS_SIZENS,   IDC_SIZENS,   "SizeNS",   NULL },
    { IDS_SIZEWE,   IDC_SIZEWE,   "SizeWE",   NULL },
    { IDS_SIZENWSE, IDC_SIZENWSE, "SizeNWSE", NULL },
    { IDS_SIZENESW, IDC_SIZENESW, "SizeNESW", NULL },
    { IDS_SIZEALL,  IDC_SIZEALL,  "SizeAll",  NULL }
};

CURSORINFO acuri[CCURSORS];

// registry keys
char szSchemeINI[] = "Cursor Schemes";
char szCurrentINI[] = "Current";
char gszSchemeName[MAX_SCHEME_NAME_LEN+1];

//==========================================================================
//                          Local Function Prototypes
//==========================================================================

BOOL InitCursorsDlg(HWND hwnd);
VOID CreateBrushes(VOID);
VOID DestroyBrushes(VOID);
LPTSTR GetResourceString(HINSTANCE hmod, int id);
void DrawCursorListItem(DRAWITEMSTRUCT *pdis);
BOOL GetCursorFromFile(CURSORINFO *pcuri);
BOOL Browse(HWND hwndOwner);
UINT_PTR CALLBACK OpenFileNameHookDlgProc(HWND hwnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
void CleanUpEverything(void);
VOID UpdateCursorList(VOID);
VOID NextFrame(HWND hwnd);
BOOL ReadTag( HANDLE hf, PRTAG ptag);
BOOL ReadChunk(HANDLE hf, PRTAG ptag, PVOID pv);
BOOL ReadChunkN(HANDLE hf, PRTAG ptag, PVOID pv, DWORD cbMax);
DWORD Skip( HANDLE hf, DWORD cbSkip);
void HourGlass(BOOL fOn);
DWORD FAR PASCAL MsgFilterHookFunc(INT nCode, WPARAM wParam, LPMSG lpMsg);

BOOL TryToLoadCursor(HWND hwnd,int i,CURSORINFO *pcuri);
BOOL LoadScheme(void);
BOOL SaveScheme(void);
BOOL SaveSchemeAs(void);
BOOL RemoveScheme(void);
BOOL InitSchemeComboBox(void);
BOOL SchemeUpdate(int);
LPSTR MakeFilename(LPSTR sz);
INT_PTR CALLBACK SaveSchemeDlgProc(HWND  hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void StripBlanks (LPSTR pszString);


//==========================================================================
//                              Functions
//==========================================================================

#ifdef NOTINMAIN //NOTINMAIN

//
// This is a hack to get around the mess in CPLIB.H.  It can all go away
// when this applet is incorporated into MAIN.CPL.
//
#define wHelpMessage    xwHelpMessage
#define dwContext       xdwContext
#define szControlHlp    xszControlHlp
#define CPHelp          xCPHelp


UINT    wHelpMessage;           // stuff for help
DWORD   dwContext = 0L;
char szControlHlp[] = "control.hlp";

void CPHelp (HWND hWnd)
{
//    char    szBuf[80];

//    wsprintf (szBuf, "Help Context %ld", dwContext);

    WinHelp (hWnd, szControlHlp, HELP_CONTEXT, dwContext);
//    hWnd = hWnd;
}

#endif //NOTINMAIN


/***************************************************************************\
* InitCursorsDlg
*
*
* History:
* 12-22-91 DarrinM      Created.
* 04-10-93 ErikGav      Added init for schemes
\***************************************************************************/

BOOL InitCursorsDlg(
    HWND hwnd)
{
    CURSORINFO *pcuri;
    LOGFONT lf;
    int i;
    DWORD dwDummy;
    static TCHAR szBuffer[256];
    LPTSTR p,p2;

#ifdef NOTINMAIN
    wHelpMessage = RegisterWindowMessage("ShellHelp");
    dwContext = IDH_CHILD_CURSORS;
#endif //NOTINMAIN

    GetProfileString(szCurrentINI,szSchemeINI,"",szBuffer,sizeof(szBuffer));

    if (szBuffer[0] == '\0')
    {
        //
        // this key doesn't exist-- this is the first time
        // the applet has been run.  Create the default
        // scheme sets.
        //

        LoadString(ghmod, IDS_DEFAULTSCHEME, szBuffer, sizeof(szBuffer));
        WriteProfileString(szCurrentINI,szSchemeINI,szBuffer);

        // fill in the schemes for
        // the listbox

        for (i=IDS_FIRSTSCHEME;i<=IDS_LASTSCHEME;i++)
        {
            LoadString(ghmod, i, szBuffer, sizeof(szBuffer));
            p = szBuffer;

            while (*p != '=') p = CharNext(p);
            p2 = CharNext(p);
            *p = '\0';

            WriteProfileString(szSchemeINI,szBuffer,p2);
        }
    }

    //
    // Register the help message from the File Open (Browse) dialog.
    //

    wBrowseHelpMessage = RegisterWindowMessage(HELPMSGSTRING);
    LoadAccelerators(ghmod, MAKEINTRESOURCE(CP_ACCEL));

    /*
     * Load Strings
     */

    if (gszFileNotFound == NULL) {

        gszFileNotFound = GetResourceString(ghmod, IDS_CUR_BADFILE);

        if (gszFileNotFound == NULL) {
            return FALSE;
        }
    }


    if (gszBrowse == NULL) {

        gszBrowse = GetResourceString(ghmod, IDS_CUR_BROWSE);

        if (gszBrowse == NULL) {
            return FALSE;
        }
    }

    if (gszFilter == NULL) {
        gszFilter = GetResourceString(ghmod, IDS_CUR_FILTER);
        if (gszFilter == NULL) {
            return FALSE;
        }
    }

    /*
     * Load description strings from the resource file
     */
    for( i = 0; i < CCURSORS; i++ ) {

        if (gacd[i].idVisName != 0) {
            gacd[i].pszVisName =  GetResourceString(ghmod, gacd[i].idVisName);

            if (gacd[i].pszVisName != NULL) {
                /*
                 * We got a buffer for the string,
                 * clear the string id so we won't try to load it again.
                 */
                gacd[i].idVisName = 0;
            } else {
                /*
                 * Could not get the string.  Use the registry name in this
                 * emergency case.
                 */
                gacd[i].pszVisName = gacd[i].pszIniName;
            }
        }
    }


    /*
     * As an optimization, remember the window handles of the cursor
     * information fields.
     */
    ghwndPreview = GetDlgItem(hwnd, ID_PREVIEW);
    ghwndFile = GetDlgItem(hwnd, ID_FILE);
    ghwndFileH = GetDlgItem(hwnd, ID_FILEH);
    ghwndTitle = GetDlgItem(hwnd, ID_TITLE);
    ghwndTitleH = GetDlgItem(hwnd, ID_TITLEH);
    ghwndCreator = GetDlgItem(hwnd, ID_CREATOR);
    ghwndCreatorH = GetDlgItem(hwnd, ID_CREATORH);
    ghwndLB = GetDlgItem(hwnd, ID_CURSORLIST);
    ghwndSchemeCB = GetDlgItem(hwnd, ID_SCHEMECOMBO);
    /*
     * Create some brushes we'll be using.
     */
    CreateBrushes();

    // ErikGav -
    // Initialize the scheme list box

    InitSchemeComboBox();

    /*
     * Get a nice small font for some of the controls.
     * LATER: How many of these fields do I really need to initialize?
     */
    memset(&lf, 0, sizeof(LOGFONT));
    strcpy(lf.lfFaceName, "Helv");
    lf.lfHeight = 8;
    lf.lfWeight = FW_NORMAL;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    ghfontLabels = CreateFontIndirect(&lf);

    /*
     * Change the font for the info fields.
     */
    SendMessage(ghwndFile, WM_SETFONT, (DWORD)ghfontLabels, FALSE);
    SendMessage(ghwndTitle, WM_SETFONT, (DWORD)ghfontLabels, FALSE);
    SendMessage(ghwndCreator, WM_SETFONT, (DWORD)ghfontLabels, FALSE);

    /*
     * Pre-clear the cursor info array.
     */
    memset(acuri, 0, sizeof(acuri));

    /*
     * Loop through all cursors checking WIN.INI to see if they've been
     * superceded by a 'soft' cursor.  If so, get the soft cursor's filename.
     */
    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++) {

        GetProfileString("Cursors", gacd[i].pszIniName, "", pcuri->szFile,
                sizeof(pcuri->szFile));

        if ( (*(pcuri->szFile) == '\0') || !TryToLoadCursor(hwnd,i,pcuri))
        {
            /*
             * The cursor is either not redirected, or we could not load
             * the file, either way we should use the default system cursor.
             */
            pcuri->hcur = LoadCursor(NULL, gacd[i].idResource);
            GetCursorInfo(pcuri->hcur, NULL, 0, &dwDummy, &pcuri->ccur);
            if (pcuri->ccur > 1) {
                pcuri->fl |= CIF_ANICURSOR;
            }
        }
        SendMessage(ghwndLB, LB_ADDSTRING, 0, i);
    }

    /*
     * Select the first cursor in the list ('Arrow').
     */
    SendMessage(ghwndLB, LB_SETCURSEL, 0, 0);

    /*
     * Force an update of the preview window and the cursor details.
     */
    UpdateCursorList();

    gnMsgLBSelChString = RegisterWindowMessage(LBSELCHSTRING);
    gnMsgFileOK = RegisterWindowMessage(FILEOKSTRING);

    return TRUE;
}



/*****************************************************************************\
* CreateBrushes
*
* Creates the brushes that are used to paint within the Cursors applet.
*
\*****************************************************************************/

VOID
CreateBrushes(
    VOID
    )
{
    ghbrHighlight = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
    gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ghbrHighlightText = CreateSolidBrush(gcrHighlightText);
    ghbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
}



/*****************************************************************************\
* DestroyBrushes
*
* Cleans up the brushes that were used to paint within the Cursors applet.
*
\*****************************************************************************/

VOID
DestroyBrushes(
    VOID
    )
{
    DeleteObject(ghbrHighlight);
    DeleteObject(ghbrHighlightText);
    DeleteObject(ghbrWindow);
}


/*****************************************************************************\
* LPTSTR GetResourceString(HINSTANCE hmod, int id);
*
* Gets a string out of the resouce file.
*
\*****************************************************************************/
LPTSTR GetResourceString(HINSTANCE hmod, int id) {
    TCHAR szBuffer[256];
    LPTSTR psz;
    int cch;

    if ( (cch = LoadString(hmod, id, szBuffer, sizeof(szBuffer) /
            sizeof(TCHAR) )) == 0){
        return NULL;
    }

    psz = LocalAlloc(LPTR, cch * sizeof(TCHAR));

    if (psz != NULL) {
        int i;

        for( i = 0; i <= cch; i++ ) {
            psz[i] = (szBuffer[i] == TEXT('\1')) ?
                    TEXT('\0') : szBuffer[i];
        }
    }

    return psz;
}


/***************************************************************************\
* CursorsDlgProc
*
*
* History:
* 12-22-91 DarrinM      Created.
\***************************************************************************/

INT_PTR CALLBACK
CursorsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CURSORINFO *pcuri;
    DWORD dwDummy;
    HDWP hdwp;
    INT i;

    switch (msg) {
    case WM_INITDIALOG:
        ghwndDlg = hwnd;
        if(!InitCursorsDlg(hwnd)) {
            MessageBox(hwnd, gszNoMem, NULL, MB_ICONSTOP | MB_OK);
            EndDialog(hwnd, 0);
        }
        break;

    case WM_MEASUREITEM:
        ((MEASUREITEMSTRUCT *)lParam)->itemHeight = gcyCursor + 2;
        break;

    case WM_DRAWITEM:
        DrawCursorListItem((DRAWITEMSTRUCT *)lParam);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case ID_SCHEMECOMBO:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                    LoadScheme();
                break;
            }

            break;

        case ID_DEFAULT:
            /*
             * Throw away any fancy new cursor and replace it with the
             * system's original.
             */
            i = SendMessage(ghwndLB, LB_GETCURSEL, 0, 0);
            pcuri = &acuri[i];
            if (!(pcuri->fl & CIF_FILE))
                break;

            pcuri->fl = CIF_MODIFIED;

            if (pcuri->hcur != NULL)
                DestroyCursor(pcuri->hcur);

            pcuri->hcur = GetCursorInfo(NULL, (LPWSTR)gacd[i].idResource, 0,
                &dwDummy, (LPINT)&dwDummy);
            *pcuri->szFile = '\0';

            EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);

            UpdateCursorList();
            break;

        case ID_CURSORLIST:
            switch (HIWORD(wParam)) {
            case LBN_SELCHANGE:
                i = SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                pcuri = &acuri[i];

                /*
                 * Show a preview (including animation) in the preview window.
                 */
                PreviewWndProc(ghwndPreview, PM_NEWCURSOR, 0, (LPARAM)pcuri);

                /*
                 * Show/Hide and update if necessary the information text
                 * controls that show the cursor's filename, title, and
                 * creator.
                 */
                hdwp = BeginDeferWindowPos(6);
                if (pcuri->fl & CIF_TITLE) {
                    SetWindowText(ghwndTitle, pcuri->szTitle);
                    hdwp = DeferWindowPos(hdwp, ghwndTitleH, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndTitle, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                } else {
                    hdwp = DeferWindowPos(hdwp, ghwndTitleH, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndTitle, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                }

                if (pcuri->fl & CIF_CREATOR) {
                    SetWindowText(ghwndCreator, pcuri->szCreator);
                    hdwp = DeferWindowPos(hdwp, ghwndCreatorH, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndCreator, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                } else {
                    hdwp = DeferWindowPos(hdwp, ghwndCreatorH, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndCreator, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                }

                if (pcuri->fl & CIF_FILE) {
                    SetWindowText(ghwndFile, pcuri->szFile);
                    hdwp = DeferWindowPos(hdwp, ghwndFileH, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndFile, NULL, 0, 0, 0, 0,
                        SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                } else {
                    hdwp = DeferWindowPos(hdwp, ghwndFileH, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                    hdwp = DeferWindowPos(hdwp, ghwndFile, NULL, 0, 0, 0, 0,
                        SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE);
                }
                EndDeferWindowPos(hdwp);

                //
                // Enable the "Set Default" button if the cursor is
                // from a file.
                //
                EnableWindow(GetDlgItem(hwnd, ID_DEFAULT),
                    (pcuri->fl & CIF_FILE) ? TRUE : FALSE);

                break;

            case LBN_DBLCLK:
                Browse(hwnd);
                break;
            }
            break;

        case ID_BROWSE:
            Browse(hwnd);
            break;


        case IDD_HELP:
            goto DoHelp;

        case IDOK:
            /*
             * change cursor to hourglass
             */
            HourGlass(TRUE);

            // Save the modified scheme
            SaveScheme();

            /*
             * Save any modified cursor information to WIN.INI.
             */
            for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++) {
//                if (pcuri->fl & CIF_MODIFIED) {
                    WriteProfileString("Cursors", gacd[i].pszIniName,
                        pcuri->fl & CIF_FILE ? pcuri->szFile : NULL);
                    SetSystemCursor(pcuri->hcur, (DWORD)gacd[i].idResource);
//                }
            }

            HourGlass(FALSE);

            /*
             * Free everything.
             */
            CleanUpEverything();

            EndDialog(hwnd, 0L);
            break;

        case IDCANCEL:
            /*
             * Don't leave a mess.
             */
            CleanUpEverything();

            EndDialog(hwnd, 0L);
            break;

        case ID_SAVESCHEME:
            SaveSchemeAs();
            break;

        case ID_REMOVESCHEME:
            RemoveScheme();
            break;
        }
        break;

    case WM_SYSCOLORCHANGE:
        //
        // Recreate the brushes with the new colors.
        //
        DestroyBrushes();
        CreateBrushes();
        break;

    default:
        if (msg == wHelpMessage || msg == wBrowseHelpMessage)
        {
DoHelp:
            CPHelp(hwnd);

            return TRUE;
        }
        else
            return FALSE;

        break;
    }

    return TRUE;
}


/***************************************************************************\
* DrawCursorListItem
*
*
* History:
* 12-22-91 DarrinM      Created.
\***************************************************************************/

void DrawCursorListItem(
    DRAWITEMSTRUCT *pdis)
{
    CURSORINFO *pcuri;
    COLORREF crPrev;

    /*
     * LATER: Deal with focus rect.
     */
    if (pdis->itemAction == ODA_FOCUS)
        return;

    SetBkMode(pdis->hDC, TRANSPARENT);
    pcuri = &acuri[pdis->itemData];

    if (pdis->itemState & ODS_SELECTED) {
        FillRect(pdis->hDC, &pdis->rcItem, ghbrHighlight);
        crPrev = SetTextColor(pdis->hDC, gcrHighlightText);
    } else {
        FillRect(pdis->hDC, &pdis->rcItem, ghbrWindow);
    }
    if (pcuri->hcur != NULL) {
        DrawIcon(pdis->hDC, pdis->rcItem.left + 2, pdis->rcItem.top + 1,
                pcuri->hcur);
    }
    pdis->rcItem.left += gcxCursor + 2 + gcxAvgChar;
    DrawText(pdis->hDC, gacd[pdis->itemData].pszVisName,
            strlen(gacd[pdis->itemData].pszVisName), &pdis->rcItem,
            DT_SINGLELINE | DT_LEFT | DT_VCENTER);

    if (pdis->itemState & ODS_SELECTED) {
        SetTextColor(pdis->hDC, crPrev);
    }
}



/***************************************************************************\
* TryToLoadCursor
*
*
* History:
* 01-28-93 JonPa        Created.
\***************************************************************************/
BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSORINFO *pcuri)
{
    DWORD dwDummy;
    BOOL fRet = TRUE;

    if (!GetCursorFromFile(pcuri)) {
        HWND hwndControl = GetParent(hwnd);
        LPSTR pszText;

        pszText = LocalAlloc(LPTR, strlen(gszFileNotFound) +
                strlen(gacd[i].pszVisName) + strlen(pcuri->szFile));

        if (pszText == NULL)
            return FALSE;

        wsprintf(pszText, gszFileNotFound, pcuri->szFile, gacd[i].pszVisName);

        /* do a little multimedia action here */
        MessageBeep(MB_ICONEXCLAMATION);

        if(MessageBox(hwndControl, pszText, NULL,
                MB_ICONEXCLAMATION | MB_YESNO) == IDYES) {
            /*
             * Cursor file is bad or can't be found.  User wants to
             * reset registry to use the default instead.
             */

            pcuri->fl = CIF_MODIFIED;

            if (pcuri->hcur != NULL)
                DestroyCursor(pcuri->hcur);

            pcuri->hcur = GetCursorInfo(NULL, (LPWSTR)gacd[i].idResource, 0,
                &dwDummy, (LPINT)&dwDummy);

            GetCursorInfo(pcuri->hcur, NULL, 0, &dwDummy, &pcuri->ccur);
            if (pcuri->ccur > 1) {
                pcuri->fl |= CIF_ANICURSOR;
            }

        } else {
            /* load file failed, use the default */
            fRet = FALSE;
        }

        LocalFree(pszText);
    }
    /* Load file worked! Display what we read */
    return fRet;
}

/***************************************************************************\
* GetCursorFromFile
*
*
* History:
* 12-25-91 DarrinM      Created.
* 03-25-93 JonPa        Rewote to use RIFF format
\***************************************************************************/

BOOL GetCursorFromFile(
    CURSORINFO *pcuri)
{
    HANDLE hf;
    RTAG tag;
    DWORD cbRead;
    BOOL fBadCur = FALSE;
    ANIHEADER anih;

    pcuri->fl = 0;

    hf = CreateFile(MakeFilename(pcuri->szFile), GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, 0, NULL);

    if (hf == INVALID_HANDLE_VALUE) {
        pcuri->fl |= CIF_FILE;
        return FALSE;
    }

    /*
     * Determine if this is an .ICO/.CUR file or an .ANI file.
     */
    if (ReadTag(hf, &tag) && tag.ckID == FOURCC_RIFF &&
            ReadFile(hf, &tag.ckID, sizeof(tag.ckID), &cbRead, NULL) &&
            cbRead >= sizeof(tag.ckID) && tag.ckID == FOURCC_ACON) {
        BOOL fNeedANI = TRUE;
        BOOL fNeedInfo = TRUE;

        /*
         * It's an ANICURSOR!
         *
         * Search for each chunk (LIST, anih, rate, seq, and icon).
         * while we search, we will assume the ani file is bad.
         */
        fBadCur = TRUE;
        while((fNeedANI || fNeedInfo) && ReadTag(hf, &tag)) {
            if( tag.ckID == FOURCC_LIST) {
                /* look for type INFO */
                DWORD cbChunk = (tag.ckSize + 1) & ~1;

                if (ReadFile(hf, &tag.ckID, sizeof(tag.ckID), &cbRead, NULL) &&
                        cbRead >= sizeof(tag.ckID) && tag.ckID == FOURCC_INFO){

                    // I think this should be here???
                    cbChunk -= cbRead;

                    /* now look for INAM and IART chunks */

                    while( cbChunk >= sizeof(tag) &&
                                ((pcuri->fl & (CIF_TITLE | CIF_CREATOR)) !=
                                (CIF_TITLE | CIF_CREATOR))) {

                        if (!ReadTag(hf, &tag))
                            goto gcffExit;

                        cbChunk -= sizeof(tag);

                        switch( tag.ckID ) {
                        case FOURCC_INAM:
                            if (cbChunk < tag.ckSize ||
                                    !ReadChunkN(hf, &tag, pcuri->szTitle,
                                    sizeof(pcuri->szTitle)))
                                goto gcffExit;

                            pcuri->fl |= CIF_TITLE;
                            cbChunk -= (tag.ckSize + 1) & ~1;
                            break;

                        case FOURCC_IART:
                            if (cbChunk < tag.ckSize ||
                                    !ReadChunkN(hf, &tag, pcuri->szCreator,
                                    sizeof(pcuri->szCreator)))
                                goto gcffExit;

                            pcuri->fl |= CIF_CREATOR;
                            cbChunk -= (tag.ckSize + 1) & ~1;
                            break;

                        default:
                            cbChunk -= Skip( hf, tag.ckSize );
                            break;
                        }
                    }

                    fNeedInfo = FALSE;

                    if (cbChunk != 0) {
                        // This is right, isn't it?
                        Skip( hf, cbChunk );
                    }

                } else {
                    Skip( hf, cbChunk - cbRead);
                }

            } else if (tag.ckID == FOURCC_anih) {
                if (!ReadChunk(hf, &tag, &anih))
                    goto gcffExit;

                if (!(anih.fl & AF_ICON) || (anih.cFrames == 0))
                    goto gcffExit;

                fNeedANI = FALSE;

            } else {
                Skip(hf, tag.ckSize);
            }
        }

        /* if we get here, it must be a real ani cursor */
        fBadCur = FALSE;
        pcuri->fl |= CIF_ANICURSOR;
    }

gcffExit:
    CloseHandle(hf);

    if (!fBadCur) {
        pcuri->hcur = LoadCursorFromFile(MakeFilename(pcuri->szFile));
        GetCursorInfo(pcuri->hcur, NULL, 0, &cbRead, &pcuri->ccur);
        pcuri->fl |= CIF_FILE;
    }

    return fBadCur ? FALSE : pcuri->hcur != NULL;
}



/***************************************************************************\
* Browse
*
* Browse the file system for a new cursor for the selected item.
*
* History:
* 12-25-91 DarrinM      Created.
\***************************************************************************/

BOOL Browse(
    HWND hwndOwner)
{
    static OPENFILENAME ofn;
    static char szCustomFilter[80];
    CHAR szSystemDir[MAX_PATH];
    CURSORINFO curi;
    int i;
    DWORD dwContextSave;
    HOOKPROC lpfnMsgFilterHookFunc;   // The message filter proc instance.
    BOOL fRet = FALSE;

    /*
     * Hook the message filter stream so that we can detect F1 keystrokes.
     */
    lpfnMsgFilterHookFunc =
            MakeProcInstance((HOOKPROC)MsgFilterHookFunc, ghInst);
    ghhkMsgFilter =
            SetWindowsHook(WH_MSGFILTER, lpfnMsgFilterHookFunc);


    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwndOwner;
    ofn.hInstance = ghmod;
    ofn.lpstrFilter = gszFilter;
    ofn.lpstrCustomFilter = szCustomFilter;
    ofn.nMaxCustFilter = sizeof(szCustomFilter);
    ofn.nFilterIndex = 1;
    gszFileName[0] = 0;
    ofn.lpstrFile = gszFileName;
    ofn.nMaxFile = sizeof(gszFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    GetSystemDirectory(szSystemDir, MAX_PATH);
    ofn.lpstrInitialDir = szSystemDir;
    ofn.lpstrTitle = gszBrowse;
    ofn.Flags = OFN_SHOWHELP | OFN_FILEMUSTEXIST |
        OFN_HIDEREADONLY | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    ofn.lpstrDefExt = NULL;
    ofn.lpfnHook = OpenFileNameHookDlgProc;
    ofn.lpTemplateName = MAKEINTRESOURCE(DLG_FILEOPEN);

    SendDlgItemMessage(hwndOwner, ID_PREVIEW, PM_PAUSEANIMATION, 0, 0);

    dwContextSave = dwContext;
    dwContext = IDH_DLG_CURBROWSE;
    if (!GetOpenFileName(&ofn))
    {
        dwContext = dwContextSave;
        SendDlgItemMessage(hwndOwner, ID_PREVIEW, PM_UNPAUSEANIMATION, 0, 0);
        goto brErrExit;
    }
    dwContext = dwContextSave;

    strcpy(curi.szFile, gszFileName);
    if (!GetCursorFromFile(&curi))
        goto brErrExit;

    i = SendMessage(ghwndLB, LB_GETCURSEL, 0, 0);
    curi.fl |= CIF_MODIFIED;

    EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), TRUE);

    /*
     * Destroy the old cursor before we retain the new one.
     */
    DestroyCursor(acuri[i].hcur);

    acuri[i] = curi;
    UpdateCursorList();
    fRet = TRUE;

brErrExit:

    if (ghhkMsgFilter != NULL) {
        UnhookWindowsHook(WH_MSGFILTER, lpfnMsgFilterHookFunc);
        FreeProcInstance(lpfnMsgFilterHookFunc);
    }
    return fRet;
}



/*****************************************************************************\
* OpenFileNameHookDlgProc
*
* Hook function for the GetOpenFileName common dialog function.
* Used to make the preview window work.
*
\*****************************************************************************/

UINT_PTR CALLBACK
OpenFileNameHookDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static CURSORINFO curiPreview;
    static BOOL fInSelMode;

    if (msg == gnMsgLBSelChString && wParam == lst1)
    {
        fInSelMode = TRUE;
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDOK, 0),
            (LPARAM)GetDlgItem(hwnd, IDOK));
    }
    else if (msg == gnMsgFileOK)
    {
        if (fInSelMode)
        {
            HCURSOR hcurOld;
            PCURSORINFO pcuri;

            hcurOld = curiPreview.hcur;
            strcpy(curiPreview.szFile, gszFileName);
            if (GetCursorFromFile(&curiPreview))
                pcuri = &curiPreview;
            else
                pcuri = NULL;

            if (hcurOld)
            {
                DestroyCursor(hcurOld);
            }

            /*
             * Show a preview (including animation) in the preview window,
             * or else clear the preview window (if pcuri is NULL).
             */
            SendMessage(GetDlgItem(hwnd, ID_PREVIEW), PM_NEWCURSOR,
                0, (LPARAM)pcuri);

            fInSelMode = FALSE;

            //
            // Do NOT close the dialog.
            //
            return 1;
        }
        else
        {
            //
            // OK to close the dialog.
            //
            return 0;
        }
    }
    else
    {
        switch (msg)
        {
            case WM_INITDIALOG:
                curiPreview.hcur = 0;
                fInSelMode = FALSE;
                return TRUE;

            case WM_DESTROY:
                if (curiPreview.hcur)
                {
                    DestroyCursor(curiPreview.hcur);
                    curiPreview.hcur = 0;
                }

                break;
        }
    }

    return FALSE;
}



/***************************************************************************\
* CleanUpEverything
*
* Destroy all the outstanding cursors.
*
* History:
* 12-25-91 DarrinM      Created.
\***************************************************************************/

void CleanUpEverything(void)
{
    CURSORINFO *pcuri;
    int i;

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++) {
        if (pcuri->hcur != NULL)
            DestroyCursor(pcuri->hcur);
    }

    DestroyBrushes();

    DeleteObject(ghfontLabels);
}



/***************************************************************************\
* UpdateCursorList
*
* Force the Cursor ListBox to repaint and the cursor information below the
* listbox to be refreshed as well.
*
* History:
* 12-25-91 DarrinM      Created.
\***************************************************************************/

VOID
UpdateCursorList(
    VOID
    )
{
    InvalidateRect(ghwndLB, NULL, FALSE);
    SendMessage(ghwndDlg, WM_COMMAND, MAKELONG(ID_CURSORLIST, LBN_SELCHANGE),
        (LPARAM)ghwndLB);
}



/***************************************************************************\
* PreviewWndProc
*
*
* History:
* 08-07-92 DarrinM      Created.
\***************************************************************************/

LRESULT CALLBACK
PreviewWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hdc;
    RECT rc;
    int ccur;
    JIF jifRate;
    HCURSOR hcur;
    PAINTSTRUCT ps;
    PPREVIEWDATA ppd;

    switch (msg) {
    case WM_CREATE:
        if (!(ppd = (PPREVIEWDATA)LocalAlloc(LPTR, sizeof(PREVIEWDATA))))
            return -1;

        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)ppd);

        /*
         * Create a temp DC and bitmap to be used for buffering the
         * preview rendering.
         */
        hdc = GetDC(hwnd);
        ppd->hdcMem = CreateCompatibleDC(hdc);
        ppd->hbmMem = CreateCompatibleBitmap(hdc, gcxCursor, gcyCursor);
        ppd->hbmOld = SelectObject(ppd->hdcMem, ppd->hbmMem);
        ppd->pcuri = NULL;
        ReleaseDC(hwnd, hdc);
        break;

    case WM_DESTROY:
        ppd = (PPREVIEWDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        SelectObject(ppd->hdcMem, ppd->hbmOld);
        DeleteObject(ppd->hbmMem);
        DeleteDC(ppd->hdcMem);
        LocalFree(ppd);
        break;

    case PM_NEWCURSOR:
        KillTimer(hwnd, ID_PREVIEWTIMER);
        ppd = (PPREVIEWDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        ppd->pcuri = (PCURSORINFO)lParam;

        if (ppd->pcuri)
        {
            if (ppd->pcuri->fl & CIF_ANICURSOR)
            {
                ppd->pcuri->icur = 0;
                GetCursorInfo(ppd->pcuri->hcur, NULL, 0, &jifRate, &ccur);
                SetTimer(hwnd, ID_PREVIEWTIMER, jifRate * 16, NULL);
            }
        }

        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case PM_PAUSEANIMATION:
        KillTimer(hwnd, ID_PREVIEWTIMER);
        break;

    case PM_UNPAUSEANIMATION:
        NextFrame(hwnd);
        break;

    case WM_TIMER:
        if (wParam != ID_PREVIEWTIMER)
            break;

        NextFrame(hwnd);
        break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);

        ppd = (PPREVIEWDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        if (ppd->pcuri && ppd->pcuri->hcur != NULL)
        {
            rc.left = rc.top = 0;
            rc.right = gcxCursor;
            rc.bottom = gcyCursor;
            FillRect(ppd->hdcMem, &rc, ghbrWindow);

            hcur = GetCursorInfo(ppd->pcuri->hcur, NULL, ppd->pcuri->icur,
                &jifRate, &ccur);
            DrawIcon(ppd->hdcMem, 0, 0, hcur);
            BitBlt(ps.hdc, 0, 0, gcxCursor, gcyCursor, ppd->hdcMem,
                0, 0, SRCCOPY);
        }
        else
        {
            FillRect(ps.hdc, &ps.rcPaint, ghbrWindow);
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_ERASEBKGND:
        break;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0;
}



/*****************************************************************************\
* NextFrame
*
* Sets up for the next frame in the preview window.
*
* Arguments:
*   HWND hwnd - Dialog window handle.
*
\*****************************************************************************/

VOID
NextFrame(
    HWND hwnd
    )
{
    INT ccur;
    JIF jifRate;
    PPREVIEWDATA ppd;

    ppd = (PPREVIEWDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    //
    // Be sure there is a cursor specified.  If not, or it is
    // not an animated cursor, we are done.
    //
    if (!ppd->pcuri || !(ppd->pcuri->fl & CIF_ANICURSOR))
        return;

    if (++(ppd->pcuri->icur) >= ppd->pcuri->ccur)
        ppd->pcuri->icur = 0;

    /*
     * Find how long this frame should be displayed (i.e. get jifRate)
     */
    GetCursorInfo(ppd->pcuri->hcur, NULL, ppd->pcuri->icur, &jifRate, &ccur);
    SetTimer(hwnd, ID_PREVIEWTIMER, jifRate * 16, NULL);

    /*
     * Redraw this frame of the cursor.
     */
    InvalidateRect(hwnd, NULL, FALSE);
}


/***************************************************************************\
* ReadTag, ReadChunk, SkipChunk
*
* Some handy functions for reading RIFF files.
*
* History:
* 10-02-91 DarrinM      Created.
* 03-25-93 Jonpa        Changed to use RIFF format instead of ASDF
\***************************************************************************/
BOOL ReadTag(
    HANDLE hf,
    PRTAG ptag)
{
    DWORD cbActual;

    ptag->ckID = ptag->ckSize = 0L;

    if (!ReadFile(hf, ptag, sizeof(RTAG), &cbActual, NULL) ||
            (cbActual != sizeof(RTAG)))
        return FALSE;

    /* no need to align file pointer since RTAG is already word aligned */
    return TRUE;
}


BOOL ReadChunk(
    HANDLE hf,
    PRTAG ptag,
    PVOID pv)
{
    DWORD cbActual;

    if (!ReadFile(hf, pv, ptag->ckSize, &cbActual, NULL) ||
            (cbActual != ptag->ckSize))
        return FALSE;

    /* WORD align file pointer */
    if( ptag->ckSize & 1 )
        SetFilePointer(hf, 1, NULL, FILE_CURRENT);

    return TRUE;
}


BOOL ReadChunkN(
    HANDLE hf,
    PRTAG ptag,
    PVOID pv,
    DWORD cbMax)
{
    DWORD cbActual;
    DWORD cbRead = min( cbMax, ptag->ckSize );

    if (!ReadFile(hf, pv, ptag->ckSize, &cbActual, NULL) ||
            (cbActual != cbRead))
        return FALSE;

    /* WORD align file pointer */

    // this is right isn't it?
    cbRead = ptag->ckSize - cbActual;

    if( ptag->ckSize & 1 )
        cbRead++;

    return SetFilePointer(hf, cbRead, NULL, FILE_CURRENT) != 0xFFFFFFFF;
}

DWORD Skip(
    HANDLE hf,
    DWORD cbSkip)
{
    /* Round cbSize up to nearest word boundary to maintain alignment */
    DWORD cb = (cbSkip + 1) & ~1;

    if (SetFilePointer(hf, cb, NULL, FILE_CURRENT) == 0xFFFFFFFF)
        cb = 0;

    return cb;
}



/***************************************************************************\
* HourGlass
*
* Turn hourglass cursor on or off.
*
* History:
* 07-30-92 DarrinM      Pulled from control\main\util.c
\***************************************************************************/

void HourGlass(BOOL fOn)
{
   if (!GetSystemMetrics (SM_MOUSEPRESENT))
      ShowCursor (fOn);

   SetCursor (LoadCursor (NULL, fOn ? IDC_WAIT : IDC_ARROW));
}

/************************************************************************
* MsgFilterHookFunc
*
* This is the exported message filter function that is hooked into
* the message stream for detecting the pressing of the F1 key, at
* which time it calls up the appropriate help.
*
* Arguments:
*
* History:
*
************************************************************************/

DWORD FAR PASCAL MsgFilterHookFunc(
    INT nCode,
    WPARAM wParam,
    LPMSG lpMsg)
{
    if ((nCode == MSGF_MENU || nCode == MSGF_DIALOGBOX) &&
            (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1)) {
        /*
         * Display help.
         */
        CPHelp(lpMsg->hwnd);

        /*
         * Tell Windows to swallow this message.
         */
        return 1;
    }

    return DefHookProc(nCode, wParam, (LONG)lpMsg, &ghhkMsgFilter);
}

/***************************************************************************\
* Scheme Functions
*
* History:
* 04-10-93 ErikGav Created
\***************************************************************************/

BOOL SaveSchemeAs()
{
    BOOL fSuccess=TRUE;
    LRESULT lr;

    // dialog proc returns TRUE & sets filename entered
    // to gszSchemeName if OK clicked

    if (DialogBox (ghmod, MAKEINTRESOURCE(DLG_SCHEMESAVE), ghwndDlg, SaveSchemeDlgProc))
    {
        lr = SendMessage(ghwndSchemeCB,CB_FINDSTRINGEXACT,0xFFFF,(LPARAM) gszSchemeName);

        // if not found, add it

        if (lr==CB_ERR)
        {
            lr = SendMessage(ghwndSchemeCB,CB_ADDSTRING,0,(LPARAM) gszSchemeName);
        }

        // select the name

        SendMessage(ghwndSchemeCB,CB_SETCURSEL,(WPARAM) lr,0);

        fSuccess=SaveScheme();
    }

    return fSuccess;
}

BOOL SaveScheme()
{
    const BUFFER_SIZE = CCURSORS * (FILENAME_MAX+1) + 1;
    char pszSchemeName[MAX_SCHEME_NAME_LEN+1];
    LPSTR pszBuffer;
    BOOL fSuccess=TRUE;
    int i;

    // allocate buffer for string
    pszBuffer = (LPSTR) LocalAlloc(LMEM_FIXED,BUFFER_SIZE);
    if (pszBuffer==NULL) return FALSE;

    // get current scheme name
    GetWindowText(ghwndSchemeCB,pszSchemeName,sizeof(pszSchemeName));

    // store in registry
    fSuccess = WriteProfileString(szCurrentINI,szSchemeINI,pszSchemeName);

    // concatenate the filenames into a string, write it to the registry
    pszBuffer[0]='\0';
    for (i = 0; i < CCURSORS; i++)
    {
        lstrcat(pszBuffer,acuri[i].szFile);
        lstrcat(pszBuffer,",");
    }

    pszBuffer[lstrlen(pszBuffer)-1]='\0';  // strip last comma

    fSuccess &= WriteProfileString(szSchemeINI,pszSchemeName,pszBuffer);

    LocalFree(pszBuffer);

    if (fSuccess)
    {
        EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), FALSE);
    }

    return fSuccess;
}

BOOL LoadScheme()
{
    const BUFFER_SIZE = CCURSORS * (FILENAME_MAX+1) + 1;
    char pszSchemeName[MAX_SCHEME_NAME_LEN+1];
    LPSTR pszBuffer;
    BOOL fSuccess=TRUE;
    LPSTR pszFile;
    LPSTR pszNextFile;
    BOOL fEOL=FALSE;
    LRESULT lr;
    int i=0;

    // allocate buffer for cursor paths
    pszBuffer = (LPSTR) LocalAlloc(LMEM_FIXED,BUFFER_SIZE);
    if (pszBuffer==NULL) return FALSE;

    HourGlass(TRUE);

    // get current scheme name
    GetWindowText(ghwndSchemeCB,pszSchemeName,sizeof(pszSchemeName));

    // read cursor paths from the registry
    GetProfileString(szSchemeINI,pszSchemeName,"",pszBuffer,BUFFER_SIZE);

    // parse string of format "filename1,filename2,filename3..."
    // into cursor info array

    pszFile=pszBuffer;

    do
    {
        pszNextFile=pszFile;
        while (*pszNextFile!='\0')
        {
            if (*pszNextFile==',')
                break;

            pszNextFile=CharNext(pszNextFile);
        }

        if (*pszNextFile=='\0') fEOL=TRUE;
        else *pszNextFile='\0';

        if (lstrcmp(pszFile,acuri[i].szFile))
        {
            // it's different than current, update

            lstrcpy(acuri[i].szFile,pszFile);
            fSuccess &= SchemeUpdate(i);
        }

        pszFile = pszNextFile;

        if (!fEOL) pszFile++;   // skip '\0' and move to next path

        i++;
    } while (i < CCURSORS);

    LocalFree(pszBuffer);

    // select "Arrow" in list box
    lr = SendMessage(ghwndLB, LB_GETCURSEL, 0, 0);      // avoid a "flash"
    if (lr!=0)
    {
        SendMessage(ghwndLB, LB_SETCURSEL, 0, 0);
    }

    // repaint
    UpdateCursorList();

    // disable the SAVE button
    EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), FALSE);

    HourGlass(FALSE);

    return fSuccess;
}

// helper function --
// updates the cursor at index i
// in acuri
BOOL SchemeUpdate(int i)
{
    DWORD dwDummy;
    BOOL fSuccess=TRUE;

    if (acuri[i].hcur != NULL)
    {
        DestroyCursor(acuri[i].hcur);
    }

    acuri[i].fl = CIF_MODIFIED;

    // if "Set Default"
    if (*(acuri[i].szFile) == '\0')
    {
        acuri[i].hcur = GetCursorInfo(NULL, (LPWSTR)gacd[i].idResource, 0, &dwDummy, (LPINT)&dwDummy);
    }
    else
    {
        fSuccess=TryToLoadCursor(ghwndDlg,i,&acuri[i]);
    }

    return fSuccess;
}

BOOL RemoveScheme()
{
    char pszSchemeName[MAX_SCHEME_NAME_LEN+1];
    LRESULT lr;
    char RemoveMsg[PATHMAX];
    char DialogMsg[PATHMAX];

    GetWindowText(ghwndSchemeCB,pszSchemeName,sizeof(pszSchemeName));

    if (*pszSchemeName=='\0')
    {
        return FALSE;
    }

    // put up a warning dialog

    LoadString (ghmod, IDS_REMOVESCHEME, RemoveMsg, PATHMAX);
    wsprintf(DialogMsg, RemoveMsg, (LPSTR) pszSchemeName);

//    DebugBreak();

    LoadString (ghmod, IDS_NAME, RemoveMsg, PATHMAX);

    if (MessageBox (ghwndDlg, DialogMsg, RemoveMsg, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
        return TRUE;

    // delete from registry
    WriteProfileString(szSchemeINI,pszSchemeName,"");

    // delete from list box
    lr = SendMessage(ghwndSchemeCB, CB_FINDSTRINGEXACT, 0xFFFF, (LPARAM) pszSchemeName);
    SendMessage(ghwndSchemeCB, CB_DELETESTRING, (WPARAM) lr, 0);

    // set new selection
    SendMessage(ghwndSchemeCB, CB_SETCURSEL, 0, 0);

    // Refresh everything
    return LoadScheme();
}

BOOL InitSchemeComboBox()
{
    const BUFFER_SIZE=4096;
    LPSTR pszBuffer, pszSchemeNames;
    LRESULT lr;
    BOOL fSuccess=TRUE;

    // allocate a buffer for the scheme names

    pszBuffer = (LPSTR) LocalAlloc(LMEM_FIXED,BUFFER_SIZE);
    if (pszBuffer==NULL) return FALSE;

    pszSchemeNames=pszBuffer;

    // copy the scheme names

    GetProfileString(szSchemeINI,NULL,"",pszSchemeNames,BUFFER_SIZE);

    // add each scheme name to the combo box

    while (*pszSchemeNames!='\0')
    {
        SendMessage(ghwndSchemeCB,CB_ADDSTRING,0,(LPARAM)pszSchemeNames);

        while (*pszSchemeNames!='\0')
        {
            pszSchemeNames=CharNext(pszSchemeNames);  // skip to next string
        }

        pszSchemeNames++;   // skip '\0' between strings
    }

    // determine which scheme is currently selected by the user

    GetProfileString(szCurrentINI,szSchemeINI,"",pszBuffer,BUFFER_SIZE);

    // try and find it in the combobox

    lr = SendMessage(ghwndSchemeCB,CB_FINDSTRINGEXACT,0xFFFF,(LPARAM) pszBuffer);

    // if found, select it

    if (lr!=CB_ERR)
    {
        SendMessage(ghwndSchemeCB,CB_SETCURSEL,(WPARAM) lr,0);
        fSuccess=LoadScheme();
    }
    else
    {
        // scheme was not found
        // set text to nothing
        SetWindowText(ghwndSchemeCB,"");

        // and disable the REMOVE/SAVE buttons
        EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), FALSE);
        EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), FALSE);
    }

    LocalFree(pszBuffer);

    return fSuccess;
}

INT_PTR CALLBACK SaveSchemeDlgProc(HWND  hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    char    szSchemeName[MAX_SCHEME_NAME_LEN+1];

    switch (message)
    {
    case WM_INITDIALOG:

        HourGlass (TRUE);

        GetWindowText(ghwndSchemeCB,szSchemeName,sizeof(szSchemeName));

        SetDlgItemText (hWnd, ID_SCHEMEFILENAME,  szSchemeName);
        SendDlgItemMessage (hWnd, ID_SCHEMEFILENAME, EM_SETSEL, 0, 32767);
        SendDlgItemMessage (hWnd, ID_SCHEMEFILENAME, EM_LIMITTEXT, MAX_SCHEME_NAME_LEN, 0L);
        EnableWindow (GetDlgItem (hWnd, IDOK), szSchemeName[0] != '\0');
        HourGlass (FALSE);
        return (TRUE);

        break;

    case WM_COMMAND:

        switch (LOWORD (wParam))
        {
        case ID_SCHEMEFILENAME:
            if (HIWORD (wParam) == EN_CHANGE)
            {
                EnableWindow (GetDlgItem (hWnd, IDOK),
                    GetDlgItemText (hWnd, ID_SCHEMEFILENAME,  szSchemeName, 2));
            }
            break;

        case IDD_HELP:
            goto DoHelp;

        case IDOK:

            GetDlgItemText (hWnd, ID_SCHEMEFILENAME,  szSchemeName, MAX_SCHEME_NAME_LEN);
            StripBlanks (szSchemeName);

            if (*szSchemeName=='/0')
            {
                MessageBeep(0);
                break;
            }

            lstrcpy (gszSchemeName,  szSchemeName);

        // fall through...

        case IDCANCEL:

            EndDialog (hWnd, LOWORD (wParam) == IDOK);
            return (TRUE);
        }

    default:

        if (message == wHelpMessage)
        {
DoHelp:
            CPHelp (hWnd);
            return TRUE;
        }
        else
            return FALSE;
    }
    return (FALSE);  // Didn't process a message
}

// returns Filename with a default path in system directory
// if no path is already specified
LPSTR MakeFilename(LPSTR sz)
{
    if (sz[0]=='\\' || sz[1]==':')
    {
        return sz;
    }
    else
    {
        GetSystemDirectory(gszFileName2,sizeof(gszFileName2));
        lstrcat(gszFileName2,"\\");
        lstrcat(gszFileName2,sz);

        return gszFileName2;
    }
}


/* StripBlanks()
   Strips leading and trailing blanks from a string.
   Alters the memory where the string sits.

   ErikGav- Stolen from \control\main\util.c
*/

void StripBlanks (LPSTR pszString)
{
    LPSTR pszPosn;

    /* strip leading blanks */
    pszPosn = pszString;
    while(*pszPosn == ' ')
    {
        pszPosn++;
    }

    if (pszPosn != pszString);
        strcpy (pszString, pszPosn);

    /* strip trailing blanks */
    if ((pszPosn=pszString + strlen (pszString)) != pszString)
    {
       pszPosn = CharPrev (pszString, pszPosn);
       while(*pszPosn == ' ')
           pszPosn = CharPrev (pszString, pszPosn);
       pszPosn = CharNext (pszPosn);
       *pszPosn = '\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\bezier\bezdlg.h ===
#define     ID_VELOCITY         100
#define     ID_DENSITYARROW     102
#define     ID_VELOCITY_FAST    104
#define     ID_VELOCITY_SLOW    105


#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

#define DLG_SCRNSAVECONFIGURE   2003

#define ID_LENGTH               2004
#define ID_LENGTHARROW          2005
#define ID_WIDTH		        2006
#define ID_WIDTHARROW		    2007
#define ID_LENGTH_LABEL         2008
#define ID_WIDTH_LABEL          2009

//
// Help IDs
//
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH          4213
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH           4214
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED           4215
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\bezier\strings.h ===
#include "..\common\comstrin.h"

#define idsDescription    1
#define idsName         100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\common\comstrin.h ===
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

#define DLG_SCRNSAVECONFIGURE   2003

#include "cphelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\schemes\makefile.inc ===
..\..\..\windows\inc\winuserp.h : ..\..\..\windows\inc\winuserp.x
    wcshdr < ..\..\..\windows\inc\winuserp.x > ..\..\..\windows\inc\winuserp.h


..\..\..\windows\inc\winuser.x ..\..\..\windows\inc\winuserp.x: ..\..\..\windows\inc\winuser.w
    hsplit -o ..\..\..\windows\inc\winuser.x ..\..\..\windows\inc\winuserp.x ..\..\..\windows\inc\winuser.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\bezier\ssbezier.c ===
/*

SSBEZIER.C

Bezier screensaver.

  History:
       10/14/91        kentd  Wrote for Windows NT.  Hacked from WinBez.

*/

#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "bezdlg.h"
#include "strings.h"
#include "uniconv.h"
#include "stdlib.h"

#undef OVERFLOW
#undef UNDERFLOW

#include "math.h"


#define INT int

#if !defined(_ALPHA_)
// floating point always initialized on ALPHA and ALPHA64
VOID _fltused(VOID) {}
#endif

// routines from bez.c

VOID vInitPoints();
VOID vRedraw();
VOID vNextBez();
LONG GetDlgItemLong(HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned);
VOID GetIniEntries(VOID);
VOID vInitPalette(HDC);
VOID vNewColor(VOID);
LONG GetPrivateProfileLong(LPTSTR pszApp, LPTSTR pszKey, LONG lDefault);

typedef struct _STR
{
    PSZ     psz;
    SIZE    sz;
    SHORT   c;
    BYTE    f;
} STR;

typedef struct _inst
{
    ULONG i;
    POINT pt;
    POINT ptVel;
    LONG  c;
} INST, *PINST;


typedef struct _WINDOW {
    HWND hwnd;
    HDC hdc;
    HANDLE hWait;
    int xsize;
    int ysize;
    HPALETTE hpalette;

    // frame data

    HBITMAP hbitmap;
    HDC hdcBitmap;
    PBYTE pdata;
    RECT rcBlt;
    RECT rcDraw;
    int xDelta;
    int yDelta;

    // text data

    HBITMAP hbitmapText;
    HDC hdcText;
    PBYTE pdataText;
} WINDOW, *PWINDOW;

PWINDOW gpwindow;
BOOL fRepaint = TRUE;

//
// Length is the number of beziers in each loop
// Width is the number of times each bezier loop is drawn
//

#define MINLENGTH     1
#define MAXLENGTH     10
#define DEF_LENGTH    4
#define MINWIDTH      1
#define MAXWIDTH      100
#define DEF_WIDTH     30
#define MINVEL        2
#define DEFVEL        10
#define MAXVEL        20
#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define NEWVEL (ulRandom() % (MAXVEL / 2 - MINVEL) + MINVEL)


HDC     ghdc;
HPEN    ghpenBez;
HPEN    ghpenErase;
HBRUSH  ghbrushBack;
DWORD   glSeed;
LONG    gcxScreen;
LONG    gcyScreen;
LONG    gczScreen;
LONG    gcPoints;
HDC     hdcBM;
HBITMAP hbm;
PINST   ainst;
BOOL    gbPointsDrawn;
LONG    giVelMax  =  DEFVEL;
LONG    gcBez     =  DEF_WIDTH;
LONG    gcRingLen =  DEF_LENGTH;
STR    *astr      = NULL;
BOOL    bInit     = FALSE;
int     cstr      = 0;
ULONG   ic        = 0;
BYTE    gf        = 0xff;
BOOL    gbCopy    = TRUE;
BOOL    gbPalette = FALSE;
HPALETTE ghpal    = 0;
HPALETTE ghpalOld = 0;

#define NUM_PALETTE_ENTRIES 10
#define FADE_RESOLUTION     24
#define MAX_TICKS_WIMPY     1000
#define MAX_TICKS_COOL      100

PALETTEENTRY gapal[NUM_PALETTE_ENTRIES * FADE_RESOLUTION];
PALETTEENTRY gapalDefault[NUM_PALETTE_ENTRIES + 1] =
                              { {255, 0,   0},   {128, 0,   0},
                                {0,   128, 0},   {128, 128, 0},
                                {0,   0,   128}, {128, 0,   128},
                                {0,   128, 128}, {128, 128, 128},
                                {192, 192, 192}, {255, 0,   0},
                                {0,   0,   0} };

LONG gipal;
LONG gcpal;
LONG gcTicker;
LONG gcMaxTicks;

// Structures:

typedef struct _BAND {
    POINT apt[2];
} BAND;

typedef struct _BEZ {
    BAND band[MAXLENGTH];
    BOOL bDrawn;
} BEZ, *PBEZ;

BEZ bezbuf[MAXWIDTH];
PBEZ gpBez;

POINT aPts[MAXLENGTH * 3 + 1];
POINT aVel[MAXLENGTH][2];

TCHAR  szLineSpeed [] = TEXT("LineSpeed");  // .INI Line Speed key

TCHAR  szNumBez [] = TEXT("Width");         // .INI Width key

TCHAR  szNumRings [] = TEXT("Length");      // .INI Length key

BOOL Init(HWND);

BYTE mask = 0;

//
// Help IDs
//
DWORD aBezDlgHelpIds[] = {
    65535,                  ((DWORD) -1),
    ID_LENGTH_LABEL,        IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_LENGTH,              IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_LENGTHARROW,         IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_WIDTH_LABEL,         IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_WIDTH,               IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_WIDTHARROW,          IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_VELOCITY,            IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    ID_VELOCITY_SLOW,       IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    ID_VELOCITY_FAST,       IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    0,0
};

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static UINT_PTR  wTimer;
    TCHAR   szTemp[20];                     // Temporary string buffer
    int i;
    BYTE bit;

    switch (message)
    {
    case WM_CREATE:
        GetIniEntries ();
        glSeed = GetCurrentTime ();     // random number generator

        ghdc = GetDC(hWnd);

        gcxScreen =  ((LPCREATESTRUCT)lParam)->cx;
        gcyScreen =  ((LPCREATESTRUCT)lParam)->cy;

        vInitPoints();

        if (gczScreen & (1 << 14)) {
            Init(hWnd);
        } else {
            ghbrushBack = GetStockObject(BLACK_BRUSH);
            ghpenBez    = CreatePen(PS_SOLID, 0, 0xff);
            ghpenErase  = CreatePen(PS_SOLID, 0, 0);
            SelectObject(ghdc,ghpenBez);
            SelectObject(ghdc,ghbrushBack);

            vInitPalette(ghdc);
            wTimer = SetTimer (hWnd, 1, 1, NULL);
        }
        break;

    case WM_SIZE:
        gcxScreen = LOWORD(lParam);
        gcyScreen = HIWORD(lParam);
        break;

    case WM_PALETTECHANGED:
        RealizePalette(ghdc);
        break;

    case WM_QUERYNEWPALETTE:
        if (ghpal != 0)
        {
            SelectPalette(ghdc, ghpal, FALSE);
            RealizePalette(ghdc);
            InvalidateRect(hWnd, NULL, TRUE);

            return(TRUE);
        }
        else
            return(FALSE);

    case WM_PAINT:
        if (gczScreen & (1 << 14)) {
            PAINTSTRUCT paint;
            BeginPaint(hWnd, &paint);
            EndPaint(hWnd, &paint);
            fRepaint = TRUE;
        } else {
            vRedraw();
        }
        break;

    case WM_TIMER:
        if (gczScreen & (1 << 14)) {
            SetEvent(gpwindow->hWait);
        } else {
            vNextBez();
        }
        break;

    case WM_DESTROY:
        if (wTimer)
            KillTimer (hWnd, wTimer);

        if (ghpal != 0)
        {
            SelectPalette(ghdc, ghpalOld, FALSE);
            DeleteObject(ghpal);
        }
        ReleaseDC(hWnd, ghdc);
        break;
    }
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL    fError;                         // Error flag

    UINT    wTemp;
    TCHAR   szTemp[20];                     // Temporary string buffer
    char    szTemp2[20];                    // Temporary string buffer

    WORD    nCtlId;
    int     nVal, nOldVal;
    LONG   *plState = (LONG *) szTemp2;     // State buffer

    static HWND hVelocity,         // window handle of Speed scrollbar
                hIDOK,             // window handle of OK button
                hSetPassword,      // window handle of SetPassword button
                hNumBeziers,       // window handle of NumBezier EditControl
                hNumRings;         // window handle of NumBezier EditControl


    switch (message)
    {
    case WM_INITDIALOG:
        GetIniEntries ();        // Get initial values

        hVelocity = GetDlgItem (hDlg, ID_VELOCITY);
        hIDOK = GetDlgItem (hDlg, IDOK);
        hNumBeziers = GetDlgItem (hDlg, ID_WIDTH);
        hNumRings = GetDlgItem (hDlg, ID_LENGTH);

        SendMessage (hNumBeziers, EM_LIMITTEXT, 3, 0);
        SendMessage (hNumRings, EM_LIMITTEXT, 3, 0);
        SetScrollRange (hVelocity, SB_CTL, MINVEL, MAXVEL, FALSE);
        SetScrollPos (hVelocity, SB_CTL, giVelMax, TRUE);

        SetDlgItemInt (hDlg, ID_WIDTH, gcBez, FALSE);
        SetDlgItemInt (hDlg, ID_LENGTH, gcRingLen, FALSE);

        SendDlgItemMessage( hDlg, ID_LENGTHARROW, UDM_SETRANGE, 0, MAKELONG(MAXLENGTH, MINLENGTH));
        SendDlgItemMessage( hDlg, ID_WIDTHARROW, UDM_SETRANGE, 0, MAKELONG(MAXWIDTH, MINWIDTH));

        wsprintf (szTemp, TEXT("%d"), gcBez);
        WritePrivateProfileString (szAppName, szNumBez, szTemp, szIniFile);
        return TRUE;


    case WM_HSCROLL:
        switch (LOWORD(wParam))
        {
        case SB_PAGEUP:
            --giVelMax;
            break;

        case SB_LINEUP:
            --giVelMax;
            break;

        case SB_PAGEDOWN:
            ++giVelMax;
            break;

        case SB_LINEDOWN:
            ++giVelMax;
            break;

        case SB_THUMBPOSITION:
            giVelMax = HIWORD (wParam);
            break;

        case SB_BOTTOM:
            giVelMax = MAXVEL;
            break;

        case SB_TOP:
            giVelMax = MINVEL;
            break;

        case SB_THUMBTRACK:
        case SB_ENDSCROLL:
            return TRUE;
            break;
        }
        if ((int)giVelMax <= MINVEL)
            giVelMax = MINVEL;
        if ((int)giVelMax >= MAXVEL)
            giVelMax = MAXVEL;

        SetScrollPos ((HWND) lParam, SB_CTL, giVelMax, TRUE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_LENGTH:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_LENGTH, &fError, FALSE);
                fError = ((wTemp <= MAXLENGTH) && (wTemp >= MINLENGTH));
                EnableWindow (GetDlgItem (hDlg, ID_LENGTHARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;

        case ID_WIDTH:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_WIDTH, &fError, FALSE);
                fError = ((wTemp <= MAXWIDTH) && (wTemp >= MINWIDTH));
                EnableWindow (GetDlgItem (hDlg, ID_WIDTHARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;


        case IDOK:
            wTemp = GetDlgItemInt (hDlg, ID_WIDTH, &fError, FALSE);
            wTemp |= GetPrivateProfileInt (szAppName, szNumBez, DEF_WIDTH, szIniFile) & (1 << 14);
            wsprintf (szTemp, TEXT("%d"), wTemp);

            WritePrivateProfileString (szAppName, szNumBez, szTemp, szIniFile);

            wTemp = GetDlgItemInt (hDlg, ID_LENGTH, &fError, FALSE);
            wsprintf (szTemp, TEXT("%d"), wTemp);
            WritePrivateProfileString (szAppName, szNumRings, szTemp, szIniFile);

            wsprintf (szTemp, TEXT("%d"), giVelMax);
            WritePrivateProfileString (szAppName, szLineSpeed, szTemp, szIniFile);

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aBezDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aBezDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


/* This procedure is called right before the dialog box above is created in
   order to register any child windows that are custom controls.  If no
   custom controls need to be registered, then simply return TRUE.
   Otherwise, register the child controls however is convenient... */

BOOL RegisterDialogClasses (HANDLE hInst)
{
    InitCommonControls();
    return TRUE;
}


LONG GetDlgItemLong (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned)
{
    TCHAR szTemp[20];
    LPTSTR pszTemp;
    LONG lTemp = 0l;
    BOOL fNegative;

    if (!GetDlgItemText (hDlg, wID, szTemp, CharSizeOf(szTemp)))
        goto GetDlgItemLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp == TEXT(' ') || *pszTemp == TEXT('\t'))
        pszTemp++;
    if ((!fSigned && *pszTemp == TEXT('-')) || !*pszTemp)
        goto GetDlgItemLongError;
    fNegative = (*pszTemp == TEXT('-')) ? TRUE : FALSE;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetDlgItemLongError;
    if (fNegative)
        lTemp *= -1;
    *pfTranslated = TRUE;
    return lTemp;

GetDlgItemLongError:
    *pfTranslated = FALSE;
    return 0l;
}


LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault)
{
    LONG    lTemp = 0l;
    TCHAR   szTemp[20];
    LPTSTR  pszTemp;

    if (!GetPrivateProfileString (pszApp, pszKey, TEXT(""), szTemp, CharSizeOf(szTemp), szIniFile))
        goto GetProfileLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetProfileLongError;
    return lTemp;

GetProfileLongError:
    return lDefault;
}


VOID GetIniEntries (VOID)
{
    LoadString (hMainInstance, idsName, szName, TITLEBARNAMELEN);
    LoadString (hMainInstance, idsAppName, szAppName, APPNAMEBUFFERLEN);

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, MAXFILELEN);
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, 22);
    LoadString (hMainInstance, idsHelpFile, szHelpFile, MAXFILELEN);
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, BUFFLEN);

    giVelMax = GetPrivateProfileInt (szAppName, szLineSpeed, DEFVEL, szIniFile);
    if (giVelMax > MAXVEL || giVelMax < MINVEL)
        giVelMax = DEFVEL;

    gcBez = GetPrivateProfileInt (szAppName, szNumBez, DEF_WIDTH, szIniFile);
    gcBez = (gczScreen = gcBez) & ~(1 << 14);

    if (gcBez > MAXWIDTH)
        gcBez = MAXWIDTH;
    if (gcBez < MINWIDTH)
        gcBez = MINWIDTH;

    gcRingLen = GetPrivateProfileInt (szAppName, szNumRings, DEF_LENGTH, szIniFile);
    if (gcRingLen > MAXLENGTH)
        gcRingLen = MAXLENGTH;
    if (gcRingLen < MINLENGTH)
        gcRingLen = MINLENGTH;
}



/************************************************************************
* Bezier code
*
* Created: 19-Oct-1990 10:18:45
* Author: Paul Butzi
*
* Copyright (c) 1990 Microsoft Corporation
*
* Generates random lines
*    Hacked from arcs.c
\**************************************************************************/


DWORD ulRandom()
{
    glSeed *= 69069;
    glSeed++;
    return(glSeed);
}


VOID vCLS()
{
    PatBlt(ghdc, 0, 0, gcxScreen, gcyScreen, PATCOPY);
}

int iNewVel(INT i)
{

    if ((gcRingLen != 1) || (i == 1) || (i == 2))
        return(ulRandom() % (giVelMax + 1 / 3) + MINVEL);
    else
        return(ulRandom() % giVelMax + MINVEL);
}



VOID vInitPoints()
{
    INT ii;

    for (ii = 0; ii < MAXLENGTH; ii++)
    {
        bezbuf[0].band[ii].apt[0].x = gcxScreen ? ulRandom() % gcxScreen : 0;
        bezbuf[0].band[ii].apt[0].y = gcyScreen ? ulRandom() % gcyScreen : 0;
        bezbuf[0].band[ii].apt[1].x = gcxScreen ? ulRandom() % gcxScreen : 0;
        bezbuf[0].band[ii].apt[1].y = gcyScreen ? ulRandom() % gcyScreen : 0;

        aVel[ii][0].x = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
        aVel[ii][0].y = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
        aVel[ii][1].x = iNewVel(ii) * ((ulRandom() & 0x11) ? 1 : -1);
        aVel[ii][1].y = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
    }

    gpBez = bezbuf;
}


VOID vRedraw()
{
    INT j;

    for ( j = 0; j < gcBez; j += 1 )
    {
        bezbuf[j].bDrawn = FALSE;
    }

    vCLS();
    gpBez = bezbuf;
    gbPointsDrawn = FALSE;
}


/******************************Public*Routine******************************\
* VOID vDrawBand(pbez)
*
* History:
*  14-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDrawBand(PBEZ pbez)
{
    INT    ii;
    INT    iNext;
    PPOINT ppt;

// If only drawing one Bezier, special case it:

    if (gcRingLen == 1)
    {
        aPts[0] = pbez->band[0].apt[0];
        aPts[1] = pbez->band[0].apt[1];
        aPts[2] = pbez->band[1].apt[0];
        aPts[3] = pbez->band[1].apt[1];
    }
    else
    {

    // Do the elastic band effect, with 2nd order continuity:

        aPts[0].x = (pbez->band[0].apt[0].x + pbez->band[0].apt[1].x) >> 1;
        aPts[0].y = (pbez->band[0].apt[0].y + pbez->band[0].apt[1].y) >> 1;

        ppt = &aPts[1];

        for (ii = 0; ii < gcRingLen; ii++)
        {
            iNext = (ii + 1) % gcRingLen;

            *ppt++ = pbez->band[ii].apt[1];
            *ppt++ = pbez->band[iNext].apt[0];

            ppt->x = (pbez->band[iNext].apt[0].x + pbez->band[iNext].apt[1].x) >> 1;
            ppt->y = (pbez->band[iNext].apt[0].y + pbez->band[iNext].apt[1].y) >> 1;
            ppt++;
        }
    }

    PolyBezier(ghdc, aPts, gcRingLen * 3 + 1);
}


/******************************Public*Routine******************************\
* VOID vNextBez()
*
\**************************************************************************/

VOID vNextBez()
{
    INT ii;
    INT jj;

    PBEZ obp = gpBez++;

    if ( gpBez >= &bezbuf[gcBez] )
        gpBez = bezbuf;

// If bezier on screen, erase by redrawing:

    if (gpBez->bDrawn)
    {
        if (gbCopy)
            SelectObject(ghdc, ghpenErase);

        vDrawBand(gpBez);
    }

// Adjust points:

    for (ii = 0; ii < MAX(gcRingLen, 2); ii++)
    {
        for (jj = 0; jj < 2; jj++)
        {
            register INT x, y;

            x = obp->band[ii].apt[jj].x;
            y = obp->band[ii].apt[jj].y;

            x += aVel[ii][jj].x;
            y += aVel[ii][jj].y;

            if ( x >= gcxScreen )
            {
                x = gcxScreen - ((x - gcxScreen) + 1);
                aVel[ii][jj].x = - iNewVel(ii);
            }
            if ( x < 0 )
            {
                x = - x;
                aVel[ii][jj].x = iNewVel(ii);
            }
            if ( y >= gcyScreen )
            {
                y = gcyScreen - ((y - gcyScreen) + 1);
                aVel[ii][jj].y = - iNewVel(ii);
            }
            if ( y < 0 )
            {
                y = - y;
                aVel[ii][jj].y = iNewVel(ii);
            }

            gpBez->band[ii].apt[jj].x = x;
            gpBez->band[ii].apt[jj].y = y;
        }
    }

    vNewColor();

    if (gbCopy)
        SelectObject(ghdc, ghpenBez);

    vDrawBand(gpBez);
    gpBez->bDrawn = TRUE;
}


ULONG iGet()
{
    static int i = 0;
           int j;
    if (++i >= cstr)
        i = 1;
    j = i;
    while (astr[i].f == gf) {i = (i % (cstr - 1)) + 1; if (i == j) gf = ~gf;}
    astr[i].f = ~astr[i].f;
    return(i);
}

VOID vInitPalette(HDC hdc)
{
    LOGPALETTE    lp;
    HPALETTE      hpalOld = 0;
    PALETTEENTRY *ppal;
    LONG          cBitsPerPel;
    LONG          i;
    LONG          j;

    cBitsPerPel = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    gbPalette = (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) > 0;

    if (gbPalette)
    {
    // Try and realize a palette with one palette entry reserved:

        lp.palVersion             = 0x300;
        lp.palNumEntries          = 1;
        lp.palPalEntry[0].peFlags = PC_RESERVED;

        ghpal = CreatePalette(&lp);
        if (ghpal != 0)
        {
            ghpalOld = SelectPalette(hdc, ghpal, FALSE);
            RealizePalette(ghdc);
        }
    }

    if (!gbPalette && cBitsPerPel <= 4)
    {
    // If on a wimpy device, simply cycle through the 'dark' colors of
    // its palette, skipping black because it's boring:

        gcpal = GetSystemPaletteEntries(hdc, 1, NUM_PALETTE_ENTRIES, &gapal[0]);
        if (gcpal == 0)
        {
        // Worst comes to worst, always use a white pen:

            gcpal = 1;
            gapal[0].peRed   = 255;
            gapal[0].peGreen = 255;
            gapal[0].peBlue  = 255;
            gapal[0].peFlags = 0;
        }

        gipal      = 8 % gcpal;     // Start with red
        gcMaxTicks = MAX_TICKS_WIMPY;
        gcTicker   = 0;

        return;
    }

// At this point, we either have a palette managed or high color device.

    ppal = &gapal[0];
    for (i = 0; i < NUM_PALETTE_ENTRIES; i++)
    {
        for (j = 0; j < FADE_RESOLUTION; j++)
        {
            ppal->peRed   = (BYTE)(gapalDefault[i].peRed +
                (j * (gapalDefault[i + 1].peRed   - gapalDefault[i].peRed))
                / FADE_RESOLUTION);
            ppal->peGreen = (BYTE)(gapalDefault[i].peGreen +
                (j * (gapalDefault[i + 1].peGreen - gapalDefault[i].peGreen))
                / FADE_RESOLUTION);
            ppal->peBlue = (BYTE)(gapalDefault[i].peBlue +
                (j * (gapalDefault[i + 1].peBlue  - gapalDefault[i].peBlue))
                / FADE_RESOLUTION);
            ppal->peFlags = PC_RESERVED;
            ppal++;
        }
    }

    gcpal      = (NUM_PALETTE_ENTRIES - 1) * FADE_RESOLUTION;
    gipal      = 0;
    gcMaxTicks = MAX_TICKS_COOL;
    gcTicker   = 0;

    if (gbPalette)
    {
    // Create a pen that maps to logical palette index zero:

        SelectObject(hdc, GetStockObject(BLACK_PEN));
        DeleteObject(ghpenBez);
        ghpenBez = CreatePen(0, 0, PALETTEINDEX(0));
        SelectObject(hdc, ghpenBez);
    }

    return;
}

VOID vNewColor(VOID)
{
    HPEN hpen;

    if (--gcTicker <= 0)
    {
        if (gbPalette)
        {
            AnimatePalette(ghpal, 0, 1, &gapal[gipal]);
        }
        else
        {
            if (gbCopy)
            {
                hpen = CreatePen(0, 0, RGB(gapal[gipal].peRed,
                                           gapal[gipal].peGreen,
                                           gapal[gipal].peBlue));

                SelectObject(ghdc, hpen);
                DeleteObject(ghpenBez);
                ghpenBez = hpen;
            }
        }

        gcTicker = gcMaxTicks;
        if (--gipal < 0)
            gipal = gcpal - 1;
    }

    return;
}

/****************************************************************************/

typedef struct _DOT {
    int xm, ym, zm;
    int xn, yn, zn;
    int color;
} DOT, *PDOT;

typedef struct _LIST *PLIST;
typedef struct _LIST {
    PLIST pnext;
    PLIST plistComplete;
    PSZ psz;
} LIST;

#define MAXFIXED (65536)

#define AXISSIZE 150
#define XSIZE (gcxScreen)
#define YSIZE (gcyScreen)
#define XSIZE2 (XSIZE / 2)
#define YSIZE2 (YSIZE / 2)
#define SCANSIZE ((8 * XSIZE + 31) & ~31) / 8
#define PI (3.141529)

#define MAXANGLE (360 * 10)

/****************************************************************************/

int *icos;
int *isin;

/****************************************************************************/

void ClearRect(
    PBYTE pstart,
    PRECT prc)
{
    PBYTE pdst;
    int length, y;

    pdst = pstart + SCANSIZE * prc->top + prc->left;
    length = prc->right - prc->left;

    for (y = prc->top; y < prc->bottom; y++) {
         memset(pdst, 0, length);
         pdst += SCANSIZE;
    }
}

/****************************************************************************/

void UnionRects(
    PRECT prcDest,
    PRECT prc)
{
    if (prc->left   < prcDest->left)   prcDest->left = prc->left;
    if (prc->right  > prcDest->right)  prcDest->right = prc->right;
    if (prc->top    < prcDest->top)    prcDest->top = prc->top;
    if (prc->bottom > prcDest->bottom) prcDest->bottom = prc->bottom;
}

/****************************************************************************/

__inline int WrapPlus(
    int deg,
    int range)
{
    return  deg >= range
      ? deg - range
      : deg;
}

__inline int WrapMinus(
    int deg,
    int range)
{
    return   deg < 0
        ? deg + range
        : deg;
}

__inline int Bound(
    int deg,
    int range)
{
    return WrapMinus(WrapPlus(deg, range), range);
}

/****************************************************************************/

int RandomInt(
    int min,
    int max)
{
    int dx = max - min;
    int mask = 1;
    int value;

    while (mask < dx) {
        mask = (mask << 1) + 1;
    }

    while ((value = (rand() & mask) + min) > max) ;
    return value;
}

/****************************************************************************/

#define NUMDOTS 1500

PDOT adot;

void InitDrawShaded(
    PWINDOW pwindow)
{
    int d0, d1;
    int c0, c1, s0, s1;
    int i;
    int x, y, z;

    pwindow->rcDraw.left = 0;
    pwindow->rcDraw.right = 0;
    pwindow->rcDraw.top = 0;
    pwindow->rcDraw.bottom = 0;

    for (i = 0; i < NUMDOTS; i++) {
        PDOT pdot = adot + i;

        pdot->xm = 1 * AXISSIZE / 4;
        pdot->ym = 0;
        pdot->zm = 0;

        d0 = RandomInt(0, MAXANGLE / 2);
        d1 = RandomInt(0, MAXANGLE - 1);

        c0 = icos[d0];
        s0 = isin[d0];
        c1 = icos[d1];
        s1 = isin[d1];

        x = (pdot->zm * s0 + pdot->xm * c0) / MAXFIXED;
        z = (pdot->zm * c0 - pdot->xm * s0) / MAXFIXED;

        y = (z * s1 + pdot->ym * c1) / MAXFIXED;
        z = (z * c1 - pdot->ym * s1) / MAXFIXED;

        pdot->xm = x;
        pdot->ym = y;
        pdot->zm = z;

        pdot->xn = 0;
        pdot->yn = 0;
        pdot->zn = 0;
    }
}


/****************************************************************************/

#define DELTA0 47
#define DELTA1 30
#define DELTA2 40

void DrawFrameShaded(
    PWINDOW pwindow)
{
    static int deg0 = 0, deg1 = 0, deg2 = 0, deg3 = 0;
    int i, j;
    int c0, c1, sizetext;
    int s0, s1, sizeball;
    int x, y, z;
    int xs, ys, zs;
    PBYTE pdata = pwindow->pdata;
    BYTE color;
    int d0, d1, d2;
    PRECT prc = &(pwindow->rcDraw);

    ClearRect(pwindow->pdata, &(pwindow->rcDraw));

    pwindow->rcBlt = pwindow->rcDraw;

    prc->left = XSIZE;
    prc->right = 0;
    prc->top = YSIZE;
    prc->bottom = 0;

    //
    // draw this frame
    //

    for (j = 0; j < 1; j++) {
        d0 = WrapPlus(deg0 + j * DELTA0, MAXANGLE);
        d0 = Bound((icos[d0] * MAXANGLE / 2) / MAXFIXED, MAXANGLE);
        c0 = icos[d0];
        s0 = isin[d0];

        d1 = WrapPlus(deg1 + j * DELTA1, MAXANGLE);
        c1 = icos[d1];
        s1 = isin[d1];

        d2 = WrapPlus(deg2 + MAXANGLE * 3 / 4, MAXANGLE);

        sizeball = (icos[d2] + MAXFIXED) / 2;
        sizetext = (isin[d2] + MAXFIXED) / 2;

        color = 245;

        /*
         * rotate verticies
         */
        for (i = 0; i < NUMDOTS; i++) {
            PDOT pdot = adot + i;
            PBYTE pbyte;

            xs = pdot->xm;
            ys = pdot->ym;
            zs = pdot->zm;

            x = (zs * s0 + xs * c0) / MAXFIXED;
            z = (zs * c0 - xs * s0) / MAXFIXED;

            y = (z * s1 + ys * c1) / MAXFIXED;
            z = (z * c1 - ys * s1) / MAXFIXED;

            x = (x * sizeball + pdot->xn * sizetext) / MAXFIXED;
            y = (y * sizeball + pdot->yn * sizetext) / MAXFIXED;
            z = (z * sizeball + pdot->zn * sizetext) / MAXFIXED;

            x += XSIZE2;
            y += YSIZE2;

            if (x < 0)         x = 0;
            if (x > XSIZE - 2) x = XSIZE - 2;
            if (y < 0)         y = 0;
            if (y > YSIZE - 2) y = YSIZE - 2;

            if (x < prc->left) prc->left = x;
            if (x+2 > prc->right) prc->right = x+2;

            if (y < prc->top) prc->top = y;
            if (y+2 > prc->bottom) prc->bottom = y+2;

            pbyte = pdata + x + y * SCANSIZE;

            pbyte[0] = color;
            pbyte[1] = color;
            pbyte[SCANSIZE] = color;
            pbyte[SCANSIZE + 1] = color;
        }
    }

    //
    // next frame
    //

    deg0 = WrapPlus(deg0 + DELTA0, MAXANGLE);
    deg1 = WrapPlus(deg1 + DELTA1, MAXANGLE);

    deg2 -= DELTA2;
    if (deg2 < 0) {
        deg2 += MAXANGLE;
    }

    UnionRects(&(pwindow->rcBlt), &(pwindow->rcDraw));
    pwindow->xDelta = pwindow->rcBlt.left;
    pwindow->yDelta = pwindow->rcBlt.top;
}

/****************************************************************************/

void InitDrawingThread(
    PWINDOW pwindow)
{
    int i;

    for (i = 0; i < MAXANGLE; i++) {
        double rad = i * (2.0 * PI / MAXANGLE);
        icos[i] = (int)(cos(rad) * MAXFIXED);
        isin[i] = (int)(sin(rad) * MAXFIXED);
    }
}

/****************************************************************************/

void BltThread(
    PWINDOW pwindow)
{
    PRECT prc = &(pwindow->rcBlt);

    GdiSetBatchLimit(1);
    InitDrawingThread(pwindow);
    InitDrawShaded(pwindow);

    while (TRUE) {
        if (fRepaint) {
            RECT rc;
            rc.left = 0;
            rc.right = pwindow->xsize;
            rc.top = 0;
            rc.bottom = pwindow->ysize;
            FillRect(pwindow->hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
            fRepaint = FALSE;
        }

        DrawFrameShaded(pwindow);

        BitBlt(
            pwindow->hdc,
            prc->left, prc->top,
            prc->right - prc->left, prc->bottom - prc->top,
            pwindow->hdcBitmap,
            pwindow->xDelta,
            pwindow->yDelta, SRCCOPY);

        WaitForSingleObject(pwindow->hWait, INFINITE);
    }
}

/****************************************************************************/

void vCleanSystemPalette(HDC hdc)
{
    HPALETTE hpal,hpalOld;
    DWORD aTemp[257];
    LPLOGPALETTE lpLogPal;
    UCHAR iTemp;

    lpLogPal = (LPLOGPALETTE) aTemp;
    lpLogPal->palVersion = 0x300;
    lpLogPal->palNumEntries = 256;

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        lpLogPal->palPalEntry[iTemp].peRed   = 0;
        lpLogPal->palPalEntry[iTemp].peGreen = 0;
        lpLogPal->palPalEntry[iTemp].peBlue  = iTemp;
        lpLogPal->palPalEntry[iTemp].peFlags = PC_RESERVED;
    }

    hpal = CreatePalette(lpLogPal);
    hpalOld = SelectPalette(hdc, hpal, 0);
    RealizePalette(hdc);
    SelectPalette(hdc, hpalOld, 0);
    DeleteObject(hpal);
}

/****************************************************************************/

BOOL InitDibSection(
    PWINDOW pwindow,
    RGBQUAD* ppal,
    BOOL fSystemPalette)
{
    LPLOGPALETTE plp = (LPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE) + 4 * 256);
    LPBITMAPINFO pbmi = (LPBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + 4 * 256);
    int i;
    UCHAR iTemp;
    PUSHORT pw;
    LOGFONT lf;
    HFONT hfont;

    if(plp == NULL || pbmi == NULL)
    {
        return FALSE;
    }

    plp->palVersion = 0x300;
    plp->palNumEntries = 256;

    if (fSystemPalette) {
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          0, 1, plp->palPalEntry);
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          255, 1, &plp->palPalEntry[255]);
        for (i = 1; i < 254; i++) {
            plp->palPalEntry[i].peRed   = ppal[i].rgbRed;
            plp->palPalEntry[i].peGreen = ppal[i].rgbGreen;
            plp->palPalEntry[i].peBlue  = ppal[i].rgbBlue;
            plp->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
        }
        SetSystemPaletteUse(pwindow->hdc, SYSPAL_NOSTATIC);
    } else {
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          0, 10, plp->palPalEntry);
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          246, 10, &plp->palPalEntry[255]);

        for (i = 10; i < 246; i++) {
            plp->palPalEntry[i].peRed   = ppal[i].rgbRed;
            plp->palPalEntry[i].peGreen = ppal[i].rgbGreen;
            plp->palPalEntry[i].peBlue  = ppal[i].rgbBlue;
            plp->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
        }
    }

    pwindow->hpalette = CreatePalette(plp);
    vCleanSystemPalette(pwindow->hdc);
    SelectPalette(pwindow->hdc, pwindow->hpalette, FALSE);
    RealizePalette(pwindow->hdc);

    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = XSIZE;
    pbmi->bmiHeader.biHeight        = -YSIZE;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 8;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;

    pw = (PUSHORT)(pbmi->bmiColors);
    for (iTemp=0; iTemp<256; iTemp++) {
        pw[iTemp] = iTemp;
    }

    pwindow->hbitmap = CreateDIBSection(
        pwindow->hdc, pbmi, DIB_PAL_COLORS,
        (PVOID*)&(pwindow->pdata), 0, 0);
    pwindow->hdcBitmap = CreateCompatibleDC(pwindow->hdc);
    SelectObject(pwindow->hdcBitmap, pwindow->hbitmap);

    lf.lfHeight = 30;
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = 400;
    lf.lfItalic = FALSE;
    lf.lfUnderline = FALSE;
    lf.lfStrikeOut = FALSE;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE;
    lstrcpy(lf.lfFaceName, TEXT("Arial"));

    hfont = CreateFontIndirect(&lf);

    pwindow->hbitmapText = CreateDIBSection(
        pwindow->hdc, pbmi, DIB_PAL_COLORS,
        (PVOID*)&(pwindow->pdataText), 0, 0);
    pwindow->hdcText = CreateCompatibleDC(pwindow->hdcText);
    SelectObject(pwindow->hdcText, pwindow->hbitmapText);
    SelectObject(pwindow->hdcText, hfont);

    return TRUE;
}

/****************************************************************************/

BOOL Init(
    HWND hwnd)
{
    int i;
    RGBQUAD apal[256];
    DWORD tid;

    srand(GetTickCount());

    adot = (PDOT) LocalAlloc(LPTR, sizeof(DOT) * NUMDOTS);
    isin = (int *) LocalAlloc(LPTR, sizeof(int) * MAXANGLE);
    icos = (int *) LocalAlloc(LPTR, sizeof(int) * MAXANGLE);

    gpwindow = (PWINDOW) LocalAlloc(LPTR, sizeof(WINDOW));

    if(adot == NULL || isin == NULL || icos == NULL || gpwindow == NULL)
        return FALSE;

    gpwindow->hwnd = hwnd;
    gpwindow->xsize = gcxScreen;
    gpwindow->ysize = gcyScreen;

    gpwindow->hdc = ghdc;
    SetBkColor(gpwindow->hdc, 0);
    SetTextColor(gpwindow->hdc, RGB(0xff, 0xff, 0xff));

    gpwindow->hWait = CreateEvent(NULL, FALSE, FALSE, NULL);
    SetTimer(gpwindow->hwnd, 1, 1000 / 20, NULL);

    for (i = 0; i < 236; i++) {
        apal[i + 10].rgbRed   = (i * 255) / 235;
        apal[i + 10].rgbGreen = (i * 255) / 235;
        apal[i + 10].rgbBlue  = (i * 255) / 235;
    }

    if(!InitDibSection(gpwindow, apal, FALSE))
        return FALSE;

    CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)BltThread,
        gpwindow,
        0,
        &tid);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\d3dsaver\d3dsaver.cpp ===
//-----------------------------------------------------------------------------
// File: D3DSaver.cpp
//
// Desc: Framework for screensavers that use Direct3D 8.0.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <Windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <tchar.h>
#include <regstr.h>
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#include <mmsystem.h>
#include <D3DX8.h>
#include "D3DSaver.h"
#include "dxutil.h"

// Resource IDs.  D3DSaver assumes that you will create resources with
// these IDs that it can use.  The easiest way to do this is to copy
// the resources from the rc file of an existing D3DSaver-based program.
#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212


// Use the following structure rather than DISPLAY_DEVICE, since some old 
// versions of DISPLAY_DEVICE are missing the last two fields and this can
// cause problems with EnumDisplayDevices on Windows 2000.
struct DISPLAY_DEVICE_FULL
{
    DWORD  cb;
    TCHAR  DeviceName[32];
    TCHAR  DeviceString[128];
    DWORD  StateFlags;
    TCHAR  DeviceID[128];
    TCHAR  DeviceKey[128];
};


static CD3DScreensaver* s_pD3DScreensaver = NULL;


//-----------------------------------------------------------------------------
// Name: CD3DScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CD3DScreensaver::CD3DScreensaver()
{
    s_pD3DScreensaver = this;

    m_bCheckingSaverPassword = FALSE;
    m_bIs9x = FALSE;
    m_dwSaverMouseMoveCount = 0;
    m_hWndParent = NULL;
    m_hPasswordDLL = NULL;
    m_hWnd = NULL;
    m_VerifySaverPassword = NULL;
    
    m_bAllScreensSame = FALSE;
    m_pD3D = NULL;
    m_pd3dDevice = NULL;
    m_bWindowed = FALSE;
    m_bWaitForInputIdle = FALSE;

    m_bErrorMode = FALSE;
    m_hrError = S_OK;
    m_szError[0] = TEXT('\0');

    m_fFPS              = 0.0f;
    m_strDeviceStats[0] = TEXT('\0');
    m_strFrameStats[0]  = TEXT('\0');

    // Note: clients should load a resource into m_strWindowTitle to localize this string
    lstrcpy( m_strWindowTitle, TEXT("Screen Saver") );
    m_bAllowRef = FALSE;
    m_bUseDepthBuffer = FALSE;
    m_bMultithreaded = FALSE;
    m_bOneScreenOnly = FALSE;
    m_strRegPath[0] = TEXT('\0');
    m_dwMinDepthBits = 16;
    m_dwMinStencilBits = 0;
    m_SwapEffectFullscreen = D3DSWAPEFFECT_DISCARD;
    m_SwapEffectWindowed = D3DSWAPEFFECT_COPY_VSYNC;

    SetRectEmpty( &m_rcRenderTotal );
    SetRectEmpty( &m_rcRenderCurDevice );

    ZeroMemory( m_Monitors, sizeof(m_Monitors) );
    m_dwNumMonitors = 0;

    ZeroMemory( m_Adapters, sizeof(m_Adapters) );
    m_dwNumAdapters = 0;

    ZeroMemory( m_RenderUnits, sizeof(m_RenderUnits) );
    m_dwNumRenderUnits = 0;

    m_fTime = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Have the client program call this function before calling Run().
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Create( HINSTANCE hInstance )
{
    HRESULT hr;

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );

    m_hInstance = hInstance;

    // Parse the command line and do the appropriate thing
    TCHAR* pstrCmdLine = GetCommandLine();
    m_SaverMode = ParseCommandLine( pstrCmdLine );

    EnumMonitors();

    // Create the screen saver window(s)
    if( m_SaverMode == sm_preview || 
        m_SaverMode == sm_test    || 
        m_SaverMode == sm_full )
    {
        if( FAILED( hr = CreateSaverWindow() ) )
        {
            m_bErrorMode = TRUE;
            m_hrError = hr;
        }
    }

    if( m_SaverMode == sm_preview )
    {
        // In preview mode, "pause" (enter a limited message loop) briefly 
        // before proceeding, so the display control panel knows to update itself.
        m_bWaitForInputIdle = TRUE;

        // Post a message to mark the end of the initial group of window messages
        PostMessage( m_hWnd, WM_USER, 0, 0 );

        MSG msg;
        while( m_bWaitForInputIdle )
        {
            // If GetMessage returns FALSE, it's quitting time.
            if( !GetMessage( &msg, m_hWnd, 0, 0 ) )
            {
                // Post the quit message to handle it later
                PostQuitMessage(0);
                break;
            }

            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    // Create Direct3D object
    if( (m_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) == NULL )
    {
        m_bErrorMode = TRUE;
        m_hrError = D3DAPPERR_NODIRECT3D;
        return S_OK;
    }

    // Give the app the opportunity to register a pluggable SW D3D Device.
    if( FAILED( hr = RegisterSoftwareDevice() ) )
    {
        m_bErrorMode = TRUE;
        m_hrError = hr;
        return S_OK;
    }

    // Build a list of Direct3D adapters, modes and devices. The
    // ConfirmDevice() callback is used to confirm that only devices that
    // meet the app's requirements are considered.
    if( FAILED( hr = BuildDeviceList() ) )
    {
        m_bErrorMode = TRUE;
        m_hrError = hr;
        return S_OK;
    }

    // Make sure that at least one valid usable D3D device was found
    BOOL bCompatibleDeviceFound = FALSE;
    for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
    {
        if( m_Adapters[iAdapter]->bHasAppCompatHAL || 
            m_Adapters[iAdapter]->bHasAppCompatSW )
        {
            bCompatibleDeviceFound = TRUE;
            break;
        }
    }
    if( !bCompatibleDeviceFound )
    {
        m_bErrorMode = TRUE;
        m_hrError = D3DAPPERR_NOCOMPATIBLEDEVICES;
        return S_OK;
    }

    // Read any settings we need
    ReadSettings();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: EnumMonitors()
// Desc: Determine HMONITOR, desktop rect, and other info for each monitor.  
//       Note that EnumDisplayDevices enumerates monitors in the order 
//       indicated on the Settings page of the Display control panel, which 
//       is the order we want to list monitors in, as opposed to the order 
//       used by D3D's GetAdapterInfo.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::EnumMonitors( VOID )
{
    DWORD iDevice = 0;
    DISPLAY_DEVICE_FULL dispdev;
    DISPLAY_DEVICE_FULL dispdev2;
    DEVMODE devmode;
    dispdev.cb = sizeof(dispdev);
    dispdev2.cb = sizeof(dispdev2);
    devmode.dmSize = sizeof(devmode);
    devmode.dmDriverExtra = 0;
    MonitorInfo* pMonitorInfoNew;
    while( EnumDisplayDevices(NULL, iDevice, (DISPLAY_DEVICE*)&dispdev, 0) )
    {
        // Ignore NetMeeting's mirrored displays
        if( (dispdev.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) == 0 )
        {
            // To get monitor info for a display device, call EnumDisplayDevices
            // a second time, passing dispdev.DeviceName (from the first call) as
            // the first parameter.
            EnumDisplayDevices(dispdev.DeviceName, 0, (DISPLAY_DEVICE*)&dispdev2, 0);

            pMonitorInfoNew = &m_Monitors[m_dwNumMonitors];
            ZeroMemory( pMonitorInfoNew, sizeof(MonitorInfo) );
            lstrcpy( pMonitorInfoNew->strDeviceName, dispdev.DeviceString );
            lstrcpy( pMonitorInfoNew->strMonitorName, dispdev2.DeviceString );
            pMonitorInfoNew->iAdapter = NO_ADAPTER;
            
            if( dispdev.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP )
            {
                EnumDisplaySettings( dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode );
                if( dispdev.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE )
                {
                    // For some reason devmode.dmPosition is not always (0, 0)
                    // for the primary display, so force it.
                    pMonitorInfoNew->rcScreen.left = 0;
                    pMonitorInfoNew->rcScreen.top = 0;
                }
                else
                {
                    pMonitorInfoNew->rcScreen.left = devmode.dmPosition.x;
                    pMonitorInfoNew->rcScreen.top = devmode.dmPosition.y;
                }
                pMonitorInfoNew->rcScreen.right = pMonitorInfoNew->rcScreen.left + devmode.dmPelsWidth;
                pMonitorInfoNew->rcScreen.bottom = pMonitorInfoNew->rcScreen.top + devmode.dmPelsHeight;
                pMonitorInfoNew->hMonitor = MonitorFromRect( &pMonitorInfoNew->rcScreen, MONITOR_DEFAULTTONULL );
            }
            m_dwNumMonitors++;
            if( m_dwNumMonitors == MAX_DISPLAYS )
                break;
        }
        iDevice++;
    }
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: Starts main execution of the screen saver.
//-----------------------------------------------------------------------------
INT CD3DScreensaver::Run()
{
    HRESULT hr;

    // Parse the command line and do the appropriate thing
    switch ( m_SaverMode )
    {
        case sm_config:
        {
            if( m_bErrorMode )
            {
                DisplayErrorMsg( m_hrError, 0 );
            }
            else
            {
                DoConfig();
            }
            break;
        }
        
        case sm_preview:
        case sm_test:
        case sm_full:
        {
            if( FAILED( hr = DoSaver() ) )
                DisplayErrorMsg( hr, 0 );
            break;
        }
        
        case sm_passwordchange:
        {
            ChangePassword();
            break;
        }
    }

    for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
        SAFE_DELETE( m_Adapters[iAdapter] );
    SAFE_RELEASE( m_pD3D );
    return 0;
}




//-----------------------------------------------------------------------------
// Name: ParseCommandLine()
// Desc: Interpret command-line parameters passed to this app.
//-----------------------------------------------------------------------------
SaverMode CD3DScreensaver::ParseCommandLine( TCHAR* pstrCommandLine )
{
    m_hWndParent = NULL;

    // Skip the first part of the command line, which is the full path 
    // to the exe.  If it contains spaces, it will be contained in quotes.
    if (*pstrCommandLine == TEXT('\"'))
    {
        pstrCommandLine++;
        while (*pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT('\"'))
            pstrCommandLine++;
        if( *pstrCommandLine == TEXT('\"') )
            pstrCommandLine++;
    }
    else
    {
        while (*pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT(' '))
            pstrCommandLine++;
        if( *pstrCommandLine == TEXT(' ') )
            pstrCommandLine++;
    }

    // Skip along to the first option delimiter "/" or "-"
    while ( *pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT('/') && *pstrCommandLine != TEXT('-') )
        pstrCommandLine++;

    // If there wasn't one, then must be config mode
    if ( *pstrCommandLine == TEXT('\0') )
        return sm_config;

    // Otherwise see what the option was
    switch ( *(++pstrCommandLine) )
    {
        case 'c':
        case 'C':
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            else
            {
                m_hWndParent = NULL;
            }
            return sm_config;

        case 't':
        case 'T':
            return sm_test;

        case 'p':
        case 'P':
            // Preview-mode, so option is followed by the parent HWND in decimal
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            return sm_preview;

        case 'a':
        case 'A':
            // Password change mode, so option is followed by parent HWND in decimal
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            return sm_passwordchange;

        default:
            // All other options => run the screensaver (typically this is "/s")
            return sm_full;
    }
}




//-----------------------------------------------------------------------------
// Name: CreateSaverWindow
// Desc: Register and create the appropriate window(s)
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateSaverWindow()
{
/*
    // Uncomment this code to allow stepping thru code in the preview case
    if( m_SaverMode == sm_preview )
    {
        WNDCLASS cls;
        cls.hCursor        = NULL; 
        cls.hIcon          = NULL; 
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = TEXT("Parent"); 
        cls.hbrBackground  = (HBRUSH) GetStockObject(WHITE_BRUSH);
        cls.hInstance      = m_hInstance; 
        cls.style          = CS_VREDRAW|CS_HREDRAW|CS_SAVEBITS|CS_DBLCLKS;
        cls.lpfnWndProc    = DefWindowProc;
        cls.cbWndExtra     = 0; 
        cls.cbClsExtra     = 0; 
        RegisterClass( &cls );

        // Create the window
        RECT rect;
        HWND hwnd;
        rect.left = rect.top = 40;
        rect.right = rect.left+200;
        rect.bottom = rect.top+200;
        AdjustWindowRect( &rect, WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP, FALSE );
        hwnd = CreateWindow( TEXT("Parent"), TEXT("FakeShell"),
            WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP, rect.left, rect.top,
            rect.right-rect.left, rect.bottom-rect.top, NULL,
            NULL, m_hInstance, NULL );
        m_hWndParent = hwnd;
    }
*/
    
    // Register an appropriate window class
    WNDCLASS    cls;
    cls.hCursor        = LoadCursor( NULL, IDC_ARROW );
    cls.hIcon          = LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON) ); 
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = TEXT("D3DSaverWndClass");
    cls.hbrBackground  = (HBRUSH) GetStockObject(BLACK_BRUSH);
    cls.hInstance      = m_hInstance; 
    cls.style          = CS_VREDRAW|CS_HREDRAW;
    cls.lpfnWndProc    = SaverProcStub;
    cls.cbWndExtra     = 0; 
    cls.cbClsExtra     = 0; 
    RegisterClass( &cls );

    // Create the window
    RECT rc;
    DWORD dwStyle;
    switch ( m_SaverMode )
    {
        case sm_preview:
            GetClientRect( m_hWndParent, &rc );
            dwStyle = WS_VISIBLE | WS_CHILD;
            AdjustWindowRect( &rc, dwStyle, FALSE );
            m_hWnd = CreateWindow( TEXT("D3DSaverWndClass"), m_strWindowTitle, dwStyle, 
                                    rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                                    m_hWndParent, NULL, m_hInstance, this );
            m_Monitors[0].hWnd = m_hWnd;
            GetClientRect( m_hWnd, &m_rcRenderTotal );
            GetClientRect( m_hWnd, &m_rcRenderCurDevice );
            break;

        case sm_test:
            rc.left = rc.top = 50;
            rc.right = rc.left+600;
            rc.bottom = rc.top+400;
            dwStyle = WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU;
            AdjustWindowRect( &rc, dwStyle, FALSE );
            m_hWnd = CreateWindow( TEXT("D3DSaverWndClass"), m_strWindowTitle, dwStyle, 
                                   rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                                   NULL, NULL, m_hInstance, this );
            m_Monitors[0].hWnd = m_hWnd;
            GetClientRect( m_hWnd, &m_rcRenderTotal );
            GetClientRect( m_hWnd, &m_rcRenderCurDevice );
            break;

        case sm_full:
            // Create windows for each monitor.  Note that m_hWnd is NULL when CreateWindowEx
            // is called for the first monitor, so that window has no parent.  Windows for
            // additional monitors are created as children of the window for the first monitor.
            dwStyle = WS_VISIBLE | WS_POPUP;
            m_hWnd = NULL;
            for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                MonitorInfo* pMonitorInfo;
                pMonitorInfo = &m_Monitors[iMonitor];
                if( pMonitorInfo->hMonitor == NULL )
                    continue;
                rc = pMonitorInfo->rcScreen;
                pMonitorInfo->hWnd = CreateWindowEx( WS_EX_TOPMOST, TEXT("D3DSaverWndClass"), 
                    m_strWindowTitle, dwStyle, rc.left, rc.top, rc.right - rc.left, 
                    rc.bottom - rc.top, m_hWnd, NULL, m_hInstance, this );
                if( pMonitorInfo->hWnd == NULL )
                    return E_FAIL;
                if( m_hWnd == NULL )
                    m_hWnd = pMonitorInfo->hWnd;
            }
    }
    if ( m_hWnd == NULL )
        return E_FAIL;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DoSaver()
// Desc: Run the screensaver graphics - may be preview, test or full-on mode
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::DoSaver()
{
    HRESULT hr;

    // Figure out if we're on Win9x
    OSVERSIONINFO osvi; 
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx( &osvi );
    m_bIs9x = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    // If we're in full on mode, and on 9x, then need to load the password DLL
    if ( m_SaverMode == sm_full && m_bIs9x )
    {
        // Only do this if the password is set - check registry:
        HKEY hKey; 
        if ( RegOpenKey( HKEY_CURRENT_USER , REGSTR_PATH_SCREENSAVE , &hKey ) == ERROR_SUCCESS ) 
        { 
            DWORD dwVal;
            DWORD dwSize = sizeof(dwVal); 
 
            if ( (RegQueryValueEx( hKey, REGSTR_VALUE_USESCRPASSWORD, NULL, NULL,
                                   (BYTE *)&dwVal, &dwSize ) == ERROR_SUCCESS) && dwVal ) 
            { 
                m_hPasswordDLL = LoadLibrary( TEXT("PASSWORD.CPL") );
                if ( m_hPasswordDLL )
                    m_VerifySaverPassword = (VERIFYPWDPROC)GetProcAddress( m_hPasswordDLL, "VerifyScreenSavePwd" );
                RegCloseKey( hKey );
            }
        }
    }

    // Initialize the application timer
    DXUtil_Timer( TIMER_START );

    if( !m_bErrorMode )
    {
        // Initialize the app's custom scene stuff
        if( FAILED( hr = OneTimeSceneInit() ) )
            return DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );

        // Do graphical init stuff
        if ( FAILED(hr = Initialize3DEnvironment()) )
            return hr;
    }

    // Flag as screensaver running if in full on mode
    if ( m_SaverMode == sm_full )
    {
        BOOL bUnused;
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, TRUE, &bUnused, 0 );
    }

    // Message pump
    BOOL bGotMsg;
    MSG msg;
    msg.message = WM_NULL;
    while ( msg.message != WM_QUIT )
    {
        bGotMsg = PeekMessage( &msg, NULL, 0, 0, PM_REMOVE );
        if( bGotMsg )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else
        {
            Sleep(10);
            if( m_bErrorMode )
            {
                UpdateErrorBox();
            }
            else
            {
                Render3DEnvironment();
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ShutdownSaver()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ShutdownSaver()
{
    // Unflag screensaver running if in full on mode
    if ( m_SaverMode == sm_full )
    {
        BOOL bUnused;
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, FALSE, &bUnused, 0 );
    }

    // Kill graphical stuff
    Cleanup3DEnvironment();

    // Let client app clean up its resources
    FinalCleanup();

    // Unload the password DLL (if we loaded it)
    if ( m_hPasswordDLL != NULL )
    {
        FreeLibrary( m_hPasswordDLL );
        m_hPasswordDLL = NULL;
    }

    // Post message to drop out of message loop
    PostQuitMessage( 0 );
}




//-----------------------------------------------------------------------------
// Name: SaverProcStub()
// Desc: This function forwards all window messages to SaverProc, which has
//       access to the "this" pointer.
//-----------------------------------------------------------------------------
LRESULT CALLBACK CD3DScreensaver::SaverProcStub( HWND hWnd, UINT uMsg,
                                                 WPARAM wParam, LPARAM lParam )
{
    return s_pD3DScreensaver->SaverProc( hWnd, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: SaverProc()
// Desc: Handle window messages for main screensaver windows (one per screen).
//-----------------------------------------------------------------------------
LRESULT CD3DScreensaver::SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch ( uMsg )
        {
        case WM_USER:
            // All initialization messages have gone through.  Allow
            // 500ms of idle time, then proceed with initialization.
            SetTimer( hWnd, 1, 500, NULL );
            break;

        case WM_TIMER:
            // Initial idle time is done, proceed with initialization.
            m_bWaitForInputIdle = FALSE;
            KillTimer( hWnd, 1 );
            break;

        case WM_DESTROY:
            if( m_SaverMode == sm_preview || m_SaverMode == sm_test )
                ShutdownSaver();
            break;

        case WM_SETCURSOR:
            if ( m_SaverMode == sm_full && !m_bCheckingSaverPassword )
            {
                // Hide cursor
                SetCursor( NULL );
                return TRUE;
            }
            break;

        case WM_PAINT:
        {
            // Show error message, if there is one
            PAINTSTRUCT ps;
            BeginPaint( hWnd, &ps );

            // In preview mode, just fill 
            // the preview window with black. 
            if( !m_bErrorMode && m_SaverMode == sm_preview )
            {
                RECT rc;
                GetClientRect(hWnd,&rc);
                FillRect(ps.hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH) );
            }
            else
            {
                DoPaint( hWnd, ps.hdc );
            }

            EndPaint( hWnd, &ps );
            return 0;
        }

        case WM_ERASEBKGND:
            // Erase background if checking password or if window is not
            // assigned to a render unit
            if( !m_bCheckingSaverPassword )
            {
                RenderUnit* pRenderUnit;
                D3DAdapterInfo* pD3DAdapterInfo;
                for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                {
                    pRenderUnit = &m_RenderUnits[iRenderUnit];
                    pD3DAdapterInfo = m_Adapters[pRenderUnit->iAdapter];
                    if( pD3DAdapterInfo->hWndDevice == hWnd )
                        return TRUE; // don't erase this window
                }
            }
            break;

        case WM_MOUSEMOVE:
            if( m_SaverMode != sm_test )
            {
                static INT xPrev = -1;
                static INT yPrev = -1;
                INT xCur = GET_X_LPARAM(lParam);
                INT yCur = GET_Y_LPARAM(lParam);
                if( xCur != xPrev || yCur != yPrev )
                {
                    xPrev = xCur;
                    yPrev = yCur;
                    m_dwSaverMouseMoveCount++;
                    if ( m_dwSaverMouseMoveCount > 5 )
                        InterruptSaver();
                }
            }
            break;

        case WM_KEYDOWN:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            if( m_SaverMode != sm_test )
                InterruptSaver();
            break;

        case WM_ACTIVATEAPP:
            if( wParam == FALSE && m_SaverMode != sm_test )
                InterruptSaver();
            break;

        case WM_POWERBROADCAST:
            if( wParam == PBT_APMSUSPEND && m_VerifySaverPassword == NULL )
                InterruptSaver();
            break;

        case WM_SYSCOMMAND: 
            if ( m_SaverMode == sm_full )
            {
                switch ( wParam )
                {
                    case SC_NEXTWINDOW:
                    case SC_PREVWINDOW:
                    case SC_SCREENSAVE:
                    case SC_CLOSE:
                        return FALSE;
                        break;
                    case SC_MONITORPOWER:
                        //
                        // The monitor is shutting down.  Tell our client that he needs to
                        // cleanup and exit.
                        //
                        InterruptSaver();
                        break;
                };
            }
            break;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: InterruptSaver()
// Desc: A message was received (mouse move, keydown, etc.) that may mean
//       the screen saver should show the password dialog and/or shut down.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::InterruptSaver()
{
    HRESULT hr;
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit;
    BOOL bPasswordOkay = FALSE;

    if( m_SaverMode == sm_test ||
        m_SaverMode == sm_full && !m_bCheckingSaverPassword )
    {
        if( m_bIs9x && m_SaverMode == sm_full )
        {
            // If no VerifyPassword function, then no password is set 
            // or we're not on 9x. 
            if ( m_VerifySaverPassword != NULL )
            {
                // Shut down all D3D devices so we can show a Windows dialog
                for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                {
                    pRenderUnit = &m_RenderUnits[iRenderUnit];
                    SwitchToRenderUnit(iRenderUnit);
                    if( pRenderUnit->bDeviceObjectsRestored )
                    {
                        InvalidateDeviceObjects();
                        pRenderUnit->bDeviceObjectsRestored = FALSE;
                    }
                    if( pRenderUnit->bDeviceObjectsInited )
                    {
                        DeleteDeviceObjects();
                        pRenderUnit->bDeviceObjectsInited = FALSE;
                    }
                    SAFE_RELEASE(pRenderUnit->pd3dDevice);
                }

                // Make sure all adapter windows cover the whole screen,
                // even after deleting D3D devices (which may have caused
                // mode changes)
                D3DAdapterInfo* pD3DAdapterInfo;
                for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
                {
                    pD3DAdapterInfo = m_Adapters[iAdapter];
                    ShowWindow( pD3DAdapterInfo->hWndDevice, SW_RESTORE );
                    ShowWindow( pD3DAdapterInfo->hWndDevice, SW_MAXIMIZE );
                }

                m_bCheckingSaverPassword = TRUE;

                bPasswordOkay = m_VerifySaverPassword( m_hWnd );

                m_bCheckingSaverPassword = FALSE;

                if ( bPasswordOkay )
                {
                    // D3D devices are all torn down, so it's safe
                    // to discard all render units now (so we don't
                    // try to clean them up again later).
                    m_dwNumRenderUnits = 0;
                }
                else
                {
                    // Back to screen saving...
                    SetCursor( NULL );
                    m_dwSaverMouseMoveCount = 0;

                    // Recreate all D3D devices
                    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                    {
                        pRenderUnit = &m_RenderUnits[iRenderUnit];
                        hr = m_pD3D->CreateDevice(pRenderUnit->iAdapter, 
                            pRenderUnit->DeviceType, m_hWnd, 
                            pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, 
                            &pRenderUnit->pd3dDevice );
                        if( FAILED( hr ) )
                        {
                            m_bErrorMode = TRUE;
                            m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
                        }
                        else
                        {
                            SwitchToRenderUnit(iRenderUnit);
                            if( FAILED(hr = InitDeviceObjects() ) )
                            {
                                m_bErrorMode = TRUE;
                                m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                            }
                            else 
                            {
                                pRenderUnit->bDeviceObjectsInited = TRUE;
                                if( FAILED(hr = RestoreDeviceObjects() ) )
                                {
                                    m_bErrorMode = TRUE;
                                    m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                                }
                                else
                                {
                                    pRenderUnit->bDeviceObjectsRestored = TRUE;
                                }
                            }
                        }
                    }

                    return;
                }
            }
        }
        ShutdownSaver();
    }
}




//-----------------------------------------------------------------------------
// Name: Initialize3DEnvironment()
// Desc: Set up D3D device(s)
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Initialize3DEnvironment()
{
    HRESULT hr;
    DWORD iAdapter;
    DWORD iMonitor;
    D3DAdapterInfo* pD3DAdapterInfo;
    MonitorInfo* pMonitorInfo;
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit;
    MONITORINFO monitorInfo;

    if ( m_SaverMode == sm_full )
    {
        // Fullscreen mode.  Create a RenderUnit for each monitor (unless 
        // the user wants it black)
        m_bWindowed = FALSE;

        if( m_bOneScreenOnly )
        {
            // Set things up to only create a RenderUnit on the best device
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                pD3DAdapterInfo = m_Adapters[iAdapter];
                pD3DAdapterInfo->bLeaveBlack = TRUE;
            }
            GetBestAdapter( &iAdapter );
            if( iAdapter == NO_ADAPTER )
            {
                m_bErrorMode = TRUE;
                m_hrError = D3DAPPERR_NOCOMPATIBLEDEVICES;
            }
            else
            {
                pD3DAdapterInfo = m_Adapters[iAdapter];
                pD3DAdapterInfo->bLeaveBlack = FALSE;
            }
        }

        for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
        {
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( iAdapter == NO_ADAPTER )
                continue; 
            pD3DAdapterInfo = m_Adapters[iAdapter];
            if( !pD3DAdapterInfo->bLeaveBlack && pD3DAdapterInfo->dwNumDevices > 0 )
            {
                pD3DAdapterInfo->hWndDevice = pMonitorInfo->hWnd;
                pRenderUnit = &m_RenderUnits[m_dwNumRenderUnits++];
                ZeroMemory( pRenderUnit, sizeof(RenderUnit) );
                pRenderUnit->iAdapter = iAdapter;
                if( FAILED( hr = CreateFullscreenRenderUnit( pRenderUnit ) ) )
                {
                    // skip this render unit and leave screen blank
                    m_dwNumRenderUnits--;
                    m_bErrorMode = TRUE;
                    m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
                }
            }
        }
    }
    else 
    {
        // Windowed mode, for test mode or preview window.  Just need one RenderUnit.
        m_bWindowed = TRUE;

        GetClientRect( m_hWnd, &m_rcRenderTotal );
        GetClientRect( m_hWnd, &m_rcRenderCurDevice );

        GetBestAdapter( &iAdapter );
        if( iAdapter == NO_ADAPTER )
        {
            m_bErrorMode = TRUE;
            m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
        }
        else
        {
            pD3DAdapterInfo = m_Adapters[iAdapter];
            pD3DAdapterInfo->hWndDevice = m_hWnd;
        }
        if( !m_bErrorMode )
        {
            pRenderUnit = &m_RenderUnits[m_dwNumRenderUnits++];
            ZeroMemory( pRenderUnit, sizeof(RenderUnit) );
            pRenderUnit->iAdapter = iAdapter;
            if( FAILED( hr = CreateWindowedRenderUnit( pRenderUnit ) ) )
            {
                m_dwNumRenderUnits--;
                m_bErrorMode = TRUE;
                if( m_SaverMode == sm_preview )
                    m_hrError = D3DAPPERR_NOPREVIEW;
                else
                    m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
            }
        }
    }

    // Once all mode changes are done, (re-)determine coordinates of all 
    // screens, and make sure windows still cover each screen
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        monitorInfo.cbSize = sizeof(MONITORINFO);
        GetMonitorInfo( pMonitorInfo->hMonitor, &monitorInfo );
        pMonitorInfo->rcScreen = monitorInfo.rcMonitor;
        if( !m_bWindowed )
        {
            SetWindowPos( pMonitorInfo->hWnd, HWND_TOPMOST, monitorInfo.rcMonitor.left, 
                monitorInfo.rcMonitor.top, monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left, 
                monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top, SWP_NOACTIVATE );
        }
    }

    // For fullscreen, determine bounds of the virtual screen containing all 
    // screens that are rendering.  Don't just use SM_XVIRTUALSCREEN, because 
    // we don't want to count screens that are just black
    if( !m_bWindowed )
    {
        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            pMonitorInfo = &m_Monitors[pRenderUnit->iMonitor];
            UnionRect( &m_rcRenderTotal, &m_rcRenderTotal, &pMonitorInfo->rcScreen );
        }
    }

    if( !m_bErrorMode )
    {
        // Initialize D3D devices for all render units
        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            SwitchToRenderUnit( iRenderUnit );
            if ( FAILED(hr = InitDeviceObjects() ) )
            {
                m_bErrorMode = TRUE;
                m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
            }
            else 
            {
                pRenderUnit->bDeviceObjectsInited = TRUE;
                if ( FAILED(hr = RestoreDeviceObjects() ) )
                {
                    m_bErrorMode = TRUE;
                    m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                }
                else
                {
                    pRenderUnit->bDeviceObjectsRestored = TRUE;
                }
            }
        }
        UpdateDeviceStats(); 
    }

    // Make sure all those display changes don't count as user mouse moves
    m_dwSaverMouseMoveCount = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetBestAdapter()
// Desc: To decide which adapter to use, loop through monitors until you find
//       one whose adapter has a compatible HAL.  If none, use the first 
//       monitor that has an compatible SW device.
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::GetBestAdapter( DWORD* piAdapter )
{
    DWORD iAdapterBest = NO_ADAPTER;
    DWORD iAdapter;
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    D3DAdapterInfo* pD3DAdapterInfo;

    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        if( pD3DAdapterInfo->bHasAppCompatHAL )
        {
            iAdapterBest = iAdapter;
            break;
        }
        if( pD3DAdapterInfo->bHasAppCompatSW )
        {
            iAdapterBest = iAdapter;
            // but keep looking...
        }
    }
    *piAdapter = iAdapterBest;

    return (iAdapterBest != NO_ADAPTER);
}




//-----------------------------------------------------------------------------
// Name: CreateFullscreenRenderUnit()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateFullscreenRenderUnit( RenderUnit* pRenderUnit )
{
    HRESULT hr;
    UINT iAdapter = pRenderUnit->iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    DWORD iMonitor = pD3DAdapterInfo->iMonitor;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DModeInfo* pD3DModeInfo;
    DWORD dwCurrentDevice;
    D3DDEVTYPE curType;

    if( iAdapter >= m_dwNumAdapters )
        return E_FAIL;

    if( pD3DAdapterInfo->dwNumDevices == 0 )
        return E_FAIL;

    // Find the best device for the adapter.  Use HAL
    // if it's there, otherwise SW, otherwise REF.
    dwCurrentDevice = 0xffff;
    curType = D3DDEVTYPE_FORCE_DWORD;
    for( DWORD iDevice = 0; iDevice < pD3DAdapterInfo->dwNumDevices; iDevice++)
    {
        pD3DDeviceInfo = &pD3DAdapterInfo->devices[iDevice];
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_HAL && !pD3DAdapterInfo->bDisableHW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_HAL;
            break; // stop looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_SW;
            // but keep looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_REF && m_bAllowRef && curType != D3DDEVTYPE_SW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_REF;
            // but keep looking
        }
    }
    if( dwCurrentDevice == 0xffff )
        return D3DAPPERR_NOHARDWAREDEVICE;
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[dwCurrentDevice];

    pD3DDeviceInfo->dwCurrentMode = 0xffff;
    if( pD3DAdapterInfo->dwUserPrefWidth != 0 )
    {
        // Try to find mode that matches user preference
        for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
        {
            pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
            if( pD3DModeInfo->Width == pD3DAdapterInfo->dwUserPrefWidth &&
                pD3DModeInfo->Height == pD3DAdapterInfo->dwUserPrefHeight &&
                pD3DModeInfo->Format == pD3DAdapterInfo->d3dfmtUserPrefFormat )
            {
                pD3DDeviceInfo->dwCurrentMode = iMode;
                break;
            }
        }
    }

    // If user-preferred mode is not specified or not found,
    // use "Automatic" technique: 
    if( pD3DDeviceInfo->dwCurrentMode == 0xffff )
    {
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW )
        {
            // If using a SW rast then try to find a low resolution and 16-bpp.
            BOOL bFound16BitMode = FALSE;            
            DWORD dwSmallestHeight = -1;
            pD3DDeviceInfo->dwCurrentMode = 0; // unless we find something better

            for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
            {
                pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];

                // Skip 640x400 because 640x480 is better
                if( pD3DModeInfo->Height == 400 )
                    continue; 

                if( pD3DModeInfo->Height < dwSmallestHeight || 
                    (pD3DModeInfo->Height == dwSmallestHeight && !bFound16BitMode) )
                {
                    dwSmallestHeight = pD3DModeInfo->Height;
                    pD3DDeviceInfo->dwCurrentMode = iMode;
                    bFound16BitMode = FALSE;

                    if( ( pD3DModeInfo->Format == D3DFMT_R5G6B5 ||
                          pD3DModeInfo->Format == D3DFMT_X1R5G5B5 || 
                          pD3DModeInfo->Format == D3DFMT_A1R5G5B5 || 
                          pD3DModeInfo->Format == D3DFMT_A4R4G4B4 || 
                          pD3DModeInfo->Format == D3DFMT_X4R4G4B4 ) )
                    {
                        bFound16BitMode = TRUE;
                    }
                }
            }
        }
        else
        {
            // Try to find mode matching desktop resolution and 32-bpp.
            BOOL bMatchedSize = FALSE;
            BOOL bGot32Bit = FALSE;
            pD3DDeviceInfo->dwCurrentMode = 0; // unless we find something better
            for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
            {
                pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
                if( pD3DModeInfo->Width == pD3DAdapterInfo->d3ddmDesktop.Width &&
                    pD3DModeInfo->Height == pD3DAdapterInfo->d3ddmDesktop.Height )
                {
                    if( !bMatchedSize )
                        pD3DDeviceInfo->dwCurrentMode = iMode;
                    bMatchedSize = TRUE;
                    if( !bGot32Bit &&
                        ( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
                          pD3DModeInfo->Format == D3DFMT_A8R8G8B8 ) )
                    {
                        pD3DDeviceInfo->dwCurrentMode = iMode;
                        bGot32Bit = TRUE;
                        break;
                    }
                }
            }
        }
    }

    // If desktop mode not found, pick highest mode available
    if( pD3DDeviceInfo->dwCurrentMode == 0xffff )
    {
        DWORD dwWidthMax = 0;
        DWORD dwHeightMax = 0;
        DWORD dwBppMax = 0;
        DWORD dwWidthCur = 0;
        DWORD dwHeightCur = 0;
        DWORD dwBppCur = 0;
        for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
        {
            pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
            dwWidthCur = pD3DModeInfo->Width;
            dwHeightCur = pD3DModeInfo->Height;
            if( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
                pD3DModeInfo->Format == D3DFMT_A8R8G8B8 )
            {
                dwBppCur = 32;
            }
            else
            {
                dwBppCur = 16;
            }
            if( dwWidthCur > dwWidthMax ||
                dwHeightCur > dwHeightMax ||
                dwWidthCur == dwWidthMax && dwHeightCur == dwHeightMax && dwBppCur > dwBppMax )
            {
                dwWidthMax = dwWidthCur;
                dwHeightMax = dwHeightCur;
                dwBppMax = dwBppCur;
                pD3DDeviceInfo->dwCurrentMode = iMode;
            }
        }
    }

    // Try to create the D3D device, falling back to lower-res modes if it fails
    BOOL bAtLeastOneFailure = FALSE;
    while( TRUE )
    {
        pD3DModeInfo = &pD3DDeviceInfo->modes[pD3DDeviceInfo->dwCurrentMode];
        pRenderUnit->DeviceType = pD3DDeviceInfo->DeviceType;
        pRenderUnit->dwBehavior = pD3DModeInfo->dwBehavior;
        pRenderUnit->iMonitor = iMonitor;
        pRenderUnit->d3dpp.BackBufferFormat = pD3DModeInfo->Format;
        pRenderUnit->d3dpp.BackBufferWidth = pD3DModeInfo->Width;
        pRenderUnit->d3dpp.BackBufferHeight = pD3DModeInfo->Height;
        pRenderUnit->d3dpp.Windowed = FALSE;
        pRenderUnit->d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
        pRenderUnit->d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
        pRenderUnit->d3dpp.AutoDepthStencilFormat = pD3DModeInfo->DepthStencilFormat;
        pRenderUnit->d3dpp.BackBufferCount = 1;
        pRenderUnit->d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
        pRenderUnit->d3dpp.SwapEffect = m_SwapEffectFullscreen;
        pRenderUnit->d3dpp.hDeviceWindow = pD3DAdapterInfo->hWndDevice;
        pRenderUnit->d3dpp.EnableAutoDepthStencil = m_bUseDepthBuffer;
        pRenderUnit->d3dpp.Flags = 0;

        // Create device
        hr = m_pD3D->CreateDevice( iAdapter, pRenderUnit->DeviceType, 
                                   m_hWnd, // (this is the focus window)
                                   pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, 
                                   &pRenderUnit->pd3dDevice );
        if( SUCCEEDED( hr ) )
        {
            // Give the client app an opportunity to reject this mode
            // due to not enough video memory, or any other reason
            if( SUCCEEDED( hr = ConfirmMode( pRenderUnit->pd3dDevice ) ) )
                break;
            else
                SAFE_RELEASE( pRenderUnit->pd3dDevice );
        }

        // If we get here, remember that CreateDevice or ConfirmMode failed, so
        // we can change the default mode next time
        bAtLeastOneFailure = TRUE;

        if( !FindNextLowerMode( pD3DDeviceInfo ) )
            break;
    }

    if( SUCCEEDED( hr ) && bAtLeastOneFailure && m_strRegPath[0] != TEXT('\0') )
    {
        // Record the mode that succeeded in the registry so we can 
        // default to it next time
        TCHAR strKey[100];
        HKEY hkeyParent;
        HKEY hkey;

        pD3DAdapterInfo->dwUserPrefWidth = pRenderUnit->d3dpp.BackBufferWidth;
        pD3DAdapterInfo->dwUserPrefHeight = pRenderUnit->d3dpp.BackBufferHeight;
        pD3DAdapterInfo->d3dfmtUserPrefFormat = pRenderUnit->d3dpp.BackBufferFormat;

        if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyParent, NULL ) )
        {
            wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
            if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
                0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
            {
                RegSetValueEx( hkey, TEXT("Width"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Height"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Format"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Adapter ID"), NULL, REG_BINARY, 
                    (BYTE*)&pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier, sizeof(GUID) );
                RegCloseKey( hkey );
            }
            RegCloseKey( hkeyParent );
        }
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: FindNextLowerMode()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::FindNextLowerMode( D3DDeviceInfo* pD3DDeviceInfo )
{
    DWORD iModeCur = pD3DDeviceInfo->dwCurrentMode;
    D3DModeInfo* pD3DModeInfoCur = &pD3DDeviceInfo->modes[iModeCur];
    DWORD dwWidthCur = pD3DModeInfoCur->Width;
    DWORD dwHeightCur = pD3DModeInfoCur->Height;
    DWORD dwNumPixelsCur = dwWidthCur * dwHeightCur;
    D3DFORMAT d3dfmtCur = pD3DModeInfoCur->Format;
    BOOL b32BitCur = (d3dfmtCur == D3DFMT_A8R8G8B8 ||
                      d3dfmtCur == D3DFMT_X8R8G8B8);
    DWORD iModeNew;
    D3DModeInfo* pD3DModeInfoNew;
    DWORD dwWidthNew;
    DWORD dwHeightNew;
    DWORD dwNumPixelsNew;
    D3DFORMAT d3dfmtNew = D3DFMT_UNKNOWN;
    BOOL b32BitNew;

    DWORD dwWidthBest = 0;
    DWORD dwHeightBest = 0;
    DWORD dwNumPixelsBest = 0;
    BOOL b32BitBest = FALSE;
    DWORD iModeBest = 0xffff;

    for( iModeNew = 0; iModeNew < pD3DDeviceInfo->dwNumModes; iModeNew++ )
    {
        // Don't pick the same mode we currently have
        if( iModeNew == iModeCur )
            continue;

        // Get info about new mode
        pD3DModeInfoNew = &pD3DDeviceInfo->modes[iModeNew];
        dwWidthNew = pD3DModeInfoNew->Width;
        dwHeightNew = pD3DModeInfoNew->Height;
        dwNumPixelsNew = dwWidthNew * dwHeightNew;
        d3dfmtNew = pD3DModeInfoNew->Format;
        b32BitNew = (d3dfmtNew == D3DFMT_A8R8G8B8 ||
                     d3dfmtNew == D3DFMT_X8R8G8B8);

        // If we're currently 32-bit and new mode is same width/height and 16-bit, take it
        if( b32BitCur && 
            !b32BitNew &&
            pD3DModeInfoNew->Width == dwWidthCur &&
            pD3DModeInfoNew->Height == dwHeightCur)
        {
            pD3DDeviceInfo->dwCurrentMode = iModeNew;
            return TRUE;
        }

        // If new mode is smaller than current mode, see if it's our best so far
        if( dwNumPixelsNew < dwNumPixelsCur )
        {
            // If current best is 32-bit, new mode needs to be bigger to be best
            if( b32BitBest && (dwNumPixelsNew < dwNumPixelsBest ) )
                continue;

            // If new mode is bigger or equal to best, make it the best
            if( (dwNumPixelsNew > dwNumPixelsBest) || 
                (!b32BitBest && b32BitNew) )
            {
                dwWidthBest = dwWidthNew;
                dwHeightBest = dwHeightNew;
                dwNumPixelsBest = dwNumPixelsNew;
                iModeBest = iModeNew;
                b32BitBest = b32BitNew;
            }
        }
    }
    if( iModeBest == 0xffff )
        return FALSE; // no smaller mode found
    pD3DDeviceInfo->dwCurrentMode = iModeBest;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: CreateWindowedRenderUnit()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateWindowedRenderUnit( RenderUnit* pRenderUnit )
{
    HRESULT hr;
    UINT iAdapter = pRenderUnit->iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    DWORD iMonitor = pD3DAdapterInfo->iMonitor;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DDEVTYPE curType;

    // Find the best device for the primary adapter.  Use HAL
    // if it's there, otherwise SW, otherwise REF.
    pD3DAdapterInfo->dwCurrentDevice = 0xffff; // unless we find something better
    curType = D3DDEVTYPE_FORCE_DWORD;
    for( DWORD iDevice = 0; iDevice < pD3DAdapterInfo->dwNumDevices; iDevice++)
    {
        pD3DDeviceInfo = &pD3DAdapterInfo->devices[iDevice];
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_HAL && !pD3DAdapterInfo->bDisableHW &&
            pD3DDeviceInfo->bCanDoWindowed )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_HAL;
            break;
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW &&
            pD3DDeviceInfo->bCanDoWindowed )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_SW;
            // but keep looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_REF && m_bAllowRef && curType != D3DDEVTYPE_SW )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_REF;
            // but keep looking
        }
    }
    if( pD3DAdapterInfo->dwCurrentDevice == 0xffff )
        return D3DAPPERR_NOHARDWAREDEVICE;
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];

    D3DWindowedModeInfo D3DWindowedModeInfo;

    D3DWindowedModeInfo.DisplayFormat = pD3DAdapterInfo->d3ddmDesktop.Format;
    D3DWindowedModeInfo.BackBufferFormat = pD3DAdapterInfo->d3ddmDesktop.Format;
    if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
    {
        D3DWindowedModeInfo.BackBufferFormat = D3DFMT_A8R8G8B8;
        if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
        {
            D3DWindowedModeInfo.BackBufferFormat = D3DFMT_X8R8G8B8;
            if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
            {
                D3DWindowedModeInfo.BackBufferFormat = D3DFMT_A1R5G5B5;
                if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
                {
                    D3DWindowedModeInfo.BackBufferFormat = D3DFMT_R5G6B5;
                    if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
                    {
                        return E_FAIL;
                    }
                }
            }
        }
    }

    pRenderUnit->DeviceType = pD3DDeviceInfo->DeviceType;
    pRenderUnit->dwBehavior = D3DWindowedModeInfo.dwBehavior;
    pRenderUnit->iMonitor = iMonitor;
    pRenderUnit->d3dpp.BackBufferWidth = 0;
    pRenderUnit->d3dpp.BackBufferHeight = 0;
    pRenderUnit->d3dpp.Windowed = TRUE;
    pRenderUnit->d3dpp.FullScreen_RefreshRateInHz = 0;
    pRenderUnit->d3dpp.FullScreen_PresentationInterval = 0;
    pRenderUnit->d3dpp.BackBufferFormat = D3DWindowedModeInfo.BackBufferFormat;
    pRenderUnit->d3dpp.AutoDepthStencilFormat = D3DWindowedModeInfo.DepthStencilFormat;
    pRenderUnit->d3dpp.BackBufferCount = 1;
    pRenderUnit->d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
    pRenderUnit->d3dpp.SwapEffect = m_SwapEffectWindowed;
    pRenderUnit->d3dpp.hDeviceWindow = pD3DAdapterInfo->hWndDevice;
    pRenderUnit->d3dpp.EnableAutoDepthStencil = m_bUseDepthBuffer;
    pRenderUnit->d3dpp.Flags = 0;
    // Create device
    hr = m_pD3D->CreateDevice( iAdapter, pRenderUnit->DeviceType, m_hWnd,
                               pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, &pRenderUnit->pd3dDevice );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateDeviceStats()
// Desc: Store device description
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateDeviceStats()
{
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit; 
    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        if( pRenderUnit->DeviceType == D3DDEVTYPE_REF )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("REF") );
        else if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("HAL") );
        else if( pRenderUnit->DeviceType == D3DDEVTYPE_SW )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("SW") );

        if( pRenderUnit->dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING &&
            pRenderUnit->dwBehavior & D3DCREATE_PUREDEVICE )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (pure hw vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated pure hw vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (hw vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated hw vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_MIXED_VERTEXPROCESSING )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (mixed vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated mixed vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_SOFTWARE_VERTEXPROCESSING )
        {
            lstrcat( pRenderUnit->strDeviceStats, TEXT(" (sw vp)") );
        }

        if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
        {
            lstrcat( pRenderUnit->strDeviceStats, TEXT(": ") );
            TCHAR szDescription[300];
            DXUtil_ConvertAnsiStringToGeneric( szDescription, 
                m_Adapters[pRenderUnit->iAdapter]->d3dAdapterIdentifier.Description, 300 );
            lstrcat( pRenderUnit->strDeviceStats, szDescription );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: SwitchToRenderUnit()
// Desc: Updates internal variables and notifies client that we are switching
//       to a new RenderUnit / D3D device.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::SwitchToRenderUnit( UINT iRenderUnit )
{
    RenderUnit* pRenderUnit = &m_RenderUnits[iRenderUnit];
    MonitorInfo* pMonitorInfo = &m_Monitors[pRenderUnit->iMonitor];

    m_pd3dDevice = pRenderUnit->pd3dDevice;
    if( !m_bWindowed )
        m_rcRenderCurDevice = pMonitorInfo->rcScreen;

    if( m_pd3dDevice != NULL )
    {
        // Store render target surface desc
        LPDIRECT3DSURFACE8 pBackBuffer;
        m_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
        pBackBuffer->GetDesc( &m_d3dsdBackBuffer );
        pBackBuffer->Release();
    }

    lstrcpy( m_strDeviceStats, pRenderUnit->strDeviceStats );
    lstrcpy( m_strFrameStats, pRenderUnit->strFrameStats );

    // Notify the client to switch to this device
    SetDevice(iRenderUnit);
}




//-----------------------------------------------------------------------------
// Name: SetProjectionMatrix()
// Desc: This function sets up an appropriate projection matrix to support 
//       rendering the appropriate parts of the scene to each screen.
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::SetProjectionMatrix( FLOAT fNear, FLOAT fFar )
{
    D3DXMATRIX mat;
    INT cx, cy;
    INT dx, dy;
    INT dd;
    FLOAT l,r,t,b;

    if( m_bAllScreensSame )
    {
        cx = (m_rcRenderCurDevice.right + m_rcRenderCurDevice.left) / 2;
        cy = (m_rcRenderCurDevice.bottom + m_rcRenderCurDevice.top) / 2;
        dx = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
        dy = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    }
    else
    {
        cx = (m_rcRenderTotal.right + m_rcRenderTotal.left) / 2;
        cy = (m_rcRenderTotal.bottom + m_rcRenderTotal.top) / 2;
        dx = m_rcRenderTotal.right - m_rcRenderTotal.left;
        dy = m_rcRenderTotal.bottom - m_rcRenderTotal.top;
    }

    dd = (dx > dy ? dy : dx);

    l = FLOAT(m_rcRenderCurDevice.left - cx) / (FLOAT)(dd);
    r = FLOAT(m_rcRenderCurDevice.right - cx) / (FLOAT)(dd);
    t = FLOAT(m_rcRenderCurDevice.top - cy) / (FLOAT)(dd);
    b = FLOAT(m_rcRenderCurDevice.bottom - cy) / (FLOAT)(dd);

    l = fNear * l;
    r = fNear * r;
    t = fNear * t;
    b = fNear * b;

    D3DXMatrixPerspectiveOffCenterLH( &mat, l, r, t, b, fNear, fFar );
    return m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &mat );
}




//-----------------------------------------------------------------------------
// Name: SortModesCallback()
// Desc: Callback function for sorting display modes (used by BuildDeviceList).
//-----------------------------------------------------------------------------
static int SortModesCallback( const VOID* arg1, const VOID* arg2 )
{
    D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;
    D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

    if( p1->Width  < p2->Width )    return -1;
    if( p1->Width  > p2->Width )    return +1;
    if( p1->Height < p2->Height )   return -1;
    if( p1->Height > p2->Height )   return +1;
    if( p1->Format > p2->Format )   return -1;
    if( p1->Format < p2->Format )   return +1;

    return 0;
}




//-----------------------------------------------------------------------------
// Name: BuildDeviceList()
// Desc: Builds a list of all available adapters, devices, and modes.
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::BuildDeviceList()
{
    DWORD dwNumDeviceTypes;
    const TCHAR* strDeviceDescs[] = { TEXT("HAL"), TEXT("SW"), TEXT("REF") };
    const D3DDEVTYPE DeviceTypes[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_SW, D3DDEVTYPE_REF };
    if( m_bAllowRef )
        dwNumDeviceTypes = 3;
    else
        dwNumDeviceTypes = 2;

    HMONITOR hMonitor = NULL;
    BOOL bHALExists = FALSE;
    BOOL bHALIsWindowedCompatible = FALSE;
    BOOL bHALIsDesktopCompatible = FALSE;
    BOOL bHALIsSampleCompatible = FALSE;

    // Loop through all the adapters on the system (usually, there's just one
    // unless more than one graphics card is present).
    for( UINT iAdapter = 0; iAdapter < m_pD3D->GetAdapterCount(); iAdapter++ )
    {
        // Fill in adapter info
        if( m_Adapters[m_dwNumAdapters] == NULL )
        {
            m_Adapters[m_dwNumAdapters] = new D3DAdapterInfo;
            if( m_Adapters[m_dwNumAdapters] == NULL )
                return E_OUTOFMEMORY;
            ZeroMemory( m_Adapters[m_dwNumAdapters], sizeof(D3DAdapterInfo) );
        }

        D3DAdapterInfo* pAdapter  = m_Adapters[m_dwNumAdapters];
        m_pD3D->GetAdapterIdentifier( iAdapter, D3DENUM_NO_WHQL_LEVEL, &pAdapter->d3dAdapterIdentifier );
        m_pD3D->GetAdapterDisplayMode( iAdapter, &pAdapter->d3ddmDesktop );
        pAdapter->dwNumDevices    = 0;
        pAdapter->dwCurrentDevice = 0;
        pAdapter->bLeaveBlack = FALSE;
        pAdapter->iMonitor = NO_MONITOR;

        // Find the MonitorInfo that corresponds to this adapter.  If the monitor
        // is disabled, the adapter has a NULL HMONITOR and we cannot find the 
        // corresponding MonitorInfo.  (Well, if one monitor was disabled, we
        // could link the one MonitorInfo with a NULL HMONITOR to the one
        // D3DAdapterInfo with a NULL HMONITOR, but if there are more than one,
        // we can't link them, so it's safer not to ever try.)
        hMonitor = m_pD3D->GetAdapterMonitor( iAdapter );
        if( hMonitor != NULL )
        {
            for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                MonitorInfo* pMonitorInfo;
                pMonitorInfo = &m_Monitors[iMonitor];
                if( pMonitorInfo->hMonitor == hMonitor )
                {
                    pAdapter->iMonitor = iMonitor;
                    pMonitorInfo->iAdapter = iAdapter;
                    break;
                }
            }
        }

        // Enumerate all display modes on this adapter
        D3DDISPLAYMODE modes[100];
        D3DFORMAT      formats[20];
        DWORD dwNumFormats      = 0;
        DWORD dwNumModes        = 0;
        DWORD dwNumAdapterModes = m_pD3D->GetAdapterModeCount( iAdapter );

        // Add the adapter's current desktop format to the list of formats
        formats[dwNumFormats++] = pAdapter->d3ddmDesktop.Format;

        for( UINT iMode = 0; iMode < dwNumAdapterModes; iMode++ )
        {
            // Get the display mode attributes
            D3DDISPLAYMODE DisplayMode;
            m_pD3D->EnumAdapterModes( iAdapter, iMode, &DisplayMode );

            // Filter out low-resolution modes
            if( DisplayMode.Width  < 640 || DisplayMode.Height < 400 )
                continue;

            // Check if the mode already exists (to filter out refresh rates)
            for( DWORD m=0L; m<dwNumModes; m++ )
            {
                if( ( modes[m].Width  == DisplayMode.Width  ) &&
                    ( modes[m].Height == DisplayMode.Height ) &&
                    ( modes[m].Format == DisplayMode.Format ) )
                    break;
            }

            // If we found a new mode, add it to the list of modes
            if( m == dwNumModes )
            {
                modes[dwNumModes].Width       = DisplayMode.Width;
                modes[dwNumModes].Height      = DisplayMode.Height;
                modes[dwNumModes].Format      = DisplayMode.Format;
                modes[dwNumModes].RefreshRate = 0;
                dwNumModes++;

                // Check if the mode's format already exists
                for( DWORD f=0; f<dwNumFormats; f++ )
                {
                    if( DisplayMode.Format == formats[f] )
                        break;
                }

                // If the format is new, add it to the list
                if( f== dwNumFormats )
                    formats[dwNumFormats++] = DisplayMode.Format;
            }
        }

        // Sort the list of display modes (by format, then width, then height)
        qsort( modes, dwNumModes, sizeof(D3DDISPLAYMODE), SortModesCallback );

        // Add devices to adapter
        for( UINT iDevice = 0; iDevice < dwNumDeviceTypes; iDevice++ )
        {
            // Fill in device info
            D3DDeviceInfo* pDevice;
            pDevice                 = &pAdapter->devices[pAdapter->dwNumDevices];
            pDevice->DeviceType     = DeviceTypes[iDevice];
            m_pD3D->GetDeviceCaps( iAdapter, DeviceTypes[iDevice], &pDevice->d3dCaps );
            pDevice->strDesc        = strDeviceDescs[iDevice];
            pDevice->dwNumModes     = 0;
            pDevice->dwCurrentMode  = 0;
            pDevice->bCanDoWindowed = FALSE;
            pDevice->bWindowed      = FALSE;
            pDevice->MultiSampleType = D3DMULTISAMPLE_NONE;

            // Examine each format supported by the adapter to see if it will
            // work with this device and meets the needs of the application.
            BOOL  bFormatConfirmed[20];
            DWORD dwBehavior[20];
            D3DFORMAT fmtDepthStencil[20];

            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                bFormatConfirmed[f] = FALSE;
                fmtDepthStencil[f] = D3DFMT_UNKNOWN;

                // Skip formats that cannot be used as render targets on this device
                if( FAILED( m_pD3D->CheckDeviceType( iAdapter, pDevice->DeviceType,
                                                     formats[f], formats[f], FALSE ) ) )
                    continue;

                if( pDevice->DeviceType == D3DDEVTYPE_SW )
                {
                    // This system has a SW device
                    pAdapter->bHasSW = TRUE;
                }

                if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                {
                    // This system has a HAL device
                    bHALExists = TRUE;
                    pAdapter->bHasHAL = TRUE;

                    if( pDevice->d3dCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED )
                    {
                        // HAL can run in a window for some mode
                        bHALIsWindowedCompatible = TRUE;

                        if( f == 0 )
                        {
                            // HAL can run in a window for the current desktop mode
                            bHALIsDesktopCompatible = TRUE;
                        }
                    }
                }

                // Confirm the device/format for HW vertex processing
                if( pDevice->d3dCaps.DevCaps&D3DDEVCAPS_HWTRANSFORMANDLIGHT )
                {
                    if( pDevice->d3dCaps.DevCaps&D3DDEVCAPS_PUREDEVICE )
                    {
                        dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                        D3DCREATE_PUREDEVICE;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }

                    if ( FALSE == bFormatConfirmed[f] )
                    {
                        dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }

                    if ( FALSE == bFormatConfirmed[f] )
                    {
                        dwBehavior[f] = D3DCREATE_MIXED_VERTEXPROCESSING;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }
                }

                // Confirm the device/format for SW vertex processing
                if( FALSE == bFormatConfirmed[f] )
                {
                    dwBehavior[f] = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

                    if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                  formats[f] ) ) )
                        bFormatConfirmed[f] = TRUE;
                }

                if( bFormatConfirmed[f] && m_bMultithreaded )
                {
                    dwBehavior[f] |= D3DCREATE_MULTITHREADED;
                }

                // Find a suitable depth/stencil buffer format for this device/format
                if( bFormatConfirmed[f] && m_bUseDepthBuffer )
                {
                    if( !FindDepthStencilFormat( iAdapter, pDevice->DeviceType,
                        formats[f], &fmtDepthStencil[f] ) )
                    {
                        bFormatConfirmed[f] = FALSE;
                    }
                }
            }

            // Add all enumerated display modes with confirmed formats to the
            // device's list of valid modes
            for( DWORD m=0L; m<dwNumModes; m++ )
            {
                for( DWORD f=0; f<dwNumFormats; f++ )
                {
                    if( modes[m].Format == formats[f] )
                    {
                        if( bFormatConfirmed[f] == TRUE )
                        {
                            // Add this mode to the device's list of valid modes
                            pDevice->modes[pDevice->dwNumModes].Width      = modes[m].Width;
                            pDevice->modes[pDevice->dwNumModes].Height     = modes[m].Height;
                            pDevice->modes[pDevice->dwNumModes].Format     = modes[m].Format;
                            pDevice->modes[pDevice->dwNumModes].dwBehavior = dwBehavior[f];
                            pDevice->modes[pDevice->dwNumModes].DepthStencilFormat = fmtDepthStencil[f];
                            pDevice->dwNumModes++;

                            if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                                bHALIsSampleCompatible = TRUE;
                        }
                    }
                }
            }

            // Select any 640x480 mode for default (but prefer a 16-bit mode)
            for( m=0; m<pDevice->dwNumModes; m++ )
            {
                if( pDevice->modes[m].Width==640 && pDevice->modes[m].Height==480 )
                {
                    pDevice->dwCurrentMode = m;
                    if( pDevice->modes[m].Format == D3DFMT_R5G6B5 ||
                        pDevice->modes[m].Format == D3DFMT_X1R5G5B5 ||
                        pDevice->modes[m].Format == D3DFMT_A1R5G5B5 )
                    {
                        break;
                    }
                }
            }

            // Check if the device is compatible with the desktop display mode
            // (which was added initially as formats[0])
            if( bFormatConfirmed[0] && (pDevice->d3dCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) )
            {
                pDevice->bCanDoWindowed = TRUE;
                pDevice->bWindowed      = TRUE;
            }

            // If valid modes were found, keep this device
            if( pDevice->dwNumModes > 0 )
            {
                pAdapter->dwNumDevices++;
                if( pDevice->DeviceType == D3DDEVTYPE_SW )
                    pAdapter->bHasAppCompatSW = TRUE;
                else if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                    pAdapter->bHasAppCompatHAL = TRUE;
            }
        }

        // If valid devices were found, keep this adapter
// Count adapters even if no devices, so we can throw up blank windows on them
//        if( pAdapter->dwNumDevices > 0 )
            m_dwNumAdapters++;
    }
/*
    // Return an error if no compatible devices were found
    if( 0L == m_dwNumAdapters )
        return D3DAPPERR_NOCOMPATIBLEDEVICES;

    // Pick a default device that can render into a window
    // (This code assumes that the HAL device comes before the REF
    // device in the device array).
    for( DWORD a=0; a<m_dwNumAdapters; a++ )
    {
        for( DWORD d=0; d < m_Adapters[a]->dwNumDevices; d++ )
        {
            if( m_Adapters[a]->devices[d].bWindowed )
            {
                m_Adapters[a]->dwCurrentDevice = d;
                m_dwAdapter = a;
                m_bWindowed = TRUE;

                // Display a warning message
                if( m_Adapters[a]->devices[d].DeviceType == D3DDEVTYPE_REF )
                {
                    if( !bHALExists )
                        DisplayErrorMsg( D3DAPPERR_NOHARDWAREDEVICE, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsSampleCompatible )
                        DisplayErrorMsg( D3DAPPERR_HALNOTCOMPATIBLE, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsWindowedCompatible )
                        DisplayErrorMsg( D3DAPPERR_NOWINDOWEDHAL, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsDesktopCompatible )
                        DisplayErrorMsg( D3DAPPERR_NODESKTOPHAL, MSGWARN_SWITCHEDTOREF );
                    else // HAL is desktop compatible, but not sample compatible
                        DisplayErrorMsg( D3DAPPERR_NOHALTHISMODE, MSGWARN_SWITCHEDTOREF );
                }

                return S_OK;
            }
        }
    }
    return D3DAPPERR_NOWINDOWABLEDEVICES;
*/

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CheckWindowedFormat()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CheckWindowedFormat( UINT iAdapter, D3DWindowedModeInfo* pD3DWindowedModeInfo )
{
    HRESULT hr;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    D3DDeviceInfo* pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
    BOOL bFormatConfirmed = FALSE;

    if( FAILED( hr = m_pD3D->CheckDeviceType( iAdapter, pD3DDeviceInfo->DeviceType,
        pD3DAdapterInfo->d3ddmDesktop.Format, pD3DWindowedModeInfo->BackBufferFormat, TRUE ) ) )
    {
        return hr;
    }

    // Confirm the device/format for HW vertex processing
    if( pD3DDeviceInfo->d3dCaps.DevCaps&D3DDEVCAPS_HWTRANSFORMANDLIGHT )
    {
        if( pD3DDeviceInfo->d3dCaps.DevCaps&D3DDEVCAPS_PUREDEVICE )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                            D3DCREATE_PUREDEVICE;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }

        if ( !bFormatConfirmed )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }

        if ( !bFormatConfirmed )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_MIXED_VERTEXPROCESSING;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }
    }

    // Confirm the device/format for SW vertex processing
    if( !bFormatConfirmed )
    {
        pD3DWindowedModeInfo->dwBehavior = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

        if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                      pD3DWindowedModeInfo->BackBufferFormat ) ) )
            bFormatConfirmed = TRUE;
    }

    if( bFormatConfirmed && m_bMultithreaded )
    {
        pD3DWindowedModeInfo->dwBehavior |= D3DCREATE_MULTITHREADED;
    }

    // Find a suitable depth/stencil buffer format for this device/format
    if( bFormatConfirmed && m_bUseDepthBuffer )
    {
        if( !FindDepthStencilFormat( iAdapter, pD3DDeviceInfo->DeviceType,
            pD3DWindowedModeInfo->BackBufferFormat, &pD3DWindowedModeInfo->DepthStencilFormat ) )
        {
            bFormatConfirmed = FALSE;
        }
    }

    if( !bFormatConfirmed )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindDepthStencilFormat()
// Desc: Finds a depth/stencil format for the given device that is compatible
//       with the render target format and meets the needs of the app.
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::FindDepthStencilFormat( UINT iAdapter, D3DDEVTYPE DeviceType,
    D3DFORMAT TargetFormat, D3DFORMAT* pDepthStencilFormat )
{
    if( m_dwMinDepthBits <= 16 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D16 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D16 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D16;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 15 && m_dwMinStencilBits <= 1 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D15S1 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D15S1 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D15S1;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X8 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24X8 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24X8;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 8 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24S8 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24S8 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24S8;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 4 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X4S4 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24X4S4 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24X4S4;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 32 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D32 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D32 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D32;
                return TRUE;
            }
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Cleanup3DEnvironment()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::Cleanup3DEnvironment()
{
    RenderUnit* pRenderUnit;

    for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        SwitchToRenderUnit( iRenderUnit );
        if( pRenderUnit->bDeviceObjectsRestored )
        {
            InvalidateDeviceObjects();
            pRenderUnit->bDeviceObjectsRestored = FALSE;
        }
        if( pRenderUnit->bDeviceObjectsInited )
        {
            DeleteDeviceObjects();
            pRenderUnit->bDeviceObjectsInited = FALSE;
        }
        SAFE_RELEASE(m_pd3dDevice);
    }
    m_dwNumRenderUnits = 0;
    SAFE_RELEASE(m_pD3D);
}




//-----------------------------------------------------------------------------
// Name: Render3DEnvironment()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Render3DEnvironment()
{
    HRESULT hr;
    RenderUnit* pRenderUnit;
    D3DAdapterInfo* pAdapterInfo;

    m_fTime        = DXUtil_Timer( TIMER_GETAPPTIME );
    m_fElapsedTime = DXUtil_Timer( TIMER_GETELAPSEDTIME );


    // Tell client to update the world
    FrameMove();
    UpdateFrameStats();

    for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        pAdapterInfo = m_Adapters[pRenderUnit->iAdapter];

        SwitchToRenderUnit( iRenderUnit );

        if( m_pd3dDevice == NULL )
            continue;

        // Test the cooperative level to see if it's okay to render
        if( FAILED( hr = m_pd3dDevice->TestCooperativeLevel() ) )
        {
            // If the device was lost, do not render until we get it back
            if( D3DERR_DEVICELOST == hr )
                return S_OK;

            // Check if the device needs to be reset.
            if( D3DERR_DEVICENOTRESET == hr )
            {
                // If we are windowed, read the desktop mode and use the same format for
                // the back buffer
                if( m_bWindowed )
                {
                    m_pD3D->GetAdapterDisplayMode( pRenderUnit->iAdapter, &pAdapterInfo->d3ddmDesktop );
//                    m_d3dpp.BackBufferFormat = pAdapterInfo->d3ddmDesktop.Format;
                }

                if( pRenderUnit->bDeviceObjectsRestored )
                {
                    InvalidateDeviceObjects();
                    pRenderUnit->bDeviceObjectsRestored = FALSE;
                }
                if( FAILED( hr = m_pd3dDevice->Reset( &pRenderUnit->d3dpp ) ) )
                {
                    m_bErrorMode = TRUE;
                }
                else
                {
                    if( FAILED( hr = RestoreDeviceObjects() ) )
                    {
                        m_bErrorMode = TRUE;
                    }
                    else
                    {
                        pRenderUnit->bDeviceObjectsRestored = TRUE;
                    }
                }
            }
        }

        // Tell client to render using the current device
        Render();
    }

    // Call Present() in a separate loop once all rendering is done
    // so multiple monitors are as closely synced visually as possible
    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        SwitchToRenderUnit( iRenderUnit );
        // Present the results of the rendering to the screen
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateErrorBox()
// Desc: Update the box that shows the error message
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateErrorBox()
{
    MonitorInfo* pMonitorInfo;
    HWND hwnd;
    RECT rcBounds;
    static DWORD dwTimeLast = 0;
    DWORD dwTimeNow;
    FLOAT fTimeDelta;

    // Make sure all the RenderUnits / D3D devices have been torn down
    // so the error box is visible
    if( m_bErrorMode && m_dwNumRenderUnits > 0 )
    {
        Cleanup3DEnvironment();
    }

    // Update timing to determine how much to move error box
    if( dwTimeLast == 0 )
        dwTimeLast = timeGetTime();
    dwTimeNow = timeGetTime();
    fTimeDelta = (FLOAT)(dwTimeNow - dwTimeLast) / 1000.0f;
    dwTimeLast = dwTimeNow;

    // Load error string if necessary
    if( m_szError[0] == TEXT('\0') )
    {
        GetTextForError( m_hrError, m_szError, sizeof(m_szError) / sizeof(TCHAR) );
    }

    for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        hwnd = pMonitorInfo->hWnd;
        if( hwnd == NULL )
            continue;
        if( m_SaverMode == sm_full )
        {
            rcBounds = pMonitorInfo->rcScreen;
            ScreenToClient( hwnd, (POINT*)&rcBounds.left );
            ScreenToClient( hwnd, (POINT*)&rcBounds.right );
        }
        else
        {
            rcBounds = m_rcRenderTotal;
        }

        if( pMonitorInfo->widthError == 0 )
        {
            if( m_SaverMode == sm_preview )                
            {
                pMonitorInfo->widthError = (float) (rcBounds.right - rcBounds.left);
                pMonitorInfo->heightError = (float) (rcBounds.bottom - rcBounds.top);
                pMonitorInfo->xError = 0.0f;
                pMonitorInfo->yError = 0.0f;
                pMonitorInfo->xVelError = 0.0f;
                pMonitorInfo->yVelError = 0.0f;
                InvalidateRect( hwnd, NULL, FALSE );    // Invalidate the hwnd so it gets drawn
                UpdateWindow( hwnd );
            }
            else
            {
                pMonitorInfo->widthError = 300;
                pMonitorInfo->heightError = 150;
                pMonitorInfo->xError = (rcBounds.right + rcBounds.left - pMonitorInfo->widthError) / 2.0f;
                pMonitorInfo->yError = (rcBounds.bottom + rcBounds.top - pMonitorInfo->heightError) / 2.0f;
                pMonitorInfo->xVelError = (rcBounds.right - rcBounds.left) / 10.0f;
                pMonitorInfo->yVelError = (rcBounds.bottom - rcBounds.top) / 20.0f;
            }
        }
        else
        {
            if( m_SaverMode != sm_preview )
            {
                RECT rcOld;
                RECT rcNew;

                SetRect( &rcOld, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
                    (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
                    (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );

                // Update rect velocity
                if( (pMonitorInfo->xError + pMonitorInfo->xVelError * fTimeDelta + 
                    pMonitorInfo->widthError > rcBounds.right && pMonitorInfo->xVelError > 0.0f) ||
                    (pMonitorInfo->xError + pMonitorInfo->xVelError * fTimeDelta < 
                    rcBounds.left && pMonitorInfo->xVelError < 0.0f) )
                {
                    pMonitorInfo->xVelError = -pMonitorInfo->xVelError;
                }
                if( (pMonitorInfo->yError + pMonitorInfo->yVelError * fTimeDelta + 
                    pMonitorInfo->heightError > rcBounds.bottom && pMonitorInfo->yVelError > 0.0f) ||
                    (pMonitorInfo->yError + pMonitorInfo->yVelError * fTimeDelta < 
                    rcBounds.top && pMonitorInfo->yVelError < 0.0f) )
                {
                    pMonitorInfo->yVelError = -pMonitorInfo->yVelError;
                }
                // Update rect position
                pMonitorInfo->xError += pMonitorInfo->xVelError * fTimeDelta;
                pMonitorInfo->yError += pMonitorInfo->yVelError * fTimeDelta;
            
                SetRect( &rcNew, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
                    (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
                    (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );

                if( rcOld.left != rcNew.left || rcOld.top != rcNew.top )
                {
                    InvalidateRect( hwnd, &rcOld, FALSE );    // Invalidate old rect so it gets erased
                    InvalidateRect( hwnd, &rcNew, FALSE );    // Invalidate new rect so it gets drawn
                    UpdateWindow( hwnd );
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: GetTextForError()
// Desc: Translate an HRESULT error code into a string that can be displayed
//       to explain the error.  A class derived from CD3DScreensaver can 
//       provide its own version of this function that provides app-specific
//       error translation instead of or in addition to calling this function.
//       This function returns TRUE if a specific error was translated, or
//       FALSE if no specific translation for the HRESULT was found (though
//       it still puts a generic string into pszError).
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::GetTextForError( HRESULT hr, TCHAR* pszError, 
                                       DWORD dwNumChars )
{
    const DWORD dwErrorMap[][2] = 
    {
    //  HRESULT, stringID
        E_FAIL, IDS_ERR_GENERIC,
        D3DAPPERR_NODIRECT3D, IDS_ERR_NODIRECT3D,
        D3DAPPERR_NOWINDOWEDHAL, IDS_ERR_NOWINDOWEDHAL,
        D3DAPPERR_CREATEDEVICEFAILED, IDS_ERR_CREATEDEVICEFAILED,
        D3DAPPERR_NOCOMPATIBLEDEVICES, IDS_ERR_NOCOMPATIBLEDEVICES,
        D3DAPPERR_NOHARDWAREDEVICE, IDS_ERR_NOHARDWAREDEVICE,
        D3DAPPERR_HALNOTCOMPATIBLE, IDS_ERR_HALNOTCOMPATIBLE,
        D3DAPPERR_NOHALTHISMODE, IDS_ERR_NOHALTHISMODE,   
        D3DAPPERR_MEDIANOTFOUND, IDS_ERR_MEDIANOTFOUND,   
        D3DAPPERR_RESIZEFAILED, IDS_ERR_RESIZEFAILED,    
        E_OUTOFMEMORY, IDS_ERR_OUTOFMEMORY,     
        D3DERR_OUTOFVIDEOMEMORY, IDS_ERR_OUTOFVIDEOMEMORY,
        D3DAPPERR_NOPREVIEW, IDS_ERR_NOPREVIEW
    };
    const DWORD dwErrorMapSize = sizeof(dwErrorMap) / sizeof(DWORD[2]);

    DWORD iError;
    DWORD resid = 0;

    for( iError = 0; iError < dwErrorMapSize; iError++ )
    {
        if( hr == (HRESULT)dwErrorMap[iError][0] )
        {
            resid = dwErrorMap[iError][1];
        }
    }
    if( resid == 0 )
    {
        resid = IDS_ERR_GENERIC;
    }

    LoadString( NULL, resid, pszError, dwNumChars );

    if( resid == IDS_ERR_GENERIC )
        return FALSE;
    else
        return TRUE;
}




//-----------------------------------------------------------------------------
// Name: UpdateFrameStats()
// Desc: Keep track of the frame count
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateFrameStats()
{
    UINT iRenderUnit;
    RenderUnit* pRenderUnit;
    UINT iAdapter;
    static FLOAT fLastTime = 0.0f;
    static DWORD dwFrames  = 0L;
    FLOAT fTime = DXUtil_Timer( TIMER_GETABSOLUTETIME );

    ++dwFrames;

    // Update the scene stats once per second
    if( fTime - fLastTime > 1.0f )
    {
        m_fFPS    = dwFrames / (fTime - fLastTime);
        fLastTime = fTime;
        dwFrames  = 0L;

        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            iAdapter = pRenderUnit->iAdapter;

            // Get adapter's current mode so we can report
            // bit depth (back buffer depth may be unknown)
            D3DDISPLAYMODE mode;
            m_pD3D->GetAdapterDisplayMode( iAdapter, &mode );

            _stprintf( pRenderUnit->strFrameStats, TEXT("%.02f fps (%dx%dx%d)"), m_fFPS,
                       mode.Width, mode.Height,
                       mode.Format==D3DFMT_X8R8G8B8?32:16 );
            if( m_bUseDepthBuffer )
            {
                D3DAdapterInfo* pAdapterInfo = m_Adapters[iAdapter];
                D3DDeviceInfo*  pDeviceInfo  = &pAdapterInfo->devices[pAdapterInfo->dwCurrentDevice];
                D3DModeInfo*    pModeInfo    = &pDeviceInfo->modes[pDeviceInfo->dwCurrentMode];

                switch( pModeInfo->DepthStencilFormat )
                {
                case D3DFMT_D16:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D16)") );
                    break;
                case D3DFMT_D15S1:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D15S1)") );
                    break;
                case D3DFMT_D24X8:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24X8)") );
                    break;
                case D3DFMT_D24S8:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24S8)") );
                    break;
                case D3DFMT_D24X4S4:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24X4S4)") );
                    break;
                case D3DFMT_D32:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D32)") );
                    break;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DoPaint()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::DoPaint(HWND hwnd, HDC hdc)
{
    HMONITOR hMonitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
    MonitorInfo* pMonitorInfo;
    for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++)
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        if( pMonitorInfo->hMonitor == hMonitor )
            break;
    }

    if( iMonitor == m_dwNumMonitors )
        return;

    // Draw the error message box
    RECT rc;
    SetRect( &rc, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
        (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
        (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );
    FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW+1));
    FrameRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    RECT rc2;
    int height;
    rc2 = rc;
    height = DrawText(hdc, m_szError, -1, &rc, DT_WORDBREAK | DT_CENTER | DT_CALCRECT );
    rc = rc2;

    rc2.top = (rc.bottom + rc.top - height) / 2;

    DrawText(hdc, m_szError, -1, &rc2, DT_WORDBREAK | DT_CENTER );

    // Erase everywhere except the error message box
    ExcludeClipRect( hdc, rc.left, rc.top, rc.right, rc.bottom );
    rc = pMonitorInfo->rcScreen;
    ScreenToClient( hwnd, (POINT*)&rc.left );
    ScreenToClient( hwnd, (POINT*)&rc.right );
    FillRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH) );
}




//-----------------------------------------------------------------------------
// Name: ChangePassword()
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ChangePassword()
{
    // Load the password change DLL
    HINSTANCE mpr = LoadLibrary( TEXT("MPR.DLL") );

    if ( mpr != NULL )
    {
        // Grab the password change function from it
        typedef DWORD (PASCAL *PWCHGPROC)( LPCSTR, HWND, DWORD, LPVOID );
        PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, "PwdChangePasswordA" );

        // Do the password change
        if ( pwd != NULL )
            pwd( "SCRSAVE", m_hWndParent, 0, NULL );

        // Free the library
        FreeLibrary( mpr );
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayErrorMsg()
// Desc: Displays error messages in a message box
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::DisplayErrorMsg( HRESULT hr, DWORD dwType )
{
    TCHAR strMsg[512];

    GetTextForError( hr, strMsg, 512 );

    MessageBox( m_hWnd, strMsg, m_strWindowTitle, MB_ICONERROR | MB_OK );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: ReadScreenSettings()
// Desc: Read the registry settings that affect how the screens are set up and
//       used.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ReadScreenSettings( HKEY hkeyParent )
{
    TCHAR strKey[100];
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo;
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);
    DWORD dwLength2 = sizeof(GUID);
    GUID guidAdapterID;
    GUID guidZero;
    ZeroMemory( &guidAdapterID, sizeof(GUID) );
    ZeroMemory( &guidZero, sizeof(GUID) );

    RegQueryValueEx( hkeyParent, TEXT("AllScreensSame"), NULL, &dwType, 
        (BYTE*)&m_bAllScreensSame, &dwLength);
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
        if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
        {
            RegQueryValueEx( hkey, TEXT("Adapter ID"), NULL, &dwType, 
                (BYTE*)&guidAdapterID, &dwLength2);

            RegQueryValueEx( hkey, TEXT("Leave Black"), NULL, &dwType, 
                (BYTE*)&pD3DAdapterInfo->bLeaveBlack, &dwLength);

            if( guidAdapterID == pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier ||
                guidAdapterID == guidZero )
            {
                RegQueryValueEx( hkey, TEXT("Disable Hardware"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->bDisableHW, &dwLength);
                RegQueryValueEx( hkey, TEXT("Width"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, &dwLength);
                RegQueryValueEx( hkey, TEXT("Height"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, &dwLength);
                RegQueryValueEx( hkey, TEXT("Format"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, &dwLength);
            }
            RegCloseKey( hkey);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: WriteScreenSettings()
// Desc: Write the registry settings that affect how the screens are set up and
//       used.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::WriteScreenSettings( HKEY hkeyParent )
{
    TCHAR strKey[100];
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo;
    HKEY hkey;

    RegSetValueEx( hkeyParent, TEXT("AllScreensSame"), NULL, REG_DWORD, 
        (BYTE*)&m_bAllScreensSame, sizeof(DWORD) );
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
        if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
        {
            RegSetValueEx( hkey, TEXT("Leave Black"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->bLeaveBlack, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Disable Hardware"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->bDisableHW, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Width"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Height"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Format"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Adapter ID"), NULL, REG_BINARY, 
                (BYTE*)&pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier, sizeof(GUID) );
            RegCloseKey( hkey);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DoScreenSettingsDialog()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::DoScreenSettingsDialog( HWND hwndParent )
{
    LPCTSTR pstrTemplate;

    if( m_dwNumAdapters > 1 && !m_bOneScreenOnly )
        pstrTemplate = MAKEINTRESOURCE( IDD_MULTIMONITORSETTINGS );
    else
        pstrTemplate = MAKEINTRESOURCE( IDD_SINGLEMONITORSETTINGS );

    DialogBox(m_hInstance, pstrTemplate, hwndParent, ScreenSettingsDlgProcStub );
}




//-----------------------------------------------------------------------------
// Name: ScreenSettingsDlgProcStub()
// Desc:
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CD3DScreensaver::ScreenSettingsDlgProcStub( HWND hWnd, UINT uMsg,
                                                 WPARAM wParam, LPARAM lParam )
{
    return s_pD3DScreensaver->ScreenSettingsDlgProc( hWnd, uMsg, wParam, lParam );
}




// We need to store a copy of the original screen settings so that the user
// can modify those settings in the dialog, then hit Cancel and have the
// original settings restored.
static D3DAdapterInfo* s_AdaptersSave[9];
static BOOL s_bAllScreensSameSave;

//-----------------------------------------------------------------------------
// Name: ScreenSettingsDlgProc()
// Desc:
//-----------------------------------------------------------------------------
INT_PTR CD3DScreensaver::ScreenSettingsDlgProc( HWND hWnd, UINT uMsg, 
                                                WPARAM wParam, LPARAM lParam )
{
    HWND hwndTabs = GetDlgItem(hWnd, IDC_MONITORSTAB);
    HWND hwndModeList = GetDlgItem(hWnd, IDC_MODESCOMBO);
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            INT i = 0;
            TC_ITEM tie; 
            TCHAR szFmt[100];
            TCHAR sz[100];

            GetWindowText(GetDlgItem(hWnd, IDC_TABNAMEFMT), szFmt, 100);

            tie.mask = TCIF_TEXT | TCIF_IMAGE; 
            tie.iImage = -1; 
            for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                wsprintf(sz, szFmt, iMonitor + 1);
                tie.pszText = sz; 
                TabCtrl_InsertItem(hwndTabs, i++, &tie);
            }
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                s_AdaptersSave[iAdapter] = new D3DAdapterInfo;
                if( s_AdaptersSave[iAdapter] != NULL )
                    *s_AdaptersSave[iAdapter] = *m_Adapters[iAdapter];
            }
            s_bAllScreensSameSave = m_bAllScreensSame;
            SetupAdapterPage(hWnd);
            CheckDlgButton(hWnd, IDC_SAME, (m_bAllScreensSame ? BST_CHECKED : BST_UNCHECKED));
        }
        return TRUE;
 
    case WM_NOTIFY:
        {
            NMHDR* pnmh = (LPNMHDR)lParam;
            UINT code = pnmh->code;
            if (code == TCN_SELCHANGE)
            {
                SetupAdapterPage(hWnd);
            }
        }
        return TRUE;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case IDC_SAME:
            m_bAllScreensSame = (IsDlgButtonChecked(hWnd, IDC_SAME) == BST_CHECKED);
            break;

        case IDC_LEAVEBLACK:
        case IDC_RENDER:
            if( m_bOneScreenOnly )
            {
                GetBestAdapter( &iAdapter );
                iMonitor = m_Adapters[iAdapter]->iMonitor;
            }
            else
            {
                iMonitor = TabCtrl_GetCurSel(hwndTabs);
            }
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( IsDlgButtonChecked(hWnd, IDC_LEAVEBLACK) == BST_CHECKED )
            {
                m_Adapters[iAdapter]->bLeaveBlack = TRUE;
                EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), FALSE);
            }
            else
            {
                m_Adapters[iAdapter]->bLeaveBlack = FALSE;
                EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), TRUE);
            }
            break;

        case IDC_MODESCOMBO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                DWORD iSel;
                DWORD iMode;

                if( m_bOneScreenOnly )
                {
                    GetBestAdapter( &iAdapter );
                    iMonitor = m_Adapters[iAdapter]->iMonitor;
                }
                else
                {
                    iMonitor = TabCtrl_GetCurSel(hwndTabs);
                }
                pMonitorInfo = &m_Monitors[iMonitor];
                iAdapter = pMonitorInfo->iAdapter;
                iSel = ComboBox_GetCurSel( hwndModeList );
                if( iSel == 0 )
                {
                    // "Automatic"
                    m_Adapters[iAdapter]->dwUserPrefWidth = 0;
                    m_Adapters[iAdapter]->dwUserPrefHeight = 0;
                    m_Adapters[iAdapter]->d3dfmtUserPrefFormat = D3DFMT_UNKNOWN;
                }
                else
                {
                    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
                    D3DDeviceInfo* pD3DDeviceInfo;
                    D3DModeInfo* pD3DModeInfo;
                    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
                    iMode = (DWORD)ComboBox_GetItemData( hwndModeList, iSel );
                    pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
                    m_Adapters[iAdapter]->dwUserPrefWidth = pD3DModeInfo->Width;
                    m_Adapters[iAdapter]->dwUserPrefHeight = pD3DModeInfo->Height;
                    m_Adapters[iAdapter]->d3dfmtUserPrefFormat = pD3DModeInfo->Format;
                }
            }
            break;

        case IDC_DISABLEHW:
            if( m_bOneScreenOnly )
            {
                GetBestAdapter( &iAdapter );
                iMonitor = m_Adapters[iAdapter]->iMonitor;
            }
            else
            {
                iMonitor = TabCtrl_GetCurSel(hwndTabs);
            }
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( IsDlgButtonChecked( hWnd, IDC_DISABLEHW ) == BST_CHECKED )
                m_Adapters[iAdapter]->bDisableHW = TRUE;
            else
                m_Adapters[iAdapter]->bDisableHW = FALSE;
            SetupAdapterPage( hWnd );
            break;

        case IDC_MOREINFO:
            {
                if( m_bOneScreenOnly )
                {
                    GetBestAdapter( &iAdapter );
                    iMonitor = m_Adapters[iAdapter]->iMonitor;
                }
                else
                {
                    iMonitor = TabCtrl_GetCurSel(hwndTabs);
                }
                pMonitorInfo = &m_Monitors[iMonitor];
                iAdapter = pMonitorInfo->iAdapter;
                D3DAdapterInfo* pD3DAdapterInfo;
                TCHAR szText[500];

                if( pMonitorInfo->hMonitor == NULL )
                    pD3DAdapterInfo = NULL;
                else
                    pD3DAdapterInfo = m_Adapters[pMonitorInfo->iAdapter];

                // Accelerated / Unaccelerated settings
                BOOL bHasHAL = FALSE;
                BOOL bHasAppCompatHAL = FALSE;
                BOOL bDisabledHAL = FALSE;
                BOOL bHasSW = FALSE;
                BOOL bHasAppCompatSW = FALSE;
    
                if( pD3DAdapterInfo != NULL )
                {
                    bHasHAL = pD3DAdapterInfo->bHasHAL;
                    bHasAppCompatHAL = pD3DAdapterInfo->bHasAppCompatHAL;
                    bDisabledHAL = pD3DAdapterInfo->bDisableHW;
                    bHasSW = pD3DAdapterInfo->bHasSW;
                    bHasAppCompatSW = pD3DAdapterInfo->bHasAppCompatSW;
                }
                if( bHasHAL && !bDisabledHAL && bHasAppCompatHAL )
                {
                    // Good HAL
                    LoadString( NULL, IDS_INFO_GOODHAL, szText, 500 );
                }
                else if( bHasHAL && bDisabledHAL )
                {
                    // Disabled HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_GOODSW, szText, 500 );
                    else if( bHasSW )
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_NOSW, szText, 500 );
                }
                else if( bHasHAL && !bHasAppCompatHAL )
                {
                    // Bad HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_BADHAL_GOODSW, szText, 500 );
                    else if( bHasSW )
                        LoadString( NULL, IDS_INFO_BADHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_BADHAL_NOSW, szText, 500 );
                }
                else 
                {
                    // No HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_NOHAL_GOODSW, szText, 500 );
                    else if( bHasSW  )
                        LoadString( NULL, IDS_INFO_NOHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_NOHAL_NOSW, szText, 500 );
                }

                MessageBox( hWnd, szText, pMonitorInfo->strDeviceName, MB_OK | MB_ICONINFORMATION );
                break;
            }

        case IDOK:
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                SAFE_DELETE( s_AdaptersSave[iAdapter] );
            }
            EndDialog(hWnd, IDOK);
            break;

        case IDCANCEL:
            // Restore member values to original state
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                if( s_AdaptersSave[iAdapter] != NULL )
                    *m_Adapters[iAdapter] = *s_AdaptersSave[iAdapter];
                SAFE_DELETE( s_AdaptersSave[iAdapter] );
            }
            m_bAllScreensSame = s_bAllScreensSameSave;
            EndDialog(hWnd, IDCANCEL);
            break;
        }
        return TRUE;

    default:
        return FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: SetupAdapterPage()
// Desc: Set up the controls for a given page in the Screen Settings dialog.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::SetupAdapterPage( HWND hWnd )
{
    HWND hwndTabs = GetDlgItem(hWnd, IDC_MONITORSTAB);
    HWND hwndModeList = GetDlgItem(hWnd, IDC_MODESCOMBO);
    UINT iPage = TabCtrl_GetCurFocus(hwndTabs);
    HWND hwndDesc = GetDlgItem(hWnd, IDC_ADAPTERNAME);
    MonitorInfo* pMonitorInfo;
    D3DAdapterInfo* pD3DAdapterInfo;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DModeInfo* pD3DModeInfo;

    if( m_bOneScreenOnly )
    {
        DWORD iAdapter;
        GetBestAdapter( &iAdapter );
        if( iAdapter != NO_ADAPTER )
        {
            pD3DAdapterInfo = m_Adapters[iAdapter];
            iPage = pD3DAdapterInfo->iMonitor;
        }
    }

    pMonitorInfo = &m_Monitors[iPage];

    SetWindowText( hwndDesc, pMonitorInfo->strDeviceName );

    if( pMonitorInfo->iAdapter == NO_ADAPTER )
        pD3DAdapterInfo = NULL;
    else
        pD3DAdapterInfo = m_Adapters[pMonitorInfo->iAdapter];

    // Accelerated / Unaccelerated settings
    BOOL bHasHAL = FALSE;
    BOOL bHasAppCompatHAL = FALSE;
    BOOL bDisabledHAL = FALSE;
    BOOL bHasSW = FALSE;
    BOOL bHasAppCompatSW = FALSE;
    
    if( pD3DAdapterInfo != NULL )
    {
        bHasHAL = pD3DAdapterInfo->bHasHAL;
        bHasAppCompatHAL = pD3DAdapterInfo->bHasAppCompatHAL;
        bDisabledHAL = pD3DAdapterInfo->bDisableHW;
        bHasSW = pD3DAdapterInfo->bHasSW;
        bHasAppCompatSW = pD3DAdapterInfo->bHasAppCompatSW;
    }

    TCHAR szStatus[200];
    if( bHasHAL && !bDisabledHAL && bHasAppCompatHAL )
    {
        LoadString( NULL, IDS_RENDERING_HAL, szStatus, 200 );
    }
    else if( bHasSW && bHasAppCompatSW )
    {
        LoadString( NULL, IDS_RENDERING_SW, szStatus, 200 );
    }
    else
    {
        LoadString( NULL, IDS_RENDERING_NONE, szStatus, 200 );
    }
    SetWindowText( GetDlgItem( hWnd, IDC_RENDERING ), szStatus );

    if( bHasHAL && bHasAppCompatHAL )
    {
        EnableWindow( GetDlgItem( hWnd, IDC_DISABLEHW ), TRUE );
        CheckDlgButton( hWnd, IDC_DISABLEHW, 
            pD3DAdapterInfo->bDisableHW ? BST_CHECKED : BST_UNCHECKED );
    }
    else
    {
        EnableWindow( GetDlgItem( hWnd, IDC_DISABLEHW ), FALSE );
        CheckDlgButton( hWnd, IDC_DISABLEHW, BST_UNCHECKED );
    }

    if( bHasAppCompatHAL || bHasAppCompatSW )
    {
        if( pD3DAdapterInfo->bLeaveBlack )
            CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_LEAVEBLACK);
        else
            CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_RENDER);
        EnableWindow(GetDlgItem(hWnd, IDC_LEAVEBLACK), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_RENDER), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_SCREENUSAGEBOX), TRUE);

    }
    else
    {
        CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_LEAVEBLACK);
        EnableWindow(GetDlgItem(hWnd, IDC_LEAVEBLACK), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_RENDER), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_SCREENUSAGEBOX), FALSE);
    }

    if( IsDlgButtonChecked(hWnd, IDC_LEAVEBLACK) == BST_CHECKED )
    {
        EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), TRUE);
    }

    // Mode list
    ComboBox_ResetContent( hwndModeList );
    if( pD3DAdapterInfo == NULL )
        return;
    TCHAR strAutomatic[100];
    GetWindowText(GetDlgItem(hWnd, IDC_AUTOMATIC), strAutomatic, 100);
    ComboBox_AddString( hwndModeList, strAutomatic );
    ComboBox_SetItemData( hwndModeList, 0, -1 );
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
    DWORD iSelInitial = 0;
    TCHAR strModeFmt[100];

    GetWindowText(GetDlgItem(hWnd, IDC_MODEFMT), strModeFmt, 100);
    for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++ )
    {
        DWORD dwBitDepth;
        TCHAR strMode[80];
        DWORD dwItem;

        pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
        dwBitDepth = 16;
        if( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
            pD3DModeInfo->Format == D3DFMT_A8R8G8B8 ||
            pD3DModeInfo->Format == D3DFMT_R8G8B8 )
        {
            dwBitDepth = 32;
        }

        wsprintf( strMode, strModeFmt, pD3DModeInfo->Width,
                  pD3DModeInfo->Height, dwBitDepth );
        dwItem = ComboBox_AddString( hwndModeList, strMode );
        ComboBox_SetItemData( hwndModeList, dwItem, iMode );

        if( pD3DModeInfo->Width == pD3DAdapterInfo->dwUserPrefWidth &&
            pD3DModeInfo->Height == pD3DAdapterInfo->dwUserPrefHeight &&
            pD3DModeInfo->Format == pD3DAdapterInfo->d3dfmtUserPrefFormat )
        {
            iSelInitial = dwItem;
        }
    }
    ComboBox_SetCurSel( hwndModeList, iSelInitial );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\default\strings.h ===
#define idsAppName      100
#define idsNoConfigure  101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\common\scrnsave.c ===
//----------------------------------------------------------------------------
//
// SCRNSAVE.C      --    skeleton for screen saver application
//
//    4/5/94 francish   merged NT and Win4 saver code, folded in SCRNSAVE.SCR
//
//----------------------------------------------------------------------------

#define WIN31
#include <windows.h>
#include <windowsx.h>
#include "scrnsave.h"
#include <regstr.h>
#include <commctrl.h>
#include <imm.h>

#define DBG_MSGS    0

const TCHAR szScreenSaverKey[] = REGSTR_PATH_SCREENSAVE;
TCHAR szPasswordActiveValue[] = REGSTR_VALUE_USESCRPASSWORD;
const TCHAR szPasswordValue[] = REGSTR_VALUE_SCRPASSWORD;
TCHAR szPwdDLL[] = TEXT("PASSWORD.CPL");
CHAR szFnName[] = "VerifyScreenSavePwd";        // Proc name, must be ANSI
TCHAR szImmDLL[] = TEXT("IMM32.DLL");
CHAR szImmFnc[] = "ImmAssociateContext";        // Proc name, must be ANSI
#if 0
TCHAR szCoolSaverHacks[] = REGSTR_PATH_SETUP TEXT("\\Screen Savers");
TCHAR szMouseThreshold[] = TEXT("Mouse Threshold");
TCHAR szPasswordDelay[] = TEXT("Password Delay");
#endif

typedef BOOL (FAR PASCAL * VERIFYPWDPROC) (HWND);
typedef HIMC (FAR PASCAL * IMMASSOCPROC) (HWND,HIMC);


//----------------------------------------------------------------------------
// variables declared in SCRNSAVE.H
HINSTANCE hMainInstance = 0;
HWND hMainWindow = 0;
BOOL fChildPreview = FALSE;



//----------------------------------------------------------------------------
// other globals
POINT ptMouse;
BOOL fClosing = FALSE;
BOOL fCheckingPassword = FALSE;
HINSTANCE hInstPwdDLL = NULL;
VERIFYPWDPROC VerifyPassword = NULL;
static BOOL preview_like_fullscreen = FALSE;
static UINT uShellAutoPlayQueryMessage = 0;
HINSTANCE hInstImm = NULL;
IMMASSOCPROC ImmFnc = NULL;
HIMC hPrevImc = (HIMC)0L;


static BOOL fOnWin95 = FALSE;  //TRUE if on Chicago, FALSE if on Cairo

//----------------------------------------------------------------------------
// random junk
DWORD dwWakeThreshold = 4;  //default to slight movement
DWORD dwPasswordDelay = 0;
DWORD dwBlankTime = 0;
#define MAX_PASSWORD_DELAY_IN_SECONDS (60)

BYTE  bACLineStatus = AC_LINE_UNKNOWN;    // Last state of AC line 

//----------------------------------------------------------------------------
// forward declarations of internal fns
static INT_PTR DoScreenSave( HWND hParent );
static INT_PTR DoSaverPreview( LPCTSTR szUINTHandle );
static INT_PTR DoConfigBox( HWND hParent );
static INT_PTR DoChangePw( LPCTSTR szUINTHandle );
static BOOL DoPasswordCheck( HWND hParent );
VOID LoadPwdDLL(VOID);
VOID UnloadPwdDLL(VOID);


//----------------------------------------------------------------------------
// helper for time
static DWORD
GetElapsedTime(DWORD from, DWORD to)
{
    return (to >= from)? (to - from) : (1 + to + (((DWORD)-1) - from));
}

//----------------------------------------------------------------------------
// helper to convert text to unsigned int
static UINT_PTR
atoui( LPCTSTR szUINT )
{
   UINT_PTR uValue = 0;

   while( ( *szUINT >= TEXT('0') ) && ( *szUINT <= TEXT('9') ) )
      uValue = ( ( uValue * 10 ) + ( *szUINT++ - TEXT('0') ) );

   return uValue;
}


//----------------------------------------------------------------------------
// Local reboot and hotkey control (on Win95)
static void
HogMachine( BOOL value )
{
    BOOL dummy;

    //
    // NT is always secure, therefore we don't need to call this on Cairo/NT
    //
    if (fOnWin95) {
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, value, &dummy, 0 );
    }
}


//----------------------------------------------------------------------------
// entry point (duh)
INT_PTR PASCAL
WinMainN( HINSTANCE hInst, HINSTANCE hPrev, LPTSTR szCmdLine, int nCmdShow )
{
    LPCTSTR pch = szCmdLine;
    HWND hParent = 0;
    OSVERSIONINFO osvi;
    INITCOMMONCONTROLSEX icce = {0};

	ZeroMemory(&icce, sizeof(icce));
	icce.dwSize = sizeof(icce);
	icce.dwICC = ICC_TAB_CLASSES;
	InitCommonControlsEx(&icce);

    hMainInstance = hInst;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    fOnWin95 = (GetVersionEx(&osvi) &&
                osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    _try
    {
      for(;;) switch( *pch )
      {
          case TEXT('S'):
          case TEXT('s'):
              return DoScreenSave( NULL );

          case TEXT('L'):
          case TEXT('l'):
              // special switch for tests such as WinBench
              // this is NOT a hack to make bechmarks look good
              // it's a hack to allow you to benchmark a screen saver
              // many bechmarking apps require the whole screen in foreground
              // which makes it hard to measure how a screensaver adds CPU load
              // you must provide a parent window (just like preview mode)
              preview_like_fullscreen = TRUE;
          case TEXT('P'):
          case TEXT('p'):
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoSaverPreview( pch );

          case TEXT('A'):
          case TEXT('a'):
              if (!fOnWin95)
                  return -1;
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoChangePw( pch );

          case TEXT('C'):
          case TEXT('c'): {
              HWND hwndParent = NULL
              ;
              // Look for optional parent window after the "C",
              // syntax is "C:hwnd_value"
              if (*(++pch) == TEXT(':')) {
                   hwndParent = (HWND)atoui( ++pch );
              }

              if (hwndParent == NULL || !IsWindow(hwndParent))
                   hwndParent = GetForegroundWindow();

              return DoConfigBox( hwndParent );
          }

          case TEXT('\0'):
              return DoConfigBox( NULL );

          case TEXT(' '):
          case TEXT('-'):
          case TEXT('/'):
              pch++;   // skip spaces and common switch prefixes
              break;

          default:
              return -1;
      }
    }
    _except(UnhandledExceptionFilter(GetExceptionInformation()))
    {
      // don't leave local reboot and hotkeys disabled on Win95
      HogMachine( FALSE );
    }

    return -1;
}


//----------------------------------------------------------------------------
// default screen-saver proc, declared in SCRNSAVE.H
// intended to be called by the consumer's ScreenSaverProc where
// DefWindowProc would normally be called
LRESULT WINAPI
DefScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
#if DBG_MSGS
    TCHAR szBuff[80];

    wsprintf( szBuff, TEXT("*** DefSSP received:\t0x%04lx 0x%08lx 0x%08lx\n"), uMsg, wParam, lParam );
    OutputDebugString(szBuff);
#endif
    SYSTEM_POWER_STATUS sps;
    BYTE bCurrentLineStatus;

   if( !fChildPreview && !fClosing )
   {
      switch( uMsg )
      {
         case WM_CLOSE:
            //
            // Only do password check if on Windows 95.  WinNT (Cairo) has
            // the password check built into the security desktop for
            // C2 compliance.
            //
            if (fOnWin95) {
                if( !DoPasswordCheck( hWnd ) )
                {
                    GetCursorPos( &ptMouse );  // re-establish
                    return FALSE;
                }
            }
            break;

         case SCRM_VERIFYPW:
            if (fOnWin95)
                return ( VerifyPassword? (LRESULT)VerifyPassword( hWnd ) : 1L );
            break;

         default:
         {
            POINT ptMove, ptCheck;

            if( fCheckingPassword )
                break;

            switch( uMsg )
            {
                case WM_SHOWWINDOW:
                    if( (BOOL)wParam )
                    SetCursor( NULL );
                    break;

                case WM_SETCURSOR:
                    SetCursor( NULL );
                    return TRUE;

                case WM_MOUSEMOVE:
                    GetCursorPos( &ptCheck );
                    if( ( ptMove.x = ptCheck.x - ptMouse.x ) && ( ptMove.x < 0 ) )
                        ptMove.x *= -1;
                    if( ( ptMove.y = ptCheck.y - ptMouse.y ) && ( ptMove.y < 0 ) )
                        ptMove.y *= -1;
                    if( ((DWORD)ptMove.x + (DWORD)ptMove.y) > dwWakeThreshold )
                    {
                        PostMessage( hWnd, WM_CLOSE, 0, 0l );
                        ptMouse = ptCheck;
                    }
                    break;


                //
                // Handle Power Management event
                //
                case WM_POWERBROADCAST:
                    switch (wParam)
                    {
                        case PBT_APMPOWERSTATUSCHANGE:
                        if (GetSystemPowerStatus(&sps)) {
                            bCurrentLineStatus = sps.ACLineStatus;
                        }
                        else {
                            // we can't determine the power status, use default
                            bCurrentLineStatus = AC_LINE_UNKNOWN;
                        }

                        // If the current line status differs from the previous
                        // exit the screen saver, otherwise just keep running
                        if (bCurrentLineStatus != bACLineStatus) {
                            bACLineStatus = bCurrentLineStatus;
                            goto PostClose;
                        }
                        else {
                            bACLineStatus = bCurrentLineStatus;
                        }

                        break;

                        case PBT_APMRESUMECRITICAL:
                        case PBT_APMRESUMESUSPEND:
                        case PBT_APMRESUMESTANDBY:
                        case PBT_APMRESUMEAUTOMATIC:

                        // If the system is resuming from a real suspend
                        // (as opposed to a failed suspend) deactivate
                        // the screensaver.
                        if ((lParam & PBTF_APMRESUMEFROMFAILURE) == 0)
                        {
                            goto PostClose;
                        }
                        break;

                        default:
                        {
                            goto PostClose;
                        }
                    }
                    break;

                case WM_POWER:
                    //
                    // a critical resume does not generate a WM_POWERBROADCAST
                    // to windows for some reason, but it does generate an old
                    // WM_POWER message.
                    //
                    if (wParam == PWR_CRITICALRESUME)
                        goto PostClose;
                    break;

                case WM_ACTIVATEAPP:
                    if( wParam ) break;
                case WM_LBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_KEYDOWN:
                case WM_SYSKEYDOWN:
PostClose:
                    PostMessage( hWnd, WM_CLOSE, 0, 0l );
                    break;
            }
         }
      }
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. On Win95, we return 1 to cancel autoplay if we are password protected
   //
   // On WinNT, secure screen savers run on a secure separate desktop, and will never see
   // this message, therefore, this code will never get executed.
   //
   //
   // APPCOMPAT -
   // On NT we don't want to take down the screen saver unless it is running
   // on the same desktop as the autoplay shell.  There is code in the
   // NT autoplay shell that looks for this and does not run the app if
   // that is the case; however, I not positive that the uShellAutoPlayQueryMessage
   // will not go between desktops.  (BradG assures me that it will not, but you
   // never know.)  If secure screensavers on NT randomly close when you put
   // an autoplay cd in the drive, then this code should be examined closely.
   //
   if ((uMsg == uShellAutoPlayQueryMessage) && uMsg)
   {
      PostMessage(hWnd, WM_CLOSE, 0, 0L);
      return (VerifyPassword != NULL);
   }

   return DefWindowProc( hWnd, uMsg, wParam, lParam );
}

//----------------------------------------------------------------------------
// This window procedure takes care of important stuff before calling the
// consumer's ScreenSaverProc.  This helps to prevent us from getting hosed
// by wacky consumer code.
LRESULT WINAPI
RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
   switch( uMsg )
   {
      case WM_CREATE:
         // screen saver does not need the IME
         if ((hInstImm = GetModuleHandle(szImmDLL)) &&
             (ImmFnc = (IMMASSOCPROC)GetProcAddress(hInstImm,szImmFnc)))
             hPrevImc = ImmFnc(hWnd, (HIMC)0);

         // establish the mouse position
         GetCursorPos( &ptMouse );

         if( !fChildPreview )
            SetCursor( NULL );

         break;

      case WM_DESTROY:
         // screen saver does not need the IME
         if( hInstImm && ImmFnc && hPrevImc )
            ImmFnc(hWnd, hPrevImc);

         PostQuitMessage( 0 );
         break;

      case WM_SETTEXT:
         // don't let some fool change our title
         // we need to be able to use FindWindow() to find running instances
         // of full-screen windows screen savers
         // NOTE: USER slams our title in during WM_NCCREATE by calling the
         // defproc for WM_SETTEXT directly, so the initial title will get
         // there.  If this ever changes, we can simply set a bypass flag
         // during WM_NCCREATE processing.
         return FALSE;

      case WM_SYSCOMMAND:
         if (!fChildPreview)
         {
            switch (wParam)
            {
               case SC_NEXTWINDOW:       // no Alt-tabs
               case SC_PREVWINDOW:       // no shift-alt-tabs
               case SC_SCREENSAVE:       // no more screensavers
                  return FALSE;
                  break;
                case SC_MONITORPOWER:
                  //
                  // The monitor is shutting down.  Tell our client that he needs to
                  // cleanup and exit.
                  //
                  PostMessage( hWnd, WM_CLOSE, 0, 0l );
                  break;
            }
         }
         break;

      case WM_HELP:
      case WM_CONTEXTMENU:
         if( fChildPreview )
         {
            // if we're in preview mode, pump the help stuff to our owner
            HWND hParent = GetParent( hWnd );

            if( hParent && IsWindow( hParent ) )
               PostMessage( hParent, uMsg, (WPARAM)hParent, lParam );
               return TRUE;
         }
         break;

      case WM_TIMER:
         if( fClosing )
            return FALSE;
         Sleep( 0 );
         break;

      case WM_MOUSEMOVE:
      case WM_LBUTTONDOWN:
      case WM_MBUTTONDOWN:
      case WM_RBUTTONDOWN:
      case WM_KEYDOWN:
      case WM_SYSKEYDOWN:
         if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
         break;

      case WM_PAINT:
         if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
         if( !fChildPreview )
            SetCursor( NULL );
         break;
   }

   return ScreenSaverProc( hWnd, uMsg, wParam, lParam );
}

static void
InitRealScreenSave()
{
#if 0
   HKEY hkey;

   if (RegOpenKey(HKEY_CURRENT_USER, szCoolSaverHacks, &hkey) ==
      ERROR_SUCCESS)
   {
      DWORD data, len, type;

      len = sizeof(data);
      if ((RegQueryValueEx(hkey, szMouseThreshold, NULL, &type,
         (LPBYTE)&data, &len) == ERROR_SUCCESS) && (type == REG_DWORD))
      {
         dwWakeThreshold = max(dwWakeThreshold, data);
      }

      len = sizeof(data);
      if ((RegQueryValueEx(hkey, szPasswordDelay, NULL, &type,
         (LPBYTE)&data, &len) == ERROR_SUCCESS) && (type == REG_DWORD) && data)
      {
         data = min(MAX_PASSWORD_DELAY_IN_SECONDS, data);
         dwPasswordDelay = data * 1000;
         dwBlankTime = GetTickCount();
      }
   }
#endif

   LoadPwdDLL();
}

//----------------------------------------------------------------------------

static INT_PTR
DoScreenSave( HWND hParent )
{
   LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass");
   LPCTSTR pszWindowTitle;

   WNDCLASS cls;
   MSG      msg;
   UINT     uStyle;
   UINT     uExStyle;
   int      ncx, ncy;
   int      nx, ny;

   SYSTEM_POWER_STATUS sps;

   cls.hCursor        = NULL;
   cls.hIcon          = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) );
   cls.lpszMenuName   = NULL;
   cls.lpszClassName  = pszWindowClass;
   cls.hbrBackground  = GetStockObject( BLACK_BRUSH );
   cls.hInstance      = hMainInstance;
   cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC;
   cls.lpfnWndProc    = RealScreenSaverProc;
   cls.cbWndExtra     = 0;
   cls.cbClsExtra     = 0;

   if( hParent )
   {
      RECT rcParent;
      GetClientRect( hParent, &rcParent );
      ncx = rcParent.right;
      ncy = rcParent.bottom;
      nx  = 0;
      ny  = 0;
      uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN;
      uExStyle = 0;

      fChildPreview = TRUE;
      pszWindowTitle = TEXT("Preview");      // MUST differ from full screen
   }
   else
   {
      HWND hOther;

#ifdef SM_CXVIRTUALSCREEN
      nx  = GetSystemMetrics( SM_XVIRTUALSCREEN );
      ny  = GetSystemMetrics( SM_YVIRTUALSCREEN );
      ncx = GetSystemMetrics( SM_CXVIRTUALSCREEN );
      ncy = GetSystemMetrics( SM_CYVIRTUALSCREEN );

      if (ncx == 0 || ncy == 0)
#endif
      {
        RECT rc;
        HDC hdc = GetDC(NULL);
        GetClipBox(hdc, &rc);
        ReleaseDC(NULL, hdc);
        nx = rc.left;
        ny = rc.top;
        ncx = rc.right  - rc.left;
        ncy = rc.bottom - rc.top;
      }

      uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
      uExStyle = WS_EX_TOPMOST;

      pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview

      // if there is another NORMAL screen save instance, switch to it
      hOther = FindWindow( pszWindowClass, pszWindowTitle );

      if( hOther && IsWindow( hOther ) )
      {
         SetForegroundWindow( hOther );
         return 0;
      }

      // Get current system power status and store it
      if (GetSystemPowerStatus(&sps)) {
        bACLineStatus = sps.ACLineStatus;
      }
      else {
        // we can't determine the power status, use default
        bACLineStatus = AC_LINE_UNKNOWN;
      }


      InitRealScreenSave();
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. we return 1 to cancel autoplay if we are password protected
   //
   if (fOnWin95) {
        uShellAutoPlayQueryMessage = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
   } else {
        uShellAutoPlayQueryMessage = 0;
   }

   if( RegisterClass( &cls ) )
   {
      hMainWindow = CreateWindowEx( uExStyle, pszWindowClass, pszWindowTitle,
                        uStyle, nx, ny, ncx, ncy, hParent, (HMENU)NULL,
                        hMainInstance, (LPVOID)NULL );
   }

   msg.wParam = 0;
   if( hMainWindow )
   {
      if( !fChildPreview )
         SetForegroundWindow( hMainWindow );

      while( GetMessage( &msg, NULL, 0, 0 ) )
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }

   // free password-handling DLL if loaded
   UnloadPwdDLL();

   return msg.wParam;
}


//----------------------------------------------------------------------------

static INT_PTR
DoSaverPreview( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   // only preview on a valid parent window (NOT full screen)
   return ( (hParent && IsWindow( hParent ))? DoScreenSave( hParent ) : -1 );
}


//----------------------------------------------------------------------------

static INT_PTR
DoConfigBox( HWND hParent )
{
   // let the consumer register any special controls for the dialog
   if( !RegisterDialogClasses( hMainInstance ) )
      return FALSE;

   return DialogBox( hMainInstance, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
                     hParent, (WNDPROC)ScreenSaverConfigureDialog );

}


//----------------------------------------------------------------------------

static INT_PTR
DoChangePw( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   if( !hParent || !IsWindow( hParent ) )
      hParent = GetForegroundWindow();

   // allow the library to be hooked
   ScreenSaverChangePassword( hParent );
   return 0;
}

static const TCHAR szMprDll[] = TEXT("MPR.DLL");       // not to be localized
static const TCHAR szProviderName[] = TEXT("SCRSAVE"); // not to be localized

#ifdef UNICODE
static const CHAR szPwdChangePW[] = "PwdChangePasswordW"; // not to be localized
#else
static const CHAR szPwdChangePW[] = "PwdChangePasswordA"; // not to be localized
#endif

// bogus prototype
typedef DWORD (FAR PASCAL *PWCHGPROC)( LPCTSTR, HWND, DWORD, LPVOID );

void WINAPI
ScreenSaverChangePassword( HWND hParent )
{
   HINSTANCE mpr = LoadLibrary( szMprDll );

   if( mpr )
   {
      // netland hasn't cracked MNRENTRY yet
      PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, szPwdChangePW );

      if( pwd )
         pwd( szProviderName, hParent, 0, NULL );

      FreeLibrary( mpr );
   }
}


//----------------------------------------------------------------------------

static BOOL
DoPasswordCheck( HWND hParent )
{
   // don't reenter and don't check when we've already decided
   if( fCheckingPassword || fClosing )
      return FALSE;

   if( VerifyPassword )
   {
      static DWORD lastcheck = (DWORD)-1;
      DWORD curtime = GetTickCount();
      MSG msg;

      if (dwPasswordDelay &&
         (GetElapsedTime(dwBlankTime, curtime) < dwPasswordDelay))
      {
         fClosing = TRUE;
         goto _didcheck;
      }

      // no rapid checking...
      if ((lastcheck != (DWORD)-1) &&
         (GetElapsedTime(lastcheck, curtime) < 200))
      {
         goto _didcheck;
      }

      // do the check
      fCheckingPassword = TRUE;

      // flush WM_TIMER messages before putting up the dialog
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );

      // call the password verify proc
      fClosing = (BOOL)SendMessage( hParent, SCRM_VERIFYPW, 0, 0L );

      fCheckingPassword = FALSE;

      if (!fClosing)
         SetCursor(NULL);

      // curtime may be outdated by now
      lastcheck = GetTickCount();
   }
   else
   {
      // passwords disabled or unable to load handler DLL, always allow exit
      fClosing = TRUE;
   }

_didcheck:
   return fClosing;
}

//----------------------------------------------------------------------------
// stolen from the CRT, used to shirink our code

int _stdcall
DummyEntry( void )
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"')) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while (*(pszCmdLine = CharNext(pszCmdLine)) &&
              (*pszCmdLine != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while ((UINT)*pszCmdLine > (UINT)TEXT(' '))
            pszCmdLine = CharNext(pszCmdLine);
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && ((UINT)*pszCmdLine <= (UINT)TEXT(' '))) {
        pszCmdLine = CharNext(pszCmdLine);
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = (int)WinMainN(GetModuleHandle(NULL), NULL, pszCmdLine,
        si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;   // We never comes here.
}

//----------------------------------------------------------------------------
// main() entry point to satisfy old NT screen savers
void _cdecl main( int argc, char *argv[] ) {
    DummyEntry();
}

//----------------------------------------------------------------------------
// WinMain() entry point to satisfy old NT screen savers
int PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int nCmdShow ) {
    DummyEntry();
    return 0;

    // reference unreferenced parameters
    (void)hInst;
    (void)hPrev;
    (void)szCmdLine;
    (void)nCmdShow;
}


VOID LoadPwdDLL(VOID)
{
    HKEY hKey;

    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
        UnloadPwdDLL();

    // look in registry to see if password turned on, otherwise don't
    // bother to load password handler DLL
    if (RegOpenKey(HKEY_CURRENT_USER,szScreenSaverKey,&hKey) ==
        ERROR_SUCCESS)
    {
        DWORD dwVal,dwSize=sizeof(dwVal);

        if ((RegQueryValueEx(hKey,szPasswordActiveValue,
            NULL,NULL,(BYTE *) &dwVal,&dwSize) == ERROR_SUCCESS)
            && dwVal)
        {

            // try to load the DLL that contains password proc.
            hInstPwdDLL = LoadLibrary(szPwdDLL);
            if (hInstPwdDLL)
            {
                VerifyPassword = (VERIFYPWDPROC) GetProcAddress(hInstPwdDLL,
                    szFnName);

                if( VerifyPassword )
                    HogMachine( TRUE );
                else
                    UnloadPwdDLL();
            }
        }

        RegCloseKey(hKey);
    }

}

VOID UnloadPwdDLL(VOID)
{
    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
    {
        FreeLibrary(hInstPwdDLL);
        hInstPwdDLL = NULL;

        if( VerifyPassword )
        {
            VerifyPassword = NULL;
            HogMachine( FALSE );
        }
    }
}

//----------------------------------------------------------------------------
// compatbility stuff  (to make porting easier)
TCHAR szAppName[ APPNAMEBUFFERLEN ];
TCHAR szName[ TITLEBARNAMELEN ];
TCHAR szIniFile[ MAXFILELEN ];
TCHAR szScreenSaver[ 22 ];
TCHAR szHelpFile[ MAXFILELEN ];
TCHAR szNoHelpMemory[ BUFFLEN ];

// Quick fix for old screen savers that don't know about context
// sensitive help
UINT  MyHelpMessage = WM_HELP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\d3dsaver\d3dsaver.h ===
//-----------------------------------------------------------------------------
// File: D3DSaver.h
//
// Desc: Framework for screensavers that use Direct3D 8.0.
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _D3DSAVER_H
#define _D3DSAVER_H


//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
enum APPMSGTYPE { MSG_NONE, MSGERR_APPMUSTEXIT, MSGWARN_SWITCHEDTOREF };

#define D3DAPPERR_NODIRECT3D          0x82000001
#define D3DAPPERR_NOWINDOW            0x82000002
#define D3DAPPERR_NOCOMPATIBLEDEVICES 0x82000003
#define D3DAPPERR_NOWINDOWABLEDEVICES 0x82000004
#define D3DAPPERR_NOHARDWAREDEVICE    0x82000005
#define D3DAPPERR_HALNOTCOMPATIBLE    0x82000006
#define D3DAPPERR_NOWINDOWEDHAL       0x82000007
#define D3DAPPERR_NODESKTOPHAL        0x82000008
#define D3DAPPERR_NOHALTHISMODE       0x82000009
#define D3DAPPERR_NONZEROREFCOUNT     0x8200000a
#define D3DAPPERR_MEDIANOTFOUND       0x8200000b
#define D3DAPPERR_RESIZEFAILED        0x8200000c
#define D3DAPPERR_INITDEVICEOBJECTSFAILED 0x8200000d
#define D3DAPPERR_CREATEDEVICEFAILED  0x8200000e
#define D3DAPPERR_NOPREVIEW           0x8200000f


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
#define MAX_DISPLAYS 9
#define NO_ADAPTER 0xffffffff
#define NO_MONITOR 0xffffffff


//***************************************************************************************
// Modes of operation for screensaver
enum SaverMode
{
    sm_config,         // Config dialog box
    sm_preview,        // Mini preview window in Display Properties dialog
    sm_full,           // Full-on screensaver mode
    sm_test,           // Test mode
    sm_passwordchange  // Change password
};


// Prototype for VerifyScreenSavePwd() in password.cpl, used on Win9x
typedef BOOL (PASCAL * VERIFYPWDPROC) (HWND);


//-----------------------------------------------------------------------------
// Name: struct D3DModeInfo
// Desc: Structure for holding information about a display mode
//-----------------------------------------------------------------------------
struct D3DModeInfo
{
    DWORD      Width;      // Screen width in this mode
    DWORD      Height;     // Screen height in this mode
    D3DFORMAT  Format;     // Pixel format in this mode
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
    D3DFORMAT  DepthStencilFormat; // Which depth/stencil format to use with this mode
};




//-----------------------------------------------------------------------------
// Name: struct D3DWindowedModeInfo
// Desc: Structure for holding information about a display mode
//-----------------------------------------------------------------------------
struct D3DWindowedModeInfo
{
    D3DFORMAT  DisplayFormat;
    D3DFORMAT  BackBufferFormat;
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
    D3DFORMAT  DepthStencilFormat; // Which depth/stencil format to use with this mode
};




//-----------------------------------------------------------------------------
// Name: struct D3DDeviceInfo
// Desc: Structure for holding information about a Direct3D device, including
//       a list of modes compatible with this device
//-----------------------------------------------------------------------------
struct D3DDeviceInfo
{
    // Device data
    D3DDEVTYPE   DeviceType;      // Reference, HAL, etc.
    D3DCAPS8     d3dCaps;         // Capabilities of this device
    const TCHAR* strDesc;         // Name of this device
    BOOL         bCanDoWindowed;  // Whether this device can work in windowed mode

    // Modes for this device
    DWORD        dwNumModes;
    D3DModeInfo  modes[150];

    // Current state
    DWORD        dwCurrentMode;
    BOOL         bWindowed;
    D3DMULTISAMPLE_TYPE MultiSampleType;
};




//-----------------------------------------------------------------------------
// Name: struct D3DAdapterInfo
// Desc: Structure for holding information about an adapter, including a list
//       of devices available on this adapter
//-----------------------------------------------------------------------------
struct D3DAdapterInfo
{
    // Adapter data
    DWORD          iMonitor; // Which MonitorInfo corresponds to this adapter
    D3DADAPTER_IDENTIFIER8 d3dAdapterIdentifier;
    D3DDISPLAYMODE d3ddmDesktop;      // Desktop display mode for this adapter

    // Devices for this adapter
    DWORD          dwNumDevices;
    D3DDeviceInfo  devices[3];
    BOOL           bHasHAL;
    BOOL           bHasAppCompatHAL;
    BOOL           bHasSW;
    BOOL           bHasAppCompatSW;

    // User's preferred mode settings for this adapter
    DWORD          dwUserPrefWidth;
    DWORD          dwUserPrefHeight;
    D3DFORMAT      d3dfmtUserPrefFormat;
    BOOL           bLeaveBlack;  // If TRUE, don't render to this display
    BOOL           bDisableHW;   // If TRUE, don't use HAL on this display

    // Current state
    DWORD          dwCurrentDevice;
    HWND           hWndDevice;
};




//-----------------------------------------------------------------------------
// Name: struct MonitorInfo
// Desc: Structure for holding information about a monitor
//-----------------------------------------------------------------------------
struct MonitorInfo
{
    TCHAR          strDeviceName[128];
    TCHAR          strMonitorName[128];
    HMONITOR       hMonitor;
    RECT           rcScreen;
    DWORD          iAdapter; // Which D3DAdapterInfo corresponds to this monitor
    HWND           hWnd;

    // Error message state
    FLOAT          xError;
    FLOAT          yError;
    FLOAT          widthError;
    FLOAT          heightError;
    FLOAT          xVelError;
    FLOAT          yVelError;
};




//-----------------------------------------------------------------------------
// Name: struct RenderUnit
// Desc: 
//-----------------------------------------------------------------------------
struct RenderUnit
{
    UINT                  iAdapter;
    UINT                  iMonitor;
    D3DDEVTYPE            DeviceType;      // Reference, HAL, etc.
    DWORD                 dwBehavior;
    IDirect3DDevice8*     pd3dDevice;
    D3DPRESENT_PARAMETERS d3dpp;
    BOOL                  bDeviceObjectsInited; // InitDeviceObjects was called
    BOOL                  bDeviceObjectsRestored; // RestoreDeviceObjects was called
    TCHAR                 strDeviceStats[90];// String to hold D3D device stats
    TCHAR                 strFrameStats[40]; // String to hold frame stats
};




//-----------------------------------------------------------------------------
// Name: class CD3DScreensaver
// Desc: D3D screensaver class
//-----------------------------------------------------------------------------
class CD3DScreensaver
{
public:
                    CD3DScreensaver();

    virtual HRESULT Create( HINSTANCE hInstance );
    virtual INT     Run();
    HRESULT         DisplayErrorMsg( HRESULT hr, DWORD dwType = 0 );

protected:
    SaverMode       ParseCommandLine( TCHAR* pstrCommandLine );
    VOID            ChangePassword();
    HRESULT         DoSaver();

    virtual VOID    DoConfig() { }
    virtual VOID    ReadSettings() {};
    VOID            ReadScreenSettings( HKEY hkeyParent );
    VOID            WriteScreenSettings( HKEY hkeyParent );

    virtual VOID    DoPaint( HWND hwnd, HDC hdc );
    HRESULT         Initialize3DEnvironment();
    VOID            Cleanup3DEnvironment();
    HRESULT         Render3DEnvironment();
    static LRESULT CALLBACK SaverProcStub( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    virtual LRESULT SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID            InterruptSaver();
    VOID            ShutdownSaver();
    VOID            DoScreenSettingsDialog( HWND hwndParent );
    static INT_PTR CALLBACK ScreenSettingsDlgProcStub( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR         ScreenSettingsDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID            SetupAdapterPage(HWND hWnd);

    HRESULT         CreateSaverWindow();
    HRESULT         BuildDeviceList();
    BOOL            FindDepthStencilFormat( UINT iAdapter, D3DDEVTYPE DeviceType,
                        D3DFORMAT TargetFormat, D3DFORMAT* pDepthStencilFormat );
    HRESULT         CheckWindowedFormat( UINT iAdapter, D3DWindowedModeInfo* pD3DWindowedModeInfo );
    HRESULT         CreateFullscreenRenderUnit( RenderUnit* pRenderUnit );
    HRESULT         CreateWindowedRenderUnit( RenderUnit* pRenderUnit );
    BOOL            FindNextLowerMode( D3DDeviceInfo* pD3DDeviceInfo );
    VOID            SwitchToRenderUnit( UINT iRenderUnit );
    HRESULT         SetProjectionMatrix( FLOAT fNear, FLOAT fFar );
    virtual VOID    UpdateDeviceStats();
    virtual VOID    UpdateFrameStats();
    virtual BOOL    GetTextForError( HRESULT hr, TCHAR* pszError, DWORD dwNumChars );
    VOID            UpdateErrorBox();
    VOID            EnumMonitors( VOID );
    BOOL            GetBestAdapter( DWORD* piAdapter );

    virtual VOID    SetDevice( UINT iDevice )                  { }
    virtual HRESULT RegisterSoftwareDevice()                   { return S_OK; }
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer)     { return S_OK; }
    virtual HRESULT ConfirmMode( LPDIRECT3DDEVICE8 pd3dDev )   { return S_OK; }
    virtual HRESULT OneTimeSceneInit()                         { return S_OK; }
    virtual HRESULT InitDeviceObjects()                        { return S_OK; }
    virtual HRESULT RestoreDeviceObjects()                     { return S_OK; }
    virtual HRESULT FrameMove()                                { return S_OK; }
    virtual HRESULT Render()                                   { return S_OK; }
    virtual HRESULT InvalidateDeviceObjects()                  { return S_OK; }
    virtual HRESULT DeleteDeviceObjects()                      { return S_OK; }
    virtual HRESULT FinalCleanup()                             { return S_OK; }

protected:
    SaverMode       m_SaverMode;         // sm_config, sm_full, sm_preview, etc.
    BOOL            m_bAllScreensSame;   // If TRUE, show same image on all screens
    HWND            m_hWnd;              // Focus window and device window on primary
    HWND            m_hWndParent;
    HINSTANCE       m_hInstance;
    BOOL            m_bWaitForInputIdle;  // Used to pause when preview starts
    DWORD           m_dwSaverMouseMoveCount;
    BOOL            m_bIs9x;
    HINSTANCE       m_hPasswordDLL;
    VERIFYPWDPROC   m_VerifySaverPassword;
    BOOL            m_bCheckingSaverPassword;
    BOOL            m_bWindowed;

    // Variables for non-fatal error management
    BOOL            m_bErrorMode;        // Whether to display an error
    HRESULT         m_hrError;           // Error code to display
    TCHAR           m_szError[400];      // Error message text

    MonitorInfo     m_Monitors[MAX_DISPLAYS];
    DWORD           m_dwNumMonitors;
    RenderUnit      m_RenderUnits[MAX_DISPLAYS];
    DWORD           m_dwNumRenderUnits;
    D3DAdapterInfo* m_Adapters[MAX_DISPLAYS];
    DWORD           m_dwNumAdapters;
    IDirect3D8*     m_pD3D;
    IDirect3DDevice8* m_pd3dDevice;      // Current D3D device
    RECT            m_rcRenderTotal;     // Rect of entire area to be rendered
    RECT            m_rcRenderCurDevice; // Rect of render area of current device
    D3DSURFACE_DESC m_d3dsdBackBuffer;   // Info on back buffer for current device

    TCHAR           m_strWindowTitle[200]; // Title for the app's window
    BOOL            m_bAllowRef;         // Whether to allow REF D3D device
    BOOL            m_bUseDepthBuffer;   // Whether to autocreate depthbuffer
    BOOL            m_bMultithreaded;    // Whether to make D3D thread-safe
    BOOL            m_bOneScreenOnly;    // Only ever show screensaver on one screen
    TCHAR           m_strRegPath[200];   // Where to store registry info
    DWORD           m_dwMinDepthBits;    // Minimum number of bits needed in depth buffer
    DWORD           m_dwMinStencilBits;  // Minimum number of bits needed in stencil buffer
    D3DSWAPEFFECT   m_SwapEffectFullscreen; // SwapEffect to use in fullscreen Present()
    D3DSWAPEFFECT   m_SwapEffectWindowed; // SwapEffect to use in windowed Present()

    // Variables for timing
    FLOAT           m_fTime;             // Current time in seconds
    FLOAT           m_fElapsedTime;      // Time elapsed since last frame
    FLOAT           m_fFPS;              // Instanteous frame rate
    TCHAR           m_strDeviceStats[90];// D3D device stats for current device
    TCHAR           m_strFrameStats[40]; // Frame stats for current device
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\d3dsaver\dxutil.cpp ===
//-----------------------------------------------------------------------------
// File: DXUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//@@BEGIN_MSINTERNAL
//
// Hist: 11.16.98 - mwetzel - New for DirectX 7
//       12.10.98 - mwetzel - Changes to InitLight and axed InitViewport
//       04.12.99 - mwetzelf - Changed some helper funcs
//       07.06.99 - mwetzel - Mods for UNICODE support
//       03.20.00 - mwetzel - Added timer support
//
//@@END_MSINTERNAL
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#include <stdio.h> 
#include <stdarg.h>
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath()
// Desc: Returns the DirectX SDK media path
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath()
{
    static TCHAR strNull[2] = _T("");
    static TCHAR strPath[MAX_PATH];
    DWORD dwType;
    DWORD dwSize = MAX_PATH;
    HKEY  hKey;

    // Open the appropriate registry key
    LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                _T("Software\\Microsoft\\DirectX"),
                                0, KEY_READ, &hKey );
    if( ERROR_SUCCESS != lResult )
        return strNull;

    lResult = RegQueryValueEx( hKey, _T("DX8SDK Samples Path"), NULL,
                              &dwType, (BYTE*)strPath, &dwSize );
    RegCloseKey( hKey );

    if( ERROR_SUCCESS != lResult )
        return strNull;

    _tcscat( strPath, _T("\\Media\\") );

    return strPath;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_FindMediaFile()
// Desc: Returns a valid path to a DXSDK media file
//-----------------------------------------------------------------------------
HRESULT DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename )
{
    HANDLE file;

    if( NULL==strFilename || NULL==strPath )
        return E_INVALIDARG;

    // Check if the file exists in the current directory
    _tcscpy( strPath, strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }
    
    // Check if the file exists in the current directory
    _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }

    // On failure, just return the file as the path
    _tcscpy( strPath, strFilename );
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadStringRegKey()
// Desc: Helper function to read a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, 
                                 DWORD dwLength, TCHAR* strDefault )
{
    DWORD dwType;

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)strValue, &dwLength ) )
    {
        _tcscpy( strValue, strDefault );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteStringRegKey()
// Desc: Helper function to write a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName,
                                  TCHAR* strValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
                                        (BYTE*)strValue, 
                                        (_tcslen(strValue)+1)*sizeof(TCHAR) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadIntRegKey()
// Desc: Helper function to read a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, 
                              DWORD dwDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(DWORD);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pdwValue, &dwLength ) )
    {
        *pdwValue = dwDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteIntRegKey()
// Desc: Helper function to write a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&dwValue, sizeof(DWORD) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadBoolRegKey()
// Desc: Helper function to read a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, 
                              BOOL bDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(BOOL);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pbValue, &dwLength ) )
    {
        *pbValue = bDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteBoolRegKey()
// Desc: Helper function to write a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&bValue, sizeof(BOOL) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadGuidRegKey()
// Desc: Helper function to read a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, 
                               GUID& guidDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(GUID);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (LPBYTE) pGuidValue, &dwLength ) )
    {
        *pGuidValue = guidDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteGuidRegKey()
// Desc: Helper function to write a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
                                        (BYTE*)&guidValue, sizeof(GUID) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command )
{
    static BOOL     m_bTimerInitialized = FALSE;
    static BOOL     m_bUsingQPF         = FALSE;
    static BOOL     m_bTimerStopped     = TRUE;
    static LONGLONG m_llQPFTicksPerSec  = 0;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
        // not supported, we will timeGetTime() which returns milliseconds.
        LARGE_INTEGER qwTicksPerSec;
        m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );
        if( m_bUsingQPF )
            m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
    }

    if( m_bUsingQPF )
    {
        static LONGLONG m_llStopTime        = 0;
        static LONGLONG m_llLastElapsedTime = 0;
        static LONGLONG m_llBaseTime        = 0;
        double fTime;
        double fElapsedTime;
        LARGE_INTEGER qwTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            qwTime.QuadPart = m_llStopTime;
        else
            QueryPerformanceCounter( &qwTime );

        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {
            fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;
            m_llLastElapsedTime = qwTime.QuadPart;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;
            return (FLOAT) fAppTime;
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_llBaseTime        = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_llStopTime        = 0;
            m_bTimerStopped     = FALSE;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            if( m_bTimerStopped )
                m_llBaseTime += qwTime.QuadPart - m_llStopTime;
            m_llStopTime = 0;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_bTimerStopped = FALSE;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_llStopTime = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_bTimerStopped = TRUE;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_llStopTime += m_llQPFTicksPerSec/10;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
    else
    {
        // Get the time using timeGetTime()
        static double m_fLastElapsedTime  = 0.0;
        static double m_fBaseTime         = 0.0;
        static double m_fStopTime         = 0.0;
        double fTime;
        double fElapsedTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            fTime = m_fStopTime;
        else
            fTime = timeGetTime() * 0.001;
    
        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {   
            fElapsedTime = (double) (fTime - m_fLastElapsedTime);
            m_fLastElapsedTime = fTime;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            return (FLOAT) (fTime - m_fBaseTime);
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_fBaseTime         = fTime;
            m_fLastElapsedTime  = fTime;
            m_fStopTime         = 0;
            m_bTimerStopped     = FALSE;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            if( m_bTimerStopped )
                m_fBaseTime += fTime - m_fStopTime;
            m_fStopTime = 0.0f;
            m_fLastElapsedTime  = fTime;
            m_bTimerStopped = FALSE;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_fStopTime = fTime;
            m_bTimerStopped = TRUE;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_fStopTime += 0.1f;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToWide()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertWideStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, 
                                     int cchDestChar )
{
    if( strDestination==NULL || wstrSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = wcslen(wstrSource)+1;

    WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
                         cchDestChar-1, NULL, NULL );

    strDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( strDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( strDestination, tstrSource );
    else
    	strncpy( strDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToWide()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( wstrDestination, tstrSource );
    else
	    wcsncpy( wstrDestination, tstrSource, cchDestChar );
#else
    DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || strSource==NULL )
        return;
        
#ifdef _UNICODE
    DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( tstrDestination, strSource );
    else
    	strncpy( tstrDestination, strSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || wstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( tstrDestination, wstrSource );
    else
	    wcsncpy( tstrDestination, wstrSource, cchDestChar );
#else
    DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: _DbgOut()
// Desc: Outputs a message to the debug stream
//-----------------------------------------------------------------------------
HRESULT _DbgOut( TCHAR* strFile, DWORD dwLine, HRESULT hr, TCHAR* strMsg )
{
    TCHAR buffer[256];
    wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );
    OutputDebugString( buffer );
    OutputDebugString( strMsg );

    if( hr )
    {
        wsprintf( buffer, _T("(hr=%08lx)\n"), hr );
        OutputDebugString( buffer );
    }

    OutputDebugString( _T("\n") );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Trace()
// Desc: Outputs to the debug stream a formatted string with a variable-
//       argument list.
//-----------------------------------------------------------------------------
VOID DXUtil_Trace( TCHAR* strMsg, ... )
{
#if defined(DEBUG) | defined(_DEBUG)
    TCHAR strBuffer[512];
    
    va_list args;
    va_start(args, strMsg);
    _vsntprintf( strBuffer, 512, strMsg, args );
    va_end(args);

    OutputDebugString( strBuffer );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\default\scrnsave.c ===
/*
 *  SCRNSAVE.C - default screen saver.
 *
 *  this app makes a IdleWild screen saver compatible with the windows 3.1
 *  screen saver interface.
 *
 *  Usage:      SCRNSAVE.EXE saver.iw [/s] [/c]
 *
 *      the IdleWild screen saver 'saver.iw' will be loaded and told to
 *      screen save.  if '/c' is specifed the savers configure dialog will
 *      be shown.
 *
 *      when the screen saver terminates SCRNSAVE.EXE will terminate too.
 *
 *      if the saver.iw is not specifed or refuses to load then a
 *      builtin 'blackness' screen saver will be used.
 *
 *  Restrictions:
 *
 *      because only one screen saver is loaded, (not all the screen savers
 *      like IdleWild.exe does) the random screen saver will not work correctly
 *
 *  History:
 *      10/15/90        ToddLa      stolen from SOS.C by BradCh
 *       6/17/91        stevecat    ported to NT Windows
 *
 */
#include <string.h>

#define WIN31 /* For topmost windows */
#include <windows.h>
#include "strings.h"
#include <stdlib.h>

#define BUFFER_LEN  255

CHAR szAppName[BUFFER_LEN];
CHAR szNoConfigure[BUFFER_LEN];

#define     THRESHOLD   3

#define abs(x)      ( (x)<0 ? -(x) : (x) )

//
// private stuff in IWLIB.DLL
//
HANDLE  hIdleWildDll;
CHAR    szIdleWildDll[] = "IWLIB.DLL";

SHORT (*FInitScrSave) (HANDLE, HWND);
VOID  (*TermScrSave) (VOID);
VOID  (*ScrBlank) (SHORT);
VOID  (*ScrSetIgnore) (SHORT);
SHORT (*ScrLoadServer) (CHAR *);
SHORT (*ScrSetServer) (CHAR *);
VOID  (*ScrInvokeDlg) (HANDLE, HWND);

HANDLE  hMainInstance   = NULL;
HWND    hwndApp         = NULL;
HWND    hwndActive      = NULL;
HWND    hwndPreview     = NULL;
BOOL    fBlankNow       = FALSE;
BOOL    fIdleWild       = FALSE;
//SHORT   wmScrSave       = -1;
// changed to what I believe it should be
UINT wmScrSave  = 0xffffffff;

typedef LONG (*LPWNDPROC)(); // pointer to a window procedure

BOOL FInitIdleWild (LPSTR szCmdLine);
BOOL FTermIdleWild (VOID);
BOOL FInitApp      (HANDLE hInstance, LPSTR szCmdLine, WORD sw);
BOOL FTermApp      (VOID);
BOOL FInitDefault  (VOID);
LRESULT DefaultProc   (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

int __cdecl main (USHORT argc, CHAR **argv)
{
        HANDLE   hInstance;
        HANDLE   hPrev     = NULL;
        LPSTR    szCmdLine = GetCommandLine();
        WORD     sw        = SW_SHOWNORMAL;
        MSG      msg;

    hInstance = GetModuleHandle (NULL);

        hMainInstance = hInstance;

        // If we're already running another instance, get out
        if (hPrev != NULL)
                return FALSE;

        if (!FInitApp (hInstance, szCmdLine, sw))
        {
                //MessageBox (NULL, "Cannot initialize!", szAppName, MB_OK);
                return FALSE;
        }

        while (GetMessage (&msg, NULL, 0, 0))
        {
                //
        // IWLIB.DLL will brodcast a message when the screen saving
                // is done.
        //
                if (msg.message == wmScrSave && msg.wParam == FALSE)
                        break;

                TranslateMessage (&msg);
                DispatchMessage (&msg);
        }

        return FTermApp ();
}


BOOL FTermApp (VOID)
{
        ////FTermDefault ();

        FTermIdleWild ();
        return TRUE;
}


BOOL FInitApp (HANDLE hInstance, LPSTR szCmdLine, WORD sw)
{
        LPSTR lpch, lpT;

    LoadString(hMainInstance, idsAppName, szAppName, BUFFER_LEN);
    LoadString(hMainInstance, idsNoConfigure, szNoConfigure, BUFFER_LEN);

//=================================================================

    // on NT, szCmdLine's first string includes its own name, remove this
    // to make it exactly like the windows command line.

    if (*szCmdLine)
        {
        lpT = strchr(szCmdLine, ' ');   // skip self name
        if (lpT)
                {
            szCmdLine = lpT;
            while (*szCmdLine == ' ')
                szCmdLine++;            // skip spaces to end or first cmd
        }
                else
                {
            szCmdLine += strlen(szCmdLine);   // point to NULL
        }
    }
//=====================================================================
        //
    //  parse command line looking for switches
        //

        for (lpch = szCmdLine; *lpch != '\0'; lpch += 1)
        {
                if (*lpch == '/' || *lpch == '-')
                {
                        if (lpch[1] == 's' || lpch[1] == 'S')
                                fBlankNow = TRUE;
                        if (lpch[1] == 'c' || lpch[1] == 'C')
                                hwndActive = GetActiveWindow ();
                        if (lpch[1] == 'p' || lpch[1] == 'P')
                        {
                                fBlankNow = TRUE;
                                hwndPreview = (HWND)IntToPtr(atoi(lpch+2));
                                break;
                        }
                        lpch[0] = ' ';
                        lpch[1] = ' ';
                }
        }

        //
    //  try to load the IdleWild screen saver, if none specifed or
        //  we are unable to load it then use the default one.
    //
        if (FInitIdleWild (szCmdLine))
        {
                if (fBlankNow)
                {
                        ScrSetIgnore (1);
                        ScrBlank (TRUE);
                }
                else
                {
                        ScrInvokeDlg (hMainInstance, hwndActive);
                        PostQuitMessage (0);
                }
        }
        else if (!fBlankNow || !FInitDefault ())
        {
                MessageBox (hwndActive, szNoConfigure, szAppName, MB_OK | MB_ICONEXCLAMATION);
                PostQuitMessage (0);
        }

        return TRUE;
}


//
//  run-time link to IWLIB.DLL
//
BOOL FInitIdleWild (LPSTR szCmdLine)
{
        OFSTRUCT of;

        while (*szCmdLine == ' ')
                szCmdLine++;

        if (*szCmdLine == 0)
                return FALSE;

        if (-1 == OpenFile(szIdleWildDll, &of, OF_EXIST | OF_SHARE_DENY_NONE) ||
            -1 == OpenFile(szCmdLine, &of, OF_EXIST | OF_SHARE_DENY_NONE))
                return FALSE;

        if ((hIdleWildDll = LoadLibrary (szIdleWildDll)) == NULL)
                return FALSE;

        FInitScrSave  = (SHORT (*) (HANDLE, HWND))GetProcAddress (hIdleWildDll, "FInitScrSave" );
        TermScrSave   = (VOID (*) (VOID))         GetProcAddress (hIdleWildDll, "TermScrSave"  );
        ScrBlank      = (VOID (*) (SHORT))        GetProcAddress (hIdleWildDll, "ScrBlank"     );
        ScrSetIgnore  = (VOID (*) (SHORT))        GetProcAddress (hIdleWildDll, "ScrSetIgnore" );
        ScrLoadServer = (SHORT (*) (CHAR *))      GetProcAddress (hIdleWildDll, "ScrLoadServer");
        ScrSetServer  = (SHORT (*) (CHAR *))      GetProcAddress (hIdleWildDll, "ScrSetServer" );
        ScrInvokeDlg  = (VOID (*) (HANDLE, HWND)) GetProcAddress (hIdleWildDll, "ScrInvokeDlg" );

        //
    // must be a invalid dll?
        //
    if (!FInitScrSave || !TermScrSave)
        {
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        //
    // init iwlib.dll
        //
    if (!FInitScrSave (hMainInstance, NULL))     // NULL hwnd???
        {
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        //
    //  load the screen saver on the command line.
        //  if the load fails, abort
    //
        if (!ScrLoadServer (szCmdLine))
        {
                TermScrSave ();
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        wmScrSave = RegisterWindowMessage ("SCRSAVE"); // REVIEW: for win 3.1

        fIdleWild = TRUE;

        return TRUE;
}


BOOL FTermIdleWild (VOID)
{
        if (fIdleWild)
        {
                TermScrSave ();
                FreeLibrary (hIdleWildDll);
        }
        return TRUE;
}


//
//  init the default screen saver
//
BOOL FInitDefault (VOID)
{
        WNDCLASS    cls;
        HWND        hwnd;
        HDC         hdc;
        RECT rc;
        OSVERSIONINFO osvi;
        BOOL bWin2000 =  FALSE;

        cls.style           = 0;
        cls.lpfnWndProc     = DefaultProc;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;
        cls.hInstance       = hMainInstance;
        cls.hIcon           = NULL;
        if (hwndPreview == NULL)
        {
            cls.hCursor     = NULL;
        }
        else
        {
            cls.hCursor     = LoadCursor(NULL,IDC_ARROW);
        }

        cls.hbrBackground   = GetStockObject (BLACK_BRUSH);
        cls.lpszMenuName    = NULL;
        cls.lpszClassName   = szAppName;

        if (!RegisterClass (&cls))
                return FALSE;

        //
        // Make sure we use the entire virtual desktop size for multiple
        // displays
        //
        hdc = GetDC(NULL);
        GetClipBox(hdc, &rc);
        ReleaseDC(NULL, hdc);

        // On Win2000 Terminal Services we must detect the case where a remotte session
        // is on the disconnected desktop, because in this case GetClipBox() returns
        // an empty rect.

        if (IsRectEmpty(&rc)) {
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            if (GetVersionEx (&osvi)){
                if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5)) {
                    bWin2000 = TRUE;
                }
            }
            if (bWin2000 && GetSystemMetrics(SM_REMOTESESSION)) {
                rc.left = 0;
                rc.top = 0;
                rc.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
                rc.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN);

            }

        }


        hwnd = CreateWindowEx (WS_EX_TOPMOST, szAppName, szAppName,
                                                        WS_VISIBLE | ((hwndPreview == NULL) ? WS_POPUP : WS_CHILD),
                                                        rc.left,
                                                        rc.top,
                                                        rc.right  - rc.left,
                                                        rc.bottom - rc.top,
                                                        hwndPreview, NULL,
                                                        hMainInstance, NULL);

        return hwnd != NULL;
}


LRESULT DefaultProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
        static POINT  ptLast;
        POINT  ptMouse;

        switch (msg)
        {
        case WM_CREATE:
                GetCursorPos (&ptLast);
                break;

        case WM_DESTROY:
                PostQuitMessage (0);
                break;

        case WM_ACTIVATE:
        case WM_ACTIVATEAPP:
                if (wParam)
                        break;

        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_CHAR:
                if (hwndPreview == NULL)
                {
                    PostMessage (hwnd, WM_CLOSE, 0, 0L);
                }
                break;

        case WM_MOUSEMOVE:
                if (hwndPreview == NULL)
                {
                    GetCursorPos (&ptMouse);
                    if (abs (ptMouse.x - ptLast.x) + abs (ptMouse.y - ptLast.y) > THRESHOLD)
                            PostMessage (hwnd, WM_CLOSE, 0, 0L);
                }
                break;

        case WM_SETCURSOR:
                if (hwndPreview == NULL)
                {
                    SetCursor (NULL);
                    return 0L;
                }
                break;
        }

        return DefWindowProc (hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\d3dsaver\dxutil.h ===
//-----------------------------------------------------------------------------
// File: DXUtil.h
//
// Desc: Helper functions and typing shortcuts for DirectX programming.
//
//@@BEGIN_MSINTERNAL
//
// Hist: See the source files for detailed histories
//       03.21.00 - mwetzel - Last Modified
//
//@@END_MSINTERNAL
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef DXUTIL_H
#define DXUTIL_H


//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath() and DXUtil_FindMediaFile() 
// Desc: Returns the DirectX SDK path, as stored in the system registry
//       during the SDK install.
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath();
HRESULT      DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: DXUtil_Read*RegKey() and DXUtil_Write*RegKey()
// Desc: Helper functions to read/write a string registry key 
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue );
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue );
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue );
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue );

HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, DWORD dwLength, TCHAR* strDefault );
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, DWORD dwDefault );
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, GUID& guidDefault );
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, BOOL bDefault );




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, TIMER_ADVANCE,
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME, TIMER_GETELAPSEDTIME };
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// UNICODE support for converting between CHAR, TCHAR, and WCHAR strings
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar = -1 );




//-----------------------------------------------------------------------------
// Debug printing support
//-----------------------------------------------------------------------------
VOID    DXUtil_Trace( TCHAR* strMsg, ... );
HRESULT _DbgOut( TCHAR*, DWORD, HRESULT, TCHAR* );

#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE           DXUtil_Trace
#else
    #define DXTRACE           sizeof
#endif

#if defined(DEBUG) | defined(_DEBUG)
    #define DEBUG_MSG(str)    _DbgOut( __FILE__, (DWORD)__LINE__, 0, str )
#else
    #define DEBUG_MSG(str)    (0L)
#endif




#endif // DXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dapp.cpp ===
#include    "stdafx.h"










#if 0
//-----------------------------------------------------------------------------
// File: D3DApp.cpp
//
// Desc: Application class for the Direct3D samples framework library.
//
// Copyright (c) 1998-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <pbt.h>
#include <mmsystem.h>
#include <stdio.h>
#include <tchar.h>
#include "D3DApp.h"




//-----------------------------------------------------------------------------
// Internal function prototypes and variables
//-----------------------------------------------------------------------------
enum APPMSGTYPE { MSG_NONE, MSGERR_APPMUSTEXIT, MSGWARN_SWITCHEDTOSOFTWARE };

static INT     CALLBACK AboutProc(HWND, UINT, WPARAM, LPARAM);
static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

static CD3DApplication* g_pD3DApp;




//-----------------------------------------------------------------------------
// Name: CD3DApplication()
// Desc: 
//-----------------------------------------------------------------------------
CD3DApplication::CD3DApplication()
{
    m_pFramework   = NULL;
    m_hWnd         = NULL;
    m_pDD          = NULL;
    m_pD3D         = NULL;
    m_pd3dDevice   = NULL;

    m_pddsRenderTarget     = NULL;
    m_pddsRenderTargetLeft = NULL;

    m_bActive         = FALSE;
    m_bReady          = FALSE;
    m_bFrameMoving    = TRUE;
    m_bSingleStep     = FALSE;

    m_strWindowTitle  = TEXT("Direct3D Application");
    m_bAppUseZBuffer  = FALSE;
    m_bAppUseStereo   = FALSE;
    m_bShowStats      = FALSE;
    m_fnConfirmDevice = NULL;

    g_pD3DApp = this;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DApplication::Create(HINSTANCE hInst, TCHAR* strCmdLine)
{
    HRESULT hr;

    // Enumerate available D3D devices. The callback is used so the app can
    // confirm/reject each enumerated device depending on its capabilities.
    if (FAILED(hr = D3DEnum_EnumerateDevices(m_fnConfirmDevice)))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        return hr;
    }

    // Select a device. Ask for a hardware device that renders in a window.
    if (FAILED(hr = D3DEnum_SelectDefaultDevice(&m_pDeviceInfo)))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        return hr;
    }

    // Initialize the app's custom scene stuff
    if (FAILED(hr = OneTimeSceneInit()))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        return hr;
    }

    // Create a new CD3DFramework class. This class does all of our D3D
    // initialization and manages the common D3D objects.
    if (NULL == (m_pFramework = new CD3DFramework7()))
    {
        DisplayFrameworkError(E_OUTOFMEMORY, MSGERR_APPMUSTEXIT);
        return E_OUTOFMEMORY;
    }

    // Register the window class
    WNDCLASS wndClass = { 0, WndProc, 0, 0, hInst,
                          LoadIcon(hInst, MAKEINTRESOURCE(IDI_MAIN_ICON)),
                          LoadCursor(NULL, IDC_ARROW), 
                          (HBRUSH)GetStockObject(WHITE_BRUSH),
                          NULL, TEXT("D3D Window") };
    RegisterClass(&wndClass);

    // Create the render window
    m_hWnd = CreateWindow(TEXT("D3D Window"), m_strWindowTitle,
                           WS_OVERLAPPEDWINDOW|WS_VISIBLE,
                           CW_USEDEFAULT, CW_USEDEFAULT, 300, 300, 0L,
                           LoadMenu(hInst, MAKEINTRESOURCE(IDR_MENU)), 
                           hInst, 0L);
    UpdateWindow(m_hWnd);

    // Initialize the 3D environment for the app
    if (FAILED(hr = Initialize3DEnvironment()))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        Cleanup3DEnvironment();
        return E_FAIL;
    }

    // Setup the app so it can support single-stepping
    m_dwBaseTime = timeGetTime();

    // The app is ready to go
    m_bReady = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: Message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT CD3DApplication::Run()
{
    // Load keyboard accelerators
    HACCEL hAccel = LoadAccelerators(NULL, MAKEINTRESOURCE(IDR_MAIN_ACCEL));

    // Now we're ready to recieve and process Windows messages.
    BOOL bGotMsg;
    MSG  msg;
    PeekMessage(&msg, NULL, 0U, 0U, PM_NOREMOVE);

    while(WM_QUIT != msg.message)
    {
        // Use PeekMessage() if the app is active, so we can use idle time to
        // render the scene. Else, use GetMessage() to avoid eating CPU time.
        if (m_bActive)
            bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
        else
            bGotMsg = GetMessage(&msg, NULL, 0U, 0U);

        if (bGotMsg)
        {
            // Translate and dispatch the message
            if (0 == TranslateAccelerator(m_hWnd, hAccel, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            // Render a frame during idle time (no messages are waiting)
            if (m_bActive && m_bReady)
            {
                if (FAILED(Render3DEnvironment()))
                    DestroyWindow(m_hWnd);
            }
        }
    }

    return msg.wParam;
}




//-----------------------------------------------------------------------------
// Name: WndProc()
// Desc: Static msg handler which passes messages to the application class.
//-----------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (g_pD3DApp)
        return g_pD3DApp->MsgProc(hWnd, uMsg, wParam, lParam);

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}




//-----------------------------------------------------------------------------
// Name: AboutProc()
// Desc: Minimal message proc function for the about box
//-----------------------------------------------------------------------------
BOOL CALLBACK AboutProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM)
{
    if (WM_COMMAND == uMsg)
        if (IDOK == LOWORD(wParam) || IDCANCEL == LOWORD(wParam))
            EndDialog(hWnd, TRUE);

    return WM_INITDIALOG == uMsg ? TRUE : FALSE;
}




//-----------------------------------------------------------------------------
// Name: MsgProc()
// Desc: Message handling function.
//-----------------------------------------------------------------------------
LRESULT CD3DApplication::MsgProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    HRESULT hr;

    switch(uMsg)
    {
        case WM_PAINT:
            // Handle paint messages when the app is not ready
            if (m_pFramework && !m_bReady)
            {
                if (m_pDeviceInfo->bWindowed)
                    m_pFramework->ShowFrame();
                else
                    m_pFramework->FlipToGDISurface(TRUE);
            }
            break;

        case WM_MOVE:
            // If in windowed mode, move the Framework's window
            if (m_pFramework && m_bActive && m_bReady && m_pDeviceInfo->bWindowed)
                m_pFramework->Move((SHORT)LOWORD(lParam), (SHORT)HIWORD(lParam));
            break;

        case WM_SIZE:
            // Check to see if we are losing our window...
            if (SIZE_MAXHIDE==wParam || SIZE_MINIMIZED==wParam)
                m_bActive = FALSE;
            else
                m_bActive = TRUE;

            // A new window size will require a new backbuffer
            // size, so the 3D structures must be changed accordingly.
            if (m_bActive && m_bReady && m_pDeviceInfo->bWindowed)
            {
                m_bReady = FALSE;

                if (FAILED(hr = Change3DEnvironment()))
                    return 0;

                m_bReady = TRUE;
            }
            break;

        case WM_SETCURSOR:
            // Prevent a cursor in fullscreen mode
            if (m_bActive && m_bReady && !m_pDeviceInfo->bWindowed)
            {
                SetCursor(NULL);
                return 1;
            }
            break;

        case WM_ENTERMENULOOP:
            // Pause the app when menus are displayed
            Pause(TRUE);
            break;
        case WM_EXITMENULOOP:
            Pause(FALSE);
            break;

        case WM_ENTERSIZEMOVE:
            // Halt frame movement while the app is sizing or moving
            if (m_bFrameMoving)
                m_dwStopTime = timeGetTime();
            break;
        case WM_EXITSIZEMOVE:
            if (m_bFrameMoving)
                m_dwBaseTime += timeGetTime() - m_dwStopTime;
            break;

        case WM_CONTEXTMENU:
            // Handle the app's context menu (via right mouse click) 
            TrackPopupMenuEx(
                    GetSubMenu(LoadMenu(0, MAKEINTRESOURCE(IDR_POPUP)), 0),
                    TPM_VERTICAL, LOWORD(lParam), HIWORD(lParam), hWnd, NULL);
            break;

        case WM_NCHITTEST:
            // Prevent the user from selecting the menu in fullscreen mode
            if (!m_pDeviceInfo->bWindowed)
                return HTCLIENT;

            break;

        case WM_POWERBROADCAST:
            switch(wParam)
            {
                case PBT_APMQUERYSUSPEND:
                    // At this point, the app should save any data for open
                    // network connections, files, etc.., and prepare to go into
                    // a suspended mode.
                    return OnQuerySuspend((DWORD)lParam);

                case PBT_APMRESUMESUSPEND:
                    // At this point, the app should recover any data, network
                    // connections, files, etc.., and resume running from when
                    // the app was suspended.
                    return OnResumeSuspend((DWORD)lParam);
            }
            break;

        case WM_SYSCOMMAND:
            // Prevent moving/sizing and power loss in fullscreen mode
            switch(wParam)
            {
                case SC_MOVE:
                case SC_SIZE:
                case SC_MAXIMIZE:
                case SC_MONITORPOWER:
                    if (FALSE == m_pDeviceInfo->bWindowed)
                        return 1;
                    break;
            }
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDM_TOGGLESTART:
                    // Toggle frame movement
                    m_bFrameMoving = !m_bFrameMoving;

                    if (m_bFrameMoving)
                        m_dwBaseTime += timeGetTime() - m_dwStopTime;
                    else
                        m_dwStopTime = timeGetTime();
                    break;

                case IDM_SINGLESTEP:
                    // Single-step frame movement
                    if (FALSE == m_bFrameMoving)
                        m_dwBaseTime += timeGetTime() - (m_dwStopTime + 100);

                    m_dwStopTime   = timeGetTime();
                    m_bFrameMoving = FALSE;
                    m_bSingleStep  = TRUE;
                    break;

                case IDM_CHANGEDEVICE:
                    // Display the device-selection dialog box.
                    if (m_bActive && m_bReady)
                    {
                        Pause(TRUE);

                        if (SUCCEEDED(D3DEnum_UserChangeDevice(&m_pDeviceInfo)))
                        {
                            if (FAILED(hr = Change3DEnvironment()))
                                return 0;
                        }
                        Pause(FALSE);
                    }
                    return 0;

                case IDM_TOGGLEFULLSCREEN:
                    // Toggle the fullscreen/window mode
                    if (m_bActive && m_bReady)
                    {
                        m_bReady = FALSE;

                        m_pDeviceInfo->bWindowed = !m_pDeviceInfo->bWindowed;

                        if (FAILED(hr = Change3DEnvironment()))
                            return 0;

                        m_bReady = TRUE;
                    }
                    return 0;

                case IDM_ABOUT:
                    // Display the About box
                    Pause(TRUE);
                    DialogBox((HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE),
                               MAKEINTRESOURCE(IDD_ABOUT), hWnd, AboutProc);
                    Pause(FALSE);
                    return 0;

                case IDM_EXIT:
                    // Recieved key/menu command to exit app
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    return 0;
            }
            break;

        case WM_GETMINMAXINFO:
            ((MINMAXINFO*)lParam)->ptMinTrackSize.x = 100;
            ((MINMAXINFO*)lParam)->ptMinTrackSize.y = 100;
            break;

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return 0;

        case WM_DESTROY:
            Cleanup3DEnvironment();
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
            



//-----------------------------------------------------------------------------
// Name: Initialize3DEnvironment()
// Desc: Initializes the sample framework, then calls the app-specific function
//       to initialize device specific objects. This code is structured to
//       handled any errors that may occur duing initialization
//-----------------------------------------------------------------------------
HRESULT CD3DApplication::Initialize3DEnvironment()
{
    HRESULT hr;
    DWORD   dwFrameworkFlags = 0L;
    dwFrameworkFlags |= (!m_pDeviceInfo->bWindowed ? D3DFW_FULLSCREEN : 0L);
    dwFrameworkFlags |= (m_pDeviceInfo->bStereo   ? D3DFW_STEREO     : 0L);
    dwFrameworkFlags |= (m_bAppUseZBuffer         ? D3DFW_ZBUFFER    : 0L);

    // Initialize the D3D framework
    if (SUCCEEDED(hr = m_pFramework->Initialize(m_hWnd,
                     m_pDeviceInfo->pDriverGUID, m_pDeviceInfo->pDeviceGUID,
                     &m_pDeviceInfo->ddsdFullscreenMode, dwFrameworkFlags)))
    {
        m_pDD        = m_pFramework->GetDirectDraw();
        m_pD3D       = m_pFramework->GetDirect3D();
        m_pd3dDevice = m_pFramework->GetD3DDevice();

        m_pddsRenderTarget     = m_pFramework->GetRenderSurface();
        m_pddsRenderTargetLeft = m_pFramework->GetRenderSurfaceLeft();

        m_ddsdRenderTarget.dwSize = sizeof(m_ddsdRenderTarget);
        m_pddsRenderTarget->GetSurfaceDesc(&m_ddsdRenderTarget);

        // Let the app run its startup code which creates the 3d scene.
        if (SUCCEEDED(hr = InitDeviceObjects()))
            return S_OK;
        else
        {
            DeleteDeviceObjects();
            m_pFramework->DestroyObjects();
        }
    }

    // If we get here, the first initialization passed failed. If that was with a
    // hardware device, try again using a software rasterizer instead.
    if (m_pDeviceInfo->bHardware)
    {
        // Try again with a software rasterizer
        DisplayFrameworkError(hr, MSGWARN_SWITCHEDTOSOFTWARE);
        D3DEnum_SelectDefaultDevice(&m_pDeviceInfo, D3DENUM_SOFTWAREONLY);
        return Initialize3DEnvironment();
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Change3DEnvironment()
// Desc: Handles driver, device, and/or mode changes for the app.
//-----------------------------------------------------------------------------
HRESULT CD3DApplication::Change3DEnvironment()
{
    HRESULT hr;
    static BOOL  bOldWindowedState = TRUE;
    static DWORD dwSavedStyle;
    static RECT  rcSaved;

    // Release all scene objects that will be re-created for the new device
    DeleteDeviceObjects();

    // Release framework objects, so a new device can be created
    if (FAILED(hr = m_pFramework->DestroyObjects()))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        SendMessage(m_hWnd, WM_CLOSE, 0, 0);
        return hr;
    }

    // Check if going from fullscreen to windowed mode, or vice versa.
    if (bOldWindowedState != m_pDeviceInfo->bWindowed)
    {
        if (m_pDeviceInfo->bWindowed)
        {
            // Coming from fullscreen mode, so restore window properties
            SetWindowLong(m_hWnd, GWL_STYLE, dwSavedStyle);
            SetWindowPos(m_hWnd, HWND_NOTOPMOST, rcSaved.left, rcSaved.top,
                          (rcSaved.right - rcSaved.left), 
                          (rcSaved.bottom - rcSaved.top), SWP_SHOWWINDOW);
        }
        else
        {
            // Going to fullscreen mode, save/set window properties as needed
            dwSavedStyle = GetWindowLong(m_hWnd, GWL_STYLE);
            GetWindowRect(m_hWnd, &rcSaved);
            SetWindowLong(m_hWnd, GWL_STYLE, WS_POPUP|WS_SYSMENU|WS_VISIBLE);
        }

        bOldWindowedState = m_pDeviceInfo->bWindowed;
    }

    // Inform the framework class of the driver change. It will internally
    // re-create valid surfaces, a d3ddevice, etc.
    if (FAILED(hr = Initialize3DEnvironment()))
    {
        DisplayFrameworkError(hr, MSGERR_APPMUSTEXIT);
        SendMessage(m_hWnd, WM_CLOSE, 0, 0);
        return hr;
    }

    // If the app is paused, trigger the rendering of the current frame
    if (FALSE == m_bFrameMoving)
    {
        m_bSingleStep = TRUE;
        m_dwBaseTime += timeGetTime() - m_dwStopTime;
        m_dwStopTime  = timeGetTime();
    }
    
    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: Render3DEnvironment()
// Desc: Draws the scene.
//-----------------------------------------------------------------------------
HRESULT CD3DApplication::Render3DEnvironment()
{
    HRESULT hr;

    // Check the cooperative level before rendering
    if (FAILED(hr = m_pDD->TestCooperativeLevel()))
    {
        switch(hr)
        {
            case DDERR_EXCLUSIVEMODEALREADYSET:
            case DDERR_NOEXCLUSIVEMODE:
                // Do nothing because some other app has exclusive mode
                return S_OK;

            case DDERR_WRONGMODE:
                // The display mode changed on us. Resize accordingly
                if (m_pDeviceInfo->bWindowed)
                    return Change3DEnvironment();
                break;
        }
        return hr;
    }

    // Get the relative time, in seconds
    FLOAT fTime = (timeGetTime() - m_dwBaseTime) * 0.001f;

    // FrameMove (animate) the scene
    if (m_bFrameMoving || m_bSingleStep)
    {
        if (FAILED(hr = FrameMove(fTime)))
            return hr;

        m_bSingleStep = FALSE;
    }

    // If the display is in a stereo mode, render the scene from the left eye
    // first, then the right eye.
    if (m_bAppUseStereo && m_pDeviceInfo->bStereo && !m_pDeviceInfo->bWindowed)
    {
        // Render the scene from the left eye
        m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_VIEW, &m_matLeftView);
        if (FAILED(hr = m_pd3dDevice->SetRenderTarget(m_pddsRenderTargetLeft, 0)))
            return hr;
        if (FAILED(hr = Render()))
            return hr;

        //Render the scene from the right eye
        m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_VIEW, &m_matRightView);
        if (FAILED(hr = m_pd3dDevice->SetRenderTarget(m_pddsRenderTarget, 0)))
            return hr;
        if (FAILED(hr = Render()))
            return hr;
    } 
    else 
    {
        // Set center viewing matrix if app is stereo-enabled
        if (m_bAppUseStereo)
            m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_VIEW, &m_matView);

        // Render the scene as normal
        if (FAILED(hr = Render()))
            return hr;
    }

    // Show the frame rate, etc.
    if (m_bShowStats)
        ShowStats();

    // Show the frame on the primary surface.
    if (FAILED(hr = m_pFramework->ShowFrame()))
    {
        if (DDERR_SURFACELOST != hr)
            return hr;

        m_pFramework->RestoreSurfaces();
        RestoreSurfaces();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Cleanup3DEnvironment()
// Desc: Cleanup scene objects
//-----------------------------------------------------------------------------
VOID CD3DApplication::Cleanup3DEnvironment()
{
    m_bActive = FALSE;
    m_bReady  = FALSE;

    if (m_pFramework)
    {
        DeleteDeviceObjects();
        SAFE_DELETE(m_pFramework);

        FinalCleanup();
    }

    D3DEnum_FreeResources();
}




//-----------------------------------------------------------------------------
// Name: Pause()
// Desc: Called in to toggle the pause state of the app. This function
//       brings the GDI surface to the front of the display, so drawing
//       output like message boxes and menus may be displayed.
//-----------------------------------------------------------------------------
VOID CD3DApplication::Pause(BOOL bPause)
{
    static DWORD dwAppPausedCount = 0L;

    dwAppPausedCount += (bPause ? +1 : -1);
    m_bReady          = (dwAppPausedCount ? FALSE : TRUE);

    // Handle the first pause request (of many, nestable pause requests)
    if (bPause && (1 == dwAppPausedCount))
    {
        // Get a surface for the GDI
        if (m_pFramework)
            m_pFramework->FlipToGDISurface(TRUE);

        // Stop the scene from animating
        if (m_bFrameMoving)
            m_dwStopTime = timeGetTime();
    }

    if (0 == dwAppPausedCount)
    {
        // Restart the scene
        if (m_bFrameMoving)
            m_dwBaseTime += timeGetTime() - m_dwStopTime;
    }
}




//-----------------------------------------------------------------------------
// Name: OnQuerySuspend()
// Desc: Called when the app receives a PBT_APMQUERYSUSPEND message, meaning
//       the computer is about to be suspended. At this point, the app should
//       save any data for open network connections, files, etc.., and prepare
//       to go into a suspended mode.
//-----------------------------------------------------------------------------
LRESULT CD3DApplication::OnQuerySuspend(DWORD dwFlags)
{
    Pause(TRUE);

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: OnResumeSuspend()
// Desc: Called when the app receives a PBT_APMRESUMESUSPEND message, meaning
//       the computer has just resumed from a suspended state. At this point, 
//       the app should recover any data, network connections, files, etc..,
//       and resume running from when the app was suspended.
//-----------------------------------------------------------------------------
LRESULT CD3DApplication::OnResumeSuspend(DWORD dwData)
{
    Pause(FALSE);

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ShowStats()
// Desc: Shows frame rate and dimensions of the rendering device.
//-----------------------------------------------------------------------------
VOID CD3DApplication::ShowStats()
{
    static FLOAT fFPS      = 0.0f;
    static FLOAT fLastTime = 0.0f;
    static DWORD dwFrames  = 0L;

    // Keep track of the time lapse and frame count
    FLOAT fTime = timeGetTime() * 0.001f; // Get current time in seconds
    ++dwFrames;

    // Update the frame rate once per second
    if (fTime - fLastTime > 1.0f)
    {
        fFPS      = dwFrames / (fTime - fLastTime);
        fLastTime = fTime;
        dwFrames  = 0L;
    }

    // Setup the text buffer to write out dimensions
    TCHAR buffer[80];
    sprintf(buffer, TEXT("%7.02f fps (%dx%dx%d)"), fFPS,
             m_ddsdRenderTarget.dwWidth, m_ddsdRenderTarget.dwHeight, 
             m_ddsdRenderTarget.ddpfPixelFormat.dwRGBBitCount);
    OutputText(0, 0, buffer);
}




//-----------------------------------------------------------------------------
// Name: OutputText()
// Desc: Draws text on the window.
//-----------------------------------------------------------------------------
VOID CD3DApplication::OutputText(DWORD x, DWORD y, TCHAR* str)
{
    HDC hDC;

    // Get a DC for the surface. Then, write out the buffer
    if (m_pddsRenderTarget)
    {
        if (SUCCEEDED(m_pddsRenderTarget->GetDC(&hDC)))
        {
            SetTextColor(hDC, RGB(255,255,0));
            SetBkMode(hDC, TRANSPARENT);
            ExtTextOut(hDC, x, y, 0, NULL, str, lstrlen(str), NULL);
            m_pddsRenderTarget->ReleaseDC(hDC);
        }
    }

    // Do the same for the left surface (in case of stereoscopic viewing).
    if (m_pddsRenderTargetLeft)
    {
        if (SUCCEEDED(m_pddsRenderTargetLeft->GetDC(&hDC)))
        {
            // Use a different color to help distinguish left eye view
            SetTextColor(hDC, RGB(255,0,255));
            SetBkMode(hDC, TRANSPARENT);
            ExtTextOut(hDC, x, y, 0, NULL, str, lstrlen(str), NULL);
            m_pddsRenderTargetLeft->ReleaseDC(hDC);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayFrameworkError()
// Desc: Displays error messages in a message box
//-----------------------------------------------------------------------------
VOID CD3DApplication::DisplayFrameworkError(HRESULT hr, DWORD dwType)
{
    TCHAR strMsg[512];

    switch(hr)
    {
        case D3DENUMERR_NODIRECTDRAW:
            lstrcpy(strMsg, TEXT("Could not create DirectDraw!"));
            break;
        case D3DENUMERR_NOCOMPATIBLEDEVICES:
            lstrcpy(strMsg, TEXT("Could not find any compatible Direct3D\n"
                     "devices."));
            break;
        case D3DENUMERR_SUGGESTREFRAST:
            lstrcpy(strMsg, TEXT("Could not find any compatible devices.\n\n"
                     "Try enabling the reference rasterizer using\n"
                     "EnableRefRast.reg."));
            break;
        case D3DENUMERR_ENUMERATIONFAILED:
            lstrcpy(strMsg, TEXT("Enumeration failed. Your system may be in an\n"
                     "unstable state and need to be rebooted"));
            break;
        case D3DFWERR_INITIALIZATIONFAILED:
            lstrcpy(strMsg, TEXT("Generic initialization error.\n\nEnable "
                     "debug output for detailed information."));
            break;
        case D3DFWERR_NODIRECTDRAW:
            lstrcpy(strMsg, TEXT("No DirectDraw"));
            break;
        case D3DFWERR_NODIRECT3D:
            lstrcpy(strMsg, TEXT("No Direct3D"));
            break;
        case D3DFWERR_INVALIDMODE:
            lstrcpy(strMsg, TEXT("This sample requires a 16-bit (or higher) "
                                "display mode\nto run in a window.\n\nPlease "
                                "switch your desktop settings accordingly."));
            break;
        case D3DFWERR_COULDNTSETCOOPLEVEL:
            lstrcpy(strMsg, TEXT("Could not set Cooperative Level"));
            break;
        case D3DFWERR_NO3DDEVICE:
            lstrcpy(strMsg, TEXT("Could not create the Direct3DDevice object."));
            
            if (MSGWARN_SWITCHEDTOSOFTWARE == dwType)
                lstrcat(strMsg, TEXT("\nThe 3D hardware chipset may not support"
                                    "\nrendering in the current display mode."));
            break;
        case D3DFWERR_NOZBUFFER:
            lstrcpy(strMsg, TEXT("No ZBuffer"));
            break;
        case D3DFWERR_INVALIDZBUFFERDEPTH:
            lstrcpy(strMsg, TEXT("Invalid Z-buffer depth. Try switching modes\n"
                     "from 16- to 32-bit (or vice versa)"));
            break;
        case D3DFWERR_NOVIEWPORT:
            lstrcpy(strMsg, TEXT("No Viewport"));
            break;
        case D3DFWERR_NOPRIMARY:
            lstrcpy(strMsg, TEXT("No primary"));
            break;
        case D3DFWERR_NOCLIPPER:
            lstrcpy(strMsg, TEXT("No Clipper"));
            break;
        case D3DFWERR_BADDISPLAYMODE:
            lstrcpy(strMsg, TEXT("Bad display mode"));
            break;
        case D3DFWERR_NOBACKBUFFER:
            lstrcpy(strMsg, TEXT("No backbuffer"));
            break;
        case D3DFWERR_NONZEROREFCOUNT:
            lstrcpy(strMsg, TEXT("A DDraw object has a non-zero reference\n"
                     "count (meaning it was not properly cleaned up)."));
            break;
        case D3DFWERR_NORENDERTARGET:
            lstrcpy(strMsg, TEXT("No render target"));
            break;
        case E_OUTOFMEMORY:
            lstrcpy(strMsg, TEXT("Not enough memory!"));
            break;
        case DDERR_OUTOFVIDEOMEMORY:
            lstrcpy(strMsg, TEXT("There was insufficient video memory "
                     "to use the\nhardware device."));
            break;
        default:
            lstrcpy(strMsg, TEXT("Generic application error.\n\nEnable "
                     "debug output for detailed information."));
    }

    if (MSGERR_APPMUSTEXIT == dwType)
    {
        lstrcat(strMsg, TEXT("\n\nThis sample will now exit."));
        MessageBox(NULL, strMsg, m_strWindowTitle, MB_ICONERROR|MB_OK);
    }
    else
    {
        if (MSGWARN_SWITCHEDTOSOFTWARE == dwType)
            lstrcat(strMsg, TEXT("\n\nSwitching to software rasterizer."));
        MessageBox(NULL, strMsg, m_strWindowTitle, MB_ICONWARNING|MB_OK);
    }
}




//-----------------------------------------------------------------------------
// Name: SetViewParams()
// Desc: Sets the parameters to be used by the SetViewMatrix() function.  You
//       must call this function rather than setting the D3D view matrix 
//       yourself in order for stereo modes to work properly.
//-----------------------------------------------------------------------------
VOID CD3DApplication::SetViewParams(D3DVECTOR* vEyePt, D3DVECTOR* vLookatPt,
                                     D3DVECTOR* vUpVec, FLOAT fEyeDistance)
{
    // Adjust camera position for left or right eye along the axis
    // perpendicular to the view direction vector and the up vector.
    D3DVECTOR vView = (*vLookatPt) - (*vEyePt);
    vView = CrossProduct(vView, (*vUpVec));
    vView = Normalize(vView) * fEyeDistance;

    D3DVECTOR vLeftEyePt  = (*vEyePt) + vView;
    D3DVECTOR vRightEyePt = (*vEyePt) - vView;

    // Set the view matrices
    D3DUtil_SetViewMatrix(m_matLeftView,  vLeftEyePt,  *vLookatPt, *vUpVec);
    D3DUtil_SetViewMatrix(m_matRightView, vRightEyePt, *vLookatPt, *vUpVec);
    D3DUtil_SetViewMatrix(m_matView,      *vEyePt,     *vLookatPt, *vUpVec);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3denum.h ===
//-----------------------------------------------------------------------------
// File: D3DEnum.h
//
// Desc: Functions to enumerate DDraw/D3D drivers, devices, and modes.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DENUM_H
#define D3DENUM_H

#define  D3D_OVERLOADS
#include <d3d.h>


//-----------------------------------------------------------------------------
// Flag and error definitions
//-----------------------------------------------------------------------------
#define D3DENUM_SOFTWAREONLY           0x00000001 // Software-devices only flag

#define D3DENUMERR_NODIRECTDRAW        0x81000001 // Could not create DDraw
#define D3DENUMERR_ENUMERATIONFAILED   0x81000002 // Enumeration failed
#define D3DENUMERR_SUGGESTREFRAST      0x81000003 // Suggest using the RefRast
#define D3DENUMERR_NOCOMPATIBLEDEVICES 0x81000004 // No devices were found that
                                                  // meet the app's desired
                                                  // capabilities


//-----------------------------------------------------------------------------
// Name: struct D3DEnum_DeviceInfo
// Desc: Structure to hold info about the enumerated Direct3D devices.
//-----------------------------------------------------------------------------
struct D3DEnum_DeviceInfo
{
    // D3D Device info
    TCHAR          strDesc[40];
    GUID*          pDeviceGUID;
    D3DDEVICEDESC7 ddDeviceDesc;
    BOOL           bHardware;

    // DDraw Driver info
    GUID*          pDriverGUID;
    DDCAPS         ddDriverCaps;
    DDCAPS         ddHELCaps;

    // DDraw Mode Info
    DDSURFACEDESC2 ddsdFullscreenMode;
    BOOL           bWindowed;
    BOOL           bStereo;

    // For internal use (apps should not need to use these)
    GUID            guidDevice;
    GUID            guidDriver;
    DDSURFACEDESC2* pddsdModes;
    DWORD           dwNumModes;
    DWORD           dwCurrentMode;
    BOOL            bDesktopCompatible;
    BOOL            bStereoCompatible;
};


// For code not yet switched to new struct name
typedef D3DEnum_DeviceInfo D3DDEVICEINFO;




//-----------------------------------------------------------------------------
// Name: D3DEnum_EnumerateDevices()
// Desc: Enumerates all drivers, devices, and modes. The callback function is
//       called each device, to confirm that the device supports the feature
//       set required by the app.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_EnumerateDevices(HRESULT (*fn)(DDCAPS*, D3DDEVICEDESC7*));




//-----------------------------------------------------------------------------
// Name: D3DEnum_FreeResources()
// Desc: Cleans up any memory allocated during device enumeration
//-----------------------------------------------------------------------------
VOID D3DEnum_FreeResources();




//-----------------------------------------------------------------------------
// Name: D3DEnum_GetDevices()
// Desc: Returns a ptr to the array of enumerated D3DDEVICEINFO structures.
//-----------------------------------------------------------------------------
VOID D3DEnum_GetDevices(D3DEnum_DeviceInfo** ppDevices, DWORD* pdwCount);




//-----------------------------------------------------------------------------
// Name: D3DEnum_SelectDefaultDevice()
// Desc: Picks a driver based on a set of passed in criteria. The
//       D3DENUM_SOFTWAREONLY flag can be used to pick a software device.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_SelectDefaultDevice(D3DEnum_DeviceInfo** pDevice,
                                     DWORD dwFlags = 0L);




//-----------------------------------------------------------------------------
// Name: D3DEnum_UserChangeDevice()
// Desc: Pops up a dialog which allows the user to select a new device.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_UserChangeDevice(D3DEnum_DeviceInfo** ppDevice);




#endif // D3DENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3denum.cpp ===
#include    "stdafx.h"



#if 0
//-----------------------------------------------------------------------------
// File: D3DEnum.cpp
//
// Desc: Functions to enumerate DDraw/D3D drivers, devices, and modes.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define STRICT
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include "D3DEnum.h"
#include "D3DUtil.h" // For DEBUG_MSG
#include "D3DRes.h"  // For dialog controls




//-----------------------------------------------------------------------------
// Global data for the enumerator functions
//-----------------------------------------------------------------------------
static HRESULT (*g_fnAppConfirmFn)(DDCAPS*, D3DDEVICEDESC7*) = NULL;

static D3DEnum_DeviceInfo g_pDeviceList[20];
static DWORD g_dwNumDevicesEnumerated = 0L;
static DWORD g_dwNumDevices           = 0L;




//-----------------------------------------------------------------------------
// Name: SortModesCallback()
// Desc: Callback function for sorting display modes.
//-----------------------------------------------------------------------------
int SortModesCallback(const VOID* arg1, const VOID* arg2)
{
    DDSURFACEDESC2* p1 = (DDSURFACEDESC2*)arg1;
    DDSURFACEDESC2* p2 = (DDSURFACEDESC2*)arg2;

    if (p1->dwWidth < p2->dwWidth)
        return -1;
    if (p1->dwWidth > p2->dwWidth)
        return +1;

    if (p1->dwHeight < p2->dwHeight)
        return -1;
    if (p1->dwHeight > p2->dwHeight)
        return +1;

    if (p1->ddpfPixelFormat.dwRGBBitCount < p2->ddpfPixelFormat.dwRGBBitCount)
        return -1;
    if (p1->ddpfPixelFormat.dwRGBBitCount > p2->ddpfPixelFormat.dwRGBBitCount)
        return +1;

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ModeEnumCallback()
// Desc: Callback function for enumerating display modes.
//-----------------------------------------------------------------------------
static HRESULT WINAPI ModeEnumCallback(DDSURFACEDESC2* pddsd,
                                        VOID* pParentInfo)
{
    D3DEnum_DeviceInfo* pDevice = (D3DEnum_DeviceInfo*)pParentInfo;

    // Reallocate storage for the modes
    DDSURFACEDESC2* pddsdNewModes = new DDSURFACEDESC2[pDevice->dwNumModes+1];
    memcpy(pddsdNewModes, pDevice->pddsdModes,
            pDevice->dwNumModes * sizeof(DDSURFACEDESC2));
    delete pDevice->pddsdModes;
    pDevice->pddsdModes = pddsdNewModes;

    // Add the new mode
    pDevice->pddsdModes[pDevice->dwNumModes++] = (*pddsd);

    return DDENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: DeviceEnumCallback()
// Desc: Callback function for enumerating devices
//-----------------------------------------------------------------------------
static HRESULT WINAPI DeviceEnumCallback(TCHAR* strDesc, TCHAR* strName,
                                          D3DDEVICEDESC7* pDesc,
                                          VOID* pParentInfo)
{
    // Keep track of # of devices that were enumerated
    g_dwNumDevicesEnumerated++;

    D3DEnum_DeviceInfo* pDriverInfo = (D3DEnum_DeviceInfo*)pParentInfo;
    D3DEnum_DeviceInfo* pDeviceInfo = &g_pDeviceList[g_dwNumDevices];
    ZeroMemory(pDeviceInfo, sizeof(D3DEnum_DeviceInfo));

    // Select either the HAL or HEL device desc:
    pDeviceInfo->bHardware = pDesc->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION;
    memcpy(&pDeviceInfo->ddDeviceDesc, pDesc, sizeof(D3DDEVICEDESC7));

    // Set up device info for this device
    pDeviceInfo->bDesktopCompatible = pDriverInfo->bDesktopCompatible;
    pDeviceInfo->ddDriverCaps       = pDriverInfo->ddDriverCaps;
    pDeviceInfo->ddHELCaps          = pDriverInfo->ddHELCaps;
    pDeviceInfo->guidDevice         = pDesc->deviceGUID;
    pDeviceInfo->pDeviceGUID        = &pDeviceInfo->guidDevice;
    pDeviceInfo->pddsdModes         = new DDSURFACEDESC2[pDriverInfo->dwNumModes];

    // Copy the driver GUID and description for the device
    if (pDriverInfo->pDriverGUID)
    {
        pDeviceInfo->guidDriver  = pDriverInfo->guidDriver;
        pDeviceInfo->pDriverGUID = &pDeviceInfo->guidDriver;
        lstrcpyn(pDeviceInfo->strDesc, pDriverInfo->strDesc, 39);
    }
    else
    {
        pDeviceInfo->pDriverGUID = NULL;
        lstrcpyn(pDeviceInfo->strDesc, strName, 39);
    }

    // Avoid duplicates: only enum HW devices for secondary DDraw drivers.
    if (NULL != pDeviceInfo->pDriverGUID && FALSE == pDeviceInfo->bHardware)
            return D3DENUMRET_OK;

    // Give the app a chance to accept or reject this device.
    if (g_fnAppConfirmFn)
        if (FAILED(g_fnAppConfirmFn(&pDeviceInfo->ddDriverCaps,
                                      &pDeviceInfo->ddDeviceDesc)))
            return D3DENUMRET_OK;

    // Build list of supported modes for the device
    for(DWORD i=0; i<pDriverInfo->dwNumModes; i++)
    {
        DDSURFACEDESC2 ddsdMode = pDriverInfo->pddsdModes[i];
        DWORD dwRenderDepths    = pDeviceInfo->ddDeviceDesc.dwDeviceRenderBitDepth;
        DWORD dwDepth           = ddsdMode.ddpfPixelFormat.dwRGBBitCount;

        // Accept modes that are compatable with the device
        if (((dwDepth == 32) && (dwRenderDepths & DDBD_32)) ||
            ((dwDepth == 24) && (dwRenderDepths & DDBD_24)) ||
            ((dwDepth == 16) && (dwRenderDepths & DDBD_16)))
        {
            // Copy compatible modes to the list of device-supported modes
            pDeviceInfo->pddsdModes[pDeviceInfo->dwNumModes++] = ddsdMode;

            // Record whether the device has any stereo modes
            if (ddsdMode.ddsCaps.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
                pDeviceInfo->bStereoCompatible = TRUE;
        }
    }

    // Bail if the device has no supported modes
    if (0 == pDeviceInfo->dwNumModes)
        return D3DENUMRET_OK;

    // Find a 640x480x16 mode for the default fullscreen mode
    for(i=0; i<pDeviceInfo->dwNumModes; i++)
    {
        if ((pDeviceInfo->pddsdModes[i].dwWidth == 640) &&
            (pDeviceInfo->pddsdModes[i].dwHeight == 480) &&
            (pDeviceInfo->pddsdModes[i].ddpfPixelFormat.dwRGBBitCount == 16))
        {
            pDeviceInfo->ddsdFullscreenMode = pDeviceInfo->pddsdModes[i];
            pDeviceInfo->dwCurrentMode      = i;
        }
    }

    // Select whether the device is initially windowed
    pDeviceInfo->bWindowed = pDeviceInfo->bDesktopCompatible;

    // Accept the device and return
    g_dwNumDevices++;

    return D3DENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: DriverEnumCallback()
// Desc: Callback function for enumerating drivers.
//-----------------------------------------------------------------------------
static BOOL WINAPI DriverEnumCallback(GUID* pGUID, TCHAR* strDesc,
                                       TCHAR* strName, VOID*, HMONITOR)
{
    D3DEnum_DeviceInfo d3dDeviceInfo;
    LPDIRECTDRAW7      pDD;
    LPDIRECT3D7        pD3D;
    HRESULT            hr;
    
    // Use the GUID to create the DirectDraw object
    hr = DirectDrawCreateEx(pGUID, (VOID**)&pDD, IID_IDirectDraw7, NULL);
    if (FAILED(hr))
    {
        DEBUG_MSG(_T("Can't create DDraw during enumeration!"));
        return D3DENUMRET_OK;
    }

    // Create a D3D object, to enumerate the d3d devices
    hr = pDD->QueryInterface(IID_IDirect3D7, (VOID**)&pD3D);
    if (FAILED(hr))
    {
        pDD->Release();
        DEBUG_MSG(_T("Can't query IDirect3D7 during enumeration!"));
        return D3DENUMRET_OK;
    }

    // Copy data to a device info structure
    ZeroMemory(&d3dDeviceInfo, sizeof(d3dDeviceInfo));
    lstrcpyn(d3dDeviceInfo.strDesc, strDesc, 39);
    d3dDeviceInfo.ddDriverCaps.dwSize = sizeof(DDCAPS);
    d3dDeviceInfo.ddHELCaps.dwSize    = sizeof(DDCAPS);
    pDD->GetCaps(&d3dDeviceInfo.ddDriverCaps, &d3dDeviceInfo.ddHELCaps);
    if (pGUID)
    {
        d3dDeviceInfo.guidDriver = (*pGUID);
        d3dDeviceInfo.pDriverGUID = &d3dDeviceInfo.guidDriver;
    }

    // Record whether the device can render into a desktop window
    if (d3dDeviceInfo.ddDriverCaps.dwCaps2 & DDCAPS2_CANRENDERWINDOWED)
        if (NULL == d3dDeviceInfo.pDriverGUID)
            d3dDeviceInfo.bDesktopCompatible = TRUE;

    // Enumerate the fullscreen display modes.
    pDD->EnumDisplayModes(0, NULL, &d3dDeviceInfo, ModeEnumCallback);

    // Sort list of display modes
    qsort(d3dDeviceInfo.pddsdModes, d3dDeviceInfo.dwNumModes,
           sizeof(DDSURFACEDESC2), SortModesCallback);

    // Now, enumerate all the 3D devices
    pD3D->EnumDevices(DeviceEnumCallback, &d3dDeviceInfo);

    // Clean up and return
    SAFE_DELETE(d3dDeviceInfo.pddsdModes);
    pD3D->Release();
    pDD->Release();

    return DDENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DEnum_EnumerateDevices()
// Desc: Enumerates all drivers, devices, and modes. The callback function is
//       called each device, to confirm that the device supports the feature
//       set required by the app.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_EnumerateDevices(HRESULT (*AppConfirmFn)(DDCAPS*, D3DDEVICEDESC7*))
{
    // Store the device enumeration callback function
    g_fnAppConfirmFn = AppConfirmFn;

    // Enumerate drivers, devices, and modes
    DirectDrawEnumerateEx(DriverEnumCallback, NULL, 
                           DDENUM_ATTACHEDSECONDARYDEVICES |
                           DDENUM_DETACHEDSECONDARYDEVICES |
                           DDENUM_NONDISPLAYDEVICES);

    // Make sure devices were actually enumerated
    if (0 == g_dwNumDevicesEnumerated)
    {
        DEBUG_MSG(_T("No devices and/or modes were enumerated!"));
        return D3DENUMERR_ENUMERATIONFAILED;
    }
    if (0 == g_dwNumDevices)
    {
        DEBUG_MSG(_T("No enumerated devices were accepted!"));
        DEBUG_MSG(_T("Try enabling the D3D Reference Rasterizer."));
        return D3DENUMERR_SUGGESTREFRAST;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DEnum_FreeResources()
// Desc: Cleans up any memory allocated during device enumeration
//-----------------------------------------------------------------------------
VOID D3DEnum_FreeResources()
{
    for(DWORD i=0; i<g_dwNumDevices; i++)
    {
        SAFE_DELETE(g_pDeviceList[i].pddsdModes);
    }
}




//-----------------------------------------------------------------------------
// Name: D3DEnum_GetDevices()
// Desc: Returns a ptr to the array of D3DEnum_DeviceInfo structures.
//-----------------------------------------------------------------------------
VOID D3DEnum_GetDevices(D3DEnum_DeviceInfo** ppDevices, DWORD* pdwCount)
{
    if (ppDevices)
        (*ppDevices) = g_pDeviceList;
    if (pdwCount)
        (*pdwCount)  = g_dwNumDevices;
}




//-----------------------------------------------------------------------------
// Name: UpdateDialogControls()
// Desc: Builds the list of devices and modes for the combo boxes in the device
//       select dialog box.
//-----------------------------------------------------------------------------
static VOID UpdateDialogControls(HWND hDlg, D3DEnum_DeviceInfo* pCurrentDevice,
                                  DWORD dwCurrentMode, BOOL bWindowed,
                                  BOOL bStereo)
{
    // Get access to the enumerated device list
    D3DEnum_DeviceInfo* pDeviceList;
    DWORD               dwNumDevices;
    D3DEnum_GetDevices(&pDeviceList, &dwNumDevices);

    // Access to UI controls
    HWND hwndDevice         = GetDlgItem(hDlg, IDC_DEVICE_COMBO);
    HWND hwndMode           = GetDlgItem(hDlg, IDC_MODE_COMBO);
    HWND hwndWindowed       = GetDlgItem(hDlg, IDC_WINDOWED_CHECKBOX);
    HWND hwndStereo         = GetDlgItem(hDlg, IDC_STEREO_CHECKBOX);
    HWND hwndFullscreenText = GetDlgItem(hDlg, IDC_FULLSCREEN_TEXT);

    // Reset the content in each of the combo boxes
    ComboBox_ResetContent(hwndDevice);
    ComboBox_ResetContent(hwndMode);

    // Don't let non-GDI devices be windowed
    if (FALSE == pCurrentDevice->bDesktopCompatible)
        bWindowed = FALSE;

    // Add a list of devices to the device combo box
    for(DWORD device = 0; device < dwNumDevices; device++)
    {
        D3DEnum_DeviceInfo* pDevice = &pDeviceList[device];

        // Add device name to the combo box
        DWORD dwItem = ComboBox_AddString(hwndDevice, pDevice->strDesc);
        
        // Set the remaining UI states for the current device
        if (pDevice == pCurrentDevice)
        {
            // Set the combobox selection on the current device
            ComboBox_SetCurSel(hwndDevice, dwItem);

            // Enable/set the fullscreen checkbox, as appropriate
            if (hwndWindowed)
            {
                EnableWindow(hwndWindowed, pDevice->bDesktopCompatible);
                Button_SetCheck(hwndWindowed, bWindowed);
            }
            
            // Enable/set the stereo checkbox, as appropriate
            if (hwndStereo)
            {
                EnableWindow(hwndStereo, pDevice->bStereoCompatible && !bWindowed);
                Button_SetCheck(hwndStereo, bStereo);
            }

            // Enable/set the fullscreen modes combo, as appropriate
            EnableWindow(hwndMode, !bWindowed);
            EnableWindow(hwndFullscreenText, !bWindowed);

            // Build the list of fullscreen modes
            for(DWORD mode = 0; mode < pDevice->dwNumModes; mode++)
            {
                DDSURFACEDESC2* pddsdMode = &pDevice->pddsdModes[mode];

                // Skip non-stereo modes, if the device is in stereo mode
                if (0 == (pddsdMode->ddsCaps.dwCaps2&DDSCAPS2_STEREOSURFACELEFT))
                    if (bStereo)
                        continue;

                TCHAR strMode[80];
                wsprintf(strMode, _T("%ld x %ld x %ld"),
                          pddsdMode->dwWidth, pddsdMode->dwHeight,
                          pddsdMode->ddpfPixelFormat.dwRGBBitCount);

                // Add mode desc to the combo box
                DWORD dwItem = ComboBox_AddString(hwndMode, strMode);

                // Set the item data to identify this mode
                ComboBox_SetItemData(hwndMode, dwItem, mode);

                // Set the combobox selection on the current mode
                if (mode == dwCurrentMode)
                    ComboBox_SetCurSel(hwndMode, dwItem);

                // Since not all modes support stereo, select a default mode in
                // case none was chosen yet.
                if (bStereo && (CB_ERR == ComboBox_GetCurSel(hwndMode)))
                    ComboBox_SetCurSel(hwndMode, dwItem);
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ChangeDeviceProc()
// Desc: Windows message handling function for the device select dialog
//-----------------------------------------------------------------------------
static BOOL CALLBACK ChangeDeviceProc(HWND hDlg, UINT uiMsg, WPARAM wParam, 
                                       LPARAM lParam)
{
    static D3DEnum_DeviceInfo** ppDeviceArg;
    static D3DEnum_DeviceInfo* pCurrentDevice;
    static DWORD dwCurrentMode;
    static BOOL  bCurrentWindowed;
    static BOOL  bCurrentStereo;

    // Get access to the enumerated device list
    D3DEnum_DeviceInfo* pDeviceList;
    DWORD               dwNumDevices;
    D3DEnum_GetDevices(&pDeviceList, &dwNumDevices);

    // Handle the initialization message
    if (WM_INITDIALOG == uiMsg)
    {
        // Get the app's current device, passed in as an lParam argument        
        ppDeviceArg = (D3DEnum_DeviceInfo**)lParam;
        if (NULL == ppDeviceArg)
            return FALSE;

        // Setup temp storage pointers for dialog
        pCurrentDevice = (*ppDeviceArg);
        dwCurrentMode    = pCurrentDevice->dwCurrentMode;
        bCurrentWindowed = pCurrentDevice->bWindowed;
        bCurrentStereo   = pCurrentDevice->bStereo;

        UpdateDialogControls(hDlg, pCurrentDevice, dwCurrentMode,
                              bCurrentWindowed, bCurrentStereo);

        return TRUE;
    }
    else if (WM_COMMAND == uiMsg)
    {
        HWND hwndDevice   = GetDlgItem(hDlg, IDC_DEVICE_COMBO);
        HWND hwndMode     = GetDlgItem(hDlg, IDC_MODE_COMBO);
        HWND hwndWindowed = GetDlgItem(hDlg, IDC_WINDOWED_CHECKBOX);
        HWND hwndStereo   = GetDlgItem(hDlg, IDC_STEREO_CHECKBOX);

        // Get current UI state
        DWORD dwDevice   = ComboBox_GetCurSel(hwndDevice);
        DWORD dwModeItem = ComboBox_GetCurSel(hwndMode);
        DWORD dwMode     = ComboBox_GetItemData(hwndMode, dwModeItem);
        BOOL  bWindowed  = hwndWindowed ? Button_GetCheck(hwndWindowed) : 0;
        BOOL  bStereo    = hwndStereo   ? Button_GetCheck(hwndStereo)   : 0;

        D3DEnum_DeviceInfo* pDevice = &pDeviceList[dwDevice];
        
        if (IDOK == LOWORD(wParam))
        {
            // Handle the case when the user hits the OK button. Check if any
            // of the options were changed
            if (pDevice != pCurrentDevice || dwMode != dwCurrentMode ||
                bWindowed != bCurrentWindowed || bStereo != bCurrentStereo)
            {
                // Return the newly selected device and its new properties
                (*ppDeviceArg)              = pDevice;
                pDevice->bWindowed          = bWindowed;
                pDevice->bStereo            = bStereo;
                pDevice->dwCurrentMode      = dwMode;
                pDevice->ddsdFullscreenMode = pDevice->pddsdModes[dwMode];

                EndDialog(hDlg, IDOK);
            }
            else
                EndDialog(hDlg, IDCANCEL);

            return TRUE;
        }
        else if (IDCANCEL == LOWORD(wParam))
        {
            // Handle the case when the user hits the Cancel button
            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        else if (CBN_SELENDOK == HIWORD(wParam))
        {
            if (LOWORD(wParam) == IDC_DEVICE_COMBO)
            {
                // Handle the case when the user chooses the device combo
                dwMode    = pDeviceList[dwDevice].dwCurrentMode;
                bWindowed = pDeviceList[dwDevice].bWindowed;
                bStereo   = pDeviceList[dwDevice].bStereo;
            }
        }

        // Keep the UI current
        UpdateDialogControls(hDlg, &pDeviceList[dwDevice], dwMode, bWindowed, bStereo);
        return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: D3DEnum_UserChangeDevice()
// Desc: Pops up a dialog which allows the user to select a new device.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_UserChangeDevice(D3DEnum_DeviceInfo** ppDevice)
{
    if (IDOK == DialogBoxParam((HINSTANCE)GetModuleHandle(NULL),
                                MAKEINTRESOURCE(IDD_CHANGEDEVICE),
                                GetForegroundWindow(),
                                ChangeDeviceProc, (LPARAM)ppDevice))
        return S_OK;

    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: D3DEnum_SelectDefaultDevice()
// Desc: Pick a default device, preferably hardware and desktop compatible.
//-----------------------------------------------------------------------------
HRESULT D3DEnum_SelectDefaultDevice(D3DEnum_DeviceInfo** ppDevice,
                                     DWORD dwFlags)
{
    // Check arguments
    if (NULL == ppDevice)
        return E_INVALIDARG;

    // Get access to the enumerated device list
    D3DEnum_DeviceInfo* pDeviceList;
    DWORD               dwNumDevices;
    D3DEnum_GetDevices(&pDeviceList, &dwNumDevices);

    // Look for windowable software, hardware, and hardware TnL devices
    D3DEnum_DeviceInfo* pRefRastDevice     = NULL;
    D3DEnum_DeviceInfo* pSoftwareDevice    = NULL;
    D3DEnum_DeviceInfo* pHardwareDevice    = NULL;
    D3DEnum_DeviceInfo* pHardwareTnLDevice = NULL;

    for(DWORD i=0; i<dwNumDevices; i++)
    {
        if (pDeviceList[i].bDesktopCompatible)
        {
            if (pDeviceList[i].bHardware)
            {
                if ((*pDeviceList[i].pDeviceGUID) == IID_IDirect3DTnLHalDevice)
                    pHardwareTnLDevice = &pDeviceList[i];
                else
                    pHardwareDevice = &pDeviceList[i];
            }
            else
            {
                if ((*pDeviceList[i].pDeviceGUID) == IID_IDirect3DRefDevice)
                    pRefRastDevice = &pDeviceList[i];
                else
                    pSoftwareDevice = &pDeviceList[i];
            }
        }
    }

    // Prefer a hardware TnL device first, then a non-TnL hardware device, and
    // finally, a software device.
    if (0 == (dwFlags & D3DENUM_SOFTWAREONLY) && pHardwareTnLDevice)
        (*ppDevice) = pHardwareTnLDevice;
    else if (0 == (dwFlags & D3DENUM_SOFTWAREONLY) && pHardwareDevice)
        (*ppDevice) = pHardwareDevice;
    else if (pSoftwareDevice)
        (*ppDevice) = pSoftwareDevice;
    else if (pRefRastDevice)
        (*ppDevice) = pRefRastDevice;
    else
        return D3DENUMERR_NOCOMPATIBLEDEVICES;

    // Set the windowed state of the newly selected device  
    (*ppDevice)->bWindowed = TRUE;

    return S_OK;
}





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dframe.cpp ===
#include "StdAfx.h"





#if 0
//-----------------------------------------------------------------------------
// File: D3DFrame.cpp
//
// Desc: Class functions to implement a Direct3D app framework.
//
// Copyright (c) 1995-1999 by Microsoft, all rights reserved
//-----------------------------------------------------------------------------
//#define STRICT
//#include <windows.h>
//#include <tchar.h>
#include "D3DFrame.h"
#include "D3DUtil.h"




//-----------------------------------------------------------------------------
// Name: CD3DFramework7()
// Desc: The constructor. Clears static variables
//-----------------------------------------------------------------------------
CD3DFramework7::CD3DFramework7()
{
     m_hWnd           = NULL;
     m_bIsFullscreen  = FALSE;
     m_bIsStereo      = FALSE;
     m_dwRenderWidth  = 0L;
     m_dwRenderHeight = 0L;
     
     m_pddsFrontBuffer    = NULL;
     m_pddsBackBuffer     = NULL;
     m_pddsBackBufferLeft = NULL;
     
     m_pddsZBuffer     = NULL;
     m_pd3dDevice      = NULL;
     m_pDD             = NULL;
     m_pD3D            = NULL;
     m_dwDeviceMemType = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFramework7()
// Desc: The destructor. Deletes all objects
//-----------------------------------------------------------------------------
CD3DFramework7::~CD3DFramework7()
{
    DestroyObjects();
}




//-----------------------------------------------------------------------------
// Name: DestroyObjects()
// Desc: Cleans everything up upon deletion. This code returns an error
//       if any of the objects have remaining reference counts.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::DestroyObjects()
{
    LONG nDD  = 0L; // Number of outstanding DDraw references
    LONG nD3D = 0L; // Number of outstanding D3DDevice references

    if (m_pDD)
    {
        m_pDD->SetCooperativeLevel(m_hWnd, DDSCL_NORMAL);
    }

    // Do a safe check for releasing the D3DDEVICE. RefCount must be zero.
    if (m_pd3dDevice)
        if (0 < (nD3D = m_pd3dDevice->Release()))
            DEBUG_MSG(_T("Error: D3DDevice object is still referenced!"));
    m_pd3dDevice = NULL;

    SAFE_RELEASE(m_pddsBackBuffer);
    SAFE_RELEASE(m_pddsBackBufferLeft);
    SAFE_RELEASE(m_pddsZBuffer);
    SAFE_RELEASE(m_pddsFrontBuffer);
    SAFE_RELEASE(m_pD3D);

    if (m_pDD)
    {
        // Do a safe check for releasing DDRAW. RefCount must be zero.
        if (0 < (nDD = m_pDD->Release()))
            DEBUG_MSG(_T("Error: DDraw object is still referenced!"));
    }
    m_pDD = NULL;

    // Return successful, unless there are outstanding DD or D3DDevice refs.
    return (nDD==0 && nD3D==0) ? S_OK : D3DFWERR_NONZEROREFCOUNT;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Creates the internal objects for the framework
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::Initialize(HWND hWnd, GUID* pDriverGUID,
                                    GUID* pDeviceGUID, DDSURFACEDESC2* pMode,
                                    DWORD dwFlags)
{
    HRESULT hr;

    // Check params. Note: A NULL mode is valid for windowed modes only.
    if ((NULL==hWnd) || (NULL==pDeviceGUID) || 
        (NULL==pMode && (dwFlags&D3DFW_FULLSCREEN)))
        return E_INVALIDARG;

    // Setup state for windowed/fullscreen mode
    m_hWnd          = hWnd;
    m_bIsStereo     = FALSE;
    m_bIsFullscreen = (dwFlags & D3DFW_FULLSCREEN) ? TRUE : FALSE;

    // Support stereoscopic viewing for fullscreen modes which support it
    if ((dwFlags & D3DFW_STEREO) && (dwFlags & D3DFW_FULLSCREEN))
        if (pMode->ddsCaps.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
            m_bIsStereo = TRUE;

    // Create the D3D rendering environment (surfaces, device, viewport, etc.)
    if (FAILED(hr = CreateEnvironment(pDriverGUID, pDeviceGUID, pMode,
                                        dwFlags)))
    {
        DestroyObjects();
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateEnvironment()
// Desc: Creates the internal objects for the framework
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateEnvironment(GUID* pDriverGUID, GUID* pDeviceGUID,
                                           DDSURFACEDESC2* pMode, DWORD dwFlags)
{
    HRESULT hr;

    // Select the default memory type, for whether the device is HW or SW
    if (IsEqualIID(*pDeviceGUID, IID_IDirect3DHALDevice))
        m_dwDeviceMemType = DDSCAPS_VIDEOMEMORY;
    else if (IsEqualIID(*pDeviceGUID, IID_IDirect3DTnLHalDevice))
        m_dwDeviceMemType = DDSCAPS_VIDEOMEMORY;
    else
        m_dwDeviceMemType = DDSCAPS_SYSTEMMEMORY;

    // Create the DDraw object
    hr = CreateDirectDraw(pDriverGUID, dwFlags);
    if (FAILED(hr))
        return hr;

    // Create the front and back buffers, and attach a clipper
    if (dwFlags & D3DFW_FULLSCREEN)
        hr = CreateFullscreenBuffers(pMode);
    else
        hr = CreateWindowedBuffers();
    if (FAILED(hr))
        return hr;

    // Create the Direct3D object and the Direct3DDevice object
    hr = CreateDirect3D(pDeviceGUID);
    if (FAILED(hr))
        return hr;

    // Create and attach the zbuffer
    if (dwFlags & D3DFW_ZBUFFER)
        hr = CreateZBuffer(pDeviceGUID);
    if (FAILED(hr))
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: EnumZBufferFormatsCallback()
// Desc: Simply returns the first matching enumerated z-buffer format
//-----------------------------------------------------------------------------
static HRESULT WINAPI EnumZBufferFormatsCallback(DDPIXELFORMAT* pddpf,
                                                  VOID* pContext)
{
    DDPIXELFORMAT* pddpfOut = (DDPIXELFORMAT*)pContext;

    if (pddpfOut->dwRGBBitCount == pddpf->dwRGBBitCount)
    {
        (*pddpfOut) = (*pddpf);
        return D3DENUMRET_CANCEL;
    }

    return D3DENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateDirectDraw()
// Desc: Create the DirectDraw interface
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateDirectDraw(GUID* pDriverGUID, DWORD dwFlags)
{
    // Create the DirectDraw interface, and query for the DD7 interface
    if (FAILED(DirectDrawCreateEx(pDriverGUID, (VOID**)&m_pDD,
                                    IID_IDirectDraw7, NULL)))
    {
        DEBUG_MSG(_T("Could not create DirectDraw"));
        return D3DFWERR_NODIRECTDRAW;
    }

    // Set the Windows cooperative level
    DWORD dwCoopFlags = DDSCL_NORMAL;
    if (m_bIsFullscreen)
        dwCoopFlags = DDSCL_ALLOWREBOOT|DDSCL_EXCLUSIVE|DDSCL_FULLSCREEN;

    // By defualt, set the flag to allow D3D to optimize floating point calcs
    if (0L == (dwFlags & D3DFW_NO_FPUSETUP))
        dwCoopFlags |= DDSCL_FPUSETUP;

    if (FAILED(m_pDD->SetCooperativeLevel(m_hWnd, dwCoopFlags)))
    {
        DEBUG_MSG(_T("Couldn't set coop level"));
        return D3DFWERR_COULDNTSETCOOPLEVEL;
    }

    // Check that we are NOT in a palettized display. That case will fail,
    // since the framework doesn't use palettes.
    DDSURFACEDESC2 ddsd;
    ddsd.dwSize = sizeof(ddsd);
    m_pDD->GetDisplayMode(&ddsd);
    if (ddsd.ddpfPixelFormat.dwRGBBitCount <= 8)
        return D3DFWERR_INVALIDMODE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateFullscreenBuffers()
// Desc: Creates the primary and (optional) backbuffer for rendering.
//       Windowed mode and fullscreen mode are handled differently.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateFullscreenBuffers(DDSURFACEDESC2* pddsd)
{
    HRESULT hr;

    // Get the dimensions of the screen bounds
    // Store the rectangle which contains the renderer
    SetRect(&m_rcScreenRect, 0, 0, pddsd->dwWidth, pddsd->dwHeight);
    m_dwRenderWidth  = m_rcScreenRect.right  - m_rcScreenRect.left;
    m_dwRenderHeight = m_rcScreenRect.bottom - m_rcScreenRect.top;

    // Set the display mode to the requested dimensions. Check for
    // 320x200x8 modes, and set flag to avoid using ModeX
    DWORD dwModeFlags = 0;

    if ((320==m_dwRenderWidth) && (200==m_dwRenderHeight) &&
        (8==pddsd->ddpfPixelFormat.dwRGBBitCount))
        dwModeFlags |= DDSDM_STANDARDVGAMODE;

    if (FAILED(m_pDD->SetDisplayMode(m_dwRenderWidth, m_dwRenderHeight,
                                pddsd->ddpfPixelFormat.dwRGBBitCount,
                                pddsd->dwRefreshRate, dwModeFlags)))
    {
        DEBUG_MSG(_T("Can't set display mode"));
        return D3DFWERR_BADDISPLAYMODE;
    }

    // Setup to create the primary surface w/backbuffer
    DDSURFACEDESC2 ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize            = sizeof(ddsd);
    ddsd.dwFlags           = DDSD_CAPS|DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps    = DDSCAPS_PRIMARYSURFACE | DDSCAPS_3DDEVICE |
                             DDSCAPS_FLIP | DDSCAPS_COMPLEX;
    ddsd.dwBackBufferCount = 1;

    // Support for stereoscopic viewing
    if (m_bIsStereo)
    {
        ddsd.ddsCaps.dwCaps  |= DDSCAPS_VIDEOMEMORY;
        ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
    }

    // Create the primary surface
    if (FAILED(hr = m_pDD->CreateSurface(&ddsd, &m_pddsFrontBuffer, NULL)))
    {
        DEBUG_MSG(_T("Error: Can't create primary surface"));
        if (hr != DDERR_OUTOFVIDEOMEMORY)
            return D3DFWERR_NOPRIMARY;
        DEBUG_MSG(_T("Error: Out of video memory"));
        return DDERR_OUTOFVIDEOMEMORY;
    }

    // Get the backbuffer, which was created along with the primary.
    DDSCAPS2 ddscaps = { DDSCAPS_BACKBUFFER, 0, 0, 0 };
    if (FAILED(hr = m_pddsFrontBuffer->GetAttachedSurface(&ddscaps,
                                                &m_pddsBackBuffer)))
    {
        DEBUG_ERR(hr, _T("Error: Can't get the backbuffer"));
        return D3DFWERR_NOBACKBUFFER;
    }

    // Increment the backbuffer count (for consistency with windowed mode)
    m_pddsBackBuffer->AddRef();

    // Support for stereoscopic viewing
    if (m_bIsStereo)
    {
        // Get the left backbuffer, which was created along with the primary.
        DDSCAPS2 ddscaps = { 0, DDSCAPS2_STEREOSURFACELEFT, 0, 0 };
        if (FAILED(hr = m_pddsBackBuffer->GetAttachedSurface(&ddscaps,
                                                    &m_pddsBackBufferLeft)))
        {
            DEBUG_ERR(hr, _T("Error: Can't get the left backbuffer"));
            return D3DFWERR_NOBACKBUFFER;
        }
        m_pddsBackBufferLeft->AddRef();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateWindowedBuffers()
// Desc: Creates the primary and (optional) backbuffer for rendering.
//       Windowed mode and fullscreen mode are handled differently.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateWindowedBuffers()
{
    HRESULT hr;

    // Get the dimensions of the viewport and screen bounds
    GetClientRect(m_hWnd, &m_rcScreenRect);
    ClientToScreen(m_hWnd, (POINT*)&m_rcScreenRect.left);
    ClientToScreen(m_hWnd, (POINT*)&m_rcScreenRect.right);
    m_dwRenderWidth  = m_rcScreenRect.right  - m_rcScreenRect.left;
    m_dwRenderHeight = m_rcScreenRect.bottom - m_rcScreenRect.top;

    // Create the primary surface
    DDSURFACEDESC2 ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize         = sizeof(ddsd);
    ddsd.dwFlags        = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    if (FAILED(hr = m_pDD->CreateSurface(&ddsd, &m_pddsFrontBuffer, NULL)))
    {
        DEBUG_MSG(_T("Error: Can't create primary surface"));
        if (hr != DDERR_OUTOFVIDEOMEMORY)
            return D3DFWERR_NOPRIMARY;
        DEBUG_MSG(_T("Error: Out of video memory"));
        return DDERR_OUTOFVIDEOMEMORY;
    }

    // If in windowed-mode, create a clipper object
    LPDIRECTDRAWCLIPPER pcClipper;
    if (FAILED(hr = m_pDD->CreateClipper(0, &pcClipper, NULL)))
    {
        DEBUG_MSG(_T("Error: Couldn't create clipper"));
        return D3DFWERR_NOCLIPPER;
    }

    // Associate the clipper with the window
    pcClipper->SetHWnd(0, m_hWnd);
    m_pddsFrontBuffer->SetClipper(pcClipper);
    SAFE_RELEASE(pcClipper);

    // Create a backbuffer
    ddsd.dwFlags        = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
    ddsd.dwWidth        = m_dwRenderWidth;
    ddsd.dwHeight       = m_dwRenderHeight;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;

    if (FAILED(hr = m_pDD->CreateSurface(&ddsd, &m_pddsBackBuffer, NULL)))
    {
        DEBUG_ERR(hr, _T("Error: Couldn't create the backbuffer"));
        if (hr != DDERR_OUTOFVIDEOMEMORY)
            return D3DFWERR_NOBACKBUFFER;
        DEBUG_MSG(_T("Error: Out of video memory"));
        return DDERR_OUTOFVIDEOMEMORY;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateDirect3D()
// Desc: Create the Direct3D interface
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateDirect3D(GUID* pDeviceGUID)
{
    // Query DirectDraw for access to Direct3D
    if (FAILED(m_pDD->QueryInterface(IID_IDirect3D7, (VOID**)&m_pD3D)))
    {
        DEBUG_MSG(_T("Couldn't get the Direct3D interface"));
        return D3DFWERR_NODIRECT3D;
    }

    // Create the device
    if (FAILED(m_pD3D->CreateDevice(*pDeviceGUID, m_pddsBackBuffer,
                                      &m_pd3dDevice)))
    {
        DEBUG_MSG(_T("Couldn't create the D3DDevice"));
        return D3DFWERR_NO3DDEVICE;
    }

    // Finally, set the viewport for the newly created device
    D3DVIEWPORT7 vp = { 0, 0, m_dwRenderWidth, m_dwRenderHeight, 0.0f, 1.0f };

    if (FAILED(m_pd3dDevice->SetViewport(&vp)))
    {
        DEBUG_MSG(_T("Error: Couldn't set current viewport to device"));
        return D3DFWERR_NOVIEWPORT;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateZBuffer()
// Desc: Internal function called by Create() to make and attach a zbuffer
//       to the renderer
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::CreateZBuffer(GUID* pDeviceGUID)
{
    HRESULT hr;

    // Check if the device supports z-bufferless hidden surface removal. If so,
    // we don't really need a z-buffer
    D3DDEVICEDESC7 ddDesc;
    m_pd3dDevice->GetCaps(&ddDesc);
    if (ddDesc.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
        return S_OK;

    // Get z-buffer dimensions from the render target
    DDSURFACEDESC2 ddsd;
    ddsd.dwSize = sizeof(ddsd);
    m_pddsBackBuffer->GetSurfaceDesc(&ddsd);

    // Setup the surface desc for the z-buffer.
    ddsd.dwFlags        = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_ZBUFFER | m_dwDeviceMemType;
    ddsd.ddpfPixelFormat.dwSize = 0;  // Tag the pixel format as unitialized

    // Get an appropiate pixel format from enumeration of the formats. On the
    // first pass, we look for a zbuffer dpeth which is equal to the frame
    // buffer depth (as some cards unfornately require this).
    m_pD3D->EnumZBufferFormats(*pDeviceGUID, EnumZBufferFormatsCallback,
                                (VOID*)&ddsd.ddpfPixelFormat);
    if (0 == ddsd.ddpfPixelFormat.dwSize)
    {
        // Try again, just accepting any 16-bit zbuffer
        ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
        m_pD3D->EnumZBufferFormats(*pDeviceGUID, EnumZBufferFormatsCallback,
                                    (VOID*)&ddsd.ddpfPixelFormat);
            
        if (0 == ddsd.ddpfPixelFormat.dwSize)
        {
            DEBUG_MSG(_T("Device doesn't support requested zbuffer format"));
            return D3DFWERR_NOZBUFFER;
        }
    }

    // Create and attach a z-buffer
    if (FAILED(hr = m_pDD->CreateSurface(&ddsd, &m_pddsZBuffer, NULL)))
    {
        DEBUG_MSG(_T("Error: Couldn't create a ZBuffer surface"));
        if (hr != DDERR_OUTOFVIDEOMEMORY)
            return D3DFWERR_NOZBUFFER;
        DEBUG_MSG(_T("Error: Out of video memory"));
        return DDERR_OUTOFVIDEOMEMORY;
    }

    if (FAILED(m_pddsBackBuffer->AddAttachedSurface(m_pddsZBuffer)))
    {
        DEBUG_MSG(_T("Error: Couldn't attach zbuffer to render surface"));
        return D3DFWERR_NOZBUFFER;
    }

    // For stereoscopic viewing, attach zbuffer to left surface as well
    if (m_bIsStereo)
    {
        if (FAILED(m_pddsBackBufferLeft->AddAttachedSurface(m_pddsZBuffer)))
        {
            DEBUG_MSG(_T("Error: Couldn't attach zbuffer to left render surface"));
            return D3DFWERR_NOZBUFFER;
        }
    }

    // Finally, this call rebuilds internal structures
    if (FAILED(m_pd3dDevice->SetRenderTarget(m_pddsBackBuffer, 0L)))
    {
        DEBUG_MSG(_T("Error: SetRenderTarget() failed after attaching zbuffer!"));
        return D3DFWERR_NOZBUFFER;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreSurfaces()
// Desc: Checks for lost surfaces and restores them if lost. Note: Don't
//       restore render surface, since it's just a duplicate ptr.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::RestoreSurfaces()
{
    // Restore all surfaces (including video memory vertex buffers)
    m_pDD->RestoreAllSurfaces();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Move()
// Desc: Moves the screen rect for windowed renderers
//-----------------------------------------------------------------------------
VOID CD3DFramework7::Move(INT x, INT y)
{
    if (TRUE == m_bIsFullscreen)
        return;

    SetRect(&m_rcScreenRect, x, y, x + m_dwRenderWidth, y + m_dwRenderHeight);
}




//-----------------------------------------------------------------------------
// Name: FlipToGDISurface()
// Desc: Puts the GDI surface in front of the primary, so that dialog
//       boxes and other windows drawing funcs may happen.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::FlipToGDISurface(BOOL bDrawFrame)
{
    if (m_pDD && m_bIsFullscreen)
    {
        m_pDD->FlipToGDISurface();

        if (bDrawFrame)
        {
            DrawMenuBar(m_hWnd);
            RedrawWindow(m_hWnd, NULL, NULL, RDW_FRAME);
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ShowFrame()
// Desc: Show the frame on the primary surface, via a blt or a flip.
//-----------------------------------------------------------------------------
HRESULT CD3DFramework7::ShowFrame()
{
    if (NULL == m_pddsFrontBuffer)
        return D3DFWERR_NOTINITIALIZED;

    if (m_bIsFullscreen)
    {
        // We are in fullscreen mode, so perform a flip.
        if (m_bIsStereo)
            return m_pddsFrontBuffer->Flip(NULL, DDFLIP_WAIT | DDFLIP_STEREO);
        else
            return m_pddsFrontBuffer->Flip(NULL, DDFLIP_WAIT);
    }
    else
    {
        // We are in windowed mode, so perform a blit.
        return m_pddsFrontBuffer->Blt(&m_rcScreenRect, m_pddsBackBuffer,
                                       NULL, DDBLT_WAIT, NULL);
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dfile.h ===
//-----------------------------------------------------------------------------
// File: D3DFile.h
//
// Desc: Support code for loading DirectX .X files.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DFILE_H
#define D3DFILE_H




//-----------------------------------------------------------------------------
// Name: struct MeshMaterialData
// Desc: Internal structure for holding material data for within a mesh. This
//       is used because multiple materials can be used in the same mesh.
//-----------------------------------------------------------------------------
#define MAX_MATERIAL        16
#define MAX_TEXTURE_NAME    80

struct MeshMaterialData
{
    D3DMATERIAL7 m_mtrl;
    TCHAR        m_strTexture[MAX_TEXTURE_NAME];
    DWORD        m_dwNumIndices;
};




//-----------------------------------------------------------------------------
// Name: class CD3DFileObject
// Desc: Internal class for objects in a .X file
//-----------------------------------------------------------------------------
class CD3DFileObject
{
    // Common data
    TCHAR            m_strName[80];
    CD3DFileObject*  m_pNext;
    CD3DFileObject*  m_pChild;

    // For file frames
    D3DMATRIX        m_mat;

    // For file meshes
    BOOL             m_bHasMeshData;
    DWORD            m_dwNumVertices;
    D3DVERTEX*       m_pVertices;
    DWORD            m_dwNumIndices;
    WORD*            m_pIndices;
    DWORD            m_dwNumMaterials;
    MeshMaterialData m_Material[MAX_MATERIAL];
    BOOL             m_bHasAlpha;

public:
    // Initializing functions
    VOID    AddNext(CD3DFileObject*);
    VOID    AddChild(CD3DFileObject*);
    VOID    SetName(TCHAR* strName)     { StrCpy(m_strName, strName); }
    VOID    SetMatrix(D3DMATRIX* pmat) { m_mat = *pmat; }
    VOID    SetNormals(D3DVECTOR* pNormals);
    VOID    SetTextureCoords(FLOAT* pTexCoords);
    VOID    SetMaterialData(DWORD dwMaterial, D3DMATERIAL7* pmtrl, TCHAR*strName);
    VOID    AddFace(DWORD dwMaterial, DWORD* pFaceData, DWORD dwNumFaces);
    HRESULT ComputeNormals();
    HRESULT SetMeshGeometry(D3DVECTOR* pvVertices, DWORD dwNumVertices,
                             DWORD* pFaces, DWORD dwNumFaces);
    
    // Access functions
    TCHAR*          GetName()   { return m_strName; }
    CD3DFileObject* GetNext()   { return m_pNext; }
    CD3DFileObject* GetChild()  { return m_pChild; }
    D3DMATRIX*      GetMatrix() { return &m_mat; }
    HRESULT         GetMeshGeometry(D3DVERTEX** ppVertices,
                                     DWORD* pdwNumVertices, WORD** ppIndices,
                                     DWORD* pdwNumIndices);

    // Common functions
    VOID    Render(LPDIRECT3DDEVICE7 pd3dDevice , BOOL bAlpha);
    BOOL    EnumObjects(BOOL (*fnCallback)(CD3DFileObject*,D3DMATRIX*,VOID*),
                         D3DMATRIX* pmat, VOID* pContext);

    // Constuctor / destructor
    CD3DFileObject(TCHAR* strName);
    ~CD3DFileObject();
};




//-----------------------------------------------------------------------------
// Name: class CD3DFile
// Desc: 
//-----------------------------------------------------------------------------
class CD3DFile
{
    CD3DFileObject*   m_pRoot;

public:
    HRESULT    GetMeshVertices(TCHAR* strName, D3DVERTEX** ppVertices,
                                DWORD* pdwNumVertices);
    HRESULT    GetMeshIndices(TCHAR* strName, WORD** ppIndices,
                               DWORD* pdwNumIndices);
    
    CD3DFileObject* FindObject(TCHAR* strName);
    VOID            EnumObjects(BOOL (*fnCallback)(CD3DFileObject*,D3DMATRIX*,VOID*),
                                 D3DMATRIX* pmat, VOID* pContext);
    VOID            Scale(FLOAT fScale);

    
    
    HRESULT Load(LPCTSTR strFilename);
    HRESULT Render(LPDIRECT3DDEVICE7);

    CD3DFile();
    ~CD3DFile();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dapp.h ===
//-----------------------------------------------------------------------------
// File: D3DApp.h
//
// Desc: Application class for the Direct3D samples framework library.
//
// Copyright (c) 1998-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef  D3DAPP_H
#define  D3DAPP_H

#define  D3D_OVERLOADS
#include <d3d.h>

#include "D3DFrame.h"
#include "D3DEnum.h"
#include "D3DUtil.h"
#include "D3DRes.h"




//-----------------------------------------------------------------------------
// Name: class CD3DApplication
// Desc:
//-----------------------------------------------------------------------------
class CD3DApplication
{
    // Internal variables and member functions
    CD3DFramework7* m_pFramework;
    BOOL            m_bActive;
    BOOL            m_bReady;

    BOOL            m_bFrameMoving;
    BOOL            m_bSingleStep;
    DWORD           m_dwBaseTime;
    DWORD           m_dwStopTime;

    HRESULT Initialize3DEnvironment();
    HRESULT Change3DEnvironment();

    HRESULT Render3DEnvironment();
    VOID    Cleanup3DEnvironment();
    VOID    DisplayFrameworkError(HRESULT, DWORD);

protected:
    HWND                 m_hWnd;
    D3DEnum_DeviceInfo*  m_pDeviceInfo;
    LPDIRECTDRAW7        m_pDD;
    LPDIRECT3D7          m_pD3D;
    LPDIRECT3DDEVICE7    m_pd3dDevice;
    LPDIRECTDRAWSURFACE7 m_pddsRenderTarget;
    LPDIRECTDRAWSURFACE7 m_pddsRenderTargetLeft; // For stereo modes
    DDSURFACEDESC2       m_ddsdRenderTarget;

    // Overridable variables for the app
    TCHAR*               m_strWindowTitle;
    BOOL                 m_bAppUseZBuffer;
    BOOL                 m_bAppUseStereo;
    BOOL                 m_bShowStats;
    HRESULT              (*m_fnConfirmDevice)(DDCAPS*, D3DDEVICEDESC7*);

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT OneTimeSceneInit()     { return S_OK; }
    virtual HRESULT InitDeviceObjects()    { return S_OK; }
    virtual HRESULT DeleteDeviceObjects()  { return S_OK; }
    virtual HRESULT Render()               { return S_OK; }
    virtual HRESULT FrameMove(FLOAT)     { return S_OK; }
    virtual HRESULT RestoreSurfaces()      { return S_OK; }
    virtual HRESULT FinalCleanup()         { return S_OK; }

    // Overridable power management (APM) functions
    virtual LRESULT OnQuerySuspend(DWORD dwFlags);
    virtual LRESULT OnResumeSuspend(DWORD dwData);

    // View control functions (for stereo-enabled applications)
    D3DMATRIX m_matLeftView;
    D3DMATRIX m_matRightView;
    D3DMATRIX m_matView;
    VOID    SetAppLeftViewMatrix(D3DMATRIX mat)  { m_matLeftView  = mat; }
    VOID    SetAppRightViewMatrix(D3DMATRIX mat) { m_matRightView = mat; }
    VOID    SetAppViewMatrix(D3DMATRIX mat)      { m_matView      = mat; }
    VOID    SetViewParams(D3DVECTOR* vEyePt, D3DVECTOR* vLookatPt,
                           D3DVECTOR* vUpVec, FLOAT fEyeDistance);

    // Miscellaneous functions
    VOID    ShowStats();
    VOID    OutputText(DWORD x, DWORD y, TCHAR* str);

public:
    // Functions to create, run, pause, and clean up the application
    virtual HRESULT Create(HINSTANCE, TCHAR*);
    virtual INT     Run();
    virtual LRESULT MsgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual VOID    Pause(BOOL bPause);

    // Class constructor
    CD3DApplication();
};




#endif // D3DAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dfile.cpp ===
//-----------------------------------------------------------------------------
// File: D3DFile.cpp
//
// Desc: Support code for loading DirectX .X files.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define STRICT
#define D3D_OVERLOADS

#include "StdAfx.h"

#include "guids.h"
#include "D3DUtil.h"
#include "D3DMath.h"
#include "D3DTextr.h"
#include "dxfile.h"
#include "rmxfguid.h"
#include "rmxftmpl.h"
#include "D3DFile.h"
#include "sealife.h"


//-----------------------------------------------------------------------------
// Name: GetFace
// Desc: Get the nth face
//-----------------------------------------------------------------------------
DWORD* GetFace(DWORD* pFaceData, DWORD dwFace)
{
    for(DWORD i=0; i<dwFace; i++)
        pFaceData += (*pFaceData) + 1;

    return pFaceData;
}




//-----------------------------------------------------------------------------
// Name: GetNumIndices
// Desc: Get number of indices from face data
//-----------------------------------------------------------------------------
DWORD GetNumIndices(DWORD* pFaceData, DWORD dwNumFaces)
{
    DWORD dwNumIndices = 0;
    while(dwNumFaces-- > 0)
    {
        dwNumIndices += (*pFaceData-2)*3;
        pFaceData += *pFaceData + 1;
    }

    return dwNumIndices;
}




//-----------------------------------------------------------------------------
// Name: CD3DFileBaseObject()
// Desc: 
//-----------------------------------------------------------------------------
CD3DFileObject::CD3DFileObject(TCHAR* strName)
{
    m_pNext        = NULL;
    m_pChild       = NULL;
    m_strName[0]   = 0;
    m_bHasMeshData = FALSE;

    if (strName)
        StrCpy(m_strName, strName);

    // Set a default matrix
    D3DUtil_SetIdentityMatrix(m_mat);

    // Set a default material
    D3DUtil_InitMaterial(m_Material[0].m_mtrl, 1.0f, 1.0f, 1.0f);
    ZeroMemory(m_Material, sizeof(m_Material));
    m_dwNumMaterials = 0;
    m_bHasAlpha      = FALSE;

    // Clear out vertex data
    m_dwNumVertices = 0L;
    m_pVertices     = NULL;
    m_dwNumIndices  = 0L;
    m_pIndices      = NULL;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
CD3DFileObject::~CD3DFileObject()
{
    SAFE_DELETE(m_pChild);
    SAFE_DELETE(m_pNext);

    for(DWORD i=0; i<m_dwNumMaterials; i++)
        D3DTextr_DestroyTexture(m_Material[i].m_strTexture);

    SAFE_DELETE(m_pVertices);
    SAFE_DELETE(m_pIndices);
}




//-----------------------------------------------------------------------------
// Name: SetMeshGeometry()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DFileObject::SetMeshGeometry(D3DVECTOR* pVertexData,
                                     DWORD dwNumVertices, DWORD* pFaceData,
                                     DWORD dwNumFaces)
{
    // Set up vertices
    m_dwNumVertices = dwNumVertices;
    m_pVertices     = new D3DVERTEX[m_dwNumVertices];
    if (NULL == m_pVertices)
        return E_FAIL;

    for(DWORD i=0; i< m_dwNumVertices; i++)
    {
        ZeroMemory(&m_pVertices[i], sizeof(D3DVERTEX));
        m_pVertices[i].x = pVertexData[i].x;
        m_pVertices[i].y = pVertexData[i].y;
        m_pVertices[i].z = pVertexData[i].z;
    }

    // Count the number of indices (converting n-sided faces to triangles)
    m_dwNumIndices = GetNumIndices(pFaceData, dwNumFaces);

    // Allocate memory for the indices, you must call AddFace() to set the vertices
    m_pIndices = new WORD[m_dwNumIndices];

    if (NULL == m_pIndices)
        return E_FAIL;

    m_bHasMeshData  = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DFileObject::AddChild(CD3DFileObject* pChild)
{
    if (m_pChild)
        m_pChild->AddNext(pChild);
    else
        m_pChild = pChild;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DFileObject::AddNext(CD3DFileObject* pNext)
{
    if (m_pNext)
        m_pNext->AddNext(pNext);
    else
        m_pNext = pNext;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DFileObject::Render(LPDIRECT3DDEVICE7 pd3dDevice, BOOL bAlpha)
{
    if (m_bHasMeshData)
    {
        // Render the mesh
        WORD* pIndices = m_pIndices;
        for(DWORD i=0; i <= m_dwNumMaterials; i++)
        {
            // Skip materials with no references
            if (0L == m_Material[i].m_dwNumIndices)
                continue;

            // Render opaque and transparent meshes during separate passes
            if (bAlpha == m_bHasAlpha)
            {
                TCHAR* strTexture   = m_Material[i].m_strTexture;
                DWORD  dwNumIndices = m_Material[i].m_dwNumIndices;

                if (strTexture[0])
                    pd3dDevice->SetTexture(0, D3DTextr_GetSurface(strTexture));
                pd3dDevice->SetMaterial(&m_Material[i].m_mtrl);
                pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, D3DFVF_VERTEX,
                                                  m_pVertices, m_dwNumVertices,
                                                  pIndices, dwNumIndices, NULL);
            }

            pIndices += m_Material[i].m_dwNumIndices;
        }
    }
    else
    {
        if (m_pChild)
        {
            // Save the old matrix sate
            D3DMATRIX matWorldOld, matWorldNew;
            pd3dDevice->GetTransform(D3DTRANSFORMSTATE_WORLD, &matWorldOld);

            // Concat the frame matrix with the current world matrix
            matWorldNew = m_mat * matWorldOld;
            pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &matWorldNew);

            // Render the child nodes
            m_pChild->Render(pd3dDevice, bAlpha);

            // Restore the old matrix state
            pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &matWorldOld);
        }
    }

    // Render the remaining sibling nodes
    if (m_pNext)
        m_pNext->Render(pd3dDevice, bAlpha);
}




//-----------------------------------------------------------------------------
// Name: SetMaterialData()
// Desc: Sets the material structure for the mesh
//-----------------------------------------------------------------------------
VOID CD3DFileObject::SetMaterialData(DWORD dwMaterial, D3DMATERIAL7* pmtrl,
                                      TCHAR* strName)
{
    if (dwMaterial < MAX_MATERIAL)
    {
        m_Material[dwMaterial].m_mtrl = *pmtrl;
        StrCpyN(m_Material[dwMaterial].m_strTexture, strName, MAX_TEXTURE_NAME);

        if (pmtrl->diffuse.a < 1.0f)
            m_bHasAlpha = TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: AddFace()
// Desc: Adds one or more faces to a material slot in a Mesh. Note: this must
//       be called in order (material 0 first, then 1, ...)
//-----------------------------------------------------------------------------
VOID CD3DFileObject::AddFace(DWORD dwMaterial, DWORD* pFaceData,
                              DWORD dwNumFaces)
{
    // Make sure dwMaterial is in range
    if (dwMaterial >= MAX_MATERIAL)
        return;

    // Update the material count
    if (m_dwNumMaterials < dwMaterial+1)
        m_dwNumMaterials = dwMaterial+1;

    // add indices to the end
    WORD* pIndices = m_pIndices;
    for(DWORD i=0; i<=dwMaterial; i++)
        pIndices += m_Material[i].m_dwNumIndices;

    // Assign the indices (build a triangle fan for high-order polygons)
    while(dwNumFaces--)
    {
        DWORD dwNumVerticesPerFace = *pFaceData++;

        for(DWORD i=2; i<dwNumVerticesPerFace; i++)
        {
            m_Material[dwMaterial].m_dwNumIndices += 3;
            *pIndices++ = (WORD)pFaceData[0];
            *pIndices++ = (WORD)pFaceData[i-1];
            *pIndices++ = (WORD)pFaceData[i];
        }

        pFaceData += dwNumVerticesPerFace;
    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT CD3DFileObject::GetMeshGeometry(D3DVERTEX** ppVertices, DWORD* pdwNumVertices,
                                         WORD** ppIndices, DWORD* pdwNumIndices)
{
    if (ppVertices)     *ppVertices     = m_pVertices;
    if (pdwNumVertices) *pdwNumVertices = m_dwNumVertices;
    if (ppIndices)      *ppIndices      = m_pIndices;
    if (pdwNumIndices)  *pdwNumIndices  = m_dwNumIndices;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT CD3DFileObject::ComputeNormals()
{
    D3DVECTOR* pNormals = new D3DVECTOR[m_dwNumVertices];
    ZeroMemory(pNormals, sizeof(D3DVECTOR)*m_dwNumVertices);

    for(DWORD i=0; i<m_dwNumIndices; i+=3)
    {
        WORD a = m_pIndices[i+0];
        WORD b = m_pIndices[i+1];
        WORD c = m_pIndices[i+2];

        D3DVECTOR* v1 = (D3DVECTOR*)&m_pVertices[a];
        D3DVECTOR* v2 = (D3DVECTOR*)&m_pVertices[b];
        D3DVECTOR* v3 = (D3DVECTOR*)&m_pVertices[c];

        D3DVECTOR n = Normalize(CrossProduct(*v2-*v1, *v3-*v2));

        pNormals[a] += n;
        pNormals[b] += n;
        pNormals[c] += n;
    }

    // Assign the newly computed normals back to the vertices
    for(i=0; i<m_dwNumVertices; i++)
    {
        // Provide some relief to bogus normals
        if (Magnitude(pNormals[i]) < 0.1f) 
            pNormals[i] = D3DVECTOR(0.0f, 0.0f, 1.0f);
        
        pNormals[i] = Normalize(pNormals[i]);
        m_pVertices[i].nx = pNormals[i].x;
        m_pVertices[i].ny = pNormals[i].y;
        m_pVertices[i].nz = pNormals[i].z;
    }

    delete pNormals;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DFileObject::SetNormals(D3DVECTOR* pNormals)
{
    for(DWORD i=0; i<m_dwNumVertices; i++)
    {
        m_pVertices[i].nx = pNormals[i].x;
        m_pVertices[i].ny = pNormals[i].y;
        m_pVertices[i].nz = pNormals[i].z;
    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DFileObject::SetTextureCoords(FLOAT* pTexCoords)
{
    for(DWORD i=0; i<m_dwNumVertices; i++)
    {
        m_pVertices[i].tu = pTexCoords[2*i+0];
        m_pVertices[i].tv = pTexCoords[2*i+1];
    }
}




//-----------------------------------------------------------------------------
// Name: ParseXXXX()
// Desc: The following routines implement the DirectX .X file loader.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT ParseMaterial(LPDIRECTXFILEDATA pFileData, CD3DFileObject* pMesh,
                       DWORD dwMaterial)
{
    // Read data from the file
    LONG_PTR  pData;
    DWORD dwSize;
    TCHAR strTexture[128];

    if (FAILED(pFileData->GetData(NULL, &dwSize, (VOID**)&pData)))
        return NULL;

    // Set the material properties for the mesh
    D3DMATERIAL7 mtrl;
    ZeroMemory(&mtrl, sizeof(mtrl));
    memcpy(&mtrl.diffuse,  (VOID*)(pData+0),  sizeof(FLOAT)*4);
    memcpy(&mtrl.ambient,  (VOID*)(pData+0),  sizeof(FLOAT)*4);
    memcpy(&mtrl.power,    (VOID*)(pData+16), sizeof(FLOAT)*1);
    memcpy(&mtrl.specular, (VOID*)(pData+20), sizeof(FLOAT)*3);
    memcpy(&mtrl.emissive, (VOID*)(pData+32), sizeof(FLOAT)*3);
    strTexture[0] = 0;

    LPDIRECTXFILEOBJECT pChildObj;
    if (SUCCEEDED(pFileData->GetNextObject(&pChildObj)))
    {
        LPDIRECTXFILEDATA pChildData;

        if (SUCCEEDED(pChildObj->QueryInterface(IID_IDirectXFileData,
                                                    (VOID**)&pChildData)))
        {
            const GUID* pguid;
            pChildData->GetType(&pguid);

            if (TID_D3DRMTextureFilename == *pguid)
            {
                TCHAR** string;

                if (FAILED(pChildData->GetData(NULL, &dwSize, (VOID**)&string)))
                    return NULL;

                D3DTextr_CreateTextureFromFile(*string);
                StrCpyN(strTexture, *string, 128);
            }

            pChildData->Release();
        }

        pChildObj->Release();
    }

    pMesh->SetMaterialData(dwMaterial, &mtrl, strTexture);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT ParseMeshMaterialList(LPDIRECTXFILEDATA pFileData,
                               CD3DFileObject* pMesh)
{
    LPDIRECTXFILEOBJECT        pChildObj;
    LPDIRECTXFILEDATA          pChildData;
    LPDIRECTXFILEDATAREFERENCE pChildDataRef;
    DWORD                      dwMaterial = 0;

    while(SUCCEEDED(pFileData->GetNextObject(&pChildObj)))
    {
        if (SUCCEEDED(pChildObj->QueryInterface(IID_IDirectXFileData,
                                                    (VOID**)&pChildData)))
        {
            const GUID* pguid;
            pChildData->GetType(&pguid);

            if (TID_D3DRMMaterial == *pguid)
            {
                ParseMaterial(pChildData, pMesh, dwMaterial++);
            }

            pChildData->Release();
        }

        if (SUCCEEDED(pChildObj->QueryInterface(IID_IDirectXFileDataReference,
                                                    (VOID**)&pChildDataRef)))
        {
            if (SUCCEEDED(pChildDataRef->Resolve(&pChildData)))
            {
                const GUID* pguid;
                pChildData->GetType(&pguid);

                if (TID_D3DRMMaterial == *pguid)
                {
                    ParseMaterial(pChildData, pMesh, dwMaterial++);
                }

                pChildData->Release();
            }
            pChildDataRef->Release();
        }

        pChildObj->Release();
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT ParseMesh(LPDIRECTXFILEDATA pFileData, CD3DFileObject* pParentFrame)
{
    DWORD dwNameLen=80;
    CHAR strName[80];
    TCHAR szName[80];

    if (FAILED(pFileData->GetName(strName, &dwNameLen)))
        return E_FAIL;

    // Read the Mesh data from the file
    LONG_PTR  pData;
    DWORD dwSize;

    SHAnsiToUnicode(strName, szName, ARRAYSIZE(szName));
    if (FAILED(pFileData->GetData(NULL, &dwSize, (VOID**)&pData)))
        return E_FAIL;

    DWORD      dwNumVertices =    *((DWORD*)pData); pData += 4;
    D3DVECTOR* pVertices     = ((D3DVECTOR*)pData); pData += 12*dwNumVertices;
    DWORD      dwNumFaces    =    *((DWORD*)pData); pData += 4;
    DWORD*     pFaceData     =      (DWORD*)pData;

    // Create the Mesh object
    CD3DFileObject* pMesh = new CD3DFileObject(szName);
    pMesh->SetMeshGeometry(pVertices, dwNumVertices, pFaceData, dwNumFaces);

    BOOL bHasNormals = FALSE;
    BOOL bHasMaterials = FALSE;

    // Enumerate child objects.
    LPDIRECTXFILEOBJECT pChildObj;
    while(SUCCEEDED(pFileData->GetNextObject(&pChildObj)))
    {
        LPDIRECTXFILEDATA pChildData;

        if (SUCCEEDED(pChildObj->QueryInterface(IID_IDirectXFileData,
                                                  (VOID**)&pChildData)))
        {
            const GUID* pGUID;
            LONG_PTR    pData;
            DWORD       dwSize;

            pChildData->GetType(&pGUID);
            if (FAILED(pChildData->GetData(NULL, &dwSize, (VOID**)&pData)))
            {
                delete pMesh;
                return NULL;
            }

            if (TID_D3DRMMeshMaterialList == *pGUID)
            {
                DWORD  dwNumMaterials = *((DWORD*)pData);   pData += 4;
                DWORD  dwNumMatFaces  = *((DWORD*)pData);   pData += 4;
                DWORD* pMatFace       =   (DWORD*)pData;

                if (dwNumMaterials == 1 || dwNumMatFaces != dwNumFaces)
                {
                    // Only one material add all faces at once
                    pMesh->AddFace(0, pFaceData, dwNumFaces);
                }
                else
                {
                    // Multiple materials, add in sorted order
                    for(DWORD mat=0; mat<dwNumMaterials; mat++)
                    {
                        for(DWORD face=0; face<dwNumMatFaces; face++)
                        {
                            if (pMatFace[face] == mat)
                                pMesh->AddFace(mat, GetFace(pFaceData, face), 1);
                        }
                    }
                }

                ParseMeshMaterialList(pChildData, pMesh);
                bHasMaterials = TRUE;
            }

            if (TID_D3DRMMeshNormals == *pGUID)
            {
                DWORD      dwNumNormals = *((DWORD*)pData);
                D3DVECTOR* pNormals     = (D3DVECTOR*)(pData+4);

                if (dwNumNormals == dwNumVertices)
                {
                    pMesh->SetNormals(pNormals);
                    bHasNormals = TRUE;
                }
            }

            if (TID_D3DRMMeshTextureCoords == *pGUID)
            {
                // Copy the texture coords into the mesh's vertices
                DWORD  dwNumTexCoords = *((DWORD*)pData);
                FLOAT* pTexCoords     = (FLOAT*)(((FLOAT*)pData)+4);

                if (dwNumTexCoords == dwNumVertices)
                    pMesh->SetTextureCoords(pTexCoords);
            }

            pChildData->Release();
        }

        pChildObj->Release();
    }

    if (FALSE == bHasMaterials)
        pMesh->AddFace(0, pFaceData, dwNumFaces);

    if (FALSE == bHasNormals)
        pMesh->ComputeNormals();

    pParentFrame->AddChild(pMesh);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc:
//-----------------------------------------------------------------------------
HRESULT ParseFrame(LPDIRECTXFILEDATA pFileData, CD3DFileObject* pParentFrame)
{
    DWORD dwNameLen=80;
    CHAR strName[80];
    TCHAR szName[80];

    if (FAILED(pFileData->GetName(strName, &dwNameLen)))
        return E_FAIL;

    SHAnsiToUnicode(strName, szName, ARRAYSIZE(szName));
    CD3DFileObject* pFrame = new CD3DFileObject(szName);

    // Enumerate child objects.
    LPDIRECTXFILEOBJECT pChildObj;
    while(SUCCEEDED(pFileData->GetNextObject(&pChildObj)))
    {
        LPDIRECTXFILEDATA pChildData;
        if (SUCCEEDED(pChildObj->QueryInterface(IID_IDirectXFileData,
                            (VOID**)&pChildData)))
        {
            const GUID* pGUID;
            pChildData->GetType(&pGUID);

            if (TID_D3DRMFrame == *pGUID)
                ParseFrame(pChildData, pFrame);

            if (TID_D3DRMMesh == *pGUID)
                ParseMesh(pChildData, pFrame);

            if (TID_D3DRMFrameTransformMatrix == *pGUID)
            {
                DWORD dwSize;
                VOID* pData;
                if (FAILED(pChildData->GetData(NULL, &dwSize, &pData)))
                {
                    delete pFrame;
                    return NULL;
                }

                if (dwSize == sizeof(D3DMATRIX))
                {
                    // Convert from a left- to a right-handed cordinate system
                    D3DMATRIX* pmatFrame = (D3DMATRIX*)pData;
                    pmatFrame->_13 *= -1.0f;
                    pmatFrame->_31 *= -1.0f;
                    pmatFrame->_23 *= -1.0f;
                    pmatFrame->_32 *= -1.0f;
                    pmatFrame->_43 *= -1.0f;
                    pFrame->SetMatrix(pmatFrame);
                }
            }

            pChildData->Release();
        }

        pChildObj->Release();
    }

    pParentFrame->AddChild(pFrame);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CD3DFile()
// Desc: Class constructor
//-----------------------------------------------------------------------------
CD3DFile::CD3DFile()
{
    m_pRoot = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFile()
// Desc: Class destructor
//-----------------------------------------------------------------------------
CD3DFile::~CD3DFile()
{
    SAFE_DELETE(m_pRoot);
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Loads a .X geometry file, and creates a hierarchy of frames and meshes
//       to represent the geometry in that file.
//-----------------------------------------------------------------------------
HRESULT CD3DFile::Load(LPCTSTR pszFilename)
{
    HRESULT                 hr;
    LPDIRECTXFILE           pDXFile;
    LPDIRECTXFILEENUMOBJECT pEnumObj = NULL;
    LPDIRECTXFILEDATA       pFileData;
    const GUID*             pGUID;
    CD3DFileObject*         pFrame = NULL;
    CHAR szFilename[MAX_PATH];

    SHTCharToAnsi(pszFilename, szFilename, ARRAYSIZE(szFilename));
    // Cleanup any existing object
    SAFE_DELETE(m_pRoot);

    // Create the file object, and register the D3DRM templates for .X files
    if (FAILED(DirectXFileCreate(&pDXFile)))
        return E_FAIL;
    if (FAILED(pDXFile->RegisterTemplates((VOID*)D3DRM_XTEMPLATES,
                                            D3DRM_XTEMPLATE_BYTES)))
    {
        pDXFile->Release();
        return E_FAIL;
    }

    // Create an enumerator object, to enumerate through the .X file objects.
    // This will open the file in the current directory.
    hr = pDXFile->CreateEnumObject(szFilename, DXFILELOAD_FROMFILE, &pEnumObj);
    if (FAILED(hr))
    {
        CHAR szPath[MAX_PATH];

        GetCurrentDirectoryA(ARRAYSIZE(szPath), szPath);
        PathAppendA(szPath, szFilename);
        hr = pDXFile->CreateEnumObject(szPath, DXFILELOAD_FROMFILE, &pEnumObj);
        if (FAILED(hr))
        {
            pDXFile->Release();
            return hr;
        }
    }

    // Create a root object for the X file object
    m_pRoot = new CD3DFileObject(TEXT("D3DFile_Root"));

    // Cycle through each object. Parse meshes and frames as appropriate
    while(SUCCEEDED(hr = pEnumObj->GetNextDataObject(&pFileData)))
    {
        pFileData->GetType(&pGUID);

        if (*pGUID == TID_D3DRMFrame)
            ParseFrame(pFileData, m_pRoot);

        if (*pGUID == TID_D3DRMMesh)
            ParseMesh(pFileData, m_pRoot);

        pFileData->Release();
    }

    // Success will result in hr == DXFILEERR_NOMOREOBJECTS
    if (DXFILEERR_NOMOREOBJECTS == hr) 
        hr = S_OK;
    else
        SAFE_DELETE(m_pRoot);

    pEnumObj->Release();
    pDXFile->Release();

    return hr;
}




//-----------------------------------------------------------------------------
// Name: GetMeshVertices()
// Desc: Traverse the hierarchy of frames and meshes that make up the file
//       object, and retrieves the vertices for the specified mesh.
//-----------------------------------------------------------------------------
HRESULT CD3DFile::GetMeshVertices(TCHAR* strName, D3DVERTEX** ppVertices,
                                   DWORD* pdwNumVertices)
{
    CD3DFileObject* pObject = FindObject(strName);
    if (pObject)
        return pObject->GetMeshGeometry(ppVertices, pdwNumVertices, NULL, NULL);

    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: GetMeshVertices()
// Desc: Traverse the hierarchy of frames and meshes that make up the file
//       object, and retrieves the vertices for the specified mesh.
//-----------------------------------------------------------------------------
HRESULT CD3DFile::GetMeshIndices(TCHAR* strName, WORD** ppIndices,
                                  DWORD* pdwNumIndices)
{
    CD3DFileObject* pObject = FindObject(strName);
    if (pObject)
        return pObject->GetMeshGeometry(NULL, NULL, ppIndices, pdwNumIndices);

    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: EnumObjects()
// Desc: Enumerates all objects in the file.
//-----------------------------------------------------------------------------
BOOL CD3DFileObject::EnumObjects(BOOL (*fnCallback)(CD3DFileObject*,D3DMATRIX*,VOID*),
                                  D3DMATRIX* pmat, VOID* pContext)
{
    if (fnCallback(this, pmat, pContext) == TRUE)
        return TRUE;

    if (m_pChild)
    {
        // Concat matrix set
        D3DMATRIX matSave = (*pmat);
        (*pmat) = (*pmat) * m_mat;
    
        if (m_pChild->EnumObjects(fnCallback, pmat, pContext) == TRUE)
            return TRUE;

        // Restore matrix set
        (*pmat) = matSave;
    }

    if (m_pNext)
        if (m_pNext->EnumObjects(fnCallback, pmat, pContext) == TRUE)
            return TRUE;

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: EnumObjects()
// Desc: Enumerates all objects in the file.
//-----------------------------------------------------------------------------
VOID CD3DFile::EnumObjects(BOOL (*fnCallback)(CD3DFileObject*,D3DMATRIX*,VOID*),
                            D3DMATRIX* pmat, VOID* pContext)
{
    if (m_pRoot)
    {
        D3DMATRIX mat;

        if (pmat)
            mat = *pmat;
        else
            D3DUtil_SetIdentityMatrix(mat);

        m_pRoot->EnumObjects(fnCallback, &mat, pContext);
    }
}




//-----------------------------------------------------------------------------
// Name: ScaleMeshCB()
// Desc: Callback to scale a mesh
//-----------------------------------------------------------------------------
BOOL ScaleMeshCB(CD3DFileObject* pFileObject, D3DMATRIX*, VOID* pContext)
{
    D3DVERTEX* pVertices;
    DWORD      dwNumVertices;

    if (SUCCEEDED(pFileObject->GetMeshGeometry(&pVertices, &dwNumVertices,
                                                 NULL, NULL)))
    {
        for(DWORD i=0; i<dwNumVertices; i++)
        {
            pVertices[i].x *= (*((FLOAT*)pContext));
            pVertices[i].y *= (*((FLOAT*)pContext));
            pVertices[i].z *= (*((FLOAT*)pContext));
        }
    }

    // Keep enumerating
    return FALSE;
}



//-----------------------------------------------------------------------------
// Name: FindMeshCB()
// Desc: Callback to scale a mesh
//-----------------------------------------------------------------------------
BOOL FindMeshCB(CD3DFileObject* pFileObject, D3DMATRIX*, VOID* pContext)
{
    struct FINDMESHRECORD
    {
        TCHAR*          strName;
        CD3DFileObject* pObject;
    };

    FINDMESHRECORD* data = (FINDMESHRECORD*)pContext;
    
    if (0 == lstrcmpi(data->strName, pFileObject->GetName()))
    {
        data->pObject = pFileObject;
        return TRUE;
    }

    // Keep enumerating
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Scale()
// Desc: Scales all meshes in the file
//-----------------------------------------------------------------------------
VOID CD3DFile::Scale(FLOAT fScale)
{
    EnumObjects(ScaleMeshCB, NULL, (VOID*)&fScale);
}




//-----------------------------------------------------------------------------
// Name: FindObject()
// Desc: Searches all meshes in file object and returns named mesh
//-----------------------------------------------------------------------------
CD3DFileObject* CD3DFile::FindObject(TCHAR* strName)
{
    if (NULL == strName)
        return m_pRoot;

    struct FINDMESHRECORD
    {
        TCHAR*          strName;
        CD3DFileObject* pObject;
    };

    FINDMESHRECORD data = { strName, NULL };

    EnumObjects(FindMeshCB, NULL, (VOID*)&data);
    return data.pObject;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes that make up the file
//       object
//-----------------------------------------------------------------------------
HRESULT CD3DFile::Render(LPDIRECT3DDEVICE7 pd3dDevice)
{
    LPDIRECTDRAWSURFACE7 pddsSavedTexture;
    D3DMATRIX    matSaved;
    D3DMATERIAL7 mtrlSaved;
    DWORD        dwAlphaState, dwSrcBlendState, dwDestBlendState;

    if (m_pRoot)
    {
        // State render states that will be overwritten
        pd3dDevice->GetMaterial(&mtrlSaved);
        pd3dDevice->GetTexture(0, &pddsSavedTexture);
        pd3dDevice->GetTransform(D3DTRANSFORMSTATE_WORLD, &matSaved);
        pd3dDevice->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &dwAlphaState);
        pd3dDevice->GetRenderState(D3DRENDERSTATE_SRCBLEND,  &dwSrcBlendState);
        pd3dDevice->GetRenderState(D3DRENDERSTATE_DESTBLEND, &dwDestBlendState);

        // Render the opaque file object's hierarchy of frames and meshes
        m_pRoot->Render(pd3dDevice, FALSE);

        // Render the transparent file object's hierarchy of frames and meshes
//        pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);
//        pd3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,  D3DBLEND_SRCALPHA);
//        pd3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_INVSRCALPHA);
//        m_pRoot->Render(pd3dDevice, TRUE);

        // Restore the render states
        pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, dwAlphaState);
        pd3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,  dwSrcBlendState);
        pd3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND, dwDestBlendState);
        pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &matSaved);
        pd3dDevice->SetTexture(0, pddsSavedTexture);
        pd3dDevice->SetMaterial(&mtrlSaved);

        // Keep the ref count of the texture consistent
        if (pddsSavedTexture)
            pddsSavedTexture->Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dframe.h ===
//-----------------------------------------------------------------------------
// File: D3DFrame.h
//
// Desc: Class to manage the Direct3D environment objects such as buffers,
//       viewports, and 3D devices.
//
//       The class is initialized with the Initialize() function, after which
//       the Get????() functions can be used to access the objects needed for
//       rendering. If the device or display needs to be changed, the
//       ChangeDevice() function can be called. If the display window is moved
//       the changes need to be reported with the Move() function.
//
//       After rendering a frame, the ShowFrame() function filps or blits the
//       backbuffer contents to the primary. If surfaces are lost, they can be
//       restored with the RestoreSurfaces() function. Finally, if normal
//       Windows output is needed, the FlipToGDISurface() provides a GDI
//       surface to draw on.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DFRAME_H
#define D3DFRAME_H
#include <ddraw.h>
#include <d3d.h>




//-----------------------------------------------------------------------------
// Name: CD3DFramework7
// Desc: The Direct3D sample framework class for DX7. Maintains the D3D
//       surfaces and device used for 3D rendering.
//-----------------------------------------------------------------------------
class CD3DFramework7
{
    // Internal variables for the framework class
    HWND                 m_hWnd;               // The window object
    BOOL                 m_bIsFullscreen;      // Fullscreen vs. windowed
    BOOL                 m_bIsStereo;          // Stereo view mode
    DWORD                m_dwRenderWidth;      // Dimensions of the render target
    DWORD                m_dwRenderHeight;
    RECT                 m_rcScreenRect;       // Screen rect for window
    LPDIRECTDRAW7        m_pDD;                // The DirectDraw object
    LPDIRECT3D7          m_pD3D;               // The Direct3D object
    LPDIRECT3DDEVICE7    m_pd3dDevice;         // The D3D device
    LPDIRECTDRAWSURFACE7 m_pddsFrontBuffer;    // The primary surface
    LPDIRECTDRAWSURFACE7 m_pddsBackBuffer;     // The backbuffer surface
    LPDIRECTDRAWSURFACE7 m_pddsBackBufferLeft; // For stereo modes
    LPDIRECTDRAWSURFACE7 m_pddsZBuffer;        // The zbuffer surface
    DWORD                m_dwDeviceMemType;

    // Internal functions for the framework class
    HRESULT CreateZBuffer(GUID*);
    HRESULT CreateFullscreenBuffers(DDSURFACEDESC2*);
    HRESULT CreateWindowedBuffers();
    HRESULT CreateDirectDraw(GUID*, DWORD);
    HRESULT CreateDirect3D(GUID*);
    HRESULT CreateEnvironment(GUID*, GUID*, DDSURFACEDESC2*, DWORD);

public:
    // Access functions for DirectX objects
    LPDIRECTDRAW7        GetDirectDraw()        { return m_pDD; }
    LPDIRECT3D7          GetDirect3D()          { return m_pD3D; }
    LPDIRECT3DDEVICE7    GetD3DDevice()         { return m_pd3dDevice; }
    LPDIRECTDRAWSURFACE7 GetFrontBuffer()       { return m_pddsFrontBuffer; }
    LPDIRECTDRAWSURFACE7 GetBackBuffer()        { return m_pddsBackBuffer; }
    LPDIRECTDRAWSURFACE7 GetRenderSurface()     { return m_pddsBackBuffer; }
    LPDIRECTDRAWSURFACE7 GetRenderSurfaceLeft() { return m_pddsBackBufferLeft; }

    // Functions to aid rendering
    HRESULT RestoreSurfaces();
    HRESULT ShowFrame();
    HRESULT FlipToGDISurface(BOOL bDrawFrame = FALSE);

    // Functions for managing screen and viewport bounds
    BOOL    IsFullscreen()                  { return m_bIsFullscreen; }
    BOOL    IsStereo()                      { return m_bIsStereo; }
    VOID    Move(INT x, INT y);

    // Creates the Framework
    HRESULT Initialize(HWND hWnd, GUID* pDriverGUID, GUID* pDeviceGUID,
                        DDSURFACEDESC2* pddsd, DWORD dwFlags);
    HRESULT DestroyObjects();

            CD3DFramework7();
           ~CD3DFramework7();
};




//-----------------------------------------------------------------------------
// Flags used for the Initialize() method of a CD3DFramework object
//-----------------------------------------------------------------------------
#define D3DFW_FULLSCREEN    0x00000001 // Use fullscreen mode
#define D3DFW_STEREO        0x00000002 // Use stereo-scopic viewing
#define D3DFW_ZBUFFER       0x00000004 // Create and use a zbuffer
#define D3DFW_NO_FPUSETUP   0x00000008 // Don't use default DDSCL_FPUSETUP flag




//-----------------------------------------------------------------------------
// Errors that the Initialize() and ChangeDriver() calls may return
//-----------------------------------------------------------------------------
#define D3DFWERR_INITIALIZATIONFAILED 0x82000000
#define D3DFWERR_NODIRECTDRAW         0x82000001
#define D3DFWERR_COULDNTSETCOOPLEVEL  0x82000002
#define D3DFWERR_NODIRECT3D           0x82000003
#define D3DFWERR_NO3DDEVICE           0x82000004
#define D3DFWERR_NOZBUFFER            0x82000005
#define D3DFWERR_INVALIDZBUFFERDEPTH  0x82000006
#define D3DFWERR_NOVIEWPORT           0x82000007
#define D3DFWERR_NOPRIMARY            0x82000008
#define D3DFWERR_NOCLIPPER            0x82000009
#define D3DFWERR_BADDISPLAYMODE       0x8200000a
#define D3DFWERR_NOBACKBUFFER         0x8200000b
#define D3DFWERR_NONZEROREFCOUNT      0x8200000c
#define D3DFWERR_NORENDERTARGET       0x8200000d
#define D3DFWERR_INVALIDMODE          0x8200000e
#define D3DFWERR_NOTINITIALIZED       0x8200000f


#endif // D3DFRAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dres.h ===
//-----------------------------------------------------------------------------
// File: D3DRes.h
//
// Desc: Resource definitions required by the CD3DApplication class.
//       Any application using the CD3DApplication class must include resources
//       with the following identifiers.
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DRES_H
#define D3DRES_H


#define IDI_MAIN_ICON          101 // Application icon
#define IDR_MAIN_ACCEL         113 // Keyboard accelerator
#define IDR_MENU               141 // Application menu
#define IDR_POPUP              142 // Popup menu
#define IDD_ABOUT              143 // About dialog box
#define IDD_CHANGEDEVICE       144 // "Change Device" dialog box

#define IDC_DEVICE_COMBO      1000 // Device combobox for "Change Device" dlg
#define IDC_MODE_COMBO        1001 // Mode combobox for "Change Device" dlg
#define IDC_WINDOWED_CHECKBOX 1012 // Checkbox for windowed-mode
#define IDC_STEREO_CHECKBOX   1013 // Checkbox for stereo modes
#define IDC_FULLSCREEN_TEXT   1014 // Group box text label

#define IDM_ABOUT            40001 // Command to invoke About dlg
#define IDM_CHANGEDEVICE     40002 // Command to invoke "Change Device" dlg
#define IDM_TOGGLEFULLSCREEN 40003 // Command to toggle fullscreen mode
#define IDM_TOGGLESTART      40004 // Command to toggle frame animation
#define IDM_SINGLESTEP       40005 // Command to single step frame animation
#define IDM_EXIT             40006 // Command to exit the application




#endif // D3DRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dmath.cpp ===
//-----------------------------------------------------------------------------
// File: D3DMath.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define D3D_OVERLOADS
#define STRICT

#include "StdAfx.h"

#include <math.h>
#include "D3DMath.h"




//-----------------------------------------------------------------------------
// Name: D3DMath_MatrixMultiply()
// Desc: Does the matrix operation: [Q] = [A] * [B]. Note that the order of
//       this operation was changed from the previous version of the DXSDK.
//-----------------------------------------------------------------------------
VOID D3DMath_MatrixMultiply(D3DMATRIX& q, D3DMATRIX& a, D3DMATRIX& b)
{
    FLOAT* pA = (FLOAT*)&a;
    FLOAT* pB = (FLOAT*)&b;
    FLOAT  pM[16];

    ZeroMemory(pM, sizeof(D3DMATRIX));

    for(WORD i=0; i<4; i++) 
        for(WORD j=0; j<4; j++) 
            for(WORD k=0; k<4; k++) 
                pM[4*i+j] +=  pA[4*i+k] * pB[4*k+j];

    memcpy(&q, pM, sizeof(D3DMATRIX));
}




//-----------------------------------------------------------------------------
// Name: D3DMath_MatrixInvert()
// Desc: Does the matrix operation: [Q] = inv[A]. Note: this function only
//       works for matrices with [0 0 0 1] for the 4th column.
//-----------------------------------------------------------------------------
HRESULT D3DMath_MatrixInvert(D3DMATRIX& q, D3DMATRIX& a)
{
    if (fabs(a._44 - 1.0f) > .001f)
        return E_INVALIDARG;
    if (fabs(a._14) > .001f || fabs(a._24) > .001f || fabs(a._34) > .001f)
        return E_INVALIDARG;

    FLOAT fDetInv = 1.0f / (a._11 * (a._22 * a._33 - a._23 * a._32) -
                             a._12 * (a._21 * a._33 - a._23 * a._31) +
                             a._13 * (a._21 * a._32 - a._22 * a._31));

    q._11 =  fDetInv * (a._22 * a._33 - a._23 * a._32);
    q._12 = -fDetInv * (a._12 * a._33 - a._13 * a._32);
    q._13 =  fDetInv * (a._12 * a._23 - a._13 * a._22);
    q._14 = 0.0f;

    q._21 = -fDetInv * (a._21 * a._33 - a._23 * a._31);
    q._22 =  fDetInv * (a._11 * a._33 - a._13 * a._31);
    q._23 = -fDetInv * (a._11 * a._23 - a._13 * a._21);
    q._24 = 0.0f;

    q._31 =  fDetInv * (a._21 * a._32 - a._22 * a._31);
    q._32 = -fDetInv * (a._11 * a._32 - a._12 * a._31);
    q._33 =  fDetInv * (a._11 * a._22 - a._12 * a._21);
    q._34 = 0.0f;

    q._41 = -(a._41 * q._11 + a._42 * q._21 + a._43 * q._31);
    q._42 = -(a._41 * q._12 + a._42 * q._22 + a._43 * q._32);
    q._43 = -(a._41 * q._13 + a._42 * q._23 + a._43 * q._33);
    q._44 = 1.0f;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_VectorMatrixMultiply()
// Desc: Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
HRESULT D3DMath_VectorMatrixMultiply(D3DVECTOR& vDest, D3DVECTOR& vSrc,
                                      D3DMATRIX& mat)
{
    FLOAT x = vSrc.x*mat._11 + vSrc.y*mat._21 + vSrc.z* mat._31 + mat._41;
    FLOAT y = vSrc.x*mat._12 + vSrc.y*mat._22 + vSrc.z* mat._32 + mat._42;
    FLOAT z = vSrc.x*mat._13 + vSrc.y*mat._23 + vSrc.z* mat._33 + mat._43;
    FLOAT w = vSrc.x*mat._14 + vSrc.y*mat._24 + vSrc.z* mat._34 + mat._44;
    
    if (fabs(w) < g_EPSILON)
        return E_INVALIDARG;

    vDest.x = x/w;
    vDest.y = y/w;
    vDest.z = z/w;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_VertexMatrixMultiply()
// Desc: Multiplies a vertex by a matrix
//-----------------------------------------------------------------------------
HRESULT D3DMath_VertexMatrixMultiply(D3DVERTEX& vDest, D3DVERTEX& vSrc,
                                      D3DMATRIX& mat)
{
    HRESULT    hr;
    D3DVECTOR* pSrcVec  = (D3DVECTOR*)&vSrc.x;
    D3DVECTOR* pDestVec = (D3DVECTOR*)&vDest.x;

    if (SUCCEEDED(hr = D3DMath_VectorMatrixMultiply(*pDestVec, *pSrcVec,
                                                      mat)))
    {
        pSrcVec  = (D3DVECTOR*)&vSrc.nx;
        pDestVec = (D3DVECTOR*)&vDest.nx;
        hr = D3DMath_VectorMatrixMultiply(*pDestVec, *pSrcVec, mat);
    }
    return hr;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_QuaternionFromRotation()
// Desc: Converts a normalized axis and angle to a unit quaternion.
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionFromRotation(FLOAT& x, FLOAT& y, FLOAT& z, FLOAT& w,
                                     D3DVECTOR& v, FLOAT fTheta)
{
    x = sinf(fTheta/2.0f) * v.x;
    y = sinf(fTheta/2.0f) * v.y;
    z = sinf(fTheta/2.0f) * v.z;
    w = cosf(fTheta/2.0f);
}




//-----------------------------------------------------------------------------
// Name: D3DMath_RotationFromQuaternion()
// Desc: Converts a normalized axis and angle to a unit quaternion.
//-----------------------------------------------------------------------------
VOID D3DMath_RotationFromQuaternion(D3DVECTOR& v, FLOAT& fTheta,
                                     FLOAT x, FLOAT y, FLOAT z, FLOAT w)
                                      
{
    fTheta = acosf(w) * 2.0f;
    v.x    = x / sinf(fTheta/2.0f);
    v.y    = y / sinf(fTheta/2.0f);
    v.z    = z / sinf(fTheta/2.0f);
}




//-----------------------------------------------------------------------------
// Name: D3DMath_QuaternionFromAngles()
// Desc: Converts euler angles to a unit quaternion.
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionFromAngles(FLOAT& x, FLOAT& y, FLOAT& z, FLOAT& w,
                                   FLOAT fYaw, FLOAT fPitch, FLOAT fRoll)
                                        
{
    FLOAT fSinYaw   = sinf(fYaw/2.0f);
    FLOAT fSinPitch = sinf(fPitch/2.0f);
    FLOAT fSinRoll  = sinf(fRoll/2.0f);
    FLOAT fCosYaw   = cosf(fYaw/2.0f);
    FLOAT fCosPitch = cosf(fPitch/2.0f);
    FLOAT fCosRoll  = cosf(fRoll/2.0f);

    x = fSinRoll * fCosPitch * fCosYaw - fCosRoll * fSinPitch * fSinYaw;
    y = fCosRoll * fSinPitch * fCosYaw + fSinRoll * fCosPitch * fSinYaw;
    z = fCosRoll * fCosPitch * fSinYaw - fSinRoll * fSinPitch * fCosYaw;
    w = fCosRoll * fCosPitch * fCosYaw + fSinRoll * fSinPitch * fSinYaw;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_MatrixFromQuaternion()
// Desc: Converts a unit quaternion into a rotation matrix.
//-----------------------------------------------------------------------------
VOID D3DMath_MatrixFromQuaternion(D3DMATRIX& mat, FLOAT x, FLOAT y, FLOAT z,
                                   FLOAT w)
{
    FLOAT xx = x*x; FLOAT yy = y*y; FLOAT zz = z*z;
    FLOAT xy = x*y; FLOAT xz = x*z; FLOAT yz = y*z;
    FLOAT wx = w*x; FLOAT wy = w*y; FLOAT wz = w*z;
    
    mat._11 = 1 - 2 * (yy + zz); 
    mat._12 =     2 * (xy - wz);
    mat._13 =     2 * (xz + wy);

    mat._21 =     2 * (xy + wz);
    mat._22 = 1 - 2 * (xx + zz);
    mat._23 =     2 * (yz - wx);

    mat._31 =     2 * (xz - wy);
    mat._32 =     2 * (yz + wx);
    mat._33 = 1 - 2 * (xx + yy);

    mat._14 = mat._24 = mat._34 = 0.0f;
    mat._41 = mat._42 = mat._43 = 0.0f;
    mat._44 = 1.0f;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_QuaternionFromMatrix()
// Desc: Converts a rotation matrix into a unit quaternion.
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionFromMatrix(FLOAT& x, FLOAT& y, FLOAT& z, FLOAT& w,
                                   D3DMATRIX& mat)
{
    if (mat._11 + mat._22 + mat._33 > 0.0f)
    {
        FLOAT s = sqrtf(mat._11 + mat._22 + mat._33 + mat._44);

        x = (mat._23-mat._32) / (2*s);
        y = (mat._31-mat._13) / (2*s);
        z = (mat._12-mat._21) / (2*s);
        w = 0.5f * s;
    }
    else
    {


    }
    FLOAT xx = x*x; FLOAT yy = y*y; FLOAT zz = z*z;
    FLOAT xy = x*y; FLOAT xz = x*z; FLOAT yz = y*z;
    FLOAT wx = w*x; FLOAT wy = w*y; FLOAT wz = w*z;
    
    mat._11 = 1 - 2 * (yy + zz); 
    mat._12 =     2 * (xy - wz);
    mat._13 =     2 * (xz + wy);

    mat._21 =     2 * (xy + wz);
    mat._22 = 1 - 2 * (xx + zz);
    mat._23 =     2 * (yz - wx);

    mat._31 =     2 * (xz - wy);
    mat._32 =     2 * (yz + wx);
    mat._33 = 1 - 2 * (xx + yy);

    mat._14 = mat._24 = mat._34 = 0.0f;
    mat._41 = mat._42 = mat._43 = 0.0f;
    mat._44 = 1.0f;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_QuaternionMultiply()
// Desc: Mulitples two quaternions together as in {Q} = {A} * {B}.
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionMultiply(FLOAT& Qx, FLOAT& Qy, FLOAT& Qz, FLOAT& Qw,
                                  FLOAT Ax, FLOAT Ay, FLOAT Az, FLOAT Aw,
                                  FLOAT Bx, FLOAT By, FLOAT Bz, FLOAT Bw)
{
    FLOAT Dx =  Ax*Bw + Ay*Bz - Az*By + Aw*Bx;
    FLOAT Dy = -Ax*Bz + Ay*Bw + Az*Bx + Aw*By;
    FLOAT Dz =  Ax*By - Ay*Bx + Az*Bw + Aw*Bz;
    FLOAT Dw = -Ax*Bx - Ay*By - Az*Bz + Aw*Bw;

    Qx = Dx; Qy = Dy; Qz = Dz; Qw = Dw;
}




//-----------------------------------------------------------------------------
// Name: D3DMath_SlerpQuaternions()
// Desc: Compute a quaternion which is the spherical linear interpolation
//       between two other quaternions by dvFraction.
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionSlerp(FLOAT& Qx, FLOAT& Qy, FLOAT& Qz, FLOAT& Qw,
                              FLOAT Ax, FLOAT Ay, FLOAT Az, FLOAT Aw,
                              FLOAT Bx, FLOAT By, FLOAT Bz, FLOAT Bw,
                              FLOAT fAlpha)
{
    // Compute dot product (equal to cosine of the angle between quaternions)
    FLOAT fCosTheta = Ax*Bx + Ay*By + Az*Bz + Aw*Bw;

    // Check angle to see if quaternions are in opposite hemispheres
    if (fCosTheta < 0.0f) 
    {
        // If so, flip one of the quaterions
        fCosTheta = -fCosTheta;
        Bx = -Bx; By = -By; Bz = -Bz; Bw = -Bw;
    }

    // Set factors to do linear interpolation, as a special case where the
    // quaternions are close together.
    FLOAT fBeta = 1.0f - fAlpha;
    
    // If the quaternions aren't close, proceed with spherical interpolation
    if (1.0f - fCosTheta > 0.001f) 
    {   
        FLOAT fTheta = acosf(fCosTheta);
        
        fBeta  = sinf(fTheta*fBeta) / sinf(fTheta);
        fAlpha = sinf(fTheta*fAlpha) / sinf(fTheta);
    }

    // Do the interpolation
    Qx = fBeta*Ax + fAlpha*Bx;
    Qy = fBeta*Ay + fAlpha*By;
    Qz = fBeta*Az + fAlpha*Bz;
    Qw = fBeta*Aw + fAlpha*Bw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dmath.h ===
//-----------------------------------------------------------------------------
// File: D3DMath.h
//
// Desc: Math functions and shortcuts for Direct3D programming.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DMATH_H
#define D3DMATH_H
#include <ddraw.h>
#include <d3d.h>


//-----------------------------------------------------------------------------
// Useful Math constants
//-----------------------------------------------------------------------------
const FLOAT g_PI       =  3.14159265358979323846f; // Pi
const FLOAT g_2_PI     =  6.28318530717958623200f; // 2 * Pi
const FLOAT g_PI_DIV_2 =  1.57079632679489655800f; // Pi / 2
const FLOAT g_PI_DIV_4 =  0.78539816339744827900f; // Pi / 4
const FLOAT g_INV_PI   =  0.31830988618379069122f; // 1 / Pi
const FLOAT g_DEGTORAD =  0.01745329251994329547f; // Degrees to Radians
const FLOAT g_RADTODEG = 57.29577951308232286465f; // Radians to Degrees
const FLOAT g_HUGE     =  1.0e+38f;                // Huge number for FLOAT
const FLOAT g_EPSILON  =  1.0e-5f;                 // Tolerance for FLOATs




//-----------------------------------------------------------------------------
// Fuzzy compares (within tolerance)
//-----------------------------------------------------------------------------
inline BOOL D3DMath_IsZero(FLOAT a, FLOAT fTol = g_EPSILON)
{ return (a <= 0.0f) ? (a >= -fTol) : (a <= fTol); }




//-----------------------------------------------------------------------------
// Matrix functions
//-----------------------------------------------------------------------------
VOID    D3DMath_MatrixMultiply(D3DMATRIX& q, D3DMATRIX& a, D3DMATRIX& b);
HRESULT D3DMath_MatrixInvert(D3DMATRIX& q, D3DMATRIX& a);




//-----------------------------------------------------------------------------
// Vector functions
//-----------------------------------------------------------------------------
HRESULT D3DMath_VectorMatrixMultiply(D3DVECTOR& vDest, D3DVECTOR& vSrc,
                                      D3DMATRIX& mat);
HRESULT D3DMath_VertexMatrixMultiply(D3DVERTEX& vDest, D3DVERTEX& vSrc,
                                      D3DMATRIX& mat);




//-----------------------------------------------------------------------------
// Quaternion functions
//-----------------------------------------------------------------------------
VOID D3DMath_QuaternionFromRotation(FLOAT& x, FLOAT& y, FLOAT& z, FLOAT& w,
                                     D3DVECTOR& v, FLOAT fTheta);
VOID D3DMath_RotationFromQuaternion(D3DVECTOR& v, FLOAT& fTheta,
                                     FLOAT x, FLOAT y, FLOAT z, FLOAT w);
VOID D3DMath_QuaternionFromAngles(FLOAT& x, FLOAT& y, FLOAT& z, FLOAT& w,
                                   FLOAT fYaw, FLOAT fPitch, FLOAT fRoll);
VOID D3DMath_MatrixFromQuaternion(D3DMATRIX& mat, FLOAT x, FLOAT y, FLOAT z,
                                   FLOAT w);
VOID D3DMath_QuaternionFromMatrix(FLOAT &x, FLOAT &y, FLOAT &z, FLOAT &w,
                                   D3DMATRIX& mat);
VOID D3DMath_QuaternionMultiply(FLOAT& Qx, FLOAT& Qy, FLOAT& Qz, FLOAT& Qw,
                                 FLOAT Ax, FLOAT Ay, FLOAT Az, FLOAT Aw,
                                 FLOAT Bx, FLOAT By, FLOAT Bz, FLOAT Bw);
VOID D3DMath_QuaternionSlerp(FLOAT& Qx, FLOAT& Qy, FLOAT& Qz, FLOAT& Qw,
                              FLOAT Ax, FLOAT Ay, FLOAT Az, FLOAT Aw,
                              FLOAT Bx, FLOAT By, FLOAT Bz, FLOAT Bw,
                              FLOAT fAlpha);


#endif // D3DMATH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dtextr.cpp ===
//-----------------------------------------------------------------------------
// File: D3DTextr.cpp
//
// Desc: Functions to manage textures, including creating (loading from a
//       file), restoring lost surfaces, invalidating, and destroying.
//
//       Note: the implementation of these fucntions maintain an internal list
//       of loaded textures. After creation, individual textures are referenced
//       via their ASCII names.
//
// Copyright (c) 1996-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#include "stdafx.h"

#include "D3DTextr.h"
#include "D3DUtil.h"




//-----------------------------------------------------------------------------
// Macros, function prototypes and static variable
//-----------------------------------------------------------------------------
TCHAR g_strTexturePath[512]; // Path for files



//-----------------------------------------------------------------------------
// Name: TextureContainer
// Desc: Linked list structure to hold info per texture
//-----------------------------------------------------------------------------
struct TextureContainer
{
    TextureContainer* m_pNext; // Linked list ptr

    TCHAR   m_strName[80];     // Name of texture (doubles as image filename)
    DWORD   m_dwWidth;
    DWORD   m_dwHeight;
    DWORD   m_dwStage;         // Texture stage (for multitexture devices)
    DWORD   m_dwBPP;
    DWORD   m_dwFlags;
    BOOL    m_bHasAlpha;

    LPDIRECTDRAWSURFACE7 m_pddsSurface; // Surface of the texture
    HBITMAP m_hbmBitmap;       // Bitmap containing texture image
    DWORD*  m_pRGBAData;

public:
    HRESULT LoadImageData();
    HRESULT LoadBitmapFile(TCHAR* strPathname);
    HRESULT LoadTargaFile(TCHAR* strPathname);
    HRESULT Restore(LPDIRECT3DDEVICE7 pd3dDevice);
    HRESULT CopyBitmapToSurface();
    HRESULT CopyRGBADataToSurface();

    TextureContainer(TCHAR* strName, DWORD dwStage, DWORD dwFlags);
    ~TextureContainer();
};

// Local list of textures
static TextureContainer* g_ptcTextureList = NULL;



//-----------------------------------------------------------------------------
// Name: CD3DTextureManager
// Desc: Class used to automatically construct and destruct the static
//       texture engine class.
//-----------------------------------------------------------------------------
class CD3DTextureManager
{
public:
    CD3DTextureManager() {}
    ~CD3DTextureManager() { if (g_ptcTextureList) delete g_ptcTextureList; }
};

// Global instance
CD3DTextureManager g_StaticTextureEngine;



//-----------------------------------------------------------------------------
// Name: struct TEXTURESEARCHINFO
// Desc: Structure used to search for texture formats
//-----------------------------------------------------------------------------
struct TEXTURESEARCHINFO
{
    DWORD dwDesiredBPP;   // Input for texture format search
    BOOL  bUseAlpha;
    BOOL  bUsePalette;
    BOOL  bFoundGoodFormat;

    DDPIXELFORMAT* pddpf; // Output of texture format search
};




//-----------------------------------------------------------------------------
// Name: TextureSearchCallback()
// Desc: Enumeration callback routine to find a best-matching texture format.
//       The param data is the DDPIXELFORMAT of the best-so-far matching
//       texture. Note: the desired BPP is passed in the dwSize field, and the
//       default BPP is passed in the dwFlags field.
//-----------------------------------------------------------------------------
static HRESULT CALLBACK TextureSearchCallback(DDPIXELFORMAT* pddpf,
                                               VOID* param)
{
    if (NULL==pddpf || NULL==param)
        return DDENUMRET_OK;

    TEXTURESEARCHINFO* ptsi = (TEXTURESEARCHINFO*)param;

    // Skip any funky modes
    if (pddpf->dwFlags & (DDPF_LUMINANCE|DDPF_BUMPLUMINANCE|DDPF_BUMPDUDV))
        return DDENUMRET_OK;

    // Check for palettized formats
    if (ptsi->bUsePalette)
    {
        if (!(pddpf->dwFlags & DDPF_PALETTEINDEXED8))
            return DDENUMRET_OK;

        // Accept the first 8-bit palettized format we get
        memcpy(ptsi->pddpf, pddpf, sizeof(DDPIXELFORMAT));
        ptsi->bFoundGoodFormat = TRUE;
        return DDENUMRET_CANCEL;
    }

    // Else, skip any paletized formats (all modes under 16bpp)
    if (pddpf->dwRGBBitCount < 16)
        return DDENUMRET_OK;

    // Skip any FourCC formats
    if (pddpf->dwFourCC != 0)
        return DDENUMRET_OK;

    // Skip any ARGB 4444 formats (which are best used for pre-authored
    // content designed speciafically for an ARGB 4444 format).
    if (pddpf->dwRGBAlphaBitMask == 0x0000f000)
        return DDENUMRET_OK;

    // Make sure current alpha format agrees with requested format type
    if ((ptsi->bUseAlpha==TRUE) && !(pddpf->dwFlags&DDPF_ALPHAPIXELS))
        return DDENUMRET_OK;
    if ((ptsi->bUseAlpha==FALSE) && (pddpf->dwFlags&DDPF_ALPHAPIXELS))
        return DDENUMRET_OK;

    // Check if we found a good match
    if (pddpf->dwRGBBitCount == ptsi->dwDesiredBPP)
    {
        memcpy(ptsi->pddpf, pddpf, sizeof(DDPIXELFORMAT));
        ptsi->bFoundGoodFormat = TRUE;
        return DDENUMRET_CANCEL;
    }

    return DDENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: FindTexture()
// Desc: Searches the internal list of textures for a texture specified by
//       its name. Returns the structure associated with that texture.
//-----------------------------------------------------------------------------
static TextureContainer* FindTexture(TCHAR* strTextureName)
{
    TextureContainer* ptcTexture = g_ptcTextureList;

    while(ptcTexture)
    {
        if (!StrCmpI(strTextureName, ptcTexture->m_strName))
            return ptcTexture;
        ptcTexture = ptcTexture->m_pNext;
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: TextureContainer()
// Desc: Constructor for a texture object
//-----------------------------------------------------------------------------
TextureContainer::TextureContainer(TCHAR* strName, DWORD dwStage,
                                    DWORD dwFlags)
{
    lstrcpy(m_strName, strName);
    m_dwWidth     = 0;
    m_dwHeight    = 0;
    m_dwStage     = dwStage;
    m_dwBPP       = 0;
    m_dwFlags     = dwFlags;
    m_bHasAlpha   = 0;

    m_pddsSurface = NULL;
    m_hbmBitmap   = NULL;
    m_pRGBAData   = NULL;

    // Add the texture to the head of the global texture list
    m_pNext = g_ptcTextureList;
    g_ptcTextureList = this;
}




//-----------------------------------------------------------------------------
// Name: ~TextureContainer()
// Desc: Destructs the contents of the texture container
//-----------------------------------------------------------------------------
TextureContainer::~TextureContainer()
{
    SAFE_RELEASE(m_pddsSurface);
    SAFE_DELETE(m_pRGBAData);
    DeleteObject(m_hbmBitmap);

    // Remove the texture container from the global list
    if (g_ptcTextureList == this)
        g_ptcTextureList = m_pNext;
    else
    {
        for(TextureContainer* ptc=g_ptcTextureList; ptc; ptc=ptc->m_pNext)
            if (ptc->m_pNext == this)
                ptc->m_pNext = m_pNext;
    }
}




//-----------------------------------------------------------------------------
// Name: LoadImageData()
// Desc: Loads the texture map's image data
//-----------------------------------------------------------------------------
HRESULT TextureContainer::LoadImageData()
{
    HRESULT hr = S_OK;

    // Check the executable's resource. If it's there, we're done!
    m_hbmBitmap = (HBITMAP)LoadImage(GetModuleHandle(NULL), m_strName,
                                      IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (!m_hbmBitmap)
    {
        TCHAR* strExtension;
        TCHAR  strPathname[256];

        // First check if the file exists in the global texture path
        lstrcpy(strPathname, g_strTexturePath);
        lstrcat(strPathname, m_strName);

        if (!PathFileExists(strPathname))
        {
            // Then check if the file exists in the DirectX SDK media path
            lstrcpy(strPathname, D3DUtil_GetDXSDKMediaPath());
            lstrcat(strPathname, m_strName);
        }

        if (PathFileExists(strPathname))
        {
            // Get the filename extension
            if (NULL == (strExtension = StrChr(m_strName, TEXT('.'))))
                return DDERR_UNSUPPORTED;

            // Load bitmap files
            if (!lstrcmpi(strExtension, TEXT(".bmp")))
                return LoadBitmapFile(strPathname);

            // Load targa files
            if (!lstrcmpi(strExtension, TEXT(".tga")))
                return LoadTargaFile(strPathname);
        }
        else
        {
            hr = DDERR_NOTFOUND;
        }
    }

    // Can add code here to check for other file formats before failing
    return DDERR_UNSUPPORTED;
}




//-----------------------------------------------------------------------------
// Name: LoadBitmapFile()
// Desc: Loads data from a .bmp file, and stores it in a bitmap structure.
//-----------------------------------------------------------------------------
HRESULT TextureContainer::LoadBitmapFile(TCHAR* strPathname)
{
    // Try to load the bitmap as a file
    m_hbmBitmap = (HBITMAP)LoadImage(NULL, strPathname, IMAGE_BITMAP, 0, 0,
                                      LR_LOADFROMFILE|LR_CREATEDIBSECTION);
    if (m_hbmBitmap)
        return S_OK;
    
    return DDERR_NOTFOUND;
}


BYTE GetFileByte(HANDLE hFile)
{
    BYTE byte = 0;
    DWORD cbRead;

    if (!ReadFile(hFile, &byte, sizeof(byte), &cbRead, NULL) || (sizeof(byte) != cbRead))
    {
        return 0;
    }

    return byte;
}

//-----------------------------------------------------------------------------
// Name: LoadTargaFile()
// Desc: Loads RGBA data from a .tga file, and stores it in allocated memory
//       for the specified texture container
//-----------------------------------------------------------------------------
HRESULT TextureContainer::LoadTargaFile(TCHAR* strPathname)
{
    HANDLE hFile = CreateFile(strPathname, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hFile)
        return E_FAIL;

    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tga;

    DWORD cbRead;
    if (ReadFile(hFile, &tga, sizeof(tga), &cbRead, NULL))
    {
        // Only true color, non-mapped images are supported
        if ((0 != tga.ColormapType) || 
            (tga.ImageType != 10 && tga.ImageType != 2))
        {
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Skip the ID field. The first byte of the header is the length of this field
        if (tga.IDLength)
        {
            SetFilePointer(hFile, tga.IDLength, 0, FILE_CURRENT);
        }

        m_dwWidth   = tga.ImageWidth;
        m_dwHeight  = tga.ImageHeight;
        m_dwBPP     = tga.PixelDepth;
        m_pRGBAData = new DWORD[m_dwWidth*m_dwHeight];

        if (m_pRGBAData == NULL)
        {
            CloseHandle(hFile);
            return E_FAIL;
        }

        for(DWORD y=0; y<m_dwHeight; y++)
        {
            DWORD dwOffset = y*m_dwWidth;

            if (0 == (tga.ImageDescriptor & 0x0010))
                dwOffset = (m_dwHeight-y-1)*m_dwWidth;

            for(DWORD x=0; x<m_dwWidth; x)
            {
                if (tga.ImageType == 10)
                {
                    BYTE PacketInfo = GetFileByte(hFile);
                    WORD PacketType = 0x80 & PacketInfo;
                    WORD PixelCount = (0x007f & PacketInfo) + 1;

                    if (PacketType)
                    {
                        DWORD b = GetFileByte(hFile);
                        DWORD g = GetFileByte(hFile);
                        DWORD r = GetFileByte(hFile);
                        DWORD a = 0xff;
                        if (m_dwBPP == 32)
                            a = GetFileByte(hFile);

                        while(PixelCount--)
                        {
                            m_pRGBAData[dwOffset+x] = (r<<24L)+(g<<16L)+(b<<8L)+(a);
                            x++;
                        }
                    }
                    else
                    {
                        while(PixelCount--)
                        {
                            BYTE b = GetFileByte(hFile);
                            BYTE g = GetFileByte(hFile);
                            BYTE r = GetFileByte(hFile);
                            BYTE a = 0xff;
                            if (m_dwBPP == 32)
                                a = GetFileByte(hFile);

                            m_pRGBAData[dwOffset+x] = (r<<24L)+(g<<16L)+(b<<8L)+(a);
                            x++;
                        }
                    }
                }
                else
                {
                    BYTE b = GetFileByte(hFile);
                    BYTE g = GetFileByte(hFile);
                    BYTE r = GetFileByte(hFile);
                    BYTE a = 0xff;
                    if (m_dwBPP == 32)
                        a = GetFileByte(hFile);

                    m_pRGBAData[dwOffset+x] = (r<<24L)+(g<<16L)+(b<<8L)+(a);
                    x++;
                }
            }
        }
    }
    
    CloseHandle(hFile);

    // Check for alpha content
    for(DWORD i=0; i<(m_dwWidth*m_dwHeight); i++)
    {
        if ((m_pRGBAData[i] & 0x000000ff) != 0xff)
        {
            m_bHasAlpha = TRUE;
            break;
        }
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Restore()
// Desc: Rebuilds the texture surface using the new device.
//-----------------------------------------------------------------------------
HRESULT TextureContainer::Restore(LPDIRECT3DDEVICE7 pd3dDevice)
{
    // Release any previously created objects
    SAFE_RELEASE(m_pddsSurface);

    // Check params
    if (NULL == pd3dDevice)
        return DDERR_INVALIDPARAMS;

    // Get the device caps
    D3DDEVICEDESC7 ddDesc;
    if (FAILED(pd3dDevice->GetCaps(&ddDesc)))
        return E_FAIL;

    // Setup the new surface desc
    DDSURFACEDESC2 ddsd;
    D3DUtil_InitSurfaceDesc(ddsd);
    ddsd.dwFlags         = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|
                           DDSD_PIXELFORMAT|DDSD_TEXTURESTAGE;
    ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE;
    ddsd.dwTextureStage  = m_dwStage;
    ddsd.dwWidth         = m_dwWidth;
    ddsd.dwHeight        = m_dwHeight;

    // Turn on texture management for hardware devices
    if (ddDesc.deviceGUID == IID_IDirect3DHALDevice)
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_TEXTUREMANAGE;
    else if (ddDesc.deviceGUID == IID_IDirect3DTnLHalDevice)
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_TEXTUREMANAGE;
    else
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    // Adjust width and height to be powers of 2, if the device requires it
    if (ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2)
    {
        for(ddsd.dwWidth=1;  m_dwWidth>ddsd.dwWidth;   ddsd.dwWidth<<=1);
        for(ddsd.dwHeight=1; m_dwHeight>ddsd.dwHeight; ddsd.dwHeight<<=1);
    }

    // Limit max texture sizes, if the driver can't handle large textures
    DWORD dwMaxWidth  = ddDesc.dwMaxTextureWidth;
    DWORD dwMaxHeight = ddDesc.dwMaxTextureHeight;
    ddsd.dwWidth  = min(ddsd.dwWidth,  (dwMaxWidth  ? dwMaxWidth  : 256));
    ddsd.dwHeight = min(ddsd.dwHeight, (dwMaxHeight ? dwMaxHeight : 256));

    // Make the texture square, if the driver requires it
    if (ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if (ddsd.dwWidth > ddsd.dwHeight) ddsd.dwHeight = ddsd.dwWidth;
        else                               ddsd.dwWidth  = ddsd.dwHeight;
    }

    // Setup the structure to be used for texture enumration.
    TEXTURESEARCHINFO tsi;
    tsi.bFoundGoodFormat = FALSE;
    tsi.pddpf            = &ddsd.ddpfPixelFormat;
    tsi.dwDesiredBPP     = m_dwBPP;
    tsi.bUsePalette      = (m_dwBPP <= 8);
    tsi.bUseAlpha        = m_bHasAlpha;
    if (m_dwFlags & D3DTEXTR_16BITSPERPIXEL)
        tsi.dwDesiredBPP = 16;
    else if (m_dwFlags & D3DTEXTR_32BITSPERPIXEL)
        tsi.dwDesiredBPP = 32;

    if (m_dwFlags & (D3DTEXTR_TRANSPARENTWHITE|D3DTEXTR_TRANSPARENTBLACK))
    {
        if (tsi.bUsePalette)
        {
            if (ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)
            {
                tsi.bUseAlpha   = TRUE;
                tsi.bUsePalette = TRUE;
            }
            else
            {
                tsi.bUseAlpha   = TRUE;
                tsi.bUsePalette = FALSE;
            }
        }
    }

    // Enumerate the texture formats, and find the closest device-supported
    // texture pixel format
    pd3dDevice->EnumTextureFormats(TextureSearchCallback, &tsi);

    // If we couldn't find a format, let's try a default format
    if (FALSE == tsi.bFoundGoodFormat)
    {
        tsi.bUsePalette  = FALSE;
        tsi.dwDesiredBPP = 16;
        pd3dDevice->EnumTextureFormats(TextureSearchCallback, &tsi);

        // If we still fail, we cannot create this texture
        if (FALSE == tsi.bFoundGoodFormat)
            return E_FAIL;
    }

    // Get the DirectDraw interface for creating surfaces
    LPDIRECTDRAW7        pDD;
    LPDIRECTDRAWSURFACE7 pddsRender;
    pd3dDevice->GetRenderTarget(&pddsRender);
    pddsRender->GetDDInterface((VOID**)&pDD);
    pddsRender->Release();

    // Create a new surface for the texture
    HRESULT hr = pDD->CreateSurface(&ddsd, &m_pddsSurface, NULL);

    // Done with DDraw
    pDD->Release();

    if (FAILED(hr))
        return hr;

    // For bitmap-based textures, copy the bitmap image.
    if (m_hbmBitmap)
        return CopyBitmapToSurface();

    if (m_pRGBAData)
        return CopyRGBADataToSurface();

    // At this point, code can be added to handle other file formats (such as
    // .dds files, .jpg files, etc.).
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CopyBitmapToSurface()
// Desc: Copies the image of a bitmap into a surface
//-----------------------------------------------------------------------------
HRESULT TextureContainer::CopyBitmapToSurface()
{
    // Get a DDraw object to create a temporary surface
    LPDIRECTDRAW7 pDD;
    m_pddsSurface->GetDDInterface((VOID**)&pDD);

    // Get the bitmap structure (to extract width, height, and bpp)
    BITMAP bm;
    GetObject(m_hbmBitmap, sizeof(BITMAP), &bm);

    // Setup the new surface desc
    DDSURFACEDESC2 ddsd;
    ddsd.dwSize = sizeof(ddsd);
    m_pddsSurface->GetSurfaceDesc(&ddsd);
    ddsd.dwFlags          = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT|
                            DDSD_TEXTURESTAGE;
    ddsd.ddsCaps.dwCaps   = DDSCAPS_TEXTURE|DDSCAPS_SYSTEMMEMORY;
    ddsd.ddsCaps.dwCaps2  = 0L;
    ddsd.dwWidth          = bm.bmWidth;
    ddsd.dwHeight         = bm.bmHeight;

    // Create a new surface for the texture
    LPDIRECTDRAWSURFACE7 pddsTempSurface;
    HRESULT hr;
    if (FAILED(hr = pDD->CreateSurface(&ddsd, &pddsTempSurface, NULL)))
    {
        pDD->Release();
        return hr;
    }

    // Get a DC for the bitmap
    HDC hdcBitmap = CreateCompatibleDC(NULL);
    if (NULL == hdcBitmap)
    {
        pddsTempSurface->Release();
        pDD->Release();
        return hr;
    }
    SelectObject(hdcBitmap, m_hbmBitmap);

    // Handle palettized textures. Need to attach a palette
    if (ddsd.ddpfPixelFormat.dwRGBBitCount == 8)
    {
        LPDIRECTDRAWPALETTE  pPalette;
        DWORD dwPaletteFlags = DDPCAPS_8BIT|DDPCAPS_ALLOW256;
        DWORD pe[256];
        WORD  wNumColors = (WORD) GetDIBColorTable(hdcBitmap, 0, 256, (RGBQUAD*)pe);

        // Create the color table
        for(WORD i=0; i<wNumColors; i++)
        {
            pe[i] = RGB(GetBValue(pe[i]), GetGValue(pe[i]), GetRValue(pe[i]));

            // Handle textures with transparent pixels
            if (m_dwFlags & (D3DTEXTR_TRANSPARENTWHITE|D3DTEXTR_TRANSPARENTBLACK))
            {
                // Set alpha for opaque pixels
                if (m_dwFlags & D3DTEXTR_TRANSPARENTBLACK)
                {
                    if (pe[i] != 0x00000000)
                        pe[i] |= 0xff000000;
                }
                else if (m_dwFlags & D3DTEXTR_TRANSPARENTWHITE)
                {
                    if (pe[i] != 0x00ffffff)
                        pe[i] |= 0xff000000;
                }
            }
        }
        // Add DDPCAPS_ALPHA flag for textures with transparent pixels
        if (m_dwFlags & (D3DTEXTR_TRANSPARENTWHITE|D3DTEXTR_TRANSPARENTBLACK))
            dwPaletteFlags |= DDPCAPS_ALPHA;

        // Create & attach a palette
        pDD->CreatePalette(dwPaletteFlags, (PALETTEENTRY*)pe, &pPalette, NULL);
        pddsTempSurface->SetPalette(pPalette);
        m_pddsSurface->SetPalette(pPalette);
        SAFE_RELEASE(pPalette);
    }

    // Copy the bitmap image to the surface.
    HDC hdcSurface;
    if (SUCCEEDED(pddsTempSurface->GetDC(&hdcSurface)))
    {
        BitBlt(hdcSurface, 0, 0, bm.bmWidth, bm.bmHeight, hdcBitmap, 0, 0,
                SRCCOPY);
        pddsTempSurface->ReleaseDC(hdcSurface);
    }
    DeleteDC(hdcBitmap);

    // Copy the temp surface to the real texture surface
    m_pddsSurface->Blt(NULL, pddsTempSurface, NULL, DDBLT_WAIT, NULL);

    // Done with the temp surface
    pddsTempSurface->Release();

    // For textures with real alpha (not palettized), set transparent bits
    if (ddsd.ddpfPixelFormat.dwRGBAlphaBitMask)
    {
        if (m_dwFlags & (D3DTEXTR_TRANSPARENTWHITE|D3DTEXTR_TRANSPARENTBLACK))
        {
            // Lock the texture surface
            DDSURFACEDESC2 ddsd;
            ddsd.dwSize = sizeof(ddsd);
            while(m_pddsSurface->Lock(NULL, &ddsd, 0, NULL) ==
                   DDERR_WASSTILLDRAWING);

            DWORD dwAlphaMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
            DWORD dwRGBMask   = (ddsd.ddpfPixelFormat.dwRBitMask |
                                  ddsd.ddpfPixelFormat.dwGBitMask |
                                  ddsd.ddpfPixelFormat.dwBBitMask);
            DWORD dwColorkey  = 0x00000000; // Colorkey on black
            if (m_dwFlags & D3DTEXTR_TRANSPARENTWHITE)
                dwColorkey = dwRGBMask;     // Colorkey on white

            // Add an opaque alpha value to each non-colorkeyed pixel
            for(DWORD y=0; y<ddsd.dwHeight; y++)
            {
                WORD*  p16 =  (WORD*)((BYTE*)ddsd.lpSurface + y*ddsd.lPitch);
                DWORD* p32 = (DWORD*)((BYTE*)ddsd.lpSurface + y*ddsd.lPitch);

                for(DWORD x=0; x<ddsd.dwWidth; x++)
                {
                    if (ddsd.ddpfPixelFormat.dwRGBBitCount == 16)
                    {
                        if ((*p16 &= dwRGBMask) != dwColorkey)
                            *p16 |= dwAlphaMask;
                        p16++;
                    }
                    if (ddsd.ddpfPixelFormat.dwRGBBitCount == 32)
                    {
                        if ((*p32 &= dwRGBMask) != dwColorkey)
                            *p32 |= dwAlphaMask;
                        p32++;
                    }
                }
            }
            m_pddsSurface->Unlock(NULL);
        }
    }

    pDD->Release();

    return S_OK;;
}




//-----------------------------------------------------------------------------
// Name: CopyRGBADataToSurface()
// Desc: Invalidates the current texture objects and rebuilds new ones
//       using the new device.
//-----------------------------------------------------------------------------
HRESULT TextureContainer::CopyRGBADataToSurface()
{
    // Get a DDraw object to create a temporary surface
    LPDIRECTDRAW7 pDD;
    m_pddsSurface->GetDDInterface((VOID**)&pDD);

    // Setup the new surface desc
    DDSURFACEDESC2 ddsd;
    ddsd.dwSize = sizeof(ddsd);
    m_pddsSurface->GetSurfaceDesc(&ddsd);
    ddsd.dwFlags         = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT|
                           DDSD_TEXTURESTAGE;
    ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE|DDSCAPS_SYSTEMMEMORY;
    ddsd.ddsCaps.dwCaps2 = 0L;
    ddsd.dwWidth         = m_dwWidth;
    ddsd.dwHeight        = m_dwHeight;

    // Create a new surface for the texture
    LPDIRECTDRAWSURFACE7 pddsTempSurface;
    HRESULT hr;
    if (FAILED(hr = pDD->CreateSurface(&ddsd, &pddsTempSurface, NULL)))
    {
        pDD->Release();
        return NULL;
    }

    while(pddsTempSurface->Lock(NULL, &ddsd, 0, 0) == DDERR_WASSTILLDRAWING);
    DWORD lPitch = ddsd.lPitch;
    BYTE* pBytes = (BYTE*)ddsd.lpSurface;

    DWORD dwRMask = ddsd.ddpfPixelFormat.dwRBitMask;
    DWORD dwGMask = ddsd.ddpfPixelFormat.dwGBitMask;
    DWORD dwBMask = ddsd.ddpfPixelFormat.dwBBitMask;
    DWORD dwAMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;

    DWORD dwRShiftL = 8, dwRShiftR = 0;
    DWORD dwGShiftL = 8, dwGShiftR = 0;
    DWORD dwBShiftL = 8, dwBShiftR = 0;
    DWORD dwAShiftL = 8, dwAShiftR = 0;

    DWORD dwMask;
    for(dwMask=dwRMask; dwMask && !(dwMask&0x1); dwMask>>=1) dwRShiftR++;
    for(; dwMask; dwMask>>=1) dwRShiftL--;

    for(dwMask=dwGMask; dwMask && !(dwMask&0x1); dwMask>>=1) dwGShiftR++;
    for(; dwMask; dwMask>>=1) dwGShiftL--;

    for(dwMask=dwBMask; dwMask && !(dwMask&0x1); dwMask>>=1) dwBShiftR++;
    for(; dwMask; dwMask>>=1) dwBShiftL--;

    for(dwMask=dwAMask; dwMask && !(dwMask&0x1); dwMask>>=1) dwAShiftR++;
    for(; dwMask; dwMask>>=1) dwAShiftL--;

    for(DWORD y=0; y<ddsd.dwHeight; y++)
    {
        DWORD* pDstData32 = (DWORD*)pBytes;
        WORD*  pDstData16 = (WORD*)pBytes;

        for(DWORD x=0; x<ddsd.dwWidth; x++)
        {
            DWORD dwPixel = m_pRGBAData[y*ddsd.dwWidth+x];

            BYTE r = (BYTE)((dwPixel>>24)&0x000000ff);
            BYTE g = (BYTE)((dwPixel>>16)&0x000000ff);
            BYTE b = (BYTE)((dwPixel>> 8)&0x000000ff);
            BYTE a = (BYTE)((dwPixel>> 0)&0x000000ff);

            DWORD dr = ((r>>(dwRShiftL))<<dwRShiftR)&dwRMask;
            DWORD dg = ((g>>(dwGShiftL))<<dwGShiftR)&dwGMask;
            DWORD db = ((b>>(dwBShiftL))<<dwBShiftR)&dwBMask;
            DWORD da = ((a>>(dwAShiftL))<<dwAShiftR)&dwAMask;

            if (32 == ddsd.ddpfPixelFormat.dwRGBBitCount)
                pDstData32[x] = (DWORD)(dr+dg+db+da);
            else
                pDstData16[x] = (WORD)(dr+dg+db+da);
        }
    
        pBytes += ddsd.lPitch;
    }

    pddsTempSurface->Unlock(0);

    // Copy the temp surface to the real texture surface
    m_pddsSurface->Blt(NULL, pddsTempSurface, NULL, DDBLT_WAIT, NULL);

    // Done with the temp objects
    pddsTempSurface->Release();
    pDD->Release();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: D3DTextr_SetTexturePath()
// Desc: Enumeration callback routine to find a best-matching texture format.
//-----------------------------------------------------------------------------
VOID D3DTextr_SetTexturePath(TCHAR* strTexturePath)
{
    if (NULL == strTexturePath)
        strTexturePath[0] = 0;
    lstrcpy(g_strTexturePath, strTexturePath);
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_CreateTextureFromFile()
// Desc: Is passed a filename and creates a local Bitmap from that file.
//       The texture can not be used until it is restored, however.
//-----------------------------------------------------------------------------
HRESULT D3DTextr_CreateTextureFromFile(TCHAR* strName, DWORD dwStage,
                                        DWORD dwFlags)
{
    // Check parameters
    if (NULL == strName)
        return E_INVALIDARG;

    // Check first to see if the texture is already loaded
    if (NULL != FindTexture(strName))
        return S_OK;

    // Allocate and add the texture to the linked list of textures;
    TextureContainer* ptcTexture = new TextureContainer(strName, dwStage,
                                                         dwFlags);
    if (NULL == ptcTexture)
        return E_OUTOFMEMORY;

    // Create a bitmap and load the texture file into it,
    if (FAILED(ptcTexture->LoadImageData()))
    {
        delete ptcTexture;
        return E_FAIL;
    }

    // Save the image's dimensions
    if (ptcTexture->m_hbmBitmap)
    {
        BITMAP bm;
        GetObject(ptcTexture->m_hbmBitmap, sizeof(BITMAP), &bm);
        ptcTexture->m_dwWidth  = (DWORD)bm.bmWidth;
        ptcTexture->m_dwHeight = (DWORD)bm.bmHeight;
        ptcTexture->m_dwBPP    = (DWORD)bm.bmBitsPixel;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_CreateEmptyTexture()
// Desc: Creates an empty texture.
//-----------------------------------------------------------------------------
HRESULT D3DTextr_CreateEmptyTexture(TCHAR* strName, DWORD dwWidth,
                                     DWORD dwHeight, DWORD dwStage, 
                                     DWORD dwFlags)
{
    // Check parameters
    if (NULL == strName)
        return E_INVALIDARG;

    // Check first to see if the texture is already loaded
    if (NULL != FindTexture(strName))
        return E_FAIL;

    // Allocate and add the texture to the linked list of textures;
    TextureContainer* ptcTexture = new TextureContainer(strName, dwStage,
                                                         dwFlags);
    if (NULL == ptcTexture)
        return E_OUTOFMEMORY;

    // Save dimensions
    ptcTexture->m_dwWidth  = dwWidth;
    ptcTexture->m_dwHeight = dwHeight;
    ptcTexture->m_dwBPP    = 16;
    if (ptcTexture->m_dwFlags & D3DTEXTR_32BITSPERPIXEL)
        ptcTexture->m_dwBPP = 32;

    // Save alpha usage flag
    if (dwFlags & D3DTEXTR_CREATEWITHALPHA)
        ptcTexture->m_bHasAlpha = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_Restore()
// Desc: Invalidates the current texture objects and rebuilds new ones
//       using the new device.
//-----------------------------------------------------------------------------
HRESULT D3DTextr_Restore(TCHAR* strName, LPDIRECT3DDEVICE7 pd3dDevice)
{
    TextureContainer* ptcTexture = FindTexture(strName);
    if (NULL == ptcTexture)
        return DDERR_NOTFOUND;

    // Restore the texture (this recreates the new surface for this device).
    return ptcTexture->Restore(pd3dDevice);
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_RestoreAllTextures()
// Desc: This function is called when a mode is changed. It updates all
//       texture objects to be valid with the new device.
//-----------------------------------------------------------------------------
HRESULT D3DTextr_RestoreAllTextures(LPDIRECT3DDEVICE7 pd3dDevice)
{
    TextureContainer* ptcTexture = g_ptcTextureList;

    while(ptcTexture)
    {
        D3DTextr_Restore(ptcTexture->m_strName, pd3dDevice);
        ptcTexture = ptcTexture->m_pNext;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_Invalidate()
// Desc: Used to bump a texture out of (video) memory, this function
//       actually destroys the d3dtexture and ddsurface of the texture
//-----------------------------------------------------------------------------
HRESULT D3DTextr_Invalidate(TCHAR* strName)
{
    TextureContainer* ptcTexture = FindTexture(strName);
    if (NULL == ptcTexture)
        return DDERR_NOTFOUND;

    SAFE_RELEASE(ptcTexture->m_pddsSurface);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_InvalidateAllTextures()
// Desc: This function is called when a mode is changed. It invalidates
//       all texture objects so their device can be safely released.
//-----------------------------------------------------------------------------
HRESULT D3DTextr_InvalidateAllTextures()
{
    TextureContainer* ptcTexture = g_ptcTextureList;

    while(ptcTexture)
    {
        SAFE_RELEASE(ptcTexture->m_pddsSurface);
        ptcTexture = ptcTexture->m_pNext;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_DestroyTexture()
// Desc: Frees the resources for the specified texture container
//-----------------------------------------------------------------------------
HRESULT D3DTextr_DestroyTexture(TCHAR* strName)
{
    TextureContainer* ptcTexture = FindTexture(strName);

    SAFE_DELETE(ptcTexture);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DTextr_GetSurface()
// Desc: Returns a pointer to a d3dSurface from the name of the texture
//-----------------------------------------------------------------------------
LPDIRECTDRAWSURFACE7 D3DTextr_GetSurface(TCHAR* strName)
{
    TextureContainer* ptcTexture = FindTexture(strName);

    return ptcTexture ? ptcTexture->m_pddsSurface : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dtextr.h ===
//-----------------------------------------------------------------------------
// File: D3DTextr.h
//
// Desc: Functions to manage textures, including creating (loading from a
//       file), restoring lost surfaces, invalidating, and destroying.
//
//       Note: the implementation of these fucntions maintain an internal list
//       of loaded textures. After creation, individual textures are referenced
//       via their ASCII names.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DTEXTR_H
#define D3DTEXTR_H

#include <ddraw.h>
#include <d3d.h>




//-----------------------------------------------------------------------------
// Access functions for loaded textures. Note: these functions search
// an internal list of the textures, and use the texture associated with the
// ASCII name.
//-----------------------------------------------------------------------------
LPDIRECTDRAWSURFACE7 D3DTextr_GetSurface(TCHAR* strName);




//-----------------------------------------------------------------------------
// Texture invalidation and restoration functions
//-----------------------------------------------------------------------------
HRESULT D3DTextr_Invalidate(TCHAR* strName);
HRESULT D3DTextr_Restore(TCHAR* strName, LPDIRECT3DDEVICE7 pd3dDevice);
HRESULT D3DTextr_InvalidateAllTextures();
HRESULT D3DTextr_RestoreAllTextures(LPDIRECT3DDEVICE7 pd3dDevice);




//-----------------------------------------------------------------------------
// Texture creation and deletion functions
//-----------------------------------------------------------------------------
#define D3DTEXTR_TRANSPARENTWHITE 0x00000001
#define D3DTEXTR_TRANSPARENTBLACK 0x00000002
#define D3DTEXTR_32BITSPERPIXEL   0x00000004
#define D3DTEXTR_16BITSPERPIXEL   0x00000008
#define D3DTEXTR_CREATEWITHALPHA  0x00000010


HRESULT D3DTextr_CreateTextureFromFile(TCHAR* strName, DWORD dwStage=0L,
                                        DWORD dwFlags=0L);
HRESULT D3DTextr_CreateEmptyTexture(TCHAR* strName, DWORD dwWidth,
                                     DWORD dwHeight, DWORD dwStage,
                                     DWORD dwFlags);
HRESULT D3DTextr_DestroyTexture(TCHAR* strName);
VOID    D3DTextr_SetTexturePath(TCHAR* strTexturePath);



#endif // D3DTEXTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dutil.h ===
//-----------------------------------------------------------------------------
// File: D3DUtil.h
//
// Desc: Helper functions and typing shortcuts for Direct3D programming.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DUTIL_H
#define D3DUTIL_H
#include <ddraw.h>
#include <d3d.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
const TCHAR* D3DUtil_GetDXSDKMediaPath();

#define SAFE_DELETE(p)  { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_RELEASE(p) { if(p) { (p)->Release(); (p)=NULL; } }




//-----------------------------------------------------------------------------
// Short cut functions for creating and using DX structures
//-----------------------------------------------------------------------------
VOID D3DUtil_InitDeviceDesc(D3DDEVICEDESC7& ddDevDesc);
VOID D3DUtil_InitSurfaceDesc(DDSURFACEDESC2& ddsd, DWORD dwFlags=0,
                              DWORD dwCaps=0);
VOID D3DUtil_InitMaterial(D3DMATERIAL7& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                           FLOAT b=0.0f, FLOAT a=1.0f);
VOID D3DUtil_InitLight(D3DLIGHT7& light, D3DLIGHTTYPE ltType,
                        FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f);




//-----------------------------------------------------------------------------
// D3D Matrix functions. For performance reasons, some functions are inline.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetViewMatrix(D3DMATRIX& mat, D3DVECTOR& vFrom,
                               D3DVECTOR& vAt, D3DVECTOR& vUp);
HRESULT D3DUtil_SetProjectionMatrix(D3DMATRIX& mat, FLOAT fFOV = 1.570795f,
                                     FLOAT fAspect = 1.0f,
                                     FLOAT fNearPlane = 1.0f,
                                     FLOAT fFarPlane = 1000.0f);

inline VOID D3DUtil_SetIdentityMatrix(D3DMATRIX& m)
{
    m._12 = m._13 = m._14 = m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = m._41 = m._42 = m._43 = 0.0f;
    m._11 = m._22 = m._33 = m._44 = 1.0f;
}

inline VOID D3DUtil_SetTranslateMatrix(D3DMATRIX& m, FLOAT tx, FLOAT ty,
                                        FLOAT tz)
{ D3DUtil_SetIdentityMatrix(m); m._41 = tx; m._42 = ty; m._43 = tz; }

inline VOID D3DUtil_SetTranslateMatrix(D3DMATRIX& m, D3DVECTOR& v)
{ D3DUtil_SetTranslateMatrix(m, v.x, v.y, v.z); }

inline VOID D3DUtil_SetScaleMatrix(D3DMATRIX& m, FLOAT sx, FLOAT sy,
                                    FLOAT sz)
{ D3DUtil_SetIdentityMatrix(m); m._11 = sx; m._22 = sy; m._33 = sz; }

inline VOID SetScaleMatrix(D3DMATRIX& m, D3DVECTOR& v)
{ D3DUtil_SetScaleMatrix(m, v.x, v.y, v.z); }

VOID    D3DUtil_SetRotateXMatrix(D3DMATRIX& mat, FLOAT fRads);
VOID    D3DUtil_SetRotateYMatrix(D3DMATRIX& mat, FLOAT fRads);
VOID    D3DUtil_SetRotateZMatrix(D3DMATRIX& mat, FLOAT fRads);
VOID    D3DUtil_SetRotationMatrix(D3DMATRIX& mat, D3DVECTOR& vDir,
                                   FLOAT fRads);




//-----------------------------------------------------------------------------
// Debug printing support
//-----------------------------------------------------------------------------

HRESULT _DbgOut(TCHAR*, DWORD, HRESULT, TCHAR*);

#if defined(DEBUG) | defined(_DEBUG)
    #define DEBUG_MSG(str)    _DbgOut(__FILE__, (DWORD)__LINE__, 0, str)
    #define DEBUG_ERR(hr,str) _DbgOut(__FILE__, (DWORD)__LINE__, hr, str)
#else
    #define DEBUG_MSG(str)    (0L)
    #define DEBUG_ERR(hr,str) (hr)
#endif




#endif // D3DUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\dolphin.cpp ===
//-----------------------------------------------------------------------------
// File: Dolphin.cpp
//
// Desc: Sample of swimming dolphin
//
//       Note: This code uses the D3D Framework helper library.
//
// Copyright (c) 1998-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"

#define D3D_OVERLOADS

#include "StdAfx.h"

#include <ddraw.h>
#include <d3d.h>

#include "D3DApp.h"
#include "D3DUtil.h"
#include "D3DMath.h"
#include "D3DTextr.h"
#include "D3DFile.h"
#include <math.h>
#include <time.h>
//#include <mmsystem.h>
#include "dxsvr.h"
#include "sealife.h"





float rnd(void)
{
    return float(rand())/RAND_MAX;
}   




//-----------------------------------------------------------------------------
// Name: CSeaLife()
// Desc: Constructor
//-----------------------------------------------------------------------------
/*
*/
CSeaLife::CSeaLife()   
{
    // Initialize member variables
    m_pDolphinGroupObject = NULL;
    m_pDolphinObject      = NULL;
    m_pFloorObject        = NULL;
    m_pFish1Object        = NULL;
    m_pd3dDevice          = NULL;
    m_pDeviceInfo         = NULL;


}



//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::OneTimeSceneInit()
{
    HRESULT hr;

    m_pDolphinGroupObject = NULL;
    m_pDolphinObject      = NULL;
    m_pFloorObject        = NULL;
    m_pFish1Object        = NULL;
    m_pd3dDevice          = NULL;
    m_pDeviceInfo         = NULL;


    m_pDolphinGroupObject = new CD3DFile();
    m_pDolphinObject      = new CD3DFile();
    m_pFloorObject        = new CD3DFile();
    m_pFish1Object        = new CD3DFile();

    hr  = m_pDolphinGroupObject->Load(TEXT("dolphin_group.x"));
    hr |= m_pDolphinGroupObject->GetMeshVertices(TEXT("Dolph01"), &m_pDolphin1Vertices, &m_dwNumDolphinVertices);
    hr |= m_pDolphinGroupObject->GetMeshVertices(TEXT("Dolph02"), &m_pDolphin2Vertices, &m_dwNumDolphinVertices);
    hr |= m_pDolphinGroupObject->GetMeshVertices(TEXT("Dolph03"), &m_pDolphin3Vertices, &m_dwNumDolphinVertices);


    if (FAILED(hr))
    {
        MessageBox(NULL, TEXT("Error loading DOLPHIN_GROUP.X file"),
                    TEXT("Dolphins"), MB_OK|MB_ICONERROR);
        return E_FAIL;
    }

    hr  = m_pDolphinObject->Load(TEXT("dolphin.x"));
    hr |= m_pDolphinObject->GetMeshVertices(TEXT("Dolph02"), &m_pDolphinVertices, &m_dwNumDolphinVertices);
    if (FAILED(hr))
    {
        MessageBox(NULL, TEXT("Error loading DOLPHIN.X file"),
                    TEXT("Dolphins"), MB_OK|MB_ICONERROR);
        return E_FAIL;
    }

    hr  = m_pFloorObject->Load(TEXT("seafloor.x"));
    hr |= m_pFloorObject->GetMeshVertices(TEXT("SeaFloor"), &m_pFloorVertices, &m_dwNumFloorVertices);
    if (FAILED(hr))
    {
        MessageBox(NULL, TEXT("Error loading SEAFLOOR.X file"),
                    TEXT("Dolphins"), MB_OK|MB_ICONERROR);
        return E_FAIL;
    }


    hr  = m_pFish1Object->Load(TEXT("clownfish2.x"));


    D3DTextr_CreateTextureFromFile(TEXT("seafloor.bmp"));
    D3DTextr_CreateTextureFromFile(TEXT("dolphin.bmp"));
    
    srand(5);

    // Scale the sea floor vertices, and add some bumpiness
    for(DWORD i=0; i<m_dwNumFloorVertices; i++)
    {
        m_pFloorVertices[i].y  += (rand()/(FLOAT)RAND_MAX);
        m_pFloorVertices[i].y  += (rand()/(FLOAT)RAND_MAX);
        m_pFloorVertices[i].y  += (rand()/(FLOAT)RAND_MAX);
        m_pFloorVertices[i].tu *= 10;
        m_pFloorVertices[i].tv *= 10;
    }

    // Scale the dolphin vertices (the model file is too big)
    for(i=0; i<m_dwNumDolphinVertices; i++)
    {
        D3DVECTOR vScale(0.01f, 0.01f, 0.01f);
        *((D3DVECTOR*)(&m_pDolphin1Vertices[i])) *= vScale;
        *((D3DVECTOR*)(&m_pDolphin2Vertices[i])) *= vScale;
        *((D3DVECTOR*)(&m_pDolphin3Vertices[i])) *= vScale;
    }

    

    for (i=0; i<NUM_FISH;i++)
    {
        ZeroMemory(&m_FishState[i],sizeof(FISHSTRUCT));
        
        m_FishState[i].type=FISHTYPE_DOLPHIN;
        m_FishState[i].dir=D3DVECTOR(0,0,1);
        m_FishState[i].goal=D3DVECTOR(XEXTENT,YEXTENT,ZEXTENT);
        m_FishState[i].loc=D3DVECTOR(XEXTENT,0,ZEXTENT);
        m_FishState[i].speed = DOLPHINSPEED;
        m_FishState[i].angle_tweak =TWEAK;
        m_FishState[i].pitch=INITPITCH;
        m_FishState[i].turndelta=(float)TURNDELTADOLPHIN;
        m_FishState[i].pitchchange= (float)PITCHCHANGE;
        m_FishState[i].pitchdelta= PITCHDELTA;
        

        if ((i > NUM_DOLPHINS))
        {
            m_FishState[i].type=FISHTYPE_FISH1;
            m_FishState[i].pitchchange= (float)PITCHCHANGEFISH;
            m_FishState[i].pitchdelta= PITCHDELTAFISH;          
            m_FishState[i].turndelta=(float)TURNDELTAFISH;
            m_FishState[i].angle_tweak =TWEAKFISH;
            m_FishState[i].speed = FISHSPEED;
            ;
        }
    }

    m_FishState[0].type=FISHTYPE_CAMERA;
    m_FishState[0].turndelta=(float)TURNDELTADOLPHIN;
    m_FishState[0].angle_tweak =TWEAK;

    srand (time (0));


    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::FinalCleanup()
{
    SAFE_DELETE(m_pDolphinGroupObject);
    SAFE_DELETE(m_pDolphinObject);
    SAFE_DELETE(m_pFloorObject);
    //dont cleanup device object.. 

    D3DTextr_InvalidateAllTextures();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: BlendMeshes()
// Desc: Does a linear interpolation between all vertex positions and normals
//       in two source meshes and outputs the result to the destination mesh.
//       This function assumes that all strided vertices have the same stride,
//       and that each mesh contains the same number of vertices
//-----------------------------------------------------------------------------
VOID BlendMeshes(D3DVERTEX* pDstMesh, D3DVERTEX* pSrcMesh1,
                  D3DVERTEX* pSrcMesh2, DWORD dwNumVertices, FLOAT fWeight)
{
    FLOAT fInvWeight = 1.0f - fWeight;

    // LERP positions and normals
    for(DWORD i=0; i<dwNumVertices; i++)
    {
        pDstMesh->x  = fWeight*pSrcMesh1->x  + fInvWeight*pSrcMesh2->x;
        pDstMesh->y  = fWeight*pSrcMesh1->y  + fInvWeight*pSrcMesh2->y;
        pDstMesh->z  = fWeight*pSrcMesh1->z  + fInvWeight*pSrcMesh2->z;
        pDstMesh->nx = fWeight*pSrcMesh1->nx + fInvWeight*pSrcMesh2->nx;
        pDstMesh->ny = fWeight*pSrcMesh1->ny + fInvWeight*pSrcMesh2->ny;
        pDstMesh->nz = fWeight*pSrcMesh1->nz + fInvWeight*pSrcMesh2->nz;

        pDstMesh++;
        pSrcMesh1++;
        pSrcMesh2++;
    }
}








//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::Render(LPDIRECT3DDEVICE7 lpDev)
{
    float fWeight;
    D3DMATRIX* pmatDest=NULL;

    D3DUtil_SetIdentityMatrix(m_matFloor);

    if (lpDev!=m_pd3dDevice)
    {       
        D3DTextr_RestoreAllTextures(lpDev);

    }
    m_pd3dDevice=lpDev;
    // Clear the viewport
    m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                           WATER_COLOR, 1.0f, 0L);

    // Begin the scene 
    if (SUCCEEDED(m_pd3dDevice->BeginScene()))
    {

        m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &m_matFloor);
        m_pFloorObject->Render(m_pd3dDevice);


        // Move the dolphin in a circle
        CD3DFileObject* pDolphinObject = m_pDolphinObject->FindObject(TEXT("x3ds_Dolph02"));
        CD3DFileObject* pFish1Object = m_pFish1Object->FindObject(TEXT("clownfish_root"));

        for (int i =0;i<NUM_FISH;i++)
        {
            switch (m_FishState[i].type)
            {
             case FISHTYPE_DOLPHIN:

                fWeight=-m_FishState[i].weight;

                if(fWeight < 0.0f)
                {
                    BlendMeshes(m_pDolphinVertices, m_pDolphin3Vertices, 
                                 m_pDolphin2Vertices, m_dwNumDolphinVertices, -fWeight);
                }
                else
                {
                    BlendMeshes(m_pDolphinVertices, m_pDolphin1Vertices, 
                                 m_pDolphin2Vertices, m_dwNumDolphinVertices, fWeight);
                }

                
                if (pDolphinObject)
                {
                    m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &m_matFloor);     
                     pmatDest = pDolphinObject->GetMatrix();
                    *pmatDest=m_FishState[i].matrix;
                    m_pDolphinObject->Render(m_pd3dDevice);
                }

            
                break;

             case FISHTYPE_FISH1:
                if (pFish1Object)
                {
            
                    m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &m_matFloor);     
                    pmatDest = pFish1Object->GetMatrix();
                    *pmatDest=m_FishState[i].matrix;
                    m_pFish1Object->Render(m_pd3dDevice);
                }
                break;

            }

        }

        
        // End the scene.
        m_pd3dDevice->EndScene();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::InitDeviceObjects(LPDIRECT3DDEVICE7 pDev ,D3DEnum_DeviceInfo* pInfo)
{
    if (!pDev) return E_FAIL;

    m_pd3dDevice=pDev;
    m_pDeviceInfo=pInfo;

    // Set up the lighting states
//    if (m_pDeviceInfo->ddDeviceDesc.dwVertexProcessingCaps &
//                                                D3DVTXPCAPS_DIRECTIONALLIGHTS)
    {
        D3DLIGHT7 light;
        D3DUtil_InitLight(light, D3DLIGHT_DIRECTIONAL, 0.0f, -1.0f, 0.0f);
        m_pd3dDevice->SetLight(0, &light);
        m_pd3dDevice->LightEnable(0, TRUE);
        m_pd3dDevice->SetRenderState(D3DRENDERSTATE_LIGHTING, TRUE);
    }
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_AMBIENT, 0x33333333);

    // Set the transform matrices
    D3DVIEWPORT7 vp;
    m_pd3dDevice->GetViewport(&vp);
    FLOAT fAspect = ((FLOAT)vp.dwHeight) / vp.dwWidth;

    D3DVECTOR vEyePt    = D3DVECTOR(0.0f, 0.0f, -10.0f);
    D3DVECTOR vLookatPt = D3DVECTOR(0.0f, 0.0f,   0.0f);
    D3DVECTOR vUpVec    = D3DVECTOR(0.0f, 1.0f,   0.0f);
    D3DMATRIX matWorld, matProj;

    D3DUtil_SetIdentityMatrix(matWorld);
    m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD,      &matWorld);

    D3DMATRIX matView;
    D3DUtil_SetViewMatrix(matView,vEyePt, vLookatPt, vUpVec);
    m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_VIEW, &matView);

    D3DUtil_SetProjectionMatrix(matProj, g_PI/3, fAspect, 1.0f, 1000.0f);    
    m_pd3dDevice->SetTransform(D3DTRANSFORMSTATE_PROJECTION, &matProj);

    // Set up textures
    D3DTextr_RestoreAllTextures(m_pd3dDevice);
    
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTFN_LINEAR);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTFG_LINEAR);

    // Set default render states
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_DITHERENABLE,   TRUE);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_SPECULARENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE,        TRUE);

    // Turn on fog
    FLOAT fFogStart =  1.0f;
    FLOAT fFogEnd   = 50.0f;
    FLOAT fDense    =  0.5f;

    //note turn off fog for RGB
    //m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGENABLE,    FALSE);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGENABLE,    TRUE);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGCOLOR,     WATER_COLOR);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGDENSITY, *(DWORD*)(&fDense));
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGVERTEXMODE,  D3DFOG_LINEAR);
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGSTART, *((DWORD *)(&fFogStart)));
    m_pd3dDevice->SetRenderState(D3DRENDERSTATE_FOGEND,   *((DWORD *)(&fFogEnd)));


    D3DTextr_Restore(TEXT("seafloor.bmp") ,m_pd3dDevice);
    D3DTextr_Restore(TEXT("dolphin.bmp"), m_pd3dDevice);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::DeleteDeviceObjects()
{
    D3DTextr_InvalidateAllTextures();

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CSeaLife::FrameMove(FLOAT fTimeKeyIn)
{
    

    D3DVECTOR vDirXZ;       
    D3DVECTOR vDeltaXZ;
    float dotProd;
    static DWORD dwLastTime=0;

    float deltaspeed=.002f;
    
    DWORD dwThisTime=timeGetTime();
    if (dwLastTime != 0) 
    {
        deltaspeed=((float)(dwThisTime-dwLastTime))/10000.0f;   
    }
    dwLastTime=dwThisTime;


    float fT,fT2,fT3 ;
    D3DMATRIX   matFish;
    D3DMATRIX   matYRotate,matZRotate,matXRotate;
    D3DMATRIX   matTrans1, matScale;
    D3DMATRIX   matRotate1, matRotate2;
    D3DMATRIX   matTemp,matTemp2;

    FLOAT       fPhase;
    FLOAT       fKickFreq;
    FLOAT       fTimeKey;
    FLOAT       fJiggleFreq;
    
    for (int i=0; i< NUM_FISH;i++)
    {
        //time based numbers
        fTimeKey=fTimeKeyIn+i*2;
        fKickFreq = 3*fTimeKey;
        fJiggleFreq = fTimeKey;
        fT=-(DOLPHINUPDOWN(fKickFreq));
        fT2=-fT/2;
        fT3=(float) ((3.1415/32)*sin(fTimeKeyIn/10));

        fPhase = (fTimeKey)/3;
        m_FishState[i].weight= - (float)sin(fKickFreq);

        //get the vector from current location to the goal
        vDeltaXZ=m_FishState[i].goal -m_FishState[i].loc ;      
        vDeltaXZ.y=0;

        //transpose x and z coordinates to find normal to direction
        //only for the dolphin though
        vDirXZ.x =-m_FishState[i].dir.z;
        vDirXZ.z = m_FishState[i].dir.x;
        vDirXZ.y =0;
        
        //take dot product to determine   what side to turn to
        dotProd=DotProduct(vDeltaXZ,vDirXZ);

        // turn by adding yaw
        if (dotProd < -m_FishState[i].turndelta)
            m_FishState[i].yaw +=m_FishState[i].angle_tweak;
        
        if (dotProd > m_FishState[i].turndelta)
            m_FishState[i].yaw -=m_FishState[i].angle_tweak;
        

        // now see how far we have to go up and down.
        float deltaY=m_FishState[i].goal.y - m_FishState[i].loc.y;

        

        if (deltaY <  -m_FishState[i].pitchdelta)
        {
            m_FishState[i].pitch+=m_FishState[i].pitchchange;
            if (m_FishState[i].pitch > 0.8f) m_FishState[i].pitch=0.8f;
        }
        else if (deltaY >   PITCHDELTA)
        {
            m_FishState[i].pitch-=m_FishState[i].pitchchange;
            if (m_FishState[i].pitch < -0.8f) m_FishState[i].pitch=-0.8f;
        }
        else
        {
            m_FishState[i].pitch *= .95f;
        }

        if (m_FishState[i].type==FISHTYPE_FISH1)
        {

            //note for the dolphin we will modulate the pitch
            D3DUtil_SetRotateYMatrix(matYRotate, (float) (m_FishState[i].yaw+FISHWIGGLE));
            D3DUtil_SetRotateXMatrix(matXRotate,-m_FishState[i].pitch);
            D3DMath_MatrixMultiply(matTemp, matXRotate,  matYRotate);      //ak
        }
        else if (m_FishState[i].type==FISHTYPE_CAMERA)
        {
            D3DUtil_SetRotateYMatrix(matYRotate,m_FishState[i].yaw);
            D3DUtil_SetRotateXMatrix(matXRotate,-m_FishState[i].pitch);
            D3DMath_MatrixMultiply(matTemp, matXRotate,  matYRotate);      //ak
        }
        else 
        {
            //note for the dolphin we will modulate the pitch
            D3DUtil_SetRotateYMatrix(matYRotate,m_FishState[i].yaw);
            D3DUtil_SetRotateXMatrix(matXRotate,-m_FishState[i].pitch+fT);
            D3DMath_MatrixMultiply(matTemp, matXRotate,  matYRotate);      //ak

        }
        //extract a new direction vector
        m_FishState[i].dir[0] = -matTemp(2, 0);
        m_FishState[i].dir[1] = -matTemp(2, 1);
        m_FishState[i].dir[2] = -matTemp(2, 2);
        

        //normalize direction
        m_FishState[i].dir = Normalize(m_FishState[i].dir);

        if (m_FishState[i].type ==FISHTYPE_CAMERA) 
        {
            D3DVECTOR local_up;
            D3DVECTOR from;
            D3DVECTOR at;
            D3DVECTOR loc = m_FishState[i].loc;
            D3DVECTOR dir = m_FishState[i].dir;
            D3DMATRIX view;
            local_up.x =matTemp(1, 0);
            local_up.y =matTemp(1, 1);
            local_up.z =matTemp(1, 2);

            from=loc; // - 20 * dir + 3* local_up;
            at= loc+dir;
                                            
            //SetViewParams(&from,&at,&local_up,1.0f);
        }

        //update the location
        //TODO make time based
        m_FishState[i].loc +=  m_FishState[i].speed *deltaspeed* m_FishState[i].dir;

        
        //if we near our goal choose another one
        D3DVECTOR vRes = (m_FishState[i].goal - m_FishState[i].loc);
        if ((((int)abs(vRes.x)) < 1) && (((int)abs(vRes.z)) < 1)) 
        {
            m_FishState[i].goal=D3DVECTOR(XEXTENT,YEXTENT,ZEXTENT);
        }

    
        if (m_FishState[i].type==FISHTYPE_FISH1)
        {
            D3DUtil_SetRotateXMatrix(matRotate2,-m_FishState[i].pitch);
            D3DUtil_SetScaleMatrix(matScale,10,10,10);
            D3DUtil_SetRotateYMatrix(matRotate1,m_FishState[i].yaw+FISHWIGGLE);
            
            if (rnd()<.01)
            {
                m_FishState[i].goal=D3DVECTOR(XEXTENT,YEXTENT,ZEXTENT);
            }
        }

        else if (m_FishState[i].type==FISHTYPE_CAMERA)
        { 
            D3DUtil_SetRotateXMatrix(matRotate2,-m_FishState[i].pitch);
            D3DUtil_SetScaleMatrix(matScale,10,10,10);
            D3DUtil_SetRotateYMatrix(matRotate1,m_FishState[i].yaw);
            
            if (rnd()<.01)
            {
                m_FishState[i].goal=D3DVECTOR(XEXTENT,YEXTENT,ZEXTENT);
            }
        }

        else
        {
            D3DUtil_SetScaleMatrix(matScale,1,1,1);
            D3DUtil_SetRotateZMatrix(matRotate2,m_FishState[i].pitch +fT2);
            D3DUtil_SetRotateYMatrix(matRotate1,m_FishState[i].yaw-3.1415/2);
        }

        D3DUtil_SetTranslateMatrix(matTrans1,
                    m_FishState[i].loc.x,
                    m_FishState[i].loc.y,
                    m_FishState[i].loc.z);
        
        
        D3DMath_MatrixMultiply(matTemp, matRotate2,  matRotate1);
        D3DMath_MatrixMultiply(matTemp2, matTemp,  matScale);
        D3DMath_MatrixMultiply(matFish, matTemp2, matTrans1);          
    
        

        m_FishState[i].matrix = matFish;
        
        
        
    }

    return S_OK;
}





#if 0
        float   dot = DotProduct (offset, FISH[i].delta);
        offset = CrossProduct (offset, FISH[i].delta);
        dot = (1.0f-dot)/2.0f * angle_tweak * 10.0f;
        if (offset.y > 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f + dot) * 0.1f;
        } else if (offset.y < 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f - dot) * 0.1f;
        }
        FISH[i].yaw += FISH[i].dyaw;
        FISH[i].roll = -FISH[i].dyaw * 9.0f;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\d3dutil.cpp ===
//-----------------------------------------------------------------------------
// File: D3DUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define D3D_OVERLOADS
#define STRICT

#include "StdAfx.h"

#include <math.h>
#include "D3DUtil.h"




//-----------------------------------------------------------------------------
// Name: D3DUtil_GetDXSDKMediaPath()
// Desc: Returns the DirectX SDK media path, as stored in the system registry
//       during the SDK install.
//-----------------------------------------------------------------------------
const TCHAR* D3DUtil_GetDXSDKMediaPath()
{
    static TCHAR strNull[2] = TEXT("");
    static TCHAR strPath[512];
    HKEY  key;
    DWORD type, size = 512;

    // Open the appropriate registry key
    LONG result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("Software\\Microsoft\\DirectX"),
                                0, KEY_READ, &key);
    if (ERROR_SUCCESS != result)
        return strNull;

    result = RegQueryValueEx(key, TEXT("DXSDK Samples Path"), NULL,
                              &type, (BYTE*)strPath, &size);
    RegCloseKey(key);

    if (ERROR_SUCCESS != result)
        return strNull;

    lstrcat(strPath, TEXT("\\D3DIM\\Media\\"));

    return strPath;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitSurfaceDesc()
// Desc: Helper function called to build a DDSURFACEDESC2 structure,
//       typically before calling CreateSurface() or GetSurfaceDesc()
//-----------------------------------------------------------------------------
VOID D3DUtil_InitSurfaceDesc(DDSURFACEDESC2& ddsd, DWORD dwFlags,
                              DWORD dwCaps)
{
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize                 = sizeof(ddsd);
    ddsd.dwFlags                = dwFlags;
    ddsd.ddsCaps.dwCaps         = dwCaps;
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitMaterial()
// Desc: Helper function called to build a D3DMATERIAL7 structure
//-----------------------------------------------------------------------------
VOID D3DUtil_InitMaterial(D3DMATERIAL7& mtrl, FLOAT r, FLOAT g, FLOAT b,
                           FLOAT a)
{
    ZeroMemory(&mtrl, sizeof(D3DMATERIAL7));
    mtrl.dcvDiffuse.r = mtrl.dcvAmbient.r = r;
    mtrl.dcvDiffuse.g = mtrl.dcvAmbient.g = g;
    mtrl.dcvDiffuse.b = mtrl.dcvAmbient.b = b;
    mtrl.dcvDiffuse.a = mtrl.dcvAmbient.a = a;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitLight()
// Desc: Initializes a D3DLIGHT7 structure
//-----------------------------------------------------------------------------
VOID D3DUtil_InitLight(D3DLIGHT7& light, D3DLIGHTTYPE ltType,
                        FLOAT x, FLOAT y, FLOAT z)
{
    ZeroMemory(&light, sizeof(D3DLIGHT7));
    light.dltType        = ltType;
    light.dcvDiffuse.r   = 1.0f;
    light.dcvDiffuse.g   = 1.0f;
    light.dcvDiffuse.b   = 1.0f;
    light.dcvSpecular    = light.dcvDiffuse;
    light.dvPosition.x   = light.dvDirection.x = x;
    light.dvPosition.y   = light.dvDirection.y = y;
    light.dvPosition.z   = light.dvDirection.z = z;
    light.dvAttenuation0 = 1.0f;
    light.dvRange        = D3DLIGHT_RANGE_MAX;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetViewMatrix()
// Desc: Given an eye point, a lookat point, and an up vector, this
//       function builds a 4x4 view matrix.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetViewMatrix(D3DMATRIX& mat, D3DVECTOR& vFrom,
                               D3DVECTOR& vAt, D3DVECTOR& vWorldUp)
{
    // Get the z basis vector, which points straight ahead. This is the
    // difference from the eyepoint to the lookat point.
    D3DVECTOR vView = vAt - vFrom;

    FLOAT fLength = Magnitude(vView);
    if (fLength < 1e-6f)
        return E_INVALIDARG;

    // Normalize the z basis vector
    vView /= fLength;

    // Get the dot product, and calculate the projection of the z basis
    // vector onto the up vector. The projection is the y basis vector.
    FLOAT fDotProduct = DotProduct(vWorldUp, vView);

    D3DVECTOR vUp = vWorldUp - fDotProduct * vView;

    // If this vector has near-zero length because the input specified a
    // bogus up vector, let's try a default up vector
    if (1e-6f > (fLength = Magnitude(vUp)))
    {
        vUp = D3DVECTOR(0.0f, 1.0f, 0.0f) - vView.y * vView;

        // If we still have near-zero length, resort to a different axis.
        if (1e-6f > (fLength = Magnitude(vUp)))
        {
            vUp = D3DVECTOR(0.0f, 0.0f, 1.0f) - vView.z * vView;

            if (1e-6f > (fLength = Magnitude(vUp)))
                return E_INVALIDARG;
        }
    }

    // Normalize the y basis vector
    vUp /= fLength;

    // The x basis vector is found simply with the cross product of the y
    // and z basis vectors
    D3DVECTOR vRight = CrossProduct(vUp, vView);

    // Start building the matrix. The first three rows contains the basis
    // vectors used to rotate the view to point at the lookat point
    D3DUtil_SetIdentityMatrix(mat);
    mat._11 = vRight.x;    mat._12 = vUp.x;    mat._13 = vView.x;
    mat._21 = vRight.y;    mat._22 = vUp.y;    mat._23 = vView.y;
    mat._31 = vRight.z;    mat._32 = vUp.z;    mat._33 = vView.z;

    // Do the translation values (rotations are still about the eyepoint)
    mat._41 = - DotProduct(vFrom, vRight);
    mat._42 = - DotProduct(vFrom, vUp);
    mat._43 = - DotProduct(vFrom, vView);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetProjectionMatrix()
// Desc: Sets the passed in 4x4 matrix to a perpsective projection matrix built
//       from the field-of-view (fov, in y), aspect ratio, near plane (D),
//       and far plane (F). Note that the projection matrix is normalized for
//       element [3][4] to be 1.0. This is performed so that W-based range fog
//       will work correctly.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetProjectionMatrix(D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect,
                                     FLOAT fNearPlane, FLOAT fFarPlane)
{
    if (fabs(fFarPlane-fNearPlane) < 0.01f)
        return E_INVALIDARG;
    if (fabs(sin(fFOV/2)) < 0.01f)
        return E_INVALIDARG;

    FLOAT w = fAspect * (cosf(fFOV/2)/sinf(fFOV/2));
    FLOAT h =   1.0f  * (cosf(fFOV/2)/sinf(fFOV/2));
    FLOAT Q = fFarPlane / (fFarPlane - fNearPlane);

    ZeroMemory(&mat, sizeof(D3DMATRIX));
    mat._11 = w;
    mat._22 = h;
    mat._33 = Q;
    mat._34 = 1.0f;
    mat._43 = -Q*fNearPlane;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetRotateXMatrix()
// Desc: Create Rotation matrix about X axis
//-----------------------------------------------------------------------------
VOID D3DUtil_SetRotateXMatrix(D3DMATRIX& mat, FLOAT fRads)
{
    D3DUtil_SetIdentityMatrix(mat);
    mat._22 =  cosf(fRads);
    mat._23 =  sinf(fRads);
    mat._32 = -sinf(fRads);
    mat._33 =  cosf(fRads);
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetRotateYMatrix()
// Desc: Create Rotation matrix about Y axis
//-----------------------------------------------------------------------------
VOID D3DUtil_SetRotateYMatrix(D3DMATRIX& mat, FLOAT fRads)
{
    D3DUtil_SetIdentityMatrix(mat);
    mat._11 =  cosf(fRads);
    mat._13 = -sinf(fRads);
    mat._31 =  sinf(fRads);
    mat._33 =  cosf(fRads);
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetRotateZMatrix()
// Desc: Create Rotation matrix about Z axis
//-----------------------------------------------------------------------------
VOID D3DUtil_SetRotateZMatrix(D3DMATRIX& mat, FLOAT fRads)
{
    D3DUtil_SetIdentityMatrix(mat);
    mat._11  =  cosf(fRads);
    mat._12  =  sinf(fRads);
    mat._21  = -sinf(fRads);
    mat._22  =  cosf(fRads);
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetRotationMatrix
// Desc: Create a Rotation matrix about vector direction
//-----------------------------------------------------------------------------
VOID D3DUtil_SetRotationMatrix(D3DMATRIX& mat, D3DVECTOR& vDir, FLOAT fRads)
{
    FLOAT     fCos = cosf(fRads);
    FLOAT     fSin = sinf(fRads);
    D3DVECTOR v    = Normalize(vDir);

    mat._11 = (v.x * v.x) * (1.0f - fCos) + fCos;
    mat._12 = (v.x * v.y) * (1.0f - fCos) - (v.z * fSin);
    mat._13 = (v.x * v.z) * (1.0f - fCos) + (v.y * fSin);

    mat._21 = (v.y * v.x) * (1.0f - fCos) + (v.z * fSin);
    mat._22 = (v.y * v.y) * (1.0f - fCos) + fCos ;
    mat._23 = (v.y * v.z) * (1.0f - fCos) - (v.x * fSin);

    mat._31 = (v.z * v.x) * (1.0f - fCos) - (v.y * fSin);
    mat._32 = (v.z * v.y) * (1.0f - fCos) + (v.x * fSin);
    mat._33 = (v.z * v.z) * (1.0f - fCos) + fCos;

    mat._14 = mat._24 = mat._34 = 0.0f;
    mat._41 = mat._42 = mat._43 = 0.0f;
    mat._44 = 1.0f;
}




//-----------------------------------------------------------------------------
// Name: _DbgOut()
// Desc: Outputs a message to the debug stream
//-----------------------------------------------------------------------------
HRESULT _DbgOut(TCHAR* strFile, DWORD dwLine, HRESULT hr, TCHAR* strMsg)
{
    TCHAR buffer[256];
    wsprintf(buffer, TEXT("%s(%ld): "), strFile, dwLine);
    OutputDebugString(buffer);
    OutputDebugString(strMsg);

    if (hr)
    {
        wsprintf(buffer, TEXT("(hr=%08lx)\n"), hr);
        OutputDebugString(buffer);
    }

    OutputDebugString(TEXT("\n"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\dolphmain.cpp ===
#define STRICT
#define D3D_OVERLOADS

#include "StdAfx.h"

//#include  "Settings.h"
//#include  "Resource.h"
//#include  "Material.h"

IDirectDrawSurface7*    CreateTextureFromFile(char* filename);

//******************************************************************************************

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(p) if(p){(p)->Release();(p)=NULL;}else{};
#endif


//******************************************************************************************

BOOL                g_bNeedZBuffer = TRUE;
DWORD               g_dwWidth,g_dwHeight;
const char*         g_szKeyname = "Software\\Microsoft\\D3DClock";
BOOL                g_bHardwareTL;
DWORD               g_dwVBMemType;

IDirect3D7*         g_pD3D=NULL;

DWORD               g_dwLastTickCount;

CSeaLife            g_SeaLife;

DWORD               g_dwBaseTime=0;

//Settings          g_Settings;

const float pi2 = 3.1415926536f*2.0f;

//******************************************************************************************

//******************************************************************************************
int WINAPI WinMain(HINSTANCE instance , HINSTANCE prev_instance , LPSTR cmd_line , int show)
{
    return DXSvrMain(instance , prev_instance , cmd_line , show);
}

//******************************************************************************************
LRESULT WINAPI ScreenSaverProc(HWND wnd , UINT msg , WPARAM wParam , LPARAM lParam)
{
    return DefDXScreenSaverProc(wnd , msg , wParam , lParam);
}

//******************************************************************************************
BOOL    ScreenSaverInit()
{
    // Get settings
    //g_Settings.ReadFromReg();

    // Grab pixel width and height of the window we're in
    g_pXContext->GetBufferSize(&g_dwWidth , &g_dwHeight);
    TRACE("Buffer size is (%d,%d)\n" , g_dwWidth , g_dwHeight);

    // Set up the projection matrix to something sensible
    D3DXMATRIX  projection;
    D3DXMatrixPerspectiveFovLH(&projection , 1.3f , float(g_dwHeight)/float(g_dwWidth) ,
                                0.1f , 100.0f);
    g_pDevice->SetTransform(D3DTRANSFORMSTATE_PROJECTION , projection);

    // Set up the initial camera to something sensible
    D3DXMATRIX  camera;
    D3DXMatrixLookAtLH(&camera , &D3DXVECTOR3(0,0,-2.3f) , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,1,0));
    g_pDevice->SetTransform(D3DTRANSFORMSTATE_VIEW , camera);

    // Set a matt white default material
    D3DMATERIAL7    mat;
    mat.ambient = mat.diffuse = D3DXCOLOR(1,1,1,0);
    mat.specular = mat.emissive = D3DXCOLOR(0,0,0,0);
    mat.power = 0;
    g_pDevice->SetMaterial(&mat);

    // Figure out if the device is HW or SW T&L
    D3DDEVICEDESC7  devdesc = {sizeof(devdesc)};
    g_pDevice->GetCaps(&devdesc);
    if (devdesc.dwDevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)
    {
        TRACE("Is hardware T&L\n");
        g_bHardwareTL = TRUE;
        g_dwVBMemType = 0;
    }
    else
    {
        TRACE("Is software T&L\n");
        g_bHardwareTL = FALSE;
        g_dwVBMemType = D3DVBCAPS_SYSTEMMEMORY;
    }

    // Grab the D3D object (we'll need it)
    g_pD3D = g_pXContext->GetD3D();


    // Set up some global renderstates
    g_pDevice->SetRenderState(D3DRENDERSTATE_DITHERENABLE , TRUE);
    g_pDevice->SetTextureStageState(0 , D3DTSS_MAGFILTER , D3DTFG_LINEAR);
    g_pDevice->SetTextureStageState(0 , D3DTSS_MINFILTER , D3DTFN_LINEAR);
    g_pDevice->SetTextureStageState(0 , D3DTSS_MIPFILTER , D3DTFP_LINEAR);
    g_pDevice->SetTextureStageState(1 , D3DTSS_MAGFILTER , D3DTFG_LINEAR);
    g_pDevice->SetTextureStageState(1 , D3DTSS_MINFILTER , D3DTFN_LINEAR);
    g_pDevice->SetTextureStageState(1 , D3DTSS_MIPFILTER , D3DTFP_LINEAR);
    g_pDevice->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE , TRUE);

    // Set up lighting
    g_pDevice->SetRenderState(D3DRENDERSTATE_LIGHTING , TRUE);
    g_pDevice->SetRenderState(D3DRENDERSTATE_AMBIENT , 0xff222222);
    g_pDevice->SetRenderState(D3DRENDERSTATE_AMBIENTMATERIALSOURCE , D3DMCS_MATERIAL);
    g_pDevice->SetRenderState(D3DRENDERSTATE_DIFFUSEMATERIALSOURCE , D3DMCS_MATERIAL);
    g_pDevice->SetRenderState(D3DRENDERSTATE_SPECULARMATERIALSOURCE , D3DMCS_MATERIAL);
    g_pDevice->SetRenderState(D3DRENDERSTATE_EMISSIVEMATERIALSOURCE , D3DMCS_MATERIAL);
    D3DLIGHT7   light;
    light.dltType = D3DLIGHT_POINT;
    light.dcvDiffuse = D3DXCOLOR(1,1,1,1);
    light.dcvSpecular = D3DXCOLOR(1,1,1,0);
    light.dcvAmbient = D3DXCOLOR(0,0,0,1);
    light.dvPosition = D3DXVECTOR3(0,0,-2);
    light.dvDirection = D3DXVECTOR3(0,0,1);
    light.dvRange = D3DLIGHT_RANGE_MAX;
    light.dvFalloff = 0;
    light.dvAttenuation0 = 0;
    light.dvAttenuation1 = 0;
    light.dvAttenuation2 = 0.3f;
    light.dvTheta = light.dvPhi = 0;
    g_pDevice->SetLight(0 , &light);
    g_pDevice->LightEnable(0 , TRUE);

    // Set texture transform (we always use the same one, if we do use one)
    D3DXMATRIX  texmatrix;
    D3DXMatrixIdentity(&texmatrix);
    texmatrix.m00 = texmatrix.m11 = 0.5f;
    texmatrix.m30 = texmatrix.m31 = 0.5f;
    g_pDevice->SetTransform(D3DTRANSFORMSTATE_TEXTURE0 , texmatrix);
    g_pDevice->SetTransform(D3DTRANSFORMSTATE_TEXTURE1 , texmatrix);

    g_dwLastTickCount = GetTickCount();
    g_dwBaseTime=timeGetTime();


    g_SeaLife.InitDeviceObjects(g_pDevice,NULL);
    g_SeaLife.OneTimeSceneInit();


    return TRUE;
}

//******************************************************************************************
void    ScreenSaverShutdown()
{

    g_SeaLife.DeleteDeviceObjects();
    g_SeaLife.FinalCleanup();


    SAFE_RELEASE(g_pD3D);
    //g_Settings.ReleaseMaterialSettings();
}


//******************************************************************************************
void    ScreenSaverDrawFrame()
{
    DWORD   tick = GetTickCount();
    DWORD   elapsed = tick - g_dwLastTickCount;
    g_dwLastTickCount = tick;
    float   felapsed = float(elapsed);

    static  float   theta,phi,xang,yang;

    FLOAT fTime = (timeGetTime() - g_dwBaseTime) * 0.001f;

    g_SeaLife.FrameMove(fTime);
    
    g_pXContext->RestoreSurfaces();


    //g_pXContext->Clear(D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER);
    //g_pDevice->BeginScene();

    //TODO DRAW
    g_SeaLife.Render(g_pDevice);

    
    //g_pDevice->EndScene();
    Flip();
}

BOOL    ScreenSaverDoConfig()
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\dxsvr.h ===
#if _MSC_VER > 1000
#pragma once
#endif
#ifndef _DXSVR_LIB_H
#define _DXSVR_LIB_H

#include    <d3dx.h>

//***************************************************************************************
// Forces the correct version of the library to be included

/*
#ifndef BUILDING_DXSVR_LIB
    #ifdef _DEBUG
        #pragma comment(lib,"dxsvrd.lib")
    #else
        #pragma comment(lib,"dxsvr.lib")
    #endif
#endif
*/

//***************************************************************************************
// These functions must be exported by the screensaver app

extern "C"  LRESULT WINAPI ScreenSaverProc(HWND , UINT , WPARAM , LPARAM);
extern "C"  BOOL    ScreenSaverInit();
extern "C"  void    ScreenSaverShutdown();
extern "C"  void    ScreenSaverDrawFrame();
extern "C"  int     ScreenSaverDoConfig();

//***************************************************************************************
// Principal functions exported by DXSave.lib

// WinMain replacement
extern "C" int  DXSvrMain(HINSTANCE instance , HINSTANCE , LPSTR cmd , int);

// Window procedure
extern "C"  LONG    DefDXScreenSaverProc(HWND hWnd , UINT message , WPARAM wParam , LPARAM lParam);

// Flip procedure. Must call this instead of just doing g_pXContext->UpdateFrame(0) to get preview window correct
extern "C"  void    Flip();

// Handy methods for reading and writing the registry. Use for storing settings. Note that DXSave.lib
// already reads and writes device and display mode settings
extern "C"
{
    GUID    GetRegistryGUID(LPCSTR szName , const GUID& guidDefault);
    void    SetRegistryGUID(LPCSTR szName , const GUID& guidValue);
    int     GetRegistryInt(LPCSTR szName , int iDefault);
    void    SetRegistryInt(LPCSTR szName , int iValue);
    void    GetRegistryString(LPCSTR szName , LPSTR szBuffer , DWORD dwBufferLength , LPCSTR szDefault);
    void    SetRegistryString(LPCTSTR szName , LPCTSTR szValue);
};

//***************************************************************************************
// Global variables exported by DXSave.lib

extern "C" HINSTANCE            g_hMainInstance;    // Main instance handle

extern "C" ID3DXContext*        g_pXContext;        // X-Library context
extern "C" IDirect3DDevice7*    g_pDevice;          // D3D Device

extern "C" BOOL                 g_bIsTest;          // Is in test mode?
extern "C" BOOL                 g_bIsPreview;       // Is in preview (mini-window) mode?
extern "C" HWND                 g_hWnd;             // Handle of the rendering window
extern "C" HWND                 g_hRefWindow;       // Reference window (for preview mode)

//***************************************************************************************
// These variables must be present in the screen saver application

// The name of the registry key to use, e.g. "Software\\MyCompany\\MyScreenSaver"
extern const char*  g_szKeyname;

//***************************************************************************************
// Utility functions exported by DXSave.lib. Most of these are straight from d3dutil in d3dframe

#if 0

// Fill out an identity matrix
extern "C"  void    D3DUtil_SetIdentityMatrix(D3DMATRIX& mat);

// Fill out a translation matrix
extern "C"  void    D3DUtil_SetTranslationMatrix(D3DMATRIX& mat , const D3DVECTOR& vTrans);

// Fill out a view matrix - can fail if vAt and vFrom are too close together (or identical)
extern "C"  HRESULT D3DUtil_SetViewMatrix(D3DMATRIX& mat, D3DVECTOR& vFrom, 
                                           D3DVECTOR& vAt, D3DVECTOR& vWorldUp);

// Fill out a projection matrix - can fail if far and near planes are too close together (or identical)
extern "C"  HRESULT D3DUtil_SetProjectionMatrix(D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect,
                                                 FLOAT fNearPlane, FLOAT fFarPlane);

// Fill out rotation matrix about principle axis
extern "C"  void    D3DUtil_SetRotateXMatrix(D3DMATRIX& mat, FLOAT fRads);
extern "C"  void    D3DUtil_SetRotateYMatrix(D3DMATRIX& mat, FLOAT fRads);
extern "C"  void    D3DUtil_SetRotateZMatrix(D3DMATRIX& mat, FLOAT fRads);

// Fill out rotation matrix about arbitrary axis vDir
extern "C"  void    D3DUtil_SetRotationMatrix(D3DMATRIX& mat, D3DVECTOR& vDir, FLOAT fRads);

#endif

//***************************************************************************************
// Useful TRACE debugging macro. Compiles out in release builds, otherwise can be used to output
// formatted text to the debugging stream. e.g. TRACE("Foo = %d. Bar = %s\n" , dwFoo , szBar);
#ifndef TRACE
    extern "C"  void    __TraceOutput(LPCTSTR pszFormat, ...);
    #ifdef  _DEBUG
        #define TRACE   __TraceOutput
    #else
        #define TRACE   sizeof
    #endif
#endif

//***************************************************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\fish.cpp ===
#define D3D_OVERLOADS

#include "StdAfx.h"

#include "D3DApp.h"
#include "D3DTextr.h"
#include "D3DUtil.h"
#include "D3DMath.h"
#include "D3DFile.h"
#include "resource.h"




/*
**-----------------------------------------------------------------------------
**  File:       fish.cpp
**  Purpose:    fish demo
**  Notes:      
**              and SetTransform
**
** Copyright (c) 1995 - 1997 by Microsoft, all rights reserved
**-----------------------------------------------------------------------------
*/
//#define FREQUENCY ((rnd()<0.01)||(abs(loc.x-goal.x)< 5.0f)||(abs(loc.y-goal.y)< 5.0f)||(abs(loc.z-goal.z)< 5.0f))
//#define FREQUENCY ((abs(loc.x-goal.x)< 5.0f)||(abs(loc.y-goal.y)< 5.0f)||(abs(loc.z-goal.z)< 5.0f))
#define FREQUENCY 0
#define SPEED   0.001f

/*
**-----------------------------------------------------------------------------
**  Include files
**-----------------------------------------------------------------------------
*/

typedef struct xxx_FISH {
    D3DVECTOR   loc,    // current location
                goal,   // current goal
                delta;  // current direction
    float       yaw, pitch, roll;
    float       dyaw;
} AFISH;


/*
**-----------------------------------------------------------------------------
**  Local variables
**-----------------------------------------------------------------------------
*/

const float pi = (float)3.1415;

//#define POINT_LINE_TEST
#define GROUND_GRID

//#define NUM_FISH    42
AFISH   FISH[NUM_FISH];

#define FISH_VERTICES   36
#define FISH_INDICES    60
D3DVERTEX   vFISH[FISH_VERTICES];

WORD        iFISH[FISH_INDICES];

#ifdef GROUND_GRID
    #define NUM_GRID    22
    #define GRID_WIDTH  800.0f
    D3DVERTEX   grid[NUM_GRID*NUM_GRID];
#endif

#ifdef POINT_LINE_TEST
    #define LOTS_OF_POINTS  (222)
    D3DVERTEX   points[LOTS_OF_POINTS];
#endif


D3DMATRIX       g_proj, g_view, g_world;    // Matrices

D3DLIGHT7       g_light;        // Structure defining the light


D3DMATRIX MatrixMult(D3DMATRIX a, D3DMATRIX b)
{
    D3DMATRIX result;
    D3DXMatrixMultiply((D3DXMATRIX*)&result,(D3DXMATRIX*)&a,(D3DXMATRIX*)&b);
    return result;
}


D3DMATRIX RotateXMatrix(float rot)
{
    D3DMATRIX result;
    D3DXMatrixRotationX((D3DXMATRIX*)&result,rot);
    return result;
}


D3DMATRIX RotateYMatrix(float rot)
{
    D3DMATRIX result;
    D3DXMatrixRotationY((D3DXMATRIX*)&result,rot);
    return result;
}

D3DMATRIX RotateZMatrix(float rot)
{
    D3DMATRIX result;
    D3DXMatrixRotationZ((D3DXMATRIX*)&result,rot);
    return result;
}

D3DMATRIX TranslateMatrix(D3DVECTOR v)
{
    D3DMATRIX result;
    D3DXMatrixTranslation((D3DXMATRIX*)&result,v.x,v.y,v.z);
    return result;
}

D3DMATRIX TranslateMatrix(float x, float y , float z)
{
    D3DMATRIX result;
    D3DXMatrixTranslation((D3DXMATRIX*)&result,x,y,z);
    return result;
}

/*
float rnd(void)
{
    return float(rand())/RAND_MAX;
}   
*/



  
/*
**-----------------------------------------------------------------------------
**  Name:       DrawFISH
**  Purpose:    Draws a single Paper FISH
**-----------------------------------------------------------------------------
*/

HRESULT DrawFISH (LPDIRECT3DDEVICE7 lpDev)
{
    HRESULT hResult;
    lpDev->SetTexture(0,NULL);
    hResult =lpDev->DrawIndexedPrimitive (D3DPT_TRIANGLELIST, D3DVT_VERTEX, (LPVOID)vFISH, FISH_VERTICES, iFISH, FISH_INDICES, D3DDP_WAIT);
    return hResult;
}


/*
**-----------------------------------------------------------------------------
**  Name:       D3DWindow::Init
**  Purpose:    Initialize scene objects
**-----------------------------------------------------------------------------
*/

HRESULT InitGeometry()
{


    //
    // generate the paper FISH data
    //

    // right wing top
    vFISH[ 0] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 1] = D3DVERTEX(D3DVECTOR(0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 2] = D3DVERTEX(D3DVECTOR(2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 3] = D3DVERTEX(D3DVECTOR(2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 4] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd());

    // right wing bottom
    vFISH[ 5] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 6] = D3DVERTEX(D3DVECTOR(0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 7] = D3DVERTEX(D3DVECTOR(2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 8] = D3DVERTEX(D3DVECTOR(2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[ 9] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd());

    // left wing bottom
    vFISH[10] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[11] = D3DVERTEX(D3DVECTOR(-0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[12] = D3DVERTEX(D3DVECTOR(-2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[13] = D3DVERTEX(D3DVECTOR(-2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd());
    vFISH[14] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd());

    // left wing top
    vFISH[15] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[16] = D3DVERTEX(D3DVECTOR(-0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[17] = D3DVERTEX(D3DVECTOR(-2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[18] = D3DVERTEX(D3DVECTOR(-2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd());
    vFISH[19] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd());
    
    // right body outside
    vFISH[20] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[21] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[22] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[23] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd());

    // right body inside
    vFISH[24] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[25] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[26] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[27] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd());

    // left body outside
    vFISH[28] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[29] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[30] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd());
    vFISH[31] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd());

    // left body inside
    vFISH[32] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[33] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[34] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd());
    vFISH[35] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd());

    // right wing top
    iFISH[ 0] = 0;
    iFISH[ 1] = 1;
    iFISH[ 2] = 4;
    iFISH[ 3] = 1;
    iFISH[ 4] = 2;
    iFISH[ 5] = 4;
    iFISH[ 6] = 4;
    iFISH[ 7] = 2;
    iFISH[ 8] = 3;

    // right wing bottom
    iFISH[ 9] = 5;
    iFISH[10] = 9;
    iFISH[11] = 6;
    iFISH[12] = 6;
    iFISH[13] = 9;
    iFISH[14] = 7;
    iFISH[15] = 7;
    iFISH[16] = 9;
    iFISH[17] = 8;

    // left wing top
    iFISH[18] = 10;
    iFISH[19] = 11;
    iFISH[20] = 14;
    iFISH[21] = 11;
    iFISH[22] = 12;
    iFISH[23] = 14;
    iFISH[24] = 14;
    iFISH[25] = 12;
    iFISH[26] = 13;

    // left wing bottom
    iFISH[27] = 15;
    iFISH[28] = 19;
    iFISH[29] = 16;
    iFISH[30] = 16;
    iFISH[31] = 19;
    iFISH[32] = 17;
    iFISH[33] = 17;
    iFISH[34] = 19;
    iFISH[35] = 18;

    // right body outside
    iFISH[36] = 20;
    iFISH[37] = 23;
    iFISH[38] = 21;
    iFISH[39] = 21;
    iFISH[40] = 23;
    iFISH[41] = 22;

    // right body inside
    iFISH[42] = 24;
    iFISH[43] = 25;
    iFISH[44] = 27;
    iFISH[45] = 25;
    iFISH[46] = 26;
    iFISH[47] = 27;

    // left body outside
    iFISH[48] = 28;
    iFISH[49] = 29;
    iFISH[50] = 31;
    iFISH[51] = 29;
    iFISH[52] = 30;
    iFISH[53] = 31;

    // left body inside
    iFISH[54] = 32;
    iFISH[55] = 35;
    iFISH[56] = 33;
    iFISH[57] = 33;
    iFISH[58] = 35;
    iFISH[59] = 34;

    // seed the random number generator
    srand (time (0));

    for (int i=0; i<NUM_FISH; i++) 
    {
        FISH[i].loc = D3DVECTOR(0.0f, 0.0f, 0.0f);
        FISH[i].goal = D3DVECTOR(XEXTENT, YEXTENT,ZEXTENT);
        FISH[i].delta = D3DVECTOR(0.0f, 0.0f, 1.0f);
        FISH[i].yaw = 0.0f;
        FISH[i].pitch = 0.0f;
        FISH[i].roll = 0.0f;
        FISH[i].dyaw = 0.0f;
    }




    float   size = GRID_WIDTH/(NUM_GRID-1.0f);
    float   offset = GRID_WIDTH/2.0f;
    for (i=0; i<NUM_GRID; i++) 
    {
        for (int j=0; j<NUM_GRID; j++) 
        {
            grid[j+i*NUM_GRID] = D3DVERTEX(D3DVECTOR(i*size-offset, 0.0f, j*size-offset), Normalize(D3DVECTOR(0.0f, 1.0f, 0.0f)), 0.0f, 0.0f);
        }
    }

    return S_OK;
} 



  
/*
**-----------------------------------------------------------------------------
**  Name:       D3DScene::Render
**  Purpose:    Draws scene
**-----------------------------------------------------------------------------
*/

HRESULT PlayWithFish(LPDIRECT3DDEVICE7 lpDev)
{
    HRESULT hResult;
    
    // play with FISH
    static float        tic = 0.0f;
    static float        speed=SPEED;
    static float        angle_tweak = TWEAK;
    static D3DVECTOR    z_ward(0.0f, 0.0f, 1.0f);

    for (int i=0; i<NUM_FISH; i++) 
    {
        D3DVECTOR   offset;

        // tweek orientation based on last position and goal
        offset = FISH[i].goal - FISH[i].loc;

        // first, tweak the pitch
        if (offset.y > 1.0) {           // we're too low
            FISH[i].pitch += angle_tweak;
            if (FISH[i].pitch > 0.8f)
                FISH[i].pitch = 0.8f;
        } else if (offset.y < -1.0) {   // we're too high
            FISH[i].pitch -= angle_tweak;
            if (FISH[i].pitch < -0.8f)
                FISH[i].pitch = -0.8f;
        } else {
            // add damping
            FISH[i].pitch *= 0.95f;
        }

        // now figure out yaw changes
        offset.y = 0.0f;  FISH[i].delta.y = 0.0f;
        FISH[i].delta = Normalize (FISH[i].delta);
        offset = Normalize (offset);
        float   dot = DotProduct (offset, FISH[i].delta);
        offset = CrossProduct (offset, FISH[i].delta);
        dot = (1.0f-dot)/2.0f * angle_tweak * 10.0f;
        if (offset.y > 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f + dot) * 0.1f;
        } else if (offset.y < 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f - dot) * 0.1f;
        }
        FISH[i].yaw += FISH[i].dyaw;
        FISH[i].roll = -FISH[i].dyaw * 9.0f;
        
        D3DVECTOR loc=FISH[i].loc;
        D3DVECTOR goal=FISH[i].goal;

        if (FREQUENCY) 
        {
            FISH[i].goal = D3DVECTOR(XEXTENT,YEXTENT,ZEXTENT);
        }

        

        g_world =         
            MatrixMult(
                MatrixMult (
                    RotateYMatrix (FISH[i].yaw), 
                    RotateXMatrix (FISH[i].pitch)
            ), 
                RotateZMatrix (FISH[i].roll)            
        );
        
        // get delta buy grabbing the z axis out of the transform
        FISH[i].delta[0] = g_world(2, 0);
        FISH[i].delta[1] = g_world(2, 1);
        FISH[i].delta[2] = g_world(2, 2);
        // update position
        FISH[i].loc += speed * FISH[i].delta;

    
        

        D3DMATRIX scaleMatrix;
        D3DXMatrixScaling((D3DXMATRIX*)&scaleMatrix,0.1f,0.1f,0.1f);

        // first scale then translate into place, then set orientation, then scale
        g_world = MatrixMult(scaleMatrix,TranslateMatrix (FISH[i].loc));
        g_world = MatrixMult (g_world, MatrixMult (MatrixMult (RotateYMatrix (FISH[i].yaw), RotateXMatrix (FISH[i].pitch)), RotateZMatrix (FISH[i].roll)));

            
        // apply the world matrix
        hResult = lpDev->SetTransform (D3DTRANSFORMSTATE_WORLD, &g_world);
        if (FAILED (hResult))
            return hResult;
    
        // display the vFISH
        DrawFISH (lpDev);
    }   // end of loop for each vFISH

    tic += 0.01f;

    
    return DD_OK;
} 




HRESULT PlayWithGeometry(LPDIRECT3DDEVICE7 lpDev,CD3DFile* pFileObject)
{
    HRESULT hResult;
    
    // play with FISH
    static float        tic = 0.0f;
    static float        speed=2.0f;
    static float        angle_tweak = 0.02f;
    static D3DVECTOR    z_ward(0.0f, 0.0f, 1.0f);

    for (int i=0; i<NUM_FISH; i++) 
    {
        D3DVECTOR   offset;

        // tweek orientation based on last position and goal
        offset = FISH[i].goal - FISH[i].loc;

        // first, tweak the pitch
        if (offset.y > 1.0) {           // we're too low
            FISH[i].pitch += angle_tweak;
            if (FISH[i].pitch > 0.8f)
                FISH[i].pitch = 0.8f;
        } else if (offset.y < -1.0) {   // we're too high
            FISH[i].pitch -= angle_tweak;
            if (FISH[i].pitch < -0.8f)
                FISH[i].pitch = -0.8f;
        } else {
            // add damping
            FISH[i].pitch *= 0.95f;
        }

        // now figure out yaw changes
        offset.y = 0.0f;  FISH[i].delta.y = 0.0f;
        FISH[i].delta = Normalize (FISH[i].delta);
        offset = Normalize (offset);
        float   dot = DotProduct (offset, FISH[i].delta);
        offset = CrossProduct (offset, FISH[i].delta);
        dot = (1.0f-dot)/2.0f * angle_tweak * 10.0f;
        if (offset.y > 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f + dot) * 0.1f;
        } else if (offset.y < 0.01) {
            FISH[i].dyaw = (FISH[i].dyaw*9.0f - dot) * 0.1f;
        }
        FISH[i].yaw += FISH[i].dyaw;
        FISH[i].roll = -FISH[i].dyaw * 9.0f;

        if (rnd() < 0.03) 
        {
            FISH[i].goal = D3DVECTOR(10.0f*(rnd()-rnd()), 10.0f*(rnd()-rnd()), rnd()*20.0f - 10.0f);
        }

        D3DMATRIX scaleMatrix;
        D3DXMatrixScaling((D3DXMATRIX*)&scaleMatrix,0.1f,0.1f,0.1f);


        // build the world matrix for the vFISH
        g_world = MatrixMult(
            MatrixMult (RotateYMatrix (FISH[i].yaw), 
            RotateXMatrix (FISH[i].pitch)), RotateZMatrix (FISH[i].roll)
     );
        
        // get delta buy grabbing the z axis out of the transform
        FISH[i].delta[0] = g_world(2, 0);
        FISH[i].delta[1] = g_world(2, 1);
        FISH[i].delta[2] = g_world(2, 2);
        // update position
        FISH[i].loc += speed * FISH[i].delta;

    
        // first translate into place, then set orientation, then scale
        g_world =  MatrixMult (g_world, MatrixMult (MatrixMult (RotateYMatrix (FISH[i].yaw), RotateXMatrix (FISH[i].pitch)), RotateZMatrix (FISH[i].roll)));
        g_world =  MatrixMult(scaleMatrix,g_world);

        //g_world = MatrixMult (g_world, MatrixMult (MatrixMult (RotateYMatrix (FISH[i].yaw), RotateXMatrix (FISH[i].pitch)), RotateZMatrix (FISH[i].roll)));
        //g_world = MatrixMult (g_world, Scale(5.0f));
        
        // apply the world matrix
        hResult = lpDev->SetTransform (D3DTRANSFORMSTATE_WORLD, &g_world);
        if (FAILED (hResult))
            return hResult;

        pFileObject->Render(lpDev);
        // display the vFISH
        //DrawFISH (lpDev);
    }   // end of loop for each vFISH

/*
    g_world = TranslateMatrix (0.0f, -60.0f, 0.0f);
    hResult = lpDev->SetTransform (D3DTRANSFORMSTATE_WORLD, &g_world);
    if (FAILED (hResult))
        return hResult;

    hResult = lpDev->DrawPrimitive (D3DPT_LINELIST, D3DVT_VERTEX, (LPVOID)grid, NUM_GRID*NUM_GRID, D3DDP_WAIT);
    if (FAILED (hResult))
        return hResult;
    
    g_world = MatrixMult (g_world, RotateYMatrix (pi/2.0f));
    hResult = lpDev->SetTransform (D3DTRANSFORMSTATE_WORLD, &g_world);
    if (FAILED (hResult))
        return hResult;
    
    hResult = lpDev->DrawPrimitive (D3DPT_LINELIST, D3DVT_VERTEX, (LPVOID)grid, NUM_GRID*NUM_GRID, D3DDP_WAIT);
    if (FAILED (hResult))
        return hResult;
    
*/
    tic += 0.01f;

    
    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.


    BryanSt 11/22/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "StdAfx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\fish.h ===
#ifndef PPLANE_H
#define PPLANE_H
/*
**-----------------------------------------------------------------------------
** File:       PPlane.h
** Purpose:    Sample showing DrawPrimitive functionality 
**
** Copyright (c) 1995 - 1997 by Microsoft, all rights reserved
**-----------------------------------------------------------------------------
*/

/*
**-----------------------------------------------------------------------------
**  Include files
**-----------------------------------------------------------------------------
*/
#include "Common.h"


/*
**-----------------------------------------------------------------------------
**  Type definitions
**-----------------------------------------------------------------------------
*/

typedef struct t_plane {
    D3DVECTOR   loc,    // current location
                goal,   // current goal
                delta;  // current direction
    float       yaw, pitch, roll;
    float       dyaw;
} Plane;


/*
**-----------------------------------------------------------------------------
**  End of File
**-----------------------------------------------------------------------------
*/
#endif // PPLANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\dxinit.cpp ===
#include "stdafx.h"
#include "DXSvr.h"

//***************************************************************************************

#define SAFE_RELEASE(p) if ((p)!=NULL) { (p)->Release(); (p)=NULL; };

//***************************************************************************************

IDirectDrawSurface7*    g_pPrimarySurface = NULL;
IDirectDrawSurface7*    g_pBackSurface = NULL;
IDirectDraw7*           g_pDD = NULL;
IDirectDrawClipper*     g_pClipper = NULL;

extern BOOL g_bWait;

//***************************************************************************************
BOOL    InitD3D(HWND hWnd)
{
    // Initialise X-Library
    if (FAILED(D3DXInitialize()))
        return FALSE;

    if (FAILED(D3DXCreateContext(D3DX_DEFAULT , g_bIsPreview||g_bIsTest ? 0 : D3DX_CONTEXT_FULLSCREEN , hWnd ,
                                   D3DX_DEFAULT , D3DX_DEFAULT , &g_pXContext)))
        return FALSE;

    g_pDevice = g_pXContext->GetD3DDevice();
    g_pBackSurface = g_pXContext->GetBackBuffer(0);
    g_pPrimarySurface = g_pXContext->GetPrimary();
    g_pDD = g_pXContext->GetDD();

    if (g_bIsPreview)
    {
        g_pDD->CreateClipper(0 , &g_pClipper , 0);
        g_pClipper->SetHWnd(0 , g_hRefWindow);
    }

    return TRUE;
}

//***************************************************************************************
void    KillD3D()
{
    SAFE_RELEASE(g_pClipper);
    SAFE_RELEASE(g_pDD);
    SAFE_RELEASE(g_pPrimarySurface);
    SAFE_RELEASE(g_pBackSurface);
    SAFE_RELEASE(g_pDevice);
    SAFE_RELEASE(g_pXContext);
    D3DXUninitialize();
}

//***************************************************************************************
void    RestoreSurfaces()
{
    g_pXContext->RestoreSurfaces();
}

//***************************************************************************************
void    Flip()
{
    if (g_pXContext == NULL)
        return;

    if (g_bIsPreview)
    {
        RECT    rect;
        GetClientRect(g_hRefWindow , &rect);
        ClientToScreen(g_hRefWindow , (POINT*)&rect);
        rect.right += rect.left; rect.bottom += rect.top;
        g_pPrimarySurface->SetClipper(g_pClipper);
        HRESULT rc;
        if (FAILED(rc = g_pPrimarySurface->Blt(&rect , g_pBackSurface , NULL , DDBLT_WAIT , NULL)))
            g_bWait = TRUE;

        g_pDD->WaitForVerticalBlank(DDWAITVB_BLOCKBEGIN , NULL);
    }
    else
    {
        g_pXContext->UpdateFrame(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 11/22/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "StdAfx.h"

#ifndef MYGUIDS_H
#define MYGUIDS_H

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif


#include "rmxfguid.h"
#include "rmxftmpl.h"



#undef MIDL_DEFINE_GUID

#endif // MYGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winmain.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_MAIN_ACCEL                  113
#define IDR_MENU                        141
#define IDR_POPUP                       142
#define IDD_ABOUT                       143
#define IDD_CHANGEDEVICE                144
#define IDC_CURSOR1                     144
#define IDC_DEVICE_COMBO                1000
#define IDC_MODE_COMBO                  1001
#define IDC_WINDOWED_CHECKBOX           1012
#define IDC_STEREO_CHECKBOX             1013
#define IDC_FULLSCREEN_TEXT             1014
#define IDM_ABOUT                       40001
#define IDM_CHANGEDEVICE                40002
#define IDM_TOGGLEFULLSCREEN            40003
#define IDM_TOGGLESTART                 40004
#define IDM_SINGLESTEP                  40005
#define IDM_EXIT                        40006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        145
#define _APS_NEXT_COMMAND_VALUE         40010
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\main.cpp ===
#include    "stdafx.h"

#include    "DXSvr.h"
#include    <regstr.h>

//***************************************************************************************
// Globals

HINSTANCE               g_hMainInstance;    // Main instance handle
BOOL                    g_bIsTest;          // Is in test mode?
BOOL                    g_bIsPreview;       // Is in preview mode?
HWND                    g_hWnd;             // Handle of the rendering window
HWND                    g_hRefWindow;       // Reference window (for preview mode)
LPSTR                   g_szCommandLine;    // Command line

BOOL                    g_bCheckingPassword;
BOOL                    g_bShuttingDown;

ID3DXContext*           g_pXContext;        // X-Library context
IDirect3DDevice7*       g_pDevice;          // D3D Device

//***************************************************************************************

BOOL                    g_bIsWin9x;
BOOL                    g_bWait;

DWORD                   g_dwMouseMoveCount;

BOOL    InitD3D(HWND hWnd);
void    KillD3D();

//***************************************************************************************
// Password stuff

const TCHAR szScreenSaverKey[] = REGSTR_PATH_SCREENSAVE; 
TCHAR szPasswordActiveValue[] = REGSTR_VALUE_USESCRPASSWORD; 
const TCHAR szPasswordValue[] = REGSTR_VALUE_SCRPASSWORD; 

TCHAR szPwdDLL[] = TEXT("PASSWORD.CPL"); 
char szFnName[] = "VerifyScreenSavePwd"; 
 
typedef BOOL (FAR PASCAL * VERIFYPWDPROC) (HWND);

VERIFYPWDPROC   VerifyPassword = NULL;
HINSTANCE       hInstPwdDLL = NULL;

static LPTSTR szMprDll = TEXT("MPR.DLL"); 
static LPTSTR szProviderName = TEXT("SCRSAVE");
 
static const char szPwdChangePW[] = "PwdChangePasswordA";

typedef DWORD (FAR PASCAL *PWCHGPROC)(LPCTSTR, HWND, DWORD, LPVOID);

//***************************************************************************************
void ScreenSaverChangePassword(HWND hParent) 
{ 
   HINSTANCE mpr = LoadLibrary(szMprDll); 
 
   if (mpr) 
   { 
      PWCHGPROC pwd = (PWCHGPROC)GetProcAddress(mpr, szPwdChangePW); 
 
      if (pwd) 
         pwd(szProviderName, hParent, 0, NULL); 
 
      FreeLibrary(mpr); 
   } 
} 

//***************************************************************************************
void LoadPwdDLL() 
{ 
    // Don't bother unless we're on 9x 
    if (!g_bIsWin9x) 
        return; 
  
    // look in registry to see if password turned on, otherwise don't 
    // bother to load password handler DLL 
    HKEY hKey; 
    if (RegOpenKey(HKEY_CURRENT_USER,szScreenSaverKey,&hKey) == 
        ERROR_SUCCESS) 
    { 
        DWORD dwVal,dwSize=sizeof(dwVal); 
 
        if ((RegQueryValueEx(hKey,szPasswordActiveValue, 
            NULL,NULL,(BYTE *) &dwVal,&dwSize) == ERROR_SUCCESS) 
            && dwVal) 
        { 
 
            // try to load the DLL that contains password proc. 
            hInstPwdDLL = LoadLibrary(szPwdDLL); 
            if (hInstPwdDLL) 
            { 
                VerifyPassword = (VERIFYPWDPROC) GetProcAddress(hInstPwdDLL, szFnName); 
            } 
        } 
 
        RegCloseKey(hKey); 
    } 
 
} 


//***************************************************************************************
int DXSvrMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR pszCmdLine, int)
{
    // Store our instance handle for later use
    g_hMainInstance = hInstance;

    // Figure out if we're on 9x or NT (password stuff is different)
    OSVERSIONINFO osvi; 
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    g_bIsWin9x = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    // Load the password DLL
    LoadPwdDLL();
 
    // Parse the command line 
    g_szCommandLine = pszCmdLine;
    LPCSTR pszSwitch = StrChrA(pszCmdLine, '/');
    
    if (pszSwitch == NULL)
    {
        return ScreenSaverDoConfig();
    }
    else
    {
        pszSwitch++;    // Skip past the '/'.
        switch (*pszSwitch)
        {
        case 't':
        case 'T':
            g_bIsTest = TRUE;
            break;

        case 'p':
        case 'P':
            while (*pszSwitch && !isdigit(*pszSwitch))
                pszSwitch++;
            if (isdigit(*pszSwitch))
            {
                LONGLONG llSize;

                if (StrToInt64ExA(pszSwitch, 0, &llSize))
                {
                    g_hRefWindow = HWND(llSize);
                }
                if (g_hRefWindow != NULL)
                    g_bIsPreview = TRUE;
            }
            break;

        case 'a':
        case 'A':
            while (*pszSwitch && !isdigit(*pszSwitch))
                pszSwitch++;
            if (isdigit(*pszSwitch))
            {
                LONGLONG llSize;

                if (StrToInt64ExA(pszSwitch, 0, &llSize))
                {
                    g_hRefWindow = HWND(llSize);
                }
            }
            ScreenSaverChangePassword(g_hRefWindow);
            return 0;

        case 'c':
        case 'C':
        return ScreenSaverDoConfig();
        }
    }

    // Register the window class
    WNDCLASS    cls;
    cls.hCursor        = NULL; 
    cls.hIcon          = NULL; 
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = TEXT("DXSvrWindow"); 
    cls.hbrBackground  = (HBRUSH) GetStockObject(BLACK_BRUSH);
    cls.hInstance      = g_hMainInstance; 
    cls.style          = CS_VREDRAW|CS_HREDRAW|CS_SAVEBITS|CS_DBLCLKS;
    cls.lpfnWndProc    = ScreenSaverProc;
    cls.cbWndExtra     = 0; 
    cls.cbClsExtra     = 0; 
    RegisterClass(&cls);

    g_bWait = TRUE;

    // Create the window
    RECT    rect;
    if (g_bIsTest)
    {
        rect.left = rect.top = 40;
        rect.right = rect.left+640;
        rect.bottom = rect.top+480;
        AdjustWindowRect(&rect , WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP , FALSE);
        g_hWnd = CreateWindow(TEXT("DXSvrWindow"), TEXT("ScreenSaverTest"),
                               WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP , rect.left , rect.top ,
                               rect.right-rect.left , rect.bottom-rect.top , NULL ,
                               NULL , g_hMainInstance , NULL);
    }
    else if (g_bIsPreview)
    {
        GetClientRect(g_hRefWindow , &rect);
        ClientToScreen(g_hRefWindow , (POINT*)(&rect));
        rect.right += rect.left; rect.bottom += rect.top;
        AdjustWindowRect(&rect , WS_VISIBLE|WS_CHILD , FALSE);
        g_hWnd = CreateWindow(TEXT("DXSvrWindow"), TEXT("ScreenSaverPreview"),
                                WS_VISIBLE|WS_CHILD , rect.left , rect.top ,
                                rect.right-rect.left , rect.bottom-rect.top , g_hRefWindow ,
                                NULL , g_hMainInstance , NULL);
    }
    else
    {
        g_hWnd = CreateWindowEx(WS_EX_TOPMOST , TEXT("DXSvrWindow"), TEXT("ScreenSaver"),
                                 WS_MAXIMIZE|WS_VISIBLE|WS_POPUP , 0 , 0 , 640 , 480 , NULL ,
                                 NULL , g_hMainInstance , NULL);
    }

    if (g_hWnd == NULL)
        return 0;

    // Prevent task switching if we're on 9x
    BOOL    dummy;
    if (!g_bIsTest && !g_bIsPreview && g_bIsWin9x)
        SystemParametersInfo(SPI_SCREENSAVERRUNNING, TRUE, &dummy, 0); 

    // Pump messages
    MSG msg;
    msg.message = 0;
    while (msg.message != WM_QUIT)
    {
        if (g_bWait)
        {
            GetMessage(&msg , NULL , 0 , 0);
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            g_bWait = FALSE;
        }
        else
        {
            if (PeekMessage(&msg , NULL , 0 , 0 , PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
                ScreenSaverDrawFrame();
        }
    }

    // Allow task switching if we disabled it
    if (!g_bIsTest && !g_bIsPreview && g_bIsWin9x)
        SystemParametersInfo(SPI_SCREENSAVERRUNNING, FALSE, &dummy, 0); 

    // Unload the password DLL
    if (hInstPwdDLL)
        FreeLibrary(hInstPwdDLL);

    // Done
    return 0;
}


void _stdcall ModuleEntry(void)
{
    CHAR szCmdLine[MAX_PATH];
    LPCTSTR pszCmdLine = GetCommandLine();

    SHTCharToAnsi(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    int nReturn = DXSvrMain(GetModuleHandle(NULL), NULL, szCmdLine, SW_SHOWDEFAULT);
    ExitProcess(nReturn);
}


//***************************************************************************************
BOOL    DoPasswordCheck(HWND hWnd) 
{
    // Don't check if we're already checking or being shut down
    if (g_bCheckingPassword || g_bShuttingDown)
        return FALSE;

    // If no VerifyPassword function, then no password is set or we're on NT. Either way just
    // say the password was okay.
    if (VerifyPassword == NULL)
        return TRUE;

    g_bCheckingPassword = TRUE;

    if (g_pXContext != NULL)
    {
        IDirectDraw7*   dd = g_pXContext->GetDD();
        if (dd != NULL)
        {
            dd->FlipToGDISurface();
            dd->Release();
        }
    }


    BOOL    password_okay = VerifyPassword(hWnd);
    g_bCheckingPassword = FALSE;

    if (!password_okay)
        SetCursor(NULL);

    g_dwMouseMoveCount = 0;

    return password_okay;
} 

//***************************************************************************************
LONG DefDXScreenSaverProc(HWND hWnd , UINT message , WPARAM wParam , LPARAM lParam)
{
    switch (message)
    {
        case WM_CREATE:
            if (!InitD3D(hWnd))
                return -1;
            if (!ScreenSaverInit())
                return -1;
            g_bWait = FALSE;
            break;

        case WM_DESTROY:
            ScreenSaverShutdown();
            KillD3D();
            PostQuitMessage(0);
            g_bWait = TRUE;
            break;

        case WM_SETCURSOR:
            SetCursor(NULL);
            return TRUE;

        case WM_CHAR:
            if (g_bIsTest)
                DestroyWindow(hWnd);
            else if (!g_bIsPreview)
                PostMessage(hWnd , WM_CLOSE , 0 , 0);
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            BeginPaint(hWnd , &ps);
            EndPaint(hWnd , &ps);
            return 0;
        }

        case WM_ERASEBKGND:
            return TRUE;

        case WM_MOUSEMOVE:
            if (!g_bIsTest && !g_bIsPreview)
            {
                g_dwMouseMoveCount++;
                if (g_dwMouseMoveCount >= 3)
                    PostMessage(hWnd , WM_CLOSE , 0 , 0);
            }
            break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            if (!g_bIsTest && !g_bIsPreview)
                PostMessage(hWnd , WM_CLOSE , 0 , 0);
            break;

        case WM_CLOSE:
            if (g_bIsWin9x && !g_bIsPreview)
            {
                if (!DoPasswordCheck(hWnd))
                    return FALSE;
            }
            break;

        case WM_SYSCOMMAND: 
            if (!g_bIsPreview && !g_bIsTest)
            {
                switch (wParam)
                {
                    case SC_NEXTWINDOW:
                    case SC_PREVWINDOW:
                    case SC_SCREENSAVE:
                        return FALSE;
                };
            }
            break;
    }

    return DefWindowProc(hWnd , message , wParam , lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  DXSvr.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
#define AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN       // Exclude rarely-used stuff from Windows headers
//#define STRICT
#define D3D_OVERLOADS

#include <windows.h>
#include <commdlg.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <mmsystem.h>
#include <math.h>
#include <time.h>

#include <ddraw.h>
#include <d3d.h>
#include <d3dxmath.h>

#include "dxsvr.h"
#include "D3DFile.h"
#include "D3DEnum.h"
#include "sealife.h"

#pragma warning(disable:4244)
#pragma warning(disable:4042)

float rnd(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))
#endif



#endif // !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\sealife.h ===
#ifndef SEALIFE_H
#define SEALIFE_H

#include "D3DEnum.h"

#define WATER_COLOR          0x00008899

#define NUM_FISH        44
#define NUM_DOLPHINS    5
#define NUM_CAMFISH     1

#define NUM_FISH1       50


#define XEXTENT (40.0f*(rnd()-rnd()))
#define YEXTENT (10.0f*(rnd()))
#define ZEXTENT (30.0f*(rnd()))
#define DOLPHINSPEED    35  //0.01f
#define FISHSPEED   40  //0.01f

#define TWEAK   0.005f
#define TWEAKFISH   0.05f

#define TURNDELTADOLPHIN    .1
#define TURNDELTAFISH       .1

#define PITCHCHANGE     (3.1415 / 5000)
#define PITCHDELTA      1

#define PITCHCHANGEFISH (3.1415 / 500)
#define PITCHDELTAFISH  2

#define INITPITCH       0


#define DOLPHINUPDOWN(t) (-2*(float)cos(t)/6)
#define FISHWIGGLE  (3.1415/8)*sin(fTimeKey*10)
#define FISHTYPE_DOLPHIN 0
#define FISHTYPE_FISH1 1
#define FISHTYPE_CAMERA 2

typedef struct t_FISH 
{
    D3DVECTOR loc;
    D3DVECTOR goal;
    D3DVECTOR dir;
    D3DMATRIX matrix;
    float angle_tweak;
    float turndelta;
    float yaw;
    float pitch;
    float pitchchange;
    float pitchdelta;
    float roll;
    float weight;
    float speed;
    float upDownFactor;     
    DWORD type;
} FISHSTRUCT;


//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Main class to run this application. Most functionality is inherited
//       from the CD3DApplication base class.
//-----------------------------------------------------------------------------
class CSeaLife
{
    // The DirectX file objects
    CD3DFile* m_pDolphinGroupObject;
    CD3DFile* m_pDolphinObject;
    CD3DFile* m_pFloorObject;
    CD3DFile* m_pFish1Object;

    // Vertex data from the file objects
    D3DVERTEX* m_pDolphinVertices;
    D3DVERTEX* m_pDolphin1Vertices;
    D3DVERTEX* m_pDolphin2Vertices;
    D3DVERTEX* m_pDolphin3Vertices;
    DWORD      m_dwNumDolphinVertices;
    
    D3DVERTEX* m_pFloorVertices;
    DWORD      m_dwNumFloorVertices;
    D3DMATRIX  m_matDolphin;
    D3DMATRIX  m_matFloor;
    FISHSTRUCT m_FishState[NUM_FISH];


    LPDIRECT3DDEVICE7    m_pd3dDevice;
    D3DEnum_DeviceInfo  *m_pDeviceInfo;

public:
    //SeaLife();
    HRESULT OneTimeSceneInit();
    HRESULT InitDeviceObjects(LPDIRECT3DDEVICE7,D3DEnum_DeviceInfo*);
    HRESULT DeleteDeviceObjects();
    HRESULT Render(LPDIRECT3DDEVICE7);
    HRESULT FrameMove(FLOAT);
    HRESULT FinalCleanup();     

    
};


#endif // SEALIFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\regist.cpp ===
#include "stdafx.h"
#include "DXSvr.h"

/*
//***************************************************************************************
GUID    GetRegistryGUID(LPCSTR szName , const GUID& guidDefault)
{
    HKEY    hKey;
    GUID    guidReturn = guidDefault;

    if (RegOpenKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
    {
        GUID    guidValue;
        DWORD   dwValueSize = sizeof(GUID);
        DWORD   dwType;

        if ((RegQueryValueEx(hKey , szName , 0 , &dwType , (LPBYTE) &guidValue , &dwValueSize) == ERROR_SUCCESS)
             && (dwType == REG_BINARY || dwType == REG_NONE))
        {
            guidReturn = guidValue;
        }
        RegCloseKey(hKey);
    }

    return guidReturn;
}

//***************************************************************************************
void    SetRegistryGUID(LPCSTR szName , const GUID& guidValue)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    
    if ((RegCreateKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , NULL , REG_OPTION_NON_VOLATILE ,
                          KEY_WRITE , NULL , &hKey , &dwDisposition) == ERROR_SUCCESS))
    {
        RegSetValueEx(hKey , szName , 0 , REG_BINARY , (CONST BYTE*)(&guidValue) , sizeof(GUID));
        RegCloseKey(hKey);
    }
}

//***************************************************************************************
int     GetRegistryInt(LPCSTR szName , int iDefault)
{
    HKEY    hKey;
    int     iReturn = iDefault;

    if (RegOpenKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
    {
        int     iValue;
        DWORD   dwValueSize = sizeof(int);
        DWORD   dwType;

        if ((RegQueryValueEx(hKey , szName , 0 , &dwType , (LPBYTE) &iValue , &dwValueSize) == ERROR_SUCCESS)
             && dwType == REG_DWORD)
        {
            iReturn = iValue;
        }

        RegCloseKey(hKey);
    }

    return iReturn;
}

//***************************************************************************************
void    SetRegistryInt(LPCSTR szName , int iValue)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    
    if ((RegCreateKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , NULL , REG_OPTION_NON_VOLATILE ,
                          KEY_WRITE , NULL , &hKey , &dwDisposition) == ERROR_SUCCESS))
    {
        RegSetValueEx(hKey , szName , 0 , REG_DWORD , (CONST BYTE*)(&iValue) , sizeof(DWORD));
        RegCloseKey(hKey);
    }
}

//***************************************************************************************
void    GetRegistryString(LPCSTR szName , LPSTR szBuffer , DWORD dwBufferLength , LPCSTR szDefault)
{
    HKEY    hKey;

    if (RegOpenKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
    {
        DWORD   dwType;

        if ((RegQueryValueEx(hKey , szName , 0 , &dwType , (LPBYTE) szBuffer , &dwBufferLength) != ERROR_SUCCESS)
             || (dwType != REG_SZ && dwType != REG_NONE))
        {
            strcpy(szBuffer , szDefault);
        }
        RegCloseKey(hKey);
    }
    else
        strcpy(szBuffer , szDefault);
}

//***************************************************************************************
void    SetRegistryString(LPCTSTR szName , LPCTSTR szValue)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    
    if ((RegCreateKeyEx(HKEY_CURRENT_USER , g_szKeyname , 0 , NULL , REG_OPTION_NON_VOLATILE ,
                          KEY_WRITE , NULL , &hKey , &dwDisposition) == ERROR_SUCCESS))
    {
        RegSetValueEx(hKey , szName , 0 , REG_SZ , (CONST BYTE*)szValue , strlen(szValue)+1);
        RegCloseKey(hKey);
    }
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\trace.cpp ===
#include    <stdafx.h>
#include    "DXSvr.h"

//***************************************************************************************
void __TraceOutput(LPCTSTR pszFormat, ...)
{
    TCHAR buffer[256];

    wnsprintf(buffer, ARRAYSIZE(buffer), pszFormat, (LPCTSTR)((&pszFormat)+1));
    OutputDebugString(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\dolphin\texture.cpp ===
#include    "stdafx.h"
#include    "DXSvr.h"

extern IDirectDraw7 * g_pDD;


//***************************************************************************************
HRESULT LoadBMPFile(TCHAR* strFilename, HBITMAP* phbm)
{ 
    // Check params
    if (NULL==strFilename || NULL==phbm)
        return DDERR_INVALIDPARAMS;

    // Try to load the bitmap as a resource.
    (*phbm) = (HBITMAP)LoadImage(g_hMainInstance, strFilename, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); 

    // If the bitmap wasn't a resource, try it as a file.
    if (NULL == (*phbm)) 
        (*phbm) = (HBITMAP)LoadImage(NULL, strFilename, IMAGE_BITMAP, 0, 0, 
                                      LR_LOADFROMFILE|LR_CREATEDIBSECTION); 

    return (*phbm) ? DD_OK : DDERR_NOTFOUND;
}

//***************************************************************************************
HRESULT LoadBMPFileChain(TCHAR** strFilenames , HBITMAP* phbm , int num_files)
{
    for (int i = 0 ; i < num_files ; i++)
    {
        if (FAILED(LoadBMPFile(strFilenames[i] , phbm+i)))
        {
            for (int j = 0 ; j < i ; j++)
                DeleteObject(phbm[j]);
            return E_FAIL;
        }
    }

    return S_OK;
}

//***************************************************************************************
IDirectDrawSurface7*    CreateTextureFromBitmap(HBITMAP hBmp , DDPIXELFORMAT& ddpfFormat)
{
    IDirectDrawSurface7*    pTexture;
    IDirectDrawSurface7*    pSurface;
    DDSURFACEDESC2          desc;

    // Figure out the size of the bitmap
    BITMAP  bm;
    GetObject(hBmp, sizeof(BITMAP), &bm);

    // Create texture surface. Flag as a managed texture
    memset(&desc , 0 , sizeof(desc));
    desc.dwSize             = sizeof(desc);
    desc.dwFlags            = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT;
    desc.dwHeight           = bm.bmHeight;
    desc.dwWidth            = bm.bmWidth;
    desc.ddpfPixelFormat    = ddpfFormat;
    desc.ddsCaps.dwCaps     = DDSCAPS_TEXTURE;
    desc.ddsCaps.dwCaps2    = DDSCAPS2_TEXTUREMANAGE;
    if (FAILED(g_pDD->CreateSurface(&desc , &pTexture , NULL)))     // g_pDDraw
        return NULL;

    // Now create system surface which we'll put the bitmap data into.
    desc.ddsCaps.dwCaps = DDSCAPS_TEXTURE|DDSCAPS_SYSTEMMEMORY;
    desc.ddsCaps.dwCaps2 = 0;
    if (FAILED(g_pDD->CreateSurface(&desc , &pSurface , NULL)))
    {
        pTexture->Release();
        return NULL;
    }

    // Copy the bitmap into the system surface
    HDC image = CreateCompatibleDC(NULL);
    if (image != NULL)
    {
        SelectObject(image , hBmp);
        HDC dc;
        if (SUCCEEDED(pSurface->GetDC(&dc)))
        {
            BitBlt(dc , 0 , 0 , bm.bmWidth , bm.bmHeight , image , 0 , 0 , SRCCOPY);
            pSurface->ReleaseDC(dc);
        }
        DeleteDC(image);
    }

    // Load the texture
    pTexture->Blt(NULL , pSurface , NULL , DDBLT_WAIT , NULL);

    // Lose the system copy of the texture
    pSurface->Release();

    // Done
    return pTexture;
}

//***************************************************************************************
IDirectDrawSurface7*    CreateMipTextureFromBitmapChain(HBITMAP* hBmp , DDPIXELFORMAT& ddpfFormat , int num_mips)
{
    IDirectDrawSurface7*    pSurface;
    IDirectDrawSurface7*    pTexture;
    DDSURFACEDESC2          desc;

    // Figure out the size of the first bitmap
    BITMAP  bm;
    GetObject(*hBmp, sizeof(BITMAP), &bm);

    // Create texture surface. Flag as a managed texture
    memset(&desc , 0 , sizeof(desc));
    desc.dwSize             = sizeof(desc);
    desc.dwFlags            = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT|DDSD_MIPMAPCOUNT;
    desc.dwHeight           = bm.bmHeight;
    desc.dwWidth            = bm.bmWidth;
    desc.dwMipMapCount      = num_mips;
    desc.ddpfPixelFormat    = ddpfFormat;
    desc.ddsCaps.dwCaps     = DDSCAPS_TEXTURE|DDSCAPS_MIPMAP|DDSCAPS_COMPLEX;
    desc.ddsCaps.dwCaps2    = DDSCAPS2_TEXTUREMANAGE;
    if (FAILED(g_pDD->CreateSurface(&desc , &pTexture , NULL)))
        return NULL;

    // Now create system surface which we'll put the bitmap data into.
    desc.ddsCaps.dwCaps = DDSCAPS_TEXTURE|DDSCAPS_SYSTEMMEMORY|DDSCAPS_MIPMAP|DDSCAPS_COMPLEX;
    desc.ddsCaps.dwCaps2 = 0;
    if (FAILED(g_pDD->CreateSurface(&desc , &pSurface , NULL)))
    {
        pTexture->Release();
        return NULL;
    }

    // Copy the bitmaps into the system surfaces
    IDirectDrawSurface7*    pMipLevel = pSurface;
    HDC image = CreateCompatibleDC(NULL);
    if (image != NULL)
    {
        for (int i = 0 ; i < num_mips ; i++)
        {
            GetObject(hBmp[i] , sizeof(BITMAP) , &bm);
            SelectObject(image , hBmp[i]);
            HDC dc;
            if (SUCCEEDED(pMipLevel->GetDC(&dc)))
            {
                BitBlt(dc , 0 , 0 , bm.bmWidth , bm.bmHeight , image , 0 , 0 , SRCCOPY);
                pMipLevel->ReleaseDC(dc);
            }

            DDSCAPS2    ddsCaps;
            ddsCaps.dwCaps = DDSCAPS_TEXTURE|DDSCAPS_MIPMAP;
            ddsCaps.dwCaps2 = ddsCaps.dwCaps3 = ddsCaps.dwCaps4 = 0;
            if (FAILED(pMipLevel->GetAttachedSurface(&ddsCaps , &pMipLevel)))
                break;
        }
        DeleteDC(image);
    }

    // Load the texture
    pTexture->Blt(NULL , pSurface , NULL , DDBLT_WAIT , NULL);

    // Lose the system copy of the texture
    pSurface->Release();

    // Done
    return pTexture;
}

//***************************************************************************************
IDirectDrawSurface7*    LoadAndCreateTexture(TCHAR* strFilename , DDPIXELFORMAT& ddpfFormat)
{
    HBITMAP hBmp;
    if (FAILED(LoadBMPFile(strFilename , &hBmp)))
        return NULL;

    IDirectDrawSurface7*    texture = CreateTextureFromBitmap(hBmp , ddpfFormat);

    DeleteObject(hBmp);

    return texture;
}

//***************************************************************************************
IDirectDrawSurface7*    LoadAndCreateMipTexture(TCHAR** strFilenames , DDPIXELFORMAT& ddpfFormat , int num_mips)
{
    if (num_mips > 16 || num_mips < 1)
        return NULL;

    HBITMAP hBmp[16];

    if (FAILED(LoadBMPFileChain(strFilenames , hBmp , num_mips)))
        return NULL;

    IDirectDrawSurface7*    texture = CreateMipTextureFromBitmapChain(hBmp , ddpfFormat , num_mips);

    for (int i = 0 ; i < num_mips ; i++)
        DeleteObject(hBmp[i]);

    return texture;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flowerbox\flowerbox.cpp ===
//-----------------------------------------------------------------------------
// File: FlowerBox.cpp
//
// Desc: Fun screen saver
//       Original OpenGL version by Drew Bliss
//       Ported to Direct3D 8.0 by Mike Anderson
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <stdio.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "d3dsaver.h"
#include "FlowerBox.h"
#include "Resource.h"
#include "dxutil.h"

#ifndef GL_FRONT
#define GL_FRONT                          0x0404
#endif

#ifndef GL_FRONT_AND_BACK
#define GL_FRONT_AND_BACK                 0x0408
#endif


// Minimum and maximum image sizes
#define MINIMAGESIZE 10
#define MAXIMAGESIZE 100

// Color tables for checkboard, per-side and single color modes
FLOAT base_checker_cols[MAXSIDES][NCCOLS][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.0f, 0.0f, 1.0f
};
FLOAT checker_cols[MAXSIDES][NCCOLS][4];

FLOAT base_side_cols[MAXSIDES][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f
};
FLOAT side_cols[MAXSIDES][4];

FLOAT base_solid_cols[4] =
{
    1.0f, 1.0f, 1.0f, 1.0f
};
FLOAT solid_cols[4];


// Default configuration
CONFIG config =
{
    TRUE, FALSE, FALSE, TRUE, TRUE, MAXSUBDIV, ID_COL_PER_SIDE,
    (MAXIMAGESIZE+MINIMAGESIZE)/2, GEOM_CUBE, GL_FRONT
};

// A slider range
typedef struct _RANGE
{
    INT min_val;
    INT max_val;
    INT step;
    INT page_step;
} RANGE;

RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2};
RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10};

// Values to map a 2D point onto a 3D plane
// Base point and axes to map X and Y coordinates onto
struct PLANE_MAP
{
    D3DXVECTOR3 base, x_axis, y_axis;
    PLANE_MAP(D3DXVECTOR3 tbase, D3DXVECTOR3 tx_axis, D3DXVECTOR3 ty_axis)
        { base = tbase; x_axis = tx_axis; y_axis = ty_axis; }
    PLANE_MAP(VOID) {};
};

// Data area used by the current geometry
// Base points and generated points
D3DXVECTOR3 pts[MAXPTS], npts[MAXPTS];
MYVERTEX vertices[MAXPTS];

// Scaling factor for spherical projection
FLOAT vlen[MAXPTS];
// Normals
D3DXVECTOR3 normals[MAXPTS];
// Vertex data indices
WORD index[MAXPTS*2];
// Triangle strip sizes
INT strip_size[MAXSIDES*MAXSUBDIV];

VOID InitCube(GEOMETRY *geom);
VOID InitTetra(GEOMETRY *geom);
VOID InitPyramids(GEOMETRY *geom);
VOID InitCylinder(GEOMETRY *geom);
VOID InitSpring(GEOMETRY *geom);

GEOMETRY cube_geom = {InitCube};
GEOMETRY tetra_geom = {InitTetra};
GEOMETRY pyramids_geom = {InitPyramids};
GEOMETRY cylinder_geom = {InitCylinder};
GEOMETRY spring_geom = {InitSpring};

GEOMETRY *geom_table[] =
{
    &cube_geom,
    &tetra_geom,
    &pyramids_geom,
    &cylinder_geom,
    &spring_geom
};


#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];

CFlowerBoxScreensaver* g_pMyFlowerBoxScreensaver = NULL;




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CFlowerBoxScreensaver flowerboxSS;

    if( FAILED( hr = flowerboxSS.Create( hInst ) ) )
    {
        flowerboxSS.DisplayErrorMsg( hr );
        return 0;
    }

    return flowerboxSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CFlowerBoxScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CFlowerBoxScreensaver::CFlowerBoxScreensaver( )
{
    g_pMyFlowerBoxScreensaver = this;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;

    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Flowerbox") );

    m_xr = 0;
    m_yr = 0;
    m_zr = 0;

    m_sf = 0;
    m_sfi = 0;

    m_phase = 0.0f;

    m_pGeomCur = NULL;

    m_floatrect.xSize = 0.0f;
    InitCommonControls();
}


//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::FrameMove()
{
    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = (FLOAT)config.image_size / 150.0f;

    //    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    //    size = (DWORD) (sizeFact * ( ((FLOAT)(dwParentWidth + dwParentHeight)) / 2.0f ));

        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on primary
        m_floatrect.xMin = rcBounds.left + (dwParentWidth - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + (dwParentHeight - size) / 2.0f;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        m_floatrect.yVel = 0.01f * (FLOAT) size;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
    m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
    if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
        m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
    {
        m_floatrect.xMin = xMinOld; // undo last move
        m_floatrect.xVel = -m_floatrect.xVel; // change direction
    }
    if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
        m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
    {
        m_floatrect.yMin = yMinOld; // undo last move
        m_floatrect.yVel = -m_floatrect.yVel; // change direction
    }

    if (config.spin)
    {
        m_xr += 3 * 20.0f * m_fElapsedTime;
        m_yr += 2 * 20.0f * m_fElapsedTime;
    }

    if (config.bloom)
    {
        m_sf += m_sfi * 20.0f * m_fElapsedTime;
        if (m_sfi > 0.0f && m_sf > m_pGeomCur->max_sf ||
            m_sfi < 0.0f && m_sf < m_pGeomCur->min_sf )
        {
            m_sfi = -m_sfi;
        }
        UpdatePts(m_pGeomCur, m_sf);
    }

    if (config.cycle_colors)
    {
        ComputeHsvColors();
        m_phase += (FLOAT)(2.5 * 20.0f * m_fElapsedTime * D3DX_PI/180.);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -0.8f;
    r =  0.8f;
    b =  0.8f;
    t = -0.8f;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, b, t, 2.0f, 5.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Begin the scene 
    if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
    {
        D3DXMATRIX mat, matx, maty, matz;
        D3DXMatrixRotationX( &matx, D3DXToRadian( (FLOAT)m_xr ) );
        D3DXMatrixRotationY( &maty, D3DXToRadian( (FLOAT)m_yr ) );
        D3DXMatrixRotationZ( &matz, D3DXToRadian( (FLOAT)m_zr ) );
        mat = matx * maty * matz;
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &mat );

        DrawGeom(m_pGeomCur);

        // End the scene.
        m_pd3dDevice->EndScene();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;
    
    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 3.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW , &matView );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type       = D3DLIGHT_POINT;
    light.Diffuse.r  = 1.0f;
    light.Diffuse.g  = 1.0f;
    light.Diffuse.b  = 1.0f;
    light.Diffuse.a  = 1.0f;
    light.Specular.r = 1.0f;
    light.Specular.g = 1.0f;
    light.Specular.b = 1.0f;
    light.Specular.a = 1.0f;
    light.Position.x = 2.0;
    light.Position.y = 2.0;
    light.Position.z = 10.0;
    light.Range      = 1000.0f;
    light.Attenuation0 = 1.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);
    
    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR(0x40404040 ) );
    if( config.two_sided == GL_FRONT_AND_BACK )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    
    NewConfig(&config);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::InvalidateDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVlen()
// Desc: Precomputes scaling factor for spherical projection
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::InitVlen(GEOMETRY *geom, INT npts, D3DXVECTOR3 *pts)
{
    const FLOAT RADIUS = 1;
    FLOAT d;
    FLOAT *vl;

    vl = vlen;
    while (npts-- > 0)
    {
        d = D3DXVec3Length(pts);

        // Don't allow really close points because this leads to
        // numeric instability and really large objects
//        assert(d > 0.01f);

        // Geometries are created with size one, filling the area
        // from -.5 to .5.  This leads to distances generally less
        // than one, which leaves off half of the interesting morphing
        // effects due to the projection
        // Scaling up the scaling factor allows the values to
        // be both above and below one
        d *= geom->init_sf;
        
//        assert(d > 0.0001f);
        
        *vl++ = (RADIUS-d)/d;

        pts++;
    }
}




//-----------------------------------------------------------------------------
// Name: MapToSide()
// Desc: Takes x,y coordinates in the range 0-1 and maps them onto the given
//       side plane for the current geometry
//-----------------------------------------------------------------------------
VOID MapToSide(PLANE_MAP *map, FLOAT x, FLOAT y, D3DXVECTOR3 *pt)
{
    pt->x = x*map->x_axis.x+y*map->y_axis.x+map->base.x;
    pt->y = x*map->x_axis.y+y*map->y_axis.y+map->base.y;
    pt->z = x*map->x_axis.z+y*map->y_axis.z+map->base.z;
}





//-----------------------------------------------------------------------------
// Name: InitCube()
// Desc: Initializes the cube's geometry
//-----------------------------------------------------------------------------
VOID InitCube(GEOMETRY *geom)
{
    const INT CUBE_SIDES = 6;
    PLANE_MAP cube_planes[CUBE_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, -0.5f,  0.5f),  D3DXVECTOR3( 1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, -0.5f, -0.5f),  D3DXVECTOR3(-1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f,  0.5f, -0.5f),  D3DXVECTOR3(-1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, -0.5f, -0.5f),  D3DXVECTOR3( 1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, -0.5f, -0.5f),  D3DXVECTOR3( 0.0f,  1.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f,  0.5f, -0.5f),  D3DXVECTOR3( 0.0f, -1.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f))
    };
    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    INT side_pts;

    side_pts = (config.subdiv+1)*(config.subdiv+1);
    
    geom->nsides = CUBE_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.1f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.0f;
    
    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
        
        for (x = 0; x < config.subdiv; x++)
        {
            *sz++ = (config.subdiv+1)*2;

            for (y = 0; y < config.subdiv+1; y++)
            {
                *idx++ = side * side_pts + x * (config.subdiv + 1) + y;
                *idx++ = side * side_pts + (x + 1) * (config.subdiv + 1) + y;
            }
        }
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        for (x = 0; x < config.subdiv+1; x++)
        {
            for (y = 0; y < config.subdiv+1; y++)
            {
                MapToSide(&cube_planes[side],
                          (FLOAT)x/config.subdiv, (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}





//-----------------------------------------------------------------------------
// Name: InitTetra()
// Desc: Initializes the tetrahedron's geometry
//-----------------------------------------------------------------------------
VOID InitTetra(GEOMETRY *geom)
{
    const INT TETRA_SIDES = 4;
    const FLOAT SQRT3 = 1.73205f;
    const FLOAT SQRT3_2 = (SQRT3/2.0f);
    const FLOAT SQRT3_3 = (SQRT3/3.0f);
    const FLOAT SQRT3_6 = (SQRT3/6.0f);
    const FLOAT SQRT3_12 = (SQRT3/12.0f);
    const FLOAT TETRA_BASE = (-SQRT3/8.0f);
    PLANE_MAP tetra_planes[TETRA_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, TETRA_BASE, SQRT3_6), D3DXVECTOR3(1.0f, 0.0f, 0.0f),      D3DXVECTOR3(0.0f, SQRT3_2, -SQRT3_6)),
        PLANE_MAP(D3DXVECTOR3(0.0f, TETRA_BASE, -SQRT3_3), D3DXVECTOR3(-0.5f, 0.0f, SQRT3_2),  D3DXVECTOR3(0.25f, SQRT3_2, SQRT3_12)),
        PLANE_MAP(D3DXVECTOR3(0.5f, TETRA_BASE, SQRT3_6),  D3DXVECTOR3(-0.5f, 0.0f, -SQRT3_2), D3DXVECTOR3(-0.25f, SQRT3_2, SQRT3_12)),
        PLANE_MAP(D3DXVECTOR3(0.5f, TETRA_BASE, SQRT3_6),  D3DXVECTOR3(-1.0f, 0.0f, 0.0f),     D3DXVECTOR3(0.0f, 0.0f, -SQRT3_2)),
    };

    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short side_pts;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = TETRA_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.75f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;

        for (x = 0; x < config.subdiv; x++)
        {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++)
            {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }

        base_pt++;
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLOAT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&tetra_planes[side],
                          fx+(FLOAT)y/(config.subdiv*2),
                          (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}




//-----------------------------------------------------------------------------
// Name: InitPyramids()
// Desc: Initializes double pyramid geometry
//-----------------------------------------------------------------------------
VOID InitPyramids(GEOMETRY *geom)
{
    const INT PYRAMIDS_SIDES = 8;
    PLANE_MAP pyramids_planes[PYRAMIDS_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f,  0.5f), D3DXVECTOR3( 1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f,  0.5f, -0.5f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f,  0.5f), D3DXVECTOR3(-1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f, -0.5f, -0.5f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f,  0.5f), D3DXVECTOR3( 0.0f, 0.0f, -1.0f), D3DXVECTOR3(-0.5f,  0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f, -0.5f), D3DXVECTOR3( 0.0f, 0.0f,  1.0f), D3DXVECTOR3(-0.5f, -0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f, -0.5f), D3DXVECTOR3(-1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f,  0.5f,  0.5f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f, -0.5f), D3DXVECTOR3( 1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f, -0.5f,  0.5f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f, -0.5f), D3DXVECTOR3( 0.0f, 0.0f,  1.0f), D3DXVECTOR3( 0.5f,  0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f,  0.5f), D3DXVECTOR3( 0.0f, 0.0f, -1.0f), D3DXVECTOR3( 0.5f, -0.5f,  0.0f))
    };

    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short side_pts;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = PYRAMIDS_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.0f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;

    for (side = 0; side < geom->nsides; side++) {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
            
        for (x = 0; x < config.subdiv; x++) {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++) {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }
            
        base_pt++;
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLOAT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&pyramids_planes[side],
                          fx+(FLOAT)y/(config.subdiv*2),
                          (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}




//-----------------------------------------------------------------------------
// Name: InitCylinder()
// Desc: Initializes the cylinder geometry
//-----------------------------------------------------------------------------
VOID InitCylinder(GEOMETRY *geom)
{
    unsigned short side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx, fz;
    double ang;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -2.5f;
    geom->max_sf = 8.5f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.1f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv+1;
    base_pt = 0;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = row_pts*2;
        
        for (y = 0; y < row_pts; y++) {
            // Wrap around at the edge so the cylinder normals
            // are properly averaged
            if (x == config.subdiv-1) {
                *idx++ = y;
            }
            else {
                *idx++ = base_pt+row_pts+y;
            }
            *idx++ = base_pt+y;
        }

        base_pt += row_pts;
    }
    
    // Generate base vertices
    pt = geom->pts;
    ang = 0;
    for (x = 0; x < config.subdiv; x++)
    {
        fx = (FLOAT)cos(ang)*0.5f;
        fz = (FLOAT)sin(ang)*0.5f;
        for (y = 0; y < config.subdiv+1; y++)
        {
            pt->x = fx;
            pt->y = (FLOAT)y/config.subdiv-0.5f;
            pt->z = fz;
            pt++;
        }
        ang += (2*D3DX_PI)/config.subdiv;
    }

    geom->total_pts = geom->nsides*(config.subdiv+1)*config.subdiv;
}




//-----------------------------------------------------------------------------
// Name: InitSpring()
// Desc: Initializes the spring geometry
//-----------------------------------------------------------------------------
VOID InitSpring(GEOMETRY *geom)
{
    const FLOAT SPRING_RADIUS = 0.1f;
    const FLOAT SPRING_CENTER = (0.5f-SPRING_RADIUS);
    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    double ang_center, ang_surf;
    FLOAT cs, sn;
    FLOAT rad;
    PLANE_MAP plane;
    INT spin_pts;
    INT row_pts;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -2.2f;
    geom->max_sf = 0.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 1.0f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv;
    spin_pts = 4*config.subdiv+1;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = spin_pts*2;

        for (y = 0; y < spin_pts; y++) {
            *idx++ = x+row_pts*y;
            // Wrap around at the edge so the cylindrical surface
            // of the tube is seamless.  Without this the normal
            // averaging would be incorrect and a seam would be visible
            if (x == config.subdiv-1) {
                *idx++ = row_pts*y;
            }
            else {
                *idx++ = x+row_pts*y+1;
            }
        }
    }
    
    // Generate base vertices
    pt = geom->pts;
    ang_center = 0;
    plane.y_axis.x = 0.0f;
    plane.y_axis.y = SPRING_RADIUS;
    plane.y_axis.z = 0.0f;
    plane.x_axis.y = 0.0f;
    for (x = 0; x < spin_pts; x++)
    {
        cs = (FLOAT)cos(ang_center);
        sn = (FLOAT)sin(ang_center);
        rad = 0.5f-(FLOAT)x/(spin_pts-1)*(SPRING_CENTER/2);
        plane.base.x = cs*rad;
        plane.base.y = -0.5f+(FLOAT)x/(spin_pts-1);
        plane.base.z = sn*rad;
        plane.x_axis.x = cs*SPRING_RADIUS;
        plane.x_axis.z = sn*SPRING_RADIUS;

        ang_surf = 0;
        for (y = 0; y < config.subdiv; y++)
        {
            MapToSide(&plane,
                      (FLOAT)cos(ang_surf), (FLOAT)sin(ang_surf),
                      pt);
            pt++;
            ang_surf += (2*D3DX_PI)/config.subdiv;
        }
        
        ang_center += (4*D3DX_PI)/(spin_pts-1);
    }

    geom->total_pts = geom->nsides*spin_pts*config.subdiv;
}




//-----------------------------------------------------------------------------
// Name: DrawGeom()
// Desc: Draw the current geometry
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::DrawGeom(GEOMETRY *geom)
{
    if (config.smooth_colors)
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
    else
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT );

    if (config.color_pick == ID_COL_SINGLE)
        SetMaterialColor(solid_cols);

    for( INT i = 0; i < geom->total_pts; i++ )
    {
        geom->pVertices[i].p = *(D3DXVECTOR3*)&geom->npts[i];
        D3DXVec3Normalize( &geom->pVertices[i].n, (D3DXVECTOR3*)&geom->normals[i] );
    }

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD col0Indices[5000];
    INT numCol0Indices;
    WORD col1Indices[5000];
    INT numCol1Indices;

    INT side;
    INT strip;
    INT triangle;
    unsigned short *idx;
    BOOL bBackwards; // triangle backwards for original strip implementation
    BOOL bCol0; // col0 or col1 for this triangle?
    INT numThisColor; // num tris done in this color; helps determine bCol0
    for (side = 0; side < geom->nsides; side++) 
    {
        numCol0Indices = 0;
        numCol1Indices = 0;
        bCol0 = TRUE;

        idx = geom->sides[side].strip_index;
        for (strip = 0; strip < geom->sides[side].nstrips; strip++, idx += 2) 
        {
            numThisColor = 0;
            if( !config.triangle_colors )
                numThisColor++;
            bBackwards = FALSE;
            if( config.color_pick == ID_COL_CHECKER )
                bCol0 = ( strip & 1 );

            for( triangle = 0; triangle < geom->sides[side].strip_size[strip] - 2; triangle++ )
            {
                if( config.color_pick == ID_COL_CHECKER )
                {
                    numThisColor++;
                    if( numThisColor == 2 )
                    {
                        bCol0 = !bCol0;
                        numThisColor = 0;
                    }
                }

                if( bCol0 )
                {
                    if( bBackwards )
                    {
                        col0Indices[numCol0Indices++] = *(idx+1);
                        col0Indices[numCol0Indices++] = *(idx+0);
                        col0Indices[numCol0Indices++] = *(idx+2);
                    }
                    else
                    {
                        col0Indices[numCol0Indices++] = *(idx+0);
                        col0Indices[numCol0Indices++] = *(idx+1);
                        col0Indices[numCol0Indices++] = *(idx+2);
                    }
                }
                else
                {
                    if( bBackwards )
                    {
                        col1Indices[numCol1Indices++] = *(idx+1);
                        col1Indices[numCol1Indices++] = *(idx+0);
                        col1Indices[numCol1Indices++] = *(idx+2);
                    }
                    else
                    {
                        col1Indices[numCol1Indices++] = *(idx+0);
                        col1Indices[numCol1Indices++] = *(idx+1);
                        col1Indices[numCol1Indices++] = *(idx+2);
                   }
                }
                idx ++;
                bBackwards = !bBackwards;
            }
        }

        // Draw this side's col0 primitives
        if (config.color_pick == ID_COL_PER_SIDE) 
            SetMaterialColor(side_cols[side]);
        else if (config.color_pick == ID_COL_CHECKER) 
            SetMaterialColor(checker_cols[side][0]);
        m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0,
            geom->total_pts, numCol0Indices / 3, 
            col0Indices, D3DFMT_INDEX16, &geom->pVertices[0], sizeof(MYVERTEX) );

        // Draw this side's col1 primitives, if any
        if (config.color_pick == ID_COL_CHECKER) 
        {
            SetMaterialColor(checker_cols[side][1]);
            m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0,
                geom->total_pts, numCol1Indices / 3, 
                col1Indices, D3DFMT_INDEX16, &geom->pVertices[0], sizeof(MYVERTEX) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ComputeAveragedNormals()
// Desc: Compute face-averaged normals for each vertex
//-----------------------------------------------------------------------------
VOID ComputeAveragedNormals(GEOMETRY *geom)
{
    INT side, strip;
    INT *sz;
    unsigned short/*INT*/ *idx;
    INT idx1, idx2, idx3;
    INT tc, idc;
    D3DXVECTOR3 v1, v2, n1;
    
    memset(geom->normals, 0, sizeof(D3DXVECTOR3)*geom->total_pts);
    
    for (side = 0; side < geom->nsides; side++)
    {
        idx = geom->sides[side].strip_index;
        sz = geom->sides[side].strip_size;
        for (strip = 0; strip < geom->sides[side].nstrips; strip++)
        {
            idx1 = *idx++;
            idx2 = *idx++;

//            assert(idx1 >= 0 && idx1 < geom->total_pts &&
//                   idx2 >= 0 && idx2 < geom->total_pts);
            
            tc = (*sz++)-2;
            for (idc = 0; idc < tc; idc++)
            {
                idx3 = *idx++;

//                assert(idx3 >= 0 && idx3 < geom->total_pts);

                v1 = geom->npts[idx3] - geom->npts[idx1];
                v2 = geom->npts[idx2] - geom->npts[idx1];
                D3DXVec3Cross( &n1, &v1, &v2 );

                // Triangle strip ordering causes half of the triangles
                // to be oriented oppositely from the others
                // Those triangles need to have their normals flipped
                // so the whole triangle strip has consistent normals
                if ((idc & 1) == 0)
                {
                    n1.x = -n1.x;
                    n1.y = -n1.y;
                    n1.z = -n1.z;
                }

                geom->normals[idx1] += n1;
                geom->normals[idx2] += n1;
                geom->normals[idx3] += n1;

                idx1 = idx2;
                idx2 = idx3;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdatePts()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::UpdatePts(GEOMETRY *geom, FLOAT sf)
{
    INT pt;
    FLOAT f, *vl;
    D3DXVECTOR3 *v;
    D3DXVECTOR3 *p;

    vl = vlen;
    p = &geom->pts[0];
    v = &geom->npts[0];
    for (pt = 0; pt < geom->total_pts; pt++)
    {
        f = (*vl++)*sf+1;
        v->x = p->x*f;
        v->y = p->y*f;
        v->z = p->z*f;
        p++;
        v++;
    }

    ComputeAveragedNormals(geom);
}




//-----------------------------------------------------------------------------
// Name: ComputeHsvColors()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ComputeHsvColors(VOID)
{
    FLOAT *cols;
    INT ncols;
    FLOAT ang, da;
    INT hex;
    FLOAT fhex, frac;
    FLOAT p, q, t;
    FLOAT sat, val;

    switch(config.color_pick)
    {
    case ID_COL_CHECKER:
        ncols = MAXSIDES*NCCOLS;
        cols = &checker_cols[0][0][0];
        break;
    case ID_COL_PER_SIDE:
        ncols = MAXSIDES;
        cols = &side_cols[0][0];
        break;
    case ID_COL_SINGLE:
        ncols = 1;
        cols = &solid_cols[0];
        break;
    }

    ang = m_phase;
    da = (FLOAT)((2*D3DX_PI)/ncols);
    val = sat = 1.0f;

    while (ncols > 0)
    {
        fhex = (FLOAT)(6*ang/(2*D3DX_PI));
        hex = (INT)fhex;
        frac = fhex-hex;
        hex = hex % 6;
        
	p = val*(1-sat);
	q = val*(1-sat*frac);
	t = val*(1-sat*(1-frac));
        
	switch(hex)
	{
	case 0:
            cols[0] = val;
            cols[1] = t;
            cols[2] = p;
	    break;
	case 1:
            cols[0] = q;
            cols[1] = val;
            cols[2] = p;
	    break;
	case 2:
            cols[0] = p;
            cols[1] = val;
            cols[2] = t;
	    break;
	case 3:
            cols[0] = p;
            cols[1] = q;
            cols[2] = val;
	    break;
	case 4:
            cols[0] = t;
            cols[1] = p;
            cols[2] = val;
            break;
	case 5:
            cols[0] = val;
            cols[1] = p;
            cols[2] = q;
	    break;
	}

        ang += da;
        cols += 4;
        ncols--;
    }
}




//-----------------------------------------------------------------------------
// Name: NewConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::NewConfig(CONFIG *cnf)
{
    // Set new config
    config = *cnf;

    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        DXUtil_WriteBoolRegKey( hkey, TEXT("Smooth"), config.smooth_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Slanted"), config.triangle_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Cycle"), config.cycle_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Spin"), config.spin );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Bloom"), config.bloom );
        DXUtil_WriteIntRegKey( hkey, TEXT("Subdiv"), config.subdiv );
        DXUtil_WriteIntRegKey( hkey, TEXT("ColorPick"), config.color_pick );
        DXUtil_WriteIntRegKey( hkey, TEXT("ImageSize"), config.image_size );
        DXUtil_WriteIntRegKey( hkey, TEXT("Geom"), config.geom );
        DXUtil_WriteIntRegKey( hkey, TEXT("TwoSided"), config.two_sided );

        WriteScreenSettings( hkey );

        RegCloseKey( hkey );
    }

    // Reset colors
    memcpy(checker_cols, base_checker_cols, sizeof(checker_cols));
    memcpy(side_cols, base_side_cols, sizeof(side_cols));
    memcpy(solid_cols, base_solid_cols, sizeof(solid_cols));

    // Reset geometry
    m_pGeomCur = geom_table[config.geom];
    m_pGeomCur->init(m_pGeomCur);
    
//    assert(m_pGeomCur->total_pts <= MAXPTS);
           
    InitVlen(m_pGeomCur, m_pGeomCur->total_pts, m_pGeomCur->pts);
    m_sf = 0.0f;
    m_sfi = m_pGeomCur->sf_inc;
    UpdatePts(m_pGeomCur, m_sf);
}




//-----------------------------------------------------------------------------
// Name: SetupTrackbar()
// Desc: Setup a common control trackbar
//-----------------------------------------------------------------------------
VOID SetupTrackbar( HWND hDlg, INT item, INT lo, INT hi, INT lineSize, 
                  INT pageSize, INT pos )
{
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETRANGE, 
        (WPARAM) TRUE, 
        (LPARAM) MAKELONG( lo, hi )
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPOS, 
        (WPARAM) TRUE, 
        (LPARAM) pos
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPAGESIZE, 
        (WPARAM) 0,
        (LPARAM) pageSize 
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETLINESIZE, 
        (WPARAM) 0,
        (LPARAM) lineSize
    );
}




//-----------------------------------------------------------------------------
// Name: GetTrackbarPos()
// Desc: Get the current position of a common control trackbar
//-----------------------------------------------------------------------------
INT GetTrackbarPos( HWND hDlg, INT item )
{
    return 
       (INT)SendDlgItemMessage( 
            hDlg, 
            item,
            TBM_GETPOS, 
            0,
            0
        );
}

// Temporary configuration for when the configuration dialog is active
// If the dialog is ok'ed then this becomes the current configuration,
// otherwise it is discarded
CONFIG temp_config;

//-----------------------------------------------------------------------------
// Name: ScreenSaverConfigureDialog()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CALLBACK CFlowerBoxScreensaver::ScreenSaverConfigureDialog(HWND hdlg, UINT msg,
                                         WPARAM wpm, LPARAM lpm)
{
    HWND hCtrl;
    INT i;
    
    switch(msg)
    {
    case WM_INITDIALOG:

        InitCommonControls();

        g_pMyFlowerBoxScreensaver->ReadSettings();
    
        temp_config = config;
        
        CheckRadioButton(hdlg, ID_COL_PICK_FIRST, ID_COL_PICK_LAST,
                         config.color_pick);
        CheckDlgButton(hdlg, ID_COL_SMOOTH, config.smooth_colors);
        CheckDlgButton(hdlg, ID_COL_TRIANGLE, config.triangle_colors);
        CheckDlgButton(hdlg, ID_COL_CYCLE, config.cycle_colors);
        CheckDlgButton(hdlg, ID_SPIN, config.spin);
        CheckDlgButton(hdlg, ID_BLOOM, config.bloom);
        CheckDlgButton(hdlg, ID_TWO_SIDED,
                       config.two_sided == GL_FRONT_AND_BACK);
        
        SetupTrackbar( hdlg, ID_COMPLEXITY, MINSUBDIV, MAXSUBDIV, 
                          complexity_range.step,
                          complexity_range.page_step,
                          config.subdiv);

        SetupTrackbar( hdlg, ID_IMAGE_SIZE, MINIMAGESIZE, MAXIMAGESIZE, 
                          image_size_range.step,
                          image_size_range.page_step,
                          config.image_size);

        hCtrl = GetDlgItem(hdlg, ID_GEOM);
        SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

        // String storage
        TCHAR geom_names[IDS_GEOM_COUNT][20];
        
        for (i = 0; i < IDS_GEOM_COUNT; i++)
        {
            LoadString( NULL, i+IDS_GEOM_FIRST, geom_names[i],
                        sizeof(geom_names)/IDS_GEOM_COUNT );
            SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)geom_names[i]);
        }
        SendMessage(hCtrl, CB_SETCURSEL, config.geom, 0);
        
        SetFocus(GetDlgItem(hdlg, ID_COMPLEXITY));
        return FALSE;

    case WM_COMMAND:
        switch(LOWORD(wpm))
        {
        case ID_COL_CHECKER:
        case ID_COL_PER_SIDE:
        case ID_COL_SINGLE:
            temp_config.color_pick = LOWORD(wpm);
            break;

        case ID_COL_SMOOTH:
            temp_config.smooth_colors = !temp_config.smooth_colors;
            break;
        case ID_COL_TRIANGLE:
            temp_config.triangle_colors = !temp_config.triangle_colors;
            break;
        case ID_COL_CYCLE:
            temp_config.cycle_colors = !temp_config.cycle_colors;
            break;
            
        case ID_SPIN:
            temp_config.spin = !temp_config.spin;
            break;
        case ID_BLOOM:
            temp_config.bloom = !temp_config.bloom;
            break;
        case ID_TWO_SIDED:
            temp_config.two_sided =
                temp_config.two_sided == GL_FRONT_AND_BACK ? GL_FRONT :
                GL_FRONT_AND_BACK;
            break;

        case IDC_SCREENSETTINGS:
            g_pMyFlowerBoxScreensaver->DoScreenSettingsDialog(hdlg);
            break;

        case IDOK:
            temp_config.subdiv =
                GetTrackbarPos(hdlg, ID_COMPLEXITY);
            temp_config.image_size =
                GetTrackbarPos(hdlg, ID_IMAGE_SIZE);
            temp_config.geom =
                (INT)SendMessage(GetDlgItem(hdlg, ID_GEOM), CB_GETCURSEL, 0, 0);
//            NewConfig(&temp_config);
            // Fall through
        case IDCANCEL:
            EndDialog(hdlg, LOWORD(wpm));
            break;
        }
        return TRUE;
        
    }

    return FALSE;
}





//-----------------------------------------------------------------------------
// Name: SetMaterialColor()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::SetMaterialColor(FLOAT* pfColors)
{
    D3DMATERIAL8 mtrl;

    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = pfColors[0];
    mtrl.Diffuse.g = mtrl.Ambient.g = pfColors[1];
    mtrl.Diffuse.b = mtrl.Ambient.b = pfColors[2];
    mtrl.Diffuse.a = mtrl.Ambient.a = pfColors[3];
    mtrl.Specular.r = 0.8f;
    mtrl.Specular.g = 0.8f;
    mtrl.Specular.b = 0.8f;
    mtrl.Specular.a = 1.0f;
    mtrl.Power = 30.0f;

    return m_pd3dDevice->SetMaterial(&mtrl);
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: Read user preferences from registry
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ReadSettings()
{
    HKEY hkey;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        DXUtil_ReadBoolRegKey( hkey, TEXT("Smooth"), &config.smooth_colors, config.smooth_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Slanted"), &config.triangle_colors, config.triangle_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Cycle"), &config.cycle_colors, config.cycle_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Spin"), &config.spin, config.spin );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Bloom"), &config.bloom, config.bloom );
        DXUtil_ReadIntRegKey( hkey, TEXT("Subdiv"), (DWORD*)&config.subdiv, config.subdiv );
        if( config.subdiv < MINSUBDIV )
            config.subdiv = MINSUBDIV;
        if( config.subdiv > MAXSUBDIV )
            config.subdiv = MAXSUBDIV;
        DXUtil_ReadIntRegKey( hkey, TEXT("ColorPick"), (DWORD*)&config.color_pick, config.color_pick );
        DXUtil_ReadIntRegKey( hkey, TEXT("ImageSize"), (DWORD*)&config.image_size, config.image_size );
        DXUtil_ReadIntRegKey( hkey, TEXT("Geom"), (DWORD*)&config.geom, config.geom );
        DXUtil_ReadIntRegKey( hkey, TEXT("TwoSided"), (DWORD*)&config.two_sided, config.two_sided );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ss_ReadSettings()
{
    if( !ss_RegistrySetup( IDS_INI_SECTION, IDS_INIFILE ) )
        return;
    
    config.smooth_colors =
        ss_GetRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors );
    config.triangle_colors =
        ss_GetRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors );
    config.cycle_colors =
        ss_GetRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors );
    config.spin =
        ss_GetRegistryInt( IDS_CONFIG_SPIN, config.spin );
    config.bloom =
        ss_GetRegistryInt( IDS_CONFIG_BLOOM, config.bloom );
    config.subdiv =
        ss_GetRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv );
    config.color_pick =
        ss_GetRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick );
    config.image_size =
        ss_GetRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size );
    config.geom =
        ss_GetRegistryInt( IDS_CONFIG_GEOM, config.geom );
    config.two_sided =
        ss_GetRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided );
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CFlowerBoxScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CFlowerBoxScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::DoConfig()
{
    if( IDOK == DialogBox( NULL, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
        m_hWndParent, (DLGPROC)ScreenSaverConfigureDialog ) )
    {
        NewConfig(&temp_config);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flowerbox\flowerbox.h ===
//-----------------------------------------------------------------------------
// File: FlowerBox.h
//
// Desc: 
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _FLOWERBOX_H
#define _FLOWERBOX_H

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    D3DXVECTOR3 n;     // Normal
};

#define D3DFVF_MYVERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL )


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;
    FLOAT xVel;
    FLOAT yVel;
};



// Minimum and maximum number of side subdivisions
#define MINSUBDIV 3
#define MAXSUBDIV 10

// Maximum values allowed
#define MAXSIDES 8
#define MAXSPTS ((MAXSUBDIV+1)*(MAXSUBDIV+1))
#define MAXPTS (MAXSIDES*MAXSPTS)
#define MAXSFACES (MAXSUBDIV*MAXSUBDIV)
#define MAXFACES (MAXSIDES*MAXSFACES)
#define MAXFPTS 4

// Number of colors used in checkerboarding
#define NCCOLS 2

// Configurable options
struct CONFIG
{
    BOOL smooth_colors;
    BOOL triangle_colors;
    BOOL cycle_colors;
    BOOL spin;
    BOOL bloom;
    INT subdiv;
    INT color_pick;
    INT image_size;
    INT geom;
    INT two_sided;
};

extern CONFIG config;

extern FLOAT checker_cols[MAXSIDES][NCCOLS][4];
extern FLOAT side_cols[MAXSIDES][4];
extern FLOAT solid_cols[4];



// A side of a shape
struct SIDE
{
    INT nstrips; // Number of triangle strips in this side
    INT *strip_size; // Number of vertices per strip
    unsigned short *strip_index; // Indices for each point in the triangle strips
};

// Geometry of a shape
struct GEOMETRY
{
    VOID (*init)(GEOMETRY *geom);
    INT nsides; // Number of sides
    SIDE sides[MAXSIDES]; // Sides

    // Data for each vertex in the shape
    D3DXVECTOR3 *pts, *npts;
    D3DXVECTOR3 *normals;
    MYVERTEX* pVertices;
    INT total_pts; // Total number of vertices

    // Scaling control
    FLOAT min_sf, max_sf, sf_inc;
    FLOAT init_sf; // Initial scale factor setup control
};

#define GEOM_CUBE       0
#define GEOM_TETRA      1
#define GEOM_PYRAMIDS   2


class   CFlowerBoxScreensaver : public CD3DScreensaver
{
protected:
    FLOATRECT m_floatrect;
    // Spin rotations
    FLOAT m_xr;
    FLOAT m_yr;
    FLOAT m_zr;

    // Scale factor and increment
    FLOAT m_sf;
    FLOAT m_sfi;

    // Color cycling hue phase
    FLOAT m_phase;
    GEOMETRY *m_pGeomCur;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    VOID NewConfig(CONFIG *cnf);
    VOID UpdatePts(GEOMETRY *geom, FLOAT sf);
    VOID InitVlen(GEOMETRY *geom, INT npts, D3DXVECTOR3 *pts);
    VOID DrawGeom(GEOMETRY *geom);
    VOID ComputeHsvColors(VOID);
    HRESULT SetMaterialColor(FLOAT* pfColors);
    static BOOL CALLBACK ScreenSaverConfigureDialog(HWND hdlg, UINT msg,
                                                    WPARAM wpm, LPARAM lpm);

public:
    CFlowerBoxScreensaver();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flowerbox\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlowerBox.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_MAIN_ACCEL                  113
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212


#define ID_COMPLEXITY              401
#define ID_IMAGE_SIZE              402

#define ID_COL_PICK_FIRST          ID_COL_CHECKER
#define ID_COL_CHECKER             500
#define ID_COL_PER_SIDE            501
#define ID_COL_SINGLE              502
#define ID_COL_PICK_LAST           ID_COL_SINGLE
#define ID_COL_PICK_COUNT          (ID_COL_PICK_LAST-ID_COL_PICK_FIRST+1)

#define ID_COL_SMOOTH              550
#define ID_COL_TRIANGLE            551
#define ID_COL_CYCLE               552

#define ID_SPIN                    600
#define ID_BLOOM                   601
#define ID_TWO_SIDED               602

#define ID_GEOM                    650

#define IDC_SCREENSETTINGS         651

#define IDS_GEOM_FIRST                  IDS_GEOM_CUBE
#define IDS_GEOM_CUBE                   1025
#define IDS_GEOM_TETRA                  1026
#define IDS_GEOM_PYRAMIDS               1027
#define IDS_GEOM_CYLINDER               1028
#define IDS_GEOM_SPRING                 1029
#define IDS_GEOM_LAST                   IDS_GEOM_SPRING
#define IDS_GEOM_COUNT                  (IDS_GEOM_LAST-IDS_GEOM_FIRST+1)

#define IDS_INIFILE                     1113
#define IDS_INI_SECTION                 1114
#define IDS_CONFIG_TRIANGLE_COLORS      1115
#define IDS_CONFIG_CYCLE_COLORS         1116
#define IDS_CONFIG_SPIN                 1117
#define IDS_CONFIG_BLOOM                1118
#define IDS_CONFIG_SUBDIV               1119
#define IDS_CONFIG_COLOR_PICK           1120
#define IDS_CONFIG_IMAGE_SIZE           1121
#define IDS_CONFIG_GEOM                 1122
#define IDS_CONFIG_TWO_SIDED            1123
#define IDS_CONFIG_SMOOTH_COLORS        1124

#define IDS_GENNAME             9003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\flyingobjects.cpp ===
//-----------------------------------------------------------------------------
// File: FlyingObjects.cpp
//
// Desc: Fun screen saver
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <time.h>
#include <stdio.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"
#include "mesh.h"
#include "Resource.h"
#include "dxutil.h"


extern void updateStripScene(int flags, FLOAT fElapsedTime);
extern void updateDropScene(int flags, FLOAT fElapsedTime);
extern void updateLemScene(int flags, FLOAT fElapsedTime);
extern void updateExplodeScene(int flags, FLOAT fElapsedTime);
extern void updateWinScene(int flags, FLOAT fElapsedTime);
extern void updateWin2Scene(int flags, FLOAT fElapsedTime);
extern void updateTexScene(int flags, FLOAT fElapsedTime);
extern BOOL initStripScene(void);
extern BOOL initDropScene(void);
extern BOOL initLemScene(void);
extern BOOL initExplodeScene(void);
extern BOOL initWinScene(void);
extern BOOL initWin2Scene(void);
extern BOOL initTexScene(void);
extern void delStripScene(void);
extern void delDropScene(void);
extern void delLemScene(void);
extern void delExplodeScene(void);
extern void delWinScene(void);
extern void delWin2Scene(void);
extern void delTexScene(void);

typedef void (*PTRUPDATE)(int flags, FLOAT fElapsedTime);
typedef void (*ptrdel)();
typedef BOOL (*ptrinit)();

// Each screen saver style puts its hook functions into the function
// arrays below.  A consistent ordering of the functions is required.

static PTRUPDATE updateFuncs[] =
    {/*updateWinScene,*/ updateWin2Scene, updateExplodeScene,updateStripScene, updateStripScene,
     updateDropScene, updateLemScene, updateTexScene};

static ptrdel delFuncs[] =
    {/*delWinScene,*/ delWin2Scene, delExplodeScene, delStripScene, delStripScene,
     delDropScene, delLemScene, delTexScene};

static ptrinit initFuncs[] =
    {/*initWinScene,*/ initWin2Scene, initExplodeScene, initStripScene, initStripScene,
     initDropScene, initLemScene, initTexScene};

static int idsStyles[] =
    {IDS_LOGO, IDS_EXPLODE, IDS_RIBBON, IDS_2RIBBON,
     IDS_SPLASH, IDS_TWIST, IDS_FLAG};

#define MAX_TYPE    ( sizeof(initFuncs) / sizeof(ptrinit) - 1 )

// Each screen saver style can choose which dialog box controls it wants
// to use.  These flags enable each of the controls.  Controls not choosen
// will be disabled.

#define OPT_COLOR_CYCLE     0x00000001
#define OPT_SMOOTH_SHADE    0x00000002
#define OPT_TESSEL          0x00000008
#define OPT_SIZE            0x00000010
#define OPT_TEXTURE         0x00000020
#define OPT_STD             ( OPT_COLOR_CYCLE | OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE )

static ULONG gflConfigOpt[] = {
//     OPT_STD,               // Windows logo
     0,                     // New Windows logo
     OPT_STD,               // Explode
     OPT_STD,               // Strip
     OPT_STD,               // Strip
     OPT_STD,               // Drop
     OPT_STD,               // Twist (lemniscate)
     OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE | OPT_TEXTURE  // Texture mapped flag
};

static void updateDialogControls(HWND hDlg);

CFlyingObjectsScreensaver* g_pMyFlyingObjectsScreensaver = NULL;

INT g_xScreenOrigin = 0;
INT g_yScreenOrigin = 0;
INT g_iDevice = -1;
FLOATRECT* g_pFloatRect = NULL;
BOOL gbBounce = FALSE; // floating window bounce off side


// Global message loop variables.
D3DMATERIAL8 Material[16];
#ifdef MEMDEBUG
ULONG totalMem = 0;
#endif

void (*updateSceneFunc)(int flags, FLOAT fElapsedTime); // current screen saver update function
void (*delSceneFunc)(void);         // current screen saver deletion function
BOOL bColorCycle = FALSE;           // color cycling flag
DeviceObjects* g_pDeviceObjects = NULL;
BOOL g_bMoveToOrigin = FALSE;
BOOL g_bAtOrigin = FALSE;
BOOL bSmoothShading = TRUE;         // smooth shading flag
UINT uSize = 100;                   // object size
float fTesselFact = 2.0f;           // object tessalation
int UpdateFlags = 0;                // extra data sent to update function
int Type = 0;                       // screen saver index (into function arrays)

LPDIRECT3DDEVICE8 m_pd3dDevice = NULL;
LPDIRECT3DINDEXBUFFER8 m_pIB = NULL;
LPDIRECT3DVERTEXBUFFER8 m_pVB = NULL;
LPDIRECT3DVERTEXBUFFER8 m_pVB2 = NULL;

// Texture file information
TEXFILE gTexFile = {0};

// Lighting properties.

static const RGBA lightAmbient   = {0.21f, 0.21f, 0.21f, 1.0f};
static const RGBA light0Ambient  = {0.0f, 0.0f, 0.0f, 1.0f};
static const RGBA light0Diffuse  = {0.7f, 0.7f, 0.7f, 1.0f};
static const RGBA light0Specular = {1.0f, 1.0f, 1.0f, 1.0f};
static const FLOAT light0Pos[]      = {100.0f, 100.0f, 100.0f, 0.0f};

// Material properties.

static RGBA matlColors[7] = {{1.0f, 0.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 0.0f, 1.0f, 1.0f},
                             {1.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 1.0f, 1.0f},
                             {1.0f, 0.0f, 1.0f, 1.0f},
                             {0.235f, 0.0f, 0.78f, 1.0f},
                            };




static D3DMATERIAL8 s_mtrl = 
{ 
    1.0f, 1.0f, 1.0f, 1.0f,  // Diffuse
    1.0f, 1.0f, 1.0f, 1.0f,  // Ambient
    1.0f, 1.0f, 1.0f, 1.0f,  // Specular
    0.0f, 0.0f, 0.0f, 0.0f,  // Emissive
    30.0f                    // Power
};


#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


//-----------------------------------------------------------------------------
// Name: myglMaterialfv()
// Desc: 
//-----------------------------------------------------------------------------
VOID myglMaterialfv(INT face, INT pname, FLOAT* params)
{
    if( pname == GL_AMBIENT_AND_DIFFUSE)
    {
        s_mtrl.Ambient.r = s_mtrl.Diffuse.r = params[0];
        s_mtrl.Ambient.g = s_mtrl.Diffuse.g = params[1];
        s_mtrl.Ambient.b = s_mtrl.Diffuse.b = params[2];
        s_mtrl.Ambient.a = s_mtrl.Diffuse.a = params[3];
    }
    else if( pname == GL_SPECULAR )
    {
        s_mtrl.Specular.r = params[0];
        s_mtrl.Specular.g = params[1];
        s_mtrl.Specular.b = params[2];
        s_mtrl.Specular.a = params[3];
    }
    else if( pname == GL_SHININESS )
    {
        s_mtrl.Power = params[0];
    }

    m_pd3dDevice->SetMaterial(&s_mtrl);
}




//-----------------------------------------------------------------------------
// Name: myglMaterialf()
// Desc: 
//-----------------------------------------------------------------------------
VOID myglMaterialf(INT face, INT pname, FLOAT param)
{
    if( pname == GL_SHININESS )
    {
        s_mtrl.Power = param;
    }

    m_pd3dDevice->SetMaterial(&s_mtrl);
}




/******************************Public*Routine******************************\
* HsvToRgb
*
* HSV to RGB color space conversion.  From pg. 593 of Foley & van Dam.
*
\**************************************************************************/
void ss_HsvToRgb(float h, float s, float v, RGBA *color )
{
    float i, f, p, q, t;

    // set alpha value, so caller doesn't have to worry about undefined value
    color->a = 1.0f;

    if (s == 0.0f)     // assume h is undefined
        color->r = color->g = color->b = v;
    else {
        if (h >= 360.0f)
            h = 0.0f;
        h = h / 60.0f;
        i = (float) floor(h);
        f = h - i;
        p = v * (1.0f - s);
        q = v * (1.0f - (s * f));
        t = v * (1.0f - (s * (1.0f - f)));
        switch ((int)i) {
        case 0:
            color->r = v;
            color->g = t;
            color->b = p;
            break;
        case 1:
            color->r = q;
            color->g = v;
            color->b = p;
            break;
        case 2:
            color->r = p;
            color->g = v;
            color->b = t;
            break;
        case 3:
            color->r = p;
            color->g = q;
            color->b = v;
            break;
        case 4:
            color->r = t;
            color->g = p;
            color->b = v;
            break;
        case 5:
            color->r = v;
            color->g = p;
            color->b = q;
            break;
        default:
            break;
        }
    }
}





void *SaverAlloc(ULONG size)
{
    void *mPtr;

    mPtr = malloc(size);
#ifdef MEMDEBUG
    totalMem += size;
    xprintf("malloc'd %x, size %d\n", mPtr, size);
#endif
    return mPtr;
}




void SaverFree(void *pMem)
{
#ifdef MEMDEBUG
    totalMem -= _msize(pMem);
    xprintf("free %x, size = %d, total = %d\n", pMem, _msize(pMem), totalMem);
#endif
    free(pMem);
}




// Minimum and maximum image sizes
#define MINIMAGESIZE 10
#define MAXIMAGESIZE 100


// A slider range
typedef struct _RANGE
{
    int min_val;
    int max_val;
    int step;
    int page_step;
} RANGE;

RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2};
RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10};



/******************************Public*Routine******************************\
* initMaterial
*
* Initialize the material properties.
*
\**************************************************************************/

void initMaterial(int id, float r, float g, float b, float a)
{
    Material[id].Ambient.r = r;
    Material[id].Ambient.g = g;
    Material[id].Ambient.b = b;
    Material[id].Ambient.a = a;

    Material[id].Diffuse.r = r;
    Material[id].Diffuse.g = g;
    Material[id].Diffuse.b = b;
    Material[id].Diffuse.a = a;

    Material[id].Specular.r = 1.0f;
    Material[id].Specular.g = 1.0f;
    Material[id].Specular.b = 1.0f;
    Material[id].Specular.a = 1.0f;

    Material[id].Power = 128.0f;
}

/******************************Public*Routine******************************\
* _3dfo_Init
*
\**************************************************************************/

BOOL CFlyingObjectsScreensaver::_3dfo_Init(void *data)
{

    int i;

    for (i = 0; i < 7; i++)
        initMaterial(i, matlColors[i].r, matlColors[i].g,
                     matlColors[i].b, matlColors[i].a);

/*
    // Set the OpenGL clear color to black.

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
#ifdef SS_DEBUG
    glClearColor(0.2f, 0.2f, 0.2f, 0.0f);
#endif

    // Enable the z-buffer.

    glEnable(GL_DEPTH_TEST);
*/
    // Select the shading model.

    if (bSmoothShading)
    {
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
    }
    else
    {
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT );
    }

/*    // Setup the OpenGL matrices.

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // Setup the lighting.

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (FLOAT *) &lightAmbient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
    glLightfv(GL_LIGHT0, GL_AMBIENT, (FLOAT *) &light0Ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, (FLOAT *) &light0Diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, (FLOAT *) &light0Specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
*/

//    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR_COLORVALUE(lightAmbient.r,
//        lightAmbient.g, lightAmbient.b, lightAmbient.a ) );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type = D3DLIGHT_POINT;
    light.Range = 1000.0f;
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    light.Ambient.r = lightAmbient.r;
    light.Ambient.g = lightAmbient.g;
    light.Ambient.b = lightAmbient.b;
    light.Ambient.a = light0Ambient.a;
    light.Diffuse.r = light0Diffuse.r;
    light.Diffuse.g = light0Diffuse.g;
    light.Diffuse.b = light0Diffuse.b;
    light.Diffuse.a = light0Diffuse.a;
    light.Specular.r = light0Specular.r;
    light.Specular.g = light0Specular.g;
    light.Specular.b = light0Specular.b;
    light.Specular.a = light0Specular.a;
    light.Attenuation0 = 1.0f;
    light.Attenuation1 = 0.0f;
    light.Attenuation2 = 0.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);

//    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE);

    // Setup the material properties.
    m_pd3dDevice->SetMaterial( &Material[0] );

/*    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &Material[0].ks);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT *) &Material[0].specExp);
*/
    // call specific objects init func
    if (! (*initFuncs[Type])() )
        return FALSE;
    updateSceneFunc = updateFuncs[Type];

    return TRUE;
}




/******************************Public*Routine******************************\
* WriteSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
VOID CFlyingObjectsScreensaver::WriteSettings(HWND hDlg)
{
    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        int pos, options;
        int optMask = 1;

        bSmoothShading = IsDlgButtonChecked(hDlg, DLG_SETUP_SMOOTH);
        bColorCycle = IsDlgButtonChecked(hDlg, DLG_SETUP_CYCLE);
        options = bColorCycle;
        options <<= 1;
        options |= bSmoothShading;
        DXUtil_WriteIntRegKey( hkey, TEXT("Options"), options );

        Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_GETCURSEL,
                                       0, 0);
        DXUtil_WriteIntRegKey( hkey, TEXT("Type"), Type );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_TESSEL );
        DXUtil_WriteIntRegKey( hkey, TEXT("Tesselation"), pos );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_SIZE );
        DXUtil_WriteIntRegKey( hkey, TEXT("Size"), pos );

        DXUtil_WriteStringRegKey( hkey, TEXT("Texture"), gTexFile.szPathName );
        DXUtil_WriteIntRegKey( hkey, TEXT("TextureFileOffset"), gTexFile.nOffset );

        WriteScreenSettings( hkey );
        
        RegCloseKey( hkey );
    }
}




/******************************Public*Routine******************************\
* SetupTrackbar
*
* Setup a common control trackbar
\**************************************************************************/
void
ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, 
                  int pageSize, int pos )
{
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETRANGE, 
        (WPARAM) TRUE, 
        (LPARAM) MAKELONG( lo, hi )
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPOS, 
        (WPARAM) TRUE, 
        (LPARAM) pos
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPAGESIZE, 
        (WPARAM) 0,
        (LPARAM) pageSize 
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETLINESIZE, 
        (WPARAM) 0,
        (LPARAM) lineSize
    );
}




/******************************Public*Routine******************************\
* GetTrackbarPos
*
* Get the current position of a common control trackbar
\**************************************************************************/
int
ss_GetTrackbarPos( HWND hDlg, int item )
{
    return 
       (int)SendDlgItemMessage( 
            hDlg, 
            item,
            TBM_GETPOS, 
            0,
            0
        );
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Setup the dialog controls initially.
*
\**************************************************************************/

static void
setupDialogControls(HWND hDlg)
{
    int pos;

    InitCommonControls();

    if (fTesselFact <= 1.0f)
        pos = (int)(fTesselFact * 100.0f);
    else
        pos = 100 + (int) ((fTesselFact - 1.0f) * 100.0f);

    ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, 0, 200, 1, 10, pos );

    ss_SetupTrackbar( hDlg, DLG_SETUP_SIZE, 0, 100, 1, 10, uSize );

    updateDialogControls( hDlg );
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Update the dialog controls based on the current global state.
*
\**************************************************************************/

static void
updateDialogControls(HWND hDlg)
{
    CheckDlgButton(hDlg, DLG_SETUP_SMOOTH, bSmoothShading);
    CheckDlgButton(hDlg, DLG_SETUP_CYCLE, bColorCycle);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SMOOTH),
                 gflConfigOpt[Type] & OPT_SMOOTH_SHADE );
    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_CYCLE),
                 gflConfigOpt[Type] & OPT_COLOR_CYCLE );

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TESSEL),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MIN),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MAX),
                 gflConfigOpt[Type] & OPT_TESSEL);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MIN),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MAX),
                 gflConfigOpt[Type] & OPT_SIZE);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TEXTURE),
                 gflConfigOpt[Type] & OPT_TEXTURE);
}

/******************************Public*Routine******************************\
*
* ScreenSaverConfigureDialog
*
* Standard screensaver hook
*
* History:
*  Wed Jul 19 14:56:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
BOOL CALLBACK CFlyingObjectsScreensaver::ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                         WPARAM wParam, LPARAM lParam)
{
    int wTmp;
    TCHAR szString[GEN_STRING_SIZE];

    switch (message) {
        case WM_INITDIALOG:
            g_pMyFlyingObjectsScreensaver->ReadSettings();

            setupDialogControls(hDlg);

            for (wTmp = 0; wTmp <= MAX_TYPE; wTmp++) {
                LoadString(NULL, idsStyles[wTmp], szString, GEN_STRING_SIZE);
                SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_ADDSTRING, 0,
                                   (LPARAM) szString);
            }
            SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_SETCURSEL, Type, 0);

            return TRUE;


        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case DLG_SETUP_TYPES:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES,
                                                           CB_GETCURSEL, 0, 0);
                            updateDialogControls(hDlg);
                            break;
                        default:
                            break;
                    }
                    return FALSE;

                case DLG_SETUP_TEXTURE:
                    ss_SelectTextureFile( hDlg, &gTexFile );
                    break;

                case DLG_SETUP_MONITORSETTINGS:
                    g_pMyFlyingObjectsScreensaver->DoScreenSettingsDialog( hDlg );
                    break;

                case IDOK:
                    g_pMyFlyingObjectsScreensaver->WriteSettings( hDlg );
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case DLG_SETUP_SMOOTH:
                case DLG_SETUP_CYCLE:
                default:
                    break;
            }
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}





//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CFlyingObjectsScreensaver flyingobjectsSS;

    if( FAILED( hr = flyingobjectsSS.Create( hInst ) ) )
    {
        flyingobjectsSS.DisplayErrorMsg( hr );
        return 0;
    }

    return flyingobjectsSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CFlyingObjectsScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CFlyingObjectsScreensaver::CFlyingObjectsScreensaver( )
{
    g_pMyFlyingObjectsScreensaver = this;
    g_pFloatRect = &m_floatrect;

    ZeroMemory( m_DeviceObjectsArray, sizeof(m_DeviceObjectsArray) );
    m_pDeviceObjects = NULL;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;

    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Flying Objects") );

    m_floatrect.xSize = 0.0f;
    InitCommonControls();

    bSmoothShading = FALSE;
    bColorCycle = FALSE;
    UpdateFlags = (bColorCycle << 1);
    Type = 0;
    fTesselFact = 2.0f;
    uSize = 50;
    ss_GetDefaultBmpFile( gTexFile.szPathName );
    gTexFile.nOffset = 0;

    ss_LoadTextureResourceStrings();

    srand((UINT)time(NULL)); // seed random number generator
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: SetMaterialColor()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::SetMaterialColor(FLOAT* pfColors)
{
    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(mtrl) );
    mtrl.Diffuse.r = mtrl.Ambient.r = pfColors[0];
    mtrl.Diffuse.g = mtrl.Ambient.g = pfColors[1];
    mtrl.Diffuse.b = mtrl.Ambient.b = pfColors[2];
    mtrl.Diffuse.a = mtrl.Ambient.a = pfColors[3];
    mtrl.Specular.r = 1.0f;
    mtrl.Specular.g = 1.0f;
    mtrl.Specular.b = 1.0f;
    mtrl.Specular.a = 1.0f;
    mtrl.Power = 30.0f;

    return m_pd3dDevice->SetMaterial(&mtrl);
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::FrameMove()
{
    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = (FLOAT)uSize / 150.0f;

    //    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    //    size = (DWORD) (sizeFact * ( ((FLOAT)(dwParentWidth + dwParentHeight)) / 2.0f ));

//        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        // Note: there are bouncing problems when size is 100% (gbBounce is always 
        // true) -- things "jitter" too much.  So limit size to 95% for this screensaver.
        sizeFact = 0.25f + (0.70f * sizeScale);     // range 25-95%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on first RenderUnit's screen
        if( !m_bWindowed )
        {
            INT iMonitor = m_RenderUnits[0].iMonitor;
            rcBounds = m_Monitors[iMonitor].rcScreen;
        }
        m_floatrect.xMin = rcBounds.left + ((rcBounds.right - rcBounds.left) - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + ((rcBounds.bottom - rcBounds.top) - size) / 2.0f;
        m_floatrect.xOrigin = m_floatrect.xMin;
        m_floatrect.yOrigin = m_floatrect.yMin;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.xVel = -m_floatrect.xVel;

        m_floatrect.yVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.yVel = -m_floatrect.yVel;

        m_floatrect.xVelMax = m_floatrect.xVel;
        m_floatrect.yVelMax = m_floatrect.yVel;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    if( g_bMoveToOrigin )
    {
        if( m_floatrect.xVel < 0  && m_floatrect.xMin < m_floatrect.xOrigin ||
            m_floatrect.xVel > 0 && m_floatrect.xMin > m_floatrect.xOrigin )
        {
            m_floatrect.xVel = -m_floatrect.xVel;
        }
        if( m_floatrect.yVel < 0  && m_floatrect.yMin < m_floatrect.yOrigin ||
            m_floatrect.yVel > 0 && m_floatrect.yMin > m_floatrect.yOrigin )
        {
            m_floatrect.yVel = -m_floatrect.yVel;
        }
        m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
        m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;

        if( m_floatrect.xVel < 0  && m_floatrect.xMin < m_floatrect.xOrigin ||
            m_floatrect.xVel > 0 && m_floatrect.xMin > m_floatrect.xOrigin )
        {
            m_floatrect.xMin = m_floatrect.xOrigin;
            m_floatrect.xVel = 0.0f;
        }
        if( m_floatrect.yVel < 0  && m_floatrect.yMin < m_floatrect.yOrigin ||
            m_floatrect.yVel > 0 && m_floatrect.yMin > m_floatrect.yOrigin )
        {
            m_floatrect.yMin = m_floatrect.yOrigin;
            m_floatrect.yVel = 0.0f;
        }
        if( m_floatrect.xMin == m_floatrect.xOrigin &&
            m_floatrect.yMin == m_floatrect.yOrigin )
        {
            g_bAtOrigin = TRUE;
        }
    }
    else
    {
        g_bAtOrigin = FALSE;
        if( m_floatrect.xVel == 0.0f )
        {
            m_floatrect.xVel = m_floatrect.xVelMax;
            if( rand() % 2 == 0 )
                m_floatrect.xVel = -m_floatrect.xVel;
        }
        if( m_floatrect.yVel == 0.0f )
        {
            m_floatrect.yVel = m_floatrect.yVelMax;
            if( rand() % 2 == 0 )
                m_floatrect.yVel = -m_floatrect.yVel;
        }

        m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
        m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
        if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
            m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
        {
            gbBounce = TRUE;
            m_floatrect.xMin = xMinOld; // undo last move
            m_floatrect.xVel = -m_floatrect.xVel; // change direction
        }
        if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
            m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
        {
            gbBounce = TRUE;
            m_floatrect.yMin = yMinOld; // undo last move
            m_floatrect.yVel = -m_floatrect.yVel; // change direction
        }
    }

    return S_OK;
}


VOID SetProjectionMatrixInfo( BOOL bOrtho, FLOAT fWidth, 
                              FLOAT fHeight, FLOAT fNear, FLOAT fFar )
{
    g_pMyFlyingObjectsScreensaver->m_bOrtho = bOrtho;
    g_pMyFlyingObjectsScreensaver->m_fWidth = fWidth;
    g_pMyFlyingObjectsScreensaver->m_fHeight = fHeight;
    g_pMyFlyingObjectsScreensaver->m_fNear = fNear;
    g_pMyFlyingObjectsScreensaver->m_fFar = fFar;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
//    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000080, 1.0f, 0L );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -m_fWidth / 2;
    r =  m_fWidth / 2;
    b = -m_fHeight / 2;
    t =  m_fHeight / 2;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    if( m_bOrtho )
    {
        D3DXMatrixOrthoOffCenterLH( &matProj, l, r, b, t, m_fNear, m_fFar );
    }
    else
    {
        D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, b, t, m_fNear, m_fFar );
    }
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Make elapsed time be zero unless time has really advanced since
    // the last call, so things don't move faster in multimon situations.
    // The right way to do this would be to separate the animation code from
    // the rendering code.
    FLOAT fElapsedTime;
    static FLOAT s_fTimeLast = 0.0f;
    if( m_fTime == s_fTimeLast )
        fElapsedTime = 0.0f;
    else
        fElapsedTime = m_fElapsedTime;
    s_fTimeLast = m_fTime;

    // Begin the scene 
    if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
    {
        ::m_pd3dDevice = m_pd3dDevice;
        ::m_pIB = m_pDeviceObjects->m_pIB;
        ::m_pVB = m_pDeviceObjects->m_pVB;
        ::m_pVB2 = m_pDeviceObjects->m_pVB2;
    
        updateSceneFunc( UpdateFlags, fElapsedTime );

        // End the scene.
        m_pd3dDevice->EndScene();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjectsArray[iDevice];
    g_pDeviceObjects = m_pDeviceObjects;

    INT iMonitor = m_RenderUnits[iDevice].iMonitor;
    g_xScreenOrigin = m_Monitors[iMonitor].rcScreen.left;
    g_yScreenOrigin = m_Monitors[iMonitor].rcScreen.top;
    g_iDevice = iDevice;
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFromResource()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT LoadTextureFromResource( LPDIRECT3DDEVICE8 pd3dDevice, 
    TCHAR* strRes, TCHAR* strResType, LPDIRECT3DTEXTURE8* ppTex )
{
    HRESULT hr;
    HMODULE hModule = NULL;
    HRSRC rsrc;
    HGLOBAL hgData;
    LPVOID pvData;
    DWORD cbData;

    rsrc = FindResource( hModule, strRes, strResType );
    if( rsrc != NULL )
    {
        cbData = SizeofResource( hModule, rsrc );
        if( cbData > 0 )
        {
            hgData = LoadResource( hModule, rsrc );
            if( hgData != NULL )
            {
                pvData = LockResource( hgData );
                if( pvData != NULL )
                {
                    if( FAILED( hr = D3DXCreateTextureFromFileInMemory( pd3dDevice, 
                        pvData, cbData, ppTex ) ) )
                    {
                        return hr;
                    }
                }
            }
        }
    }
    
    if( *ppTex == NULL)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;

    ::m_pd3dDevice = m_pd3dDevice;
    

/*
    D3DLIGHT8 light;
    D3DUtil_InitLight( light, D3DLIGHT_POINT, 2.0, 2.0, 10.0 );
    light.Specular.r = 1.0f;
    light.Specular.g = 1.0f;
    light.Specular.b = 1.0f;
    light.Specular.a = 1.0f;
    light.Attenuation0 = 1.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);
*/    
    
    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR(0x20202020) );
/*    if( config.two_sided == GL_FRONT_AND_BACK )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
*/    
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );


    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(mtrl) );
    mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
    mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
    mtrl.Diffuse.b = mtrl.Ambient.b = 1.0f;
    mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;

    m_pd3dDevice->SetMaterial(&mtrl);
    
    if( !_3dfo_Init(NULL) )
        return E_FAIL;

    if( Type == 6 )
    {
        if( FAILED( D3DXCreateTextureFromFile( m_pd3dDevice, gTexFile.szPathName, 
            &m_pDeviceObjects->m_pTexture ) ) )
        {
            LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_DEFTEX), TEXT("JPG"),
                &m_pDeviceObjects->m_pTexture );
        }
    }
    else if( Type == 0 )
    {
        LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDR_FLATFLAG), TEXT("DDS"),
            &m_pDeviceObjects->m_pTexture );
        LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDR_WINLOGO), TEXT("PNG"),
            &m_pDeviceObjects->m_pTexture2 );
    }

    m_pd3dDevice->SetTexture( 0, m_pDeviceObjects->m_pTexture );
    
    if( FAILED( m_pd3dDevice->CreateIndexBuffer( MAX_INDICES * sizeof(WORD),
        D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pIB ) ) )
    {
        return E_FAIL;
    }

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( MAX_VERTICES * sizeof(MYVERTEX),
        D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pVB ) ) )
    {
        return E_FAIL;
    }

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( MAX_VERTICES * sizeof(MYVERTEX2),
        D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX2, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pVB2 ) ) )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pDeviceObjects->m_pTexture );
    SAFE_RELEASE( m_pDeviceObjects->m_pTexture2 );
    SAFE_RELEASE( m_pDeviceObjects->m_pIB );
    SAFE_RELEASE( m_pDeviceObjects->m_pVB );
    SAFE_RELEASE( m_pDeviceObjects->m_pVB2 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ReadSettings()
{
    int    options;
    int    optMask = 1;
    int    tessel=0;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        options = bSmoothShading | bColorCycle<<1;
        DXUtil_ReadIntRegKey( hkey, TEXT("Options"), (DWORD*)&options, options );
        if (options >= 0)
        {
            bSmoothShading = ((options & optMask) != 0);
            optMask <<= 1;
            bColorCycle = ((options & optMask) != 0);
            UpdateFlags = (bColorCycle << 1);
        }

        DXUtil_ReadIntRegKey( hkey, TEXT("Type"), (DWORD*)&Type, Type );

        // Sanity check Type.  Don't want to index into function arrays
        // with a bad index!
        Type = (int)min(Type, MAX_TYPE);

        // Set flag so that updateStripScene will do two strips instead
        // of one.

        if (Type == 3)
            UpdateFlags |= 0x4;

        tessel = (int) (fTesselFact * 100);
        DXUtil_ReadIntRegKey( hkey, TEXT("Tesselation"), (DWORD*)&tessel, tessel );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );

        if (tessel <= 100)
            fTesselFact  = (float)tessel / 100.0f;
        else
            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f);

        DXUtil_ReadIntRegKey( hkey, TEXT("Size"), (DWORD*)&uSize, uSize );
        if (uSize > 100)
            uSize = 100;
        
        // Static size for new winlogo
        if (Type == 0)
        {
            uSize = 75;
            bSmoothShading = TRUE;
        }

        // SS_CLAMP_TO_RANGE2( uSize, 0, 100 );  /* can't be less than zero since it is a UINT */

        // Is there a texture specified in the registry that overrides the
        // default?

        DXUtil_ReadStringRegKey( hkey, TEXT("Texture"), (TCHAR*)&gTexFile.szPathName, 
            MAX_PATH, gTexFile.szPathName );

        DXUtil_ReadIntRegKey( hkey, TEXT("TextureFileOffset"), (DWORD*)&gTexFile.nOffset, gTexFile.nOffset );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ss_ReadSettings()
{
    int    options;
    int    optMask = 1;
    TCHAR  szDefaultBitmap[MAX_PATH];
    int    tessel=0;

    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        options = ss_GetRegistryInt( IDS_OPTIONS, -1 );
        if (options >= 0)
        {
            bSmoothShading = ((options & optMask) != 0);
            optMask <<= 1;
            bColorCycle = ((options & optMask) != 0);
            UpdateFlags = (bColorCycle << 1);
        }

        Type = ss_GetRegistryInt( IDS_OBJTYPE, 0 );

        // Sanity check Type.  Don't want to index into function arrays
        // with a bad index!
        Type = (int)min(Type, MAX_TYPE);

        // Set flag so that updateStripScene will do two strips instead
        // of one.

        if (Type == 3)
            UpdateFlags |= 0x4;

        tessel = ss_GetRegistryInt( IDS_TESSELATION, 100 );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );

        if (tessel <= 100)
            fTesselFact  = (float)tessel / 100.0f;
        else
            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f);

        uSize = ss_GetRegistryInt( IDS_SIZE, 50 );
        if (uSize > 100)
            uSize = 100;
        // SS_CLAMP_TO_RANGE2( uSize, 0, 100 );  /* can't be less than zero since it is a UINT */

        // Determine the default .bmp file

        ss_GetDefaultBmpFile( szDefaultBitmap );

        // Is there a texture specified in the registry that overrides the
        // default?


        ss_GetRegistryString( IDS_TEXTURE, szDefaultBitmap, gTexFile.szPathName,
                              MAX_PATH);

        gTexFile.nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CFlyingObjectsScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CFlyingObjectsScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::DoConfig()
{
    if( IDOK == DialogBox( NULL, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
        m_hWndParent, (DLGPROC)ScreenSaverConfigureDialog ) )
    {
    }
}




//-----------------------------------------------------------------------------
// Name: ConfirmDevice()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer)
{
    if( dwBehavior & D3DCREATE_PUREDEVICE )
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\gendrop.cpp ===
/******************************Module*Header*******************************\
* Module Name: gendrop.c
*
* The Splash style of the 3D Flying Objects screen saver.
*
* Simulation of a drop of water falling into a pool of water.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define FLOAT_SMALL (1e-6)

#define DROPPREC   10

// Remember from pre-calc:
//      x = r cos th
//      y = r sin th
// to convert from polar to rect, and that
//      x = x' cos th - y' sin th
//      y = x' sin th + y' cos th
// to rotate axes.
//
// Also, note that the equation for a lemniscate is:
//      r = sqrt(sin 2*th)
//

static POINT3D *circle;
static POINT3D *drop;
static POINT3D *curves;
static MESH waterMesh;
static MESH waterInmesh;
static MESH waterOutmesh;
static MESH waterBorderMesh;
static MESH *drops;
static int iPrec;
static float fRadiusFact = 0.35f;

static FLOAT light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};

void genCurves()
{
    // iPrec is already protected from getting too low in InitDropScene,
    // but this will make "prefix" happy:
    if( iPrec <= 1 )
        return;

    int i;
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    double rotSin = sin(PI / 4.0);
    double rotCos = cos(PI / 4.0);
    double aFract = 0.0;
    double bFract = 1.0;
    double fractInc = 1.0 / (double)(iPrec - 1);
    POINT3D *pt = curves;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (0.5 * cos(angle));
        circle[i].y = (float) (0.5 * sin(angle));
    }

    step = (-PI / 4.0) / (float)(iPrec - 1);
    start = PI / 4.0;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        double x, y, r;
        double xrot, yrot;
        double sinVal;

        sinVal = sin(2.0 * angle);
        if (sinVal < 0.0)
            sinVal = -sinVal;

        r = 1.5 * sqrt(sinVal);
        x = r * cos(angle);
        y = r * sin(angle);

        xrot = x * rotCos - y * rotSin;
        yrot = x * rotSin + y * rotCos - 1.0;

        drop[i].x = (float) xrot;
        drop[i].y = (float) yrot;
    }


    for (i = 0; i < DROPPREC; i++) {
        int j;

        for (j = 0; j < iPrec; j++, pt++) {
            pt->x = (float) (aFract * circle[j].x +
                             bFract * drop[j].x);

            pt->y = (float) (aFract * circle[j].y +
                             bFract * drop[j].y);

            pt->z = 0.0f;
        }
        aFract += fractInc;
        bFract -= fractInc;
    }
}

#define NORMS(x, y) waterMesh.norms[((x) * iPrec) + y]
#define BNORMS(x, y) waterBorderMesh.norms[((x) * iPrec) + y]
#define INGRID(x, y)  waterInmesh.pts[((x) * iPrec) + y]
#define OUTGRID(x, y)  waterOutmesh.pts[((x) * iPrec) + y]
#define GRID(x, y)  waterMesh.pts[((x) * iPrec) + y]
#define BGRID(x, y)  waterBorderMesh.pts[((x) * iPrec) + y]

void genWater(double freq, double damp, double mag, double w, double minr)
{
    int i;
    int j;
    double r;
    double theta;
    double thetaInc = (2.0 * PI) / (float)iPrec;
    double posInc = 1.0 / (float)iPrec;
    int facecount;
    double xCenter = 0.0;
    double zCenter = 0.0;
    POINT3D norm;
    static BOOL first = TRUE;

    if (first) {
        for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
            for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
                float x, z;
                float dx, dz;
                float rr;

                x = (float) cos(theta);
                z = (float) sin(theta);

                dx = x - (float) xCenter;
                dz = z - (float) zCenter;

                rr = (float) sqrt((dx * dx) + (dz * dz));
                dx /= rr;
                dz /= rr;
                dx *= i / (float)(iPrec - 1);
                dz *= i / (float)(iPrec - 1);
                GRID(i, j).x = dx + (float) xCenter;
                GRID(i, j).z = dz + (float) zCenter;

                INGRID(i, j).y = 0.0f;
                OUTGRID(i, j).y = 0.0f;
            }
        }
    }


    for (i = (iPrec - 1), r = 1.0; i >= 0; i--, r -= posInc) {
        float val;

        if (i == 0) {
            if (minr != 0.0)
                val = (float) (-mag * cos(w + (r * freq)) * exp((-damp * r)/2.0));
            else
                val =  INGRID(0, 0).y * 0.95f;
        } else
            val = OUTGRID(i - 1, 0).y * 0.95f;

        for (j = 0; j < iPrec; j++)
            OUTGRID(i, j).y = val;
    }


    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0; j < iPrec; j++) {
            if (i == iPrec-1)
                INGRID(i, j).y = -OUTGRID(i, j).y;
            else
                INGRID(i, j).y = INGRID(i + 1, j).y * 0.95f;
        }
    }


    waterMesh.numFaces = 0;
    waterBorderMesh.numFaces = 0;

    for (i = 0; i < iPrec; i++) {
        for (j = 0; j < iPrec; j++) {
            NORMS(i, j).x = 0.0f;
            NORMS(i, j).y = 0.0f;
            NORMS(i, j).z = 0.0f;
        }
    }

    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
            GRID(i, j).y = OUTGRID(i, j).y + INGRID(i, j).y;


            if (i == (iPrec - 1)) {
                GRID(i, j).y = 0.0f;

                BGRID(0, j).x = GRID(i, j).x;
                BGRID(0, j).z = GRID(i, j).z;
                BGRID(0, j).y = GRID(i, j).y;

                BGRID(1, j).x = GRID(i, j).x;
                BGRID(1, j).z = GRID(i, j).z;
                BGRID(1, j).y = -0.5f;
            }
        }
    }

    for (i = 0; i < 2; i++) {
        for (j = 0; j < iPrec; j++) {
            BNORMS(i, j).x = 0.0f;
            BNORMS(i, j).y = 0.0f;
            BNORMS(i, j).z = 0.0f;
        }
    }

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &GRID(k, j), &GRID(i, j), &GRID(i, l));

            if (norm.x > -FLOAT_SMALL && norm.x < FLOAT_SMALL &&
                norm.y > -FLOAT_SMALL && norm.y < FLOAT_SMALL &&
                norm.z > -FLOAT_SMALL && norm.z < FLOAT_SMALL)
                ss_calcNorm(&norm, &GRID(i, l), &GRID(k, l), &GRID(k, j));


            waterMesh.faces[facecount].material = 0;
            waterMesh.faces[facecount].norm = norm;

            NORMS(i, j).x += norm.x;
            NORMS(i, j).y += norm.y;
            NORMS(i, j).z += norm.z;

            NORMS(k, j).x += norm.x;
            NORMS(k, j).y += norm.y;
            NORMS(k, j).z += norm.z;

            NORMS(i, l).x += norm.x;
            NORMS(i, l).y += norm.y;
            NORMS(i, l).z += norm.z;

            NORMS(k, l).x += norm.x;
            NORMS(k, l).y += norm.y;
            NORMS(k, l).z += norm.z;

            waterMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterMesh.numFaces++;
            facecount++;
        }
    }

    waterMesh.numPoints = iPrec * iPrec;

    for (facecount = 0, i = 0; i < 1; i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &BGRID(k, j), &BGRID(i, j), &BGRID(i, l));

            waterBorderMesh.faces[facecount].material = 0;
            waterBorderMesh.faces[facecount].norm = norm;

// Setting SMOOTH_BORDER will render the border (the sides of the "pool")
// with smooth shading.  This effect is good at higher tesselations, but
// doesn't really look that good for low tesselations.
//
// A possible enhancement for later: use smooth shading if tesselation
// exceeds some threshold.  Should we just pick some arbitrary threshold?
// Make it a setup option?  Things look pretty good now, so don't bother?

#if SMOOTH_BORDER
            BNORMS(i, j).x += norm.x;
            BNORMS(i, j).y += norm.y;
            BNORMS(i, j).z += norm.z;

            if (i) {
                BNORMS(i-1, j).x += norm.x;
                BNORMS(i-1, j).y += norm.y;
                BNORMS(i-1, j).z += norm.z;
            }
            if (j) {
                BNORMS(i, j-1).x += norm.x;
                BNORMS(i, j-1).y += norm.y;
                BNORMS(i, j-1).z += norm.z;
            }

            BNORMS(k, j).x += norm.x;
            BNORMS(k, j).y += norm.y;
            BNORMS(k, j).z += norm.z;

            BNORMS(i, l).x += norm.x;
            BNORMS(i, l).y += norm.y;
            BNORMS(i, l).z += norm.z;
#else
            BNORMS(i, j) = norm;

            if (i)
                BNORMS(i-1, j) = norm;
            if (j)
                BNORMS(i, j-1) = norm;

            BNORMS(k, j) = norm;
            BNORMS(i, l) = norm;
#endif

            waterBorderMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterBorderMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterBorderMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterBorderMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterBorderMesh.numFaces++;
            facecount++;
        }
    }
    waterBorderMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(waterBorderMesh.norms, waterBorderMesh.numPoints);
    ss_normalizeNorms(waterMesh.norms, waterMesh.numPoints);

    first = FALSE;
}


BOOL initDropScene()
{
    int i;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 4)
        iPrec = 4;

    if (fTesselFact > fRadiusFact)
        fRadiusFact = fTesselFact;

    circle = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    if( circle == NULL )
        return FALSE;

    drop = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    if( drop == NULL )
        return FALSE;

    curves = (POINT3D *)SaverAlloc(DROPPREC * iPrec * sizeof(POINT3D));
    if( curves == NULL )
        return FALSE;

    drops = (MESH *)SaverAlloc(DROPPREC * sizeof(MESH));
    if( drops == NULL )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 3.0, 3.0, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 3.0, 3.0, 0.0, 3.0 );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    if (!newMesh(&waterInmesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterOutmesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterMesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterBorderMesh, iPrec, 2 * iPrec) )
        return FALSE;
    genCurves();

    for (i = 0; i < DROPPREC; i++)
        revolveSurface(&drops[i], &curves[i * iPrec], iPrec);
    return TRUE;
}

void delDropScene()
{
    int i;

    for (i = 0; i < DROPPREC; i++) {
        delMesh(&drops[i]);
    }

    SaverFree(circle);
    SaverFree(drop);
    SaverFree(curves);
    SaverFree(drops);
    
    delMesh(&waterMesh);
    delMesh(&waterInmesh);
    delMesh(&waterOutmesh);
    delMesh(&waterBorderMesh);
}


void updateDropScene(int flags, FLOAT fElapsedTime)
{
    static double zrot = 0.0;
    static double yrot = 0.0;
    static double myrot = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 3.0;
    static double yrotInc = 1.5;
    static double ypos = 1.0;
    static int dropnum = 0;
    static double radius = 0.3;
    static double damp = 1.0;
    static double mag = 0.0;
    static double w = 1.0;
    static double freq = 1.0;
    static double dist;
    static double minr = 0.0;
    static FLOAT fH = 0.0f;
    static FLOAT fTimer = 0.0f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    if( fTimeFactor > 0.25f )
        fTimeFactor = 0.25f;
    RGBA color;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;

    zrot += zrotInc * fTimeFactor;
    if (zrot >= 45.0) {
        zrot = 45.0;
        zrotInc = -(2.0 + ((float)rand() / (float)RAND_MAX) * 3.0);
    } else if (zrot <= -45.0) {
        zrot = -45.0;
        zrotInc = 2.0 + ((float)rand() / (float)RAND_MAX) * 3.0;
    }

    yrot += yrotInc * fTimeFactor;
    if (yrot >= 10.0) {
        yrot = 10.0;
        yrotInc = -(1.0 + ((float)rand() / (float)RAND_MAX) * 2.0);
    } else if (zrot <= -10.0) {
        yrot = -10.0;
        yrotInc = 1.0 + ((float)rand() / (float)RAND_MAX) * 2.0;
    }

    if ((ypos + 0.5 < -radius) && (mag < 0.05)) {
        radius = (float)rand() / (6.0 * (float)RAND_MAX) + 0.1;
        ypos = 1.0;
        dropnum = 0;
    }

    dist = (ypos + 0.5);
    if ((dist > -radius / 2.0) && (dist < radius / 2.0)) {
        if (dist <= 0.0)
            dist = radius / 2.0;
        else
            dist = (radius / 2.0) - dist;
        freq = (0.25 * PI) / dist;
        if (freq < 0.2)
            freq = 0.2;

        minr = radius;

        damp = 20.0;
        mag = (0.35 / fRadiusFact) + 0.2 * dist;

        w = 0;
    } else {
        minr -= 0.05 * fTimeFactor;
        if (minr < 0.0)
            minr = 0.0;

        mag = mag * 0.95 * fTimeFactor;
        if (minr == 0.0) {
            w -= (PI / 6.0) * fTimeFactor;
            mag *= 0.75 * fTimeFactor;
        }
        if (damp > 0.0)
            damp -= 1.0 * fTimeFactor;
    }

    // Only call genWater about 10x per second
    fTimer += fElapsedTime;
    if( fTimer > 0.07f)
    {
        genWater(freq, damp, mag, w, minr);
        fTimer = 0.0f;
    }

    D3DXMatrixRotationZ(&mat1, D3DXToRadian((FLOAT)zrot));
    D3DXMatrixRotationX(&mat2, D3DXToRadian(30.0f));
    D3DXMatrixTranslation(&mat3, 0.0f, -0.5f, 0.0f);
    D3DXMatrixRotationY(&mat4, D3DXToRadian((FLOAT) (myrot * (180.0 / PI))));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    } else {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &Material[6].Diffuse);
    }

    RenderMesh3(&waterMesh, bSmoothShading);

    if (!bColorCycle)
    {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &Material[2].Diffuse);

    }
    RenderMesh3(&waterBorderMesh, FALSE);

    if (dist > -radius) {

        if (!bColorCycle)
        {
            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (FLOAT *) &Material[6].Diffuse);
        }
        D3DXMatrixRotationZ(&mat1, D3DXToRadian((FLOAT)zrot));
        D3DXMatrixRotationX(&mat2, D3DXToRadian(30.0f));
        D3DXMatrixTranslation(&mat3, 0.0f, (FLOAT) ypos, 0.0f);
        D3DXMatrixScaling(&mat4, (FLOAT) radius, (FLOAT) radius, (FLOAT) radius);
        D3DXMatrixRotationX(&mat5, D3DXToRadian(180.0f));
        matFinal = mat5 * mat4 * mat3 * mat2 * mat1;
        m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );
        
        RenderMesh3( &drops[dropnum], bSmoothShading );
    }

    myrot += myrotInc * fTimeFactor;

    ypos -= 0.08 * fTimeFactor;
    dropnum = (int) ((DROPPREC - 1) - (ypos * (DROPPREC - 1)));
    if (dropnum > (DROPPREC - 1))
        dropnum = DROPPREC - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\flyingobjects.h ===
//-----------------------------------------------------------------------------
// File: FlyingObjects.h
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _FLYINGOBJECTS_H
#define _FLYINGOBJECTS_H

#include "resource.h"

#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

#define GEN_STRING_SIZE 64

typedef struct _point2d {
    FLOAT x;
    FLOAT y;
} POINT2D;

typedef struct _ipoint2d {
    int x;
    int y;
} IPOINT2D;

typedef D3DXVECTOR3 POINT3D;

typedef struct _ipoint3d {
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d {
    FLOAT s;
    FLOAT t;
} TEX_POINT2D;

typedef struct _isize {
    int width;
    int height;
} ISIZE;

typedef struct _fsize {
    FLOAT width;
    FLOAT height;
} FSIZE;

typedef struct _glrect {
    int x, y;
    int width, height;
} GLRECT;

// texture data
typedef struct {
    int     width;
    int     height;
    DWORD  format;
    INT components;
    float   origAspectRatio; // original width/height aspect ratio
    unsigned char *data;
    DWORD  texObj;          // texture object
    int     pal_size;
    int     iPalRot;         // current palette rotation (not used yet)
    RGBQUAD *pal;
} TEXTURE, *HTEXTURE;


// texture resource

#define RT_RGB          99
#define RT_MYBMP        100
#define RT_A8           101

// texture resource types
enum {
    TEX_UNKNOWN = 0,
    TEX_RGB,
    TEX_BMP,
    TEX_A8
};

typedef struct {
    int     type;
    int     name;
} TEX_RES;


typedef struct _MATRIX {
    FLOAT M[4][4];
} MATRIX;
//typedef D3DXMATRIX MATRIX;

typedef struct strRGBA {
    FLOAT r;
    FLOAT g;
    FLOAT b;
    FLOAT a;
} RGBA;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
} RGB8;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
    BYTE a;
} RGBA8;


typedef struct _MATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    FLOAT specExp;
} MATERIAL;

// texture file info

typedef struct {
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;

// texture file processing messages

typedef struct {
    TCHAR   szWarningMsg[MAX_PATH];
    TCHAR   szBitmapSizeMsg[MAX_PATH];
    TCHAR   szBitmapInvalidMsg[MAX_PATH];
    TCHAR   szSelectAnotherBitmapMsg[MAX_PATH];
    TCHAR   szTextureDialogTitle[GEN_STRING_SIZE];
    TCHAR   szTextureFilter[2*GEN_STRING_SIZE];
    TCHAR   szBmp[GEN_STRING_SIZE];
    TCHAR   szDotBmp[GEN_STRING_SIZE];
} TEX_STRINGS;

// Useful macros

#define SS_MAX( a, b ) \
    ( a > b ? a : b )

#define SS_MIN( a, b ) \
    ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval ) \
    ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \
    ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

// degree<->radian macros
#define ONE_OVER_180 (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI )

extern MATERIAL TeaMaterial[], TexMaterial[], ss_BlackMat;


// color

extern void ss_HsvToRgb(float h, float s, float v, RGBA *color );


// texture file processing

extern void ss_DisableTextureErrorMsgs();
extern void ss_SetTexture( TEXTURE *pTex );
extern void ss_SetTexturePalette( TEXTURE *pTex, int index );
extern void ss_DeleteTexture( TEXTURE *pTex );
extern BOOL ss_LoadTextureResourceStrings();
extern BOOL ss_VerifyTextureFile( TEXFILE *ptf );
extern BOOL ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf );
extern void ss_GetDefaultBmpFile( LPTSTR pszBmpFile );
extern void ss_InitAutoTexture( TEX_POINT2D *pTexRep );

// math functions

extern POINT3D ss_ptZero;
extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_matrixIdent(MATRIX *);
extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 );
extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void ss_normalizeNorm(POINT3D *);
extern void ss_normalizeNorms(POINT3D *, ULONG);

// dialog helper functions

extern int ss_GetTrackbarPos( HWND hDlg, int item );
extern void ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, int pageSize, int pos );

extern BOOL gbTextureObjects; // from texture.c

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    D3DXVECTOR3 n;     // Normal
};

#define D3DFVF_MYVERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL )


//-----------------------------------------------------------------------------
// Name: struct MYVERTEX2
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX2
{
    D3DXVECTOR3 p;      // Position
    D3DXVECTOR3 n;      // Normal
    FLOAT       tu, tv; // Vertex texture coordinates

};

#define D3DFVF_MYVERTEX2 ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX3
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX3
{
    D3DXVECTOR3 p;      // Position
    FLOAT       rhw;
    DWORD       dwDiffuse;
    FLOAT       tu, tv; // Vertex texture coordinates

};

#define D3DFVF_MYVERTEX3 ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#define MAX_VERTICES 5000
#define MAX_INDICES 5000


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;

    FLOAT xVel;
    FLOAT yVel;

    FLOAT xOrigin;
    FLOAT yOrigin;
    FLOAT xVelMax;
    FLOAT yVelMax;
};



#ifndef PI
#define PI 3.14159265358979323846
#endif



// Minimum and maximum number of side subdivisions
#define MINSUBDIV 2
#define MAXSUBDIV 10

// Maximum values allowed
#define MAXSIDES 8
#define MAXSPTS ((MAXSUBDIV+1)*(MAXSUBDIV+1))
#define MAXPTS (MAXSIDES*MAXSPTS)
#define MAXSFACES (MAXSUBDIV*MAXSUBDIV)
#define MAXFACES (MAXSIDES*MAXSFACES)
#define MAXFPTS 4

// Allow floating point type configurability
typedef FLOAT FLT;
typedef struct
{
    FLT x, y, z;
} PT3;

extern LPDIRECT3DDEVICE8 m_pd3dDevice;
extern LPDIRECT3DINDEXBUFFER8 m_pIB;
extern LPDIRECT3DVERTEXBUFFER8 m_pVB;
extern LPDIRECT3DVERTEXBUFFER8 m_pVB2;

#define DIMA(a) (sizeof(a)/sizeof(a[0]))


#define PALETTE_PER_MATL    32
#define PALETTE_PER_DIFF    26
#define PALETTE_PER_SPEC    6
#define MATL_MAX            7

typedef struct strFACE {
    POINT3D p[4];
    POINT3D n[4];
    POINT3D fn;
    int idMatl;
} FACE;

typedef struct strMFACE {
    int p[4];
    int material;
    POINT3D norm;
} MFACE;

typedef struct strMESH {
    int numFaces;
    int numPoints;
    POINT3D *pts;
    POINT3D *norms;
    MFACE *faces;
    INT listID;
} MESH;


/******************************Public*Routine******************************\
*
* Basic vector math macros
*
* History:
*  Wed Jul 19 14:49:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define V3Sub(a, b, r) \
    ((r)->x = (a)->x-(b)->x, (r)->y = (a)->y-(b)->y, (r)->z = (a)->z-(b)->z)
#define V3Add(a, b, r) \
    ((r)->x = (a)->x+(b)->x, (r)->y = (a)->y+(b)->y, (r)->z = (a)->z+(b)->z)
#define V3Cross(a, b, r) \
    ((r)->x = (a)->y*(b)->z-(b)->y*(a)->z,\
     (r)->y = (a)->z*(b)->x-(b)->z*(a)->x,\
     (r)->z = (a)->x*(b)->y-(b)->x*(a)->y)
extern FLT V3Len(PT3 *v);


#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    LPDIRECT3DTEXTURE8 m_pTexture;
    LPDIRECT3DTEXTURE8 m_pTexture2;
    LPDIRECT3DINDEXBUFFER8 m_pIB;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;  // D3DFVF_MYVERTEX (no tex coords)
    LPDIRECT3DVERTEXBUFFER8 m_pVB2; // D3DFVF_MYVERTEX2 (tex coords)
};



extern DeviceObjects* g_pDeviceObjects;
extern FLOATRECT* g_pFloatRect;
extern INT g_xScreenOrigin;
extern INT g_yScreenOrigin;
extern INT g_iDevice;
extern BOOL g_bMoveToOrigin;
extern BOOL g_bAtOrigin;
extern BOOL bSmoothShading;
extern BOOL bFalseColor;
extern BOOL bColorCycle;
extern float fTesselFact;
extern TEXFILE gTexFile;
extern BOOL gbBounce;

extern D3DMATERIAL8 Material[];
extern int NumLights;

extern BOOL newMesh(MESH *, int numFaces, int numPts);
extern void delMesh(MESH *);
extern void revolveSurface(MESH *, POINT3D *curve, int steps);

extern void *SaverAlloc(ULONG);
extern void SaverFree(void *);

#ifndef GL_FRONT
#define GL_FRONT                          0x0404
#endif

#ifndef GL_FRONT_AND_BACK
#define GL_FRONT_AND_BACK                 0x0408
#endif

#ifndef GL_AMBIENT_AND_DIFFUSE
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#endif

#ifndef GL_SHININESS
#define GL_SHININESS                      0x1601
#endif

#ifndef GL_SPECULAR
#define GL_SPECULAR                       0x1202
#endif



extern VOID myglMaterialfv(INT face, INT pname, FLOAT* params);
extern VOID myglMaterialf(INT face, INT pname, FLOAT param);

VOID SetProjectionMatrixInfo( BOOL bOrtho, FLOAT fWidth, 
                              FLOAT fHeight, FLOAT fNear, FLOAT fFar );

class   CFlyingObjectsScreensaver : public CD3DScreensaver
{
protected:
    FLOATRECT m_floatrect;
    DeviceObjects  m_DeviceObjectsArray[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;

public:
    // Projection matrix settings
    BOOL m_bOrtho;
    FLOAT m_fWidth;
    FLOAT m_fHeight;
    FLOAT m_fNear;
    FLOAT m_fFar;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    SetDevice( UINT iDevice );
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer);
    VOID            WriteSettings( HWND hdlg );

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    static BOOL CALLBACK ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                         WPARAM wParam, LPARAM lParam);
    HRESULT SetMaterialColor(FLOAT* pfColors);
    BOOL _3dfo_Init(void *data);
    void _3dfo_Draw(void *data);


public:
    CFlyingObjectsScreensaver();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\genlem.cpp ===
/******************************Module*Header*******************************\
* Module Name: genlem.c
*
* The Twist style of the 3D Flying Objects screen saver.
*
* Solid model of a 3D lemniscate.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
//#include <GL\gl.h>
#include <string.h>
#include <math.h>
//#include "ss3dfo.h"
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define ROT_PREC    10
#define NORMS(x, y) lemMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  lemMesh.pts[((x) * iPrec) + y]

static MESH lemMesh;
static POINT3D basis[ROT_PREC];
static double zrot = 0.2;
static int iPrec = 32;
static double *lemX;
static double *lemY;
static double *lemXT;
static double *lemYT;


static void getLem(double index, double max, double *angle, double *r)
{    
    double a, sina;

    a = (index * PI) / (max - 1.0);
    if (a >= PI)
        a -= PI;
    if (a > PI / 2.0) {
        *angle = (2.0 * PI) - a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0; // protect against sqrt fpe
        *r = 0.5 * sqrt(sina);
    } else {
        *angle = a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0;
        *r = 0.5 * sqrt(sina);
    }
}            


static void initLemCoords(int iMax)
{
    int i;
    double max = (double)iMax;
    double angle;
    double r;

    for (i = 0; i < iMax; i++) {
        getLem((double)i, (double)iPrec, &angle, &r);        
        lemX[i] = r * cos(angle);
        lemY[i] = r * sin(angle);
        
        getLem((double)i + 0.00001, (double)iPrec, &angle, &r);        
        lemXT[i] = r * cos(angle);
        lemYT[i] = r * sin(angle);

    }
}


void genLemniscate(void)
{
    int i;
    int j;
    double posInc = 2.0 / (float)iPrec;
    int facecount = 0;
    int ptcount = 0;
    POINT3D norm;
    static float twistFact = 0.0f;
    static float twistFactAdd = 0.05f;
    POINT3D a[ROT_PREC];
    POINT3D b[ROT_PREC];
    MATRIX matrix;
    MESH *mesh = &lemMesh;

    mesh->numPoints = 0;   
    mesh->numFaces = 0;   
    for (i = 0; i < (iPrec - 1) * (ROT_PREC - 1); i++)
        mesh->norms[i] = ss_ptZero;

    for (i = 0; i < (iPrec - 1); i++) {
        double x1, y1, x2, y2;
        double len;
        double sinAngle;
        double rotZ;
        int id[4];

        x1 = lemX[i];
        y1 = lemY[i];
        x2 = lemXT[i];
        y2 = lemYT[i];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);
        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * (float)i) / ((float)iPrec - 1)));
        
        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&a[j], &basis[j], &matrix);

        x1 = lemX[i+1];
        y1 = lemY[i+1];

        x2 = lemXT[i+1];
        y2 = lemYT[i+1];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);

        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);        
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * ((float)i + 1.0)) / ((float)iPrec - 1)));

        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&b[j], &basis[j], &matrix);
            
        memcpy(&mesh->pts[ptcount], &a, sizeof(POINT3D) * (ROT_PREC - 1));
        ptcount += (ROT_PREC - 1);
        mesh->numPoints += (ROT_PREC - 1);
        
            
        for (j = 0; j < (ROT_PREC - 1); j++) {
            int k;
            int jj;
            
            if (j == (ROT_PREC - 2))
                jj = 0;
            else
                jj = j + 1;

            ss_calcNorm(&norm, &b[j + 1], &b[j], &a[j]);
            
            mesh->faces[facecount].material = 3;
            mesh->faces[facecount].norm = norm;
            if (i == iPrec - 2) {
                id[0] = mesh->faces[facecount].p[0] = j;
                id[1] = mesh->faces[facecount].p[1] = jj;
            } else {
                id[0] = mesh->faces[facecount].p[0] = ptcount + j;
                id[1] = mesh->faces[facecount].p[1] = ptcount + jj;
            }
            id[2] = mesh->faces[facecount].p[2] = ptcount - (ROT_PREC - 1) + j;
            id[3] = mesh->faces[facecount].p[3] = ptcount - (ROT_PREC - 1) + jj;
            
            for (k = 0; k < 4; k++) {
                POINT3D *pn = &mesh->norms[id[k]];
                
                pn->x += norm.x;
                pn->y += norm.y;
                pn->z += norm.z;
            }
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(lemMesh.norms, lemMesh.numPoints);
        
    if (twistFact >= 1.0f)
        twistFactAdd = -0.01f;
    else if (twistFact <= -1.0f)
        twistFactAdd = 0.01f;
    twistFact += twistFactAdd;
        
}

BOOL initLemScene()
{
    int i;
    RGBA lightAmbient = {0.0f, 0.0f, 0.0f, 1.0f};

    iPrec = (int)(fTesselFact * 32.5);
    if (iPrec < 5)
        iPrec = 5;

    lemX = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemX == NULL )
        return FALSE;

    lemY = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemY == NULL )
        return FALSE;

    lemXT = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemXT == NULL )
        return FALSE;

    lemYT = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemYT == NULL )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 3.0, 3.0, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 3.0f, 3.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    if (!newMesh(&lemMesh, (ROT_PREC - 1) * (iPrec - 1) , 
            (ROT_PREC - 1) * (iPrec - 1)) )
    {
        return FALSE;
    }

    for (i = 0; i < ROT_PREC; i++) {
        basis[i].x = 0.0f;
        basis[i].y = (float) (0.15 * cos((i * 2.0 * PI) / (ROT_PREC - 1.0)));
        basis[i].z = (float) (0.15 * sin((i * 2.0 * PI) / (ROT_PREC - 1.0)));
    }

    initLemCoords(iPrec);
/*
    glFrontFace(GL_CW);
    glEnable(GL_CULL_FACE);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (FLOAT *) &lightAmbient);
*/
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                 (FLOAT *) &Material[3].Diffuse);

    return TRUE;
}

void delLemScene()
{
    delMesh(&lemMesh);

    SaverFree(lemX);
    SaverFree(lemY);
    SaverFree(lemXT);
    SaverFree(lemYT);
}

void updateLemScene(int flags, FLOAT fElapsedTime)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 0.1;
    static double mzrotInc = 0.0;
    RGBA color;
    MATRIX model;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;
    static FLOAT fH = 0.0f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    if( fTimeFactor > 0.25f )
        fTimeFactor = 0.25f;
    
    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if( gbBounce ) {
        // floating window bounced off an edge
        if (mxrotInc) {
            mxrotInc = 0.0;
            myrotInc = 0.1;
        } else if (myrotInc) {
            myrotInc = 0.0;
            mzrotInc = 0.1;
        } else if (mzrotInc) {
            mzrotInc = 0.0;
            mxrotInc = 0.1;
        }
        gbBounce = FALSE;
    }

    zrot += zrotInc * fTimeFactor;
    if (zrot >= PI / 4.0) {
        zrot = PI / 4.0;
        zrotInc = -0.03;
    } else if (zrot <= -PI / 4.0) {
        zrot = -PI / 4.0;
        zrotInc = 0.03;
    }

    genLemniscate();

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &color);

        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
/*
    glRotatef((FLOAT) (zrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef(50.0f, 1.0f, 0.0f, 0.0f);
    glRotatef(50.0f, 0.0f, 0.0f, 1.0f);
*/

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
/*
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0f, -0.5f, 0.0f);
    glRotatef((FLOAT) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f);
    glRotatef((FLOAT) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef((FLOAT) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f);
*/
    D3DXMatrixTranslation(&mat1, 0.0f, -0.5f, 0.0f);
    D3DXMatrixRotationX(&mat2, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
    D3DXMatrixRotationY(&mat3, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
    D3DXMatrixRotationZ(&mat4, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    ss_matrixIdent(&model);
    ss_matrixRotate(&model, mxrot, myrot, mzrot);
    ss_matrixTranslate(&model, 0.0, -0.5, 0.0);

//    updateObject(&lemMesh, bSmoothShading);    
    RenderMesh3(&lemMesh, bSmoothShading);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\genstrip.cpp ===
/******************************Module*Header*******************************\
* Module Name: genstrip.c
*
* The Ribbon and 2 Ribbon styles of the 3D Flying Objects screen saver.
*
* Animation of 1 or 2 quad strips floating about.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

static MESH stripMesh;
static int iPrec = 40;

void genStrip(FLOAT fTimeFactor)
{
    static int counter = 0;
    int i;
    int facecount;
    // Use Hermite basis, pg 488, FVD
    static float M[4][4] = {{2.0f, -2.0f, 1.0f, 1.0f},
                            {-3.0f, 3.0f, -2.0f, -1.0f},
                            {0.0f, 0.0f, 1.0f, 0.0f},
                            {1.0f, 0.0f, 0.0f, 0.0f}};
    float xx[4], yy[4], zz[4];
    float cx[4], cy[4], cz[4];
    float d = 1.0f / (float) iPrec;
    float t = 0.0f;
    float t2, t3;
    POINT3D p1(-0.5f, 0.0f, 0.0f);
    POINT3D p2(0.5f, 0.0f, 0.0f);
    POINT3D v1(1.5f, 1.5f, 0.0f);
    POINT3D v2(0.0f, 3.0f, 0.0f);
    POINT3D norm;
    float sinVal;
    float angle;
    float angleStep = (float) (PI / iPrec);
    static float rotA = 0.0f;
    static float rotB = (float) (PI / 2.0);
    static float sideSin = 0.0f;
    float rotStepA = (float) (PI / (2.0 * iPrec)) * fTimeFactor;
    float rotStepB = (float) (PI / (4.0 * iPrec)) * fTimeFactor;
    MESH *mesh = &stripMesh;

#define NORMS(x, y) stripMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  stripMesh.pts[((x) * iPrec) + y]
    
    v1.x = (float) (4.0 * cos(rotA));
    v1.y = (float) (4.0 * sin(rotA));

    p2.x = (float) (0.5 * sin(rotB));
//    p2.y = (float) (0.5 * sin(rotB));
    
    rotA += rotStepA;
    rotB += rotStepB;
    counter++;
    if (counter >= (2 * iPrec)) {
        rotStepA = -rotStepA;
        counter = 0;
    }

    angle = sideSin;
    sideSin += (float) (PI / 80.0);
    
    xx[0] = p1.x;
    xx[1] = p2.x;
    xx[2] = v1.x;
    xx[3] = v2.x;

    yy[0] = p1.y;
    yy[1] = p2.y;
    yy[2] = v1.y;
    yy[3] = v2.y;

    zz[0] = p1.z;
    zz[1] = p2.z;
    zz[2] = v1.z;
    zz[3] = v2.z;
    
    for (i = 0; i < 4; i++) {
        cx[i] = xx[0] * M[i][0] + xx[1] * M[i][1] +
                xx[2] * M[i][2] + xx[3] * M[i][3];
        cy[i] = yy[0] * M[i][0] + yy[1] * M[i][1] +
                yy[2] * M[i][2] + yy[3] * M[i][3];
        cz[i] = zz[0] * M[i][0] + zz[1] * M[i][1] +
                zz[2] * M[i][2] + zz[3] * M[i][3];
    }

    for (i = 0; i < iPrec; i++) {
        float x, y;
            
        t += d;
        t2 = t * t;
        t3 = t2 * t;
        
        x = cx[0] * t3 + cx[1] * t2 + cx[2] * t + cx[3];
        y = cy[0] * t3 + cy[1] * t2 + cy[2] * t + cy[3];
        
        sinVal = (float) (sin(angle) / 5.0);
        if (sinVal < 0.0)
            sinVal = -sinVal;
        angle += angleStep;
       
        GRID(0, i).x = x;
        GRID(0, i).z = y;
        GRID(0, i).y = 0.25f;    // extrusion // + sinVal;
        GRID(1, i).x = x;
        GRID(1, i).z = y;
        GRID(1, i).y = -0.25f;   // - sinVal;
    }

    stripMesh.numFaces = 0;
    
    for (i = 0; i < 2 * iPrec; i++)
        mesh->norms[i] = ss_ptZero;

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        
        ss_calcNorm(&norm, &GRID(0, i + 1), &GRID(0, i), &GRID(1, i));
        stripMesh.faces[facecount].material = 0;
        stripMesh.faces[facecount].norm = norm;
            
        NORMS(0, i).x += norm.x;
        NORMS(0, i).y += norm.y;
        NORMS(0, i).z += norm.z;
        NORMS(1, i).x += norm.x;
        NORMS(1, i).y += norm.y;
        NORMS(1, i).z += norm.z;

        if (i != (iPrec - 1)) {
            NORMS(0, i+1).x += norm.x;
            NORMS(0, i+1).y += norm.y;
            NORMS(0, i+1).z += norm.z;
            NORMS(1, i+1).x += norm.x;
            NORMS(1, i+1).y += norm.y;
            NORMS(1, i+1).z += norm.z;
        }

        stripMesh.faces[facecount].p[0] = i;
        stripMesh.faces[facecount].p[1] = iPrec + i;
        stripMesh.faces[facecount].p[2] = i + 1;
        stripMesh.faces[facecount].p[3] = iPrec + i + 1;
        stripMesh.numFaces++;
        facecount++;
    }

    stripMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(stripMesh.norms, stripMesh.numPoints);
}




BOOL initStripScene()
{
    iPrec = (int)(fTesselFact * 40.5);
    if (iPrec < 4)
        iPrec = 4;

    if( !newMesh(&stripMesh, iPrec, 2 * iPrec) )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 2.2f, 2.2f, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 2.2f, 2.2f, 0.0f, 3.0f );

    D3DXMATRIX mat1, mat2, mat3, mat4, matFinal;
    D3DXMatrixTranslation(&mat1, 0.0f, 0.0f, 1.5f);
    D3DXMatrixRotationX(&mat2, D3DXToRadian(50.0f));
    D3DXMatrixRotationY(&mat3, D3DXToRadian(50.0f));
    D3DXMatrixRotationZ(&mat4, D3DXToRadian(12.0f));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matFinal );

//    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    return TRUE;
}

void delStripScene()
{
    delMesh(&stripMesh);
}

void updateStripScene(int flags, FLOAT fElapsedTime)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double mzrotInc = 0.0;
    static FLOAT fH = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    RGBA color;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;

    // This is to deal with when you set maximum size and
    // gbBounce is TRUE every frame.  If that's happening,
    // don't toggle the rotInc's or the scene will jiggle.
    static BOOL bBounceLast = FALSE;

    if( gbBounce ) {
        if( bBounceLast )
        {
        }
        else
        {
            // floating window bounced off an edge
            if (mxrotInc) {
                mxrotInc = 0.0;
                myrotInc = 0.1;
            } else if (myrotInc) {
                myrotInc = 0.0;
                mzrotInc = 0.1;
            } else if (mzrotInc) {
                mzrotInc = 0.0;
                mxrotInc = 0.1;
            }
        }
        gbBounce = FALSE;
        bBounceLast = TRUE;
    }
    else
    {
        bBounceLast = FALSE;
    }

    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );

    genStrip(fTimeFactor);

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    } else {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                     (FLOAT *) &Material[1].Diffuse);
    }

    RenderMesh3(&stripMesh, bSmoothShading);
    RenderMesh3Backsides(&stripMesh, bSmoothShading);

    if (flags & 0x4) 
    {
        D3DXMatrixTranslation(&mat1, 0.05f, 0.0f, 0.0f);
        D3DXMatrixRotationX(&mat2, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
        D3DXMatrixRotationY(&mat3, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
        D3DXMatrixRotationZ(&mat4, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
        matFinal = mat4 * mat3 * mat2 * mat1 ;
        m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

        if (bColorCycle) {
            color.r = 1.0f - color.r;
            color.g = 1.0f - color.g;
            color.b = 1.0f - color.b;

            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (FLOAT *) &color);
        } else {
            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                         (FLOAT *) &Material[2].Diffuse);
        }

        RenderMesh3(&stripMesh, bSmoothShading);
        RenderMesh3Backsides(&stripMesh, bSmoothShading);
    }

    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\genexpld.cpp ===
/******************************Module*Header*******************************\
* Module Name: genexpld.c
*
* The Explode style of the 3D Flying Objects screen saver.
*
* Simulation of a sphere that occasionally explodes.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define RADIUS         	0.3
#define STEPS    	30
#define MAXPREC		20

static MATRIX *faceMat;
static float *xstep;
static float *ystep;
static float *zstep;
static float *xrot;
static float *yrot;
static float *zrot;
static MESH explodeMesh;
static int iPrec = 10;

// Data type accepted by glInterleavedArrays
typedef struct _POINT_N3F_V3F {
    POINT3D normal;
    POINT3D vertex;
} POINT_N3F_V3F;

static POINT_N3F_V3F *pN3V3;

static FLOAT matl1Diffuse[] = {1.0f, 0.8f, 0.0f, 1.0f};
static FLOAT matl2Diffuse[] = {0.8f, 0.8f, 0.8f, 1.0f};
static FLOAT matlSpecular[] = {1.0f, 1.0f, 1.0f, 1.0f};
static FLOAT light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};

void genExplode()
{
    int i;
    POINT3D circle[MAXPREC+1];
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    
    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (RADIUS * cos(angle));
        circle[i].y = (float) (RADIUS * sin(angle));
        circle[i].z = 0.0f;
    }

    revolveSurface(&explodeMesh, circle, iPrec);

    for (i = 0; i < explodeMesh.numFaces; i++) {
        ss_matrixIdent(&faceMat[i]);
        xstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        ystep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        zstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        xrot[i] = 0.0f;
        yrot[i] = 0.0f;
        zrot[i] = 0.0f;
    }
}

BOOL initExplodeScene()
{
    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;

    faceMat = (MATRIX *)SaverAlloc((iPrec * iPrec) * 
    				 (4 * 4 * sizeof(float)));
    if( faceMat == NULL )
        return FALSE;

    xstep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( xstep == NULL )
        return FALSE;

    ystep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( ystep == NULL )
        return FALSE;

    zstep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( zstep == NULL )
        return FALSE;

    xrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( xrot == NULL )
        return FALSE;

    yrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( yrot == NULL )
        return FALSE;

    zrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( zrot == NULL )
        return FALSE;

    
    genExplode();

/*
    // Find out the OpenGL version that we are running on.
    bOpenGL11 = ss_fOnGL11();
*/

    // Setup the data arrays.
    pN3V3 = (POINT_N3F_V3F*)SaverAlloc(explodeMesh.numFaces * 4 * sizeof(POINT_N3F_V3F));
/*
    // If we are running on OpenGL 1.1, use the new vertex array functions.
    if (bOpenGL11) {
        glInterleavedArrays(GL_N3F_V3F, 0, pN3V3);
    }
*/

    myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, matl1Diffuse);
    myglMaterialfv(GL_FRONT, GL_SPECULAR, matlSpecular);
    myglMaterialf(GL_FRONT, GL_SHININESS, 100.0f);
/*
    glMaterialfv(GL_BACK, GL_AMBIENT_AND_DIFFUSE, matl2Diffuse);
    glMaterialfv(GL_BACK, GL_SPECULAR, matlSpecular);
    glMaterialf(GL_BACK, GL_SHININESS, 60.0f);
*/

/*
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveLH( &matProj, 0.66f, 0.66f, 0.3f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( FALSE, 0.66f, 0.66f, 0.3f, 3.0f );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    return TRUE;
}


void delExplodeScene()
{
    delMesh(&explodeMesh);
    
    SaverFree(faceMat);
    SaverFree(xstep);
    SaverFree(ystep);
    SaverFree(zstep);
    SaverFree(xrot);
    SaverFree(yrot);
    SaverFree(zrot);
    SaverFree(pN3V3);
}

void updateExplodeScene(int flags, FLOAT fElapsedTime)
{
    static float maxR;
    static float r = 0.0f;
    static float rChange = 0.0f;
    static float rChangePrev = 1.0f;
    static float rotZ = 0.0f;
    static int count = 0;
    static float fCount = 0.0f;
    static int direction = 1;
    static FLOAT fRestCount = 0.0f;
    static float lightSpin = 0.0f;
    static float spinDelta = 5.0f;
    static FLOAT fH = 0.0f;
    static RGBA color;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    int i;
    MFACE *faces;
    POINT_N3F_V3F *pn3v3;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;
    static FLOAT fTimer = 0.0f;
/*
    // Only update 50x per second
    fTimer += fElapsedTime;
    if( fTimer < 1.0f/50.0f )
        return;
    fTimer = 0.0f;
*/
    if (bColorCycle || fH == 0.0f) 
    {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color);

        myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }
/*
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glRotatef(-lightSpin, 0.0f, 1.0f, 0.0f);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);

    lightSpin += spinDelta * fTimeFactor;
    if ((lightSpin > 90.0) || (lightSpin < 0.0))
        spinDelta = -spinDelta;
*/
/*
    glPopMatrix();

    if (!bOpenGL11) {
        glBegin(GL_QUADS);
    }
*/
    for(
        i = 0, faces = explodeMesh.faces, pn3v3 = pN3V3;
        i < explodeMesh.numFaces;
        i++, faces++, pn3v3 += 4
       ) 
        {
        int a, b, c, d;
        int j;
        POINT3D vector;
        
        ss_matrixIdent(&faceMat[i]);
        ss_matrixRotate(&faceMat[i], xrot[i], yrot[i], zrot[i]);

        if (fRestCount > 0.0f)
            ;
        else {
            xrot[i] += (xstep[i]) * fTimeFactor;
            yrot[i] += (ystep[i]) * fTimeFactor;
            zrot[i] += (zstep[i]) * fTimeFactor;
        } 

        a = faces->p[0];
        b = faces->p[1];
        c = faces->p[3];
        d = faces->p[2];
        
        memcpy(&pn3v3[0].vertex, (explodeMesh.pts + a), sizeof(POINT3D));
        memcpy(&pn3v3[1].vertex, (explodeMesh.pts + b), sizeof(POINT3D));
        memcpy(&pn3v3[2].vertex, (explodeMesh.pts + c), sizeof(POINT3D));
        memcpy(&pn3v3[3].vertex, (explodeMesh.pts + d), sizeof(POINT3D));

        vector.x = pn3v3[0].vertex.x;
        vector.y = pn3v3[0].vertex.y;
        vector.z = pn3v3[0].vertex.z;

        for (j = 0; j < 4; j++) {
            pn3v3[j].vertex.x -= vector.x;
            pn3v3[j].vertex.y -= vector.y;
            pn3v3[j].vertex.z -= vector.z;
            ss_xformPoint((POINT3D *)&pn3v3[j].vertex, (POINT3D *)&pn3v3[j].vertex, &faceMat[i]);
            pn3v3[j].vertex.x += vector.x + (vector.x * r);
            pn3v3[j].vertex.y += vector.y + (vector.y * r);
            pn3v3[j].vertex.z += vector.z + (vector.z * r);
        }
        if (bSmoothShading) {
            memcpy(&pn3v3[0].normal, (explodeMesh.norms + a), sizeof(POINT3D));
            memcpy(&pn3v3[1].normal, (explodeMesh.norms + b), sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, (explodeMesh.norms + c), sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, (explodeMesh.norms + d), sizeof(POINT3D));
           
            for (j = 0; j < 4; j++)
                ss_xformNorm((POINT3D *)&pn3v3[j].normal, (POINT3D *)&pn3v3[j].normal, &faceMat[i]);
        } else {            
            memcpy(&pn3v3[0].normal, &faces->norm, sizeof(POINT3D));
            ss_xformNorm((POINT3D *)&pn3v3[0].normal, (POINT3D *)&pn3v3[0].normal, &faceMat[i]);
            memcpy(&pn3v3[1].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, &pn3v3[0].normal, sizeof(POINT3D));
        }
    }
    {
        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );
        static WORD s_indexArray[5000];
        static MYVERTEX s_vertexArray[5000];
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD iVertexA, iVertexB, iVertexC, iVertexD;
        INT a,b,c,d;
        HRESULT hr;

        for( int iFace = 0; iFace < explodeMesh.numFaces; iFace++ )
        {
            a = iFace * 4 + 0;
            b = iFace * 4 + 1;
            c = iFace * 4 + 2;
            d = iFace * 4 + 3;

            s_vertexArray[numVertices].p = pN3V3[a].vertex;
            s_vertexArray[numVertices].n = pN3V3[a].normal;
            iVertexA = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[b].vertex;
            s_vertexArray[numVertices].n = pN3V3[b].normal;
            iVertexB = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[c].vertex;
            s_vertexArray[numVertices].n = pN3V3[c].normal;
            iVertexC = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[d].vertex;
            s_vertexArray[numVertices].n = pN3V3[d].normal;
            iVertexD = numVertices++;

            s_indexArray[numIndices++] = iVertexA;
            s_indexArray[numIndices++] = iVertexB;
            s_indexArray[numIndices++] = iVertexC;
            numPrims++;
            s_indexArray[numIndices++] = iVertexA;
            s_indexArray[numIndices++] = iVertexC;
            s_indexArray[numIndices++] = iVertexD;
            numPrims++;
        }
        hr = m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0, numVertices, 
            numPrims, s_indexArray, D3DFMT_INDEX16, s_vertexArray, sizeof(MYVERTEX) );
    }
/*
    if (bOpenGL11) {
        glDrawArrays(GL_QUADS, 0, explodeMesh.numFaces * 4);
    } else {
        glEnd();
    }
*/
    if (fRestCount > 0.0f) {
        fRestCount -= fTimeFactor;
        goto resting;
    }

    rChange += fTimeFactor;
    while( (INT)rChangePrev < (INT)rChange )
    {
        rChangePrev += 1.0;
        if (direction) {
            maxR = r;
            r += (float) (0.3 * pow((double)(STEPS - count) / (double)STEPS, 4.0));
        } else {
            r -= (float) (maxR / (double)(STEPS));
        }
    }

    fCount += fTimeFactor;
    count = (INT)fCount;
    if (count > STEPS) {
        direction ^= 1;
        count = 0;
        fCount = 0.0f;

        if (direction == 1) {
            fRestCount = 10.0f;
            r = 0.0f;
            rChange = 0.0f;
            rChangePrev = 1.0f;

            for (i = 0; i < explodeMesh.numFaces; i++) {
                ss_matrixIdent(&faceMat[i]);
                xstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                ystep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                zstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                
                xrot[i] = 0.0f;
                yrot[i] = 0.0f;
                zrot[i] = 0.0f;
            }
        }
    }

resting:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\genwin2.cpp ===
/******************************Module*Header*******************************\
* Module Name: genwin2.c
*
* The new Windows style of the 3D Flying Objects screen saver.
*
* Texture maps .BMP files onto a simulation of a flag waving in the breeze.
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "resource.h"
#include "mesh.h"


enum STATE
{
    S_FREE,
    S_MOVETOORIGIN,
    S_FADETOCOLOR,
    S_PAUSE,
    S_FADEFROMCOLOR
};

#define TIME_FREE 10.0f
#define TIME_FADETOCOLOR 1.0f
#define TIME_PAUSE 5.0f
#define TIME_FADEFROMCOLOR 1.0f
// Note: There's no TIME_MOVETOORIGIN since that takes a variable amt of time.

const FLOAT winTotalwidth = (FLOAT)0.75;
const FLOAT winTotalheight = (FLOAT)0.75;

#define MAX_FRAMES 20

// IPREC is the number of faces in the mesh that models the flag.
#define IPREC   35

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static FLOAT sinAngle = (FLOAT)0.0;
static FLOAT xTrans = (FLOAT)0.0;

// Material properties
static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};

// Lighting properties
static FLOAT light0Pos[] = {-15.0f, 0.0f, -10.0f};

                           
                           
/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* getZpos
*
* Get the z-position (depth) of the "wavy" flag component at the given x.
*
* The function used to model the wave is:
*
*        1/2
*   z = x    * sin((2*PI*x + sinAngle) / 8)
*
* The shape of the wave varies from frame to frame by changing the
* phase, sinAngle.
*
\**************************************************************************/
static FLOAT getZpos(FLOAT x)
{
    FLOAT xAbs = x - xTrans;
    FLOAT angle = sinAngle + ((FLOAT) (2.0 * PI) * (xAbs / winTotalwidth));

    xAbs = winTotalwidth - xAbs;

    return (FLOAT)(-(sin((double)angle) / 8.0) *
                   sqrt((double)(xAbs / winTotalwidth )));
}




/******************************Public*Routine******************************\
* genTex
*
* Generate a mesh representing a frame of the flag.  The phase, sinAngle,
* is a global variable.
*
\**************************************************************************/
static BOOL genTex(MESH *winMesh)
{
    POINT3D pos;
    POINT3D pts[4];
    FLOAT w, h;
    int i;

    if( !newMesh(winMesh, IPREC * IPREC, IPREC * IPREC) )
        return FALSE;

    // Width and height of each face
    w = (winTotalwidth) / (FLOAT)(IPREC + 1);
    h = winTotalheight;

    // Generate the mesh data.  At equally spaced intervals along the x-axis,
    // we compute the z-position of the flag surface.

    pos.y = (FLOAT) 0.0;
    pos.z = (FLOAT) 0.0;

    for (i = 0, pos.x = xTrans; i < IPREC; i++, pos.x += w) {
        int faceCount = winMesh->numFaces;

        pts[0].x = (FLOAT)pos.x; 
        pts[0].y = (FLOAT)(pos.y);   
        pts[0].z = getZpos(pos.x);

        pts[1].x = (FLOAT)pos.x;
        pts[1].y = (FLOAT)(pos.y + h);  
        pts[1].z = getZpos(pos.x);

        pts[2].x = (FLOAT)(pos.x + w);  
        pts[2].y = (FLOAT)(pos.y);  
        pts[2].z = getZpos(pos.x + w);

        pts[3].x = (FLOAT)(pos.x + w);
        pts[3].y = (FLOAT)(pos.y + h);
        pts[3].z = getZpos(pos.x + w);

        // Compute the face normal.
        ss_calcNorm(&winMesh->faces[faceCount].norm, pts + 2, pts + 1, pts);

        // Add the face to the mesh.
        winMesh->faces[faceCount].material = 0;
        winMesh->faces[faceCount].p[0] = iPtInList(winMesh, 0, pts,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3,
            &winMesh->faces[faceCount].norm, TRUE);

        winMesh->numFaces++;
    }

    // Normalize the vertex normals in the mesh.
    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    return TRUE;
}




/******************************Public*Routine******************************\
* initWin2Scene
*
* Initialize the screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
BOOL initWin2Scene()
{
    int i;
    FLOAT angleDelta;

    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXMatrixTranslation(&matView, -0.17f, -0.04f, 1.5f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Adjust position of light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    
    Frames = MAX_FRAMES;

    // Generate the geometry data (stored in the array of mesh structures),
    // for each frame of the animation.  The shape of the flag is varied by
    // changing the global variable sinAngle.
    angleDelta = (FLOAT)(2.0 * PI) / (FLOAT)Frames;
    sinAngle = (FLOAT) 0.0;
    for (i = 0; i < Frames; i++) {
        if( !genTex(&winMesh[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }

    return TRUE;
}




/******************************Public*Routine******************************\
* delWin2Scene
*
* Cleanup the data associated with this screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void delWin2Scene()
{
    int i;
    for (i = 0; i < Frames; i++)
        delMesh(&winMesh[i]);
}




/******************************Public*Routine******************************\
* updateWin2Scene
*
* Generate a scene by taking one of the meshes and rendering it
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void updateWin2Scene(int flags, FLOAT fElapsedTime)
{
    MESH *pMesh;
    static double mxrot = 40.0;
    static double myrot = 0;
    static double mzrot = -12.0;
    static int frameNum = 0;
    static FLOAT fFrameNum = (FLOAT)Frames;
    FLOAT s = 0.0f;
    FLOAT ds;
    static FLOAT s_fTime = 0.0f;
    static FLOAT s_fTimeLastChange = 0.0f;
    static FLOAT s_fTimeNextChange = TIME_FREE;
    static STATE s_state = S_FREE;
    FLOAT fBeta;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    HRESULT hr;

    s_fTime += fElapsedTime;
    if( s_fTimeNextChange != -1.0f && s_fTime > s_fTimeNextChange )
    {
        // Handle state transitions
        s_fTimeLastChange = s_fTime;
        switch( s_state )
        {
        case S_FREE:
            s_state = S_MOVETOORIGIN;
            g_bMoveToOrigin = TRUE;
            s_fTimeNextChange = -1.0f;
            break;
        case S_MOVETOORIGIN:
            s_state = S_FADETOCOLOR;
            s_fTimeNextChange = s_fTime + TIME_FADETOCOLOR;
            break;
        case S_FADETOCOLOR:
            s_state = S_PAUSE;
            s_fTimeNextChange = s_fTime + TIME_PAUSE;
            break;
        case S_PAUSE:
            s_state = S_FADEFROMCOLOR;
            s_fTimeNextChange = s_fTime + TIME_FADEFROMCOLOR;
            break;
        case S_FADEFROMCOLOR:
            s_state = S_FREE;
            s_fTimeNextChange = s_fTime + TIME_FREE;
            g_bMoveToOrigin = FALSE;
            break;
        }
    }

    fBeta = 0.0f;

    // Handle state processing
    switch( s_state )
    {
    case S_MOVETOORIGIN:
        if( g_bAtOrigin && frameNum == 0)
            s_fTimeNextChange = s_fTime; // provoke state change next time
        break;
    case S_FADETOCOLOR:
        fBeta = (s_fTime - s_fTimeLastChange) / TIME_FADETOCOLOR;
        break;
    case S_PAUSE:
        fBeta = 1.0f;
        break;
    case S_FADEFROMCOLOR:
        fBeta = 1.0f - ( (s_fTime - s_fTimeLastChange) / TIME_FADEFROMCOLOR );
        break;
    }

    if( fBeta != 0.0f )
    {
        // Render background logo
        MYVERTEX3 v[4];
        FLOAT fLeft = g_pFloatRect->xMin - g_xScreenOrigin;
        FLOAT fRight = fLeft + g_pFloatRect->xSize;
        FLOAT fBottom = g_pFloatRect->yMin - g_yScreenOrigin;
        FLOAT fTop = g_pFloatRect->yMin + g_pFloatRect->ySize;
        DWORD dwColor = D3DXCOLOR( 1.0f, 1.0f, 1.0f, fBeta );
        v[0].p = D3DXVECTOR3(fLeft, fBottom, 0.9f); v[0].rhw = 0.1f; v[0].dwDiffuse = dwColor; v[0].tu = 0.0f; v[0].tv = 0.0f;
        v[1].p = D3DXVECTOR3(fRight, fBottom, 0.9f); v[1].rhw = 0.1f; v[1].dwDiffuse = dwColor; v[1].tu = 1.0f; v[1].tv = 0.0f;
        v[2].p = D3DXVECTOR3(fLeft, fTop, 0.9f); v[2].rhw = 0.1f; v[2].dwDiffuse = dwColor; v[2].tu = 0.0f; v[2].tv = 1.0f;
        v[3].p = D3DXVECTOR3(fRight, fTop, 0.9f); v[3].rhw = 0.1f; v[3].dwDiffuse = dwColor; v[3].tu = 1.0f; v[3].tv = 1.0f;

        hr = m_pd3dDevice->SetTexture( 0, g_pDeviceObjects->m_pTexture2 );
        hr = m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX3 );
        hr = m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(MYVERTEX3) );
    }
    m_pd3dDevice->SetTexture( 0, g_pDeviceObjects->m_pTexture );


    D3DXMATRIX mat1, mat2, mat3, mat4, matFinal;
    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    D3DXMatrixScaling( &mat4, 0.82f, 0.92f, 0.82f );
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );
    
    // Divide the texture into IPREC slices.  ds is the texture coordinate
    // delta we apply as we move along the x-axis.
    ds = (FLOAT)1.0 / (FLOAT)IPREC;

    // Setup the material property of the flag.  The material property, light
    // properties, and polygon orientation will interact with the texture.
    myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT) 40.0);

    FLOAT fColor[4];
    fColor[0] = 1.0f;
    fColor[1] = 1.0f;
    fColor[2] = 1.0f;
    fColor[3] = 1.0f - fBeta; // Adjust flag alpha so it fades when showing logo
    if( fColor[3] != 0.0f )
    {
        // Render flag
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, fColor);
        pMesh = &winMesh[frameNum];

        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD iVertexA, iVertexB, iVertexC, iVertexD;
        INT a,b,c,d;
        MFACE *faces;

        WORD* i;
        MYVERTEX2* v;
        hr = m_pVB2->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        faces = pMesh->faces;
        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            a = faces[iFace].p[0];
            b = faces[iFace].p[1];
            c = faces[iFace].p[2];
            d = faces[iFace].p[3];

            v[numVertices].p = pMesh->pts[a];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[a] : -faces[iFace].norm;
            v[numVertices].tu = s; v[numVertices].tv = 1.0f;
            iVertexA = numVertices++;
            v[numVertices].p = pMesh->pts[b];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[b] : -faces[iFace].norm;
            v[numVertices].tu = s; v[numVertices].tv = 0.0f;
            iVertexB = numVertices++;
            v[numVertices].p = pMesh->pts[c];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[c] : -faces[iFace].norm;
            v[numVertices].tu = s+ds; v[numVertices].tv = 1.0f;
            iVertexC = numVertices++;
            v[numVertices].p = pMesh->pts[d];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[d] : -faces[iFace].norm;
            v[numVertices].tu = s+ds; v[numVertices].tv = 0.0f;
            iVertexD = numVertices++;

            s += ds;

            i[numIndices++] = iVertexA;
            i[numIndices++] = iVertexB;
            i[numIndices++] = iVertexC;
            numPrims++;
            i[numIndices++] = iVertexC;
            i[numIndices++] = iVertexB;
            i[numIndices++] = iVertexD;
            numPrims++;
        }        

        hr = m_pVB2->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX2 );
        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB2, sizeof(MYVERTEX2) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    // Don't change frame number if we're in S_FADETOCOLOR, S_PAUSE, 
    // or S_FADEFROMCOLOR, unless by some chance we're in those states
    // but framenum is not at zero (yet).
    if( frameNum != 0 ||
        s_state != S_FADETOCOLOR &&
        s_state != S_PAUSE && 
        s_state != S_FADEFROMCOLOR )
    {
        fFrameNum -= fTimeFactor;
        frameNum = (INT)fFrameNum;
        if (frameNum < 0)
        {
            fFrameNum = (FLOAT)(Frames - 1);
            frameNum = Frames - 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\gentex.cpp ===
/******************************Module*Header*******************************\
* Module Name: gentex.c
*
* The Textured Flag style of the 3D Flying Objects screen saver.
*
* Texture maps .BMP files onto a simulation of a flag waving in the breeze.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "resource.h"
#include "mesh.h"

static FLOAT winTotalwidth = (FLOAT)0.75;
static FLOAT winTotalheight = (FLOAT)0.75 * (FLOAT)0.75;

#define MAX_FRAMES 20

// IPREC is the number of faces in the mesh that models the flag.

#define IPREC   15

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static FLOAT sinAngle = (FLOAT)0.0;
static FLOAT xTrans = (FLOAT)0.0;
static int curMatl = 0;

// Material properties.

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular    = {0.5f, 0.5f, 0.5f, 1.0f};
static RGBA matlNoSpecular     = {0.0f, 0.0f, 0.0f, 0.0f};

// Lighting properties.

static FLOAT light0Pos[] = {20.0f, 5.0f, 20.0f, 0.0f};
static FLOAT light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};
static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};

static RGBA flagColors[] = {{1.0f, 1.0f, 1.0f, 1.0f},
                            {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           };

// Default texture resource

static TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX };

static TEXTURE gTex = {0}; // One global texture


                           
                           
/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* getZpos
*
* Get the z-position (depth) of the "wavy" flag component at the given x.
*
* The function used to model the wave is:
*
*        1/2
*   z = x    * sin((2*PI*x + sinAngle) / 4)
*
* The shape of the wave varies from frame to frame by changing the
* phase, sinAngle.
*
\**************************************************************************/
FLOAT getZpos(FLOAT x)
{
    FLOAT xAbs = x - xTrans;
    FLOAT angle = sinAngle + ((FLOAT) (2.0 * PI) * (xAbs / winTotalwidth));

    xAbs = winTotalwidth - xAbs;
//    xAbs += (winTotalwidth / 2.0);

    return (FLOAT)((sin((double)angle) / 4.0) *
                   sqrt((double)(xAbs / winTotalwidth )));
}




/******************************Public*Routine******************************\
* genTex
*
* Generate a mesh representing a frame of the flag.  The phase, sinAngle,
* is a global variable.
*
\**************************************************************************/
BOOL genTex(MESH *winMesh)
{
    POINT3D pos;
    POINT3D pts[4];
    FLOAT w, h;
    int i;

    if( !newMesh(winMesh, IPREC * IPREC, IPREC * IPREC) )
        return FALSE;

// Width and height of each face

    w = (winTotalwidth) / (FLOAT)(IPREC + 1);
    h = winTotalheight;

// Generate the mesh data.  At equally spaced intervals along the x-axis,
// we compute the z-position of the flag surface.

    pos.y = (FLOAT) 0.0;
    pos.z = (FLOAT) 0.0;

    for (i = 0, pos.x = xTrans; i < IPREC; i++, pos.x += w) {
        int faceCount = winMesh->numFaces;

        pts[0].x = (FLOAT)pos.x; 
        pts[0].y = (FLOAT)(pos.y);   
        pts[0].z = getZpos(pos.x);

        pts[1].x = (FLOAT)pos.x;
        pts[1].y = (FLOAT)(pos.y + h);  
        pts[1].z = getZpos(pos.x);

        pts[2].x = (FLOAT)(pos.x + w);  
        pts[2].y = (FLOAT)(pos.y);  
        pts[2].z = getZpos(pos.x + w);

        pts[3].x = (FLOAT)(pos.x + w);
        pts[3].y = (FLOAT)(pos.y + h);
        pts[3].z = getZpos(pos.x + w);

    // Compute the face normal.

        ss_calcNorm(&winMesh->faces[faceCount].norm, pts + 2, pts + 1, pts);

    // Add the face to the mesh.

        winMesh->faces[faceCount].material = 0;
        winMesh->faces[faceCount].p[0] = iPtInList(winMesh, 0, pts,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3,
            &winMesh->faces[faceCount].norm, TRUE);

        winMesh->numFaces++;
    }

// Normalize the vertex normals in the mesh.

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    return TRUE;
}




/******************************Public*Routine******************************\
* initTexScene
*
* Initialize the screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
BOOL initTexScene()
{
    int i;
    FLOAT angleDelta;
//    FLOAT aspectRatio;

    // Initialize the transform.
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-0.25, 1.0, -0.25, 1.0, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXMatrixTranslation(&matView, 0.0f, 0.0f, 1.5f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Initialize and turn on lighting.
/*
    glDisable(GL_DEPTH_TEST);
*/
    // Light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    // Light 1
    light.Type = D3DLIGHT_POINT;
    light.Ambient.r = light1Ambient.r;
    light.Ambient.g = light1Ambient.g;
    light.Ambient.b = light1Ambient.b;
    light.Ambient.a = light1Ambient.a;
    light.Diffuse.r = light1Diffuse.r;
    light.Diffuse.g = light1Diffuse.g;
    light.Diffuse.b = light1Diffuse.b;
    light.Diffuse.a = light1Diffuse.a;
    light.Specular.r = light1Specular.r;
    light.Specular.g = light1Specular.g;
    light.Specular.b = light1Specular.b;
    light.Specular.a = light1Specular.a;
    light.Position.x = light1Pos[0];
    light.Position.y = light1Pos[1];
    light.Position.z = light1Pos[2];
    m_pd3dDevice->SetLight(1, &light);
    m_pd3dDevice->LightEnable(1, TRUE);

    // Leave OpenGL in a state ready to accept the model view transform (we
    // are going to have the flag vary its orientation from frame to frame).
/*
    glMatrixMode(GL_MODELVIEW);
*/
    // Define orientation of polygon faces.

//    glFrontFace(GL_CW);
    //    glEnable(GL_CULL_FACE);
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    Frames = (int)((FLOAT)(MAX_FRAMES / 2) * fTesselFact);

    // Load user texture - if that fails load default texture resource
#if 0
//    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if( ss_LoadTextureFile( &gTexFile, &gTex ) ||
        ss_LoadTextureResource( &gTexRes, &gTex) )
    {
/*        glEnable(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
*/
        ss_SetTexture( &gTex );

    // Correct aspect ratio of flag to match image.
    //
    // The 1.4 is a correction factor to account for the length of the
    // curve that models the surface ripple of the waving flag.  This
    // factor is the length of the curve at zero phase.  It would be
    // more accurate to determine the length of the curve at each phase,
    // but this is a sufficient approximation for our purposes.

        aspectRatio = ((FLOAT) gTex.height / (FLOAT) gTex.width)
                      * (FLOAT) 1.4;

        if (aspectRatio < (FLOAT) 1.0) {
            winTotalwidth  = (FLOAT)0.75;
            winTotalheight = winTotalwidth * aspectRatio;
        } else {
            winTotalheight = (FLOAT) 0.75;
            winTotalwidth  = winTotalheight / aspectRatio;
        };
    }
#endif

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    // Generate the geometry data (stored in the array of mesh structures),
    // for each frame of the animation.  The shape of the flag is varied by
    // changing the global variable sinAngle.

    angleDelta = (FLOAT)(2.0 * PI) / (FLOAT)Frames;
    sinAngle = (FLOAT) 0.0;

    for (i = 0; i < Frames; i++) {
        if( !genTex(&winMesh[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }
    return TRUE;
}




/******************************Public*Routine******************************\
* delTexScene
*
* Cleanup the data associated with this screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void delTexScene()
{
    int i;

    for (i = 0; i < Frames; i++)
        delMesh(&winMesh[i]);

    // Delete the texture
    ss_DeleteTexture( &gTex );
}




/******************************Public*Routine******************************\
* updateTexScene
*
* Generate a scene by taking one of the meshes and rendering it with
* OpenGL.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void updateTexScene(int flags, FLOAT fElapsedTime)
{
    MESH *mesh;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static int frameNum = 0;
    static FLOAT fFrameNum = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
/*
    MFACE *faces;
    int i;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;
    int aOffs, bOffs, cOffs, dOffs;
    int a, b;
*/
    FLOAT s = (FLOAT) 0.0;
    FLOAT ds;

// In addition to having the flag wave (an effect acheived by switching
// meshes from frame to frame), the flag changes its orientation from
// frame to frame.  This is done by applying a model view transform.
    D3DXMATRIX mat1, mat2, mat3, matFinal;
    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );
    
// Divide the texture into IPREC slices.  ds is the texture coordinate
// delta we apply as we move along the x-axis.

    ds = (FLOAT)1.0 / (FLOAT)IPREC;

// Setup the material property of the flag.  The material property, light
// properties, and polygon orientation will interact with the texture.

    curMatl = 0;

    myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &flagColors[0]);
    myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT) 60.0);

// Pick the mesh for the current frame.

    mesh = &winMesh[frameNum];

// Take the geometry data is the mesh and convert it to a single OpenGL
// quad strip.  If smooth shading is required, use the vertex normals stored
// in the mesh.  Otherwise, use the face normals.
//
// As we define each vertex, we also define a corresponding vertex and
// texture coordinate.

//    glBegin(GL_QUAD_STRIP);
#if 0
    pp = mesh->pts;
    pn = mesh->norms;

    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmoothShading) {
            // Since flag is a single quad strip, this isn't needed.
            // But lets keep it in case we ever change to a more
            // complex model (ie., one that uses more than one quad
            // strip).
            #if 0
            if ((a != lastC) || (b != lastD)) {
/*
                glNormal3fv((FLOAT *)&(faces - 1)->norm);

                glTexCoord2f(s, (FLOAT) 0.0);
                glVertex3fv((FLOAT *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glTexCoord2f(s, (FLOAT) 1.0);
                glVertex3fv((FLOAT *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
*/
                s += ds;
/*
                glEnd();
                glBegin(GL_QUAD_STRIP);
*/
            }
            #endif

            if (faces->material != curMatl) {
                curMatl = faces->material;
/*
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &flagColors[curMatl]);
*/
            }
/*
            glNormal3fv((FLOAT *)&faces->norm);
            glTexCoord2f(s, (FLOAT) 0.0);
            glVertex3fv((FLOAT *)((char *)pp + (a << 3) + (a << 2)));
            glTexCoord2f(s, (FLOAT) 1.0);
            glVertex3fv((FLOAT *)((char *)pp + (b << 3) + (b << 2)));
*/
            s += ds;
        } else {

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            if (faces->material != curMatl) {
                curMatl = faces->material;
/*
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &flagColors[curMatl]);
*/
            }
/*
            glTexCoord2f(s, (FLOAT) 0.0);
            glNormal3fv((FLOAT *)((char *)pn + aOffs));
            glVertex3fv((FLOAT *)((char *)pp + aOffs));
            glTexCoord2f(s, (FLOAT) 1.0);
            glNormal3fv((FLOAT *)((char *)pn + bOffs));
            glVertex3fv((FLOAT *)((char *)pp + bOffs));
*/
            s += ds;
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmoothShading) {
/*
        glNormal3fv((FLOAT *)&(faces - 1)->norm);
        glTexCoord2f(s, (FLOAT) 0.0);
        glVertex3fv((FLOAT *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glTexCoord2f(s, (FLOAT) 1.0);
        glVertex3fv((FLOAT *)((char *)pp + (lastD << 3) + (lastD << 2)));
*/
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);
/*
        glTexCoord2f(s, (FLOAT) 0.0);
        glNormal3fv((FLOAT *)((char *)pn + cOffs));
        glVertex3fv((FLOAT *)((char *)pp + cOffs));
        glTexCoord2f(s, (FLOAT) 1.0);
        glNormal3fv((FLOAT *)((char *)pn + dOffs));
        glVertex3fv((FLOAT *)((char *)pp + dOffs));
*/
    }

//    glEnd();
#endif
    {
        HRESULT hr;
        WORD indexArray[4];
        MYVERTEX2 vertexArray[4];

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX2 );

        indexArray[0] = 0;
        indexArray[1] = 1;
        indexArray[2] = 2;
        indexArray[3] = 3;

        for( int iFace = 0; iFace < mesh->numFaces; iFace++ )
        {
            vertexArray[0].p = mesh->pts[ mesh->faces[iFace].p[0] ];
            vertexArray[1].p = mesh->pts[ mesh->faces[iFace].p[1] ];
            vertexArray[2].p = mesh->pts[ mesh->faces[iFace].p[2] ];
            vertexArray[3].p = mesh->pts[ mesh->faces[iFace].p[3] ];

            vertexArray[0].tu = s; vertexArray[0].tv = 1.0f;
            vertexArray[1].tu = s; vertexArray[1].tv = 0.0f;
            vertexArray[2].tu = s+ds; vertexArray[2].tv = 1.0f;
            vertexArray[3].tu = s+ds; vertexArray[3].tv = 0.0f;
            s += ds;

            if( bSmoothShading )
            {
                vertexArray[0].n = mesh->norms[ mesh->faces[iFace].p[0] ];
                vertexArray[1].n = mesh->norms[ mesh->faces[iFace].p[1] ];
                vertexArray[2].n = mesh->norms[ mesh->faces[iFace].p[2] ];
                vertexArray[3].n = mesh->norms[ mesh->faces[iFace].p[3] ];
            }
            else
            {
                vertexArray[0].n = mesh->faces[iFace].norm;
                vertexArray[1].n = mesh->faces[iFace].norm;
                vertexArray[2].n = mesh->faces[iFace].norm;
                vertexArray[3].n = mesh->faces[iFace].norm;
            }

            hr = m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLESTRIP, 0,
                4, 2, indexArray, D3DFMT_INDEX16, vertexArray, sizeof(MYVERTEX2) );
        }
    }

// Transfer the image to the floating OpenGL window.

// Determine the flag orientation for the next frame.
// What we are doing is an oscillating rotation about the y-axis
// (mxrotInc and mzrotInc are currently 0).


    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if ((myrot < -65.0 && myrotInc < 0) || (myrot > 25.0 && myrotInc > 0))
        myrotInc = -myrotInc;

//    frameNum++;
    fFrameNum += fTimeFactor;
    frameNum = (INT)fFrameNum;
    if (frameNum >= Frames)
    {
        fFrameNum = 0.0f;
        frameNum = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\genwin.cpp ===
/******************************Module*Header*******************************\
* Module Name: genwin.c
*
* The Windows Logo style of the 3D Flying Objects screen saver.
*
* Animated 3D model of the Microsoft (R) Windows NT (TM) flag logo.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define WIN_TOP_BORDER      (float)0.1
#define WIN_RIGHT_BORDER    WIN_TOP_BORDER
#define WIN_CROSSBAR        (0.6522f * WIN_TOP_BORDER)
#define WIN_NUMPIECES       7
#define WIN_NUMCOLUMNS      6
#define WIN_GAP             (WIN_TOP_BORDER / 8.0f)
#define WIN_GAP_X           (2.0f * WIN_GAP)
#define WIN_HEIGHT          ((WIN_GAP * 6.0f) + \
                                (WIN_NUMPIECES * WIN_TOP_BORDER))
#define WIN_WIDTH           (0.7024f * WIN_HEIGHT)
#define WIN_THICKNESS       WIN_CROSSBAR

#define WIN_TOTALWIDTH      (WIN_TOP_BORDER * 1.1f * (float)WIN_NUMCOLUMNS + \
                             WIN_WIDTH)

#define BLOCK_TOP            0x0001
#define BLOCK_BOTTOM         0x0002
#define BLOCK_LEFT           0x0004
#define BLOCK_RIGHT          0x0008
#define BLOCK_FRONT          0x0010
#define BLOCK_BACK           0x0020
#define BLOCK_ALL            0x003f
#define DELTA_BLEND          0x2000
#define NO_BLEND             0x1000

#define CUBE_FACES          6
#define CUBE_POINTS         8

#define MAX_FRAMES 20

#define MAXPREC 15
#define S_IPREC 3

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static MESH winStreamer[MAX_FRAMES];
static float sinAngle = 0.0f;
static float xTrans = 0.2f;
static int curMatl = 0;
static int iPrec = 10;

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular = {0.3f, 0.3f, 0.3f, 1.0f};
static RGBA matlNoSpecular = {0.0f, 0.0f, 0.0f, 0.0f};
static FLOAT light0Pos[] = {20.0f, -10.0f, 20.0f, 0.0f};

static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};
static FLOAT light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};

static RGBA winColors[] = {{0.3f, 0.3f, 0.3f, 1.0f},
                           {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           {0.22f, 0.42f, 0.78f, 1.0f},    // blue
                           {0.35f, 0.71f, 0.35f, 1.0f},    // green
                           {0.95f, 0.82f, 0.12f, 1.0f}};   // yellow




static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




float getZPos(float x)
{
    float xAbs = x - xTrans;
    float angle = (float) (sinAngle + ((2.0 * PI) * (xAbs / WIN_TOTALWIDTH)));

    xAbs += (WIN_TOTALWIDTH / 2.0f);
    xAbs = WIN_TOTALWIDTH - xAbs;

    return (float)((sin((double)angle) / 4.0) * 
                   sqrt((double)(xAbs / WIN_TOTALWIDTH )));
}




void AddFace(MESH *mesh, int startBlend, POINT3D *pos, float w, float h)
{
#define FACE_VERTEX(i) \
    iPtInList(mesh, startBlend, pts + i, &mesh->faces[faceCount].norm, TRUE)

    int faceCount = mesh->numFaces;     
    int numPts = mesh->numPoints;
    POINT3D *pts = mesh->pts + numPts;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);

    pts->x = (float)pos->x; 
    pts->y = (float)pos->y;   
    pts->z = zLeft; 
    pts++;

    pts->x = (float)pos->x;
    pts->y = (float)(pos->y + h);  
    pts->z = zLeft;  
    pts++;

    pts->x = (float)(pos->x + w);  
    pts->y = (float)(pos->y + h);  
    pts->z = zRight;  
    pts++;

    pts->x = (float)(pos->x + w);
    pts->y = (float)pos->y;  
    pts->z = zRight;

    pts -= 3;

    mesh->faces[faceCount].material = curMatl;
    ss_calcNorm(&mesh->faces[faceCount].norm, pts + 2, pts + 1, pts);
    mesh->faces[faceCount].p[3] = FACE_VERTEX(0);
    mesh->faces[faceCount].p[2] = FACE_VERTEX(1);
    mesh->faces[faceCount].p[1] = FACE_VERTEX(2);
    mesh->faces[faceCount].p[0] = FACE_VERTEX(3);
    mesh->numFaces++;
}




#define BLOCK_VERTEX(face, i)\
{\
    if (flags & DELTA_BLEND) {\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i], &norms[((i & 0x2) >> 1)],\
                      bBlend);\
    } else\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i],\
                      &mesh->faces[faceCount].norm, bBlend);\
}


#define DELTA_FACT  (float)10.0



void AddBlock(MESH *mesh, int blendStart, POINT3D *pos, 
              float w, float h, float d, ULONG flags)
{

    POINT3D pts[8];
    POINT3D ptsL[8];
    POINT3D ptsR[8];
    POINT3D norms[2];
    POINT3D posPrev;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);
    int faceCount = mesh->numFaces;     
    BOOL bBlend = ((flags & NO_BLEND) == 0);

    flags |= DELTA_BLEND;

    pts[0].x = (float)pos->x; 
    pts[0].y = (float)(pos->y + h);   
    pts[0].z = zLeft;

    pts[1].x = (float)pos->x;
    pts[1].y = (float)(pos->y + h);  
    pts[1].z = zLeft + d;  

    pts[2].x = (float)(pos->x + w);  
    pts[2].y = (float)(pos->y + h);  
    pts[2].z = zRight + d;  

    pts[3].x = (float)(pos->x + w);
    pts[3].y = (float)(pos->y + h);
    pts[3].z = zRight;

    pts[4].x = (float)pos->x;
    pts[4].y = (float)pos->y;
    pts[4].z = zLeft;

    pts[5].x = (float)pos->x;
    pts[5].y = (float)pos->y;
    pts[5].z = zLeft + d;  

    pts[6].x = (float)(pos->x + w);  
    pts[6].y = (float)pos->y;
    pts[6].z = zRight + d;  

    pts[7].x = (float)(pos->x + w);  
    pts[7].y = (float)pos->y;
    pts[7].z = zRight;

    if (flags & DELTA_BLEND) 
    {
    	float prevW = w;
        posPrev = *pos;

        w /= DELTA_FACT;
        zRight = getZPos(pos->x + w);

        ptsL[0].x = (float)pos->x; 
        ptsL[0].y = (float)(pos->y + h);   
        ptsL[0].z = zLeft;

        ptsL[1].x = (float)pos->x;
        ptsL[1].y = (float)(pos->y + h);  
        ptsL[1].z = zLeft + d;  

        ptsL[2].x = (float)(pos->x + w);  
        ptsL[2].y = (float)(pos->y + h);  
        ptsL[2].z = zRight + d;  

        ptsL[3].x = (float)(pos->x + w);
        ptsL[3].y = (float)(pos->y + h);
        ptsL[3].z = zRight;

        ptsL[4].x = (float)pos->x;
        ptsL[4].y = (float)pos->y;
        ptsL[4].z = zLeft;

        ptsL[5].x = (float)pos->x;
        ptsL[5].y = (float)pos->y;
        ptsL[5].z = zLeft + d;  

        ptsL[6].x = (float)(pos->x + w);  
        ptsL[6].y = (float)pos->y;
        ptsL[6].z = zRight + d;  

        ptsL[7].x = (float)(pos->x + w);  
        ptsL[7].y = (float)pos->y;
        ptsL[7].z = zRight;

        pos->x += (prevW - w);
        zLeft = getZPos(pos->x);
        zRight = getZPos(pos->x + w);

        ptsR[0].x = (float)pos->x; 
        ptsR[0].y = (float)(pos->y + h);   
        ptsR[0].z = zLeft;

        ptsR[1].x = (float)pos->x;
        ptsR[1].y = (float)(pos->y + h);  
        ptsR[1].z = zLeft + d;  

        ptsR[2].x = (float)(pos->x + w);  
        ptsR[2].y = (float)(pos->y + h);  
        ptsR[2].z = zRight + d;  

        ptsR[3].x = (float)(pos->x + w);
        ptsR[3].y = (float)(pos->y + h);
        ptsR[3].z = zRight;

        ptsR[4].x = (float)pos->x;
        ptsR[4].y = (float)pos->y;
        ptsR[4].z = zLeft;

        ptsR[5].x = (float)pos->x;
        ptsR[5].y = (float)pos->y;
        ptsR[5].z = zLeft + d;  

        ptsR[6].x = (float)(pos->x + w);  
        ptsR[6].y = (float)pos->y;
        ptsR[6].z = zRight + d;  

        ptsR[7].x = (float)(pos->x + w);  
        ptsR[7].y = (float)pos->y;
        ptsR[7].z = zRight;

        *pos = posPrev;

    }

    if (flags & BLOCK_TOP) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[1], &pts[2]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[1], &ptsL[2]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[1], &ptsR[2]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 1);
        BLOCK_VERTEX(2, 2);
        BLOCK_VERTEX(3, 3);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BOTTOM) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[4], &pts[7], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[4], &ptsL[7], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[4], &ptsR[7], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 4);
        BLOCK_VERTEX(1, 7);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_LEFT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[0], &pts[4]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[0], &ptsL[4]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[0], &ptsR[4]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 0);
        BLOCK_VERTEX(2, 4);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_RIGHT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[3], &pts[2], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[3], &ptsL[2], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[3], &ptsR[2], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 3);
        BLOCK_VERTEX(1, 2);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 7);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_FRONT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[3], &pts[7]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[3], &ptsL[7]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[3], &ptsR[7]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 3);
        BLOCK_VERTEX(2, 7);
        BLOCK_VERTEX(3, 4);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BACK) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[5], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[5], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[5], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 5);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 2);
        mesh->numFaces++;
    }

}




BOOL genWin(MESH *winMesh, MESH *winStreamer)
{
    POINT3D pos, posCenter;
    float w, h, d;
    float wMax, hMax;
    float xpos;
    int i, j, prec;
    int startBlend;

    if( !newMesh(winMesh, CUBE_FACES * iPrec * 20, CUBE_POINTS * iPrec * 20) )
        return FALSE;

    //
    // create window frame
    //

    w = (WIN_WIDTH - WIN_TOP_BORDER) / (float)iPrec;
    h = (float)WIN_TOP_BORDER;
    d = (float)WIN_THICKNESS;

    // draw top and bottom portions

    pos.y = 0.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints; 
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);

    pos.y = WIN_HEIGHT - WIN_TOP_BORDER;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);
    
    // draw middle horizontal portions

    prec = (iPrec / 2);
    w = (WIN_WIDTH - WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;
    w /= (float)prec;
    h = WIN_CROSSBAR;
    pos.y = (WIN_HEIGHT - WIN_CROSSBAR) / 2.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    xpos = pos.x + WIN_CROSSBAR;

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);


    // Draw thick right-hand edge of frame

    pos.x = xpos = xTrans + WIN_WIDTH - WIN_RIGHT_BORDER;
    pos.y = 0.0f;
    pos.z = 0.0f;
    w = WIN_RIGHT_BORDER / (float)S_IPREC;
    h = WIN_HEIGHT;

    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_LEFT);

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    pos.y = WIN_HEIGHT;
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);

    pos.y = 0.0f;
    pos.x = xTrans + WIN_WIDTH - w;
    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_RIGHT);

    // draw middle-vertical portion of frame

    pos.x = xTrans + (WIN_WIDTH - WIN_RIGHT_BORDER) / 2.0f - (WIN_CROSSBAR / 2.0f);
    pos.y = WIN_TOP_BORDER;
    pos.z = 0.0f;
    w = WIN_CROSSBAR;
    h = WIN_HEIGHT - 2.0f * WIN_TOP_BORDER;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_ALL | NO_BLEND);

    //
    // add the panels
    //

    w = (WIN_WIDTH - WIN_RIGHT_BORDER - WIN_CROSSBAR) / 2.0f;
    h = (WIN_HEIGHT - 2.0f * WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;

    w /= (float)(iPrec / 2);

    curMatl = 2;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 4;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    curMatl = 1;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER + h + WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 3;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    if( !newMesh(winStreamer, CUBE_FACES * WIN_NUMPIECES * WIN_NUMCOLUMNS,
            CUBE_POINTS * WIN_NUMPIECES * WIN_NUMCOLUMNS) )
    {
        return FALSE;
    }

    h = hMax = WIN_TOP_BORDER;
    w = wMax = WIN_TOP_BORDER * 1.1f;

    posCenter.x = pos.x = xTrans - wMax - WIN_GAP_X;
    posCenter.y = pos.y = 0.0f;

    for (i = 0; i < WIN_NUMCOLUMNS; i++) {
        for (j = 0; j < WIN_NUMPIECES; j++) {
            if (((j % 3) == 0) || (i == 0))
                curMatl = 0;
            else if (j < 3)
                curMatl = 2;
            else
                curMatl = 1;
            AddBlock(winStreamer, 0, &pos, w, h, d, BLOCK_ALL);
            pos.y += (hMax + WIN_GAP);
        }

        posCenter.x -= (wMax + WIN_GAP_X);
        posCenter.y = 0.0f;

        h = h * 0.8f;
        w = w * 0.8f;

        pos.x = posCenter.x;
        pos.y = posCenter.y;

        pos.x += (wMax - w) / 2.0f;
        pos.y += (hMax - h) / 2.0f;
    }    
    ss_normalizeNorms(winStreamer->norms, winStreamer->numPoints);

    return TRUE;
}




BOOL initWinScene()
{
    int i;
    float angleDelta;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -0.75, 1.25, 0.0, 3.0);
*/
    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

/*
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
    D3DXMATRIX matView1, matReverseX, matView2;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView1, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixScaling( &matReverseX, -1.0f, 1.0f, 1.0f );
    matView2 = matView1 * matReverseX;
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView2 );

    // Light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    // Light 1
    light.Type = D3DLIGHT_POINT;
    light.Ambient.r = light1Ambient.r;
    light.Ambient.g = light1Ambient.g;
    light.Ambient.b = light1Ambient.b;
    light.Ambient.a = light1Ambient.a;
    light.Diffuse.r = light1Diffuse.r;
    light.Diffuse.g = light1Diffuse.g;
    light.Diffuse.b = light1Diffuse.b;
    light.Diffuse.a = light1Diffuse.a;
    light.Specular.r = light1Specular.r;
    light.Specular.g = light1Specular.g;
    light.Specular.b = light1Specular.b;
    light.Specular.a = light1Specular.a;
    light.Position.x = light1Pos[0];
    light.Position.y = light1Pos[1];
    light.Position.z = light1Pos[2];
    m_pd3dDevice->SetLight(1, &light);
    m_pd3dDevice->LightEnable(1, TRUE);
    
/*
    glMatrixMode(GL_MODELVIEW);

    glFrontFace(GL_CCW);
    glEnable(GL_CULL_FACE);
*/
    
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact);

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    angleDelta = (float) ((2.0 * PI) / Frames);
    sinAngle = 0.0f;

    for (i = 0; i < Frames; i++) {
        if( !genWin(&winMesh[i], &winStreamer[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }
    return TRUE;
}




void delWinScene()
{
    int i;

    for (i = 0; i < Frames; i++) {
        delMesh(&winMesh[i]);
        delMesh(&winStreamer[i]);
    }
}




void updateWinScene(int flags, FLOAT fElapsedTime)
{
    MESH *mesh;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static FLOAT fH = 0.0f;
    static int frameNum = 0;
    static FLOAT fFrameNum = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    D3DXMATRIX mat1, mat2, mat3, matFinal;

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &winColors[0] );

        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }

    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    curMatl = 0;

    myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &winColors[0]);
    myglMaterialfv(GL_FRONT, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT, GL_SHININESS, 60.0f);

    mesh = &winMesh[frameNum];

    {
        HRESULT hr;
        MESH* pMesh = mesh;
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD* i;
        MYVERTEX* v;
        hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            if (pMesh->faces[iFace].material != curMatl) 
            {
                hr = m_pVB->Unlock();
                hr = m_pIB->Unlock();

                hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
                hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

                hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
                    0, numPrims );
                numVertices = 0;
                numIndices = 0;
                numPrims = 0;
                hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
                hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

                curMatl = pMesh->faces[iFace].material;
                myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &winColors[curMatl]);
    
            }
            v[numVertices+0].p = pMesh->pts[ pMesh->faces[iFace].p[0] ];
            v[numVertices+1].p = pMesh->pts[ pMesh->faces[iFace].p[1] ];
            v[numVertices+2].p = pMesh->pts[ pMesh->faces[iFace].p[2] ];
            v[numVertices+3].p = pMesh->pts[ pMesh->faces[iFace].p[3] ];

            if( bSmoothShading )
            {
                v[numVertices+0].n = pMesh->norms[ pMesh->faces[iFace].p[0] ];
                v[numVertices+1].n = pMesh->norms[ pMesh->faces[iFace].p[1] ];
                v[numVertices+2].n = pMesh->norms[ pMesh->faces[iFace].p[2] ];
                v[numVertices+3].n = pMesh->norms[ pMesh->faces[iFace].p[3] ];
            }
            else
            {
                v[numVertices+0].n = pMesh->faces[iFace].norm;
                v[numVertices+1].n = pMesh->faces[iFace].norm;
                v[numVertices+2].n = pMesh->faces[iFace].norm;
                v[numVertices+3].n = pMesh->faces[iFace].norm;
            }

            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 1;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 3;
            numVertices += 4;
            numPrims += 2;
        }
        hr = m_pVB->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    myglMaterialfv(GL_FRONT, GL_SPECULAR, (FLOAT *) &matlDimSpecular);

    mesh = &winStreamer[frameNum];

    {
        HRESULT hr;
        MESH* pMesh = mesh;
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD* i;
        MYVERTEX* v;
        hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            if (pMesh->faces[iFace].material != curMatl) 
            {
                hr = m_pVB->Unlock();
                hr = m_pIB->Unlock();

                hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
                hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

                hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
                    0, numPrims );

                numVertices = 0;
                numIndices = 0;
                numPrims = 0;
                hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
                hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

                curMatl = pMesh->faces[iFace].material;
                myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &winColors[curMatl]);
    
            }
            v[numVertices+0].p = pMesh->pts[ pMesh->faces[iFace].p[0] ];
            v[numVertices+1].p = pMesh->pts[ pMesh->faces[iFace].p[1] ];
            v[numVertices+2].p = pMesh->pts[ pMesh->faces[iFace].p[2] ];
            v[numVertices+3].p = pMesh->pts[ pMesh->faces[iFace].p[3] ];

            v[numVertices+0].n = pMesh->faces[iFace].norm;
            v[numVertices+1].n = pMesh->faces[iFace].norm;
            v[numVertices+2].n = pMesh->faces[iFace].norm;
            v[numVertices+3].n = pMesh->faces[iFace].norm;

            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 1;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 3;
            numVertices += 4;
            numPrims += 2;
        }
        hr = m_pVB->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if ((myrot < -45.0 && myrotInc < 0) || (myrot > 45.0 && myrotInc > 0))
        myrotInc = -myrotInc;

    fFrameNum += fTimeFactor;
    frameNum = (INT)fFrameNum;
    if (frameNum >= Frames)
    {
        frameNum = 0;
        fFrameNum -= Frames; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\mesh.cpp ===
/******************************Module*Header*******************************\
* Module Name: mesh.c
*
* Routines to create a mesh representation of a 3D object and to turn it
* into an OpenGL description.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <D3DX8.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define ZERO_EPS    0.00000001




/******************************Public*Routine******************************\
* newMesh
*
* Allocate memory for the mesh structure to accomodate the specified number
* of points and faces.
*
\**************************************************************************/
BOOL newMesh(MESH *mesh, int numFaces, int numPts)
{
    mesh->numFaces = 0;
    mesh->numPoints = 0;

    if (numPts) {
        mesh->pts = (POINT3D*)SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
        if( mesh->pts == NULL ) 
            return FALSE;

        mesh->norms = (POINT3D*)SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
        if( mesh->norms == NULL )
            return FALSE;
    }
    mesh->faces = (MFACE*)SaverAlloc((LONG)numFaces * (LONG)sizeof(MFACE));
    if (mesh->faces == NULL )
        return FALSE;

    return TRUE;
}




/******************************Public*Routine******************************\
* delMesh
*
* Delete the allocated portions of the MESH structure.
*
\**************************************************************************/
void delMesh(MESH *mesh)
{    
    SaverFree(mesh->pts);
    SaverFree(mesh->norms);
    SaverFree(mesh->faces);
}




/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, POINT3D *p, POINT3D *norm, int start)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    for (i = start; i < mesh->numPoints; i++, pts++)
    {
    // If the vertices are within ZERO_EPS of each other, then its the same
    // vertex.

        if ( fabs(pts->x - p->x) < ZERO_EPS &&
             fabs(pts->y - p->y) < ZERO_EPS &&
             fabs(pts->z - p->z) < ZERO_EPS )
        {
            mesh->norms[i].x += norm->x;
            mesh->norms[i].y += norm->y;
            mesh->norms[i].z += norm->z;
            return i;
        }
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* revolveSurface
*
* Takes the set of points in curve and fills the mesh structure with a
* surface of revolution.  The surface consists of quads made up of the
* points in curve rotated about the y-axis.  The number of increments
* in the revolution is determined by the steps parameter.
*
\**************************************************************************/
#define MAXPREC 40
void revolveSurface(MESH *mesh, POINT3D *curve, int steps)
{
    int i;
    int j;
    int facecount = 0;
    double rotation = 0.0;
    double rotInc;
    double cosVal;
    double sinVal;
    int stepsSqr;
    POINT3D norm;
    POINT3D a[MAXPREC + 1];
    POINT3D b[MAXPREC + 1];
    
    if (steps > MAXPREC)
        steps = MAXPREC;
    rotInc = (2.0 * PI) / (double)(steps - 1);
    stepsSqr = steps * steps;
    newMesh(mesh, stepsSqr, 4 * stepsSqr);

    for (j = 0; j < steps; j++, rotation += rotInc) {
        cosVal = cos(rotation);
        sinVal = sin(rotation);
        for (i = 0; i < steps; i++) {
            a[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            a[i].y = (float) (curve[i].y);
            a[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        cosVal = cos(rotation + rotInc);
        sinVal = sin(rotation + rotInc);
        for (i = 0; i < steps; i++) {
            b[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            b[i].y = (float) (curve[i].y);
            b[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        for (i = 0; i < (steps - 1); i++) {
            ss_calcNorm(&norm, &b[i + 1], &b[i], &a[i]);
            if ((norm.x * norm.x) + (norm.y * norm.y) + (norm.z * norm.z) < 0.9)
                ss_calcNorm(&norm, &a[i], &a[i+1], &b[i + 1]);
            mesh->faces[facecount].material = j & 7;
            mesh->faces[facecount].norm = norm;
            mesh->faces[facecount].p[0] = iPtInList(mesh, &b[i], &norm, 0);
            mesh->faces[facecount].p[1] = iPtInList(mesh, &a[i], &norm, 0);
            mesh->faces[facecount].p[2] = iPtInList(mesh, &b[i + 1], &norm, 0);
            mesh->faces[facecount].p[3] = iPtInList(mesh, &a[i + 1], &norm, 0); 
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(mesh->norms, mesh->numPoints);
}




HRESULT RenderMesh3( MESH* pMesh, BOOL bSmooth )
{
    HRESULT hr;
    INT numPrims = 0;
    INT numIndices = 0;
    INT numVertices = 0;
    WORD iVertexA, iVertexB, iVertexC, iVertexD;
    INT a,b,c,d;
    MFACE *faces;

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD* i;
    MYVERTEX* v;
    hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
    hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

    faces = pMesh->faces;
    for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
    {
        a = faces[iFace].p[0];
        b = faces[iFace].p[1];
        c = faces[iFace].p[2];
        d = faces[iFace].p[3];

        v[numVertices].p = pMesh->pts[a];
        v[numVertices].n = bSmooth ? pMesh->norms[a] : faces[iFace].norm;
        iVertexA = numVertices++;
        v[numVertices].p = pMesh->pts[b];
        v[numVertices].n = bSmooth ? pMesh->norms[b] : faces[iFace].norm;
        iVertexB = numVertices++;
        v[numVertices].p = pMesh->pts[c];
        v[numVertices].n = bSmooth ? pMesh->norms[c] : faces[iFace].norm;
        iVertexC = numVertices++;
        v[numVertices].p = pMesh->pts[d];
        v[numVertices].n = bSmooth ? pMesh->norms[d] : faces[iFace].norm;
        iVertexD = numVertices++;

        i[numIndices++] = iVertexA;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexC;
        numPrims++;
        i[numIndices++] = iVertexC;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexD;
        numPrims++;
    }        

    hr = m_pVB->Unlock();
    hr = m_pIB->Unlock();

    hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
    hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

    hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
        0, numPrims );
    return hr;
}




HRESULT RenderMesh3Backsides( MESH* pMesh, BOOL bSmooth )
{
    HRESULT hr;
    INT numPrims = 0;
    INT numIndices = 0;
    INT numVertices = 0;
    WORD iVertexA, iVertexB, iVertexC, iVertexD;
    INT a,b,c,d;
    MFACE *faces;

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD* i;
    MYVERTEX* v;
    hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
    hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

    faces = pMesh->faces;
    for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
    {
        a = faces[iFace].p[0];
        b = faces[iFace].p[1];
        c = faces[iFace].p[2];
        d = faces[iFace].p[3];

        v[numVertices].p = pMesh->pts[a];
        v[numVertices].n = bSmooth ? -pMesh->norms[a] : -faces[iFace].norm;
        iVertexA = numVertices++;
        v[numVertices].p = pMesh->pts[b];
        v[numVertices].n = bSmooth ? -pMesh->norms[b] : -faces[iFace].norm;
        iVertexB = numVertices++;
        v[numVertices].p = pMesh->pts[c];
        v[numVertices].n = bSmooth ? -pMesh->norms[c] : -faces[iFace].norm;
        iVertexC = numVertices++;
        v[numVertices].p = pMesh->pts[d];
        v[numVertices].n = bSmooth ? -pMesh->norms[d] : -faces[iFace].norm;
        iVertexD = numVertices++;

        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexA;
        i[numIndices++] = iVertexC;
        numPrims++;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexC;
        i[numIndices++] = iVertexD;
        numPrims++;
    }        

    hr = m_pVB->Unlock();
    hr = m_pIB->Unlock();

    hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
    hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

    hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
        0, numPrims );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\mesh.h ===
/******************************Module*Header*******************************\
* Module Name: mesh.h
*
* Declaration of the mesh routines.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

extern BOOL newMesh(MESH *mesh, int numFaces, int numPts);
extern void delMesh(MESH *mesh);
extern void revolveSurface(MESH *mesh, POINT3D *curve, int steps);
extern void updateObject(MESH *mesh, BOOL bSmooth);
extern void updateObject2(MESH *mesh, BOOL bSmooth);
extern void MakeList(DWORD listID, MESH *mesh);

extern VOID SetD3DDevice( LPDIRECT3DDEVICE8 pd3dDevice );
extern HRESULT RenderMesh( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh2( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh3( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh3Backsides( MESH* pMesh, BOOL bSmooth );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\math.cpp ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Misc. useful math utility functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"

#define ZERO_EPS    0.00000001

POINT3D ss_ptZero(0.0f, 0.0f, 0.0f);


void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void ss_matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}


void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 )
{
    int i, j;

    for( j = 0; j < 4; j ++ ) {
    	for( i = 0; i < 4; i ++ ) {
	    m1->M[j][i] = m2->M[j][0] * m3->M[0][i] +
			  m2->M[j][1] * m3->M[1][i] +
			  m2->M[j][2] * m3->M[2][i] +
			  m2->M[j][3] * m3->M[3][i];
	}
    }
}

void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}


void ss_normalizeNorm( POINT3D *n ) 
{
    float len;

    len = (n->x * n->x) + (n->y * n->y) + (n->z * n->z);
    if (len > ZERO_EPS)
        len = (float) (1.0 / sqrt(len));
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
    n->z *= len;
}

void ss_normalizeNorms(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlyingObjects.rc
//
#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

#define ID_COMPLEXITY              401
#define ID_IMAGE_SIZE              402

#define ID_COL_PICK_FIRST          ID_COL_CHECKER
#define ID_COL_CHECKER             500
#define ID_COL_PER_SIDE            501
#define ID_COL_SINGLE              502
#define ID_COL_PICK_LAST           ID_COL_SINGLE
#define ID_COL_PICK_COUNT          (ID_COL_PICK_LAST-ID_COL_PICK_FIRST+1)

#define ID_COL_SMOOTH              550
#define ID_COL_TRIANGLE            551
#define ID_COL_CYCLE               552

#define ID_SPIN                    600
#define ID_BLOOM                   601
#define ID_TWO_SIDED               602

#define ID_GEOM                    650

#define IDS_CONFIG_SMOOTH_COLORS        1000
#define IDS_CONFIG_TRIANGLE_COLORS      1001
#define IDS_CONFIG_CYCLE_COLORS         1002
#define IDS_CONFIG_SPIN                 1003
#define IDS_CONFIG_BLOOM                1004
#define IDS_CONFIG_SUBDIV               1005
#define IDS_CONFIG_COLOR_PICK           1006
#define IDS_CONFIG_IMAGE_SIZE           1007
#define IDS_CONFIG_GEOM                 1008
#define IDS_CONFIG_TWO_SIDED            1009

#define IDS_GEOM_FIRST                  IDS_GEOM_CUBE
#define IDS_GEOM_CUBE                   1025
#define IDS_GEOM_TETRA                  1026
#define IDS_GEOM_PYRAMIDS               1027
#define IDS_GEOM_CYLINDER               1028
#define IDS_GEOM_SPRING                 1029
#define IDS_GEOM_LAST                   IDS_GEOM_SPRING
#define IDS_GEOM_COUNT                  (IDS_GEOM_LAST-IDS_GEOM_FIRST+1)

#define IDS_INI_SECTION                 1051

#define IDS_WARNING             9014
#define IDS_ERROR               9015
#define IDS_BITMAP_SIZE         9016
#define IDS_BITMAP_INVALID      9017
#define IDS_SELECT_ANOTHER_BITMAP 9018
#define IDS_START_FAILED        9019
#define IDS_TEXTUREFILTER       9021
#define IDS_TEXTUREDIALOGTITLE  9022
#define IDS_BMP                 9023
#define IDS_DOTBMP              9024
#define IDS_STARDOTBMP          9025
#define IDS_RGB                 9030
#define IDS_DOTRGB              9031
#define IDS_STARDOTRGB          9032

// 3dfo

#define IDS_LOGO                1100
#define IDS_EXPLODE             1101
#define IDS_RIBBON              1102
#define IDS_2RIBBON             1103
#define IDS_SPLASH              1104
#define IDS_TWIST               1105
#define IDS_FLAG                1106

#define IDS_SAVERNAME           1107
#define IDS_OPTIONS             1108
#define IDS_OBJTYPE             1109
#define IDS_TEXTURE             1110
#define IDS_TEXTURE_FILE_OFFSET 1111
#define IDS_SIZE                1112
#define IDS_TESSELATION         1113
#define IDS_INIFILE             1114

#define DLG_SETUP_HELP          2001
#define DLG_SETUP_TYPES         2002
#define DLG_SETUP_BITMAP        2003
#define DLG_SETUP_FCOLOR        2004
#define DLG_SETUP_SMOOTH        2005
#define DLG_SETUP_CYCLE         2006
#define DLG_SETUP_ABOUT         2007
#define DLG_SETUP_TESSEL        2008
#define DLG_SETUP_SIZE          2009
#define DLG_SETUP_TEXTURE       2010
#define IDC_STATIC_TESS         2011
#define IDC_STATIC_TESS_MIN     2012
#define IDC_STATIC_TESS_MAX     2013
#define IDC_STATIC_SIZE         2014
#define IDC_STATIC_SIZE_MIN     2015
#define IDC_STATIC_SIZE_MAX     2016
#define DLG_SETUP_MONITORSETTINGS 2017

#define IDB_DEFTEX              3000
#define IDR_FLATFLAG            3001
#define IDR_WINLOGO             3002


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\texture.cpp ===
/******************************Module*Header*******************************\
* Module Name: texture.c
*
* Texture handling functions
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <scrnsave.h>
#include <commdlg.h>
//#include <GL/gl.h>
//#include "tk.h"

//#include "scrnsave.h"  // for hMainInstance
//#include "sscommon.h"
#include <d3dx8.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"
#include "texture.h"

static int VerifyTextureFile( TEXFILE *pTexFile );
static int GetTexFileType( TEXFILE *pTexFile );

static TEX_STRINGS gts = {0};
BOOL gbTextureObjects = FALSE;

static BOOL gbEnableErrorMsgs = FALSE;

/******************************Public*Routine******************************\
* ss_fOnWin95
*
* True if running on Windows 95
*
\**************************************************************************/

BOOL
ss_fOnWin95( void )
{
    // Figure out if we're on 9x
    OSVERSIONINFO osvi; 
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx( &osvi );
    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}

/******************************Public*Routine******************************\
*
* ss_LoadTextureResourceStrings
*
* Load various messages and strings that are used in processing textures,
* into global TEX_STRINGS structure
*
\**************************************************************************/

BOOL
ss_LoadTextureResourceStrings()
{
    LPTSTR pszStr;

    // title for choose texture File dialog
    LoadString(NULL, IDS_TEXTUREDIALOGTITLE, gts.szTextureDialogTitle, 
                GEN_STRING_SIZE);
    LoadString(NULL, IDS_BMP, gts.szBmp, GEN_STRING_SIZE);
    LoadString(NULL, IDS_DOTBMP, gts.szDotBmp, GEN_STRING_SIZE);

    // szTextureFilter requires a little more work.  Need to assemble the file
    // name filter string, which is composed of two strings separated by a NULL
    // and terminated with a double NULL.

    LoadString(NULL, IDS_TEXTUREFILTER, gts.szTextureFilter, 
                GEN_STRING_SIZE);
    pszStr = &gts.szTextureFilter[lstrlen(gts.szTextureFilter)+1];
    LoadString(NULL, IDS_STARDOTBMP, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
/*
    *pszStr++ = TEXT(';');
    LoadString(NULL, IDS_STARDOTRGB, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
*/
    pszStr++;
    *pszStr = TEXT('\0');

    LoadString(NULL, IDS_WARNING, gts.szWarningMsg, MAX_PATH);
    LoadString(NULL, IDS_SELECT_ANOTHER_BITMAP, 
                gts.szSelectAnotherBitmapMsg, MAX_PATH );

    LoadString(NULL, IDS_BITMAP_INVALID, 
                gts.szBitmapInvalidMsg, MAX_PATH );
    LoadString(NULL, IDS_BITMAP_SIZE, 
                gts.szBitmapSizeMsg, MAX_PATH );

    // assumed here that all above calls loaded properly (mf: fix later)
    return TRUE;
}

/******************************Public*Routine******************************\
*
*
\**************************************************************************/

void
ss_DisableTextureErrorMsgs()
{
    gbEnableErrorMsgs = FALSE;
}

/******************************Public*Routine******************************\
*
* ss_DeleteTexture
*
\**************************************************************************/

void
ss_DeleteTexture( TEXTURE *pTex )
{
    if( pTex == NULL )
        return;

    if( gbTextureObjects && pTex->texObj ) {
//        glDeleteTextures( 1, &pTex->texObj );
        pTex->texObj = 0;
    }
    if (pTex->pal != NULL)
    {
        free(pTex->pal);
    }
    if( pTex->data )
        free( pTex->data );
}



/******************************Public*Routine******************************\
*
* ss_VerifyTextureFile
*
* Validates texture bmp or rgb file, by checking for valid pathname and
* correct format.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 25, 95 : [marcfo]
*    - Suppress warning dialog box in child preview mode, as it will
*      be continuously brought up.
*
*  Dec. 12, 95 : [marcfo]
*     - Support .rgb files as well
*
*  Dec. 14, 95 : [marcfo]
*     - Change to have it only check the file path
*
\**************************************************************************/

BOOL
ss_VerifyTextureFile( TEXFILE *ptf )
{
    // Make sure the selected texture file is OK.

    TCHAR szFileName[MAX_PATH];
    PTSTR pszString;
    TCHAR szString[MAX_PATH];

    lstrcpy(szFileName, ptf->szPathName);

    if ( SearchPath(NULL, szFileName, NULL, MAX_PATH,
                     ptf->szPathName, &pszString)
       )
    {
        ptf->nOffset = (int)((ULONG_PTR)(pszString - ptf->szPathName));
        return TRUE;
    }
    else
    {
        lstrcpy(ptf->szPathName, szFileName);    // restore

        if( !ss_fOnWin95() && gbEnableErrorMsgs )
        {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, ptf->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return FALSE;
    }
}


/******************************Public*Routine******************************\
*
* ss_SelectTextureFile
*
* Use the common dialog GetOpenFileName to get the name of a bitmap file
* for use as a texture.  This function will not return until the user
* either selects a valid bitmap or cancels.  If a valid bitmap is selected
* by the user, the global array szPathName will have the full path
* to the bitmap file and the global value nOffset will have the
* offset from the beginning of szPathName to the pathless file name.
*
* If the user cancels, szPathName and nOffset will remain
* unchanged.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
*    - Wrote it.
*  Apr. 28, 95 : [marcfo]
*    - Modified for common use
*  Dec. 12, 95 : [marcfo]
*    - Support .rgb files as well
*
\**************************************************************************/

BOOL
ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf )
{
    OPENFILENAME ofn;
    TCHAR dirName[MAX_PATH];
    TEXFILE newTexFile;
    LPTSTR pszFileName = newTexFile.szPathName;
    TCHAR origPathName[MAX_PATH];
    PTSTR pszString;
    BOOL bTryAgain, bFileSelected;

//mf: 
    gbEnableErrorMsgs = TRUE;

    // Make a copy of the original file path name, so we can tell if
    // it changed or not
    lstrcpy( origPathName, ptf->szPathName );

    // Make dialog look nice by parsing out the initial path and
    // file name from the full pathname.  If this isn't done, then
    // dialog has a long ugly name in the file combo box and
    // directory will end up with the default current directory.

    if (ptf->nOffset) {
    // Separate the directory and file names.

        lstrcpy(dirName, ptf->szPathName);
        dirName[ptf->nOffset-1] = L'\0';
        lstrcpy(pszFileName, &ptf->szPathName[ptf->nOffset]);
    }
    else {
    // If nOffset is zero, then szPathName is not a full path.
    // Attempt to make it a full path by calling SearchPath.

        if ( SearchPath(NULL, ptf->szPathName, NULL, MAX_PATH,
                         dirName, &pszString) )
        {
        // Successful.  Go ahead a change szPathName to the full path
        // and compute the filename offset.

            lstrcpy(ptf->szPathName, dirName);
            ptf->nOffset = (int)((ULONG_PTR)(pszString - dirName));

        // Break the filename and directory paths apart.

            dirName[ptf->nOffset-1] = TEXT('\0');
            lstrcpy(pszFileName, pszString);
        }

    // Give up and use the Windows system directory.

        else
        {
            if( !GetWindowsDirectory(dirName, MAX_PATH) )
                dirName[0] = TEXT('\0');
            lstrcpy(pszFileName, ptf->szPathName);
        }
    }

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = gts.szTextureFilter;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = pszFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = dirName;
    ofn.lpstrTitle = gts.szTextureDialogTitle;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = gts.szBmp;
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    do {
    // Invoke the common file dialog.  If it succeeds, then validate
    // the bitmap file.  If not valid, make user try again until either
    // they pick a good one or cancel the dialog.

        bTryAgain = FALSE;

        if ( bFileSelected = GetOpenFileName(&ofn) ) {
            newTexFile.nOffset = ofn.nFileOffset;
            if( VerifyTextureFile( &newTexFile ) ) {
                // copy in new file and offset
                *ptf = newTexFile;
            }
            else {
                bTryAgain = TRUE;
            }
        }

    // If need to try again, recompute dir and file name so dialog
    // still looks nice.

        if (bTryAgain && ofn.nFileOffset) {
            lstrcpy(dirName, pszFileName);
            dirName[ofn.nFileOffset-1] = L'\0';
            lstrcpy(pszFileName, &pszFileName[ofn.nFileOffset]);
        }

    } while (bTryAgain);

    gbEnableErrorMsgs = FALSE;

    if( bFileSelected ) {
        if( lstrcmpi( origPathName, ptf->szPathName ) )
            // a different file was selected
            return TRUE;
    }
    return FALSE;
}


/******************************Public*Routine******************************\
*
* ss_GetDefaultBmpFile
*
* Determine a default bitmap file to use for texturing, if none
* exists yet in the registry.  
*
* Put default in BmpFile parameter.   DotBmp parameter is the bitmap
* extension (usually .bmp).
*
* We have to synthesise the name from the ProductType registry entry.
* Currently, this can be WinNT, LanmanNT, or Server.  If it is
* WinNT, the bitmap is winnt.bmp.  If it is LanmanNT or Server,
* the bitmap is lanmannt.bmp.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 27, 95 : [marcfo]
*    - Added support for win95
*
*  Apr. 23, 96 : [marcfo]
*    - Return NULL string for win95
*
\**************************************************************************/

void
ss_GetDefaultBmpFile( LPTSTR pszBmpFile )
{
    HKEY   hkey;
    LONG   cjDefaultBitmap = MAX_PATH;

    if( ss_fOnWin95() )
        // There is no 'nice' bmp file on standard win95 installations
        lstrcpy( pszBmpFile, TEXT("") );
    else {
        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 (LPCTSTR) TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                 0,
                 KEY_QUERY_VALUE,
                 &hkey) == ERROR_SUCCESS )
        {

            if ( RegQueryValueEx(hkey,
                                  TEXT("ProductType"),
                                  (LPDWORD) NULL,
                                  (LPDWORD) NULL,
                                  (LPBYTE) pszBmpFile,
                                  (LPDWORD) &cjDefaultBitmap) == ERROR_SUCCESS
                 && (cjDefaultBitmap / sizeof(TCHAR) + 4) <= MAX_PATH )
                lstrcat( pszBmpFile, gts.szDotBmp );
            else
                lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

            RegCloseKey(hkey);
        }
        else
            lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

    // If its not winnt.bmp, then its lanmannt.bmp.  (This would be a lot
    // cleaner both in the screen savers and for usersrv desktop bitmap
    // initialization if the desktop bitmap name were stored in the
    // registry).

        if ( lstrcmpi( pszBmpFile, TEXT("winnt.bmp") ) != 0 )
            lstrcpy( pszBmpFile, TEXT("lanmannt.bmp") );
    }
}

/******************************Public*Routine******************************\
*
* VerifyTextureFile
*
* Verify that a bitmap or rgb file is valid
*
* Returns:
*   File type (RGB or BMP) if valid file; otherwise, 0.
*
* History
*  Dec. 12, 95 : [marcfo]
*    - Creation
*
\**************************************************************************/

static int
VerifyTextureFile( TEXFILE *pTexFile )
{
    int type;
//    ISIZE size;
    BOOL bValid = TRUE;
    TCHAR szString[2 * MAX_PATH]; // May contain a pathname

    // check for 0 offset and null strings
    if( (pTexFile->nOffset == 0) || (*pTexFile->szPathName == 0) )
        return 0;

    type = GetTexFileType( pTexFile );

    switch( type ) {
        case TEX_BMP:
//            bValid = bVerifyDIB( pTexFile->szPathName, &size );
            break;
/*
        case TEX_RGB:
//            bValid = bVerifyRGB( pTexFile->szPathName, &size );
            break;
*/
        case TEX_UNKNOWN:
        default:
            bValid = FALSE;
    }

    if( !bValid ) {
        if( gbEnableErrorMsgs ) {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, pTexFile->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return 0;
    }

    return type;
}

/******************************Public*Routine******************************\
*
* GetTexFileType
*
* Determine if a texture file is rgb or bmp, based on extension.  This is
* good enough, as the open texture dialog only shows files with these
* extensions.
*
\**************************************************************************/

static int
GetTexFileType( TEXFILE *pTexFile )
{
    LPTSTR pszStr;

#ifdef UNICODE
    pszStr = wcsrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#else
    pszStr = strrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#endif
    if( !pszStr || (lstrlen(++pszStr) == 0) )
        return TEX_UNKNOWN;

    if( !lstrcmpi( pszStr, TEXT("bmp") ) )
        return TEX_BMP;
/*
    else if( !lstrcmpi( pszStr, TEXT("rgb") ) )
        return TEX_RGB;
*/
    else
        return TEX_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\logon\logon.h ===
#define IDB_SERVER      200
#define IDB_WORKSTA     201
#define IDB_ADVANCED    202
#define IDB_DATACENTER  203
#define IDB_PERSONAL    204
#define IDB_EMBEDDED    205
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\flyingobjects\texture.h ===
/******************************Module*Header*******************************\
* Module Name: texture.h
*
* Local texture processing functions
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __texture_h__
#define __texture_h__


#ifdef __cplusplus
extern "C" {
#endif

extern BOOL bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize );
extern BOOL bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize );

#ifdef __cplusplus
}
#endif

#endif // __texture_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\logon\logon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#include <windows.h>
#include <scrnsave.h>
#include <logon.h>

// For IsOS()
#include <shlwapi.h>
#include <shlwapip.h>

// for added XPSP1 resources
#include "winbrand.h"
#include "debug.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))
#endif


HANDLE hInst;

int cxhwndLogon;
int cyhwndLogon;
int xScreen;        // the top-left corner of the screen, might be different than (0,0)
int yScreen;
int cxScreen;
int cyScreen;
HBRUSH hbrBlack;
HDC hdcLogon;
HWND hwndLogon;
HBITMAP hbmLogon = NULL;
HICON ghiconLogon = NULL;
HICON   hMovingIcon = NULL;
HPALETTE ghpal = NULL;

#define APPCLASS "LOGON"

#define MAX_CAPTION_LENGTH  128

DWORD FAR lRandom(VOID)
{
    static DWORD glSeed = (DWORD)-365387184;

    glSeed *= 69069;
    return(++glSeed);
}

HPALETTE GetPalette(HBITMAP hbm)
{
    DIBSECTION ds;
    int i;
    HANDLE hmem;
    HDC hdc, hdcMem;
    LOGPALETTE *ppal;
    HPALETTE hpal;
    RGBQUAD rgbquad[256];
    USHORT nColors;

    GetObject(hbm, sizeof(DIBSECTION), &ds);
    if (ds.dsBmih.biBitCount > 8)
        return NULL;

    nColors = (ds.dsBmih.biBitCount < 16) ? (1 << ds.dsBmih.biBitCount) : 0xffff;

    hmem = GlobalAlloc(GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * nColors);
    if (hmem == NULL)
        return NULL;

    ppal = (LPLOGPALETTE) GlobalLock(hmem);

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);
    SelectObject(hdcMem, hbm);

    ppal->palVersion = 0x300;
    ppal->palNumEntries = nColors;
    GetDIBColorTable(hdcMem, 0, nColors, rgbquad);

    for (i = 0; i < nColors; i++) {
        ppal->palPalEntry[i].peRed = rgbquad[i].rgbRed;
        ppal->palPalEntry[i].peGreen = rgbquad[i].rgbGreen;
        ppal->palPalEntry[i].peBlue = rgbquad[i].rgbBlue;
    }

    hpal = CreatePalette(ppal);

    GlobalUnlock(hmem);
    GlobalFree(hmem);

    DeleteObject(hdcMem);
    ReleaseDC(NULL, hdc);

    return hpal;
}

LRESULT APIENTRY
WndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    int x, y;
    int nColorsChanged;

    switch (message) {
    PAINTSTRUCT ps;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;

    case WM_QUERYNEWPALETTE:
    {
        HDC hdc = GetDC(hwnd);
        SelectPalette(hdc, ghpal, FALSE);
        nColorsChanged = RealizePalette(hdc);
        ReleaseDC(hwnd, hdc);

        if (nColorsChanged != 0) {
            InvalidateRect(hwnd, NULL, TRUE);
        }
    }
    break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        SelectPalette(ps.hdc, ghpal, FALSE);
        BitBlt(ps.hdc, 0, 0, cxhwndLogon, cyhwndLogon, hdcLogon, 0, 0, SRCCOPY);
        EndPaint(hwnd, &ps);
        break;

    case WM_TIMER:
        /*
         * Pick a new place on the screen to put the dialog.
         */
        x = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        y = lRandom() % (cyScreen - cyhwndLogon) + yScreen;

        SetWindowPos(hwndLogon, NULL, x, y, 0, 0,
                SWP_NOSIZE | SWP_NOZORDER);
        break;

    case WM_CLOSE:
        ExitProcess(0);
        break;

    case WM_SETFOCUS:
        /*
         * Don't allow DefDlgProc() to do default processing on this
         * message because it'll set the focus to the first control and
         * we want it set to the main dialog so that DefScreenSaverProc()
         * will see the key input and cancel the screen saver.
         */
        return TRUE;
        break;

    /*
     * Call DefScreenSaverProc() so we get its default processing (so it
     * can detect key and mouse input).
     */
    default:
        return DefScreenSaverProc(hwnd, message, wParam, lParam) ? TRUE : FALSE;
    }

    return 0;
}


int sx;
int sy;

LRESULT OnCreateSS(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    // Background window is black
    // Make sure we use the entire virtual desktop size for multiple
    // displays:
    cxScreen =  ((LPCREATESTRUCT)lParam)->cx;
    cyScreen =  ((LPCREATESTRUCT)lParam)->cy;
    xScreen =  ((LPCREATESTRUCT)lParam)->x;
    yScreen =  ((LPCREATESTRUCT)lParam)->y;

    hbrBlack = GetStockObject(BLACK_BRUSH);
    if (!fChildPreview)
    {
        WNDCLASS wndClass;
        BITMAP bm = {0};
        UINT uXpSpLevel = 0;
        HMODULE hResourceDll = hMainInstance;

        if (hbmLogon == NULL)
        {
            LPTSTR res;

            // Embedded OS has it's own logo
            if (IsOS(OS_EMBEDDED))
            {
                res = MAKEINTRESOURCE(IDB_EMBEDDED);
            }
            else if (IsOS(OS_TABLETPC))
            {
                uXpSpLevel = 1;
                res = MAKEINTRESOURCE(IDB_TABLETPC_LOGON_SCR);
            }
            else if (IsOS(OS_MEDIACENTER))
            {
                uXpSpLevel = 1;
                res = MAKEINTRESOURCE(IDB_MEDIACENTER_LOGON_SCR);
            }
            else if (IsOS(OS_DATACENTER))
            {
                AssertMsg(FALSE, "Should not see this on XPSP");
                res = MAKEINTRESOURCE(IDB_DATACENTER);
            }
            else if (IsOS(OS_ADVSERVER))
            {
                AssertMsg(FALSE, "Should not see this on XPSP");
                res = MAKEINTRESOURCE(IDB_ADVANCED);
            }
            else if (IsOS(OS_SERVER))
            {
                AssertMsg(FALSE, "Should not see this on XPSP");
                res = MAKEINTRESOURCE(IDB_SERVER);
            }
            else if (IsOS(OS_PERSONAL))
            {
                res = MAKEINTRESOURCE(IDB_PERSONAL);
            }
            else
            {
                res = MAKEINTRESOURCE(IDB_WORKSTA);
            }

            if (uXpSpLevel > 0)
            {
                hResourceDll = LoadLibraryEx(TEXT("winbrand.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);

                if (hResourceDll == NULL)
                {
                    hResourceDll = hMainInstance;
                }
            }

            hbmLogon = LoadImage(hResourceDll, res, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

            if (hbmLogon)
            {
                ghpal = GetPalette(hbmLogon);
            }

            if (hResourceDll != hMainInstance)
            {
                FreeLibrary(hResourceDll);
            }
        }

        if (hbmLogon)
        {
            GetObject(hbmLogon, sizeof(bm), &bm);
        }

        cxhwndLogon = bm.bmWidth;
        cyhwndLogon = bm.bmHeight;

        hdcLogon = CreateCompatibleDC(NULL);
        if (hdcLogon && hbmLogon)
        {
            SelectObject(hdcLogon, hbmLogon);
        }

        wndClass.style         = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc   = WndProc;
        wndClass.cbClsExtra    = 0;
        wndClass.cbWndExtra    = sizeof(LONG);
        wndClass.hInstance     = hInst;
        wndClass.hIcon         = NULL;
        wndClass.hCursor       = NULL;
        wndClass.hbrBackground = NULL;
        wndClass.lpszMenuName  = NULL;
        wndClass.lpszClassName = TEXT("LOGON");

        RegisterClass(&wndClass);

        // Create the window we'll move around every 10 seconds.
        hwndLogon = CreateWindowEx(WS_EX_TOPMOST, TEXT("LOGON"), NULL, WS_VISIBLE | WS_POPUP,
                50, 50, cxhwndLogon, cyhwndLogon, hMainWindow, NULL, hInst, NULL);

        if (hwndLogon)
        {
            SetTimer(hwndLogon, 1, 10 * 1000, 0);
        }

        // Post this message so we activate after this window is created.
        PostMessage(hwnd, WM_USER, 0, 0);
    }
    else
    {
        SetTimer(hwnd, 1, 10 * 1000, 0);

        cxhwndLogon = GetSystemMetrics(SM_CXICON);
        cyhwndLogon = GetSystemMetrics(SM_CYICON);

        ghiconLogon = LoadIcon(hMainInstance, MAKEINTRESOURCE(1));

        sx = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        sy = lRandom() % (cyScreen - cyhwndLogon) + yScreen;
    }

    return 0;
}

LRESULT APIENTRY ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        OnCreateSS(hwnd, message, wParam, lParam);
        break;

    case WM_SIZE:
        cxScreen = LOWORD(lParam);
        cyScreen = HIWORD(lParam);
        break;

    case WM_WINDOWPOSCHANGING:
        /*
         * Take down hwndLogon if this window is going invisible.
         */
        if (hwndLogon == NULL)
            break;

        if (((LPWINDOWPOS)lParam)->flags & SWP_HIDEWINDOW) {
            ShowWindow(hwndLogon, SW_HIDE);
        }
        break;

    case WM_USER:
        /*
         * Now show and activate this window.
         */
        if (hwndLogon == NULL)
            break;

        SetWindowPos(hwndLogon, NULL, 0, 0, 0, 0, SWP_SHOWWINDOW |
                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        SetRect(&rc, xScreen, yScreen, cxScreen, cyScreen);
        FillRect(hdc, &rc, hbrBlack);

        if (fChildPreview) {
            DrawIcon(hdc, sx, sy, ghiconLogon);
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_NCACTIVATE:
        /*
         * Case out WM_NCACTIVATE so the dialog activates: DefScreenSaverProc
         * returns FALSE for this message, not allowing activation.
         */
        if (!fChildPreview)
            return DefWindowProc(hwnd, message, wParam, lParam);
        break;

    case WM_TIMER:
        /*
         * Pick a new place on the screen to put the dialog.
         */
        sx = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        sy = lRandom() % (cyScreen - cyhwndLogon) + yScreen;
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }

    return DefScreenSaverProc(hwnd, message, wParam, lParam);
}

BOOL APIENTRY
ScreenSaverConfigureDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR ach1[256];
    TCHAR ach2[256];

    switch (message) {
    case WM_INITDIALOG:
        /*
         * This is hack-o-rama, but fast and cheap.
         */
        LoadString(hMainInstance, IDS_DESCRIPTION, ach1, ARRAYSIZE(ach1));
        LoadString(hMainInstance, 2, ach2, ARRAYSIZE(ach2));

        MessageBox(hDlg, ach2, ach1, MB_OK | MB_ICONEXCLAMATION);

        EndDialog(hDlg, TRUE);
        break;
    }
    return FALSE;
}

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\marquee\strings.h ===
#define idsDescription    1
#define idsName         100
#define idsDefaultText  101
#define idsFormatText   102
#define idsDefFontName  103


#include "..\common\comstrin.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\marquee\ssmarque.c ===
/*
marquee.c
This is a screen saver that can easily be added onto...

  History:
       6/17/91        stevecat    ported to NT Windows
       2/10/92        stevecat    snapped to latest Win3.1 sources
*/

#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>
#include <scrnsave.h>
#include "marquee.h"
#include "strings.h"
#include "uniconv.h"


#define MulDiv(a, b, c)  ((int)(a) * (int)(b) / (int)(c))

typedef struct
{
    HWND        hDlg;
    WORD        wID;
    HDC         hDC;
} INFOSTRUCT;
typedef INFOSTRUCT far * LPINFOSTRUCT;

UINT PWM_NEWSPEED;
UINT PWM_NEWPOSITION;
#define BUFFER_LEN        255
#define COUNT             2
#define MAX_SPEED         10
#define DEF_SPEED         10
#define DIV_SPEED         3

#define NATTRIBUTES       5
#define UNDERLINE         0
#define STRIKEOUT         1
#define ITALIC            2
#define MODE              3
#define BOLD              4

#define DEFAULT_TEXT_COLOR      RGB(255,0,255)
#define DEFAULT_SCREEN_COLOR    RGB(0,0,0)

TCHAR szDefaultText[BUFFER_LEN];         // Buffer for default Marquee text
TCHAR szFormatText[TITLEBARNAMELEN];     // Name in font formatting dlg.

TCHAR szFontName[]=TEXT("Font");               // CONTROL.INI key values
TCHAR szSizeName[]=TEXT("Size");
TCHAR szTextName[]=TEXT("Text");
TCHAR szTColorName[]=TEXT("TextColor");
TCHAR szBColorName[]=TEXT("BackgroundColor");
TCHAR szAttributes[]=TEXT("Attributes");
TCHAR szSpeedName[]=TEXT("Speed");
TCHAR szCharSetName[]=TEXT("CharSet");
TCHAR szShowTextName[]=TEXT("showtext");

TCHAR szBuffer[BUFFER_LEN];              // Text to display in Marquee
TCHAR szFaceName[LF_FACESIZE];           // Font face name to use...
TCHAR szDefFontName[LF_FACESIZE];
BOOL fMode=FALSE;                       // Mode of ScreenSaver
TCHAR fUnderline=TEXT('0');
TCHAR fStrikeOut=TEXT('0');
TCHAR fItalic=TEXT('0');
TCHAR fBold=TEXT('0');
HFONT hfontMessage = NULL;
DWORD dwTColor;                         // Global text color
DWORD dwBColor;                         // Global background color
BYTE bCharSet;
DWORD dwRand = 1L;

#define RAND(x)   ((rand() % ((x == 0) ? 1 : x)) + 1)
#define ZRAND(x)  (rand() % ((x == 0) ? 1 : x))

// Function prototypes...

void  srand (DWORD);
WORD  rand (void);
LRESULT APIENTRY ShowTextProc (HWND, UINT, WPARAM, LPARAM);
int   GetHeightFromPointSize (int);
void  FillR (HDC, LPRECT, DWORD);
void  FrameR (HDC, LPRECT, DWORD, int);
void  PatB (HDC, int, int, int, int, DWORD);
void  GetAttributes (void);
DWORD GetProfileRgb (LPTSTR, LPTSTR, DWORD);
WORD  AtoI (LPTSTR);
BOOL  APIENTRY ChooseFontHookProc (HWND, UINT, DWORD, LONG);

//
// Help IDs
//
DWORD aMarqueeDlgHelpIds[] = {
    ((DWORD) -1), ((DWORD) -1),
    ID_FORMATTEXT,          IDH_DISPLAY_SCREENSAVER_MARQUEE_FORMAT_TEXT,
    ID_CENTERED,            IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_CENTERED,
    ID_RANDOM,              IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_RANDOM,
    ID_BGROUNDCOLOR_LABEL,  IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR,
    ID_BGROUNDCOLOR,        IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR,
    ID_SPEED_SLOW,          IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_SPEED_FAST,          IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_SPEED,               IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_MARQUEETEXT_LABEL,   IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT,
    ID_MARQUEETEXT,         IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT,
    ID_TEXTWINDOW,          IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT_EXAMPLE,
    0,0
};

//***************************************************************************

//
// This function returns TRUE, if szBuffer includes DBCS, otherwise FALSE.
// #425:12/21/92:fixing DBCS dispatch automatically
//
// ToddB: all DBCS and CodePage issues are handled by first calling this function.
// To do the FE single binary merge I'm simply calling this function always (instead
// of only in Far East builds).  If this function returns FALSE then the remaining
// code path is identical to the old US version.
BOOL FAR PASCAL IsTextIncludeDBCSChar(void)
{
    static BOOL bDBCS = -1;
    int   i, len = lstrlen(szBuffer) ;
    CHAR  c;
    CHAR  szb[BUFFER_LEN*sizeof(TCHAR)];

    // Use lazy initialization since I have multiple the entry points which vary
    // depending on what message handlers are processed in the WndProc
    if ( -1 == bDBCS )
        bDBCS = GetSystemMetrics( SM_DBCSENABLED );

    // if we are not using a DBCS version of user.exe then nothing should
    // be treated as a DBCS character.
    if (!bDBCS)
        return FALSE;

    if (sizeof(TCHAR) == sizeof(CHAR))
    {
        // same size, just copy.  The cast is valid due to the above check and
        // it keeps the compiler happy
        lstrcpy( (TCHAR *)szb, szBuffer );
    }
    else
    {
        // szBuffer is UNICODE, we convert it to DBCS before checking for lead bytes.
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
        szBuffer, len+1,
        szb, BUFFER_LEN*sizeof(TCHAR),
        NULL, NULL );
    }

    for (i = 0;i < len;i++) {
        c = szb[i] ;

        if (IsDBCSLeadByte(c)) {
            return TRUE ;
        }
/* hankaku katakana JAPAN only */
        else if (GetACP() == 932 && c >= 0xa0 && c <  0xe0) {
            return TRUE ;
        }
    }
    return FALSE ;
}

static CHARSETINFO csi;

void LoadStrings(void)
{
    TCHAR szTmp[BUFFER_LEN];
    OSVERSIONINFO osi;

    // This simply fills a CHARSETINFO structure with data about the code page
    DWORD dw = GetACP();
    if (!TranslateCharsetInfo((DWORD*)IntToPtr(dw), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;

    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    // Get OS Version
    LoadString (hMainInstance, idsDefaultText, szTmp, CharSizeOf(szTmp));
    osi.dwOSVersionInfoSize = sizeof(osi);
    if (!GetVersionEx(&osi)) {
        osi.dwMajorVersion = 4;
        osi.dwMinorVersion = 0;
    }
    wsprintf( szDefaultText, szTmp, osi.dwMajorVersion, osi.dwMinorVersion );

    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));
    LoadString (hMainInstance, idsFormatText, szFormatText, CharSizeOf(szFormatText));
    LoadString (hMainInstance, idsDefFontName, szDefFontName, CharSizeOf(szDefFontName));
}

//***************************************************************************

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT APIENTRY ScreenSaverProc(hWnd, message, wParam, lParam)
HWND   hWnd;
UINT   message;
WPARAM wParam;
LPARAM lParam;
{
RECT                rRect;
static int          wSize;
static WORD         wHeight;
static UINT_PTR     wTimer;
static WORD         wX;
static WORD         wY;
static WORD         wCount;
static SIZE         sizeExtent;
static int          wLength;
static WORD         wSpeed;
static WORD         wVelocity;
static HBRUSH       hbrTemp;
static TEXTMETRIC   tm;
static BOOL         bMELocale;
HBRUSH              hbrOld;
HFONT               hfontOld;
HDC                 hDC;
DWORD               dwLocale;
UINT                uiETOFlags;

    switch(message)
    {
        case WM_CREATE:
            LoadStrings ();
            GetAttributes();
            /* Get the info necessary to create the font... */
            GetPrivateProfileString (szAppName, szFontName, szDefFontName, szFaceName,
                                     CharSizeOf(szFaceName), szIniFile);
            bCharSet = (BYTE)GetPrivateProfileInt (szAppName,szCharSetName,
                                                    (WORD)ANSI_CHARSET, szIniFile);
        if( IsTextIncludeDBCSChar() )
            {
                bCharSet = (BYTE)csi.ciCharset;
            }

            hDC = GetDC (NULL);

            //  See if the user locale id is Arabic or Hebrew.
            dwLocale    = GetUserDefaultLCID();
            bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_HEBREW));

            /* Get the dimensions of the entire virtual screen... */
            wX = (WORD)((LPCREATESTRUCT)lParam)->cx;
            wY = (WORD)((LPCREATESTRUCT)lParam)->cy;

            wSize = GetPrivateProfileInt (szAppName, szSizeName, 0, szIniFile);
            // wSize is in POINTS, we need to convert it to LogicalUnits...
            wSize = GetHeightFromPointSize (wSize);

            if (fChildPreview) {
                // Scale font down to fit in preview window
                wSize = (wSize * wY) / GetDeviceCaps(hDC, VERTRES);
            }

            hfontMessage = CreateFont (wSize, 0, 0, 0,
                                       (fBold == TEXT('0')) ? FW_NORMAL : FW_BOLD,
                                       (fItalic == TEXT('0')) ? 0 : 1,
                                       (fUnderline == TEXT('0')) ? 0 : 1,
                                       (fStrikeOut == TEXT('0')) ? 0 : 1,
                                       bCharSet,
                                       OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                       DEFAULT_PITCH|FF_DONTCARE, szFaceName);

            /* Get the text to display and figure out how long it is... */
            GetPrivateProfileString (szAppName, szTextName, szDefaultText, szBuffer,
                                     CharSizeOf(szBuffer), szIniFile);
            lstrcat (szDefaultText, TEXT("     "));
            wLength = lstrlen (szBuffer);
            hfontOld = SelectObject (hDC,hfontMessage);
            GetTextExtentPoint32 (hDC, szBuffer, wLength, &sizeExtent);

            if (fChildPreview)
                sizeExtent.cx *= 2;

            GetTextMetrics (hDC,&tm);
            if (hfontOld)
                SelectObject (hDC,hfontOld);

            ReleaseDC (NULL,hDC);
            if (bMELocale) {
                wCount = (WORD)(0 - sizeExtent.cy + 1);
            } else {
                wCount = wX;
            }
            srand(GetCurrentTime());

            /* set everything up... */
            if(fMode)
                wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
            else
                wHeight = (WORD) (wY - sizeExtent.cy)/2;

            if ((int)(wSpeed = (WORD) GetPrivateProfileInt (szAppName, szSpeedName, DEF_SPEED, szIniFile))
                < 1)
                wSpeed = 1;
            if (wSpeed > (MAX_SPEED * DIV_SPEED))
                wSpeed = MAX_SPEED * DIV_SPEED;

            dwTColor = GetProfileRgb(szAppName,szTColorName,DEFAULT_TEXT_COLOR);
            dwBColor = GetProfileRgb(szAppName,szBColorName,DEFAULT_SCREEN_COLOR);
            hbrTemp = CreateSolidBrush(dwBColor);

            /* Set the timer... */
            wTimer = SetTimer(hWnd,9,1,NULL);
            break;

        case WM_SIZE:
            wX = LOWORD(lParam);
            wY = HIWORD(lParam);
            break;

        case WM_ERASEBKGND:
            /* If you want something put on the background, do it right here
                using wParam as a handle to a device context.  Remember to
                unrealize a brush if it is not a solid color.  If you do
                something here, you want to use the line:
                    return 0l;
                So the program knows not to take the default action. Otherwise
                just use:
                    break;
                */
            GetClientRect (hWnd, &rRect);
            FillRect ((HDC)wParam, &rRect, hbrTemp);
            return 0l;

        case WM_TIMER:
        {
            RECT rc;

            // NOTE:  For Win32 the casting of these quantities is extremely
            //        important.  The original code was very sloppy and just
            //        made everything WORD (even for signed quantities).  We
            //        must use proper casting here to get around these coding
            //        ERRORS!!
            //           [stevecat]

            rc.top    = (int)(short) wHeight;
            rc.left   = (int)(short) wCount - tm.tmMaxCharWidth;
            rc.bottom = (int)(short) wHeight + sizeExtent.cy + (sizeExtent.cy >> 3); //Some fonts leave a trail
            rc.right  = (int)(short) wCount + sizeExtent.cx + (wVelocity / DIV_SPEED) +
                                  1 + tm.tmMaxCharWidth * 2;

            /* Add the new increment to the timer count, if we have not reached
                the integral part of the count, wait until we do... */
            wVelocity += wSpeed;
            if(wVelocity < DIV_SPEED)
                break;
            hDC = GetDC(hWnd);
            hfontOld = SelectObject(hDC,hfontMessage);
            SetTextColor(hDC,dwTColor);
            SetBkColor(hDC,dwBColor);

            uiETOFlags = ETO_OPAQUE;
            
            if (bMELocale) {
              uiETOFlags |= ETO_RTLREADING;
            }

            ExtTextOut(hDC, (int)(short)wCount, wHeight, uiETOFlags,
                                            &rc, szBuffer, wLength, NULL);
                                            
            if (hfontOld)
                SelectObject(hDC,hfontOld);

            if (bMELocale) { // Arabic/Hebrew Locale
                if((short)wCount < (short) wX)
                   wCount += (wVelocity/DIV_SPEED)+1;
                else
                {
                    wCount = (WORD)(0 - sizeExtent.cx + 1);
                    if(fMode)
                       wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
                 }

            } else {

                /* Increment so it is ready for the next pass... */
                if((short)wCount >= (short)(0-sizeExtent.cx))
                   wCount -= (wVelocity/DIV_SPEED)+1;
                else
                {
                    hbrOld = SelectObject(hDC,hbrTemp);
                    //  The wSize variable is some bogus value left over during WM_CREATE and
                    //  doesn't seem to have any connection to where the PatBlt should start
                    //  in the X direction.  Replacing this value with 0 fixes bug #5415
                    //                PatBlt(hDC,(int)(short)wSize, (int)(short)wHeight,
                    PatBlt(hDC, 0, (int)(short)wHeight,
                             ((wVelocity/DIV_SPEED)+1)*1+tm.tmMaxCharWidth*2,
                               sizeExtent.cy, PATCOPY);
                    if (hbrOld)
                       SelectObject(hDC,hbrOld);
                    wCount = wX;
                    if(fMode)
                       wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
                 }
            }
            ReleaseDC(hWnd,hDC);

            wVelocity = wVelocity % DIV_SPEED;
            break;
        }
        case WM_DESTROY:
            /* Anything that needs to be deleted when the window is closed
                goes here... */
            if(wTimer)
                KillTimer(hWnd,wTimer);
            if(hfontMessage)
                DeleteObject(hfontMessage);
            DeleteObject(hbrTemp);
            break;
    }
    /* Unless it is told otherwise, the program will take default actions... */
    return (DefScreenSaverProc(hWnd,message,wParam,lParam));
}

//***************************************************************************

/*  This is where the code for the configure dialog box goes. It is a typical
    dialog box. The corresponding resource that is loaded is called
    'ScreenSaverConfigure' and is located in the ResourceCompiler file.
    Minimally (as in this case), this functions as an about box.  In this
    case, we also get the applications icon which must be defined as
    ID_APP... */

BOOL APIENTRY ScreenSaverConfigureDialog(hDlg, message, wParam, lParam)
HWND   hDlg;
UINT   message;
WPARAM wParam;
LPARAM lParam;
{
UINT            wTemp,wPal =0;
static int      wSize;              // current font size selected.
HPALETTE        hPal;
RECT            rc;
static HWND     hIDOK, hSetPassword;
HDC             hDC;
static LOGFONT  lfFont;
CHOOSEFONT      chfChooseFont;
FARPROC         lpfp;

static HFONT hfontPrev, hFontSave;
static LOGFONT lfFontPrev;

    switch(message)
    {
        case WM_INITDIALOG:
            PWM_NEWSPEED = RegisterWindowMessage(TEXT("PWM_NEWSPEED"));
            PWM_NEWPOSITION = RegisterWindowMessage(TEXT("PWM_NEWPOSITION"));

            LoadStrings ();
            GetAttributes ();
            hIDOK = GetDlgItem (hDlg, IDOK);

            /* Fill up both of the color combo boxes and select the right
                entries... */
            hPal = GetStockObject (DEFAULT_PALETTE);
            GetObject (hPal, sizeof(int), (LPTSTR)&wPal);
            for (wTemp = 0; wTemp < wPal; wTemp++)
                SendDlgItemMessage (hDlg, ID_BGROUNDCOLOR, CB_ADDSTRING, 0,
                                    (LPARAM)TEXT("a"));

            dwBColor = GetProfileRgb (szAppName, szBColorName, DEFAULT_SCREEN_COLOR);
            wTemp = GetNearestPaletteIndex (hPal,dwBColor);
            SendDlgItemMessage (hDlg, ID_BGROUNDCOLOR, CB_SETCURSEL, wTemp, 0l);
            GetPaletteEntries (hPal, wTemp, 1, (LPPALETTEENTRY)(LPDWORD)&dwBColor);

            /* Get the mode of the marquee... */
            CheckRadioButton (hDlg,ID_CENTERED,ID_RANDOM,
                              fMode ? ID_RANDOM : ID_CENTERED);
            SendDlgItemMessage (hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);

            /* Set up the scroll bar to take care of speed... */
            SetScrollRange (GetDlgItem (hDlg,ID_SPEED), SB_CTL, 1, MAX_SPEED * DIV_SPEED,
                            FALSE);
            if ((wTemp = GetPrivateProfileInt (szAppName, szSpeedName, DEF_SPEED, szIniFile))
                < 1)
                wTemp = 1;
            if (wTemp > (MAX_SPEED * DIV_SPEED))
                wTemp = MAX_SPEED * DIV_SPEED;
            SetScrollPos (GetDlgItem (hDlg,ID_SPEED), SB_CTL, wTemp, TRUE);
            SendDlgItemMessage (hDlg, ID_TEXTWINDOW, PWM_NEWSPEED, wTemp, 0l);

            /* Get the text from the .INI file entry and set up the edit box
                where the user enters the text to display... */
            SendDlgItemMessage (hDlg, ID_MARQUEETEXT, EM_LIMITTEXT, CharSizeOf(szBuffer) - 1, 0l);
            GetPrivateProfileString (szAppName, szTextName, szDefaultText, szBuffer,
                                     CharSizeOf(szBuffer), szIniFile);
            SetWindowText (GetDlgItem (hDlg, ID_MARQUEETEXT), szBuffer);

            /* Get the info necessary to create the font... */
            GetPrivateProfileString (szAppName, szFontName, szDefFontName, szFaceName,
                                     CharSizeOf(szFaceName), szIniFile);
            bCharSet = (BYTE)GetPrivateProfileInt (szAppName, szCharSetName,
                                                 (WORD)ANSI_CHARSET, szIniFile);

            if( IsTextIncludeDBCSChar() )
            {
                bCharSet = (BYTE) csi.ciCharset;
            }

            wSize = GetPrivateProfileInt (szAppName, szSizeName, 10, szIniFile);
            // wSize is in POINTS, we need to convert it to LogicalUnits...
            wSize = GetHeightFromPointSize (wSize);

            hfontMessage = CreateFont(wSize,0,0,0,
                (fBold     ==TEXT('0'))?FW_NORMAL:FW_BOLD,
                (TCHAR)((fItalic   ==TEXT('0'))?0:1),
                (TCHAR)((fUnderline==TEXT('0'))?0:1),
                (TCHAR)((fStrikeOut==TEXT('0'))?0:1),
                bCharSet,
                OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
                DEFAULT_PITCH|FF_DONTCARE,szFaceName);
            dwTColor = GetProfileRgb(szAppName,szTColorName,DEFAULT_TEXT_COLOR);

            lfFont.lfWeight   =(fBold     ==TEXT('0'))?FW_NORMAL:FW_BOLD,
            lfFont.lfItalic   =(fItalic   ==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfUnderline=(fUnderline==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfStrikeOut=(fStrikeOut==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfHeight=(LONG)wSize;
            lfFont.lfCharSet = bCharSet;
            lstrcpy(lfFont.lfFaceName, szFaceName);

            return TRUE;

        case WM_HSCROLL:
            wTemp = GetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL);
            switch(LOWORD(wParam))
            {
                case SB_PAGEDOWN:
                    wTemp += (DIV_SPEED-1);
                case SB_LINEDOWN:
                    wTemp += 1;
                    wTemp = min(MAX_SPEED*DIV_SPEED,wTemp);
                    break;
                case SB_PAGEUP:
                    wTemp -= (DIV_SPEED-1);
                case SB_LINEUP:
                    wTemp -= 1;
                    wTemp = max(1,(int)wTemp);
                    break;
                case SB_THUMBPOSITION:
                    wTemp = HIWORD(wParam);
                    break;
                case SB_TOP:
                    wTemp = 1;
                    break;
                case SB_BOTTOM:
                    wTemp = MAX_SPEED*DIV_SPEED;
                    break;
            }
            SetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL,wTemp,TRUE);
            SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWSPEED,wTemp,0l);
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = 12;
            return TRUE;

        case WM_DRAWITEM:
            rc    = ((LPDRAWITEMSTRUCT)lParam)->rcItem;

            if (((LPDRAWITEMSTRUCT)lParam)->itemState & ODS_SELECTED)
            {
                FrameR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,RGB(0,0,0),2);
                InflateRect(&rc,-1,-1);
                FrameR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,RGB(255,255,255),2);
                InflateRect(&rc,-1,-1);
            }
            FillR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,PALETTEINDEX
                (((LPDRAWITEMSTRUCT)lParam)->itemID));
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_MARQUEETEXT:
                    if(HIWORD(wParam) == EN_UPDATE)
                    {
                        GetDlgItemText (hDlg, ID_MARQUEETEXT, szBuffer, CharSizeOf(szBuffer));

                        if (IsTextIncludeDBCSChar()) {
                            if (lfFont.lfCharSet != csi.ciCharset) {
                                if (hfontPrev) {
                                    if (hfontMessage)
                                        DeleteObject(hfontMessage);
                                    // Restore old font imformation
                                    hfontMessage = hfontPrev;
                                    lfFont = lfFontPrev;
                                    hfontPrev = NULL;
                                }
                                else {
                                    // Save old font imformation
                                    hfontPrev = hfontMessage;
                                    lfFontPrev = lfFont;
                                    lfFont.lfCharSet = (BYTE) csi.ciCharset;
                                    hfontMessage = CreateFontIndirect((LPLOGFONT)&lfFont);
                                }
                                SendDlgItemMessage(hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);
                                InvalidateRect(GetDlgItem(hDlg, ID_TEXTWINDOW), NULL, TRUE);
                            }
                        }
                        else {
                            if (lfFont.lfCharSet == csi.ciCharset) {
                                if (hfontPrev) {
                                    if (hfontMessage)
                                        DeleteObject(hfontMessage);
                                    // Restore old font imformation
                                    hfontMessage = hfontPrev;
                                    lfFont = lfFontPrev;
                                    hfontPrev = NULL;
                                    SendDlgItemMessage(hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);
                                    InvalidateRect(GetDlgItem(hDlg, ID_TEXTWINDOW), NULL, TRUE);
                                }
                            }
                        }
                        bCharSet = lfFont.lfCharSet;
                        SetDlgItemText (hDlg, ID_TEXTWINDOW, szBuffer);
                    }
                    break;

                case ID_CENTERED:
                case ID_RANDOM:
                    fMode=(wParam!=ID_CENTERED);
                    SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWPOSITION,fMode,0l);
                    CheckRadioButton(hDlg,ID_CENTERED,ID_RANDOM,LOWORD(wParam));
                    break;

                case ID_FORMATTEXT:
                    hDC = GetDC(hDlg);

                    hFontSave = SelectObject( hDC, hfontMessage );
                    GetTextFace( hDC, LF_FACESIZE, lfFont.lfFaceName );
                    SelectObject( hDC, hFontSave );

                    chfChooseFont.lStructSize = sizeof (CHOOSEFONT);
                    chfChooseFont.hwndOwner = hDlg;
                    chfChooseFont.hDC = hDC;
                    chfChooseFont.lpLogFont = &lfFont;
                    chfChooseFont.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT |
                                          CF_LIMITSIZE | CF_EFFECTS | CF_ENABLEHOOK;
                    chfChooseFont.rgbColors = dwTColor;
                    chfChooseFont.lCustData = 0L;
                    chfChooseFont.lpfnHook = (LPCFHOOKPROC)ChooseFontHookProc;
                    chfChooseFont.lpTemplateName = (LPTSTR)NULL;
                    chfChooseFont.hInstance = (HANDLE) NULL;
                    chfChooseFont.lpszStyle = (LPTSTR) NULL;
                    chfChooseFont.nFontType = SCREEN_FONTTYPE;
                    chfChooseFont.nSizeMin = 8;
                    chfChooseFont.nSizeMax = 200;
                    if (ChooseFont(&chfChooseFont))
                    {
                        lstrcpy(szFaceName, lfFont.lfFaceName);
                        wSize     =lfFont.lfHeight;
                        dwTColor  =chfChooseFont.rgbColors;
                        fStrikeOut=(lfFont.lfStrikeOut)?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fUnderline=(lfFont.lfUnderline)?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fItalic   =(lfFont.lfItalic)   ?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fBold     =(lfFont.lfWeight==FW_NORMAL)?(TCHAR)TEXT('0'):(TCHAR)TEXT('1');
                        bCharSet  =lfFont.lfCharSet;

                        if (hfontPrev)
                        {
                            DeleteObject(hfontPrev);
                            hfontPrev = NULL;
                        }

                        if (hfontMessage)
                           DeleteObject(hfontMessage);

                        hfontMessage = CreateFontIndirect((LPLOGFONT)&lfFont);

                        if (IsTextIncludeDBCSChar()) {
                            if (lfFont.lfCharSet != csi.ciCharset) {
                                hfontPrev = hfontMessage ;
                                lfFontPrev = lfFont ;
                                lfFont.lfCharSet = (BYTE) csi.ciCharset ;
                                hfontMessage = CreateFontIndirect( &lfFont );
                            }
                        }

                        SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWPOSITION,fMode,0l);
                        InvalidateRect(GetDlgItem(hDlg,ID_TEXTWINDOW),NULL,TRUE);
                    }
                    ReleaseDC(hDlg, hDC);
                    break;

                case ID_BGROUNDCOLOR:
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        wTemp = (WORD)SendDlgItemMessage(hDlg,LOWORD(wParam),
                            CB_GETCURSEL,0,0l);
                        hPal = GetStockObject(DEFAULT_PALETTE);
                        GetPaletteEntries(hPal,wTemp,1,
                            (LPPALETTEENTRY)(LPDWORD)&dwBColor);
                        InvalidateRect(GetDlgItem(hDlg,ID_TEXTWINDOW),NULL,TRUE);
                    }
                    break;

                case IDOK:
                    GetWindowText(GetDlgItem(hDlg,ID_MARQUEETEXT),szBuffer,BUFFER_LEN);
                    WritePrivateProfileString(szAppName,szTextName,szBuffer, szIniFile);

                    WritePrivateProfileString(szAppName,szFontName,szFaceName, szIniFile);

                    // wSize is in logical units... we want to save as point size.
                    hDC = GetDC(hDlg);
                    wSize = MulDiv(-wSize, 72, GetDeviceCaps(hDC, LOGPIXELSY));
                    wsprintf(szBuffer, TEXT("%d"), wSize);
                    WritePrivateProfileString(szAppName,szSizeName, szBuffer, szIniFile);
                    ReleaseDC(hDlg, hDC);

                    hPal = GetStockObject(DEFAULT_PALETTE);
                    wTemp = (WORD)SendDlgItemMessage(hDlg,ID_BGROUNDCOLOR,CB_GETCURSEL,
                        0,0l);
                    GetPaletteEntries(hPal,wTemp,1,
                        (LPPALETTEENTRY)(LPDWORD)&dwBColor);
                    wsprintf(szBuffer,TEXT("%d %d %d"),GetRValue(dwBColor),
                        GetGValue(dwBColor),GetBValue(dwBColor));
                    WritePrivateProfileString(szAppName,szBColorName,szBuffer, szIniFile);

                    wsprintf(szBuffer,TEXT("%d %d %d"),GetRValue(dwTColor),
                        GetGValue(dwTColor),GetBValue(dwTColor));
                    WritePrivateProfileString(szAppName,szTColorName,szBuffer, szIniFile);

                    wTemp = GetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL);
                    wsprintf(szBuffer,TEXT("%d"),wTemp);
                    WritePrivateProfileString(szAppName,szSpeedName,szBuffer, szIniFile);

                    szBuffer[UNDERLINE]=fUnderline;
                    szBuffer[STRIKEOUT]=fStrikeOut;
                    szBuffer[ITALIC]=fItalic;
                    szBuffer[MODE]=(fMode?(TCHAR)TEXT('1'):(TCHAR)TEXT('0'));
                    szBuffer[BOLD]=fBold;
                    szBuffer[NATTRIBUTES]=TEXT('\0');
                    WritePrivateProfileString(szAppName,szAttributes,szBuffer,szIniFile);

                    wsprintf(szBuffer, TEXT("%i"), (int)bCharSet);
                    WritePrivateProfileString(szAppName,szCharSetName,szBuffer,szIniFile);

                case IDCANCEL:
                    if (hfontMessage)
                        DeleteObject(hfontMessage);
                    EndDialog(hDlg,LOWORD(wParam) == IDOK);
                    return TRUE;

            }
            break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aMarqueeDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aMarqueeDlgHelpIds
        );
        break;

        default:
            break;
    }
    return FALSE;
}

//***************************************************************************

BOOL APIENTRY ChooseFontHookProc(hDlg, msg, wParam, lParam)
HWND  hDlg;
UINT  msg;
DWORD wParam;
LONG  lParam;
{
    switch(msg)
    {
        case WM_INITDIALOG:
            ShowWindow(hDlg, SW_SHOWNORMAL);    // bug #12820
            SetWindowText(hDlg, szFormatText);
            break;
    }
    return (FALSE);
}

//***************************************************************************

/* This procedure is called right before the dialog box above is created in
    order to register any child windows that are custom controls.  If no
    custom controls need to be registered, then simply return TRUE as in this
    case.  Otherwise, register the child controls however is convenient... */

BOOL     RegisterDialogClasses ( hInst )
HANDLE   hInst;
{
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = ShowTextProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szShowTextName;

    return RegisterClass(&wc);
}

//***************************************************************************

int GetHeightFromPointSize(int szPoints)
{
    HDC hdc;
    int height;

    hdc = GetDC(NULL);
    height = MulDiv(-szPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(NULL, hdc);

    return height;
}

void PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

void FillR(HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor(hdc,rgb);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
}

void FrameR(HDC hdc, LPRECT prc, DWORD rgb, int iFrame)
{
    int     dx,dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top - 2*iFrame;

    PatB(hdc, prc->left, prc->top,          dx,iFrame,   rgb);
    PatB(hdc, prc->left, prc->bottom-iFrame,dx,iFrame,   rgb);

    PatB(hdc, prc->left,          prc->top+iFrame, iFrame,dy, rgb);
    PatB(hdc, prc->right-iFrame,  prc->top+iFrame, iFrame,dy, rgb);
}

void srand ( dwSeed )
DWORD dwSeed;
{
    dwRand = dwSeed;
}

WORD rand ( void )
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

LRESULT APIENTRY ShowTextProc ( hWnd, message, wParam, lParam )
HWND  hWnd;
UINT  message;
WPARAM wParam;
LPARAM lParam;
{
    PAINTSTRUCT     ps;
    RECT            rc;
    TCHAR           ach[180];
    int             len;
    static SIZE     sizeExt;
    HFONT           hfontT;
    HBRUSH          hbrTemp;
    static UINT_PTR wTimer;
    static WORD     wCount;
    static WORD     wInc;
    static WORD     wStep;
    static WORD     wHeight;
    static BOOL     bMELocale;
    static BOOL     fNeedToInitHeight;
    HDC             hDC;
    DWORD           dwLocale;
    UINT            uiETOFlags;

    switch (message)
    {
    case WM_CREATE:
        //  See if the user locale id is Arabic or Hebrew.
        dwLocale    = GetUserDefaultLCID();
        bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_HEBREW));

        GetClientRect(hWnd,&rc);
        if(wTimer = SetTimer(hWnd,1,1,NULL))
            wCount = (WORD) rc.right;
        else
            wCount = 0;

        wStep = DEF_SPEED;
        hDC = GetDC(NULL);
        GetTextExtentPoint32 (hDC, TEXT("T"), 1, &sizeExt);
        wHeight = (WORD)(((rc.bottom-rc.top)-sizeExt.cy)/2);
        fNeedToInitHeight = TRUE;
        ReleaseDC(NULL, hDC);
        break;

    case WM_TIMER:
        InvalidateRect(hWnd,NULL,FALSE);
        break;

    case WM_DESTROY:
        KillTimer(hWnd,wTimer);
        break;

    case WM_SETTEXT:
        DefWindowProc(hWnd, message, wParam, lParam);
        InvalidateRect(hWnd,NULL,FALSE);
    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        wInc += wStep;
        if (wInc >= DIV_SPEED)
        {
           WORD          wVelocity;
           TEXTMETRIC    tm;

            wVelocity = (wInc / DIV_SPEED) + 1;

            if (bMELocale) {
                wCount += wVelocity;
            } else {
                wCount -= wVelocity;
            }

            wInc = wInc % DIV_SPEED;
            len = GetWindowText (hWnd,ach,180);
            if (hfontMessage)
                hfontT = SelectObject(ps.hdc,hfontMessage);
            else
                hfontT = NULL;
            GetTextExtentPoint32 (ps.hdc, ach, len, &sizeExt);
            GetTextMetrics (ps.hdc, &tm);
            GetClientRect(hWnd,&rc);

            if (bMELocale) {
                 if (((short)wCount >= rc.right) || fNeedToInitHeight)
                 {
                   wCount = (WORD)(0 - sizeExt.cx + 1);
                   if(fMode)
                       wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
                   else
                       wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
                 }
            } else {
                 if ((((short)wCount + (short)sizeExt.cx) < 0) || fNeedToInitHeight)
                 {
                   wCount = (WORD) rc.right;
                   if(fMode)
                       wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
                   else
                       wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
                 }
            }

            if(fNeedToInitHeight)
                fNeedToInitHeight = FALSE;
                
            SetBkColor (ps.hdc,dwBColor);
            SetTextColor (ps.hdc,dwTColor);

#ifdef NOT_USED
//////////////////////////////////////////////////////////////////////////////
// This should have never been put in since this winproc only handles the
// "Sample Text Window"  control for the configuration dialog.  It is OK to
// use the whole client area as the opaqueing rect.
//////////////////////////////////////////////////////////////////////////////
            // Compute the opaque rectangle.
            rc.top    = (int)(short) wHeight;
            rc.left   = (int)(short) wCount;
            rc.bottom = (int)(short) wHeight + sizeExt.cy;
            rc.right  = (int)(short) wCount + sizeExt.cx + wVelocity
                                     + tm.tmMaxCharWidth * 2;
#endif  //  NOT_USED

            uiETOFlags = ETO_OPAQUE;
            if (bMELocale) {
              uiETOFlags |= ETO_RTLREADING;
            }

            ExtTextOut (ps.hdc,(int)(short) wCount, (int)(short)wHeight, uiETOFlags, (LPRECT)&rc,
                        ach, len, NULL);
            if (hfontT)
                SelectObject(ps.hdc, hfontT);
        }
        EndPaint (hWnd, &ps);
        return 0L;

    case WM_ERASEBKGND:
        hbrTemp = CreateSolidBrush (dwBColor);
        if (hbrTemp)
        {
            GetClientRect (hWnd, &rc);
            FillRect ((HDC)wParam, &rc, hbrTemp);
            DeleteObject (hbrTemp);
        }
        return 0l;

    default:
        if (message == PWM_NEWSPEED)
        {
            wStep = (WORD) wParam;
            break;
        }
        if (message == PWM_NEWPOSITION)
        {
            GetClientRect (hWnd,&rc);
            if (fMode)
                wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
            else
                wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
            fNeedToInitHeight = TRUE;
            InvalidateRect(hWnd,NULL,TRUE);
            break;
        }
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

DWORD GetProfileRgb (LPTSTR szApp, LPTSTR szItem, DWORD rgb)
{
  TCHAR    buf[80];
  LPTSTR   pch;
  WORD     r,g,b;

    GetPrivateProfileString (szApp, szItem, TEXT(""), buf, CharSizeOf(buf), szIniFile);

    if (*buf)
    {
        pch = buf;
        r = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        g = AtoI(pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        b = AtoI(pch);

        return RGB(r,g,b);
    }
    else
        return rgb;
}

WORD  AtoI (LPTSTR  lpszConvert)
{
  WORD  wReturn = 0;

    while(*lpszConvert >= TEXT('0') && *lpszConvert <= TEXT('9'))
    {
        wReturn = wReturn*10 + (WORD)(*lpszConvert - TEXT('0'));
        lpszConvert++;
    }
    return wReturn;
}

void GetAttributes(void)
{
    TCHAR szBuffer[NATTRIBUTES+1];

    GetPrivateProfileString (szAppName, szAttributes, TEXT("00000"), szBuffer,
                             CharSizeOf(szBuffer), szIniFile);

    fUnderline = szBuffer[UNDERLINE];
    fStrikeOut = szBuffer[STRIKEOUT];
    fItalic = szBuffer[ITALIC];
    fMode = (szBuffer[MODE] == TEXT('1'));
    fBold = szBuffer[BOLD];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\marquee\marquee.h ===
#define         ID_MARQUEETEXT          102
#define         ID_BGROUNDCOLOR         104
#define         ID_CENTERED             105
#define         ID_RANDOM               106
#define         ID_SPEED                107
#define         ID_TEXTWINDOW           108
#define         ID_FORMATTEXT           109
                                        
#define         ID_PASSWORDPROTECT      110
#define         ID_SETPASSWORD          111
#define         ID_BGROUNDCOLOR_LABEL   113
#define         ID_SPEED_SLOW           114
#define         ID_SPEED_FAST           115
#define         ID_MARQUEETEXT_LABEL    116

//
// Help IDs
//
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_CENTERED  4200
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_RANDOM 4201
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED           4202
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR 4203
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT            4204
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT_EXAMPLE    4205
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_FORMAT_TEXT     4206
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\cameramove.cpp ===
/*****************************************************************************\
    FILE: CameraMove.cpp

    DESCRIPTION:
        The caller can create this object to tell it to move from point a to 
    point b from time t1 to time t2.

    BryanSt 12/24/2000

    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <d3d8.h>
#include <d3dx8.h>
#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <dxutil.h>

#include <shlobj.h>
#include "CameraMove.h"


enum eCameraMoveType
{
    cameraMoveLocation = 0,
    cameraRotate,
    cameraWait,
};

typedef struct
{
    eCameraMoveType type;
    D3DXVECTOR3 vSourceLoc;           // For cameraMoveLocation and cameraRotate
    D3DXVECTOR3 vSourceTangent;       // For cameraMoveLocation and cameraRotate
    D3DXVECTOR3 vDestLoc;             // For cameraMoveLocation
    D3DXVECTOR3 vDestTangent;         // For cameraMoveLocation and cameraRotate
    float fTime;                    // For cameraMoveLocation cameraRotate, and cameraWait
    int nMinFrames;
    int nMaxFrames;
    int nBatch;
    int nPreFetch;
} CAMERA_MOVEMENT;


CCameraMove::CCameraMove()
{
    m_hdpaMovements = DPA_Create(4);
    m_fTimeInPreviousMovements = NULL;
    m_vLookAtLast = m_vUpVec = m_vLocLast = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    m_nCurrent = 0;
    m_fTimeInPreviousMovements = 0.0f;
    m_nFramesFromCurrent = 1;

    m_fTimeToLookAtPainting = 1.0f;
    DWORD dwSpeedSlider = DEFAULT_SPEEDSLIDER;
    if (g_pConfig)
    {
        m_fTimeToLookAtPainting = (float) g_pConfig->GetDWORDSetting(CONFIG_DWORD_VIEWPAINTINGTIME);
        dwSpeedSlider = g_pConfig->GetDWORDSetting(CONFIG_DWORD_SPEED_SLIDER);
    }

    m_fTimeToRotate = s_SpeedSettings[dwSpeedSlider].fTimeToRotate;
    m_nMinTurnFrames = s_SpeedSettings[dwSpeedSlider].nMinTurnFrames;
    m_nMaxTurnFrames = s_SpeedSettings[dwSpeedSlider].nMaxTurnFrames;

    m_fTimeToWalk = s_SpeedSettings[dwSpeedSlider].fTimeToWalk;
    m_nMinWalkFrames = s_SpeedSettings[dwSpeedSlider].nMinWalkFrames;
    m_nMaxWalkFrames = s_SpeedSettings[dwSpeedSlider].nMaxWalkFrames;
}


CCameraMove::~CCameraMove()
{
    DeleteAllMovements(0.0f);
}




HRESULT CCameraMove::Init(D3DXVECTOR3 vStartLoc, D3DXVECTOR3 vStartTangent, D3DXVECTOR3 vUpVec)
{
    HRESULT hr = S_OK;

    // Initialize member variables
    m_vUpVec = vUpVec;
    m_vLocLast = vStartLoc;
    m_vLookAtLast = vStartTangent;

    m_nFramesFromCurrent = 0;

    return hr;
}


HRESULT CCameraMove::CreateNextMove(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestLoc, D3DXVECTOR3 vDestTangent)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            D3DXVECTOR3 vDelta = (vSourceLoc - vDestLoc);
            float fLen = D3DXVec3Length(&vDelta);        // How far are we traveling
            float fRatio = (fLen / 50.0f);              // The speed values are stored per 50.0f distance

            pNew->type = cameraMoveLocation;
            pNew->vSourceLoc = vSourceLoc;
            pNew->vSourceTangent = vSourceTangent;
            pNew->vDestLoc = vDestLoc;
            pNew->vDestTangent = vDestTangent;
            pNew->fTime = (m_fTimeToWalk * fRatio);
            pNew->nMinFrames = (int) max((m_nMinWalkFrames * fRatio), 1);
            pNew->nMaxFrames = (int) max((m_nMaxWalkFrames * fRatio), 1);
            pNew->nBatch = 0;
            pNew->nPreFetch = 0;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::CreateNextRotate(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestTangent)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            float fDotProduct = D3DXVec3Dot(&vSourceTangent, &vDestTangent);
            float fRatio;

            if (fDotProduct)
            {
                float fRads = (float)acos(fDotProduct / max(1, (D3DXVec3Length(&vSourceTangent) * D3DXVec3Length(&vDestTangent))));        // How far are we traveling
                fRatio = (D3DXToDegree(fRads) / 90.0f);              // The speed values are stored per 90.0f distance
            }
            else
            {
                // Assume a dot product of 0 means 90 degrees.
                fRatio = 1.0f;              // The speed values are stored per 90.0f distance
            }

            pNew->type = cameraRotate;
            pNew->vSourceLoc = vSourceLoc;
            pNew->vSourceTangent = vSourceTangent;
            pNew->vDestLoc = vSourceLoc;
            pNew->vDestTangent = vDestTangent;
            pNew->fTime = (m_fTimeToRotate * fRatio);
            pNew->nMinFrames = (int) max((m_nMinTurnFrames * fRatio), 1);
            pNew->nMaxFrames = (int) max((m_nMaxTurnFrames * fRatio), 1);
            pNew->nBatch = 0;
            pNew->nPreFetch = 0;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::CreateNextWait(int nBatch, int nPreFetch, float fTime)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (-1.0f == fTime)
    {
        fTime = m_fTimeToLookAtPainting;
    }

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            pNew->type = cameraWait;
            pNew->vSourceLoc = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vSourceTangent = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vDestTangent = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->fTime = fTime;
            pNew->nMinFrames = 1;
            pNew->nMaxFrames = 1000000;
            pNew->nBatch = nBatch;
            pNew->nPreFetch = nPreFetch;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::SetCamera(IDirect3DDevice8 * pD3DDevice, FLOAT fTimeKeyIn)
{
    HRESULT hr = E_INVALIDARG;

    if (pD3DDevice && m_hdpaMovements)
    {
        float fTimeInSegment = 0.0f;
        CAMERA_MOVEMENT * pCurrent = NULL;

        if (0 > m_nCurrent)
        {
            m_nCurrent = 0;
        }

        if (m_nCurrent >= DPA_GetPtrCount(m_hdpaMovements))
        {
            hr = S_FALSE;   // This means we left the room.
        }
        else
        {
            do
            {
                pCurrent = (CAMERA_MOVEMENT *) DPA_GetPtr(m_hdpaMovements, m_nCurrent);

                if (!pCurrent)
                {
    //                ASSERT(FAILED(hr));
                    break;
                }
                else
                {
                    float fTimePerFrameMin = (pCurrent->fTime / pCurrent->nMinFrames);

                    fTimeInSegment = (fTimeKeyIn - m_fTimeInPreviousMovements);

                    if (fTimeInSegment < 0)
                    {
                        fTimeInSegment = 0;
                    }

                    // Do we need to warp time in order to have enough frames for the motion so we don't
                    // jump?
                    if ((fTimeInSegment > (fTimePerFrameMin * m_nFramesFromCurrent)) &&
                        (m_nFramesFromCurrent <= pCurrent->nMinFrames))
                    {
                        // Yes.
                        float fTimeWarp = (fTimeInSegment - (fTimePerFrameMin * m_nFramesFromCurrent));

                        m_fTimeInPreviousMovements += fTimeWarp;
                        fTimeInSegment = (fTimeKeyIn - m_fTimeInPreviousMovements);
                    }

                    if (fTimeInSegment > pCurrent->fTime)
                    {
                        m_fTimeInPreviousMovements += pCurrent->fTime;

                        if (cameraRotate == pCurrent->type)
                        {
                            m_vLocLast = pCurrent->vSourceLoc;
                            m_vLookAtLast = pCurrent->vDestTangent;
                        }
                        else if (cameraMoveLocation == pCurrent->type)
                        {
                            m_vLocLast = pCurrent->vDestLoc;
                            m_vLookAtLast = pCurrent->vDestTangent;
                        }

                        m_nFramesFromCurrent = 0;
                        m_nCurrent++;
                    }
                    else
                    {
                        m_nFramesFromCurrent++;
                        hr = S_OK;
                        break;
                    }
                }
            }
            while (1);
        }

        if (S_OK == hr) // S_FALSE means we left the room, so do nothing.
        {
            D3DXVECTOR3 vEye = m_vLocLast;
            D3DXVECTOR3 vLookAt = (m_vLocLast + m_vLookAtLast);
            float fTimeRatio = (fTimeInSegment / pCurrent->fTime);
            float fTimeRemainingInSeg = 0.0f;

            switch (pCurrent->type)
            {
            case cameraMoveLocation:
                D3DXVec3Lerp(&vEye, &pCurrent->vSourceLoc, &pCurrent->vDestLoc, fTimeRatio);
                D3DXVec3Lerp(&vLookAt, &pCurrent->vSourceTangent, &pCurrent->vDestTangent, fTimeRatio);

                vLookAt += vEye;
                break;
            case cameraRotate:
                // TODO: Use D3DXVec3Lerp() instead.
                D3DXVec3Lerp(&vLookAt, &pCurrent->vSourceTangent, &pCurrent->vDestTangent, fTimeRatio);
                vLookAt += vEye;
//                vLookAt = (vEye + (pCurrent->vSourceTangent + (fTimeRatio * (pCurrent->vDestTangent - pCurrent->vSourceTangent))));
                // How do we rotate?  Quaternion.
                break;
            case cameraWait:
                if (m_nFramesFromCurrent > 1)
                {
                    if ((2 == m_nFramesFromCurrent) && g_pPictureMgr)
                    {
                        DWORD dwMaxPixelSize = ((3 * g_dwHeight) / 4);

                        // Let's take the hit now of converting an image into a texture object since we don't have
                        // any work to do while looking at this painting.  This can normally take 1.5 seconds, so
                        // it's big perf hit to do it any other time.
                        hr = g_pPictureMgr->PreFetch(pCurrent->nBatch, pCurrent->nPreFetch);
                    }
                    else
                    {
                        // We don't have any work remaining to do, so sleep so the computer can get some work
                        // done.  (Like in background services or let it do any paging that we may have caused)
                        fTimeRemainingInSeg = (pCurrent->fTime - fTimeInSegment);
                        int nSleepTime = 1000 * (int) fTimeRemainingInSeg;

                        Sleep(nSleepTime);
                    }
                }
                break;
            default:
                // Do nothing.
                break;
            };


            D3DXMATRIX matView;
            D3DXMATRIX matIdentity;

            D3DXMatrixIdentity(&matIdentity);
            if (g_fOverheadViewTest)
            {
                static float s_fHeight = 600.0f;
                D3DXVECTOR3 vDelta = (vEye - vLookAt);

                vEye += D3DXVECTOR3(0.0f, s_fHeight, 0.0f);
                vEye += (4 * vDelta);
                D3DXMatrixLookAtLH(&matView, &vEye, &vLookAt, &m_vUpVec);
            }
            else
            {
                D3DXMatrixLookAtLH(&matView, &vEye, &vLookAt, &m_vUpVec);
            }

//            PrintLocation(TEXT("Camera angle at: %s and looking at: %s"), vEye, vLookAt);
            hr = pD3DDevice->SetTransform(D3DTS_VIEW, &matView);

            m_vEyePrev = vEye;
            m_vLookAtPrev = vLookAt;
        }
        else
        {
            D3DXMATRIX matView;

            D3DXMatrixLookAtLH(&matView, &m_vEyePrev, &m_vLookAtPrev, &m_vUpVec);
//            PrintLocation(TEXT("xxxxxx Camera angle at: %s and looking at: %s"), m_vEyePrev, m_vLookAtPrev);
            pD3DDevice->SetTransform(D3DTS_VIEW, &matView);
        }
    }
    else
    {
        DXUtil_Trace(TEXT("ERROR: pD3DDevice or m_hdpaMovements is NULL"));
    }

    return hr;
}




HRESULT CCameraMove::DeleteAllMovements(float fCurrentTime)
{
    HRESULT hr = S_OK;

    if (m_hdpaMovements)
    {
        DPA_DestroyCallback(m_hdpaMovements, DPALocalFree_Callback, NULL);
        m_hdpaMovements = DPA_Create(4);
    }

    m_fTimeInPreviousMovements = fCurrentTime;
    m_nCurrent = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\config.cpp ===
/*****************************************************************************\
    FILE: config.cpp

    DESCRIPTION:
        The class will handle the user's configuration state.  It will also
    display the Screen Saver's configuration dialog to allow the user to change
    these settings.

    BryanSt 12/18/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "config.h"
#include "resource.h"


#define SZ_REGKEY_THISSCREENSAVER       TEXT("Software\\Microsoft\\Screensavers\\Museum")
#define SZ_REGKEY_THISSS_CONFIG         SZ_REGKEY_THISSCREENSAVER TEXT("\\Config")

#define SZ_REGVALUE_QUALITYSLIDER       TEXT("Quality Slider")
#define SZ_REGVALUE_SPEEDSLIDER         TEXT("Speed Slider")
#define SZ_REGVALUE_TEMPMB              TEXT("Temp Disk Space")
#define SZ_REGVALUE_WALKSPEED           TEXT("Walk Speed")
#define SZ_REGVALUE_OTHERPICTURES       TEXT("Other Pictures Directory")
#define SZ_REGVALUE_VIEWTIME            TEXT("View Painting Time")

SPEED_SETTING s_SpeedSettings[MAX_SPEED] =
{
    {15.0f, 15.0f, 60.0f, 15, 15, 50, 50},
    {11.0f, 11.0f, 25.0f, 12, 12, 35, 35},
    {10.0f, 10.0f, 15.0f, 10, 10, 35, 35},
    {7.0f, 7.0f, 12.0f, 9, 9, 25, 25},
    {4.0f, 4.0f, 10.0f, 8, 8, 25, 25},
    {4.0f, 4.0f, 7.0f, 7, 7, 25, 25},
    {2.5f, 2.5f, 5.0f, 6, 6, 21, 21},
    {2.0f, 2.0f, 2.50f, 5, 5, 17, 17},
    {2.00f, 2.0f, 1.5f, 10, 10, 15, 15},
    {0.50f, 0.5f, 0.5f, 7, 7, 15, 15},
    {0.50f, 0.5f, 0.5f, 5, 5, 15, 15},
//    {5.00f, 10.0f, 0.50f, 5, 5, 15, 15},
};


static QUALITY_SETTING s_QualitySettings[NUM_BOOL_SETTINGS] = 
{
    {TEXT("Show Stats")},                 // IDC_CHECK_SHOWSTATS
};


// Values we can add: Lighing, Vectors on floor, etc.
static BOOL s_fQualityValues[MAX_QUALITY][NUM_BOOL_SETTINGS] =
{   // ORDER: AntiAlias, Texture Perspective, Texture Dithering, Depth Buffering (Z), Specular Highlights, Anti-Alias Edges, Render Quality (Flat, Gouraud, Phong)
    {0},
    {0},
    {0},
    {0},
    {0},
    {0},
    {0},
    {0}
};

#define MINUTE          60

static int s_nViewTimeSettings[MAX_VIEWTIME] =
{ 1, 2, 3, 4, 5, 7, 10, 12, 15, 17,
  20, 25, 30, 35, 40, 45, 50, 55, MINUTE, MINUTE + 15, 
  MINUTE + 30, MINUTE + 45, 2 * MINUTE, 2 * MINUTE + 30, 3 * MINUTE, 4 * MINUTE, 5 * MINUTE, 7 * MINUTE, 10 * MINUTE, 20 * MINUTE};

static DWORD s_RenderQualitySliderValues[MAX_QUALITY] = 
{
    0, 1, 1, 1, 2, 2, 2, 2
};


static LPCTSTR s_pszDWORDSettingsArray[NUM_DWORD_SETTINGS] = 
{
    TEXT("RenderQuality"),              // IDC_RENDERQUALITY1
    TEXT("RealTimeMode"),               // Walking Speed                 
    TEXT("Quality Slider"),                      
    TEXT("Speed Slider"),                      
    TEXT("View Time Slider"),                      
};

static FOLDER_SETTING s_FolderSettings[NUM_BOOL_FOLDERS] = 
{
    {TEXT("My Pictures"), TRUE},                 // IDC_CHECK_MYPICTS
    {TEXT("Common Pictures"), FALSE},            // IDC_CHECK_COMMONPICTS
    {TEXT("Windows Pictures"), TRUE},            // IDC_CHECK_WINPICTS
    {TEXT("Other Pictures"), FALSE},             // IDC_CHECK_OTHERPICTS
};

static DWORD s_dwSettingsDefaults[NUM_DWORD_SETTINGS] = 
{
    DEFAULT_RENDERQUALITY,              // CONFIG_DWORD_RENDERQUALITY
    2,                                  // CONFIG_DWORD_REALTIMEMODE
    DEFAULT_QUALITYSLIDER,              // CONFIG_DWORD_QUALITY_SLIDER
    DEFAULT_SPEEDSLIDER,                // CONFIG_DWORD_SPEED_SLIDER
    DEFAULT_VIEWTIMESLIDER,             // CONFIG_DWORD_VIEWPAINTINGTIME
};

CConfig * g_pConfig = NULL;                         // The configuration settings the user wants to use.



CConfig::CConfig(CMSLogoDXScreenSaver * pMain)
{
    m_hkeyCurrentUser = NULL;
    m_fLoaded = FALSE;
    m_hDlg = NULL;
    m_szOther[0] = 0;

    m_pMain = pMain;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        m_pszCustomPaths[nIndex] = NULL;
        m_dwCustomScale[nIndex] = 100;          // Default to 100%
    }
}


CConfig::~CConfig()
{
    if (m_hkeyCurrentUser)
    {
        RegCloseKey(m_hkeyCurrentUser);
        m_hkeyCurrentUser = NULL;
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
    }
}


HRESULT CConfig::_GetStateFromUI(void)
{
    int nIndex;

    // Get Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
    {
        m_fFolders[nIndex] = GetCheckBox(m_hDlg, IDC_CHECK_MYPICTS + nIndex);
    }

    // Set Other Path
    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));

    // Get Sliders
    m_dwSettings[CONFIG_DWORD_SPEED_SLIDER] = (DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED));
    m_dwSettings[CONFIG_DWORD_QUALITY_SLIDER] = (DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY));
    m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME] = s_nViewTimeSettings[(DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME))];
  
    // Get Walk Speed ComboBox
    m_dwSettings[CONFIG_DWORD_REALTIMEMODE] = 0;

    return S_OK;
}


HRESULT CConfig::_LoadQualitySliderValues(void)
{
    int nNewPos = TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY));

    if ((nNewPos < 0) || (nNewPos >= MAX_QUALITY))
    {
        nNewPos = DEFAULT_QUALITYSLIDER;    // The value was invalid so revert to a valid value.
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
    {
        m_fSettings[nIndex] = s_fQualityValues[nNewPos][nIndex];
    }

    m_dwSettings[CONFIG_DWORD_RENDERQUALITY] = s_RenderQualitySliderValues[nNewPos];

    return S_OK;
}


HRESULT CConfig::_UpdateViewTimeSelection(void)
{
    int nNewPos = TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME));
    TCHAR szDesc[MAX_PATH];

    if ((nNewPos < 0) || (nNewPos >= MAX_VIEWTIME))
    {
        nNewPos = DEFAULT_VIEWTIMESLIDER;    // The value was invalid so revert to a valid value.
    }

    LoadString(HINST_THISDLL, IDS_VIEW_TIME_DESC + nNewPos, szDesc, ARRAYSIZE(szDesc));
    SetWindowText(GetDlgItem(m_hDlg, IDC_STATIC_VIEWTIME), szDesc);

    return S_OK;
}


int CALLBACK BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    int nResult = 0;

    switch (msg)
    {
    case BFFM_INITIALIZED:
        if (lpData)   // Documentation says it will be NULL but other code does this.
        {
            // we passed ppidl as lpData so pass on just pidl
            // Notice I pass BFFM_SETSELECTIONA which would normally indicate ANSI.
            // I do this because Win95 requires it, but it doesn't matter because I'm
            // only passing a pidl
            SendMessage(hwnd, BFFM_SETSELECTIONA, FALSE, (LPARAM)((LPITEMIDLIST)lpData));
        }
        break;
    }

    return nResult;
}


HRESULT CConfig::_OnBrowseForFolder(void)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlCurrent = NULL;
    BROWSEINFO bi = {0};
    TCHAR szTitle[MAX_PATH];

    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));
    LoadString(HINST_THISDLL, IDS_OTHERBROWSE_TITLE, szTitle, ARRAYSIZE(szTitle));

    hr = ShellFolderParsePath(m_szOther, &pidlCurrent);
    bi.hwndOwner = m_hDlg;
    bi.lpszTitle = szTitle;
    bi.lpfn = BrowseCallback;
    bi.lParam = (LPARAM) pidlCurrent;
    bi.ulFlags = (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_EDITBOX | BIF_USENEWUI | BIF_VALIDATE);

    LPITEMIDLIST pidlNew = SHBrowseForFolder(&bi);
    if (pidlNew)
    {
        hr = ShellFolderGetPath(pidlNew, m_szOther, ARRAYSIZE(m_szOther));
        if (SUCCEEDED(hr))
        {
            SetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther);
        }

        ILFree(pidlNew);
    }

    ILFree(pidlCurrent);

    return hr;
}


HRESULT CConfig::_OnInitDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
    {
        SetCheckBox(m_hDlg, IDC_CHECK_MYPICTS + nIndex, m_fFolders[nIndex]);
    }

    // Set Other Path
    SetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther);
    EnableWindow(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_fFolders[3]);
    EnableWindow(GetDlgItem(m_hDlg, IDC_BUTTON_BROWSEPICTS), m_fFolders[3]);

    // If we want to run on IE4, we need to delay load this.
    SHAutoComplete(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), SHACF_FILESYSTEM);

    // Set Sliders
    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED), TRUE, 0, MAX_SPEED-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED), TRUE, m_dwSettings[CONFIG_DWORD_SPEED_SLIDER]);

    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY), TRUE, 0, MAX_QUALITY-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY), TRUE, m_dwSettings[CONFIG_DWORD_QUALITY_SLIDER]);

    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME), TRUE, 0, MAX_VIEWTIME-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME), TRUE, m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME]);

    _UpdateViewTimeSelection();

    return S_OK;
}


HRESULT CConfig::_OnDestroy(HWND hDlg)
{
    return S_OK;
}


BOOL CConfig::_IsDialogDataValid(void)
{
    BOOL fValid = TRUE;

    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));
    if (m_fFolders[CONFIG_FOLDER_OTHER])
    {
        if (!PathFileExists(m_szOther))
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_ERROR_INVALIDOTHERPATH, szMessage, ARRAYSIZE(szMessage));
            LoadString(HINST_THISDLL, IDS_ERROR_TITLE_OTHERPATH, szTitle, ARRAYSIZE(szTitle));
            MessageBox(m_hDlg, szMessage, szTitle, MB_OK);
            fValid = FALSE;
        }
        else if (!PathIsDirectory(m_szOther))
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_ERROR_OTHERPATH_NOTDIR, szMessage, ARRAYSIZE(szMessage));
            LoadString(HINST_THISDLL, IDS_ERROR_TITLE_OTHERPATH, szTitle, ARRAYSIZE(szTitle));
            MessageBox(m_hDlg, szMessage, szTitle, MB_OK);
            fValid = FALSE;
        }
    }

    return fValid;
}


HRESULT CConfig::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        if (_IsDialogDataValid())
        {
            _GetStateFromUI();
            EndDialog(hDlg, IDOK);
        }
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_CHECK_OTHERPICTS:
        if ((BN_CLICKED == wEvent) && (IDC_CHECK_OTHERPICTS == idCtrl))
        {
            m_fFolders[3] = GetCheckBox(m_hDlg, IDC_CHECK_OTHERPICTS);

            EnableWindow(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_fFolders[3]);
            EnableWindow(GetDlgItem(m_hDlg, IDC_BUTTON_BROWSEPICTS), m_fFolders[3]);
        }
        break;


    case IDC_BUTTON_ADVANCEDQUALITY:
        DisplayAdvancedDialog(m_hDlg);
        break;

    case IDC_BUTTON_BROWSEPICTS:
        _OnBrowseForFolder();
        break;

    case IDC_BUTTON_MONITORSETTINGS:
        if (m_pMain)
        {
            m_pMain->DisplayMonitorSettings(hDlg);
        }
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK CConfig::ConfigDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pThis = (CConfig *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CConfig *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
    {
        return pThis->_ConfigDlgProc(hDlg, wMsg, wParam, lParam);
    }

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CConfig::_ConfigDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnInitDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_HELP:
        // TODO: Get help strings
//        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_HSCROLL:
    case WM_VSCROLL:
        if (GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME) == (HWND) lParam)
        {
            _UpdateViewTimeSelection();
        }
        else if (GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY) == (HWND) lParam)
        {
            _LoadQualitySliderValues();
        }
        break;
    }

    return FALSE;
}


HRESULT CConfig::_LoadState(void)
{
    HRESULT hr = S_OK;

    if (!m_fLoaded)
    {
        if (!m_hkeyCurrentUser)
        {
            hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_THISSS_CONFIG, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &m_hkeyCurrentUser, NULL);
        }

        if (m_hkeyCurrentUser)
        {
            int nIndex;

            for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_QualitySettings[nIndex].pszRegValue, (DWORD *)&m_fSettings[nIndex], s_fQualityValues[DEFAULT_QUALITYSLIDER][nIndex]);
            }

            for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_pszDWORDSettingsArray[nIndex], &m_dwSettings[nIndex], s_dwSettingsDefaults[nIndex]);
            }

            // For the view time, we persist the number of seconds, not the slot number.
            // Let's find the slot number from the view time in seconds..
            for (nIndex = 0; nIndex < ARRAYSIZE(s_nViewTimeSettings); nIndex++)
            {
                if ((DWORD)s_nViewTimeSettings[nIndex] == m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME])
                {
                    m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME] = nIndex;
                    break;
                }
            }

            for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_FolderSettings[nIndex].pszRegValue, (DWORD *)&m_fFolders[nIndex], s_FolderSettings[nIndex].fDefaultToOn);    // Only default to on for IDC_CHECK_WINPICTS
            }

            if (FAILED(HrRegGetValueString(m_hkeyCurrentUser, NULL, SZ_REGVALUE_OTHERPICTURES, m_szOther, ARRAYSIZE(m_szOther))))
            {
                StrCpyN(m_szOther, TEXT("C:\\"), ARRAYSIZE(m_szOther));
            }

            // Load any customized textures
            for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
            {
                TCHAR szRegValue[MAX_PATH];
                TCHAR szRegString[MAX_PATH];

                wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d"), nIndex);
                szRegString[0] = 0; // in case the regkey doesn't exist yet.

                HrRegGetValueString(m_hkeyCurrentUser, NULL, szRegValue, szRegString, ARRAYSIZE(szRegString));
                if (szRegString[0])
                {
                    Str_SetPtr(&(m_pszCustomPaths[nIndex]), szRegString);
                }
                else
                {
                    Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
                }

                wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d Scale"), nIndex);
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, szRegValue, (DWORD *)&m_dwCustomScale[nIndex], 100);
            }

            m_pMain->ReadScreenSettingsPublic( m_hkeyCurrentUser );
        }
        m_fLoaded = TRUE;
    }

    return hr;
}


HRESULT CConfig::_SaveState(void)
{
    HRESULT hr = E_FAIL;

    if (m_hkeyCurrentUser)
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_QualitySettings[nIndex].pszRegValue, m_fSettings[nIndex]);
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_pszDWORDSettingsArray[nIndex], m_dwSettings[nIndex]);
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_FolderSettings[nIndex].pszRegValue, m_fFolders[nIndex]);    // Only default to on for IDC_CHECK_WINPICTS
        }

        hr = HrRegSetValueString(m_hkeyCurrentUser, NULL, SZ_REGVALUE_OTHERPICTURES, m_szOther);

        // Load any customized textures
        for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
        {
            TCHAR szRegValue[MAX_PATH];

            wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d"), nIndex);
            HrRegSetValueString(m_hkeyCurrentUser, NULL, szRegValue, (m_pszCustomPaths[nIndex] ? m_pszCustomPaths[nIndex] : TEXT("")));

            wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d Scale"), nIndex);
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, szRegValue, m_dwCustomScale[nIndex]);
        }

        m_pMain->WriteScreenSettingsPublic( m_hkeyCurrentUser );
    }

    return hr;
}


HRESULT CConfig::GetOtherDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        StrCpyN(pszPath, m_szOther, cchSize);
    }

    return hr;
}


HRESULT CConfig::GetTexturePath(int nTextureIndex, DWORD * pdwScale, LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        if ((nTextureIndex >= 0) && (nTextureIndex < ARRAYSIZE(m_pszCustomPaths)) &&
            m_pszCustomPaths[nTextureIndex] && m_pszCustomPaths[nTextureIndex][0])
        {
            // We have a custom texture to use.
            StrCpyN(pszPath, m_pszCustomPaths[nTextureIndex], cchSize);
            *pdwScale = m_dwCustomScale[nTextureIndex];
            hr = S_OK;
        }
    }

    return hr;
}


BOOL CConfig::GetFolderOn(UINT nSetting)
{
    HRESULT hr = _LoadState();
    BOOL fReturn = FALSE;

    if (SUCCEEDED(hr) && (nSetting < ARRAYSIZE(m_fFolders)))
    {
        fReturn = m_fFolders[nSetting];
    }

    return fReturn;
}


BOOL CConfig::GetBoolSetting(UINT nSetting)
{
    HRESULT hr = _LoadState();
    BOOL fReturn = FALSE;

    if (SUCCEEDED(hr) && (IDC_CHECK_SHOWSTATS <= nSetting))
    {
        nSetting -= IDC_CHECK_SHOWSTATS;
        if (nSetting < ARRAYSIZE(m_fSettings))
        {
            fReturn = m_fSettings[nSetting];
        }
    }

    return fReturn;
}


DWORD CConfig::GetDWORDSetting(UINT nSetting)
{
    HRESULT hr = _LoadState();
    DWORD dwReturn = 0;

    if (SUCCEEDED(hr) && (nSetting < ARRAYSIZE(m_dwSettings)))
    {
        dwReturn = m_dwSettings[nSetting];
    }

    return dwReturn;
}


HRESULT CConfig::DisplayConfigDialog(HWND hwndParent)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DIALOG_CONFIG), hwndParent, CConfig::ConfigDlgProc, (LPARAM)this))
        {
            hr = _SaveState();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}




HRESULT CConfig::DisplayAdvancedDialog(HWND hwndParent)
{
    HRESULT hr = S_OK;
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
    {
        m_fAdvSettings[nIndex] = m_fSettings[nIndex];
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
    {
        m_dwAdvSettings[nIndex] = m_dwSettings[nIndex];
    }

    // Display Advanced Dialog
    if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DIALOG_ADVANCED), hwndParent, CConfig::AdvDlgProc, (LPARAM)this))
    {
        for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
        {
            m_fSettings[nIndex] = m_fAdvSettings[nIndex];
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
        {
            m_dwSettings[nIndex] = m_dwAdvSettings[nIndex];
        }

        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    return hr;
}


HRESULT CConfig::_OnEnableCustomTexture(int nIndex, BOOL fEnable)
{
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC1_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC2_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC3_TEXTR_FLOOR + nIndex)), fEnable);

    return S_OK;
}


HRESULT CConfig::_OnAdvInitDlg(HWND hDlg)
{
    m_hDlgAdvanced = hDlg;
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fAdvSettings); nIndex++)
    {
        SetCheckBox(m_hDlgAdvanced, IDC_CHECK_SHOWSTATS+nIndex, m_fAdvSettings[nIndex]);
    }

    // Copy the customized textures.
    for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        TCHAR szPath[MAX_PATH];

        SHAutoComplete(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), SHACF_FILESYSTEM);

        wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("%d"), m_dwCustomScale[nIndex]);
        SetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), szPath);

        if (m_pszCustomPaths[nIndex] && m_pszCustomPaths[nIndex][0])
        {
            CheckDlgButton(m_hDlgAdvanced, (IDC_CHECK_TEXTR_FLOOR + nIndex), BST_CHECKED);
            SetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), m_pszCustomPaths[nIndex]);
        }
        else
        {
            _OnEnableCustomTexture(nIndex, FALSE);
        }
    }

    CheckDlgButton(m_hDlgAdvanced, IDC_RENDERQUALITY1+m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY], BST_CHECKED);
    return S_OK;
}


HRESULT CConfig::_GetAdvState(void)
{
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fAdvSettings); nIndex++)
    {
        m_fAdvSettings[nIndex] = GetCheckBox(m_hDlgAdvanced, IDC_CHECK_SHOWSTATS+nIndex);
    }

    // Copy the customized textures.
    for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        if (IsDlgButtonChecked(m_hDlgAdvanced, (IDC_CHECK_TEXTR_FLOOR + nIndex)))
        {
            TCHAR szPath[MAX_PATH];

            GetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), szPath, ARRAYSIZE(szPath));
            Str_SetPtr(&(m_pszCustomPaths[nIndex]), szPath);

            GetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), szPath, ARRAYSIZE(szPath));
            m_dwCustomScale[nIndex] = (DWORD) StrToInt(szPath);
        }
        else
        {
            Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
        }
    }

    if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY1))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 0;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY2))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 1;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY3))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 2;
    }

    return S_OK;
}


HRESULT CConfig::_OnAdvDestroy(HWND hDlg)
{
    return S_OK;
}


HRESULT CConfig::_OnAdvCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        _GetAdvState();
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_CHECK_TEXTR_FLOOR:
        _OnEnableCustomTexture(0, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_FLOOR));
        break;

    case IDC_CHECK_TEXTR_WALLPAPER:
        _OnEnableCustomTexture(1, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_WALLPAPER));
        break;

    case IDC_CHECK_TEXTR_CEILING:
        _OnEnableCustomTexture(2, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_CEILING));
        break;

    case IDC_CHECK_TEXTR_TOEGUARD:
        _OnEnableCustomTexture(3, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_TOEGUARD));
        break;

    case IDC_CHECK_TEXTR_RUG:
        _OnEnableCustomTexture(4, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_RUG));
        break;

    case IDC_CHECK_TEXTR_FRAME:
        _OnEnableCustomTexture(5, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_FRAME));
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK CConfig::AdvDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pThis = (CConfig *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CConfig *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
    {
        return pThis->_AdvDlgProc(hDlg, wMsg, wParam, lParam);
    }

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CConfig::_AdvDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnAdvInitDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnAdvDestroy(hDlg);
        break;

    case WM_HELP:
        // TODO: Get help strings
//        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnAdvCommand(hDlg, message, wParam, lParam);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\config.h ===
/*****************************************************************************\
    FILE: config.h

    DESCRIPTION:
        The class will handle the user's configuration state.  It will also
    display the Screen Saver's configuration dialog to allow the user to change
    these settings.

    BryanSt 12/18/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef CONFIG_H
#define CONFIG_H

class CConfig;

#include "util.h"
#include "main.h"
#include "resource.h"

#define NUM_BOOL_SETTINGS           1
#define NUM_DWORD_SETTINGS          5
#define NUM_BOOL_FOLDERS            4

#define MAX_QUALITY                 8
#define MAX_WALK                    6
#define MAX_VIEWTIME                30

// Args for CConfig::GetFolderOn()
#define CONFIG_FOLDER_MYPICTS       0
#define CONFIG_FOLDER_COMMONPICTS   1
#define CONFIG_FOLDER_WINPICTS      2
#define CONFIG_FOLDER_OTHER         3

// Args for CConfig::GetDWORDSetting()
#define CONFIG_DWORD_RENDERQUALITY  0
#define CONFIG_DWORD_REALTIMEMODE   1
#define CONFIG_DWORD_QUALITY_SLIDER 2
#define CONFIG_DWORD_SPEED_SLIDER   3
#define CONFIG_DWORD_VIEWPAINTINGTIME 4

#define DEFAULT_QUALITYSLIDER           2
#define DEFAULT_VIEWTIMESLIDER          7
#define DEFAULT_SPEEDSLIDER             2
#define DEFAULT_WALKSPEED               2
#define DEFAULT_RENDERQUALITY           1


typedef struct
{
    LPCTSTR pszRegValue;
} QUALITY_SETTING;

typedef struct
{
    LPCTSTR pszRegValue;
    BOOL fDefaultToOn;
} FOLDER_SETTING;


extern CConfig * g_pConfig;                         // The configuration settings the user wants to use.
extern QUALITY_SETTING s_QualitySettings[NUM_BOOL_SETTINGS];




class CConfig
{
public:
    // Member Functions
    virtual BOOL GetBoolSetting(UINT nSetting);
    virtual DWORD GetDWORDSetting(UINT nSetting);
    virtual BOOL GetFolderOn(UINT nSetting);
    virtual HRESULT GetOtherDir(LPTSTR pszPath, DWORD cchSize);
    virtual HRESULT GetTexturePath(int nTextureIndex, DWORD * pdwScale, LPTSTR pszPath, DWORD cchSize);

    virtual HRESULT DisplayConfigDialog(HWND hwndParent);

    HRESULT LoadStatePublic(void) { return _LoadState(); }

    CConfig(CMSLogoDXScreenSaver * pMain);
    ~CConfig();

private:
    // Helper Functions
    HRESULT _LoadState(void);
    HRESULT _SaveState(void);
    HRESULT _GetState(void);

    HRESULT _UpdateViewTimeSelection(void);
    HRESULT _OnBrowseForFolder(void);
    HRESULT _GetStateFromUI(void);
    HRESULT _LoadQualitySliderValues(void);
    BOOL _IsDialogDataValid(void);

    HRESULT _OnInitDlg(HWND hDlg);
    HRESULT _OnDestroy(HWND hDlg);
    HRESULT _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    INT_PTR _ConfigDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    // Advanced Dialog
    HRESULT DisplayAdvancedDialog(HWND hwndParent);
    INT_PTR _AdvDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnAdvInitDlg(HWND hDlg);
    HRESULT _OnAdvDestroy(HWND hDlg);
    HRESULT _OnAdvCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _GetAdvState(void);

    HRESULT _OnEnableCustomTexture(int nIndex, BOOL fEnable);


    static INT_PTR CALLBACK AdvDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ConfigDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

    // Member Variables
    HKEY m_hkeyCurrentUser;         // Cached Key
    BOOL m_fSettings[NUM_BOOL_SETTINGS];
    DWORD m_dwSettings[NUM_DWORD_SETTINGS];
    BOOL m_fFolders[NUM_BOOL_FOLDERS];
    TCHAR m_szOther[MAX_PATH];
    BOOL m_fLoaded;
    HWND m_hDlg;
    HWND m_hDlgAdvanced;
    LPWSTR m_pszCustomPaths[MAX_CUSTOMTEXTURES];
    DWORD m_dwCustomScale[MAX_CUSTOMTEXTURES];

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    // Advanced Dialog
    BOOL m_fAdvSettings[NUM_BOOL_SETTINGS];
    DWORD m_dwAdvSettings[NUM_DWORD_SETTINGS];
};



#endif // CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\d3dfont.h ===
//-----------------------------------------------------------------------------
// File: D3DFont.h
//
// Desc: Texture-based font class
//
//@@BEGIN_MSINTERNAL
//
// Hist: 06.01.00 - mwetzel - Last modified
//
//@@END_MSINTERNAL
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DFONT_H
#define D3DFONT_H
#include <tchar.h>
#include <D3D8.h>


// Font creation flags
#define D3DFONT_BOLD        0x0001
#define D3DFONT_ITALIC      0x0002

// Font rendering flags
#define D3DFONT_CENTERED    0x0001
#define D3DFONT_TWOSIDED    0x0002
#define D3DFONT_FILTERED    0x0004




//-----------------------------------------------------------------------------
// Name: class CD3DFont
// Desc: Texture-based font class for doing text in a 3D scene.
//-----------------------------------------------------------------------------
class CD3DFont
{
    TCHAR   m_strFontName[80];            // Font properties
    DWORD   m_dwFontHeight;
    DWORD   m_dwFontFlags;

    LPDIRECT3DDEVICE8       m_pd3dDevice; // A D3DDevice used for rendering
    LPDIRECT3DTEXTURE8      m_pTexture;   // The d3d texture for this font
    LPDIRECT3DVERTEXBUFFER8 m_pVB;        // VertexBuffer for rendering text
    DWORD   m_dwTexWidth;                 // Texture dimensions
    DWORD   m_dwTexHeight;
    FLOAT   m_fTextScale;
    FLOAT   m_fTexCoords[128-32][4];

    // Stateblocks for setting and restoring render states
    DWORD   m_dwSavedStateBlock;
    DWORD   m_dwDrawTextStateBlock;

public:
    // 2D and 3D text drawing functions
    HRESULT DrawText( FLOAT x, FLOAT y, DWORD dwColor, 
                      TCHAR* strText, DWORD dwFlags=0L );
    HRESULT DrawTextScaled( FLOAT x, FLOAT y, FLOAT z, 
                            FLOAT fXScale, FLOAT fYScale, DWORD dwColor, 
                            TCHAR* strText, DWORD dwFlags=0L );
    HRESULT Render3DText( TCHAR* strText, DWORD dwFlags=0L );
    
    // Function to get extent of text
    HRESULT GetTextExtent( TCHAR* strText, SIZE* pSize );

    // Initializing and destroying device-dependent objects
    HRESULT InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();

    // Constructor / destructor
    CD3DFont( TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L );
    ~CD3DFont();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\d3dfont.cpp ===
//-----------------------------------------------------------------------------
// File: D3DFont.cpp
//
// Desc: Texture-based font class
//
//@@BEGIN_MSINTERNAL
//
// Hist: 02.28.98 - mwetzel - Replacing the history
//       05.15.00 - mwetzel - Cleaning up the code
//       06.01.00 - mwetzel - Converted to use state blocks
//
//@@END_MSINTERNAL
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <stdio.h>
#include <tchar.h>
#include <D3DX8.h>
#include "D3DFont.h"
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Custom vertex types for rendering text
//-----------------------------------------------------------------------------
#define MAX_NUM_VERTICES 50*6

struct FONT2DVERTEX { D3DXVECTOR4 p;   DWORD color;     FLOAT tu, tv; };
struct FONT3DVERTEX { D3DXVECTOR3 p;   D3DXVECTOR3 n;   FLOAT tu, tv; };

#define D3DFVF_FONT2DVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define D3DFVF_FONT3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

inline FONT2DVERTEX InitFont2DVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                      FLOAT tu, FLOAT tv )
{
    FONT2DVERTEX v;   v.p = p;   v.color = color;   v.tu = tu;   v.tv = tv;
    return v;
}

inline FONT3DVERTEX InitFont3DVertex( const D3DXVECTOR3& p, const D3DXVECTOR3& n,
                                      FLOAT tu, FLOAT tv )
{
    FONT3DVERTEX v;   v.p = p;   v.n = n;   v.tu = tu;   v.tv = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CD3DFont()
// Desc: Font class constructor
//-----------------------------------------------------------------------------
CD3DFont::CD3DFont( TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags )
{
    _tcscpy( m_strFontName, strFontName );
    m_dwFontHeight         = dwHeight;
    m_dwFontFlags          = dwFlags;

    m_pd3dDevice           = NULL;
    m_pTexture             = NULL;
    m_pVB                  = NULL;

    m_dwSavedStateBlock    = 0L;
    m_dwDrawTextStateBlock = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFont()
// Desc: Font class destructor
//-----------------------------------------------------------------------------
CD3DFont::~CD3DFont()
{
    InvalidateDeviceObjects();
    DeleteDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initializes device-dependent objects, including the vertex buffer used
//       for rendering text and the texture map which stores the font image.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice )
{
    HRESULT hr;

    // Keep a local copy of the device
    m_pd3dDevice = pd3dDevice;

    // Establish the font and texture size
    m_fTextScale  = 1.0f; // Draw fonts into texture without scaling

    // Large fonts need larger textures
    if( m_dwFontHeight > 40 )
        m_dwTexWidth = m_dwTexHeight = 1024;
    else if( m_dwFontHeight > 20 )
        m_dwTexWidth = m_dwTexHeight = 512;
    else
        m_dwTexWidth  = m_dwTexHeight = 256;

    // If requested texture is too big, use a smaller texture and smaller font,
    // and scale up when rendering.
    D3DCAPS8 d3dCaps;
    m_pd3dDevice->GetDeviceCaps( &d3dCaps );

    if( m_dwTexWidth > d3dCaps.MaxTextureWidth )
    {
        m_fTextScale = (FLOAT)d3dCaps.MaxTextureWidth / (FLOAT)m_dwTexWidth;
        m_dwTexWidth = m_dwTexHeight = d3dCaps.MaxTextureWidth;
    }

    // Create a new texture for the font
    hr = m_pd3dDevice->CreateTexture( m_dwTexWidth, m_dwTexHeight, 1,
                                      0, D3DFMT_A4R4G4B4,
                                      D3DPOOL_MANAGED, &m_pTexture );
    if( FAILED(hr) )
        return hr;

    // Prepare to create a bitmap
    DWORD*      pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader,  sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)m_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)m_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a DC and a bitmap for the font
    HDC     hDC       = CreateCompatibleDC( NULL );
    HBITMAP hbmBitmap = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS,
                                          (VOID**)&pBitmapBits, NULL, 0 );
    SetMapMode( hDC, MM_TEXT );

    // Create a font.  By specifying ANTIALIASED_QUALITY, we might get an
    // antialiased font, but this is not guaranteed.
    INT nHeight    = -MulDiv( m_dwFontHeight, 
        (INT)(GetDeviceCaps(hDC, LOGPIXELSY) * m_fTextScale), 72 );
    DWORD dwBold   = (m_dwFontFlags&D3DFONT_BOLD)   ? FW_BOLD : FW_NORMAL;
    DWORD dwItalic = (m_dwFontFlags&D3DFONT_ITALIC) ? TRUE    : FALSE;
    HFONT hFont    = CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                          VARIABLE_PITCH, m_strFontName );
    if( NULL==hFont )
        return E_FAIL;

    SelectObject( hDC, hbmBitmap );
    SelectObject( hDC, hFont );

    // Set text properties
    SetTextColor( hDC, RGB(255,255,255) );
    SetBkColor(   hDC, 0x00000000 );
    SetTextAlign( hDC, TA_TOP );

    // Loop through all printable character and output them to the bitmap..
    // Meanwhile, keep track of the corresponding tex coords for each character.
    DWORD x = 0;
    DWORD y = 0;
    TCHAR str[2] = _T("x");
    SIZE size;

    for( TCHAR c=32; c<127; c++ )
    {
        str[0] = c;
        GetTextExtentPoint32( hDC, str, 1, &size );

        if( (DWORD)(x+size.cx+1) > m_dwTexWidth )
        {
            x  = 0;
            y += size.cy+1;
        }

        ExtTextOut( hDC, x+0, y+0, ETO_OPAQUE, NULL, str, 1, NULL );

        m_fTexCoords[c-32][0] = ((FLOAT)(x+0))/m_dwTexWidth;
        m_fTexCoords[c-32][1] = ((FLOAT)(y+0))/m_dwTexHeight;
        m_fTexCoords[c-32][2] = ((FLOAT)(x+0+size.cx))/m_dwTexWidth;
        m_fTexCoords[c-32][3] = ((FLOAT)(y+0+size.cy))/m_dwTexHeight;

        x += size.cx+1;
    }

    // Lock the surface and write the alpha values for the set pixels
    D3DLOCKED_RECT d3dlr;
    m_pTexture->LockRect( 0, &d3dlr, 0, 0 );
    WORD* pDst16 = (WORD*)d3dlr.pBits;
    BYTE bAlpha; // 4-bit measure of pixel intensity

    for( y=0; y < m_dwTexHeight; y++ )
    {
        for( x=0; x < m_dwTexWidth; x++ )
        {
            bAlpha = (BYTE)((pBitmapBits[m_dwTexWidth*y + x] & 0xff) >> 4);
            if (bAlpha > 0)
            {
                *pDst16++ = (bAlpha << 12) | 0x0fff;
            }
            else
            {
                *pDst16++ = 0x0000;
            }
        }
    }

    // Done updating texture, so clean up used objects
    m_pTexture->UnlockRect(0);
    DeleteObject( hbmBitmap );
    DeleteDC( hDC );
    DeleteObject( hFont );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CD3DFont::RestoreDeviceObjects()
{
    HRESULT hr;

    // Create vertex buffer for the letters
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( MAX_NUM_VERTICES*sizeof(FONT2DVERTEX),
                                                       D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0,
                                                       D3DPOOL_DEFAULT, &m_pVB ) ) )
    {
        return hr;
    }

    // Create the state blocks for rendering text
    for( UINT which=0; which<2; which++ )
    {
        m_pd3dDevice->BeginStateBlock();
        m_pd3dDevice->SetTexture( 0, m_pTexture );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,  D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,   D3DFILL_SOLID );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_CCW );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPING,         TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPLANEENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_VERTEXBLEND,      FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

        if( which==0 )
            m_pd3dDevice->EndStateBlock( &m_dwSavedStateBlock );
        else
            m_pd3dDevice->EndStateBlock( &m_dwDrawTextStateBlock );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pVB );

    // Delete the state blocks
    if( m_pd3dDevice )
    {
        if( m_dwSavedStateBlock )
            m_pd3dDevice->DeleteStateBlock( m_dwSavedStateBlock );
        if( m_dwDrawTextStateBlock )
            m_pd3dDevice->DeleteStateBlock( m_dwDrawTextStateBlock );
    }

    m_dwSavedStateBlock    = 0L;
    m_dwDrawTextStateBlock = 0L;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DeleteDeviceObjects()
{
    SAFE_RELEASE( m_pTexture );
    m_pd3dDevice = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CD3DFont::GetTextExtent( TCHAR* strText, SIZE* pSize )
{
    if( NULL==strText || NULL==pSize )
        return E_FAIL;

    FLOAT fRowWidth  = 0.0f;
    FLOAT fRowHeight = (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
    FLOAT fWidth     = 0.0f;
    FLOAT fHeight    = fRowHeight;

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            fRowWidth = 0.0f;
            fHeight  += fRowHeight;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT tx2 = m_fTexCoords[c-32][2];

        fRowWidth += (tx2-tx1)*m_dwTexWidth;

        if( fRowWidth > fWidth )
            fWidth = fRowWidth;
    }

    pSize->cx = (int)fWidth;
    pSize->cy = (int)fHeight;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawTextScaled()
// Desc: Draws scaled 2D text.  Note that x and y are in viewport coordinates
//       (ranging from -1 to +1).  fXScale and fYScale are the size fraction 
//       relative to the entire viewport.  For example, a fXScale of 0.25 is
//       1/8th of the screen width.  This allows you to output text at a fixed
//       fraction of the viewport, even if the screen or window size changes.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawTextScaled( FLOAT x, FLOAT y, FLOAT z,
                                  FLOAT fXScale, FLOAT fYScale, DWORD dwColor,
                                  TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Set up renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    D3DVIEWPORT8 vp;
    m_pd3dDevice->GetViewport( &vp );
    FLOAT sx  = (x+1.0f)*vp.Width/2;
    FLOAT sy  = (y-1.0f)*vp.Height/2;
    FLOAT sz  = z;
    FLOAT rhw = 1.0f;
    FLOAT fStartX = sx;

    FLOAT fLineHeight = ( m_fTexCoords[0][3] - m_fTexCoords[0][1] ) * m_dwTexHeight;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx  = fStartX;
            sy += fYScale*vp.Height;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1)*m_dwTexWidth;
        FLOAT h = (ty2-ty1)*m_dwTexHeight;

        w *= (fXScale*vp.Height)/fLineHeight;
        h *= (fYScale*vp.Height)/fLineHeight;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws 2D text
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawText( FLOAT sx, FLOAT sy, DWORD dwColor,
                            TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    FLOAT fStartX = sx;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices = NULL;
    DWORD         dwNumTriangles = 0;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx = fStartX;
            sy += (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
        FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                pVertices = NULL;
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render3DText()
// Desc: Renders 3D text
//-----------------------------------------------------------------------------
HRESULT CD3DFont::Render3DText( TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT3DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT3DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    // Position for each text element
    FLOAT x = 0.0f;
    FLOAT y = 0.0f;

    // Center the text block at the origin
    if( dwFlags & D3DFONT_CENTERED )
    {
        SIZE sz;
        GetTextExtent( strText, &sz );
        x = -(((FLOAT)sz.cx)/10.0f)/2.0f;
        y = -(((FLOAT)sz.cy)/10.0f)/2.0f;
    }

    // Turn off culling for two-sided text
    if( dwFlags & D3DFONT_TWOSIDED )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    FLOAT fStartX = x;
    TCHAR c;

    // Fill vertex buffer
    FONT3DVERTEX* pVertices;
    DWORD         dwVertex       = 0L;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( c = *strText++ )
    {
        if( c == '\n' )
        {
            x = fStartX;
            y -= (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight/10.0f;
        }
        if( c < 32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) * m_dwTexWidth  / ( 10.0f * m_fTextScale );
        FLOAT h = (ty2-ty1) * m_dwTexHeight / ( 10.0f * m_fTextScale );

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+0,0), D3DXVECTOR3(0,0,-1), tx1, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+h,0), D3DXVECTOR3(0,0,-1), tx2, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        x += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\cameramove.h ===
/*****************************************************************************\
    FILE: CameraMove.h

    DESCRIPTION:
        The caller can create this object to tell it to move from point a to 
    point b from time t1 to time t2.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef CAMERAMOVE_H
#define CAMERAMOVE_H

class CCameraMove;

#include "util.h"
#include "main.h"


class CCameraMove
{
public:
    // Member Functions
    virtual HRESULT Init(D3DXVECTOR3 vStartLoc, D3DXVECTOR3 vStartTangent, D3DXVECTOR3 vUpVec);
    virtual HRESULT CreateNextMove(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestLoc, D3DXVECTOR3 vDestTangent);
    virtual HRESULT CreateNextRotate(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestTangent);
    virtual HRESULT CreateNextWait(int nBatch, int nPreFetch, float fTime = -1.0f);

    virtual HRESULT SetCamera(IDirect3DDevice8 * pD3DDevice, FLOAT fTimeKeyIn);

    virtual HRESULT DeleteAllMovements(float fCurrentTime);

    CCameraMove();
    ~CCameraMove();

private:
    // Helper Functions


    // Member Variables
    D3DXVECTOR3 m_vUpVec;
    D3DXVECTOR3 m_vLocLast;           // This is the last location we were in.
    D3DXVECTOR3 m_vLookAtLast;        // This is the last location we were looking at.

    D3DXVECTOR3 m_vEyePrev;
    D3DXVECTOR3 m_vLookAtPrev;

    HDPA m_hdpaMovements;           // This contains CAMERA_MOVEMENT items.
    int m_nCurrent;
    int m_nFramesFromCurrent;

    float m_fTimeInPreviousMovements;
    float m_fTimeWarp;

    float m_fTimeToRotate;
    float m_fTimeToWalk;
    float m_fTimeToLookAtPainting;
    int m_nMinTurnFrames;
    int m_nMinWalkFrames;
    int m_nMaxTurnFrames;
    int m_nMaxWalkFrames;
};



#endif // CAMERAMOVE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\main.h ===
/*****************************************************************************\
    FILE: main.h

    DESCRIPTION:
        Here we can subclass CDXScreenSaver if we want to override the behavior.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef SSMAIN_H
#define SSMAIN_H

extern IDirect3D8 * g_pD3D;
extern DWORD g_dwWidth;
extern DWORD g_dwHeight;
extern BOOL g_fFirstFrame;

class CMSLogoDXScreenSaver;
extern CMSLogoDXScreenSaver * g_pScreenSaver;

#include "texture.h"
#include "d3dfont.h"
#include "object.h"
#include "util.h"
#include "CameraMove.h"
#include "room.h"
#include "painting.h"
#include "pictures.h"
#include "config.h"
#include "resource.h"

class CCameraMove;

#define ITEM_FLOOR                  0
#define ITEM_WALLPAPER              1
#define ITEM_CEILING                2
#define ITEM_TOEGUARD               3
#define ITEM_RUG                    4
#define ITEM_FRAME                  5
#define ITEM_POWEROUTLET            6

#define MAX_DEVICE_OBJECTS 10

const LPCWSTR c_pszGlobalTextures[] =
{
    L"Floor.bmp",
    L"Walls.bmp",
    L"Ceiling.bmp",
    L"ToeGuard.bmp",
    L"Rug.bmp",
    L"Frame.bmp",
    L"PowerSocket.bmp"
};


#ifdef MANUAL_CAMERA
//-----------------------------------------------------------------------------
// Name: struct Camera
// Desc: 
//-----------------------------------------------------------------------------
struct Camera
{
    D3DXVECTOR3        m_vPosition;
    D3DXVECTOR3        m_vVelocity;
    FLOAT              m_fYaw;
    FLOAT              m_fYawVelocity;
    FLOAT              m_fPitch;
    FLOAT              m_fPitchVelocity;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matOrientation;
};
#endif

struct DeviceObjects
{
    CD3DFont* m_pStatsFont;
};


class CMSLogoDXScreenSaver : public CD3DScreensaver
{
public:
    virtual void DoConfig(void);
    CTexture * GetGlobalTexture(DWORD dwItem, float * pfScale);
    IDirect3DDevice8 * GetD3DDevice(void);
    virtual void SetDevice(UINT iDevice);
    virtual HRESULT ConfirmDevice(D3DCAPS8 * pCaps, DWORD dwBehavior, D3DFORMAT fmtBackBuffer);
    void DisplayMonitorSettings(HWND hwndParent) {DoScreenSettingsDialog(hwndParent);}
    virtual VOID ReadSettings();
    HRESULT GetCurrentScreenSize(int * pnWidth, int * pnHeight);
    int GetNumberOfMonitors(void) {return m_dwNumAdapters;}
    int GetCurrMonitorIndex(void) {return m_nCurrentDevice;}
    VOID ReadScreenSettingsPublic( HKEY hkey ) { ReadScreenSettings( hkey ); }
    VOID WriteScreenSettingsPublic( HKEY hkey ) { WriteScreenSettings( hkey ); }
    CULLINFO* PCullInfo(void) { return &m_cullInfo; }
    BOOL UseSmallImages(void) {return m_fUseSmallImages;}

    CMSLogoDXScreenSaver();
    virtual ~CMSLogoDXScreenSaver();

protected:
    // Member Functions
    virtual HRESULT RegisterSoftwareDevice(void);

    virtual HRESULT OneTimeSceneInit(void) {return S_OK;}
    virtual HRESULT FrameMove(void);
    virtual HRESULT Render(void);
    virtual HRESULT DeleteDeviceObjects(void);
    virtual HRESULT FinalCleanup(void);
    virtual HRESULT InitDeviceObjects(void);
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual BOOL UseLowResolution(int * pRecommendX, int * pRecommendY);
#ifdef MANUAL_CAMERA
    VOID    UpdateCamera(Camera* pCamera);
    virtual LRESULT SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
#endif


private:
    // Helper Functions
    HRESULT SetViewParams(IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 * pvecEyePt, D3DXVECTOR3 * pvecLookatPt, D3DXVECTOR3 * pvecUpVec, float nNumber);
    HRESULT _Init(void);
    HRESULT _SetTestCameraPosition(void);
    HRESULT _OneTimeSceneInit(void);
    HRESULT _CheckMachinePerf(void);

    // Member Variables
    CTheRoom * m_pCurrentRoom;
    BOOL m_fFrontToBack;
    int m_nCurrentDevice;
    BOOL m_fShowFrameInfo;
    CULLINFO m_cullInfo;
    BOOL m_fUseSmallImages;         // If TRUE, Cap images at 512x512, otherwise 1024x1024

#ifdef MANUAL_CAMERA
    BYTE m_bKey[256];
    Camera m_camera;
#endif

    CCameraMove * m_ptheCamera;

    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects * m_pDeviceObjects;

    CTexture * m_pTextures[ARRAYSIZE(c_pszGlobalTextures)];

    FLOAT m_fTimeKeyIn;
};






#endif // SSMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\main.cpp ===
/*****************************************************************************\
    FILE: main.cpp

    DESCRIPTION:
        Here we can subclass CDXScreenSaver if we want to override the behavior.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "main.h"
#include "..\\D3DSaver\\D3DSaver.h"


CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };

CMSLogoDXScreenSaver * g_pScreenSaver = NULL;       // Replace with CMyDXScreenSaver if you want to override.

DWORD g_dwBaseTime = 0;
HINSTANCE g_hMainInstance = NULL;
IDirect3D8 * g_pD3D = NULL;

DWORD g_dwWidth = 0;
DWORD g_dwHeight = 0;

BOOL g_fFirstFrame = TRUE;      // On our first frame, we don't want to render the images because then the screensaver will remain black for a long time while they load


//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, INT)
{
    HRESULT hr = E_OUTOFMEMORY;
    HRESULT hrOle = CoInitialize(0);
    g_pScreenSaver = new CMSLogoDXScreenSaver();

    g_hMainInstance = hInst;
    if (g_pScreenSaver)
    {
        hr = g_pScreenSaver->Create(hInst);
        if (SUCCEEDED(hr))
        {
            hr = g_pScreenSaver->Run();
        }

        if (FAILED(hr))
        {
            g_pScreenSaver->DisplayErrorMsg(hr);
        }

        SAFE_DELETE(g_pScreenSaver);
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    return hr;
}



CMSLogoDXScreenSaver::CMSLogoDXScreenSaver()
{
    InitializeCriticalSection(&g_csDll);

    time_t nTime = time(NULL);
    UINT uSeed = (UINT) nTime;

    InitCommonControls();       // To enable fusion.

    srand(uSeed);
    m_ptheCamera = NULL;
    m_pCurrentRoom = NULL;
    m_fFrontToBack = FALSE;
    m_bUseDepthBuffer = TRUE;
    m_pDeviceObjects = 0;
    m_nCurrentDevice = 0;
    m_fShowFrameInfo = FALSE;
    m_fUseSmallImages = TRUE;

    m_pDeviceObjects = NULL;
    ZeroMemory(m_DeviceObjects, sizeof(m_DeviceObjects));

#ifdef MANUAL_CAMERA
    ZeroMemory( &m_camera, sizeof(m_camera) );
    m_camera.m_vPosition = D3DXVECTOR3( 60.16f, 20.0f, 196.10f );
    m_camera.m_fYaw = -81.41f;
    ZeroMemory( m_bKey, 256 );
#endif

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTextures); nIndex++)
    {
        m_pTextures[nIndex] = NULL;
    }

    if (!g_pConfig)
    {
        g_pConfig = new CConfig(this);
    }
}


extern int g_nLeakCheck;

CMSLogoDXScreenSaver::~CMSLogoDXScreenSaver()
{
    DWORD dwTemp = 0;
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTextures); nIndex++)
    {
        SAFE_RELEASE(m_pTextures[nIndex]);
    }

    IUnknown_Set((IUnknown **) &g_pD3D, NULL);
    SAFE_DELETE(g_pConfig);

    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->FinalCleanup();
    }
    SAFE_RELEASE(m_pCurrentRoom);
//    AssertMsg((0 == g_nLeakCheck), TEXT("We have a bug in the CTheRoom ref-counting that caused %d rooms to be leaked."), g_nLeakCheck);
    if (g_nLeakCheck)
    {
        dwTemp = g_nLeakCheck;
    }

    DeleteCriticalSection(&g_csDll);
}


IDirect3DDevice8 * CMSLogoDXScreenSaver::GetD3DDevice(void)
{
    return m_pd3dDevice;
}


void CMSLogoDXScreenSaver::SetDevice(UINT iDevice)
{
    m_nCurrentDevice = iDevice;
    m_pDeviceObjects = &m_DeviceObjects[m_nCurrentDevice];
}

void CMSLogoDXScreenSaver::ReadSettings()
{
    g_pConfig->LoadStatePublic();
}


HRESULT CMSLogoDXScreenSaver::GetCurrentScreenSize(int * pnWidth, int * pnHeight)
{
    int nAdapter = m_RenderUnits[m_nCurrentDevice].iAdapter;
    D3DAdapterInfo * pAdapterInfo = m_Adapters[nAdapter];
    D3DDeviceInfo * pDeviceInfo = &(pAdapterInfo->devices[pAdapterInfo->dwCurrentDevice]);
    D3DModeInfo * pModeInfo = &(pDeviceInfo->modes[pDeviceInfo->dwCurrentMode]);

    *pnWidth = pModeInfo->Width;
    *pnHeight = pModeInfo->Height;

    return S_OK;
}


CTexture * CMSLogoDXScreenSaver::GetGlobalTexture(DWORD dwItem, float * pfScale)
{
    CTexture * pTexture = NULL;

    if (dwItem >= ARRAYSIZE(m_pTextures))
    {
        return NULL;
    }

    *pfScale = 1.0f;
    pTexture = m_pTextures[dwItem];

    if (!pTexture && m_pd3dDevice && g_pConfig)
    {
        TCHAR szPath[MAX_PATH];
        DWORD dwScale;

        if (SUCCEEDED(g_pConfig->GetTexturePath(dwItem, &dwScale, szPath, ARRAYSIZE(szPath))) &&
            PathFileExists(szPath))
        {
            *pfScale = (1.0f / (((float) dwScale) / 100.0f));
        }
        else
        {
            StrCpyN(szPath, c_pszGlobalTextures[dwItem], ARRAYSIZE(szPath));
        }

        // This will give people a chance to customize the images.
        pTexture = new CTexture(this, szPath, c_pszGlobalTextures[dwItem], *pfScale);
        m_pTextures[dwItem] = pTexture;
    }

    *pfScale = (pTexture ? pTexture->GetScale() : 1.0f);
    return pTexture;
}

HRESULT CMSLogoDXScreenSaver::RegisterSoftwareDevice(void)
{ 
    if (m_pD3D)
    {
        m_pD3D->RegisterSoftwareDevice(D3D8RGBRasterizer);
    }

    return S_OK; 
}


void _stdcall ModuleEntry(void)
{
    int nReturn = WinMain(GetModuleHandle(NULL), NULL, NULL, 0);
    ExitProcess(nReturn);
}


HRESULT CMSLogoDXScreenSaver::_SetTestCameraPosition(void)
{
    D3DXVECTOR3 vSourceLoc(1.0f, 20.f, 199.0f);
    D3DXVECTOR3 vSourceTangent(5.0f, 0.0f, 0.0f);

    HRESULT hr = m_ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        D3DXVECTOR3 vDestLoc(1.0f, 20.f, 10.0f);
        D3DXVECTOR3 vDestTangent(5.0, 0.0f, 0.0f);
        hr = m_ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        hr = m_ptheCamera->CreateNextWait(0, 0, 300.0f);
    }

    return hr;
}


HRESULT CMSLogoDXScreenSaver::_CheckMachinePerf(void)
{
    // Initialize member variables
    int nWidth;
    int nHeight;

    // We will only consider using large images if the screen is larger
    // than 1248x1024
    if (SUCCEEDED(GetCurrentScreenSize(&nWidth, &nHeight)) && g_pConfig &&
        (nWidth > 1200) && (nHeight >= 1024))
    {
        // Now, the user can force this on by using a high "Quality" setting
        if ((MAX_QUALITY - 2) <= g_pConfig->GetDWORDSetting(CONFIG_DWORD_QUALITY_SLIDER))
        {
            m_fUseSmallImages = FALSE;
        }
        else
        {
            // Otherwise, we need to check the machines capabilities.
            MEMORYSTATUS ms;

            GlobalMemoryStatus(&ms);
            SIZE_T nMegabytes = (ms.dwTotalPhys / (1024 * 1024));

            // Only use large images if there is more than 170MB of RAM or we can
            // thrash.
            if ((nMegabytes > 170) && (2 < g_pConfig->GetDWORDSetting(CONFIG_DWORD_QUALITY_SLIDER)))
            {
                // We should only use 60% of the video memory.  So at this resolution, find
                // out how many images that will most likely be.
                // TODO: nNumberOfImages = floor((VideoMemory * 0.60) / AveBytesPerImage);
                m_fUseSmallImages = FALSE;
            }
        }
    }

    return S_OK;
}


extern float g_fRoomWidthX;
extern float g_fRoomDepthZ;
extern float g_fRoomHeightY;

HRESULT CMSLogoDXScreenSaver::_Init(void)
{
    // Initialize member variables
    HRESULT hr = S_OK;

    if (g_pConfig)
    {
        m_fShowFrameInfo = g_pConfig->GetBoolSetting(IDC_CHECK_SHOWSTATS);
    }

    _CheckMachinePerf();
    if (!g_pPictureMgr)
    {
        g_pPictureMgr = new CPictureManager(this);
        if (!g_pPictureMgr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    IUnknown_Set((IUnknown **) &g_pD3D, (IUnknown *)m_pD3D);
    return hr;
}


void CMSLogoDXScreenSaver::DoConfig(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pConfig)
    {
        hr = g_pConfig->DisplayConfigDialog(NULL);
    }
}


HRESULT CMSLogoDXScreenSaver::SetViewParams(IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 * pvecEyePt, D3DXVECTOR3 * pvecLookatPt, D3DXVECTOR3 * pvecUpVec, float nNumber)
{
    HRESULT hr = E_UNEXPECTED;

    if (pD3DDevice)
    {
        D3DXMATRIX matView;

        D3DXMatrixLookAtLH(&matView, pvecEyePt, pvecLookatPt, pvecUpVec);
        hr = pD3DDevice->SetTransform(D3DTS_VIEW, &matView);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::_OneTimeSceneInit(void)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        m_pCurrentRoom = new CTheRoom(FALSE, this, NULL, 0);
        if (m_pCurrentRoom)
        {
            m_pCurrentRoom->SetCurrent(TRUE);
            hr = m_pCurrentRoom->OneTimeSceneInit(2, FALSE);

            if (SUCCEEDED(hr) && !m_ptheCamera)
            {
                m_ptheCamera = new CCameraMove();
                if (m_ptheCamera && g_pPictureMgr)
                {
//            return _SetTestCameraPosition();
                    hr = m_pCurrentRoom->LoadCameraMoves(m_ptheCamera);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::FinalCleanup(void)
{
    HRESULT hr = S_OK;
    
    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->FinalCleanup();
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::InitDeviceObjects(void)
{
    HRESULT hr = E_FAIL;

    if (m_pd3dDevice && g_pConfig)
    {
        DWORD dwAmbient = 0xD0D0D0D0;       // 0x33333333, 0x0a0a0a0a, 0x11111111

        // Set up the lights
        hr = m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, dwAmbient);

        // TODO: GetViewport() is not compatible with pure-devices, which we want because it gives us
        // Big perf win.
        D3DMATERIAL8 mtrl = {0};
        mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
        mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
        mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
        mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;

        m_pd3dDevice->SetMaterial(&mtrl);


        // Setup texture states
        hr = m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        hr = m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

        // Set default render states
        hr = m_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
        hr = m_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);

        switch (g_pConfig->GetDWORDSetting(CONFIG_DWORD_RENDERQUALITY))
        {
        case 0:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);
            break;
        case 1:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
            break;
        case 2:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_PHONG);
            break;
        }

        if (SUCCEEDED(hr))
        {
            hr = _OneTimeSceneInit();
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::RestoreDeviceObjects(void)
{
    m_pDeviceObjects->m_pStatsFont = new CD3DFont( _T("Arial"), 12, D3DFONT_BOLD );
    m_pDeviceObjects->m_pStatsFont->InitDeviceObjects( m_pd3dDevice );
    m_pDeviceObjects->m_pStatsFont->RestoreDeviceObjects();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::InvalidateDeviceObjects()
{
    m_pDeviceObjects->m_pStatsFont->InvalidateDeviceObjects();
    m_pDeviceObjects->m_pStatsFont->DeleteDeviceObjects();
    SAFE_DELETE( m_pDeviceObjects->m_pStatsFont );

    return S_OK;
}



/*****************************************************************************\
    DESCRIPTION:
        This function is used to check the computers capabilities.  By default
    we try to use the user's current resolution to render.  If we are happy with
    the computer's capabilities, we return FALSE, and the current resolution is used.

    Otherwise, we return FALSE and recommend a resolution to use.  Most often
    640x480 or 800x600 is recommended.
\*****************************************************************************/
BOOL CMSLogoDXScreenSaver::UseLowResolution(int * pRecommendX, int * pRecommendY)
{
    BOOL fUseLowRes = FALSE;
    MEMORYSTATUS ms;
/*
    DDCAPS ddCaps = {0};

    ddCaps.dwSize = sizeof(ddCaps);
    HRESULT hr = pDDraw7->GetCaps(&ddCaps, NULL);
*/
    GlobalMemoryStatus(&ms);

    // Our frame rate will hurt if any of these are true...
    if ( (ms.dwTotalPhys < (125 * 1024 * 1024))           // If the computer has less than 128 MB of physical RAM, then it could trash.
/*        TODO
        ||
        FAILED(hr) ||
        (ddCaps.dwCaps & DDCAPS_3D) || )                    // Our frame rate will hurt without these abilities
        (ddCaps.dwVidMemTotal < (15 * 1024 * 1024)) || )    // We want video cards with 16 MB of RAM.  Less indicates old hardware.
        (ddCaps.dwCaps & DDCAPS_3D))                        // We want a real 3D card
        (ddCaps.dwCaps.ddsCaps  & DDSCAPS_TEXTURE))         // We want video cards with at least this support...
*/
        )
    {
        fUseLowRes = TRUE;
        *pRecommendX = 640;
        *pRecommendY = 480;
    }

    return fUseLowRes;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::DeleteDeviceObjects(void)
{
    HRESULT hr = S_OK;
    
    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->DeleteDeviceObjects();
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::Render(void)
{
    HRESULT hr = E_INVALIDARG;

    g_nTexturesRenderedInThisFrame = 0;
    g_nTrianglesRenderedInThisFrame = 0;

    SetProjectionMatrix( 1.0f, 1000.0f );

    if (m_pd3dDevice)
    {
        // Clear the viewport
        hr = m_pd3dDevice->Clear(0, NULL, (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER), 0x00000000 /*WATER_COLOR*/, 1.0f, 0L);

        // Watch the number of textures we have open at one time.
//        TCHAR szOut[MAX_PATH];
//        wsprintf(szOut, TEXT("Number of open textures: %d"), D3DTextr_GetTextureCount());
//        TraceOutput(szOut);

        // Begin the scene 
        if (m_ptheCamera && SUCCEEDED(m_pd3dDevice->BeginScene()))
        {
            D3DXMATRIX matIdentity;

            D3DXMatrixIdentity(&matIdentity);

#ifdef MANUAL_CAMERA
            UpdateCamera(&m_camera);
            hr = m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_camera.m_matView );
#else
            hr = m_ptheCamera->SetCamera(m_pd3dDevice, m_fTimeKeyIn);
            if (FAILED(hr))
            {
                DXUtil_Trace(TEXT("ERROR: m_ptheCamera->SetCamera failed."));
            }
#endif

            if ((S_FALSE == hr) && m_pCurrentRoom)
            {
                CTheRoom * pNextRoom = NULL;

                m_pCurrentRoom->FreePictures();
                hr = m_pCurrentRoom->GetNextRoom(&pNextRoom);
                if (SUCCEEDED(hr))
                {
                    m_pCurrentRoom->SetCurrent(FALSE);
                    pNextRoom->SetCurrent(TRUE);

                    SAFE_RELEASE(m_pCurrentRoom);
                    m_pCurrentRoom = pNextRoom;

                    hr = m_ptheCamera->DeleteAllMovements(m_fTimeKeyIn);        // Purge all the previous movements.
                    hr = m_pCurrentRoom->LoadCameraMoves(m_ptheCamera);
                    if (SUCCEEDED(hr))
                    {
                        // We need to set the camera at the start of the new room.
                        hr = m_ptheCamera->SetCamera(m_pd3dDevice, m_fTimeKeyIn);
                    }
                }
            }

            // Update cull info for this frame
            // TODO: cache these matrices ourselves rather than using GetTransform
            D3DXMATRIX matView;
            D3DXMATRIX matProj;
            m_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
            m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
            UpdateCullInfo( &m_cullInfo, &matView, &matProj );

            ////////////////////////////
            // Render the objects in the room
            ////////////////////////////
            // Room
            m_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
            m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(0), &matIdentity);

            if (m_pCurrentRoom)
            {
                int nMaxPhases = m_pCurrentRoom->GetMaxRenderPhases();

                m_fFrontToBack = !m_fFrontToBack;

                // An object will break down it's rendering by the textures it uses.  It will then
                // render one phase for each texture.  We reverse the phase render order to try
                // to keep the textures in memory when transitioning between one rendering cycle and the next.

                // For now, reversing the rendering order has been removed.  DX should take care of this for us
                // and it causes us to control z-order.
                for (int nCurrentPhase = 0; nCurrentPhase < nMaxPhases; nCurrentPhase++)
                {
                    hr = m_pCurrentRoom->Render(m_pd3dDevice, nCurrentPhase, TRUE /*m_fFrontToBack*/);
                }
            }

            if( m_fShowFrameInfo )
            {
                m_pDeviceObjects->m_pStatsFont->DrawText( 3,  1, D3DCOLOR_ARGB(255,0,0,0), m_strFrameStats );
                m_pDeviceObjects->m_pStatsFont->DrawText( 2,  0, D3DCOLOR_ARGB(255,255,255,0), m_strFrameStats );

                m_pDeviceObjects->m_pStatsFont->DrawText( 3, 21, D3DCOLOR_ARGB(255,0,0,0), m_strDeviceStats );
                m_pDeviceObjects->m_pStatsFont->DrawText( 2, 20, D3DCOLOR_ARGB(255,255,255,0), m_strDeviceStats );
            }
            // End the scene.
            m_pd3dDevice->EndScene();
        }
        else
        {
            DXUtil_Trace(TEXT("ERROR: m_ptheCamera is NULL or ::BeginScene() failed."));
        }
    }

    g_nTexturesRenderedInThisFrame++;       // This is the picture frame.
    g_fFirstFrame = FALSE;

    // Display stats for this frame.
    DXUtil_Trace(TEXT("RENDER FRAME: Textures: %d (Rendered %d)   Triangles Rendered: %d  Room: %d\n"), 
                g_nTotalTexturesLoaded, g_nTexturesRenderedInThisFrame, g_nTrianglesRenderedInThisFrame, m_pCurrentRoom->m_nBatch);

    return hr;
}


#ifdef MANUAL_CAMERA
//-----------------------------------------------------------------------------
// Name: UpdateCamera()
// Desc: 
//-----------------------------------------------------------------------------
VOID CMSLogoDXScreenSaver::UpdateCamera(Camera* pCamera)
{
    FLOAT fElapsedTime;

    if( m_fElapsedTime > 0.0f )
        fElapsedTime = m_fElapsedTime;
    else
        fElapsedTime = 0.05f;

    FLOAT fSpeed        = 5.0f*fElapsedTime;
    FLOAT fAngularSpeed = 2.0f*fElapsedTime;

    // De-accelerate the camera movement (for smooth motion)
    pCamera->m_vVelocity      *= 0.75f;
    pCamera->m_fYawVelocity   *= 0.75f;
    pCamera->m_fPitchVelocity *= 0.75f;

    // Process keyboard input
    if( m_bKey[VK_RIGHT] )    pCamera->m_vVelocity.x    += fSpeed; // Slide Right
    if( m_bKey[VK_LEFT] )     pCamera->m_vVelocity.x    -= fSpeed; // Slide Left
    if( m_bKey[VK_UP] )       pCamera->m_vVelocity.y    += fSpeed; // Slide Up
    if( m_bKey[VK_DOWN] )     pCamera->m_vVelocity.y    -= fSpeed; // Slide Down
    if( m_bKey['W'] )         pCamera->m_vVelocity.z    += fSpeed; // Move Forward
    if( m_bKey['S'] )         pCamera->m_vVelocity.z    -= fSpeed; // Move Backward
    if( m_bKey['E'] )         pCamera->m_fYawVelocity   += fSpeed; // Turn Right
    if( m_bKey['Q'] )         pCamera->m_fYawVelocity   -= fSpeed; // Turn Left
    if( m_bKey['Z'] )         pCamera->m_fPitchVelocity += fSpeed; // Turn Down
    if( m_bKey['A'] )         pCamera->m_fPitchVelocity -= fSpeed; // Turn Up

    // Update the position vector
    D3DXVECTOR3 vT = pCamera->m_vVelocity * fSpeed;
    D3DXVec3TransformNormal( &vT, &vT, &pCamera->m_matOrientation );
    pCamera->m_vPosition += vT;

    // Update the yaw-pitch-rotation vector
    pCamera->m_fYaw   += fAngularSpeed * pCamera->m_fYawVelocity;
    pCamera->m_fPitch += fAngularSpeed * pCamera->m_fPitchVelocity;
    if( pCamera->m_fPitch < -D3DX_PI/2 ) 
        pCamera->m_fPitch = -D3DX_PI/2;
    if( pCamera->m_fPitch > D3DX_PI/2 ) 
        pCamera->m_fPitch = D3DX_PI/2;

    // Set the view matrix
    D3DXQUATERNION qR;
    D3DXQuaternionRotationYawPitchRoll( &qR, pCamera->m_fYaw, pCamera->m_fPitch, 0.0f );
    D3DXMatrixAffineTransformation( &pCamera->m_matOrientation, 1.25f, NULL, &qR, &pCamera->m_vPosition );
    D3DXMatrixInverse( &pCamera->m_matView, NULL, &pCamera->m_matOrientation );
}



LRESULT CMSLogoDXScreenSaver::SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if( WM_KEYDOWN == uMsg )
    {
        m_bKey[wParam] = 1;
    }
    // Perform commands when keys are released
    if( WM_KEYUP == uMsg )
    {
        m_bKey[wParam] = 0;
    }
    return CD3DScreensaver::SaverProc( hWnd, uMsg, wParam, lParam );
}
#endif

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::FrameMove(void)
{
    if (sm_preview == m_SaverMode)
    {
        Sleep(50);        // We can render plenty of frames in preview mode.
    }

    if (0 == g_dwBaseTime)
    {
        g_dwBaseTime = timeGetTime();
    }

    m_fTimeKeyIn = (timeGetTime() - g_dwBaseTime) * 0.001f;
    return S_OK;
}


HRESULT CMSLogoDXScreenSaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, D3DFORMAT fmtBackBuffer)
{
    // TODO: In the future, we would like to use PURE-Devices because it's
    // a big perf win.  However, if we do, then we need to stop using GetViewport and
    // GetTransform.
    if (dwBehavior & D3DCREATE_PUREDEVICE)
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\pictures.h ===
/*****************************************************************************\
    FILE: pictures.h

    DESCRIPTION:
        Manage the pictures in the user's directories.  Convert them when needed.
    Handle caching and making sure we don't use too much diskspace.  Also add
    picture frames when needed.

    PERF:
    The biggest perf impact on this screen saver is how we handle loading the pictures.
    1. If we load to many pictures, we will start paging and blow the texture
       memory.
    2. If we recycle too much or too little, we will either use too much memory or look too repeative.
    3. Latency is a killer.  We want the main thread being CPU and video card bound while
       we have a background thread loading and uncompressing images.  This will allow
       the background thread to be I/O bound so the forground can still render fairly well.

    We need to decide a size and scale pictures down to that size.  This will reduce the memory
    requirements.  If we determine that smallest picture we can use that will still look good,
    we should be okay.
    
    Here are some numbers:
    Images Size     Each Picture    For 18 Images
    ===========     =============   =============
    320x240         .152 MB         5.47 MB
    640x480         .6 MB           21 MB
    800x600         .96 MB          34 MB
    1024x768        1.5 MB          54 MB

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef PICTURES_H
#define PICTURES_H


#include "util.h"
#include "main.h"
#include "config.h"

class CPictureManager;

extern CPictureManager * g_pPictureMgr;

#define GNPF_NONE                       0x00000000
#define GNPF_RECYCLEPAINTINGS           0x00000001      // The picture is probably in a side room so reuse pictures to keep memory use down.

#define MAX_PICTURES_IN_BATCH           7

typedef struct
{
    LPTSTR pszPath;
    CTexture * pTexture;
    BOOL fInABatch;           // Has this painting been loaded?
} SSPICTURE_INFO;


typedef struct
{
    SSPICTURE_INFO * pInfo[MAX_PICTURES_IN_BATCH];
} SSPICTURES_BATCH;



class CPictureManager
{
public:
    // Member Functions
    HRESULT GetPainting(int nBatch, int nIndex, DWORD dwFlags, CTexture ** ppTexture);
    HRESULT PreFetch(int nBatch, int nToFetch);
    HRESULT ReleaseBatch(int nBatch);

    CPictureManager(CMSLogoDXScreenSaver * pMain);
    virtual ~CPictureManager();

private:
    // Private Functions

    // Enum and build of picture list
    HRESULT _PInfoCreate(int nIndex, LPCTSTR pszPath);
    HRESULT _EnumPaintings(void);
    HRESULT _AddPaintingsFromDir(LPCTSTR pszPath);

    // Create a batch
    HRESULT _LoadTexture(SSPICTURE_INFO * pInfo, BOOL fFaultInTexture);
    HRESULT _GetNextWithWrap(SSPICTURE_INFO ** ppInfo, BOOL fAlreadyLoaded, BOOL fFaultInTexture);
    HRESULT _TryGetNextPainting(SSPICTURE_INFO ** ppInfo, DWORD dwFlags);
    HRESULT _CreateNewBatch(int nBatch, BOOL fFaultInTexture);


    // Member Variables
    HDSA m_hdsaPictures;           // Contains SSPICTURE_INFO.  We want each painting in m_hdpaPaintings to be ref-counted.
    int m_nCurrent;

    HDSA m_hdsaBatches;             // Contains Batches (SSPICTURES_BATCH)
    int m_nCurrentBatch;            // 

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
};



#endif // PICTURES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\painting.cpp ===
/*****************************************************************************\
    FILE: painting.cpp

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "util.h"
#include "painting.h"





//-----------------------------------------------------------------------------
// Name: C3DObject()
// Desc: Constructor
//-----------------------------------------------------------------------------
CPainting::CPainting(CMSLogoDXScreenSaver * pMain)
{
    // Initialize member variables
    m_pMain = pMain;

    m_pFrameTexture = NULL;
    m_pPaintingTexture = NULL;

    m_pObjPainting = NULL;
    m_pObjFrame = NULL;
}


CPainting::~CPainting()
{
    SAFE_RELEASE(m_pFrameTexture);
    SAFE_RELEASE(m_pPaintingTexture);

    SAFE_DELETE(m_pObjPainting);
    SAFE_DELETE(m_pObjFrame);
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CPainting::FinalCleanup(void)
{
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CPainting::DeleteDeviceObjects(void)
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CPainting::OneTimeSceneInit(void)
{
    HRESULT hr = E_OUTOFMEMORY;

    m_pObjPainting = new C3DObject(m_pMain);
    m_pObjFrame = new C3DObject(m_pMain);
    if (m_pObjFrame && m_pObjFrame)
    {
        hr = S_OK;
    }

    return hr;
}


HRESULT CPainting::SetPainting(CTexture * pFrameTexture, CTexture * pPaintingTexture, D3DXVECTOR3 vLocationCenter, float fMaxHeight,
                               float fFrameWidth, float fFrameHeight, D3DXVECTOR3 vNormal, DWORD dwMaxPixelSize)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_pObjPainting && m_pObjFrame && m_pMain && pFrameTexture && pPaintingTexture)
    {
        D3DXVECTOR3 vWidth;
        D3DXVECTOR3 vHeight;

        if (vNormal.x)
        {
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }
        else if (vNormal.y)
        {
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(1, 0, 0);
        }
        else
        {
            vWidth = D3DXVECTOR3(1, 0, 0);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }

        IUnknown_Set((IUnknown **) &m_pFrameTexture, (IUnknown *) pFrameTexture);
        IUnknown_Set((IUnknown **) &m_pPaintingTexture, (IUnknown *) pPaintingTexture);

        DWORD dwPaintingWidth = pPaintingTexture->GetTextureWidth();
        DWORD dwPaintingHeight = pPaintingTexture->GetTextureHeight();
        float fPaintingRatio = (((float) dwPaintingWidth) / ((float) dwPaintingHeight));

        int nWidth = 1;
        int nHeight = 1;
        
        m_pMain->GetCurrentScreenSize(&nWidth, &nHeight);
        float fMonitorRatio = (((float) nWidth) / ((float) nHeight));

        float fPaintingHeight = fMaxHeight;
        float fPaintingWidth = (fPaintingHeight * fPaintingRatio);

        if (fPaintingRatio > fMonitorRatio)
        {
            // Oh no, the picture ratio is wider than the screen radio.  This will cause
            // warpping so it will extend off the right and left.  We need to scale it down.
            float fScaleDownRatio = (fMonitorRatio / fPaintingRatio);
            fPaintingHeight *= fScaleDownRatio;
            fPaintingWidth *= fScaleDownRatio;
        }

        D3DXVECTOR3 vTranslateToCorner = ((-fPaintingWidth/2)*vWidth + (-fPaintingHeight/2)*vHeight);

        D3DXVECTOR3 vObjLocation(vLocationCenter + vTranslateToCorner);
        D3DXVECTOR3 vObjSize(fPaintingWidth*vWidth + fPaintingHeight*vHeight);
        hr = m_pObjPainting->InitPlaneStretch(pPaintingTexture, m_pMain->GetD3DDevice(), vObjLocation, vObjSize, vNormal, 3, 3, dwMaxPixelSize);

        D3DXVECTOR3 vFrameSize(D3DXVec3Multiply(vObjSize, (D3DXVECTOR3((fFrameWidth * vWidth) + D3DXVECTOR3(fFrameHeight * vHeight)))));
        vObjLocation = (vObjLocation - vFrameSize + ((g_fFudge / -2.0f)* vNormal));
        vObjSize = (vObjSize + (2 * vFrameSize));
        hr = m_pObjFrame->InitPlaneStretch(pFrameTexture, m_pMain->GetD3DDevice(), vObjLocation, vObjSize, vNormal, 3, 3, dwMaxPixelSize);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CPainting::Render(IDirect3DDevice8 * pD3DDevice, int nPhase)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_pObjFrame && m_pObjPainting)
    {
        switch (nPhase)
        {
        case 0:
            hr = m_pObjFrame->Render(pD3DDevice);
        break;

        case 1:
            hr = m_pObjPainting->Render(pD3DDevice);
        break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  DXSvr.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\painting.h ===
/*****************************************************************************\
    FILE: painting.h

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef PAINTING_H
#define PAINTING_H

#include "util.h"
#include "main.h"



//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------

#define SIZE_MAXPAINTINGSIZE_INWALLPERCENT          0.5f




class CPainting
{
public:
    HRESULT OneTimeSceneInit(void);
    HRESULT Render(IDirect3DDevice8 * lpDev, int nPhase);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);

    HRESULT SetPainting(CTexture * pFrameTexture, CTexture * pPaintingTexture, D3DXVECTOR3 vLocationCenter, float fMaxHeight,
                        float fFrameWidth, float fFrameHeight, D3DXVECTOR3 vNormal, DWORD dwMaxPixelSize);

    CPainting(CMSLogoDXScreenSaver * pMain);
    virtual ~CPainting();

    CTexture * m_pPaintingTexture;

private:
    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    C3DObject * m_pObjPainting;
    C3DObject * m_pObjFrame;

    CTexture * m_pFrameTexture;
};


#endif // PAINTING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\object.cpp ===
/*****************************************************************************\
    FILE: object.cpp

    DESCRIPTION:
        The caller will tell us what shape they want.  Normally a rectangle on a
    plane or a sphere.  We will then create the number vertexs the caller wants
    for that objectand create texture coordinates.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "util.h"
#include "room.h"
#include "object.h"


int g_nTrianglesRenderedInThisFrame = 0;



C3DObject::C3DObject(CMSLogoDXScreenSaver * pMain)
{
    // Initialize member variables
    m_pTexture = NULL;
    m_pdwIndices = NULL;

    m_dwNumVer = 0;
    m_dwNumIndeces = 0;

    m_pvVertexs = NULL;

    m_pMain = pMain;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pIndexBuff); nIndex++)
    {
        m_pVB[nIndex] = NULL;
        m_pIndexBuff[nIndex] = NULL;
    }

    m_pNextObject = NULL;
}


C3DObject::~C3DObject()
{
    SAFE_RELEASE(m_pTexture);

    SAFE_DELETE(m_pdwIndices);
    SAFE_DELETE(m_pvVertexs);
    SAFE_DELETE(m_pNextObject);
    _PurgeDeviceObjects();
}


HRESULT C3DObject::InitPlaneStretch(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, DWORD dwMaxPixelSize)
{
    D3DXVECTOR3 vWidth;
    D3DXVECTOR3 vHeight;

    if (vNormal.x)
    {
        vWidth = D3DXVECTOR3(0, 0, 1);
        vHeight = D3DXVECTOR3(0, 1, 0);
    }
    else if (vNormal.y)
    {
        vWidth = D3DXVECTOR3(0, 0, 1);
        vHeight = D3DXVECTOR3(1, 0, 0);
    }
    else
    {
        vWidth = D3DXVECTOR3(1, 0, 0);
        vHeight = D3DXVECTOR3(0, 1, 0);
    }
    
    float fTextureX = (1.0f / AddVectorComponents(D3DXVec3Multiply(vSize, vWidth)));
    float fTextureY = (1.0f / AddVectorComponents(D3DXVec3Multiply(vSize, vHeight)));
    
    return InitPlane(pTexture, pD3DDevice, vLocation, vSize, vNormal, nNumVertexX, nNumVertexY,
            fTextureX, fTextureY, dwMaxPixelSize, 0.0f);
}


/*****************************************************************************\
    DESCRIPTION:
        This function needs to force pvSize to be positive, but ajusting pvLocation.
    This is necessary in order to get the normal vectors for the verticies correct
    or the triangle will be culled from the user's view.
\*****************************************************************************/
HRESULT C3DObject::_ForPositiveSize(D3DXVECTOR3 * pvLocation, D3DXVECTOR3 * pvSize)
{
    if (0 > pvSize->x)
    {
        pvLocation->x += pvSize->x;
        pvSize->x = -pvSize->x;
    }

    if (0 > pvSize->y)
    {
        pvLocation->y += pvSize->y;
        pvSize->y = -pvSize->y;
    }

    if (0 > pvSize->z)
    {
        pvLocation->z += pvSize->z;
        pvSize->z = -pvSize->z;
    }

    return S_OK;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will create an object which is a plane with pTexture on the
    surface.  It will be a grid of nNumVertexX by nNumVertexY.

    PARAMETERS:
        fTextureScaleX: This is the number patterns to repeat in a 1.0f of space.
\*****************************************************************************/
HRESULT C3DObject::InitPlane(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, float fTextureScaleX, float fTextureScaleY,
                                DWORD dwMaxPixelSize, float fVisibleRadius)
{
    HRESULT hr = E_INVALIDARG;

    _ForPositiveSize(&vLocation, &vSize);
    _PurgeDeviceObjects();

    m_vMin = vLocation;
    m_vMax = vLocation + vSize;
    
    SAFE_DELETE(m_pdwIndices);
    SAFE_DELETE(m_pvVertexs);
    if (pD3DDevice && (nNumVertexX > 1) && (nNumVertexY > 1))
    {
        D3DXVECTOR3 vWidth;
        D3DXVECTOR3 vHeight;
        BOOL fFlipOrder = FALSE;
        BOOL fFlipTexture = FALSE;

        IUnknown_Set((IUnknown **) &m_pTexture, (IUnknown *) pTexture);

        //AssertMsg(((nNumVertexX > 1) && (nNumVertexY > 1)), TEXT("Grid needs to be larger."));
        if (vNormal.x)
        {
            // Flip the order of the triangle vectors.
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }
        else if (vNormal.y)
        {
            fFlipOrder = TRUE;
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(1, 0, 0);
        }
        else
        {
            // Flip the order of the triangle vectors.
            fFlipOrder = TRUE;
            vWidth = D3DXVECTOR3(1, 0, 0);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }

        if ((0 > vNormal.x) || (0 < vNormal.z))
        {
            fFlipTexture = TRUE;
        }

        if (0 < AddVectorComponents(vNormal))
        {
            fFlipOrder = !fFlipOrder;
        }

        D3DXMatrixIdentity(&m_matIdentity);

        m_dwNumVer = (nNumVertexX * nNumVertexY);

        m_dwNumIndeces = (6 * ((nNumVertexX - 1) * (nNumVertexY - 1)));
        m_pdwIndices = new WORD[m_dwNumIndeces];
        if (m_pdwIndices)
        {
            m_pvVertexs = new MYVERTEX[m_dwNumVer];
            if (m_pvVertexs)
            {
                int nVerticies = 0;

                hr = S_OK;
                for (int nCurrentY = 0; nCurrentY < nNumVertexY; nCurrentY++)
                {
                    for (int nCurrentX = 0; nCurrentX < nNumVertexX; nCurrentX++)
                    {
                        D3DXVECTOR3 vThisSize = ( D3DXVec3Multiply( (((float)nCurrentY)*vHeight), (vSize / ((float)(nNumVertexY - 1))) ) + 
                                                D3DXVec3Multiply( (((float)nCurrentX) *vWidth), (vSize / ((float)(nNumVertexX - 1))) ));
                        D3DXVECTOR3 vThisLocation = (vLocation + vThisSize);
                        float fTextureX = ((fTextureScaleX*AddVectorComponents(D3DXVec3Multiply(vThisSize, vWidth))) * (fFlipTexture ? -1 : 1));
                        float fTextureY = (-fTextureScaleY*AddVectorComponents(D3DXVec3Multiply(vThisSize, vHeight)));

                        m_pvVertexs[(nCurrentY * nNumVertexX) + nCurrentX] = MYVERTEX(vThisLocation, vNormal, fTextureX, fTextureY);

                        if (( (int)m_dwNumIndeces > (nVerticies * 6)) &&
                            (nCurrentY < (nNumVertexY - 1)) &&
                            (nCurrentX < (nNumVertexX - 1)))
                        {
                            // The number of indexs will not have the last row.
                            m_pdwIndices[(nVerticies * 6) + 0] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 1] = ((nCurrentY * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 2] = (((nCurrentY + 0) * nNumVertexY) + nCurrentX + 1);

                            m_pdwIndices[(nVerticies * 6) + 3] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 4] = (((nCurrentY + 0) * nNumVertexY) + nCurrentX + 1);
                            m_pdwIndices[(nVerticies * 6) + 5] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX + 1);

                            if (fFlipOrder)
                            {
                                WORD wTemp = m_pdwIndices[(nVerticies * 6) + 0];

                                m_pdwIndices[(nVerticies * 6) + 0] = m_pdwIndices[(nVerticies * 6) + 2];
                                m_pdwIndices[(nVerticies * 6) + 2] = wTemp;

                                wTemp = m_pdwIndices[(nVerticies * 6) + 3];
                                m_pdwIndices[(nVerticies * 6) + 3] = m_pdwIndices[(nVerticies * 6) + 5];
                                m_pdwIndices[(nVerticies * 6) + 5] = wTemp;
                            }

                            nVerticies++;
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT C3DObject::_PurgeDeviceObjects(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pIndexBuff); nIndex++)
    {
        SAFE_RELEASE(m_pVB[nIndex]);
        SAFE_RELEASE(m_pIndexBuff[nIndex]);
    }

    return S_OK;
}


HRESULT C3DObject::_GenerateDeviceObjects(void)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();
        IDirect3DDevice8 * pD3DDevice = m_pMain->GetD3DDevice();

        hr = S_OK;
        if (pD3DDevice && (!m_pVB[nCurrMonitor] || !m_pIndexBuff[nCurrMonitor]))
        {
            SAFE_RELEASE(m_pVB[nCurrMonitor]);              // Make sure both are set or both clear.
            SAFE_RELEASE(m_pIndexBuff[nCurrMonitor]);

            hr = pD3DDevice->CreateVertexBuffer((m_dwNumVer*sizeof(MYVERTEX)), D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX, D3DPOOL_MANAGED, &m_pVB[nCurrMonitor]);
            if (SUCCEEDED(hr))
            {
                MYVERTEX * pVertexArray;

                hr = m_pVB[nCurrMonitor]->Lock(0, 0, (BYTE **)&pVertexArray, 0);
                if (SUCCEEDED(hr))
                {
                    hr = pD3DDevice->CreateIndexBuffer((m_dwNumIndeces*sizeof(WORD)), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pIndexBuff[nCurrMonitor]);
                    if (SUCCEEDED(hr))
                    {
                        WORD * pwIndexes;

                        hr = m_pIndexBuff[nCurrMonitor]->Lock(0, (m_dwNumIndeces*sizeof(WORD)), (BYTE **)&pwIndexes, 0);
                        if (SUCCEEDED(hr))
                        {
                            // 1. Copy m_pvVertexs to pVertexArray
                            DWORD cbSize = (m_dwNumVer*sizeof(MYVERTEX));
                            CopyMemory(pVertexArray, m_pvVertexs, cbSize);

                            // 2. Copy m_pdwIndices[(nVerticies * 6) + 0] to y
                            cbSize = (m_dwNumIndeces*sizeof(WORD));
                            CopyMemory(pwIndexes, m_pdwIndices, cbSize);

                            m_pIndexBuff[nCurrMonitor]->Unlock();
                        }
                    }

                    m_pVB[nCurrMonitor]->Unlock();
                }

                if (FAILED(hr))
                {
                    SAFE_RELEASE(m_pVB[nCurrMonitor]);              // Make sure both are set or both clear.
                    SAFE_RELEASE(m_pIndexBuff[nCurrMonitor]);
                }
            }
        }
    }

    return hr;
}


HRESULT C3DObject::CombineObject(IDirect3DDevice8 * pD3DDevice, C3DObject * pObjToMerge)
{
    HRESULT hr = E_INVALIDARG;

    if (pObjToMerge && m_pdwIndices && m_dwNumIndeces && pObjToMerge->m_pdwIndices && pObjToMerge->m_dwNumIndeces)
    {
        hr = _PurgeDeviceObjects();

        if (pObjToMerge->m_vMin.x < m_vMin.x)
            m_vMin.x = pObjToMerge->m_vMin.x;
        if (pObjToMerge->m_vMin.y < m_vMin.y)
            m_vMin.y = pObjToMerge->m_vMin.y;
        if (pObjToMerge->m_vMin.z < m_vMin.z)
            m_vMin.z = pObjToMerge->m_vMin.z;

        if (pObjToMerge->m_vMax.x > m_vMax.x)
            m_vMax.x = pObjToMerge->m_vMax.x;
        if (pObjToMerge->m_vMax.y > m_vMax.y)
            m_vMax.y = pObjToMerge->m_vMax.y;
        if (pObjToMerge->m_vMax.z > m_vMax.z)
            m_vMax.z = pObjToMerge->m_vMax.z;

        if (SUCCEEDED(hr))
        {
            LPWORD pdwIndicesOld = m_pdwIndices;
            DWORD dwNumIndecesOld = m_dwNumIndeces;
            MYVERTEX * pvVertexsOld = m_pvVertexs;
            DWORD dwNumVerOld = m_dwNumVer;

            m_dwNumIndeces += pObjToMerge->m_dwNumIndeces;
            m_pdwIndices = new WORD[m_dwNumIndeces];

            m_dwNumVer += pObjToMerge->m_dwNumVer;
            m_pvVertexs = new MYVERTEX[m_dwNumIndeces];

            if (m_pvVertexs && m_pdwIndices)
            {
                DWORD dwCurrent;

                // Copy the original Index values.
                for (dwCurrent = 0; dwCurrent < dwNumIndecesOld; dwCurrent++)
                {
                    m_pdwIndices[dwCurrent] = pdwIndicesOld[dwCurrent];
                }

                // Append the new Index values.
                for (dwCurrent = 0; dwCurrent < pObjToMerge->m_dwNumIndeces; dwCurrent++)
                {
                    m_pdwIndices[dwCurrent + dwNumIndecesOld] = (pObjToMerge->m_pdwIndices[dwCurrent] + (WORD) dwNumVerOld);
                }

                // Copy the original vertex values.
                for (dwCurrent = 0; dwCurrent < dwNumVerOld; dwCurrent++)
                {
                    m_pvVertexs[dwCurrent] = pvVertexsOld[dwCurrent];
                }

                // Append the new vertex values.
                for (dwCurrent = 0; dwCurrent < pObjToMerge->m_dwNumVer; dwCurrent++)
                {
                    m_pvVertexs[dwCurrent + dwNumVerOld] = pObjToMerge->m_pvVertexs[dwCurrent];
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SAFE_DELETE(pdwIndicesOld);
            SAFE_DELETE(pvVertexsOld);
        }
    }
    else
    {
        SAFE_DELETE(m_pvVertexs);
        SAFE_DELETE(m_pdwIndices);
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr) && pObjToMerge && pObjToMerge->m_pNextObject)
    {
        hr = CombineObject(pD3DDevice, pObjToMerge->m_pNextObject);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT C3DObject::FinalCleanup(void)
{
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT C3DObject::DeleteDeviceObjects(void)
{
    return S_OK;
}


BOOL C3DObject::IsObjectViewable(IDirect3DDevice8 * pD3DDevice)
{
    D3DXMATRIX matWorld;

    pD3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
    return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, m_vMin, m_vMax );
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT C3DObject::Render(IDirect3DDevice8 * pD3DDevice)
{
    HRESULT hr = E_INVALIDARG;

    if (pD3DDevice && m_pMain && m_pdwIndices && m_pvVertexs)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        hr = _GenerateDeviceObjects();              // We may not have created them yet.  Especially for the current device (monitor)
        if (SUCCEEDED(hr))
        {
#ifdef RENDER_CORNERS
            D3DMATERIAL8 mtrl = {0};
            mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
            mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
            mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
            mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;
            pD3DDevice->SetMaterial(&mtrl);

            LPD3DXMESH pMesh;
            if( FAILED( D3DXCreateSphere( pD3DDevice, 1.0f, 12, 12, &pMesh, NULL ) ) )
                return hr;
            D3DXComputeNormals( pMesh );
            
            D3DXMATRIX matWorldSave;
            D3DXMATRIX matWorld;
            pD3DDevice->GetTransform( D3DTS_WORLD, &matWorldSave );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMax.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMax.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMax.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMax.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMin.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMin.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMin.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMin.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorldSave );
            SAFE_RELEASE( pMesh );
#endif

            if (IsObjectViewable(pD3DDevice))
            {
                /////////////////////
                // Draw Object
                /////////////////////
                hr = pD3DDevice->SetTexture(0, (m_pTexture ? m_pTexture->GetTexture() : NULL));

                if (m_pTexture->GetTexture())
                {
                    g_nTexturesRenderedInThisFrame++;
                }

                if (SUCCEEDED(hr) && m_pVB[nCurrMonitor] && m_pIndexBuff[nCurrMonitor])
                {
                    hr = pD3DDevice->SetStreamSource(0, m_pVB[nCurrMonitor], sizeof(MYVERTEX));
                    if (SUCCEEDED(hr))
                    {
                        hr = pD3DDevice->SetIndices(m_pIndexBuff[nCurrMonitor], 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pD3DDevice->SetVertexShader(D3DFVF_MYVERTEX);
                            if (SUCCEEDED(hr))
                            {
                                DWORD dwNumPrimitives = (m_dwNumIndeces / 3);

                                g_nTrianglesRenderedInThisFrame += dwNumPrimitives;
                                hr = pD3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVer, 0, dwNumPrimitives);
                            }
                        }
                    }
                }

                pD3DDevice->SetTexture(0, NULL);
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    if (m_pNextObject)
    {
        m_pNextObject->Render(pD3DDevice);
    }

    return hr;
}


HRESULT C3DObject::SetNextObject(C3DObject * pNextObject)
{
    _PurgeDeviceObjects();
    SAFE_DELETE(m_pNextObject);
    m_pNextObject = pNextObject;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\object.h ===
/*****************************************************************************\
    FILE: object.h

    DESCRIPTION:
        The caller will tell us what shape they want.  Normally a rectangle on a
    plane or a sphere.  We will then create the number vertexs the caller wants
    for that objectand create texture coordinates.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef OBJECT_H
#define OBJECT_H

#include "main.h"


struct MYVERTEX
{
    D3DXVECTOR3 pos;
    D3DXVECTOR3 norm;
    float tu;
    float tv;

    MYVERTEX() { }
    MYVERTEX(const D3DXVECTOR3& v, const D3DXVECTOR3& n, float _tu, float _tv)
        { pos = v; norm = n; 
          tu = _tu; tv = _tv;
        }
};

#define D3DFVF_MYVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------


extern int g_nTrianglesRenderedInThisFrame;


class C3DObject
{
public:
    HRESULT InitPlane(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, float fTextureScaleX, float fTextureScaleY,
                                DWORD dwMaxPixelSize, float fVisibleRadius);
    HRESULT InitPlaneStretch(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, DWORD dwMaxPixelSize);

    HRESULT Render(IDirect3DDevice8 * pDev);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);
    HRESULT SetNextObject(C3DObject * pNextObject);
    HRESULT CombineObject(IDirect3DDevice8 * pD3DDevice, C3DObject * pObjToMerge);
    BOOL IsObjectViewable(IDirect3DDevice8 * pD3DDevice);

    C3DObject(CMSLogoDXScreenSaver * pMain);
    virtual ~C3DObject();

public:

    D3DXMATRIX m_matIdentity;

    CTexture * m_pTexture;

    IDirect3DVertexBuffer8 * m_pVB[10];
    IDirect3DIndexBuffer8 * m_pIndexBuff[10];
    MYVERTEX * m_pvVertexs;
    DWORD m_dwNumVer;
    LPWORD m_pdwIndices;
    DWORD m_dwNumIndeces;

    C3DObject * m_pNextObject;
    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    D3DXVECTOR3 m_vMin;
    D3DXVECTOR3 m_vMax;

private:
    // Functions:
    HRESULT _PurgeDeviceObjects(void);
    HRESULT _GenerateDeviceObjects(void);
    HRESULT _ForPositiveSize(D3DXVECTOR3 * pvLocation, D3DXVECTOR3 * pvSize);
};


#endif // OBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winmain.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_MAIN_ACCEL                  113
#define IDR_MENU                        141
#define IDR_POPUP                       142
#define IDC_CURSOR1                     144
#define IDC_DEVICE_COMBO                1000
#define IDC_MODE_COMBO                  1001
#define IDC_WINDOWED_CHECKBOX           1012
#define IDC_STEREO_CHECKBOX             1013
#define IDC_FULLSCREEN_TEXT             1014
#define IDM_ABOUT                       40001
#define IDM_CHANGEDEVICE                40002
#define IDM_TOGGLEFULLSCREEN            40003
#define IDM_TOGGLESTART                 40004
#define IDM_SINGLESTEP                  40005
#define IDM_EXIT                        40006

/////////////////////////
// Dialogs
/////////////////////////
#define IDD_ABOUT                       143
#define IDD_CHANGEDEVICE                144
#define IDD_DIALOG_ADVANCED             145
#define IDD_DIALOG_CONFIG               146

/////////////////////////
// Dialog Controls
/////////////////////////
// Config Dialog
#define IDC_SLIDER_VIEWTIME             2002
#define IDC_SLIDER_SPEED                2003
#define IDC_SLIDER_QUALITY              2004
#define IDC_BUTTON_ADVANCEDQUALITY      2009
#define IDC_STATIC_VIEWTIME             2010
#define IDC_CHECK_MYPICTS               2013
#define IDC_CHECK_COMMONPICTS           2014
#define IDC_CHECK_WINPICTS              2015
#define IDC_CHECK_OTHERPICTS            2016
#define IDC_EDIT_OTHERPICTS             2017
#define IDC_BUTTON_BROWSEPICTS          2018
#define IDC_BUTTON_MONITORSETTINGS      2020

// Advanced Dialog
#define IDC_CHECK_SHOWSTATS             2036

#define IDC_RENDERQUALITY1              2040
#define IDC_RENDERQUALITY2              2041
#define IDC_RENDERQUALITY3              2042

// Textures
#define IDC_CHECK_TEXTR_FLOOR           2060
#define IDC_CHECK_TEXTR_WALLPAPER       2061
#define IDC_CHECK_TEXTR_CEILING         2062
#define IDC_CHECK_TEXTR_TOEGUARD        2063
#define IDC_CHECK_TEXTR_RUG             2064
#define IDC_CHECK_TEXTR_FRAME           2065

#define IDC_EDIT_TEXTR_FLOOR            2070
#define IDC_EDIT_TEXTR_WALLPAPER        2071
#define IDC_EDIT_TEXTR_CEILING          2072
#define IDC_EDIT_TEXTR_TOEGUARD         2073
#define IDC_EDIT_TEXTR_RUG              2074
#define IDC_EDIT_TEXTR_FRAME            2075

#define IDC_EDIT_TEXTR_FLOORSIZE        2080
#define IDC_EDIT_TEXTR_WALLPAPERSIZE    2081
#define IDC_EDIT_TEXTR_CEILINGSIZE      2082
#define IDC_EDIT_TEXTR_TOEGUARDSIZE     2083

#define IDC_STATIC1_TEXTR_FLOOR         2090
#define IDC_STATIC1_TEXTR_WALLPAPER     2091
#define IDC_STATIC1_TEXTR_CEILING       2092
#define IDC_STATIC1_TEXTR_TOEGUARD      2093
#define IDC_STATIC1_TEXTR_RUG           2094
#define IDC_STATIC1_TEXTR_FRAME         2095

#define IDC_STATIC2_TEXTR_FLOOR         2100
#define IDC_STATIC2_TEXTR_WALLPAPER     2101
#define IDC_STATIC2_TEXTR_CEILING       2102
#define IDC_STATIC2_TEXTR_TOEGUARD      2103
 
#define IDC_STATIC3_TEXTR_FLOOR         2110
#define IDC_STATIC3_TEXTR_WALLPAPER     2111
#define IDC_STATIC3_TEXTR_CEILING       2112
#define IDC_STATIC3_TEXTR_TOEGUARD      2113

#define MAX_CUSTOMTEXTURES              6



/////////////////////////
// String Resources
/////////////////////////
#define IDS_SSDISPLAYNAME               1
#define IDS_WALKSPEED                   4000
#define IDS_OTHERBROWSE_TITLE           4020
#define IDS_LOBBY_TITLE                 4021
#define IDS_LOBBY_TITLE2                4022
#define IDS_VIEW_TIME_DESC              4030



/////////////////////////
// Error Strings
/////////////////////////
#define IDS_ERROR_INVALIDOTHERPATH      5000
#define IDS_ERROR_TITLE_OTHERPATH       5001
#define IDS_ERROR_OTHERPATH_NOTDIR      5002





/////////////////////////
// D3DSaver Framework Resources
/////////////////////////
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

#define IDS_STATS_TEMPLATE              2213
#define IDS_STATS_D3DFMT_D16            2214
#define IDS_STATS_D3DFMT_D15S1          2215
#define IDS_STATS_D3DFMT_D24X8          2216
#define IDS_STATS_D3DFMT_D24S8          2217
#define IDS_STATS_D3DFMT_D24X4S4        2218
#define IDS_STATS_D3DFMT_D32            2219
#define IDS_STATS_DEVTYPE_PHW           2220
#define IDS_STATS_DEVTYPE_SPHW          2221
#define IDS_STATS_DEVTYPE_HW            2222
#define IDS_STATS_DEVTYPE_SHW           2223
#define IDS_STATS_DEVTYPE_MVP           2224
#define IDS_STATS_DEVTYPE_SMVP          2225
#define IDS_STATS_DEVTYPE_SWVP          2226
#define IDS_STATS_DEV_REF               2227
#define IDS_STATS_DEV_HAL               2228
#define IDS_STATS_DEV_SW                2229





/////////////////////////
// Bitmaps
/////////////////////////
#define IDB_FLOOR                       3500
#define IDB_CEILING                     3501
#define IDB_WALLS                       3502
#define IDB_FRAME                       3503
#define IDB_POWERPLUG                   3504
#define IDB_TOEGUARD                    3505
#define IDB_RUG                         3506




// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        145
#define _APS_NEXT_COMMAND_VALUE         40010
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\room.cpp ===
/*****************************************************************************\
    FILE: room.cpp

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "main.h"
#include "room.h"
#include "util.h"


// Ref-counting on the room tree is involved because it's a doubly linked tree with the root node constantly changing, so
// we need this mechanism to make sure we get the ref-count correct and don't leak.
int g_nLeakCheck = 0;

float g_fRoomWidthX = 100.0f;
float g_fRoomDepthZ = 200.0f;
float g_fRoomHeightY = 40.0f;

float g_fPaintingHeightY = (g_fRoomHeightY * SIZE_MAXPAINTINGSIZE_INWALLPERCENT);   // This is how much of the wall we want the painting to take up.

float g_fFudge = 0.1f;            // This will cause one object to be above another.

#define MAX_ROOMWALK_PATHS          2

#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)
#define NORMAL_NEG_Y            D3DXVECTOR3(0, -1, 0)
#define NORMAL_NEG_X            D3DXVECTOR3(-1, 0, 0)

#define NORMAL_Z                D3DXVECTOR3(0, 0, 1)
#define NORMAL_Y                D3DXVECTOR3(0, 1, 0)
#define NORMAL_X                D3DXVECTOR3(1, 0, 0)

#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)
#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)


PAINTING_LAYOUT g_LongRoomPaintings1[6];            // Both doors exist (1 & 2)

PAINTING_LAYOUT g_LongRoomPaintings2[7];            // Doors 0 & 1 exist (Must exit 1)
PAINTING_LAYOUT g_LongRoomPaintings3[7];            // Doors 0 & 1 exist (Must exit 2)



ROOM_FLOORPLANS g_RoomFloorPlans[] =
{
    {0, 1, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
    {0, 1, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},    // Duplicate to increase odds
    {0, 2, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
    {0, 2, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},    // Duplicate to increase odds
    {0, 1, 0, TRUE, TRUE, FALSE, ARRAYSIZE(g_LongRoomPaintings2), g_LongRoomPaintings2},
    {0, 2, 0, TRUE, FALSE, TRUE, ARRAYSIZE(g_LongRoomPaintings3), g_LongRoomPaintings3},

// These require entering door other than 0
//    {1, 2, 1, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
//    {2, 1, 1, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},

// This requuires supporting leaving the first door
//    {2, 0, TRUE, TRUE, FALSE, ARRAYSIZE(g_LongRoomPaintings2), g_LongRoomPaintings2},
};

ROOM_FLOORPLANS g_RoomFloorPlansLobby[] =
{
    {0, 1, 0, FALSE, TRUE, TRUE, 0, NULL},
    {0, 2, 0, FALSE, TRUE, TRUE, 0, NULL}
};


void InitLayout(void)
{
    static BOOL fInited = FALSE;

    if (!fInited)
    {
        int nIndex;
        fInited = TRUE;

        g_LongRoomPaintings1[0].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ / 4.0f)); g_LongRoomPaintings1[0].vNormal = NORMAL_X;                                  // Left Wall 1
        g_LongRoomPaintings1[1].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (2.0f / 4.0f))); g_LongRoomPaintings1[1].vNormal = NORMAL_X;                         // Left Wall 2
        g_LongRoomPaintings1[2].vLocation = D3DXVECTOR3((g_fRoomWidthX * (1.0f / 3.0f)), g_fPaintingHeightY, g_fRoomDepthZ-g_fFudge); g_LongRoomPaintings1[2].vNormal = NORMAL_NEG_Z;       // Front Wall 1
        g_LongRoomPaintings1[3].vLocation = D3DXVECTOR3((g_fRoomWidthX * (2.0f / 3.0f)), g_fPaintingHeightY, g_fRoomDepthZ-g_fFudge); g_LongRoomPaintings1[3].vNormal = NORMAL_NEG_Z;       // Front Wall 2
        g_LongRoomPaintings1[4].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ / 4.0f)); g_LongRoomPaintings1[4].vNormal = NORMAL_NEG_X;                // Right Wall 1
        g_LongRoomPaintings1[5].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (2.0f / 4.0f) )); g_LongRoomPaintings1[5].vNormal = NORMAL_NEG_X;      // Right Wall 2

        // g_LongRoomPaintings2 is a copy of g_LongRoomPaintings1 plus another painting.
        for (nIndex = 0; nIndex < ARRAYSIZE(g_LongRoomPaintings1); nIndex++)
        {
            g_LongRoomPaintings2[nIndex].vLocation = g_LongRoomPaintings1[nIndex].vLocation;
            g_LongRoomPaintings2[nIndex].vNormal = g_LongRoomPaintings1[nIndex].vNormal;
        }
        g_LongRoomPaintings2[6].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (3.0f / 4.0f) )); g_LongRoomPaintings2[6].vNormal = NORMAL_NEG_X;      // Right Wall 3

        // g_LongRoomPaintings3 is a copy of g_LongRoomPaintings1 plus another painting.
        for (nIndex = 0; nIndex < ARRAYSIZE(g_LongRoomPaintings1); nIndex++)
        {
            g_LongRoomPaintings3[nIndex].vLocation = g_LongRoomPaintings1[nIndex].vLocation;
            g_LongRoomPaintings3[nIndex].vNormal = g_LongRoomPaintings1[nIndex].vNormal;
        }
        g_LongRoomPaintings3[6].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (3.0f / 4.0f))); g_LongRoomPaintings3[6].vNormal = NORMAL_X;                         // Left Wall 3
    }
}


//-----------------------------------------------------------------------------
// Name: CTheRoom()
// Desc: Constructor
//-----------------------------------------------------------------------------
CTheRoom::CTheRoom(BOOL fLobby, CMSLogoDXScreenSaver * pMain, CTheRoom * pEnterRoom, int nBatch) 
                        : m_objWall1(pMain), m_objCeiling(pMain), m_objToeGuard1(pMain), m_objFloor(pMain),
                          m_theRug(pMain), m_thePowerSocket(pMain), m_nBatch(nBatch), m_cRef(1)
{
    InitLayout();

    // Initialize member variables
    D3DXMatrixIdentity(&m_matIdentity);
    m_pEnterRoom = NULL;
    m_pFirstRoom = NULL;
    m_pLeftRoom = NULL;
    m_pRightRoom = NULL;

    m_fRoomCreated = FALSE;
    m_fVisible = FALSE;
    m_fLowPriority = FALSE;
    m_fLobby = fLobby;
    m_pMain = pMain;
    m_fCurrentRoom = FALSE;
    IUnknown_Set((IUnknown **) &m_pEnterRoom, pEnterRoom);

    if (fLobby)
    {
        m_pFloorPlan = &g_RoomFloorPlansLobby[GetRandomInt(0, ARRAYSIZE(g_RoomFloorPlansLobby)-1)];
    }
    else
    {
        m_pFloorPlan = &g_RoomFloorPlans[GetRandomInt(0, ARRAYSIZE(g_RoomFloorPlans)-1)];   // ARRAYSIZE(g_RoomFloorPlans)-1
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pPaintings); nIndex++)
    {
        m_pPaintings[nIndex] = NULL;
    }

    g_nLeakCheck++;
}


CTheRoom::~CTheRoom()
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pPaintings); nIndex++)
    {
        SAFE_DELETE(m_pPaintings[nIndex]);
    }

    FinalCleanup();     // Just in case someone forgot to call FinalCleanup() in an error condition.
    g_nLeakCheck--;
}


HRESULT CTheRoom::_InitPaintings(void)
{
    HRESULT hr = S_OK;

    if (!g_pPictureMgr || !m_pFloorPlan)
    {
        return E_FAIL;
    }

    if (m_pPaintings[0])
    {
        return S_OK;
    }

#define FRAMESIZE_X     0.062696f      // This is the frame size for frame.bmp
#define FRAMESIZE_Y     0.087336f      // This is the frame size for frame.bmp

    float fMaxPaintingWH = (g_fRoomHeightY * 0.4f);       // The picture can not be more than one half the size of the wall.
    float fScale = 1.0f;

    for (int nIndex = 0; (nIndex < ARRAYSIZE(m_pPaintings)) && (nIndex < m_pFloorPlan->nPaintings) && SUCCEEDED(hr); nIndex++)
    {
        m_pPaintings[nIndex] = new CPainting(m_pMain);

        if (m_pPaintings[nIndex])
        {
            DWORD dwMaxPixelSize = ((3 * g_dwHeight) / 4);
            CTexture * pPaintingTexture = NULL;

            hr = g_pPictureMgr->GetPainting(m_nBatch, nIndex, 0, &pPaintingTexture);
            if (SUCCEEDED(hr))
            {
                D3DXVECTOR3 vPaintingLoc = m_pFloorPlan->pPaintingsLayout[nIndex].vLocation;
                D3DXVECTOR3 vPainting