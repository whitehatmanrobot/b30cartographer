                  

                    }
                }

                //
                // If we haven't already failed, try to impersonate and
                // revert. This verifies that the user has batch logon
                // permission.
                //

                if (!failedCheck) {

                    impersonateError = OscImpersonate(clientState);
                    if (impersonateError != ERROR_SUCCESS) {

                        if ( impersonateError == ERROR_LOGON_TYPE_NOT_GRANTED )
                        {
                            BinlPrint(( DEBUG_OSC_ERROR,
                                        "!!Error 0x%08x - CheckDomain: Batch Logon type not granted\n",
                                        impersonateError ));
                            Error = ERROR_BINL_LOGON_TYPE_NOT_GRANTED;
                        }
                        else
                        {
                            BinlPrint(( DEBUG_OSC_ERROR, "!!Error 0x%08x - CheckDomain: login failed\n", impersonateError ));
                            Error = ERROR_BINL_USER_LOGIN_FAILED;
                        }

                    } else {

                        OscRevert(clientState);
                    }

                }

                //
                // Once we've done this once, don't need to do it again.
                //

                if ( OscAddVariableW( clientState, "CHECKDOMAIN", L"0" ) != ERROR_SUCCESS )
                {
                    // don't overwrite the "Error" value unless we need to
                    Error = OscAddVariableW( clientState, "CHECKDOMAIN", L"0" );
                }
            }

            if ( lstrcmpiA( NameLoc, "INSTALL" ) == 0 )
            {
                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }
                RspBinaryDataLength = sizeof(CREATE_DATA);

                //
                // This will fill in RspBinaryData with the CREATE_DATA
                // information.
                //

                Error = OscInstallClient( RequestContext, clientState, (PCREATE_DATA)RspBinaryData );

            }
            else if ( lstrcmpiA( NameLoc, "LAUNCH" ) == 0 )
            {
                //
                // Launch the "LaunchFile" indicated in a SIF. Mainly used to
                // launch tools and other real-mode utilities.  In the case of
                // the command console, we need to copy this sif and fix it up
                // so that it looks like a textmode setup.
                //
                PCHAR pTemplatePath = OscFindVariableA( clientState, "SIF" );
                PCREATE_DATA pCreate;

                if ( pTemplatePath[0] == '\0' ) {
                    BinlPrint(( DEBUG_OSC_ERROR, "Missing SIF variable\n" ));
                    OscAddVariableA( clientState, "SUBERROR", "SIF" );
                    Error = ERROR_BINL_MISSING_VARIABLE;
                    goto SendResponse;    // skip the rest and just send it.
                }

                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                }

                RspMessageLength = strlen("LAUNCH") + 1 + sizeof(CREATE_DATA);
                RspMessage = BinlAllocateMemory( RspMessageLength );
                if ( RspMessage == NULL ) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                strcpy(RspMessage, "LAUNCH");

                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                ZeroMemory( RspBinaryData, sizeof(CREATE_DATA) );

                pCreate = (PCREATE_DATA)RspBinaryData;
                pCreate->VersionNumber = OSC_CREATE_DATA_VERSION;

                if (OscSifIsCmdConsA(pTemplatePath)) {
                    //
                    // Setup the client for an install
                    //
                    Error = OscSetupClient( clientState, FALSE );

                    if (Error != ERROR_SUCCESS) {
                        goto SendResponse;
                    }

                    pTemplatePath = (PCHAR)FilePath;
                    strcpy(pTemplatePath, IntelliMirrorPathA);
                    strcat(pTemplatePath, "\\");
                    strcat(pTemplatePath, OscFindVariableA( clientState, "SIFFILE" ));
                    

                    pCreate->RebootParameter = OSC_REBOOT_COMMAND_CONSOLE_ONLY;
                } 

                if (OscSifIsASR(pTemplatePath)) {
                    PSTR pGuid,pPathToAsrFile;
                    
                    //
                    // Setup the client for an install
                    //
                    Error = OscSetupClient( clientState, FALSE );

                    if (Error != ERROR_SUCCESS) {
                        goto SendResponse;
                    }

                    pTemplatePath = (PCHAR)FilePath;
                    strcpy(pTemplatePath, IntelliMirrorPathA);
                    strcat(pTemplatePath, "\\");
                    strcat(pTemplatePath, OscFindVariableA( clientState, "SIFFILE" ));
                    
#if 0
                    pGuid = OscFindVariableA( clientState, "GUID" );
                    pPathToAsrFile = BinlAllocateMemory( sizeof("ASRFiles\\") + strlen(pGuid) + sizeof(".sif") + 1 );
                    if (pPathToAsrFile) {
                        strcat(pPathToAsrFile, "ASRFiles\\");
                        strcat(pPathToAsrFile, pGuid  );
                        strcat(pPathToAsrFile, ".sif" );

                        WritePrivateProfileStringA( 
                                          OSCHOOSER_SIF_SECTIONA,
                                          "ASRFile",
                                          pPathToAsrFile,
                                          pTemplatePath );
                                          
                        BinlFreeMemory( pPathToAsrFile );
                    }
#endif

                    pCreate->RebootParameter = OSC_REBOOT_ASR;

                }


                GetPrivateProfileStringA( OSCHOOSER_SIF_SECTIONA,
                                          "LaunchFile",
                                          "",
                                          pCreate->NextBootfile,
                                          sizeof(pCreate->NextBootfile),
                                          pTemplatePath );
                strcpy(pCreate->SifFile, pTemplatePath + strlen(IntelliMirrorPathA) + 1); // skip the next backslash
                BinlPrint(( DEBUG_OSC_ERROR, "Client will use SIF file %s\n", pCreate->SifFile ));
                BinlPrint(( DEBUG_OSC_ERROR, "Client rebooting to %s\n", pCreate->NextBootfile ));

                RspBinaryDataLength = sizeof(CREATE_DATA);

                goto SendResponse;    // skip the rest and just send it.
            }
            else if ( lstrcmpiA( NameLoc, "RESTART" ) == 0 )
            {
                //
                // NOTE: This is very similar to the GETCREATE processing
                // except for the error case. We send down a packet with
                // only the create data in it.
                //

                //
                // Make RspMessage be NULL.
                //
                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                    RspMessage = NULL;
                }
                RspMessageLength = 0;

                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                Error = OscGetCreateData( RequestContext, clientState, (PCREATE_DATA)RspBinaryData );

                if ( Error == ERROR_SUCCESS ) {
                    RspBinaryDataLength = sizeof(CREATE_DATA);
                    goto SendResponse;    // skip the rest and just send it.
                } else {
                    BinlAssert( sizeof(TmpName) >= sizeof("RSTRTERR") );

                    BinlFreeMemory(RspBinaryData);
                    RspBinaryData = NULL;

                    strcpy(TmpName, "RSTRTERR");
                    NameLoc = TmpName;
                    Error = ERROR_SUCCESS;
                }

            }
        }

        //
        // Try to retrieve the next screen
        //
        if ( Error == ERROR_SUCCESS )
        {
            //
            // If NULL message, then send down the welcome screen.
            //
            if ( NameLoc == NULL || *NameLoc == '\0' )
            {
                if ( _snwprintf( FilePath,
                                 sizeof(FilePath) / sizeof(FilePath[0]),
                                 L"%ws\\OSChooser\\%s",
                                 IntelliMirrorPathW,
                                 DEFAULT_SCREEN_NAME
                                 ) == -1 ) {
                    Error = ERROR_BAD_PATHNAME;

                } else {

                    BinlPrint(( DEBUG_OSC, "NULL screen name so we are retrieving the Welcome Screen.\n"));
                }
            }
            else
            {
                WCHAR NameLocW[ MAX_PATH ];
                ULONG NameLocLength;

                //
                // Create path to possible OSC file. Should look something like:
                //  "D:\RemoteInstall\OSChooser\English\NameLoc.OSC"
                BinlAssert( NameLoc );

                NameLocLength = strlen(NameLoc) + 1;
                if (NameLocLength > MAX_PATH) {
                    NameLocLength = MAX_PATH-1;
                    NameLocW[ MAX_PATH-1 ] = L'\0';
                }

                mbstowcs( NameLocW, NameLoc, NameLocLength );

#if DBG
                if (OscWatchVariable[0] != '\0') {
                    DbgPrint("Looking for screen <%ws>\n", NameLocW);
                }
#endif

                if ( _snwprintf( FilePath,
                                 sizeof(FilePath) / sizeof(FilePath[0]),
                                 L"%ws\\OSChooser\\%ws\\%ws.OSC",
                                 IntelliMirrorPathW,
                                 OscFindVariableW( clientState, "LANGUAGE" ),
                                 NameLocW
                                 ) == -1 ) {
                    Error = ERROR_BAD_PATHNAME;
                }
            }
        }
    }

    if ( Error == ERROR_SUCCESS )
    {
        //
        // If we find the file, load it into memory.
        //
        BinlPrint(( DEBUG_OSC, "Retrieving screen file: '%ws'\n", FilePath));

        hfile = CreateFile( FilePath, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if ( hfile != INVALID_HANDLE_VALUE )
        {
            DWORD FileSize;
            //
            // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
            // display it.
            //
            FileSize = GetFileSize( hfile, NULL );
            if ( FileSize != 0xFFFFffff )
            {
                DWORD dwRead = 0;

                //
                // This might be non-NULL if we looped back to GrabAnotherScreen.
                //
                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                }
                RspMessage = BinlAllocateMemory( FileSize + RspBinaryDataLength + 3 );
                if ( RspMessage == NULL )
                {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                }
                else
                {
                    RspMessageLength = 0;
                    RspMessage[0] = '\0';

                    while ( dwRead != FileSize )
                    {
                        BOOL b;
                        DWORD dw;
                        b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                        if (!b)
                        {
                            BinlPrint(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                        dwRead, FileSize - dwRead, FilePath ));
                            Error = GetLastError( );
                            break;
                        }
                        dwRead += dw;
                    }

                    RspMessageLength = FileSize + 1;
                    RspMessage[RspMessageLength - 1] = '\0';
                }
            }
            else
            {
                BinlPrintDbg((DEBUG_OSC, "!!Error - Could not determine file size.\n"));
                Error = GetLastError();
            }

            CloseHandle( hfile );
        }
        else
        {
            BinlPrint((DEBUG_OSC, "!!Error - Did not find screen file: '%ws'\n", FilePath));
            Error = GetLastError();
            OscAddVariableW( clientState, "SUBERROR", FilePath );
        }
    }

    //
    // Check the outgoing screen for special NAMEs
    //
    if ( Error == ERROR_SUCCESS )
    {
        //
        // Read the screen name from the "NAME" section of the file. This allows
        // the admin to have different screens with the same "NAME" section but
        // that have a different layout and/or text associated with them.
        //
        PCHAR ServerMeta = RspMessage;
        while ( ServerMeta && !!*ServerMeta )
        {
            CHAR tmpCh = '>';   // save (default)
            LPSTR EndofLine;
            ServerMeta = StrStrIA( ServerMeta, "<META " );
            if ( !ServerMeta )
                break;

            // Find the end of the meta line
            EndofLine = StrChrA( ServerMeta, '>' );
            if ( !EndofLine )
                break;

            *EndofLine = '\0';  // terminate

            // Is it a server side meta?
            ServerMeta = StrStrIA( ServerMeta, "SERVER" );
            if ( !ServerMeta )
                goto SkipLine;  // nope, skip it

            // Find the action
            ServerMeta = StrStrIA( ServerMeta, "ACTION=" );
            if ( !ServerMeta )
                goto SkipLine;  // nothing to do, skip it

            ServerMeta += sizeof("ACTION=") - sizeof("");

            // If the ACTION encapsulated in a pair of quotes, the only use
            // the part that is within the quotes.
            if ( *ServerMeta == '\"' ) {
                *EndofLine = '>';   // restore
                ServerMeta++;
                EndofLine = StrChrA( ServerMeta, '\"' );
                if ( EndofLine ) {
                    tmpCh = '\"';   // save
                } else {
                    EndofLine = StrChrA( ServerMeta, '>' );
                }
                *EndofLine = '\0';  // terminate
            }

            BinlPrintDbg(( DEBUG_OSC, "Processing SERVER side ACTION: %s\n", ServerMeta ));

            if ( StrCmpNIA( ServerMeta, "ENUM ", sizeof("ENUM ")-sizeof("") ) == 0 )
            {
                PCHAR pOptionBuffer;
                ULONG OptionBufferLength;
                PCHAR pOptionBufferTemp;
                ULONG OptionBufferLengthTemp;
                PCHAR pCurOptionBuffer;
                PCHAR pDirToEnum;
                CHAR SaveChar;

                //
                // They are asking for the screen that has the listing
                // of the different types of network booted installations.
                //
                ServerMeta += sizeof("ENUM ") - sizeof("");

                OscResetVariable( clientState, "OPTIONS" );

                while (*ServerMeta != '\0') {

                    //
                    // Skip leading blanks
                    //
                    while (*ServerMeta == ' ') {
                        ServerMeta++;
                    }

                    if (*ServerMeta == '\0') {
                        break;
                    }

                    //
                    // Save beginning of the dir
                    //
                    pDirToEnum = ServerMeta;

                    //
                    // Skip to the end of the word
                    //
                    while ((*ServerMeta != ' ') &&
                           (*ServerMeta != '\"') &&
                           (*ServerMeta != '>') &&
                           (*ServerMeta != '\0')){
                        ServerMeta++;
                    }

                    //
                    // Temporarily terminate the word, we will restore it in this loop.
                    //
                    SaveChar = *ServerMeta;
                    *ServerMeta = '\0';

                    BinlPrintDbg(( DEBUG_OSC, "Processing SERVER side ACTION: ENUM, directory %s\n", pDirToEnum));

                    //
                    // Start a buffer for this directory
                    //
                    OptionBufferLengthTemp = 512;
                    pOptionBufferTemp = BinlAllocateMemory( OptionBufferLengthTemp );

                    if ( pOptionBufferTemp == NULL )
                    {
                        OscResetVariable( clientState, "OPTIONS" );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        break;
                    }

                    BinlAssert(RspBinaryData == NULL);
                    *pOptionBufferTemp = '\0';

                    SearchAndGenerateOSMenu( &pOptionBufferTemp,
                                             &OptionBufferLengthTemp,
                                             pDirToEnum,
                                             clientState
                                           );

                    if (*pOptionBufferTemp == '\0') {
                        BinlFreeMemory( pOptionBufferTemp );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        continue;
                    }

                    pCurOptionBuffer = OscFindVariableA( clientState, "OPTIONS" );

                    OptionBufferLength = strlen(pCurOptionBuffer) + sizeof("");

                    pOptionBuffer = BinlAllocateMemory( OptionBufferLength + OptionBufferLengthTemp );

                    if (pOptionBuffer == NULL) {
                        BinlFreeMemory( pOptionBufferTemp );
                        OscResetVariable( clientState, "OPTIONS" );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        break;
                    }

                    strcpy( pOptionBuffer, pCurOptionBuffer );
                    strcat( pOptionBuffer, pOptionBufferTemp);

                    OscAddVariableA( clientState, "OPTIONS", pOptionBuffer );

                    BinlFreeMemory( pOptionBuffer );
                    BinlFreeMemory( pOptionBufferTemp );

                    *ServerMeta = SaveChar;
                    if (SaveChar != '\0') {
                        ServerMeta++;
                    }

                }


                //
                // If this generated no options, send down the
                // NOOSES screen.
                //
                pOptionBuffer = OscFindVariableA( clientState, "OPTIONS" );
                if (*pOptionBuffer == '\0') {
                    BinlAssert( sizeof(TmpName) >= sizeof("NOOSES") );
                    strcpy(TmpName, "NOOSES");
                    NameLoc = TmpName;
                    goto GrabAnotherScreen;
                }

            }
            else if ( StrCmpNIA( ServerMeta, "WARNING", sizeof("WARNING")-sizeof("") ) == 0 )
            {
                LPSTR pszSIF = OscFindVariableA( clientState, "SIF" );
                if ( pszSIF )
                {
                    //
                    // lets check if we're repartitioning or not.  if we aren't,
                    // then there's no need to show the warning screen.
                    //
                    CHAR szRepartition[ 64 ];
                    BOOL DoRepartitionWarning = TRUE;

                    GetPrivateProfileStringA( "RemoteInstall",
                                              "Repartition",
                                              "Yes",
                                              szRepartition,
                                              sizeof(szRepartition)/sizeof(szRepartition[0]),
                                              pszSIF );

                    if ( StrCmpIA( szRepartition, "no") != 0) {
                        LPSTR pszPart;
                         
                        //
                        // check if 'repartition' points to an OSC variable
                        //
                        if (szRepartition[0] = '%' && szRepartition[strlen(szRepartition)-1] == '%') {
                            szRepartition[strlen(szRepartition)-1] = '\0';
                        
                            pszPart= OscFindVariableA( clientState, &szRepartition[1] );
                            if (StrCmpIA( pszPart, "no") == 0) {
                                DoRepartitionWarning = FALSE;
                            }
                        }
                    } else {
                        DoRepartitionWarning = FALSE;
                    }
                        
                    if ( DoRepartitionWarning == FALSE ) {
                        // skip the warning screen
                        BinlPrintDbg(( DEBUG_OSC, "Repartition == NO. Skipping WARNING screen.\n" ));

                        *EndofLine = '>';   // restore
                        ServerMeta = StrStrIA( RspMessage, "ENTER" );
                        if ( ServerMeta )
                        {
                            ServerMeta = StrStrIA( ServerMeta, "HREF=" );
                            ServerMeta += sizeof("HREF=") - sizeof("");
                            // If the HREF encapsulated in a pair of quotes, the only use
                            // the part that is within the quotes.
                            if ( *ServerMeta == '\"' ) {
                                ServerMeta ++;
                                EndofLine = StrChrA( ServerMeta, '\"' );
                                if ( !EndofLine) {
                                    EndofLine = StrChrA( ServerMeta, '>' );
                                }
                                if ( EndofLine ) {
                                    *EndofLine = '\0';  // terminate
                                }
                            }
                            NameLoc = ServerMeta;
                            goto GrabAnotherScreen;
                        }
                    }
                }
            }
            else if ( StrCmpNIA( ServerMeta, "FILTER ", sizeof("FILTER ")-sizeof("") ) == 0 )
            {
                ULONG OptionCount;

                //
                // The options on the form on this screen are supposed
                // to be filtered by looking at the GPO list for this
                // client. This call may modify RspMessageLength, but
                // it will only shorten it.
                //
                // NOTE: We assume that the data we want to modify is after
                // the META SERVER ACTION tag. This assumption shows up in
                // two ways:
                // a) The second parameter to FilterFormOptions is the place
                // to start filtering -- we pass it EndOfLine+1 (that is,
                // the point right after the FILTER name) because
                // we have put a NULL character at EndOfLine. But this means
                // it won't process any of the screen before the META tag.
                // b) FilterFormOptions may remove parts of the message at
                // any place after the "start filtering" location -- so in
                // order for the code below after SkipLine: to still work,
                // we have to assume that the place in the message that
                // EndOfLine points to has not changed.
                //
                OptionCount = FilterFormOptions(
                                 RspMessage,   // start of message
                                 EndofLine+1,  // where we start filtering -- after the FILTER name,
                                               // since that is NULL-terminated.
                                 &RspMessageLength,
                                 ServerMeta + sizeof("FILTER ") - sizeof(""),
                                 clientState);

                //
                // If the result of the filtering is no options, then
                // send down the NOCHOICE screen.
                //

                if (OptionCount == 0) {
                    BinlAssert( sizeof(TmpName) >= sizeof("NOCHOICE") );
                    strcpy(TmpName, "NOCHOICE");
                    NameLoc = TmpName;
                    goto GrabAnotherScreen;
                }
            }
            else if ( StrCmpNIA( ServerMeta, "CHECKGUID ", sizeof("CHECKGUID ")-sizeof("") ) == 0 )
            {
                //
                //  Search the DS for accounts that have this same GUID and
                //  fill in the form with all the dups.  If it's fatal, tell
                //  them so here, otherwise allow them to continue warned.
                //

                PCHAR successScreen;
                PCHAR failureScreen;

                Error = OscCheckMachineDN( clientState );

                //
                // If there are DN warnings, then the text is saved off in
                // %SUBERROR% string.
                //

                ServerMeta += sizeof("CHECKGUID ") - sizeof("");
                successScreen = ServerMeta;
                while (*successScreen == ' ') {
                    successScreen++;
                }

                failureScreen = successScreen;
                while (*failureScreen != ' ' &&
                       *failureScreen != '>' &&
                       *failureScreen != '\0' ) {

                    failureScreen++;
                }
                if (*failureScreen == ' ') {

                    // terminate the success screen name

                    *failureScreen = '\0';
                    failureScreen++;

                    //
                    //  if they neglected to put a second parameter, then they
                    //  must not care about the warning case.
                    //

                    while (*failureScreen == ' ') {
                        failureScreen++;
                    }
                }

                if ((*failureScreen == '>') || (*failureScreen == '\0')) {
                    failureScreen = successScreen;
                }

                if (Error == ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND) {

                    //
                    //  in the case of failure, we grab the second parameter
                    //  to CHECKGUID as the warning screen.
                    //

                    NameLoc = failureScreen;

                } else if (Error != ERROR_SUCCESS) {

                    goto SendResponse;

                } else {

                    NameLoc = successScreen;
                }

                //
                //  in the case of success, we grab the first parameter
                //  to CHECKGUID as the success screen.
                //

                Error = ERROR_SUCCESS;
                goto GrabAnotherScreen;
            }
            else if ( StrCmpNIA( ServerMeta, "DNRESET", sizeof("DNRESET")-sizeof("") ) == 0 )
            {
                //
                //  the client went back to select between auto and custom,
                //  therefore we need to reset machineou, machinename,
                //  machinedn, and machinedomain
                //

                clientState->fHaveSetupMachineDN = FALSE;
                OscResetVariable( clientState, "MACHINEOU" );
                OscResetVariable( clientState, "MACHINENAME" );
                OscResetVariable( clientState, "MACHINEDN" );
                OscResetVariable( clientState, "MACHINEDOMAIN" );
                OscResetVariable( clientState, "NETBIOSNAME" );
                OscResetVariable( clientState, "DEFAULTDOMAINOU" );
            }
SkipLine:
            *EndofLine = tmpCh;  // restore
            EndofLine++;
            ServerMeta = EndofLine;
        }
    }

SendResponse:
    //
    // If there were any errors, switch to the error screen.
    //
    if ( Error != ERROR_SUCCESS )
    {
        //
        // Send down message about account creation failure.
        //
        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
            RspMessage = NULL;  // paranoid
        }
        if ( RspBinaryData )
        {
            BinlFreeMemory( RspBinaryData );
            RspBinaryData = NULL;  // paranoid
        }
        Error = GenerateErrorScreen( &RspMessage,
                                     &RspMessageLength,
                                     Error,
                                     clientState );
        BinlAssert( Error == ERROR_SUCCESS );
        if ( Error != ERROR_SUCCESS )
            goto Cleanup;

        // Don't send this
        RspBinaryDataLength = 0;
    }

    //
    // Make some adjustments to the outgoing screen
    //
    if ( Error == ERROR_SUCCESS )
    {
        if (RspMessage) {

            //
            // Do replacements for dynamic screens
            //
            SearchAndReplace(   clientState->Variables,
                                &RspMessage,
                                clientState->nVariables,
                                RspMessageLength,
                                RspBinaryDataLength);
            RspMessageLength = strlen( RspMessage ) + 1;

            //
            // NULL terminate RspMessage, and copy binary data if any exists.
            //
            RspMessage[RspMessageLength-1] = '\0';

            if (RspBinaryDataLength) {
                memcpy(RspMessage + RspMessageLength, RspBinaryData, RspBinaryDataLength);
                RspMessageLength += RspBinaryDataLength;
            }
        } else {

            //
            // No RspMessage, RspBinaryData must be the entire thing.
            //
            BinlAssert( RspBinaryData );

            RspMessage = RspBinaryData;
            RspBinaryData = NULL;
            RspMessageLength = RspBinaryDataLength;
            RspBinaryDataLength = 0;
        }
    }

    //
    // Send out a signed response
    //
    BinlAssert( RspMessage );
    // BinlPrint((DEBUG_OSC, "Sending Signed:\n%s\n", RspMessage));

#if DBG
    if (OscWatchVariable[0] != '\0') {
        DbgPrint("VALUE OF <%s> IS <%ws>\n", OscWatchVariable, OscFindVariableW(clientState, OscWatchVariable));
    }
#endif

    Error = OscSendSignedMessage( RequestContext, clientState, RspMessage, RspMessageLength );

Cleanup:
    //
    // Free any memory the we allocated for the screen.
    //
    if ( RspMessage ) {
        BinlFreeMemory( RspMessage );
    }
    if ( RspBinaryData ) {
        BinlFreeMemory( RspBinaryData );
    }

    //  Clear the unencrypted buffer to ensure private data is erased.
    ZeroMemory(&signedMessage->SequenceNumber, signedMessage->Length);

    return Error;
}

//
//
//
DWORD
OscProcessSetupRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message sent by textmode setup on a client.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SPUDP_PACKET UNALIGNED * Message = (SPUDP_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;

    PSPUDP_PACKET SuccessPacket;
    SPUDP_PACKET ErrorResponsePacket;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    ULONG SuccessPacketLength;

    PNETCARD_RESPONSE_DATABASE pInfEntry = NULL;

    PSP_NETCARD_INFO_REQ pReqData;
    PSP_NETCARD_INFO_RSP pRspData;

    PLIST_ENTRY CopyHead;
    PLIST_ENTRY CopyListEntry;
    PNETCARD_FILECOPY_PARAMETERS cpyParam;
    PWCHAR pTmp;

    TraceFunc("OscProcessSetupRequest( )\n");

    //
    // All clients start with at least one unsigned request. When we get an
    // unsigned request, the client may have rebooted and be asking for a
    // different request with the same sequence number. To avoid having
    // to check for this, we don't bother resending unsigned messages. We
    // do save the incoming sequence number since we use that for sending
    // the response.
    //

    clientState->LastSequenceNumber = Message->SequenceNumber;

    //
    // Get info from the INF file.
    //
    pReqData = (PSP_NETCARD_INFO_REQ)(&(Message->Data[0]));
    Error = NetInfFindNetcardInfo(pReqData->SetupPath,
                                  pReqData->Architecture,
                                  pReqData->Version,
                                  &pReqData->CardInfo,
                                  NULL,
                                  &pInfEntry
                                 );


    if (Error != ERROR_SUCCESS) {

        BinlPrint(( DEBUG_OSC_ERROR, "OscProcessSetupRequest( Card not found ) \n"));

SendErrorResponse:
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscProcessSetupRequest( ) sending Error response \n"));

        memcpy(ErrorResponsePacket.Signature, NetcardErrorSignature, 4);
        ErrorResponsePacket.Length = sizeof(ULONG) * 2;
        ErrorResponsePacket.RequestType = Message->RequestType;
        ErrorResponsePacket.Status = STATUS_INVALID_PARAMETER;

        TempClientState.LastResponse = (PUCHAR)&ErrorResponsePacket;
        TempClientState.LastResponseLength = 12;

        Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

        goto CleanUp;

    }

    //
    //  We found a match, so construct a response.  We first need to
    //  calculate how big the buffer needs to be.
    //
    CopyHead = &pInfEntry->FileCopyList;

    SuccessPacketLength = sizeof(SP_NETCARD_INFO_RSP) - sizeof(WCHAR); // everything except the data

    SuccessPacketLength += sizeof(WCHAR) * (wcslen(pInfEntry->DriverName) +
                                            wcslen(pInfEntry->InfFileName) + 4);

    CopyListEntry = CopyHead->Flink;
    while (CopyListEntry != CopyHead) {

        cpyParam = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(CopyListEntry,
                                                                    NETCARD_FILECOPY_PARAMETERS,
                                                                    FileCopyListEntry
                                                                   );
        SuccessPacketLength += cpyParam->SourceFile.Length;

        if (cpyParam->SourceFile.Buffer[cpyParam->SourceFile.Length / sizeof(WCHAR)] != UNICODE_NULL) {
            SuccessPacketLength += sizeof(WCHAR);
        }

        if (cpyParam->DestFile.Buffer == NULL) {
            SuccessPacketLength += sizeof(UNICODE_NULL);
        } else {
            SuccessPacketLength += cpyParam->DestFile.Length;
            if (cpyParam->DestFile.Buffer[cpyParam->DestFile.Length / sizeof(WCHAR)] != UNICODE_NULL) {
                SuccessPacketLength += sizeof(WCHAR);
            }

        }

        CopyListEntry = CopyListEntry->Flink;
    }


    //
    // Build response message
    //
    RspMessage = BinlAllocateMemory(SuccessPacketLength);

    if (RspMessage == NULL) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto SendErrorResponse;
    }

    pRspData = (PSP_NETCARD_INFO_RSP)RspMessage;
    pRspData->cFiles = 0;
    pTmp = &(pRspData->MultiSzFiles[0]);

    CopyListEntry = CopyHead->Flink;
    while (CopyListEntry != CopyHead) {

        pRspData->cFiles++;

        cpyParam = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(CopyListEntry,
                                                                    NETCARD_FILECOPY_PARAMETERS,
                                                                    FileCopyListEntry
                                                                   );

        RtlCopyMemory(pTmp, cpyParam->SourceFile.Buffer, cpyParam->SourceFile.Length);
        pTmp = &(pTmp[cpyParam->SourceFile.Length / sizeof(WCHAR)]);

        if (*pTmp != UNICODE_NULL) {

            pTmp++;
            *pTmp = UNICODE_NULL;

        }

        pTmp++;

        if (cpyParam->DestFile.Buffer == NULL) {

            *pTmp = UNICODE_NULL;
            pTmp++;

        } else {

            RtlCopyMemory(pTmp, cpyParam->DestFile.Buffer, cpyParam->DestFile.Length);
            pTmp = &(pTmp[cpyParam->DestFile.Length / sizeof(WCHAR)]);

            if (*pTmp != UNICODE_NULL) {

                pTmp++;
                *pTmp = UNICODE_NULL;

            }

            pTmp++;

        }

        CopyListEntry = CopyListEntry->Flink;
    }

    //
    // Add the driver name and INF file to the list
    //
    wcscpy(pTmp, pInfEntry->DriverName);
    pTmp = pTmp + (wcslen(pTmp) + 1);
    *pTmp = UNICODE_NULL;
    pTmp++;

    wcscpy(pTmp, pInfEntry->InfFileName);
    pTmp = pTmp + (wcslen(pTmp) + 1);
    *pTmp = UNICODE_NULL;
    pTmp++;

    pRspData->cFiles += 2;


    //
    // Send out a response
    //
    BinlAssert(RspMessage);

    Error = OscSendSetupMessage(RequestContext,
                                clientState,
                                Message->RequestType,
                                RspMessage,
                                SuccessPacketLength
                               );

CleanUp:
    //
    // Free any memory the we allocated for the screen.
    //
    if (pInfEntry) {
        NetInfDereferenceNetcardEntry(pInfEntry);
    }
    if (RspMessage) {
        BinlFreeMemory(RspMessage);
    }

    return Error;
}


DWORD
OscProcessLogoff(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a logoff message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    //
    // clientState will already have been removed from the
    // client database. All we need to do is add one to the
    // NegativeRefCount and the client will then be deleted
    // once everyone else is done using it.
    //

    TraceFunc("OscProcessLogoff( )\n");

    ++clientState->NegativeRefCount;

    if (clientState->PositiveRefCount != (clientState->NegativeRefCount+1)) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Refcount not equal at logoff for %s\n", inet_ntoa(*(struct in_addr *)&(clientState->RemoteIp)) ));
    }

    return ERROR_SUCCESS;

}


DWORD
OscProcessNetcardRequest(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function processes requests from clients for information
    about network cards.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    NETCARD_REQUEST_PACKET UNALIGNED * netcardRequestMessage = (NETCARD_REQUEST_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    NETCARD_RESPONSE_PACKET ErrorResponsePacket;
    PNETCARD_RESPONSE_PACKET SuccessResponsePacket;
    ULONG SuccessResponsePacketLength;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    PWCHAR driverPath = NULL;
    PWCHAR setupPath = NULL;
    PCHAR ansiSetupPath = NULL;
    ULONG ansiSetupLength;

    DWORD Error;
    ULONG i;
    PNETCARD_RESPONSE_DATABASE pInfEntry = NULL;

    TraceFunc("OscProcessNetcardRequest( )\n");

    if (netcardRequestMessage->Version != OSCPKT_NETCARD_REQUEST_VERSION) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( Version not correct ) \n");
        goto sendErrorResponse;
    }

    if (RequestContext->ReceiveMessageSize < sizeof(NETCARD_REQUEST_PACKET)) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( Message too short ) \n");
        goto sendErrorResponse;
    }

    if ((netcardRequestMessage->SetupDirectoryLength >
         RequestContext->ReceiveMessageSize -
            sizeof(NETCARD_REQUEST_PACKET))
            ) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( setup path length invalid ) \n");
        goto sendErrorResponse;
    }
    ansiSetupLength = netcardRequestMessage->SetupDirectoryLength;

    ansiSetupPath = BinlAllocateMemory( ansiSetupLength + 1 );
    if (ansiSetupPath == NULL) {

        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        TraceFunc("OscProcessNetcardRequest( couldn't allocate temp buffer ) \n");
        goto sendErrorResponse;
    }

    //
    //  convert the setup path to unicode safely
    //

    memcpy( ansiSetupPath,
            &netcardRequestMessage->SetupDirectoryPath[0],
            ansiSetupLength );

    *(ansiSetupPath + ansiSetupLength) = '\0';

    setupPath = (PWCHAR) BinlAllocateMemory( (ansiSetupLength + 1) * sizeof(WCHAR) );
    if (setupPath == NULL) {

        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        TraceFunc("OscProcessNetcardRequest( couldn't allocate setup path buffer ) \n");
        goto sendErrorResponse;
    }
    mbstowcs( setupPath,
              ansiSetupPath,
              ansiSetupLength + 1); // include null

    BinlFreeMemory( ansiSetupPath );

    //
    // Make sure this is a PCI card and the client request structure
    // is version 0.
    //
    BinlPrintDbg(( DEBUG_OSC, "Searching %ws for NIC INF...\n", setupPath ));

    Error = NetInfFindNetcardInfo( setupPath,
                                   netcardRequestMessage->Architecture,
                                   netcardRequestMessage->Version,
                                   &netcardRequestMessage->CardInfo,
                                   NULL,
                                   &pInfEntry );

    BinlAssert (pInfEntry != NULL || Error != ERROR_SUCCESS);

    if (Error != ERROR_SUCCESS) {

        BinlPrint(( DEBUG_OSC_ERROR, "OscProcessNetcardRequest( Card not found ) \n"));

sendErrorResponse:
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscProcessNetcardRequest( ) sending Error response \n"));

        memcpy(ErrorResponsePacket.Signature, NetcardErrorSignature, 4);
        ErrorResponsePacket.Length = sizeof(ULONG);
        ErrorResponsePacket.Status = STATUS_INVALID_PARAMETER;

        TempClientState.LastResponse = (PUCHAR)&ErrorResponsePacket;
        TempClientState.LastResponseLength = 12;

        Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

    } else {

        //
        //  We found a match, so construct a response.  We first need to
        //  calculate how bit the buffer needs to be.
        //

        PLIST_ENTRY registryHead;
        PLIST_ENTRY registryListEntry;
        PNETCARD_REGISTRY_PARAMETERS regParam;
        ULONG registryLength = 0;

        registryHead = &pInfEntry->Registry;

        SuccessResponsePacketLength = sizeof(NETCARD_RESPONSE_PACKET) +
                + (( lstrlenW( pInfEntry->HardwareId ) + 1 ) * sizeof(WCHAR)) +
                + (( lstrlenW( pInfEntry->DriverName ) + 1 ) * sizeof(WCHAR)) +
                + (( lstrlenW( pInfEntry->ServiceName ) + 1 ) * sizeof(WCHAR)) +
                sizeof(WCHAR);      // termination for registry field

        registryListEntry = registryHead->Flink;
        while (registryListEntry != registryHead) {

            //
            //  each entry is a field name, field type (2 = string, 1 = int)
            //  and field value.  All of these are unicode strings terminated
            //  with a unicode null.
            //

            regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                        registryListEntry,
                                                        NETCARD_REGISTRY_PARAMETERS,
                                                        RegistryListEntry );

            registryLength += regParam->Parameter.Length + 1;
            registryLength += 2; // field type
            registryLength += regParam->Value.Length + 1;

            registryListEntry = registryListEntry->Flink;
        }

        registryLength += sizeof("Description");
        registryLength += 2;    // field type
        registryLength += lstrlenW( pInfEntry->DriverDescription ) + 1;

        SuccessResponsePacket = (PNETCARD_RESPONSE_PACKET)
                                BinlAllocateMemory(
                                        SuccessResponsePacketLength +
                                        registryLength );

        if (SuccessResponsePacket == NULL) {

            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not allocate SuccessResponsePacket of %ld bytes\n",
                        SuccessResponsePacketLength + registryLength));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto sendErrorResponse;

        } else {

            PWCHAR nextWideField;
            PCHAR nextField;
            PCHAR startOfRegistry;
            ANSI_STRING aString;
            UNICODE_STRING descriptionString;

            RtlZeroMemory(SuccessResponsePacket,
                            SuccessResponsePacketLength + registryLength);

            memcpy(SuccessResponsePacket->Signature, NetcardResponseSignature, 4);
            SuccessResponsePacket->Status = STATUS_SUCCESS;
            SuccessResponsePacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;

            nextWideField = (PWCHAR)(PCHAR)((PCHAR) &SuccessResponsePacket->RegistryOffset
                                                + sizeof(ULONG));

            lstrcpyW( nextWideField, pInfEntry->HardwareId );
            SuccessResponsePacket->HardwareIdOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += lstrlenW( pInfEntry->HardwareId ) + 1;

            lstrcpyW( nextWideField, pInfEntry->DriverName );
            SuccessResponsePacket->DriverNameOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += lstrlenW( pInfEntry->DriverName ) + 1;

            lstrcpyW( nextWideField, pInfEntry->ServiceName );
            SuccessResponsePacket->ServiceNameOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += lstrlenW( pInfEntry->ServiceName ) + 1;

            SuccessResponsePacket->RegistryOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);

            startOfRegistry = nextField = (PCHAR) nextWideField;

            //
            //  the first registry value should be description, otherwise
            //  bad things happen in NDIS on the client.
            //

            strcpy( nextField, "Description" );
            nextField += sizeof("Description");

            //
            //  then copy in the type of the field, int or string
            //

            *(nextField++) = NETCARD_REGISTRY_TYPE_STRING;
            *(nextField++) = '\0';

            //
            //  then copy in the registry value
            //

            RtlInitUnicodeString( &descriptionString, pInfEntry->DriverDescription );

            aString.Buffer = nextField;
            aString.Length = 0;
            aString.MaximumLength = ( descriptionString.Length + 1 ) * sizeof(WCHAR);

            RtlUnicodeStringToAnsiString( &aString,
                                          &descriptionString,
                                          FALSE );
            nextField += aString.Length + 1;

            registryListEntry = registryHead->Flink;
            while (registryListEntry != registryHead) {


                //
                //  each entry is a field name, field type (2 = string, 1 = int)
                //  and field value.  All of these are unicode strings terminated
                //  with a unicode null.
                //

                regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                            registryListEntry,
                                                            NETCARD_REGISTRY_PARAMETERS,
                                                            RegistryListEntry );

                if (regParam->Parameter.Length > 0) {

                    //
                    //  first copy in the registry value name
                    //

                    aString.Buffer = nextField;
                    aString.Length = 0;
                    aString.MaximumLength = ( regParam->Parameter.Length + 1 ) * sizeof(WCHAR);

                    RtlUnicodeStringToAnsiString( &aString,
                                                  &regParam->Parameter,
                                                  FALSE );

                    nextField += aString.Length + 1;

                    //
                    //  then copy in the type of the field, int or string
                    //

                    *(nextField++) = (UCHAR) regParam->Type;
                    *(nextField++) = '\0';

                    //
                    //  then copy in the registry value
                    //

                    aString.Buffer = nextField;
                    aString.Length = 0;
                    aString.MaximumLength = ( regParam->Value.Length + 1 ) * sizeof(WCHAR);

                    RtlUnicodeStringToAnsiString( &aString,
                                                  &regParam->Value,
                                                  FALSE );
                    nextField += aString.Length + 1;
                }

                registryListEntry = registryListEntry->Flink;
            }

            //
            //  put in extra null terminator for end of registry section
            //

            *nextField = '\0';
            nextField++;

            SuccessResponsePacket->RegistryLength = (ULONG) (nextField - startOfRegistry);
            SuccessResponsePacketLength += SuccessResponsePacket->RegistryLength;

            //
            //  The length field in the packet is set to the length of the
            //  packet starting at the Status field.  If we put in a field
            //  between LENGTH and STATUS, we need to update this code.
            //

            SuccessResponsePacket->Length = (ULONG)((PCHAR) nextField -
                                (PCHAR) &SuccessResponsePacket->Status);

            TempClientState.LastResponse = (PUCHAR)SuccessResponsePacket;
            TempClientState.LastResponseLength = SuccessResponsePacketLength;

            Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

            BinlFreeMemory(SuccessResponsePacket);
        }
    }

    if (pInfEntry) {
        NetInfDereferenceNetcardEntry( pInfEntry );
    }

    if (driverPath) {

        BinlFreeMemory( driverPath );
    }

    if (setupPath) {

        BinlFreeMemory( setupPath );
    }

    return Error;
}



DWORD
OscProcessHalRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes requests from clients for taking a
    detected HAL name string and mapping it to a <hal>.dll name
    and then copying that hal to the machine directory.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.
    clientState - contains client state for the remote machine

Return Value:

    Windows Error.

--*/
{
    HAL_REQUEST_PACKET UNALIGNED * halRequestMessage = (HAL_REQUEST_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    HAL_RESPONSE_PACKET responsePacket;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    DWORD Error;
    WCHAR MachinePath[MAX_PATH];
    WCHAR SrcPath[MAX_PATH];
    WCHAR DestPath[MAX_PATH];
    WCHAR HalName[MAX_HAL_NAME_LENGTH+1];
    WCHAR HalInfo[MAX_PATH];
    ULONG HalNameLength;
    ULONG len, index;
    BOOL b;
    PMACHINE_INFO pMachineInfo = NULL;
    USHORT SystemArchitecture;
    TraceFunc("OscProcessHalRequest( )\n");

    //
    // Find the length of the HAL name. To avoid overflowing past the
    // end of the received message, check it ourselves.
    //

    HalNameLength = 0;
    while (halRequestMessage->HalName[HalNameLength] != '\0') {
        ++HalNameLength;
        if (HalNameLength >= sizeof(HalName)/sizeof(WCHAR)) {
            Error = ERROR_INVALID_DATA;
            TraceFunc("OscProcessHalRequest( Exit 0 ) \n");
            goto SendResponse;
        }
    }
    ++HalNameLength;  // convert the '\0' also
    mbstowcs( HalName, halRequestMessage->HalName, HalNameLength );

    SystemArchitecture = OscPlatformToArchitecture( clientState );

    //
    // Retrieve information from the DS
    //
    Error = GetBootParameters( halRequestMessage->Guid,
                               &pMachineInfo,
                               MI_NAME | MI_SETUPPATH | MI_HOSTNAME,
                               SystemArchitecture,
                               FALSE );
    if (Error != ERROR_SUCCESS) {
        TraceFunc("OscProcessHalRequest( Exit 1 ) \n");
        goto SendResponse;
    }

    //
    // Find the HAL
    //
    //
    // Resulting string should be something like:
    //      "\\ADAMBA4\REMINST\Setup\English\Images\NTWKS5.0\i386\txtsetup.sif"
    if ( _snwprintf( SrcPath,
                     sizeof(SrcPath) / sizeof(SrcPath[0]),
                     L"%ws\\txtsetup.sif",
                     pMachineInfo->SetupPath
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }

    len = GetPrivateProfileString(L"hal",
                                  HalName,
                                  L"",
                                  HalInfo,
                                  sizeof(HalInfo)/sizeof(HalInfo[0]),
                                  SrcPath
                                  );
    if (len == 0) {
        TraceFunc("OscProcessHalRequest( Exit 3 ) \n");
        goto SendResponse;
    }

    //
    // Parse the response which should be in the form:
    // "newhal.dll,2,hal.dll"
    //
    index = 0;
    while ( HalInfo[index] )
    {
        if (HalInfo[index] == L' ' || HalInfo[index] == L',' )
            break;

        index++;
    }

    HalInfo[index] = L'\0';
    if (HalInfo[0] == L'\0' ) {
        Error = ERROR_BINL_HAL_NOT_FOUND;
        goto SendResponse;
    }

    //
    // Copy the HAL to the machine directory
    //

    if ( _snwprintf( SrcPath,
                     sizeof(SrcPath) / sizeof(SrcPath[0]),
                     L"%ws\\%ws",
                     pMachineInfo->SetupPath,
                     HalInfo
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }

    if ( _snwprintf( DestPath,
                     sizeof(DestPath) / sizeof(DestPath[0]),
                     L"%ws\\winnt\\system32\\hal.dll",
                     MachinePath
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }

    BinlPrintDbg((DEBUG_OSC, "Copying %ws to %ws...\n", SrcPath, DestPath));

    b = CopyFile( SrcPath, DestPath, FALSE );

    if (!b) {
        Error = ERROR_BINL_HAL_NOT_FOUND;
        TraceFunc("OscProcessHalRequest( Exit 4 ) \n");
        goto SendResponse;
    }

    //
    // Find which kernel to copy
    //

    index = wcslen(HalName);
    while (index > 0) {
        index--;
        if (HalName[index] == L'_') {
            index++;
            break;
        }
    }

    if ((index == 0) || (index == wcslen(HalName))) {
        Error = ERROR_SERVER_KERNEL_NOT_FOUND;
        goto SendResponse;
    }

    //
    // Copy that too
    //
    if ((HalName[index] == L'u') ||
        (HalName[index] == L'U')) {
        if ( _snwprintf( SrcPath,
                         sizeof(SrcPath) / sizeof(SrcPath[0]),
                         L"%ws\\ntoskrnl.exe",
                         pMachineInfo->SetupPath
                         ) == -1 ) {
            Error = ERROR_BAD_PATHNAME;
            goto SendResponse;
        }
    } else {
        if ( _snwprintf( SrcPath,
                         sizeof(SrcPath) / sizeof(SrcPath[0]),
                         L"%ws\\ntkrnlmp.exe",
                         pMachineInfo->SetupPath
                         ) == -1 ) {
            Error = ERROR_BAD_PATHNAME;
            goto SendResponse;
        }
    }

    if ( _snwprintf( DestPath,
                     sizeof(DestPath) / sizeof(DestPath[0]),
                     L"%s\\winnt\\system32\\ntoskrnl.exe",
                     MachinePath
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }

    BinlPrintDbg((DEBUG_OSC, "Copying %ws to %ws...\n", SrcPath, DestPath));

    b = CopyFile( SrcPath, DestPath, FALSE );

    if (!b) {
        Error = ERROR_SERVER_KERNEL_NOT_FOUND;
        TraceFunc("OscProcessHalRequest( Exit 5 ) \n");
        goto SendResponse;
    }

    Error = ERROR_SUCCESS;
    TraceFunc("OscProcessHalRequest( SUCCESS ) \n");

SendResponse:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    memcpy(responsePacket.Signature, HalResponseSignature, 4);
    responsePacket.Length = sizeof(ULONG);
    responsePacket.Status = (Error == ERROR_SUCCESS) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    TempClientState.LastResponse = (PUCHAR)&responsePacket;
    TempClientState.LastResponseLength = sizeof(responsePacket);

    Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);
    return Error;
}


//
// Process WINNT.SIF file for the client setup
//
DWORD
OscProcessSifFile(
    PCLIENT_STATE clientState,
    LPWSTR TemplateFile,
    LPWSTR WinntSifPath )
{
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD  len;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SECURITY_ATTRIBUTES SecurityAttributes;
    EXPLICIT_ACCESS ExplicitAccessList[2];
    PACL pAcl;
    PSID pSid;
    PWCHAR pszUserName;
    PWCHAR pszDomainName;
    WCHAR UniqueUdbPath[ MAX_PATH ];  // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386\Templates\unique.udb"
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
    PSECURITY_DESCRIPTOR pSd;

    TraceFunc("OscProcessSifFile( )\n");

    //
    // Impersonate while opening the file, in case the administrator messed
    // up and didn't give local system permission.
    //

    dwErr = OscImpersonate(clientState);
    if (dwErr == ERROR_SUCCESS) {

        LPWSTR uniqueUdbId = OscFindVariableW( clientState, "UNIQUEUDBID" );

        if (uniqueUdbId[0] != L'\0') {

            //
            // See if a unique.udb file name was specified in the template file.
            // The default name is "unique.udb".
            //
            len = GetPrivateProfileStringW(OSCHOOSER_SIF_SECTIONW,
                                           L"UniqueUdbFile",
                                           L"unique.udb",  // default
                                           UniqueUdbPath,
                                           sizeof(UniqueUdbPath)/sizeof(UniqueUdbPath[0]),
                                           TemplateFile
                                          );
    
            if (len == 0) {
                UniqueUdbPath[0] = L'\0';  // means not to process it
            } else {
                //
                // Prepend the path to our template file to UniqueUdbPath.
                //
                PWCHAR EndOfTemplatePath = wcsrchr(TemplateFile, L'\\');
                if (EndOfTemplatePath != NULL) {
                    DWORD PathLength = (DWORD)(EndOfTemplatePath - TemplateFile + 1);
                    DWORD FileNameLength = wcslen(UniqueUdbPath) + 1;
                    if (PathLength + FileNameLength <= MAX_PATH) {
                        memmove(UniqueUdbPath + PathLength, UniqueUdbPath, FileNameLength * sizeof(WCHAR));
                        memmove(UniqueUdbPath, TemplateFile, PathLength * sizeof(WCHAR));
                    }
                }
            }
        }

        //
        // Open the template file
        //
        hFile = CreateFile( TemplateFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,                   // security attribs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN(?)
                            NULL );                 // template

        OscRevert(clientState);

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            DWORD dwFileSize = GetFileSize( hFile, NULL );
            if ( dwFileSize != -1 )
            {
                LPSTR pBuffer = BinlAllocateMemory( dwFileSize + 1);   // SIF file buffer
                if ( pBuffer )
                {
                    DWORD dw;

                    //
                    // Read the file in
                    //
                    ReadFile( hFile, pBuffer, dwFileSize, &dw, NULL );
                    CloseHandle( hFile );

                    pBuffer[ dwFileSize ] = '\0'; // terminate

                    //
                    // Process the unique.udb overlay. We change the
                    // in-memory version of the file in pBuffer. NOTE
                    // we do this before calling SearchAndReplace in
                    // case unique.udb has any variables in it, or
                    // has a hard-coded value for something that it
                    // normally a variable in the file.
                    //
                    if ((uniqueUdbId[0] != L'\0') &&
                        (UniqueUdbPath[0] != L'\0')) {
                        ProcessUniqueUdb( &pBuffer,
                                          dwFileSize + 1,
                                          UniqueUdbPath,
                                          uniqueUdbId );
                        dwFileSize = strlen( pBuffer );
                    }
 
                    //
                    // search and replace defined macros
                    //
                    SearchAndReplace(   clientState->Variables,
                                        &pBuffer,
                                        clientState->nVariables,
                                        dwFileSize + 1,
                                        0 );

                    dwFileSize = strlen( pBuffer );

                    //
                    // HACK:
                    // If there is a line 'FullName = " "' in the SIF, get rid
                    // of the space in the quotes. This deals with the case
                    // where the template SIF had something like:
                    //    FullName = "%USERFIRSTNAME% %USERLASTNAME%"
                    // and OscGetUserDetails() was unable to get the necessary
                    // user information from the DS. If we leave the space in
                    // there, setup won't prompt for the user name.
                    //

#define BLANK_FULL_NAME "FullName = \" \"\r\n"
                    {
                        LPSTR p = pBuffer;
                        while ( *p != 0 ) {
                            if ( StrCmpNIA( p, BLANK_FULL_NAME, strlen(BLANK_FULL_NAME) ) == 0 ) {
                                p = p + strlen(BLANK_FULL_NAME) - 4;
                                memmove( p, p+1, dwFileSize - (p - pBuffer) ); // move terminator too
                                dwFileSize--;
                                break;
                            }
                            while ( (*p != 0) && (*p != '\r') && (*p != '\n') ) {
                                p++;
                            }
                            while ( (*p != 0) && ((*p == '\r') || (*p == '\n')) ) {
                                p++;
                            }
                        }
                    }

                    //
                    // Setup the ACL for this file, first is to grant admins all rights.
                    //
                    if (!AllocateAndInitializeSid(&SidAuthority, 
                                                  2,
                                                  SECURITY_BUILTIN_DOMAIN_RID,
                                                  DOMAIN_ALIAS_RID_ADMINS,
                                                  0, 0, 0, 0, 0, 0,
                                                  &pSid
                                                 )) {

                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        BinlFreeMemory(pBuffer);
                        return dwErr;

                    }

                    ExplicitAccessList[0].grfAccessMode = SET_ACCESS;
                    ExplicitAccessList[0].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | DELETE;
                    ExplicitAccessList[0].grfInheritance = NO_INHERITANCE;
                    ExplicitAccessList[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                    ExplicitAccessList[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                    ExplicitAccessList[0].Trustee.ptstrName = pSid;

                    //
                    // Now grant the user all rights.
                    //
                    pszUserName = OscFindVariableW(clientState, "USERNAME");
                    pszDomainName = OscFindVariableW(clientState, "USERDOMAIN");

                    if (pszUserName[0] == L'\0') {
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    if (pszDomainName[0] != L'\0') {
                        swprintf(UniqueUdbPath, L"%s\\", pszDomainName);
                    } else {
                        UniqueUdbPath[0] = L'\0';
                    }
                    wcscat(UniqueUdbPath, pszUserName);

                    ExplicitAccessList[1].grfAccessMode = SET_ACCESS;
                    ExplicitAccessList[1].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | DELETE;
                    ExplicitAccessList[1].grfInheritance = NO_INHERITANCE;
                    ExplicitAccessList[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
                    ExplicitAccessList[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    ExplicitAccessList[1].Trustee.ptstrName = UniqueUdbPath;

                    //
                    // Create an ACL with these two.
                    //
                    dwErr = SetEntriesInAcl(2, ExplicitAccessList, NULL, &pAcl);

                    if (dwErr != ERROR_SUCCESS) {
                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    //
                    // Create an SD for this ACL
                    //
                    pSd = BinlAllocateMemory(SECURITY_DESCRIPTOR_MIN_LENGTH);

                    if (pSd == NULL) {
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION) ||
                        !SetSecurityDescriptorDacl(pSd, TRUE, pAcl, FALSE)) {
                        
                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;

                    }

                    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
                    SecurityAttributes.lpSecurityDescriptor = pSd;
                    SecurityAttributes.bInheritHandle = FALSE;

                    //
                    // Create the destination file
                    //
                    hFile = CreateFile( WinntSifPath,
                                        GENERIC_WRITE | GENERIC_READ | DELETE,
                                        FILE_SHARE_READ,
                                        &SecurityAttributes,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL );                 // template

                    BinlFreeMemory(pSd);
                    FreeSid(pSid);
                    LocalFree(pAcl);
                    
                    if ( hFile != INVALID_HANDLE_VALUE )
                    {
                        //
                        // Write it all at once
                        //
                        if (!WriteFile( hFile, pBuffer, dwFileSize, &dw, NULL )) {
                            OscCreateWin32SubError( clientState, GetLastError( ) );
                            dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        }

                        CloseHandle( hFile );
                    }
                    else
                    {
                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                    }

                    BinlFreeMemory(pBuffer);

                } else {
                    CloseHandle( hFile );
                    OscCreateWin32SubError( clientState, GetLastError( ) );
                    dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                }

            } else {
                CloseHandle( hFile );
            }
        }
        else
        {
            dwErr = GetLastError( );
        }
    }
    else
    {
        OscCreateWin32SubError( clientState, GetLastError( ) );
        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
    }

    return dwErr;
}

//
// Creates the client image directory, copy the files needed to run
// launch text mode setup, munges Winnt.Sif, more...
//
DWORD
OscSetupClient(
    PCLIENT_STATE clientState,
    BOOLEAN ErrorDuplicateName
    )
{
    DWORD    dwErr = ERROR_SUCCESS;
    WCHAR    SetupPath[ MAX_PATH ];     // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386"
    PWCHAR   pTemplatePath;             // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386\Templates\RemBoot.SIF"
    WCHAR    WinntSifPath[ MAX_PATH ];  // ie "D:\RemoteInstall\Clients\NP00805F7F4C85$\winnt.sif"
    PWCHAR   pwc;                       // parsing pointer
    WCHAR    wch;                       // temp wide char
    PWCHAR   pMachineName;              // Pointer to Machine Name variable value
    PWCHAR   pMachineOU;                // Pointer to where the MAO will be created
    PWCHAR   pDomain;                   // Pointer to Domain variable name
    PWCHAR   pGuid;                     // Pointer to Guid variable name
    WCHAR    Path[MAX_PATH];            // general purpose path buffer
    WCHAR    TmpPath[MAX_PATH];         // general purpose path buffer
    ULONG    lenIntelliMirror;          // Lenght of IntelliMirrorPath (eg "D:\RemoteInstall")
    HANDLE   hDir;                      // Directory handle
    ULONG    i;                         // general counter
    BOOL     b;                         // general purpose BOOLean.
    BOOLEAN  ExactMatch;
    UINT     uSize;
    LARGE_INTEGER KernelVersion;
    WCHAR    VersionString[20];
    PCHAR    pszGuid;
    UCHAR    Guid[ BINL_GUID_LENGTH ];
    USHORT   SystemArchitecture;
    PMACHINE_INFO pMachineInfo = NULL;

    TraceFunc("OscSetupClient( )\n");

    lenIntelliMirror = wcslen(IntelliMirrorPathW) + 1;

    dwErr = OscCheckMachineDN( clientState );

    if ((dwErr == ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND) && !ErrorDuplicateName) {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscCheckMachineDN returned 0x%x\n", dwErr ));
        goto e0;
    }

    //
    // Get the machine GUID and get any overriding parameters.
    //
    pszGuid = OscFindVariableA( clientState, "GUID" );
    if ( pszGuid[0] == '\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscSetupClient: could not find GUID" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    pGuid = OscFindVariableW( clientState, "GUID" );
    if ( pGuid[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    dwErr = OscGuidToBytes( pszGuid, Guid );
    if ( dwErr != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscSetupClient: OscGuidToBytes failed\n" ));
        goto e0;
    }

    SystemArchitecture = OscPlatformToArchitecture(clientState);
    
    dwErr = GetBootParameters( Guid,
                               &pMachineInfo,
                               MI_SIFFILENAME_ALLOC,
                               SystemArchitecture,
                               FALSE );

    if ( dwErr == ERROR_SUCCESS ) {
        //
        // Set default values
        //
        if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {
            
            dwErr = OscAddVariableW( clientState, "FORCESIFFILE",  pMachineInfo->ForcedSifFileName );
            if ( dwErr != ERROR_SUCCESS ) {
                goto e0;
            }
    
        }
    }

    //
    // Get SIF File name.
    //
    pTemplatePath = OscFindVariableW( clientState, "SIF" );

    if ( pTemplatePath[0] == L'\0' ) {
        BinlPrint(( DEBUG_OSC_ERROR, "Missing SIF variable\n" ));
        OscAddVariableA( clientState, "SUBERROR", "SIF" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    //
    // validate the machine name.  Note the extra check for a 
    // period that DnsValidateDnsName_W won't catch for us.
    //
    pMachineName  = OscFindVariableW( clientState, "MACHINENAME" );
    if ( pMachineName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINENAME" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    } else if ( DnsValidateDnsName_W( pMachineName ) != ERROR_SUCCESS ) {
        dwErr = ERROR_BINL_INVALID_MACHINE_NAME;
        OscAddVariableA( clientState, "SUBERROR", " " );
        goto e0;
    } else if ( StrStrI( pMachineName,L".")) {
        dwErr = ERROR_BINL_INVALID_MACHINE_NAME;
        OscAddVariableA( clientState, "SUBERROR", " " );
        goto e0;
    }

    pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
    if ( pMachineOU[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINEOU" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    // Do we have a domain yet?
    pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
    if ( pDomain[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINEDOMAIN" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    if (OscSifIsSysPrep(pTemplatePath)) {
        DWORD SysPrepSku;

        //
        // Get the system path from the SIF file
        //
        dwErr = GetPrivateProfileStringW(OSCHOOSER_SIF_SECTIONW,
                                         L"SysPrepSystemRoot",
                                         L"",
                                         TmpPath,
                                         sizeof(TmpPath)/sizeof(TmpPath[0]),
                                         pTemplatePath
                                        );

        if (dwErr == 0) {
            dwErr  = ERROR_BINL_CD_IMAGE_NOT_FOUND;
            goto e0;
        }

        SysPrepSku = GetPrivateProfileInt( 
                              OSCHOOSER_SIF_SECTIONW,
                              L"ProductType",
                              0,
                              pTemplatePath );

        //
        // Get the root of the mirror directory from the template path.
        //
        // pTemplatePath looks like
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386\templates\riprep.sif",
        // truncate it temporarily to
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386"
        // by NULLing out the second-to-last '\'.
        //
        pwc = pTemplatePath + wcslen( pTemplatePath );
        for ( i = 0; i < 2; i++ )
        {
            while ( pwc > pTemplatePath && *pwc != L'\\' )
                pwc--;
            pwc--;
        }
        pwc++;
        wch = *pwc;                         // remember
        *pwc = L'\0';                       // terminate

        //
        // Now make Path be something like
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386\Mirror1\UserData\WINNT\system32"
        // which is where the ntoskrnl.exe whose version we want is located.
        //
        // Make sure there is room for pTemplatePath + "\" (1 byte) +
        // TmpPath + "\system32" (9 bytes) + '\0' (1 byte).
        //

        if (wcslen(pTemplatePath) + wcslen(TmpPath) + 11 > sizeof(Path)/sizeof(Path[0])) {
            dwErr = ERROR_BAD_PATHNAME;
            goto e0;
        }

        wcscpy(Path, pTemplatePath);
        wcscat(Path, L"\\");
        wcscat(Path, TmpPath);
        wcscat(Path, L"\\system32");

        //
        //  For NT 5.0, we'll bomb out if it's not an exact match.
        //

        if (!OscGetClosestNt(
                        Path, 
                        SysPrepSku,
                        clientState, 
                        SetupPath, 
                        &ExactMatch) ||
            ( ExactMatch == FALSE ))  {
            dwErr  = ERROR_BINL_CD_IMAGE_NOT_FOUND;
            goto e0;
        }

        //
        // SetupPath comes back as a path like
        // "D:\RemoteInstall\Setup\English\Images\nt5.0\i386",
        // If there was an exact match, we want SYSPREPDRIVERS to just be
        // "Setup\English\Images\nt5.0\i386"
        // otherwise we want it to be blank.
        //

        if (ExactMatch) {
            OscAddVariableW(clientState, "SYSPREPDRIVERS", &(SetupPath[lenIntelliMirror]));
        } else {
            OscAddVariableW(clientState, "SYSPREPDRIVERS", L"");
        }

        //
        // SYSPREPPATH will be the truncated pTemplatePath, without the
        // local path at the front, something like
        // "Setup\English\Images\NT50.Prep\i386".
        //

        OscAddVariableW(clientState, "SYSPREPPATH", &pTemplatePath[lenIntelliMirror]);

        //
        // Now restore pTemplatePath to what it was originally.
        //

        *pwc = wch;

        dwErr = ERROR_SUCCESS;

    } else {

        //
        // create the setup path to the workstation installation by stripping off
        // the SIF filename. We'll search backwards for the first 2nd "\".
        //
        // "D:\RemoteInstall\Setup\English\NetBootOs\NT50.WKS\i386"
        pwc = pTemplatePath + wcslen( pTemplatePath );
        for ( i = 0; i < 2; i++ )
        {
            while ( pwc > pTemplatePath && *pwc != L'\\' )
                pwc--;
            pwc--;
        }
        pwc++;
        wch = *pwc;                         // remember
        *pwc = L'\0';                       // terminate
        wcscpy( SetupPath, pTemplatePath ); // copy
        *pwc = wch;                         // restore

    }

    //
    // Figure out the INSTALLPATH. This is the SetupPath minus the
    // "D:\RemoteInstall" and should be:
    // "Setup\English\Images\NT50.WKS"
    wcscpy( Path, &SetupPath[lenIntelliMirror] );
    Path[ wcslen(Path) - 1
              - strlen( OscFindVariableA( clientState, "MACHINETYPE" ) ) ] = '\0';
    dwErr = OscAddVariableW( clientState, "INSTALLPATH", Path );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // record the build and version of the OS we're installing.
    // if it fails, just fall back to NT 5.0.
    //
    if(!OscGetNtVersionInfo((PULONGLONG)&KernelVersion, SetupPath, clientState )) {
        KernelVersion.LowPart = MAKELONG(0,2195);
        KernelVersion.HighPart = MAKELONG(0,5);
    }

    wsprintf(VersionString,L"%d.%d", HIWORD(KernelVersion.HighPart), LOWORD(KernelVersion.HighPart));

    OscAddVariableW( clientState, "IMAGEVERSION", VersionString );

    wsprintf(VersionString,L"%d", HIWORD(KernelVersion.LowPart));

    OscAddVariableW( clientState, "IMAGEBUILD", VersionString );                
    
    //
    // Create the default path to the image
    //
    if ( _snwprintf( Path,
                     sizeof(Path) / sizeof(Path[0]),
                     L"%ws\\%ws\\templates",
                     OscFindVariableW( clientState, "INSTALLPATH" ),
                     OscFindVariableW( clientState, "MACHINETYPE" )
                     ) == -1 ) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }

    //
    // Create destination SIF file path.
    //
    if ( _snwprintf( WinntSifPath,
                     sizeof(WinntSifPath) / sizeof(WinntSifPath[0]),
                     L"%ws\\%ws\\%ws.sif",
                     IntelliMirrorPathW,
                     TEMP_DIRECTORY,
                     pGuid
                     ) == -1 ) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }

    //
    // Make sure there is a tmp directory below \remoteinstall.
    //

    dwErr = OscCheckTmpDirectory();
    if (dwErr != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // generate a machine password that we'll use in the SIF file and when
    // setting up the MAO
    //
    wcscpy(TmpPath, Path );

    dwErr = OscSetupMachinePassword( clientState, pTemplatePath );
    if (dwErr != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // Copy and process the selected SIF file
    //
    dwErr = OscProcessSifFile( clientState, pTemplatePath, WinntSifPath );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // Get the boot file name
    //
    // Make sure there is room for Path + "\startrom.com" + NULL (so
    // use sizeof to include the NULL).
    //
    if (wcslen(Path) + sizeof("\\startrom.com") > sizeof(Path)/sizeof(Path[0])) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }
    
    //
    // construct default path in case the LaunchFile entry isn't
    // found in the SIF file.
    //
    switch ( SystemArchitecture ) {
        case DHCP_OPTION_CLIENT_ARCHITECTURE_IA64:
            wcscat( Path, L"\\setupldr.efi" );
            break;
        default:
            wcscat( Path, L"\\startrom.com" );      // construct default path
    }

    GetPrivateProfileString( OSCHOOSER_SIF_SECTIONW,
                             L"LaunchFile",
                             Path, // default
                             Path,
                             MAX_PATH,
                             WinntSifPath );
    dwErr = OscAddVariableW( clientState, "BOOTFILE", Path );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // Get the SIF file name
    //

    dwErr = OscAddVariableW( clientState, "SIFFILE", &WinntSifPath[lenIntelliMirror] );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

e0:
    if (pMachineInfo != NULL) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    return dwErr;
}

//
// Undoes whatever permanent things OscSetupClient does.
//
VOID
OscUndoSetupClient(
    PCLIENT_STATE clientState
    )
{
    WCHAR  WinntSifPath[ MAX_PATH ];  // ie "D:\RemoteInstall\tmp\NP00805F7F4C85$.sif"
    PWCHAR pSifFile;
    DWORD  dwErr;

    TraceFunc("OscUndoSetupClient( )\n");

    pSifFile = OscFindVariableW( clientState, "SIFFILE" );
    if ( pSifFile[0] == L'\0' ) {
        return;
    }

    //
    // Create destination SIF file path.
    //
    if ( _snwprintf( WinntSifPath,
                     sizeof(WinntSifPath) / sizeof(WinntSifPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     pSifFile
                     ) == -1 ) {
        return;
    }

    //
    // Impersonate so that we can get correct permissions to delete the file.
    //
    dwErr = OscImpersonate(clientState);

    if (dwErr == ERROR_SUCCESS) {

        //
        // Delete the template file
        //
        DeleteFile( WinntSifPath );

        OscRevert(clientState);
    }

}


USHORT 
OscPlatformToArchitecture(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    Translates the client architecture string value to a
    DHCP_OPTION_CLIENT_ARCHITECTURE_*** flag.

Arguments:

    ClientState - The client state.  It's assumed that the MACHINETYPE
    OSC variable has been set when you call this function.  This occurs
    after OSCHOICE logs on the user.

Return Value:

    DHCP_OPTION_CLIENT_ARCHITECTURE_*** flag.

--*/
{
    PCWSTR pArch;

    pArch = OscFindVariableW( clientState, "MACHINETYPE");
    if (!pArch) {
        //
        // if we have no architecture, just assume x86
        //
        return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
    }

    if (_wcsicmp(pArch, L"ia64") == 0) {
        return DHCP_OPTION_CLIENT_ARCHITECTURE_IA64;
    } else if (_wcsicmp(pArch, L"i386") == 0) {
        return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
    }

    return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
}

DWORD
OscSetupMachinePassword(
    IN PCLIENT_STATE clientState,
    IN PCWSTR SifFile
    ) 
/*++

Routine Description:

    Generates and stores the machine password for later use.
    
Arguments:

    ClientState - The client state. 
    SifFile - path to unattend SIF file.

Return Value:

    DWORD Win32Error code indicating status of the operation.

--*/
{
    WCHAR MachinePassword[LM20_PWLEN+1];
    DWORD MachinePasswordLength;
    PWCHAR pMachineName;
    BOOL SecuredJoin;
    PWCHAR pVersion;
    WCHAR Answer[20];

    //
    // Figure out if we should be doing a secure domain join.
    // In Win2K, there is no such thing, so we do the old 
    // style domain join with a weaker password.  In all other
    // cases, we use the secure domain join method.
    //
    pVersion = OscFindVariableW( clientState, "IMAGEVERSION" );
    if (pVersion && (wcscmp(pVersion,L"5.0") == 0)) {
        SecuredJoin = FALSE;
    } else {
        if (!GetPrivateProfileString( L"Identification",
                                 L"DoOldStyleDomainJoin",
                                 L"", // default
                                 Answer,
                                 20,
                                 SifFile ) ||
            0 == _wcsicmp(Answer, L"Yes" )) {
            SecuredJoin = FALSE;
        } else {
            SecuredJoin = TRUE;
        }
    }

     
    //
    // Set up the password. For diskless clients it is the machine name
    // in lowercase, for disked clients we generate a random one, making
    // sure it has no NULLs in it.
    //
    //
    // We have to change the password for DISKED machines, since
    // they will have a random password that we can't query.
    //

    //
    // Windows 2000 machines have to have the "well-known-password"
    // Machine passwords are just the "MachineName" (without the "$")
    //
    
    if (!SecuredJoin) {

        UINT i;

        pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
        if (!pMachineName) {
            return ERROR_INVALID_DATA;
        }

        memset( MachinePassword, 0, sizeof(MachinePassword) );

        MachinePasswordLength = wcslen( pMachineName ) * sizeof(WCHAR);
        if ( MachinePasswordLength > (LM20_PWLEN * sizeof(WCHAR)) ) {
            MachinePasswordLength = LM20_PWLEN * sizeof(WCHAR);
        }

        //
        // Lower-case the NT password.
        //
        for (i = 0; i < MachinePasswordLength / sizeof(WCHAR); i++) {
            MachinePassword[i] = towlower(pMachineName[i]);
        }

        BinlPrintDbg(( DEBUG_OSC, "Using WKP\n" ));
    } else {

        PUCHAR psz = (PUCHAR) &MachinePassword[0];
        UINT i;

        OscGeneratePassword(MachinePassword, &MachinePasswordLength );

#if 0 && DBG
        BinlPrintDbg(( DEBUG_OSC, "Generated password: " ));
        for ( i = 0; i < MachinePasswordLength / sizeof(WCHAR); i++ ) {
            BinlPrintDbg(( DEBUG_OSC, "x%02x ", psz[i] ));
        }
        BinlPrintDbg(( DEBUG_OSC, "\n" ));
#endif      

    }

    RtlCopyMemory(clientState->MachineAccountPassword,MachinePassword, MachinePasswordLength);
    clientState->MachineAccountPasswordLength = MachinePasswordLength;
    
    //
    // the password always consists of printable characters since it must be 
    // substituted into a text file.
    //
    OscAddVariableW( clientState, "MACHINEPASSWORD", clientState->MachineAccountPassword );


    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\dhcpcli.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    Private header file for the client end of the DHCP server service.

Author:

    Madan Appiah (madana) 10-Sep-1993
    Manny Weiser (mannyw) 11-Aug-1992

Revision History:

--*/

//
//  NT public header files
//

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <rpc.h>

//
//  DHCP public header files
//

#include "dhcp.h"


//
//  Local RPC built files
//

#include "dhcp_cli.h"
#include "dhcp2_cli.h"

ULONG DhcpGlobalTryDownlevel;

#define USE_TCP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\rogue.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rogue.c

Abstract:

    This module contains the rogue detection interface to DHCP for BINL server.

Author:

    Andy Herron (andyhe)  19-Aug-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

VOID
BinlRogueLoop(
    LPVOID Parameter
    );

NTSTATUS
MaybeStartRogueThread (
    VOID
    )
//
//  Initiate rogue thread.  The gcsDHCPBINL should not be held by caller.
//
{
    DWORD Error = ERROR_SUCCESS;
    DWORD threadId;

    EnterCriticalSection(&gcsDHCPBINL);

    //
    //  if we're stopping anyway or if we're already running the rogue stuff
    //  or if the DHCP server is up, then we don't bother starting rogue
    //  detection.
    //

    if ((BinlCurrentState == BINL_STOPPED) ||
        (BinlGlobalHaveCalledRogueInit) ||
        (DHCPState != DHCP_STOPPED)) {

        LeaveCriticalSection(&gcsDHCPBINL);
        return ERROR_SUCCESS;
    }

    //
    //  Let's do rogue detection..  first create the events we need
    //

    if (BinlRogueTerminateEventHandle == NULL) {

        BinlRogueTerminateEventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }
    if (RogueUnauthorizedHandle == NULL) {

        RogueUnauthorizedHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    }
    if ( BinlRogueTerminateEventHandle == NULL || RogueUnauthorizedHandle == NULL) {

        Error = GetLastError();

        BinlPrintDbg( (DEBUG_ROGUE,
                    "Initialize(...) CreateEvent returned error %x for rogue\n",
                    Error )
                );

        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    Error = DhcpRogueInit( &DhcpRogueInfo,
                            BinlRogueTerminateEventHandle,
                            RogueUnauthorizedHandle );

    if (Error != ERROR_SUCCESS) {

        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    //
    //  create the thread that handles the rogue detection logic in DHCP code.
    //

    BinlRogueThread = CreateThread( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)BinlRogueLoop,
                                    NULL,
                                    0,
                                    &threadId );

    if ( BinlRogueThread == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_ROGUE, "Can't create rogue Thread, %ld.\n", Error));
        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    BinlGlobalHaveCalledRogueInit = TRUE;
    LeaveCriticalSection(&gcsDHCPBINL);

    return ERROR_SUCCESS;
}

VOID
StopRogueThread (
    VOID
    )
//
//  Cleanup all rogue thread resources.
//  The gcsDHCPBINL should not be held by caller.
//
{
    HANDLE tempThreadHandle;

    tempThreadHandle = InterlockedExchangePointer( &BinlRogueThread, NULL );

    if ( tempThreadHandle != NULL ) {

        BinlAssert( BinlRogueTerminateEventHandle != NULL );
        SetEvent( BinlRogueTerminateEventHandle );

        WaitForSingleObject(
            tempThreadHandle,
            THREAD_TERMINATION_TIMEOUT );
        CloseHandle( tempThreadHandle );
    }

    EnterCriticalSection(&gcsDHCPBINL);

    if (BinlGlobalHaveCalledRogueInit) {

        DhcpRogueCleanup( &DhcpRogueInfo );
        BinlGlobalHaveCalledRogueInit = FALSE;
    }

    if ( BinlRogueTerminateEventHandle ) {

        CloseHandle( BinlRogueTerminateEventHandle );
        BinlRogueTerminateEventHandle = NULL;
    }
    if ( RogueUnauthorizedHandle ) {

        CloseHandle( RogueUnauthorizedHandle );
        RogueUnauthorizedHandle = NULL;
    }

    LeaveCriticalSection(&gcsDHCPBINL);

    return;
}

VOID
HandleRogueAuthorized (
    VOID
    )
{
    BOOL oldState = BinlGlobalAuthorized;

    BinlGlobalAuthorized = TRUE;

    if ((BinlGlobalAuthorized != oldState) &&
        (BinlCurrentState != BINL_STOPPED)) {

        LogCurrentRogueState( FALSE );
    }
    return;
}

VOID
HandleRogueUnauthorized (
    VOID
    )
{
    BOOL oldState = BinlGlobalAuthorized;

    BinlGlobalAuthorized = FALSE;

    if ((BinlGlobalAuthorized != oldState) &&
        (BinlCurrentState != BINL_STOPPED)) {

        LogCurrentRogueState( FALSE );
    }
    return;
}

VOID
LogCurrentRogueState (
    BOOL ResponseToMessage
    )
{
    //
    //  If we're responding to a message and we haven't yet logged that
    //  we're unauthorized

    if ((ResponseToMessage == FALSE) ||
        ((BinlGlobalAuthorized == FALSE) &&
         (BinlRogueLoggedState == FALSE)) ) {

        BinlRogueLoggedState = TRUE;

        BinlReportEventW(   BinlGlobalAuthorized ?
                                EVENT_ERROR_DHCP_AUTHORIZED :
                                EVENT_ERROR_DHCP_NOT_AUTHORIZED,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            0,
                            NULL,
                            NULL
                            );
    }
    return;
}

VOID
BinlRogueLoop(
    LPVOID Parameter
    )
{
    HANDLE  Handles[3];
    ULONG SecondsToSleep, SleepTime, Error;
    ULONG Flag;

    BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread has been started.\n" ));

    Handles[0] = BinlRogueTerminateEventHandle;
    Handles[1] = RogueUnauthorizedHandle;
    Handles[2] = BinlGlobalProcessTerminationEvent;

    do {
        SecondsToSleep = RogueDetectStateMachine(&DhcpRogueInfo);

        if( INFINITE == SecondsToSleep ) {
            SleepTime = INFINITE;
        } else {
            SleepTime = SecondsToSleep * 1000;
        }

        BinlPrintDbg( (DEBUG_ROGUE, "BinlRogue waiting %u milliseconds.\n", SleepTime ));

        Error = WaitForMultipleObjects(3, Handles, FALSE, SleepTime );

        //
        //   if we got anything but WAIT_TIMEOUT or RogueUnauthorized, we
        //   break out.  This is per RameshV's sample code.
        //

        if (Error == WAIT_OBJECT_0+2) {

            //
            // binl is terminating.
            //

            BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread is exiting because BINL shutting down.\n" ));
            return;
        }

        if (BinlRogueThread == NULL) {

            //
            //  we've been terminated because DHCP has started and is doing
            //  it's own rogue detection.
            //

            BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread is exiting because rogue thread is null.\n" ));
            return;
        }


        // if we ever have to do anything besides just continue when the
        // state machine tells us to exit, do so here.

#if 0
        if ((Error == WAIT_OBJECT_0+1) || (Error == WAIT_TIMEOUT)) {
            continue;
        }
#endif
        //
        //  supposedly the state machine resets so we should just continue.
        //

        BinlPrintDbg((DEBUG_ROGUE, "BinlRogue has error of 0x%x. sleeping a bit\n", Error ));
        Sleep( 1000 );  //  we'll sleep to give the dhcp rogue state
                            //  machine time to reset

    } while ( TRUE );
}

// rogue.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\osc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    osc.h

Abstract:

    This file containes definitions for the OS chooser server part.

Author:

    Adam Barr (adamba)  08-Jul-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _OSCSERVER_
#define _OSCSERVER_

//
// Functions in osc.c.
//

DWORD
OscInitialize(
    VOID
    );

VOID
OscUninitialize(
    VOID
    );

DWORD
OscProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
OscVerifyLastResponseSize(
    PCLIENT_STATE clientState
    );

DWORD
OscProcessNegotiate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessAuthenticate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessScreenArguments(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PUCHAR *NameLoc
    );

DWORD
OscProcessRequestUnsigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

OscInstallClient(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA createData
    );

DWORD
OscGetCreateData(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    );

DWORD
OscProcessRequestSigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessSetupRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessLogoff(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessNetcardRequest(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
OscProcessHalRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessSifFile(
    PCLIENT_STATE clientState,
    LPWSTR TemplateFile,
    LPWSTR WinntSifPath
    );

DWORD
OscSetupClient(
    PCLIENT_STATE clientState,
    BOOLEAN ErrorDuplicateName
    );

VOID
OscUndoSetupClient(
    PCLIENT_STATE clientState
    );

USHORT 
OscPlatformToArchitecture(
    PCLIENT_STATE clientState
    );

//
// client.c
//

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    );

VOID
FreeClient(
    PCLIENT_STATE client
    );

VOID
OscFreeClientVariables(
    PCLIENT_STATE clientState
    );

BOOLEAN
OscInitializeClientVariables(
    PCLIENT_STATE clientState
    );

DWORD
OscFindClient(
    ULONG RemoteIp,
    BOOL Remove,
    PCLIENT_STATE * pClientState
    );

VOID
OscFreeClients(
    VOID
    );

VOID
SearchAndReplace(
    LPSAR psarList,
    LPSTR *pszString,
    DWORD ArraySize,
    DWORD dwSize,
    DWORD dwExtraSize
    );

VOID
ProcessUniqueUdb(
    LPSTR *pszString,
    DWORD dwSize,
    LPWSTR UniqueUdbPath,
    LPWSTR UniqueUdbId
    );

LPSTR
OscFindVariableA(
    PCLIENT_STATE clientState,
    LPSTR variableName
    );

LPWSTR
OscFindVariableW(
    PCLIENT_STATE clientState,
    LPSTR variableName
    );

BOOLEAN
OscCheckVariableLength(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    ULONG        variableLength
    );

DWORD
OscAddVariableA(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    LPSTR        variableValue
    );

DWORD
OscAddVariableW(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    LPWSTR       variableValue
    );

VOID
OscResetVariable(
    PCLIENT_STATE clientState,
    LPSTR        variableName
    );

//
// ds.c
//

DWORD
OscGetUserDetails (
    PCLIENT_STATE clientState
    );

DWORD
OscCreateAccount(
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    );

DWORD
CheckForDuplicateMachineName(
    PCLIENT_STATE clientState,
    LPWSTR pszMachineName
    );

DWORD
GenerateMachineName(
    PCLIENT_STATE clientState
    );

DWORD
OscCheckMachineDN(
    PCLIENT_STATE clientState
    );

DWORD
OscGetDefaultContainerForDomain (
    PCLIENT_STATE clientState,
    PWCHAR DomainDN
    );

//
// menu.c
//

DWORD
OscAppendTemplatesMenus(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState,
    BOOLEAN RecoveryOptionsOnly
    );

DWORD
SearchAndGenerateOSMenu(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState
    );

DWORD
FilterFormOptions(
    PCHAR  OutMessage,
    PCHAR  FilterStart,
    PULONG OutMessageLength,
    PCHAR SectionName,
    PCLIENT_STATE ClientState
    );

//
// utils.c
//

void
OscCreateWin32SubError(
    PCLIENT_STATE clientState,
    DWORD Error
    );

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error
    );

VOID
OscGenerateSeed(
    UCHAR Seed[1]
    );

DWORD
OscRunEncode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR Data,
    OUT LPSTR * EncodedData
    );

DWORD
OscRunDecode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR EncodedData,
    OUT LPSTR * Data
    );

BOOLEAN
OscGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    );

VOID
OscGeneratePassword(
    OUT PWCHAR Password,
    OUT PULONG PasswordLength
    );

DWORD
GenerateErrorScreen(
    PCHAR  *OutMessage,
    PULONG OutMessageLength,
    DWORD  Error,
    PCLIENT_STATE clientState
    );

PCHAR
FindNext(
    PCHAR Start,
    CHAR ch,
    PCHAR End
    );

PCHAR
FindScreenName(
    PCHAR Screen
    );

DWORD
OscImpersonate(
    PCLIENT_STATE ClientState
    );

DWORD
OscRevert(
    PCLIENT_STATE ClientState
    );

DWORD
OscGuidToBytes(
    LPSTR  pszGuid,
    LPBYTE Guid
    );

BOOLEAN
OscSifIsSysPrep(
    PWCHAR pSysPrepSifPath
    );

BOOLEAN
OscSifIsCmdConsA(
    PCHAR pSysPrepSifPath
    );

BOOLEAN
OscSifIsASR(
    PCHAR pSysPrepSifPath
    );

BOOLEAN
OscGetClosestNt(
    IN LPWSTR PathToKernel,
    IN DWORD  SkuType,
    IN PCLIENT_STATE ClientState,
    OUT LPWSTR SetupPath,
    OUT PBOOLEAN ExactMatch
    );

BOOLEAN
OscGetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir,
    PCLIENT_STATE ClientState
    );

DWORD
SendUdpMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    BOOL bFragment,
    BOOL bResend
    );

DWORD
OscVerifySignature(
    PCLIENT_STATE clientState,
    SIGNED_PACKET UNALIGNED * signedMessage
    );

DWORD
OscSendSignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscSendUnsignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscSendSetupMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    ULONG RequestType,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscConstructSecret(
    PCLIENT_STATE clientState,
    PWCHAR UnicodePassword,
    ULONG  UnicodePasswordLength,
    PCREATE_DATA CreateData
    );

#if defined(SET_ACLS_ON_CLIENT_DIRS)
DWORD
OscSetClientDirectoryPermissions(
    PCLIENT_STATE clientState
    );
#endif

#if 0
VOID
OscGetFlipServerList(
    PUCHAR FlipServerList,
    PULONG FlipServerListLength
    );
#endif

#if defined(REMOTE_BOOT)
DWORD
OscCopyTemplateFiles(
    LPWSTR SourcePath,
    LPWSTR ImagePath,
    LPWSTR TemplateFile
    );
#endif // defined(REMOTE_BOOT)

#if DBG && defined(REMOTE_BOOT)
DWORD
OscCreateNullFile(
    LPWSTR Image,
    LPWSTR MAC
    );
#endif // DBG && defined(REMOTE_BOOT)

DWORD
OscSetupMachinePassword(
    PCLIENT_STATE clientState,
    PCWSTR        SifFile
    );

DWORD 
MyGetDcHandle(
    PCLIENT_STATE clientState,
    PCSTR DomainName,
    PHANDLE Handle
    );

DWORD
GetDomainNetBIOSName(
    IN PCWSTR DomainNameInAnyFormat,
    OUT PWSTR *NetBIOSName
    );


//
// OSC packet definitions.
//

#define OSC_REQUEST     0x81

//
// Miscellaneous definitions.
//

#define DESCRIPTION_SIZE        70              // 70 cols
#define HELPLINES_SIZE          4 * 70          // 4 lines of text
#define OSCHOOSER_SIF_SECTIONA    "OSChooser"
#define OSCHOOSER_SIF_SECTIONW    L"OSChooser"

#define COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM L"B:32:AA312825768811D1ADED00C04FD8D5CD:"

//
// Default "default screen" (the first one sent down) if none is specified
// in the registry. Note that this is the actual filename, not the NAME
// value within it.
//

#define DEFAULT_SCREEN_NAME     L"welcome.osc"

//
// This defines the size by which the generated screen buffers will grow.
//

#define GENERATED_SCREEN_GROW_SIZE 512

//
// Make English default
//

#define DEFAULT_LANGUAGE     L"English"

//
// Default value for %ORGNAME%
//

#define DEFAULT_ORGNAME      L""

//
// Default value for %TIMEZONE% (GMT)
//

#define DEFAULT_TIMEZONE     L"085"

//
// Name of the tmp directory we create below the REMINST share.
//

#define TEMP_DIRECTORY L"tmp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\dhcpcmd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcmd.c

Abstract:

    This file contains program to test all DHCP APIs.

Author:

    Madan Appiah (madana) 5-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <dhcplib.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <jet.h>        // for JET_cbColumnMost
#ifdef NT5
#include <mdhcsapi.h>
#endif NT5
#include <heapx.h>
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#include <winnls.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__


#pragma message ( "*** DHCPCMD will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x) free(x)

#endif
#endif


typedef enum _COMMAND_CODE {
    AddIpRange,
    RemoveIpRange,
    EnumIpRanges,
    AddReservedIp,
    EnumClients,
    EnumClientsV5,
    DeleteBadClients,
    DeleteClient,
    MibCounts,
    ServerConfig,
    GetDhcpVersion,
    SetSuperScope,
    DeleteSuperScope,
    GetSuperScopeTable,
    RemoveSubscope,
    CheckDB,
    CreateSubnet,
    AddExcludeRange,
    RemoveReservedIp,
    RemoveExcludeRange,
    SetSubnetState,
    DeleteSubnet,
    CreateOption,
    DeleteOption,
    EnumOptions,
    SetGlobalOptionValue,
    SetGlobalOptionValues,
    RemoveGlobalOptionValue,
    SetSubnetOptionValue,
    RemoveSubnetOptionValue,
    SetReservedOptionValue,
    RemoveReservedOptionValue,
    GetAllOptions,
    GetAllOptionValues,
    CreateMScope,
    DeleteMScope,
    AddMScopeRange,
    EnumMScopeClients,
    ReconcileMScope,
    EnumMScopes,
    MCastMibCounts,
    CreateClass,
    DeleteClass,
    EnumClasses,
    AddServer,
    DelServer,
    EnumServers,
    GetServerStatus,
    RetryAuthorization,
    GetBindings,
    SetBinding,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

LPWSTR GlobalServerIpAddressUnicodeString = NULL;
LPSTR GlobalServerIpAddressAnsiString = NULL;
LPWSTR GlobalClassName = NULL;
LPWSTR GlobalVendorName = NULL;
BOOL   GlobalIsVendor = FALSE;
BOOL   GlobalNoRPC = FALSE;
BOOL   GlobalNoDS = TRUE;

DWORD GlobalClientCount;
DWORD g_dwMajor = (DWORD) -1 ,
      g_dwMinor = (DWORD) -1; // version control

#define CLASS_ID_VERSION  0x5

COMMAND_INFO GlobalCommandInfo[] = {
    // global server stuff.
    {"MibCounts",             MibCounts },
    {"GetVersion",            GetDhcpVersion },
    {"ServerConfig",          ServerConfig },

    // subnet stuff
    {"CreateSubnet",          CreateSubnet },
    {"DeleteSubnet",          DeleteSubnet },
    {"SetSubnetState",        SetSubnetState },

    // ranges
    {"AddIpRange",            AddIpRange },
    {"RemoveIpRange",         RemoveIpRange },
#ifdef NT5
    {"EnumIpRanges",          EnumIpRanges },
#endif NT5
    {"AddExcludeRange",       AddExcludeRange },
    {"RemoveExcludeRange",    RemoveExcludeRange },

    // active leases
    {"EnumClients",           EnumClients },
    {"DeleteBadClients",      DeleteBadClients },
    {"DeleteClient",          DeleteClient },
#ifdef NT5
    {"EnumClientsV5",         EnumClientsV5 },
#endif NT5

    // reservations
    {"AddReservedIp",         AddReservedIp },
    {"RemoveReservedIp",      RemoveReservedIp },

    // super-scoping
    {"SetSuperScope",         SetSuperScope },
    {"DeleteSuperScope",      DeleteSuperScope },
    {"GetSuperScopeTable",    GetSuperScopeTable },
    {"RemoveSubscope",        RemoveSubscope },

    // reconcile
    {"CheckDB",               CheckDB },

    // options
    {"CreateOption",          CreateOption },
    {"DeleteOption",          DeleteOption },
    {"SetGlobalOptionValue",  SetGlobalOptionValue },
    {"SetGlobalOptionValues", SetGlobalOptionValues },
    {"RemoveGlobalOptionValue", RemoveGlobalOptionValue },
    {"SetSubnetOptionValue",  SetSubnetOptionValue },
    {"RemoveSubnetOptionValue", RemoveSubnetOptionValue },
    {"SetReservedOptionValue",SetReservedOptionValue },
    {"RemoveReservedOptionValue", RemoveReservedOptionValue },
    {"EnumOptions",           EnumOptions},

#ifdef NT5
    {"GetAllOptions",         GetAllOptions },
    {"GetAllOptionValues",    GetAllOptionValues },

    // multicast stuff
    {"CreateMScope",          CreateMScope},
    {"DeleteMScope",          DeleteMScope},
    {"AddMScopeIpRange",      AddMScopeRange},
    {"EnumMScopeClients",     EnumMScopeClients},
    {"ReconcileMScope",       ReconcileMScope},
    {"EnumMScopes",           EnumMScopes},
    {"MCastMibCounts",           MCastMibCounts},

    // classes
    {"CreateClass",           CreateClass},
    {"DeleteClass",           DeleteClass},
    {"EnumClasses",           EnumClasses},

    // servers
    {"AddServer",             AddServer},
    {"DeleteServer",          DelServer},
    {"EnumServers",           EnumServers},

    {"GetServerStatus",       GetServerStatus},
    {"RetryAuthorization",    RetryAuthorization},

    {"GetBindings",           GetBindings},
    {"SetBinding",            SetBinding}
#endif NT5
};

typedef enum _CONFIG_COMMAND_CODE {
    ConfigAPIProtocolSupport,
    ConfigDatabaseName,
    ConfigDatabasePath,
    ConfigBackupPath,
    ConfigBackupInterval,
    ConfigDatabaseLoggingFlag,
    ConfigRestoreFlag,
    ConfigDatabaseCleanupInterval,
    ConfigDebugFlag,
    ConfigActivityLog,
    ConfigPingRetries,
    ConfigBootFileTable,
    UnknownConfigCommand
} CONFIG_COMMAND_CODE, *LPCONFIG_COMMAND_CODE;

typedef struct _CONFIG_COMMAND_INFO {
    LPSTR CommandName;
    CONFIG_COMMAND_CODE CommandCode;
} CONFIG_COMMAND_INFO, *LPCONFIG_COMMAND_INFO;

CONFIG_COMMAND_INFO GlobalConfigCommandInfo[] =
{
    {"APIProtocolSupport",           ConfigAPIProtocolSupport },
    {"DatabaseName",                 ConfigDatabaseName },
    {"DatabasePath",                 ConfigDatabasePath },
    {"BackupPath",                   ConfigBackupPath },
    {"BackupInterval",               ConfigBackupInterval },
    {"DatabaseLoggingFlag",          ConfigDatabaseLoggingFlag },
    {"RestoreFlag",                  ConfigRestoreFlag },
    {"DatabaseCleanupInterval",      ConfigDatabaseCleanupInterval },
    {"DebugFlag",                    ConfigDebugFlag },
    {"ActivityLog",                  ConfigActivityLog },
    {"PingRetries",                  ConfigPingRetries },
    {"BootFileTable",                ConfigBootFileTable }
};




#define DHCPCMD_VERSION_MAJOR   4
#define DHCPCMD_VERSION_MINOR   1


#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

     DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG
DWORD
SetOptionDataType(
    LPSTR OptionTypeString,
    LPSTR OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT OptionData,
    LPWSTR *UnicodeOptionValueString
    )
{
    DHCP_OPTION_DATA_TYPE OptionType;
    DHCP_OPTION_ID OptionValue;

    if( _stricmp( OptionTypeString, "BYTE") == 0 ) {
        OptionType = DhcpByteOption;
    } else if( _stricmp( OptionTypeString, "WORD") == 0 ) {
        OptionType = DhcpWordOption;
    } else if( _stricmp( OptionTypeString, "DWORD") == 0 ) {
        OptionType = DhcpDWordOption;
    } else if( _stricmp( OptionTypeString, "STRING") == 0 ) {
        OptionType = DhcpStringDataOption;
    } else if( _stricmp( OptionTypeString, "IPADDRESS") == 0 ) {
        OptionType = DhcpIpAddressOption;
    } else {
        printf("OptionType either Unknown or not supported, %s.\n",
                OptionTypeString );
        return( ERROR_INVALID_PARAMETER );
    }

    OptionData->OptionType = OptionType;

    switch( OptionType ) {
    case DhcpByteOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );

        if( OptionValue & ~((BYTE)-1) ) {
            printf("DefValue is too large (%ld).\n", OptionValue );
            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.ByteOption = (BYTE)OptionValue;
        break;

    case DhcpWordOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );

        if( OptionValue & ~((WORD)-1) ) {
            printf("DefValue is too large (%ld).\n", OptionValue );
            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.WordOption = (WORD)OptionValue;
        break;

    case DhcpDWordOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );
        OptionData->Element.DWordOption = (DWORD)OptionValue;
        break;


    case DhcpIpAddressOption:
        OptionData->Element.IpAddressOption =
            DhcpDottedStringToIpAddress(OptionValueString);
        break;

    case DhcpStringDataOption:
        *UnicodeOptionValueString =
            DhcpOemToUnicode( OptionValueString, NULL );
        if( UnicodeOptionValueString == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        OptionData->Element.StringDataOption = *UnicodeOptionValueString;
        break;

    default:
        DhcpAssert(FALSE);
        printf("CreateOptionValue: Unknown OptionType \n");
        return( ERROR_INVALID_PARAMETER );
        break;
    }

    return( ERROR_SUCCESS );
}

COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    DhcpAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if( _stricmp( CommandName, GlobalCommandInfo[i].CommandName ) == 0 ) {
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    DhcpAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        printf( "    %s\n", GlobalCommandInfo[i].CommandName );
    }
}


DWORD
ProcessCreateSubnet(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_SUBNET_INFO SubnetInfo;
    LPWSTR UnicodeSubnetName = NULL;

    //
    // Expected Parameters are : <SubnetAddress SubnetMask SubnetName>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateSubnet [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress SubnetMask SubnetName>.\n" );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    SubnetInfo.SubnetAddress =
        DhcpDottedStringToIpAddress(CommandArgv[0]);
    SubnetInfo.SubnetMask =
        DhcpDottedStringToIpAddress(CommandArgv[1]);

    UnicodeSubnetName = DhcpOemToUnicode( CommandArgv[2], NULL );
    DhcpAssert( UnicodeSubnetName != NULL );

    SubnetInfo.SubnetName = UnicodeSubnetName;
    SubnetInfo.SubnetComment = NULL;
    SubnetInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(GlobalServerIpAddressAnsiString);

    SubnetInfo.PrimaryHost.NetBiosName = NULL;
    SubnetInfo.PrimaryHost.HostName = NULL;
    SubnetInfo.SubnetState = DhcpSubnetEnabled;

    Error = DhcpCreateSubnet(
                GlobalServerIpAddressUnicodeString,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

Cleanup:

    if( UnicodeSubnetName != NULL ) {
        DhcpFreeMemory( UnicodeSubnetName );
    }

    return( Error );
}

BOOL
IsValidServerVersion(
    DWORD dwMajor,
    DWORD dwMinor
    )
{
    DWORD dwServerVersion = MAKEWORD( dwMinor, dwMajor );
    return ( dwServerVersion >=
         MAKEWORD( DHCPCMD_VERSION_MINOR,
                   DHCPCMD_VERSION_MAJOR ));
}

DWORD
ProcessAddIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    ULONG MajorVersion, MinorVersion;
    ULONG Resume;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddIpRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

#ifdef NT5
    if( CommandArgc >= 4 ) {
        DHCP_BOOTP_IP_RANGE ThisRange = {IpRange.StartAddress, IpRange.EndAddress, 0, ~0};

        Element.Element.IpRange = (PVOID)&ThisRange;
        if( GlobalNoRPC ) {
            MajorVersion = CLASS_ID_VERSION;
        } else {
            Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
            if( ERROR_SUCCESS != Error ) {
                printf("Could not determine server version\n");
                return Error;
            }
        }

        if( MajorVersion >= CLASS_ID_VERSION ) {
            if( CommandArgc >= 5 ) {
                ThisRange.MaxBootpAllowed = strtoul( CommandArgv[4], NULL, 0 ) ;
            }

            if( 0 == _stricmp(CommandArgv[3], "DHCP") ) {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "BOOTP") ) {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "DHCPBOOTP" ) ) {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } else {
                printf("usage:DhcpCmd SrvIpAddress AddIpRange [Command Parameters].\n"
                       "<CommandParameters> - <SubnetAddress IpRangeStart"
                       " IpRangeEnd (DHCP | BOOTP | DHCPBOOTP)>\n");
                return ERROR_SUCCESS;
            }

            return DhcpAddSubnetElementV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                (PVOID)&Element
                );
        }
    }
#endif

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    return( Error );
}

DWORD
ProcessRemoveIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    ULONG MajorVersion, MinorVersion;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveIpRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

#ifdef NT5
    if( CommandArgc >= 4 ) {
        if( GlobalNoRPC ) {
            MajorVersion = CLASS_ID_VERSION;
        } else {
            Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
            if( ERROR_SUCCESS != Error ) {
                printf("Could not determine server version\n");
                return Error;
            }
        }

        if( MajorVersion >= CLASS_ID_VERSION ) {
            if( 0 == _stricmp(CommandArgv[3], "DHCP") ) {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "BOOTP") ) {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "DHCPBOOTP" ) ) {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } else {
                printf("usage:DhcpCmd SrvIpAddress AddIpRange [Command Parameters].\n"
                       "<CommandParameters> - <SubnetAddress IpRangeStart"
                       " IpRangeEnd (DHCP | BOOTP | DHCPBOOTP)>\n");
                return ERROR_SUCCESS;
            }

            return DhcpRemoveSubnetElementV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                (PVOID)&Element,
                FALSE
                );
        }
    }
#endif

    Error = DhcpRemoveSubnetElement(
        GlobalServerIpAddressUnicodeString,
        DhcpDottedStringToIpAddress(CommandArgv[0]),
        &Element,
        FALSE
        );

    return( Error );
}

#ifdef NT5
VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed
)
{
    printf("Range: %s -", DhcpIpAddressToDottedString( Start ) );
    printf("%s ", DhcpIpAddressToDottedString( End ) );

    switch(Type ) {
    case DhcpIpRanges : printf("\n"); break;
    case DhcpIpRangesDhcpOnly : printf("DHCP\n"); break;
    case DhcpIpRangesDhcpBootp:
        printf("DHCPBOOTP Bootp Clients leased = %d; Max Allowed BootpClients = %ld\n",
               BootpAllocated, MaxBootpAllowed
            );
        break;
    case DhcpIpRangesBootpOnly:
        printf("BOOTP     Bootp Clients leased = %d; Max Allowed BootpClients = %ld\n",
               BootpAllocated, MaxBootpAllowed
            );
        break;
    default: printf("Unknown range type: %ld\n", Type);
    }
}

DWORD
ProcessEnumIpRanges(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    ULONG Error;
    ULONG MajorVersion, MinorVersion;
    ULONG nRead, nTotal, i;
    ULONG Resume;
    BOOL fIsV5Call;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumIpRanges <SubnetAddress>\n");
        return ERROR_SUCCESS;
    }

    Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
    if( MajorVersion >= CLASS_ID_VERSION ) {
        fIsV5Call = TRUE;
    } else {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    while( TRUE ) {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;

        if( fIsV5Call ) {
            Error = DhcpEnumSubnetElementsV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } else {
            Error = DhcpEnumSubnetElementsV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( ERROR_SUCCESS == Error || ERROR_MORE_DATA == Error ) {
            for( i = 0; i < nRead ; i ++ ) {
                if( fIsV5Call ) {
                    PrintRange(
                        Elements5->Elements[i].ElementType,
                        Elements5->Elements[i].Element.IpRange->StartAddress,
                        Elements5->Elements[i].Element.IpRange->EndAddress,
                        Elements5->Elements[i].Element.IpRange->BootpAllocated,
                        Elements5->Elements[i].Element.IpRange->MaxBootpAllowed
                        );
                } else {
                    PrintRange(
                        Elements4->Elements[i].ElementType,
                        Elements4->Elements[i].Element.IpRange->StartAddress,
                        Elements4->Elements[i].Element.IpRange->EndAddress,
                        0,
                        0
                        );
                }
            }
        }

        if( Elements4 ) DhcpRpcFreeMemory( Elements4 );
        if( Elements5 ) DhcpRpcFreeMemory( Elements5 );
        if( ERROR_SUCCESS == Error || ERROR_NO_MORE_ITEMS == Error ) break;
        if( ERROR_MORE_DATA != Error ) return Error;
    }

    return ERROR_SUCCESS;
}

#endif NT5

#define COMMAND_ARG_TYPE        5

DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
)
{
    DWORD dwResult = ERROR_SUCCESS;


    if ( cArgs > COMMAND_ARG_TYPE )
    {
        // user specified the allowed client type

        if ( !_stricmp( ppszArgs[ COMMAND_ARG_TYPE ], "bootp" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOOTP;
        }
        else if ( !_stricmp ( ppszArgs[ COMMAND_ARG_TYPE ], "dhcp" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }
        else if ( !_stricmp ( ppszArgs[ COMMAND_ARG_TYPE ], "both" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else
        {
            printf( "Specify BOOTP, DHCP, or BOTH for reservation type.\n" );
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // allow dhcp clients by default.
        pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        return ERROR_SUCCESS;
    }

    return dwResult;
}



DWORD
ProcessAddReservedIp(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
#define MAX_ADDRESS_LENGTH  64  // 64 bytes
#define COMMAND_ARG_CLIENT_COMMENT  4

    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4 ReserveElement;
    DHCP_CLIENT_UID ClientUID;
    BYTE  Address[MAX_ADDRESS_LENGTH];
    DWORD i;
    DHCP_IP_ADDRESS ReservedIpAddress;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //

    //
    // if the server version is 4.1 or greater, <AllowedClientTypes> and <BootFileString> can
    // also be supplied
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddReservedIp "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress ReservedIp HWAddressString [ClientName] [ClientComment]"
            " [DHCP | BOOTP | BOTH]>\n" );

        return( ERROR_SUCCESS );
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = strlen(CommandArgv[2]);
    if( ClientUID.DataLength % 2 != 0 ) {
        //
        // address must be even length.
        //

        printf("ProcessAddReservedIp: address must be even length.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    ClientUID.DataLength /= 2;
    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

    i = DhcpStringToHwAddress( (LPSTR)Address, CommandArgv[2] );
    DhcpAssert( i == ClientUID.DataLength );
    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReservedIpAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    ReserveElement.ReservedIpAddress = ReservedIpAddress;
    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = ProcessBootpParameters( CommandArgc, CommandArgv, &ReserveElement );
    if ( ERROR_SUCCESS != Error )
    {
        return Error;
    }

    Error = DhcpAddSubnetElementV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // if we are asked to set the client name, do so.
    //

    if( CommandArgc > 3 ) {

        DHCP_SEARCH_INFO ClientSearchInfo;
        LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;
        LPWSTR UnicodeClientName = NULL;
        LPWSTR UnicodeClientComment = NULL;

        //
        // set client name.
        //

        ClientSearchInfo.SearchType = DhcpClientIpAddress;
        ClientSearchInfo.SearchInfo.ClientIpAddress = ReservedIpAddress;

        do {

            Error = DhcpGetClientInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        &ClientSearchInfo,
                        &ClientInfo );

            if( Error != ERROR_SUCCESS ) {
                break;
            }

            UnicodeClientName =  DhcpOemToUnicode( CommandArgv[3], NULL );

            if( UnicodeClientName == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if ( ( wcslen( UnicodeClientName ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) {
                printf("ProcessAddReservedIp: Client Name too long\n");
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // if client comment is also given in the argument, store that
            // as well.
            //
            if ( CommandArgc > COMMAND_ARG_CLIENT_COMMENT ) {

                UnicodeClientComment    =   DhcpOemToUnicode( CommandArgv[COMMAND_ARG_CLIENT_COMMENT], NULL );

                if (!UnicodeClientComment ) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //
                // check the size here.
                //
                if ( ( wcslen( UnicodeClientComment ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) {
                    printf("ProcessAddReservedIp: Client Comment too long\n");
                    Error = ERROR_INVALID_PARAMETER;
                    break;
                }

                ClientInfo->ClientComment = UnicodeClientComment;



            }

            ClientInfo->ClientName = UnicodeClientName;

        } while ( FALSE );

        if ( Error == ERROR_SUCCESS ) {

            Error = DhcpSetClientInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        ClientInfo );

        } else {
            //
            // Cleanup.
            //
            if ( ClientInfo ) {
                DhcpRpcFreeMemory( ClientInfo );
            }
            if ( UnicodeClientName ) {
                DhcpFreeMemory( UnicodeClientName );
            }
            if ( UnicodeClientComment ) {
                DhcpFreeMemory( UnicodeClientComment );
            }
        }

    } // if( CommandArgc > 3 )


    return( Error );
}

DWORD
ProcessAddExcludeRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddExcludeRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    return( Error );
}

DWORD
ProcessRemoveExcludeRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_IP_RANGE IpRange;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveExcludeRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element,
                DhcpFullForce );

    return( Error );
}

DWORD
ProcessRemoveReservedIp(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4 ReserveElement;
    DHCP_CLIENT_UID ClientUID;
    BYTE  Address[MAX_ADDRESS_LENGTH];
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveReservedIp "
                    "[Command Parameters].\n"
                    "<Command Parameters> - "
                    "<SubnetAddress ReservedIp HWAddressString>.\n" );

        return( ERROR_SUCCESS );
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = strlen(CommandArgv[2]);
    if( ClientUID.DataLength % 2 != 0 ) {
        //
        // address must be even length.
        //

        printf("ProcessAddReservedIp: address must be even length.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    ClientUID.DataLength /= 2;
    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

    i = DhcpStringToHwAddress( (LPSTR)Address, CommandArgv[2] );
    DhcpAssert( i == ClientUID.DataLength );
    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReserveElement.ReservedIpAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = DhcpRemoveSubnetElementV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element,
                DhcpFullForce );

    return( Error );
}

DWORD
ProcessSetSubnetState(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SUBNET_INFO SubnetInfo;
    LPWSTR UnicodeSubnetName = NULL;
    DWORD State;

    //
    // Expected Parameters are : <SubnetAddress SubnetMask SubnetName>
    //


    if( CommandArgc < 2 ) {
        printf("usage:DhcpCmd SrvIpAddress SetSubnetState [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress State>.\n" );
        Error = ERROR_SUCCESS;
        return( Error );
    }

    Error = DhcpGetSubnetInfo(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &SubnetInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    State = strtoul( CommandArgv[1], NULL, 0 );

    if( State == 0 ) {
        if( SubnetInfo->SubnetState == DhcpSubnetEnabled ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
        SubnetInfo->SubnetState = DhcpSubnetEnabled;
    }
    else {
        if( SubnetInfo->SubnetState == DhcpSubnetDisabled ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
        SubnetInfo->SubnetState = DhcpSubnetDisabled;
    }

    Error = DhcpSetSubnetInfo(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                SubnetInfo );
Cleanup:

    if( SubnetInfo != NULL ) {
        DhcpFreeMemory( SubnetInfo );
    }

    return( Error );

}

DWORD
ProcessDeleteSubnet(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                SubnetAddress;
    DHCP_FORCE_FLAG                ForceFlag;

    //
    // Expected Parameters are :
    //  <SubnetAddress ForceFlag>
    // <ForceFlag> : "DhcpFullForce" "DhcpNoForce"

    if( CommandArgc != 2 ) {
        printf("usage: DhcpCmd SrvIpAddress DeleteSubnet [Command Parameters].\n"
               "<CommandParameters> - <SubnetAddress ForceFlag>.\n");
        printf("<ForceFlag> : <DhcpFullForce | DhcpNoForce>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    SubnetAddress = DhcpDottedStringToIpAddress( CommandArgv[0] );
    if( 0 == _stricmp(CommandArgv[1], "DhcpFullForce" ) ) {
        ForceFlag = DhcpFullForce;
    } else if( 0 == _stricmp(CommandArgv[1], "DhcpNoForce" ) ) {
        ForceFlag = DhcpNoForce;
    } else {
        printf("Unknown force flag value: %s (expecting DhcpFullForce or DhcpNoForce)\n",
               CommandArgv[1]);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Error = DhcpDeleteSubnet(
        GlobalServerIpAddressUnicodeString,
        SubnetAddress,
        ForceFlag
    );

  Cleanup:

    return Error;
}

DWORD
_CreateOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DHCP_OPTION           *OptionInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpCreateOptionV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpCreateOption(
        ServerAddress,
        OptionId,
        OptionInfo
    );
}

ProcessCreateOption(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION OptionInfo;
    DHCP_OPTION_ID OptionID;
    LPWSTR UnicodeOptionName = NULL;
    LPWSTR UnicodeOptionValueString = NULL;
    DHCP_OPTION_DATA_ELEMENT OptionData;

    //
    // Expected Parameters are :
    //  <OptionID OptionName DefValueType DefValue>
    //


    if( CommandArgc < 2 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateOption [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionName <DefValueType DefValue>>.\n");
        printf("<DefValueType> : <BYTE | WORD | DWORD | STRING | IPADDRESS>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    OptionInfo.OptionID = OptionID;

    UnicodeOptionName = DhcpOemToUnicode( CommandArgv[1], NULL );
    if( UnicodeOptionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    OptionInfo.OptionName = UnicodeOptionName;
    OptionInfo.OptionComment = NULL;

    if( CommandArgc >= 4 ) {
        Error = SetOptionDataType(
            CommandArgv[2],
            CommandArgv[3],
            &OptionData,
            &UnicodeOptionValueString
        );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        OptionInfo.DefaultValue.NumElements = 1;
        OptionInfo.DefaultValue.Elements = &OptionData;
    }
    else {
        OptionInfo.DefaultValue.NumElements = 0;
        OptionInfo.DefaultValue.Elements = NULL;
    }

    OptionInfo.OptionType = DhcpUnaryElementTypeOption;

    Error = _CreateOption(
        GlobalServerIpAddressUnicodeString,
        0,
        OptionID,
        GlobalClassName,
        GlobalVendorName,
        &OptionInfo
    );

Cleanup:
    if( UnicodeOptionName != NULL ) {
        DhcpFreeMemory( UnicodeOptionName );
    }

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );

}

DWORD
RemoveOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpRemoveOptionV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpRemoveOption(
        ServerAddress,
        OptionId
    );
}

ProcessDeleteOption(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;

    //
    // Expected Parameters are :
    //  <OptionID>
    //


    if( CommandArgc != 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteOption [Command Parameters].\n"
            "<Command Parameters> - <OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    Error = RemoveOption(
        GlobalServerIpAddressUnicodeString,
        0,
        OptionID,
        GlobalClassName,
        GlobalVendorName
    );

Cleanup:

    return Error ;
}

DWORD
SetOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpSetOptionValueV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpSetOptionValue(
        ServerAddress,
        OptionId,
        ScopeInfo,
        OptionValue
    );
}


ProcessSetGlobalOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress SetGlobalOptionValue [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    Error = SetOptionDataType(
        CommandArgv[1],
        CommandArgv[2],
        &OptionData,
        &UnicodeOptionValueString
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );
Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

DWORD
SetOptionValues(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpSetOptionValuesV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValues
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpSetOptionValues(
        ServerAddress,
        ScopeInfo,
        OptionValues
    );
}

ProcessSetGlobalOptionValues(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{

#define NUM_VALUES      5

    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData[NUM_VALUES];
    LPWSTR UnicodeOptionValueString[NUM_VALUES];

    DHCP_OPTION_VALUE_ARRAY ValuesArray;
    DHCP_OPTION_VALUE Values[NUM_VALUES];
    DWORD NumValue;

    RtlZeroMemory( UnicodeOptionValueString, NUM_VALUES * sizeof(LPWSTR) );

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress SetGlobalOptionValues [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionType OptionValue> <..>.\n"); Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    for (NumValue = 0;
            (CommandArgc >= 3) && (NumValue < NUM_VALUES);
                NumValue++, CommandArgc -= 3, CommandArgv += 3 ) {

       OptionID = strtoul( CommandArgv[0], NULL, 0 );

       Error = SetOptionDataType(
           CommandArgv[1],
           CommandArgv[2],
           &OptionData[NumValue],
           &UnicodeOptionValueString[NumValue]
       );

       if( Error != ERROR_SUCCESS ) {
           goto Cleanup;
       }

       Values[NumValue].OptionID = OptionID;
       Values[NumValue].Value.NumElements = 1;
       Values[NumValue].Value.Elements = &OptionData[NumValue];
    }

    ValuesArray.NumElements = NumValue;
    ValuesArray.Values = Values;

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValues(
        GlobalServerIpAddressUnicodeString,
        0,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &ValuesArray
    );

Cleanup:

    for (NumValue = 0; NumValue < NUM_VALUES; NumValue++) {

       if( UnicodeOptionValueString[NumValue] != NULL ) {
           DhcpFreeMemory( UnicodeOptionValueString );
       }
    }

    return( Error );
}

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpRemoveOptionValueV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpRemoveOptionValue(
        ServerAddress,
        OptionID,
        ScopeInfo
    );
}

DWORD
ProcessRemoveGlobalOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc != 1 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveGlobalOptionValue [Command Parameters].\n"
            "<Command Parameters> - <OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}

ProcessSetSubnetOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 4 ) {
        printf("usage:DhcpCmd SrvIpAddress SetSubnetOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  DhcpDottedStringToIpAddress( CommandArgv[0] );

    OptionID = strtoul( CommandArgv[1], NULL, 0 );

    Error = SetOptionDataType(
                CommandArgv[2],
                CommandArgv[3],
                &OptionData,
                &UnicodeOptionValueString );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );

Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

ProcessRemoveSubnetOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    if( CommandArgc != 2 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveSubnetOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  DhcpDottedStringToIpAddress( CommandArgv[0] );

    OptionID = strtoul( CommandArgv[1], NULL, 0 );

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}

ProcessSetReservedOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 5 ) {
        printf("usage:DhcpCmd SrvIpAddress SetReservedOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress Reservation-Address OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	DhcpDottedStringToIpAddress(CommandArgv[0]);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	DhcpDottedStringToIpAddress( CommandArgv[1] );

    OptionID = strtoul( CommandArgv[2], NULL, 0 );

    Error = SetOptionDataType(
        CommandArgv[3],
        CommandArgv[4],
        &OptionData,
        &UnicodeOptionValueString
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );

Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

ProcessRemoveReservedOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveReservedOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress Reservation-Address OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	DhcpDottedStringToIpAddress(CommandArgv[0]);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	DhcpDottedStringToIpAddress( CommandArgv[1] );

    OptionID = strtoul( CommandArgv[2], NULL, 0 );

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->SubnetMask));

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tComment = %ws.\n", ClientInfo->ClientComment);
    printf("\tType = " );

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            szClientType= "None";
            break;

        case CLIENT_TYPE_DHCP:
            szClientType = "DHCP";
            break;

        case CLIENT_TYPE_BOOTP:
            szClientType = "BOOTP";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
            szClientType = "Unspecified";
            break;

        default:
            DhcpAssert( FALSE );
    }
    printf( "%s\n", szClientType );

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

}

#ifdef NT5
VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->SubnetMask));

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tComment = %ws.\n", ClientInfo->ClientComment);
    printf("\tType = " );

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            szClientType= "None";
            break;

        case CLIENT_TYPE_DHCP:
            szClientType = "DHCP";
            break;

        case CLIENT_TYPE_BOOTP:
            szClientType = "BOOTP";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
            szClientType = "Unspecified";
            break;

        default:
            DhcpAssert( FALSE );
    }
    printf( "%s\n", szClientType );

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

    printf("\tState = %0x\n", ClientInfo->AddressState );
}
#endif NT5

VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }

    printf( "\n" );
}

#ifdef NT5
VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }
    printf( "State=%02x", ClientInfo->AddressState);
    printf( "\n" );
}
#endif NT5

VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    for( i = 0; i < DataLength; i++ ) {
        printf("%.2lx", (DWORD)Data[i]);
    }

    printf( "\n" );
}

DWORD
DetectIpAddressConflict(
    DHCP_IP_ADDRESS IpAddress,
    DWORD dwRetries,
    LPBOOL AddressExists
    )
/*++

Routine Description:

    This function pings the specific IP address and checks if it exists

    The number of "ping" retries is controled by the parameter
DetectConflictRetries in the registry. When it is set to 0, this
function always sets result to FALSE.

Arguments:

    IpAddress - The IP address to check

    AddressExists - pointer to the variable where the result is to be stored

Return Value:

    Windows Error

--*/

{
    HANDLE IcmpHandle;
    char ReplyBuffer [1000];
    DWORD NumReplies = 0;
    DWORD i,
          dwResult;

    DhcpAssert( dwRetries );

    *AddressExists = FALSE;



    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE)
        return GetLastError();


    for (i = 0; i < dwRetries; i++) {

        NumReplies = IcmpSendEcho(
            IcmpHandle,
            (IPAddr) ntohl(IpAddress),
            (LPVOID) "DHCP Server Bad Address",
            (WORD)strlen("DHCP Server Bad Address"),
            NULL,
            ReplyBuffer,
            sizeof(ReplyBuffer),
            1000
            );

        if (NumReplies != 0) {
            break;
        }
    }

    dwResult = GetLastError();

    // IcmpSendEcho will also return 0 to indicate an error condition.
    // IP_REQ_TIMED_OUT indicates no response

    if ( IP_REQ_TIMED_OUT == dwResult )
        dwResult = 0;

    IcmpCloseHandle (IcmpHandle);

    *AddressExists = (NumReplies != 0);


    return dwResult;
}

BOOL
AddressCanBeDeleted(
    IN DHCP_IP_ADDRESS Address
    )
{
    BOOL RetVal;

    RetVal = TRUE;
    DetectIpAddressConflict(
        Address,
        3,
        &RetVal
        );
    if( RetVal ) {
        printf("This address exists, so it wont be deleted\n");
    } else {
        printf("This address does not exist, so it will be deleted.\n");
    }

    return !RetVal;
}

DWORD
ProcessDeleteClient(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DHCP_SEARCH_INFO SrchInfo;
    DWORD Error;

    if( CommandArgc != 1 ) {
        printf("Usage: DhcpCmd SrvIpAddress DeleteClient ClientIp\n");
        return ERROR_INVALID_PARAMETER;
    }

    SrchInfo.SearchType = DhcpClientIpAddress;
    SrchInfo.SearchInfo.ClientIpAddress = htonl(
        inet_addr( CommandArgv[0]) );

    Error = DhcpDeleteClientInfo(
        GlobalServerIpAddressUnicodeString, &SrchInfo );

    if( NO_ERROR != Error ) {
        printf("DhcpDeleteClientInfo failed %ld\n", Error);
    }

    return Error;
}

DWORD
ProcessDeleteBadClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    BOOL NoPing = FALSE;
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;


    if( CommandArgc > 1 || (
        CommandArgc == 1 && _stricmp(CommandArgv[0], "NOPING") ) ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteBadClients [NOPING]\n");
        return ERROR_SUCCESS;
    }

    NoPing = (CommandArgc == 1 );

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
            GlobalServerIpAddressUnicodeString,
            0,
            &ResumeHandle,
            (DWORD)(-1),
            &ClientEnumInfo,
            &ClientsRead,
            &ClientsTotal
            );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );


        for( i = 0; i < ClientsRead; i++ ) {
            if( NULL == ClientEnumInfo->Clients[i]->ClientName ) {
                //
                // No name? Can that be a bad client? no.
                //
                continue;
            }

            if( wcscmp(ClientEnumInfo->Clients[i]->ClientName, L"BAD_ADDRESS" ) ) {
                //
                // Not a bad client! ignore it.
                //
                continue;
            }

            PrintClientInfoShort1( ClientEnumInfo->Clients[i] );
            if( NoPing || AddressCanBeDeleted(ClientEnumInfo->Clients[i]->ClientIpAddress) ) {
                DHCP_SEARCH_INFO SrchInfo2 = {
                    DhcpClientIpAddress,
                    ClientEnumInfo->Clients[i]->ClientIpAddress
                };

                Error = DhcpDeleteClientInfo(
                    GlobalServerIpAddressUnicodeString,
                    &SrchInfo2
                    );
                if( ERROR_SUCCESS != Error ) {
                    printf("DhcpDeleteClientInfo failed %ld, continuing. \n", Error);
                }
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
    return 0;
}


#ifdef NT5
VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    for( i = 0; i < DataLength; i++ ) {
        printf("%.2lx", (DWORD)Data[i]);
    }

    printf(" State=%02x\n", ClientInfo->AddressState);
    printf( "\n" );
}


DWORD
ProcessEnumClientsV5(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V5 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV5(
                    GlobalServerIpAddressUnicodeString,
                    DhcpDottedStringToIpAddress(CommandArgv[0]),
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort1V5( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoV5( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShortV5( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintClientInfoShortV5( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}
#endif NT5

DWORD
ProcessEnumClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
                    GlobalServerIpAddressUnicodeString,
                    DhcpDottedStringToIpAddress(CommandArgv[0]),
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort1( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfo( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintClientInfoShort( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}


DWORD
ProcessMibCounts(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_MIB_INFO MibInfo = NULL;
    DWORD i;
    LPSCOPE_MIB_INFO ScopeInfo;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    Error = DhcpGetMibInfo(
                GlobalServerIpAddressUnicodeString,
                &MibInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    DhcpAssert( MibInfo != NULL );

    printf("Discovers = %d.\n", MibInfo->Discovers);
    printf("Offers = %d.\n", MibInfo->Offers);
    printf("Requests = %d.\n", MibInfo->Requests);
    printf("Acks = %d.\n", MibInfo->Acks);
    printf("Naks = %d.\n", MibInfo->Naks);
    printf("Declines = %d.\n", MibInfo->Declines);
    printf("Releases = %d.\n", MibInfo->Releases);
    printf("ServerStartTime = ");

    if( FileTimeToLocalFileTime(
            (FILETIME *)(&MibInfo->ServerStartTime),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("Scopes = %d.\n", MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) {
        printf("Subnet = %s.\n",
                    DhcpIpAddressToDottedString(ScopeInfo[i].Subnet));
        printf("\tNumAddressesInuse = %d.\n",
                    ScopeInfo[i].NumAddressesInuse );
        printf("\tNumAddressesFree = %d.\n",
                    ScopeInfo[i].NumAddressesFree );
        printf("\tNumPendingOffers = %d.\n",
                    ScopeInfo[i].NumPendingOffers );
    }

    DhcpRpcFreeMemory( MibInfo );

    return( ERROR_SUCCESS );
}

VOID
PrintConfigCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalConfigCommandInfo) /
                        sizeof(CONFIG_COMMAND_INFO);

    DhcpAssert( NumCommands <= UnknownConfigCommand );
    for( i = 0; i < NumCommands; i++) {
        printf( "\t%ld. %s\n",
            i, GlobalConfigCommandInfo[i].CommandName );
    }
}

CONFIG_COMMAND_CODE
DecodeConfigCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalConfigCommandInfo) /
                    sizeof(CONFIG_COMMAND_INFO);

    DhcpAssert( NumCommands <= UnknownConfigCommand );
    for( i = 0; i < NumCommands; i++) {
        if( _stricmp( CommandName,
                GlobalConfigCommandInfo[i].CommandName ) == 0 ) {
            return( GlobalConfigCommandInfo[i].CommandCode );
        }
    }
    return( UnknownConfigCommand );
}

//
// this function assumes input of the following format:
//
// [generic name1],[server name1],<boot file1>;[generic name2],...
//
//


WCHAR *
ParseBootFileTable(
    char     *szBootFileTable,
    DWORD    *pcb
    )
{
    WCHAR *pwszOutput;
    DWORD  cb;

    *pcb = 0;
    cb = strlen( szBootFileTable ) + 2; // double null terminator

    pwszOutput = DhcpAllocateMemory( cb * sizeof( WCHAR ) );
    if ( pwszOutput )
    {
        WCHAR *pwszTemp = DhcpOemToUnicode( szBootFileTable, pwszOutput );

        if ( !pwszTemp )
        {
            // conversion failed
            DhcpFreeMemory( pwszOutput );
            pwszOutput = NULL;
        }
        else
        {
            // replace ';' with '\0'
            while ( *pwszTemp )
            {
                if ( L';' == *pwszTemp )
                {
                    *pwszTemp = L'\0';
                }

                ++pwszTemp;
            }

            *pcb = cb * sizeof( WCHAR );

            // add 2cnd null terminator
            pwszOutput[ cb - 1 ] = L'\0';
        }

    }

    return pwszOutput;
}




void PrintBootFileString(
    WCHAR *wszBootFileString
    )
{
    WCHAR *pwszBootFile = wszBootFileString;

    while( *pwszBootFile != BOOT_FILE_STRING_DELIMITER_W )
        pwszBootFile++;

    *pwszBootFile = L'\0';

    printf( "Bootfile Server = %S\n", wszBootFileString );
    printf( "Bootfile = %S\n\n", ++pwszBootFile );
}

void PrintBootTableString(
    WCHAR *wszBootFileTable
    )
{
    while( *wszBootFileTable )
    {
        WCHAR *pwszDelimiter = wszBootFileTable;
        DWORD cb = wcslen( wszBootFileTable ) + 1;

        while( *pwszDelimiter != BOOT_FILE_STRING_DELIMITER_W )
            pwszDelimiter++;

        *pwszDelimiter = L'\0';
        printf( "Generic Bootfile request = %S\n", wszBootFileTable );
        PrintBootFileString( ++pwszDelimiter );

        wszBootFileTable += cb;
    }
}

DWORD ProcessRemoveSubscope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DHCP_IP_ADDRESS SubnetAddress;
    DWORD           dwResult;

    if( CommandArgc < 1 )
    {
        printf("usage:DhcpCmd SrvIpAddress RemoveSubscope <scope ID>.\n" );
        return( ERROR_SUCCESS );
    }

    SubnetAddress = htonl( inet_addr( CommandArgv[0] ) );

    dwResult = DhcpSetSuperScopeV4(
        GlobalServerIpAddressUnicodeString,
        SubnetAddress,
        NULL,
        TRUE
    );

    return dwResult;
}

DWORD ProcessSetSuperScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DHCP_IP_ADDRESS SubnetAddress;
    WCHAR           *pwszSuperScopeName;
    BOOL            fChangeExisting;
    DWORD           dwResult;

    if( CommandArgc < 3 )
    {
        printf("usage:DhcpCmd SrvIpAddress SetSuperScope <SuperScope name> <scope ID> <1|0>\n" );
        return( ERROR_SUCCESS );
    }

    pwszSuperScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    SubnetAddress = htonl( inet_addr( CommandArgv[1] ) );
    fChangeExisting = (BOOL) ( *(CommandArgv[2]) - '0' );

    dwResult = DhcpSetSuperScopeV4( GlobalServerIpAddressUnicodeString,
                                    SubnetAddress,
                                    pwszSuperScopeName,
                                    fChangeExisting );

    return dwResult;
}

DWORD ProcessDeleteSuperScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    WCHAR *pwszSuperScope;
    DWORD  dwResult;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteSuperScope <scope name>.\n" );
        return( ERROR_SUCCESS );
    }

    printf( "Deleting SuperScope %s\n", CommandArgv[0] );

    pwszSuperScope = DhcpOemToUnicode( CommandArgv[0], NULL );
    dwResult = DhcpDeleteSuperScopeV4( GlobalServerIpAddressUnicodeString,
                                       pwszSuperScope );

    DhcpFreeMemory( pwszSuperScope );

    return dwResult;
}

DWORD ProcessGetSuperScopeTable(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DHCP_SUPER_SCOPE_TABLE *pTable = NULL;
    DWORD dwResult;

    dwResult = DhcpGetSuperScopeInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        &pTable );
    if ( ERROR_SUCCESS == dwResult )
    {
        DWORD n;

        for ( n = 0; n < pTable->cEntries; n++ )
        {
            IN_ADDR InAddr;

            InAddr.s_addr = htonl( pTable->pEntries[n].SubnetAddress );

            printf( "Superscope name = %S\n", pTable->pEntries[n].SuperScopeName );
            printf( "Subnet address = %s\n", inet_ntoa( InAddr ) );
            printf( "Superscope goup number = %d\n", pTable->pEntries[n].SuperScopeNumber );
        }


        DhcpRpcFreeMemory( pTable );
    }


    return ERROR_SUCCESS;
}

DWORD
ProcessServerConfig(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD FieldsToSet = 0;
    CONFIG_COMMAND_CODE CommandCode;
    DWORD Value;
    LPWSTR ValueString;

    if( CommandArgc < 1 ) {

        Error = DhcpServerGetConfigV4(
                    GlobalServerIpAddressUnicodeString,
                    &ConfigInfo );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        DhcpAssert( ConfigInfo != NULL );

        printf("APIProtocolSupport = %lx\n", ConfigInfo->APIProtocolSupport );
        printf("DatabaseName = %ws\n", ConfigInfo->DatabaseName );
        printf("DatabasePath = %ws\n", ConfigInfo->DatabasePath );
        printf("BackupPath = %ws\n", ConfigInfo->BackupPath );
        printf("BackupInterval = %ld mins.\n",
                ConfigInfo->BackupInterval );
        printf("DatabaseLoggingFlag = %ld\n", ConfigInfo->DatabaseLoggingFlag );
        printf("RestoreFlag = %ld\n", ConfigInfo->RestoreFlag );
        printf("DatabaseCleanupInterval = %ld mins.\n",
                ConfigInfo->DatabaseCleanupInterval );
        printf("DebugFlag = %lx\n", ConfigInfo->DebugFlag );
        printf("PingRetries = %d\n", ConfigInfo->dwPingRetries );
        printf("ActivityLog = %d\n", (DWORD) ConfigInfo->fAuditLog );

        if ( ConfigInfo->cbBootTableString )
        {
            printf( "BOOTP request table:\n" );
            PrintBootTableString( ConfigInfo->wszBootTableString );
        }

        DhcpRpcFreeMemory( ConfigInfo );

        return( Error );
    }


    if ( CommandArgc == 1)
    {
        ++CommandArgc;
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

        if( ConfigInfo == NULL ) {
            printf("Insufficient memory\n");
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        RtlZeroMemory( ConfigInfo, sizeof( *ConfigInfo ) );
    }
    while( CommandArgc >= 2 ) {


        CommandCode = DecodeConfigCommand( CommandArgv[0] );

        Value = 0;
        ValueString = NULL;

        switch( CommandCode )
        {
            case ConfigDatabaseName:
            case ConfigDatabasePath:
            case ConfigBackupPath:
            case ConfigAPIProtocolSupport:
            case ConfigBackupInterval:
            case ConfigDatabaseLoggingFlag:
            case ConfigRestoreFlag:
            case ConfigDatabaseCleanupInterval:
            case ConfigDebugFlag:
            case ConfigActivityLog:
            case ConfigPingRetries:
                Value = atoi( CommandArgv[1] );
                break;

            case ConfigBootFileTable:
                ValueString = ParseBootFileTable( CommandArgv[1],
                                                  &Value );
                break;
        }


        switch( CommandCode ) {
        case ConfigAPIProtocolSupport:
            FieldsToSet |= Set_APIProtocolSupport;
            ConfigInfo->APIProtocolSupport = Value;
            break;

        case ConfigDatabaseName:
            FieldsToSet |= Set_DatabaseName;
            ConfigInfo->DatabaseName = ValueString;
            break;

        case ConfigDatabasePath:
            FieldsToSet |= Set_DatabasePath;
            ConfigInfo->DatabasePath = ValueString;
            break;

        case ConfigBackupPath:
            FieldsToSet |= Set_BackupPath;
            ConfigInfo->BackupPath = ValueString;
            break;

        case ConfigBackupInterval:
            FieldsToSet |= Set_BackupInterval;
            ConfigInfo->BackupInterval = Value;
            break;

        case ConfigDatabaseLoggingFlag:
            FieldsToSet |= Set_DatabaseLoggingFlag;
            ConfigInfo->DatabaseLoggingFlag = Value;
            break;

        case ConfigRestoreFlag:
            FieldsToSet |= Set_RestoreFlag;
            ConfigInfo->RestoreFlag = Value;
            break;

        case ConfigDatabaseCleanupInterval:
            FieldsToSet |= Set_DatabaseCleanupInterval;
            ConfigInfo->DatabaseCleanupInterval = Value;
            break;

        case ConfigDebugFlag:
            FieldsToSet |= Set_DebugFlag;
            ConfigInfo->DebugFlag = Value;
            break;


        case ConfigPingRetries:
            FieldsToSet |= Set_PingRetries;
            ConfigInfo->dwPingRetries = Value;
            break;

        case ConfigActivityLog:
            FieldsToSet |= Set_AuditLogState;
            ConfigInfo->fAuditLog = (BOOL) Value;
            break;

        case ConfigBootFileTable:

            FieldsToSet |= Set_BootFileTable;
            ConfigInfo->wszBootTableString  = ValueString;
            ConfigInfo->cbBootTableString = Value;

            break;

        case UnknownConfigCommand:
        default:
            printf("usage:DhcpCmd SrvIpAddress ServerConfig "
                    "[ConfigCommand ConfigValue]"
                    "[ConfigCommand ConfigValue]"
                    "... \n");

            printf("ConfigCommands : \n");
            PrintConfigCommands();

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        CommandArgc -= 2;
        CommandArgv += 2;
    }

    Error = DhcpServerSetConfigV4(
                GlobalServerIpAddressUnicodeString,
                FieldsToSet,
                ConfigInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = ProcessServerConfig( 0, NULL );

Cleanup:

    if( ConfigInfo != NULL ) {

        if( ConfigInfo->DatabaseName != NULL ) {
            DhcpFreeMemory( ConfigInfo->DatabaseName );
        }

        if( ConfigInfo->DatabasePath != NULL ) {
            DhcpFreeMemory( ConfigInfo->DatabasePath );
        }

        if( ConfigInfo->BackupPath != NULL ) {
            DhcpFreeMemory( ConfigInfo->BackupPath );
        }

        DhcpFreeMemory( ConfigInfo );
    }

    return( Error );
}

DWORD
ProcessCheckDB(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SCAN_LIST ScanList = NULL;
    BOOL FixFlag = FALSE;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress CheckDB [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress> <[Fix]>.\n" );
        return( ERROR_SUCCESS );
    }

    if( CommandArgc >= 2 ) {

        //
        // parse fix parameter.
        //

        if( _stricmp(CommandArgv[0], "fix") ) {
            FixFlag = TRUE;
        }
    }

    //
    // scan dhcp database and registry, check consistency and get bad
    // entries if any.
    //

    Error = DhcpScanDatabase(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                FixFlag,
                &ScanList
                );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpScanDatabase failed, %ld.\n", Error );
        return( Error );
    }

    //
    // display bad entries.
    //

    if( (ScanList != NULL) &&
        (ScanList->NumScanItems != 0) &&
        (ScanList->ScanItems != NULL) ) {

        LPDHCP_SCAN_ITEM ScanItem;
        LPDHCP_SCAN_ITEM ScanItemEnd;
        DWORD i = 1;

        ScanItemEnd =
            ScanList->ScanItems +
            ScanList->NumScanItems;

        for( ScanItem = ScanList->ScanItems;
                ScanItem < ScanItemEnd; ScanItem++ ) {

            printf("%ld %- 16.16s ",
                i++,
                DhcpIpAddressToDottedString(ScanItem->IpAddress) );

            if( ScanItem->ScanFlag == DhcpRegistryFix ) {
                printf("Fix Registry\n");
            }
            else if( ScanItem->ScanFlag == DhcpDatabaseFix ) {
                printf("Fix Database\n");
            }
            else {
                printf("Fix Unknown\n");
            }
        }
    }

    return( ERROR_SUCCESS );
}

VOID
PrintOptionValue(
    LPDHCP_OPTION_DATA OptionValue
    )
{
    DWORD NumElements;
    DHCP_OPTION_DATA_TYPE OptionType;
    DWORD i;

    printf("Option Value : \n");
    NumElements = OptionValue->NumElements;

    printf("\tNumber of Option Elements = %ld\n", NumElements );

    if( NumElements == 0 ) {
        return;
    }

    OptionType = OptionValue->Elements[0].OptionType;
    printf("\tOption Elements Type = " );

    switch( OptionType ) {
    case DhcpByteOption:
        printf("DhcpByteOption\n");
        break;

    case DhcpWordOption:
        printf("DhcpWordOption\n");
        break;

    case DhcpDWordOption:
        printf("DhcpDWordOption\n");
        break;

    case DhcpDWordDWordOption:
        printf("DhcpDWordDWordOption\n");
        break;

    case DhcpIpAddressOption:
        printf("DhcpIpAddressOption\n");
        break;

    case DhcpStringDataOption:
        printf("DhcpStringDataOption\n");
        break;

    case DhcpBinaryDataOption:
        printf("DhcpBinaryDataOption\n");
        break;

    case DhcpEncapsulatedDataOption:
        printf("DhcpEncapsulatedDataOption\n");
        break;
    default:
        printf("Unknown\n");
        return;
    }

    for( i = 0; i < OptionValue->NumElements; i++ ) {
        DhcpAssert( OptionType == OptionValue->Elements[i].OptionType );
        printf("Option Element %ld value = ", i );

        switch( OptionType ) {
        case DhcpByteOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.ByteOption );
            break;

        case DhcpWordOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.WordOption );
            break;

        case DhcpDWordOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.DWordOption );
            break;

        case DhcpDWordDWordOption:
            printf("%lx, %lx.\n",
                OptionValue->Elements[i].Element.DWordDWordOption.DWord1,
                OptionValue->Elements[i].Element.DWordDWordOption.DWord2 );

            break;

        case DhcpIpAddressOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.IpAddressOption );
            break;

        case DhcpStringDataOption:
            printf("%ws.\n",
                OptionValue->Elements[i].Element.StringDataOption );
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption: {
            DWORD j;
            DWORD Length;

            Length = OptionValue->Elements[i].Element.BinaryDataOption.DataLength;
            for( j = 0; j < Length; j++ ) {
                printf("%2lx ",
                    OptionValue->Elements[i].Element.BinaryDataOption.Data[j] );
            }
            printf(".\n");
            break;
        }
        default:
            printf("PrintOptionValue: Unknown OptionType.\n");
            break;
        }
    }
}


VOID
PrintOptionInfo(
    LPDHCP_OPTION OptionInfo
    )
{
    printf( "Option Info : \n");
    printf( "\tOptionId : %ld \n", (DWORD)OptionInfo->OptionID );
    printf( "\tOptionName : %ws \n", OptionInfo->OptionName );
    printf( "\tOptionComment : %ws \n", OptionInfo->OptionComment );
    PrintOptionValue( &OptionInfo->DefaultValue );
    printf( "\tOptionType : %ld \n", (DWORD)OptionInfo->OptionType );
}

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpEnumOptionsV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpEnumOptions(
        ServerAddress,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

DWORD
ProcessEnumOptions(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_OPTION_ARRAY OptionsArray = NULL;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;


    Error = _EnumOptions(
        GlobalServerIpAddressUnicodeString,
        0,
        GlobalClassName,
        GlobalVendorName,
        &ResumeHandle,
        0xFFFFFFFF,  // get all.
        &OptionsArray,
        &OptionsRead,
        &OptionsTotal
    );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpEnumOptions failed %ld\n", Error );
    } else {

        DWORD i;
        LPDHCP_OPTION Options;
        DWORD NumOptions;

        printf("OptionsRead = %ld.\n", OptionsRead);
        printf("OptionsTotal = %ld.\n", OptionsTotal);

        Options = OptionsArray->Options;
        NumOptions = OptionsArray->NumElements;

        for( i = 0; i < NumOptions; i++, Options++ ) {
            PrintOptionInfo( Options );
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }

    return( Error );
}

DWORD
ProcessGetVersion(
    DWORD *pdwMajor,
    DWORD *pdwMinor
)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD MajorVersion;
    DWORD MinorVersion;

    if ( g_dwMajor == (DWORD) -1 && g_dwMinor == (DWORD) -1 ) {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &g_dwMajor,
            &g_dwMinor
        );

        if ( ERROR_SUCCESS == Error ) {
            printf( "DHCP Server version %d.%d\n", g_dwMajor, g_dwMinor );
        }
    }

    return Error;
}

VOID
PrintOptionArray(
    IN      LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD                          i;

    for( i = 0; i < OptArray->NumElements ; i ++ ) {
        PrintOptionInfo( &OptArray->Options[i] );
    }
}

VOID
PrintOptionValue1(
    IN      LPDHCP_OPTION_VALUE    OptVal
)
{
    printf("Option: %ld\n", OptVal->OptionID);

    PrintOptionValue(&OptVal->Value);
}

VOID
PrintOptionValuesArray(
    IN      LPDHCP_OPTION_VALUE_ARRAY OptValArray
)
{
    DWORD                          i;

    if( NULL == OptValArray ) return;
    for( i = 0; i < OptValArray->NumElements ; i ++ ) {
        PrintOptionValue1( &OptValArray->Values[i] );
    }
}

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):L"<None>")

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
)
{
    DWORD                          i;

    printf("Options [Non Vendor specific]:\n"
           "==============================\n");
    PrintOptionArray(Options->NonVendorOptions);

    for( i = 0; i < Options->NumVendorOptions; i ++ ) {
        printf("\nOptions [Vendor:%ws]\n==============================\n",
            CHKNULL( Options->VendorOptions[i].VendorName));
        PrintOptionInfo(&(Options->VendorOptions[i].Option));
    }

    printf("\n\n");
}

DWORD
ProcessGetAllOptions(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error, Major, Minor;
    LPDHCP_ALL_OPTIONS             Options;

    if( TRUE == GlobalNoRPC ) {
        Major = CLASS_ID_VERSION;
    } else {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &Major,
            &Minor
        );
        if( ERROR_SUCCESS != Error ) {
            printf("Could not get DHCP server version!\n");
            return Error;
        }
    }

    if( CLASS_ID_VERSION > Major ) {
        printf("DHCP Server (major version %ld) does not support this function call.\n", Major);
        return ERROR_SUCCESS;
    }

    Options = NULL;
    Error = DhcpGetAllOptions(
        GlobalServerIpAddressUnicodeString,
        0,
        &Options
    );

    if( ERROR_SUCCESS != Error ) return Error;

    if( NULL == Options ) {
        printf("Server returned no options!\n");
        DhcpAssert(FALSE);
    } else {
        PrintAllOptions(Options);
        DhcpRpcFreeMemory(Options);
    }

    return ERROR_SUCCESS;
}

VOID
PrintAllOptionValues(
    IN      LPDHCP_ALL_OPTION_VALUES OptValues
)
{
    DWORD                          i;

    printf("Flags = 0x%lx, NumValues = %ld\n", OptValues->Flags, OptValues->NumElements);
    for( i = 0; i < OptValues->NumElements ; i ++ ) {
        printf("Options");
        if( OptValues->Options[i].IsVendor ) {
            printf(" for vendor <%ws>", CHKNULL(OptValues->Options[i].VendorName));
        }
        if( OptValues->Options[i].ClassName ) {
            printf(" for user class <%ws>", OptValues->Options[i].ClassName);
        }
        printf(":\n");
        PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
    }
}

DWORD
ProcessGetAllOptionValues(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error, Major, Minor;
    LPDHCP_ALL_OPTION_VALUES       OptionValues;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;

    // usage: getalloptionvalues [command parameters]
    // [CommandParameters] = Global/Default/SubnetAddress/SubnetAddress ReservedAddress

    if( CommandArgc != 1 && CommandArgc != 2 ) {
        printf("Usage: Dhcpcmd SrvIpAddress GetAllOptionValues [CommandParameters]\n");
        printf("<Command parameters> - < GLOBAL | DEFAULT | Subnet-Adddress | Subnet-Address Reserved Address>.\n");
        return ERROR_SUCCESS;
    }

    if( 1 == CommandArgc ) {
        if( 0 == _stricmp(CommandArgv[0], "GLOBAL") ) {
            ScopeInfo.ScopeType = DhcpGlobalOptions;
        } else if ( 0 == _stricmp(CommandArgv[0], "DEFAULT" )) {
            ScopeInfo.ScopeType = DhcpDefaultOptions;
        } else {
            ScopeInfo.ScopeType = DhcpSubnetOptions;
            ScopeInfo.ScopeInfo.SubnetScopeInfo = DhcpDottedStringToIpAddress(CommandArgv[0]);
        }
    } else {
        ScopeInfo.ScopeType = DhcpReservedOptions;
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    		DhcpDottedStringToIpAddress(CommandArgv[0]);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    		DhcpDottedStringToIpAddress( CommandArgv[1] );
    }

    if( TRUE == GlobalNoRPC ) {
        Major = CLASS_ID_VERSION;
    } else {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &Major,
            &Minor
        );
        if( ERROR_SUCCESS != Error ) {
            printf("Could not get DHCP server version!\n");
            return Error;
        }
    }

    if( CLASS_ID_VERSION > Major ) {
        printf("DHCP Server (major version %ld) does not support this function call.\n", Major);
        return ERROR_SUCCESS;
    }

    OptionValues = NULL;
    Error = DhcpGetAllOptionValues(
        GlobalServerIpAddressUnicodeString,
        0,
        &ScopeInfo,
        &OptionValues
    );

    if( ERROR_SUCCESS != Error ) return Error;

    if( NULL == OptionValues ) {
        printf("Server returned no option values!\n");
        DhcpAssert(FALSE);
    } else {
        PrintAllOptionValues(OptionValues);
        DhcpRpcFreeMemory(OptionValues);
    }

    return ERROR_SUCCESS;
}

PBYTE
GetLangTag(
    )
{
    char b1[8], b2[8];
    static char buff[80];

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}

DWORD
ProcessCreateMScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR UnicodeMScopeName = NULL;
    LPWSTR UnicodeMScopeDesc = NULL;
    DWORD MScopeId;
    LPWSTR  UnicodeLangTag = NULL;
    PBYTE   LangTag;
    DWORD   ExpiryTimeInHours = 0;


    //
    // Expected Parameters are : <MScopeId MScopeName MScopeDescription ExpiryTime>
    //


    if( CommandArgc < 4 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateMScope [Command Parameters].\n"
            "<Command Parameters> - <MScopeId MScopeName MScopeDescription ExpiryTimeInHours>.\n"
             );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    MScopeId = atoi( CommandArgv[0] );
    if (!MScopeId) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[1], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    UnicodeMScopeDesc = DhcpOemToUnicode( CommandArgv[2], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    ExpiryTimeInHours = atoi(CommandArgv[3]);
    LangTag = GetLangTag();
    UnicodeLangTag = DhcpOemToUnicode(LangTag, NULL);
    DhcpAssert(UnicodeLangTag);

    MScopeInfo.MScopeName = UnicodeMScopeName;
    MScopeInfo.MScopeId = MScopeId;
    MScopeInfo.MScopeComment = UnicodeMScopeDesc;
    MScopeInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(GlobalServerIpAddressAnsiString);

    MScopeInfo.PrimaryHost.NetBiosName = NULL;
    MScopeInfo.PrimaryHost.HostName = NULL;
    MScopeInfo.MScopeState = DhcpSubnetEnabled;
    MScopeInfo.MScopeFlags = 0;
    MScopeInfo.MScopeAddressPolicy = 0;
    MScopeInfo.TTL = 255;
    MScopeInfo.LangTag = UnicodeLangTag;
    MScopeInfo.ExpiryTime = DhcpCalculateTime(ExpiryTimeInHours*60*60);

    Error = DhcpSetMScopeInfo(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &MScopeInfo,
                TRUE); // new scope

Cleanup:

    if( UnicodeMScopeName != NULL ) {
        DhcpFreeMemory( UnicodeMScopeName );
    }
    if( UnicodeMScopeDesc != NULL ) {
        DhcpFreeMemory( UnicodeMScopeDesc );
    }

    return( Error );
}

DWORD
ProcessDeleteMScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR UnicodeMScopeName = NULL;

    //
    // Expected Parameters are : <MScopeName>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteMScope [Command Parameters].\n"
            "<Command Parameters> - <MScopeName>.\n" );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    Error = DhcpDeleteMScope(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                TRUE); // force flag

Cleanup:

    if( UnicodeMScopeName != NULL ) {
        DhcpFreeMemory( UnicodeMScopeName );
    }

    return( Error );
}

DWORD
ProcessAddMScopeIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    LPWSTR UnicodeMScopeName = NULL;
    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddMScopeIpRange  [Command Parameters].\n"
            "<Command Parameters> - <MScopeName IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddMScopeElement(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &Element );

    if( UnicodeMScopeName != NULL ) DhcpFreeMemory( UnicodeMScopeName );

    return( Error );
}

DWORD
ProcessReconcileMScope(
   DWORD CommandArgc,
   LPSTR *CommandArgv
)
{
   DWORD Error;
   LPWSTR UnicodeMScopeName = NULL;
   LPDHCP_SCAN_LIST ScanList    = NULL;
   //
   // Expected Parameters are : <MScopeName>
   //


   if( CommandArgc < 1 ) {
       printf("usage:DhcpCmd SrvIpAddress ReconcileMScope  [Command Parameters].\n"
           "<Command Parameters> - <MScopeName>.\n" );
       return( ERROR_SUCCESS );
   }

   UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
   DhcpAssert( UnicodeMScopeName != NULL );


   Error = DhcpScanMDatabase(
               GlobalServerIpAddressUnicodeString,
               UnicodeMScopeName,
               TRUE,        // fix bad entries.
               &ScanList );

   if( UnicodeMScopeName != NULL ) DhcpFreeMemory( UnicodeMScopeName );
   if (ScanList) DhcpRpcFreeMemory( ScanList );

   return( Error );
}


VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tMScopeId = %lx.\n",
        ClientInfo->MScopeId);

    DataLength = ClientInfo->ClientId.DataLength;
    Data = ClientInfo->ClientId.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tStarts = ");

    if ( ClientInfo->ClientLeaseStarts.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseStarts.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseStarts),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseEnds.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseEnds),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

    printf("\tState = %0x\n", ClientInfo->AddressState );
}

VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseEnds.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseEnds),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }

    printf( "\n" );
}

DWORD
ProcessEnumMScopeClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;
    LPWSTR UnicodeMScopeName = NULL;

    //
    // Expected Parameters are : <MScopeNames>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <MScopeNames [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumMScopeClients(
                    GlobalServerIpAddressUnicodeString,
                    UnicodeMScopeName,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfo( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}

DWORD
ProcessEnumMScopes(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_MSCOPE_TABLE MScopeTable = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;
    LPWSTR UnicodeMScopeName = NULL;

    for(;;) {

        MScopeTable = NULL;
        Error = DhcpEnumMScopes(
                    GlobalServerIpAddressUnicodeString,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &MScopeTable,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( MScopeTable != NULL );
        DhcpAssert( MScopeTable->NumElements == ClientsRead );
        printf("Total Client count = %ld.\n", ClientsTotal );

        for( i = 0; i < ClientsRead; i++ ) {
            printf("MScope %ws\n", MScopeTable->pMScopeNames[i] );
        }
        break;


        DhcpRpcFreeMemory( MScopeTable );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}

DWORD
ProcessMCastMibCounts(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_MCAST_MIB_INFO MibInfo = NULL;
    DWORD i;
    LPMSCOPE_MIB_INFO ScopeInfo;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    Error = DhcpGetMCastMibInfo(
                GlobalServerIpAddressUnicodeString,
                &MibInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    DhcpAssert( MibInfo != NULL );

    printf("Discovers = %d.\n", MibInfo->Discovers);
    printf("Offers = %d.\n", MibInfo->Offers);
    printf("Requests = %d.\n", MibInfo->Requests);
    printf("Acks = %d.\n", MibInfo->Acks);
    printf("Naks = %d.\n", MibInfo->Naks);
    printf("Renews = %d.\n", MibInfo->Renews);
    printf("Releases = %d.\n", MibInfo->Releases);
    printf("ServerStartTime = ");

    if( FileTimeToLocalFileTime(
            (FILETIME *)(&MibInfo->ServerStartTime),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("Scopes = %d.\n", MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) {
        printf("Scope Name = %ws.\n",
                    (ScopeInfo[i].MScopeName));
        printf("\tNumAddressesInuse = %d.\n",
                    ScopeInfo[i].NumAddressesInuse );
        printf("\tNumAddressesFree = %d.\n",
                    ScopeInfo[i].NumAddressesFree );
        printf("\tNumPendingOffers = %d.\n",
                    ScopeInfo[i].NumPendingOffers );
    }

    DhcpRpcFreeMemory( MibInfo );

    return( ERROR_SUCCESS );
}

DWORD
ProcessAddServer(                                 // add a server to DS
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DWORD                          Address;
    LPWSTR                         ServerName;
    DHCP_SERVER_INFO               Server;

    // usage: AddServer <ServerName> <ServerIpAddress>
    if( CommandArgc != 2 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress AddServer <server-dns-name> <server-ip-address>\n");
        return ERROR_SUCCESS;
    }

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    ServerName = DhcpOemToUnicode( CommandArgv[0], NULL);
    Address = (inet_addr(CommandArgv[1]));
    printf("Adding server %ws,%s\n", ServerName, inet_ntoa(*(struct in_addr*)&Address));

    Server.Version = 0;
    Server.ServerName = ServerName;
    Server.ServerAddress = htonl(Address);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

    Err = DhcpAddServer(0, NULL, &Server, NULL, NULL);
    DhcpFreeMemory(ServerName);

    if( ERROR_SUCCESS != Err ) {                  // could not add the server
        printf("DhcpAddServer failed %ld (0x%lx)\n", Err, Err);
    }

    if( GlobalNoDS ) DhcpDsCleanup();

    return Err;
}

DWORD
ProcessDelServer(                                 // delete a server from DS
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DWORD                          Address;
    LPWSTR                         ServerName;
    DHCP_SERVER_INFO               Server;

    // usage: DelServer <ServerName> <ServerIpAddress>
    if( CommandArgc != 2 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress DelServer <server-dns-name> <server-ip-address>\n");
        return ERROR_SUCCESS;
    }

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    ServerName = DhcpOemToUnicode( CommandArgv[0], NULL);
    Address = (inet_addr(CommandArgv[1]));
    printf("Deleting server %ws,%s\n", ServerName, inet_ntoa(*(struct in_addr*)&Address));

    Server.Version = 0;
    Server.ServerName = ServerName;
    Server.ServerAddress = htonl(Address);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

    Err = DhcpDeleteServer(0, NULL, &Server, NULL, NULL);
    DhcpFreeMemory(ServerName);

    if( ERROR_SUCCESS != Err ) {                  // could not add the server
        printf("DhcpDeleteServer failed %ld (0x%lx)\n", Err, Err);
    }
    if( GlobalNoDS ) DhcpDsCleanup();
    return Err;
}


VOID
PrintServerInfo(                                  // print server information
    IN      LPDHCP_SERVER_INFO       Server
)
{
    DHCP_IP_ADDRESS                  ServerAddress = htonl(Server->ServerAddress);
    printf("Server [%ws] Address [%s] Ds location: %ws\n",
           Server->ServerName,
           inet_ntoa(*(struct in_addr *)&ServerAddress),
           Server->DsLocation? Server->DsLocation : L"<no-ds-location-available>"
    );
}

VOID
PrintServerInfoArray(                             // print list of servers
    IN      LPDHCP_SERVER_INFO_ARRAY Servers
)
{
    DWORD                          i;

    printf("%ld Servers were found in the DS:\n", Servers->NumElements);
    for( i = 0; i < Servers->NumElements; i ++ ) {
        printf("\t");
        PrintServerInfo(&Servers->Servers[i]);
    }
    printf("\n");
}

DWORD
ProcessEnumServers(                               // enumerate servers in DS.
    IN      DWORD                  CommandArgc,   // ignored..
    IN      LPSTR                 *CommandArgv    // ignored
)
{
    DWORD                          Err;
    LPDHCP_SERVER_INFO_ARRAY       Servers;

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    Servers = NULL;
    Err = DhcpEnumServers(0, NULL, &Servers, NULL, NULL);
    if( ERROR_SUCCESS != Err ) {
        printf("DhcpEnumServers failed %ld (0x%lx)\n", Err, Err);
        if( GlobalNoDS ) DhcpDsCleanup();
        return Err;
    }

    PrintServerInfoArray(Servers);
    LocalFree(Servers);
    if( GlobalNoDS ) DhcpDsCleanup();
    return ERROR_SUCCESS;
}


DWORD
ProcessCreateClass(                               // create a new class
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DHCP_CLASS_INFO                ClassInfo;

    // usage: [/IsVendor] CreateClass ClassName ClassComment Ascii-Data-For-Class

    if( CommandArgc != 3 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress CreateClass [Command Parameters]\n");
        printf("[Command Parameters] - ClassName ClassComment Ascii-Date-For-Class\n");
        printf("/IsVendor option would cause this to be created as a vendor class.\n");
        return ERROR_SUCCESS;
    }

    ClassInfo.ClassName = DhcpOemToUnicode(CommandArgv[0], NULL);
    ClassInfo.ClassComment = DhcpOemToUnicode(CommandArgv[1], NULL);
    ClassInfo.ClassDataLength = strlen(CommandArgv[2]);
    ClassInfo.ClassData = (LPBYTE)CommandArgv[2];
    ClassInfo.IsVendor = GlobalIsVendor;
    ClassInfo.Flags = 0;

    Err = DhcpCreateClass(
        GlobalServerIpAddressUnicodeString,
        0,
        &ClassInfo
    );

    DhcpFreeMemory(ClassInfo.ClassName);
    DhcpFreeMemory(ClassInfo.ClassComment);

    return Err;
}


DWORD
ProcessDeleteClass(                               // delete an existing class
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    LPWSTR                         ClassName;

    // usage: DeleteClass ClassName

    if( CommandArgc != 1 ) {
        printf("usage: DhcpCmd SrvIpAddress DeleteClass ClassName\n");
        return ERROR_SUCCESS;
    }

    ClassName = DhcpOemToUnicode(CommandArgv[0], NULL);
    Err = DhcpDeleteClass(
        GlobalServerIpAddressUnicodeString,
        0,
        ClassName
    );

    DhcpFreeMemory(ClassName);

    return Err;
}

VOID
PrintClassInfo(                                   // print info on a single class
    IN      LPDHCP_CLASS_INFO      Class
)
{
    DWORD                          i;

    printf("Class [%ws]:\n\tComment: %ws\n\tFlags: 0x%lx\n\tIsVendor: %s\n",
           Class->ClassName, Class->ClassComment, Class->Flags, Class->IsVendor?"TRUE":"FALSE");
    printf("\tClassData: ");
    for( i = 0; i < Class->ClassDataLength; i ++ )
        printf("%02x ", Class->ClassData[i]);
    printf("\n");
}

VOID
PrintClassInfoArray(                              // print array of classes
    IN      LPDHCP_CLASS_INFO_ARRAY Classes
)
{
    DWORD                          i;

    printf("NumClasses = %ld (0x%lx)\n", Classes->NumElements, Classes->NumElements);
    for( i = 0; i < Classes->NumElements; i ++ )
        PrintClassInfo(&Classes->Classes[i]);
}


DWORD
ProcessEnumClasses(                               // enumerate list of classes defined
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err, nRead, nTotal;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray;

    // usage: EnumClasses

    ClassInfoArray = NULL;
    ResumeHandle = 0;

    Err = DhcpEnumClasses(
        GlobalServerIpAddressUnicodeString,
        0,
        &ResumeHandle,
        0xFFFFFFFF,
        &ClassInfoArray,
        &nRead,
        &nTotal
    );

    if( ERROR_MORE_DATA == Err || ERROR_NO_MORE_ITEMS == Err ) {
        Err = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS == Err ) {
        PrintClassInfoArray(ClassInfoArray);
        DhcpRpcFreeMemory(ClassInfoArray);
    }

    return Err;
}

LPSTR
AttribString(
    IN ULONG AttribId
)
{
    switch(AttribId) {
    case DHCP_ATTRIB_BOOL_IS_ROGUE:
        return "IsRogue";
    case DHCP_ATTRIB_BOOL_IS_DYNBOOTP:
        return "DynamicBootpEnabled" ;
    case DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC:
        return "ServerPartOfDsEnabledDC" ;
    default:
        ;
    }

    return "UnknownAttribute";
}

VOID
PrintDhcpAttrib(                                  // print a server attrib
    IN      LPDHCP_ATTRIB          ServerAttrib
)
{
    if( NULL == ServerAttrib ) return;

    printf("Server Attrib %s [%ld]: ",
           AttribString(ServerAttrib->DhcpAttribId),
           ServerAttrib->DhcpAttribId );
    switch( ServerAttrib->DhcpAttribType ) {
    case DHCP_ATTRIB_TYPE_BOOL :
        printf("%s\n", ServerAttrib->DhcpAttribBool? "TRUE" : "FALSE");
        break;
    case DHCP_ATTRIB_TYPE_ULONG:
        printf("0x%lx\n", ServerAttrib->DhcpAttribUlong);
        break;
    default:
        printf("unknown attrib type\n");
        break;
    }
}

DWORD
ProcessGetServerStatus(                           // what is the server status?
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err, i;
    LPDHCP_ATTRIB_ARRAY            pDhcpAttribArr;
    DHCP_ATTRIB_ID                 Attribs[] = {
        DHCP_ATTRIB_BOOL_IS_ROGUE,
        DHCP_ATTRIB_BOOL_IS_DYNBOOTP,
        DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC
    };

    pDhcpAttribArr = NULL;
    Err = DhcpServerQueryAttributes(
        GlobalServerIpAddressUnicodeString,
        0,
        sizeof(Attribs)/sizeof(Attribs[0]),
        Attribs,
        &pDhcpAttribArr
    );

    if( ERROR_NOT_SUPPORTED == Err ) {
        Err = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS != Err ) {
        return Err;
    }

    printf("Supported Server Attributes:\n");
    if( pDhcpAttribArr ) {
        for( i = 0; i < pDhcpAttribArr->NumElements ; i ++ ) {
            PrintDhcpAttrib(&pDhcpAttribArr->DhcpAttribs[i]);
        }
        DhcpRpcFreeMemory(pDhcpAttribArr);
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessRetryAuthorization(                        // what is the server status?
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    return DhcpServerRedoAuthorization(
        GlobalServerIpAddressUnicodeString,
        0
    );
}


DWORD
ProcessGetBindings(
    IN DWORD CommandArgc,
    IN LPSTR *CommandArgv
)
{
    ULONG Error, i ;
    LPDHCP_BIND_ELEMENT_ARRAY BindInfo = NULL;

    Error = DhcpGetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        &BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
        return Error;
    }

    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        printf("%s \"%ws\"\n",
               BindInfo->Elements[i].fBoundToDHCPServer ? "[BOUND]  " : "[UNBOUND]" ,
               BindInfo->Elements[i].IfDescription
               );
    }

    DhcpRpcFreeMemory(BindInfo);
    return ERROR_SUCCESS;
}

DWORD
ProcessSetBinding(
    IN DWORD CommandArgc,
    IN LPSTR *CommandArgv
)
{
    ULONG Error, i ;
    BOOL Bind;
    LPDHCP_BIND_ELEMENT_ARRAY BindInfo = NULL;
    LPWSTR AdapterName;

    if( CommandArgc != 2 ) {
        printf("usage: DhcpCmd SrvIpAddress SetBinding [BIND/UNBIND] AdapterName");
        return ERROR_SUCCESS;
    }

    if( 0 == _stricmp(CommandArgv[0], "BIND") ) {
        Bind = TRUE;
    } else {
        Bind = FALSE;
    }

    AdapterName = DhcpOemToUnicode(CommandArgv[1], NULL);

    Error = DhcpGetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        &BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
        return Error;
    }

    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        if( 0 == _wcsicmp(BindInfo->Elements[i].IfDescription, AdapterName)) {
            BindInfo->Elements[i].fBoundToDHCPServer = Bind;
            break;
        }
    }

    if( i == BindInfo->NumElements ) {
        printf("Requested Adapter Name not present. \n"
               "Use DhcpCmd SrvIpAddress GetBindings to view bindings.\n");
        return ERROR_SUCCESS;
    }

    Error = DhcpSetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
    }

    DhcpRpcFreeMemory(BindInfo);
    return ERROR_SUCCESS;
}

#define CMD_OPT_INVALID            0
#define CMD_OPT_LPWSTR             1
#define CMD_OPT_BOOL               2

struct /* anonymous */ {
    LPSTR                          CommandOptName;
    DWORD                          CommandOptType;
    LPVOID                         CommandOptStorage;
} CommandOpts[] = {
    {  "ClassName",  CMD_OPT_LPWSTR, (LPVOID)&GlobalClassName  },
    {  "VendorName", CMD_OPT_LPWSTR, (LPVOID)&GlobalVendorName },
    {  "IsVendor",   CMD_OPT_BOOL,   (LPVOID)&GlobalIsVendor   },
    {  "NoRPC",      CMD_OPT_BOOL,   (LPVOID)&GlobalNoRPC      },
    {  "NoDS",       CMD_OPT_BOOL,   (LPVOID)&GlobalNoDS       },
    {  NULL,         CMD_OPT_INVALID, NULL                     },
};

DWORD
ProcessOption(                                    // process a given option
    IN       DWORD                 Index,         // index into CommandOpts table
    IN       LPSTR                 Value          // value passed for option
)
{
    BOOL                           Val_BOOL;
    LPWSTR                         Val_LPWSTR;

    switch(CommandOpts[Index].CommandOptType ) {  // see what type we need to convert to..
    case CMD_OPT_BOOL:
        if( NULL == Value || '\0' == *Value ) {
            Val_BOOL = TRUE;                      // implicitly set value to TRUE
        } else {
            if( 0 == _stricmp(Value, "TRUE") ) {  // explicitly setting TRUE
                Val_BOOL = TRUE;
            } else if( 0 == _stricmp(Value, "FALSE" ) ) {
                Val_BOOL = FALSE;                 // explicitly setting it to FALSE
            } else {
                return ERROR_INVALID_PARAMETER;   // unknown response..
            }
        }

        *((LPBOOL)(CommandOpts[Index].CommandOptStorage)) = Val_BOOL;
        break;

    case CMD_OPT_LPWSTR:
        if( NULL == Value ) {
            Val_LPWSTR = NULL;
        } else if( '\0' == *Value ) {
            Val_LPWSTR = L"";
        } else {                                  // now convert this..
            Val_LPWSTR = DhcpOemToUnicode(Value, NULL);
        }

        *((LPWSTR *)(CommandOpts[Index].CommandOptStorage)) = Val_LPWSTR;
        break;

    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessOptions(                                  // process all options..
    IN OUT   int                  *argc,
    IN OUT   LPSTR                 argv[]
)
{
    DWORD                          Error;
    int                            i, j, k, n;
    LPSTR                          Arg, Val;

    for( i = 1; i < *argc ; i ++ ) {              // process each option
        if( argv[i][0] != '/' && argv[i][0] != '-' ) {
            continue;                             // not an option
        }

        Arg = argv[i];                            // an option to process
        Arg ++;                                   // skip leading '/' or '-'
        Val = strchr(Arg, ':');                   // see if it is of form /Option:Value
        if( Val ) {                               // yup!
            *Val = '\0';                          // terminate Arg..
            Val++;                                // now Val points to value in /Option:Value
        }

        for( j = 0; CommandOpts[j].CommandOptName ; j ++ ) {
            if( 0 == _stricmp(Arg, CommandOpts[j].CommandOptName) ) {
                break;                            // found a match!
            }
        }

        if( NULL ==  CommandOpts[j].CommandOptName ) {
            if( Val ) Val[-1] = ':';              // give back the colon we stole..
            continue;
        }

        for( k = i + 1; k < *argc ; k ++ ) {      // remove this arg and slide the rest
            argv[k-1] = argv[k];
        }
        i -- ; (*argc) --;

        Error = ProcessOption( j, Val );          // now process it
        if( ERROR_SUCCESS != Error ) {            // ouch?
            DhcpPrint((0xFFFF, "Could not process option: /%s:%s\n", Arg, Val));
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

VOID
CleanupOptions(
    VOID
)
{
    DWORD                          i;
    LPWSTR                         String;

    for( i = 0; CommandOpts[i].CommandOptName ; i ++ ) {
        switch(CommandOpts[i].CommandOptType ) {
        case CMD_OPT_BOOL:
            // nothing to free
            break;
        case CMD_OPT_LPWSTR:
            // need to free string space used..
            String = *((LPWSTR *)CommandOpts[i].CommandOptStorage);
            if( NULL != String ) DhcpFreeMemory(String);
            break;
        }
    }

    // done!
}
#endif NT5

#ifdef NT5
#define OPTIONS_STRING "[Options]"
#else
#define OPTIONS_STRING
#endif

DWORD __cdecl
main(
    int argc,
    char **argv
    )
{
    DWORD Error, ThreadOptions;
    COMMAND_CODE CommandCode;
    DWORD CommandArgc;
    LPSTR *CommandArgv;

    INIT_DEBUG_HEAP( HEAPX_VERIFY );

    Error = ERROR_SUCCESS;
#ifdef NT5
    Error = ProcessOptions(&argc, argv);
#endif NT5

    if( ERROR_SUCCESS != Error || argc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress" OPTIONS_STRING  "Command [Command Parameters].\n");
        printf("Commands : \n");
        PrintCommands();
#ifdef NT5
        printf("Options: \n");
        printf("\t/ClassName:<string>  -- [default NULL] specify class name wherever applicable.\n");
        printf("\t/VendorName:<string> -- [default NULL] specify vendor name wherever applicable.\n");
        printf("\t/IsVendor:TRUE/FALSE -- [default FALSE] specify that option being referred as vendor.\n");
        printf("\t/NoRPC:TRUE/FALSE    -- [default FALSE] specify that no RPC calls should be made.\n");
        printf("\t/NoDS:TRUE/FALSE     -- [default TRUE]  specify that no DS calls should be made.\n");
        printf("\n\n");
#endif NT5
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    GlobalServerIpAddressAnsiString = argv[1];
    GlobalServerIpAddressUnicodeString =
        DhcpOemToUnicode( GlobalServerIpAddressAnsiString, NULL );

    if( GlobalServerIpAddressUnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        printf("Insufficient memory\n");
        goto Cleanup;
    }

    GlobalServerIpAddressAnsiString = argv[1];

    CommandCode = DecodeCommand( argv[2] );
    if( CommandCode == UnknownCommand ) {
        Error = ERROR_INVALID_PARAMETER;
        printf("Unknown Command Specified.\n");
        goto Cleanup;
    }

    if( FALSE == GlobalNoRPC ) {
        Error = ProcessGetVersion( &g_dwMajor, &g_dwMinor );
        if ( ERROR_SUCCESS != Error ) {
            printf("Unable to determine server version.\n" );
            goto Cleanup;
        }
    } else {
        Error = ERROR_SUCCESS;
    }

    if ( FALSE == GlobalNoRPC && !IsValidServerVersion( g_dwMajor, g_dwMinor ) ) {
        printf( "This version of %s works with Microsoft DHCP server"
                " running on Windows NT Server version %d.%d or later.\n",
                argv[0],
                DHCPCMD_VERSION_MAJOR,
                DHCPCMD_VERSION_MINOR
        );
        Error = ERROR_OLD_WIN_VERSION;
        goto Cleanup;
    }

    CommandArgc = (DWORD)(argc - 3);
    CommandArgv = &argv[3];

#ifdef NT5
    Error = ERROR_SUCCESS;
    if( FALSE == GlobalNoDS ) Error = DhcpDsInit();
    if( ERROR_SUCCESS != Error && FALSE == GlobalNoDS ) {
        printf("DhcpDsInit() failed %ld (0x%lx), but continuing ..\n", Error, Error);
        printf("This indicates that either your machine is part of a work group\n");
        printf("or that your DS is unreachable\n");
    }

    Error = ERROR_SUCCESS;

    ThreadOptions = 0;
    if( GlobalNoRPC ) ThreadOptions |= DHCP_FLAGS_DONT_DO_RPC;
    if( GlobalNoDS ) ThreadOptions |= DHCP_FLAGS_DONT_ACCESS_DS;
    DhcpSetThreadOptions(ThreadOptions, 0);

#endif NT5

    switch( CommandCode ) {
    case AddIpRange:
        Error = ProcessAddIpRange( CommandArgc, CommandArgv );
        break;

    case RemoveIpRange:
        Error = ProcessRemoveIpRange( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case EnumIpRanges:
        Error = ProcessEnumIpRanges( CommandArgc, CommandArgv );
        break;
#endif NT5

    case AddReservedIp:
        Error = ProcessAddReservedIp( CommandArgc, CommandArgv );
        break;

    case EnumClients:
        Error = ProcessEnumClients( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case EnumClientsV5:
        Error = ProcessEnumClientsV5( CommandArgc, CommandArgv );
        break;
#endif NT5

    case MibCounts:
        Error = ProcessMibCounts( CommandArgc, CommandArgv );
        break;

    case ServerConfig:
        Error = ProcessServerConfig( CommandArgc, CommandArgv );
        break;

    case GetDhcpVersion:
        Error = ProcessGetVersion( &g_dwMajor, &g_dwMinor );
        break;

    case SetSuperScope:
        Error = ProcessSetSuperScope( CommandArgc, CommandArgv );
        break;

    case RemoveSubscope:
        Error = ProcessRemoveSubscope( CommandArgc, CommandArgv );
        break;

    case DeleteSuperScope:
        Error = ProcessDeleteSuperScope( CommandArgc, CommandArgv );
        break;

    case GetSuperScopeTable:
        Error = ProcessGetSuperScopeTable( CommandArgc, CommandArgv );
        break;

    case CheckDB:
        Error = ProcessCheckDB( CommandArgc, CommandArgv );
        break;

    case CreateSubnet:
        Error = ProcessCreateSubnet( CommandArgc, CommandArgv );
        break;

    case DeleteSubnet:
        Error = ProcessDeleteSubnet( CommandArgc, CommandArgv );
        break;

    case AddExcludeRange:
        Error = ProcessAddExcludeRange( CommandArgc, CommandArgv );
        break;

    case RemoveReservedIp:
        Error = ProcessRemoveReservedIp( CommandArgc, CommandArgv );
        break;

    case RemoveExcludeRange:
        Error = ProcessRemoveExcludeRange( CommandArgc, CommandArgv );
        break;

    case SetSubnetState:
        Error = ProcessSetSubnetState( CommandArgc, CommandArgv );
        break;

    case CreateOption:
        Error = ProcessCreateOption( CommandArgc, CommandArgv );
        break;

    case DeleteOption:
        Error = ProcessDeleteOption( CommandArgc, CommandArgv );
        break;

    case SetGlobalOptionValue:
        Error = ProcessSetGlobalOptionValue( CommandArgc, CommandArgv );
        break;

    case SetGlobalOptionValues:
        Error = ProcessSetGlobalOptionValues( CommandArgc, CommandArgv );
        break;

    case RemoveGlobalOptionValue:
        Error = ProcessRemoveGlobalOptionValue( CommandArgc, CommandArgv );
        break;

    case SetSubnetOptionValue:
        Error = ProcessSetSubnetOptionValue( CommandArgc, CommandArgv );
        break;

    case RemoveSubnetOptionValue:
        Error = ProcessRemoveSubnetOptionValue( CommandArgc, CommandArgv );
        break;

    case SetReservedOptionValue:
        Error = ProcessSetReservedOptionValue( CommandArgc, CommandArgv );
        break;

    case RemoveReservedOptionValue:
        Error = ProcessRemoveReservedOptionValue( CommandArgc, CommandArgv );
        break;

    case EnumOptions:
        Error = ProcessEnumOptions( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case GetAllOptions:
        Error = ProcessGetAllOptions( CommandArgc, CommandArgv );
        break;

    case GetAllOptionValues:
        Error = ProcessGetAllOptionValues( CommandArgc, CommandArgv );
        break;

    case CreateMScope:
        Error = ProcessCreateMScope( CommandArgc, CommandArgv );
        break;

    case DeleteMScope:
        Error = ProcessDeleteMScope( CommandArgc, CommandArgv );
        break;

    case AddMScopeRange:
        Error = ProcessAddMScopeIpRange( CommandArgc, CommandArgv );
        break;

    case EnumMScopeClients:
        Error = ProcessEnumMScopeClients( CommandArgc, CommandArgv );
        break;

    case ReconcileMScope:
        Error = ProcessReconcileMScope( CommandArgc, CommandArgv );
        break;

    case EnumMScopes:
        Error = ProcessEnumMScopes( CommandArgc, CommandArgv );
        break;

    case MCastMibCounts:
        Error = ProcessMCastMibCounts( CommandArgc, CommandArgv );
        break;

    case EnumServers:
        Error = ProcessEnumServers( CommandArgc, CommandArgv );
        break;

    case AddServer:
        Error = ProcessAddServer( CommandArgc, CommandArgv );
        break;

    case DelServer:
        Error = ProcessDelServer( CommandArgc, CommandArgv );
        break;

    case CreateClass:
        Error = ProcessCreateClass( CommandArgc, CommandArgv );
        break;

    case DeleteClass:
        Error = ProcessDeleteClass( CommandArgc, CommandArgv );
        break;

    case EnumClasses:
        Error = ProcessEnumClasses( CommandArgc, CommandArgv );
        break;

    case GetServerStatus:
        Error = ProcessGetServerStatus( CommandArgc, CommandArgv );
        break;

    case RetryAuthorization:
        Error = ProcessRetryAuthorization(CommandArgc, CommandArgv);
        break;

    case DeleteBadClients:
        Error = ProcessDeleteBadClients(CommandArgc, CommandArgv);
        break;

    case DeleteClient:
        Error = ProcessDeleteClient(CommandArgc, CommandArgv);
        break;

    case GetBindings:
        Error = ProcessGetBindings(CommandArgc, CommandArgv);
        break;

    case SetBinding:
        Error = ProcessSetBinding(CommandArgc, CommandArgv);
        break;

#endif NT5

    case UnknownCommand:
    default:
        DhcpAssert( FALSE );
        Error = ERROR_INVALID_PARAMETER;
        printf("Unknown Command Specified.\n");
        goto Cleanup;
    }

Cleanup:

#ifdef NT5
    DhcpDsCleanup();
#endif NT5

    if( GlobalServerIpAddressUnicodeString != NULL ) {
        DhcpFreeMemory( GlobalServerIpAddressUnicodeString );
    }

#ifdef NT5
    CleanupOptions();
#endif NT5

    if( Error != ERROR_SUCCESS ) {
        printf("Command failed, %ld.\n", Error );
        return(1);
    }

    UNINIT_DEBUG_HEAP();
    printf("Command successfully completed.\n");

    return(0);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\proto.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    This file contain function prototypes for the BINL service.

Author:

    Colin Watson  (colinw)  11-Aug-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//
// network.c
//

DWORD
BinlWaitForMessage(
    BINL_REQUEST_CONTEXT *pRequestContext
    );

DWORD
BinlSendMessage(
    LPBINL_REQUEST_CONTEXT BinlRequestContext
    );

DHCP_IP_ADDRESS
BinlGetMyNetworkAddress (
    LPBINL_REQUEST_CONTEXT RequestContext
    );

NTSTATUS
GetIpAddressInfo (
    ULONG Delay
    );

VOID
FreeIpAddressInfo (
    VOID
    );

//
// main.c
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    );

DWORD
BinlRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE * BufferPtr
    );

DWORD
GetBinlServerParameters(
    BOOL GlobalSearch);

DWORD
BinlInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    );

VOID
SendWakeup(
           PENDPOINT pEndpoint
           );

DWORD
MaybeInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    );

VOID
MaybeCloseEndpoint(
    PENDPOINT pEndpoint
    );

VOID
BinlMessageLoop(
    LPVOID Parameter
    );

DWORD
BinlStartWorkerThread(
    BINL_REQUEST_CONTEXT **ppContext
    );

VOID
BinlProcessingLoop(
    VOID
    );

BOOL
BinlIsProcessMessageExecuting(
    VOID
    );

BOOL
BinlIsProcessMessageBusy(
    VOID
    );

DWORD
Scavenger(
    VOID
    );

VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );

NTSTATUS
BinlSetupPnpWait (
    VOID
    );

// message.c

DWORD
ProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
ProcessBinlDiscover(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS dhcpOptions
    );

DWORD
ProcessBinlRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS dhcpOptions
    );

DWORD
ProcessBinlInform(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS  DhcpOptions
);

DWORD
UpdateAccount(
    PCLIENT_STATE ClientState,
    PMACHINE_INFO pMachineInfo,
    BOOL          fCreateAccount
    );

DWORD
GetBootParameters(
    PUCHAR          pGuid,
    PMACHINE_INFO * pMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            AllowOSChooser
    );

DWORD
VerifyExistingClient(
    PUCHAR Guid
    );

DWORD
InitializeConnection(
    BOOL Global,
    PLDAP * LdapHandle,
    PWCHAR ** Base);

VOID
FreeConnections(
    VOID
    );

#ifdef REMOTE_BOOT
DWORD
SetCurrentClientCount( );
#endif // REMOTE_BOOT

DWORD
BinlReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
BinlReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

VOID
BinlLogDuplicateDsRecords (
    LPGUID Guid,
    LDAP *LdapHandle,
    LDAPMessage *LdapMessage,
    LDAPMessage *CurrentEntry
    );

//
// osc.c
//

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    );

//
//  Routines for caching the DS responses and to ensure that we don't work on
//  a request that we're already working on.
//

DWORD
BinlCreateOrFindCacheEntry (
    PCHAR Guid,
    BOOLEAN CreateIfNotExist,
    PMACHINE_INFO *CacheEntry
    );

VOID
BinlDoneWithCacheEntry (
    PMACHINE_INFO pMachineInfo,
    BOOLEAN FreeIt
    );

VOID
BinlCloseCache (
    VOID
    );

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error );


#ifndef DSCRACKNAMES_DNS
DWORD
BinlDNStoFQDN(
    PWCHAR   pMachineName,
    PWCHAR * ppMachineDN );
#endif

DWORD
GetOurServerInfo (
    VOID
    );

//
//  rogue.c
//

NTSTATUS
MaybeStartRogueThread (
    VOID
    );

VOID
StopRogueThread (
    VOID
    );

VOID
HandleRogueAuthorized (
    VOID
    );

VOID
HandleRogueUnauthorized (
    VOID
    );

VOID
LogCurrentRogueState (
    BOOL ResponseToMessage
    );

VOID
LogLdapError (
    ULONG LdapEvent,
    ULONG LdapError,
    PLDAP LdapHandle OPTIONAL
    );

//
// Create a copy of a string by allocating heap memory.
//
LPSTR
BinlStrDupA( LPCSTR pStr );

LPWSTR
BinlStrDupW( LPCWSTR pStr );

// We should always be UNICODE
#define BinlStrDup BinlStrDupW

#if DBG==1
#define BinlAllocateMemory(x) DebugAlloc( __FILE__, __LINE__, "BINL", LMEM_FIXED | LMEM_ZEROINIT, x, #x)
#define BinlFreeMemory(x)     DebugFree(x)
#else // DBG==0
#define BinlAllocateMemory(x) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, x)
#define BinlFreeMemory(x)     LocalFree(x)
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\makefile.inc ===
obj\$(TARGET_DIRECTORY)\dhcpcmd.res: dhcpcmd.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\utils.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

//
// When all else fails "Error screen".
//
CHAR ErrorScreenHeaders[] =
"<OSCML>"\
"<META KEY=F3 ACTION=\"REBOOT\">"
"<META KEY=ENTER ACTION=\"REBOOT\">"
"<TITLE>  Client Installation Wizard                                    Error "; // there is a %08x after this
CHAR ErrorScreenBody[] =
" </TITLE>"
"<FOOTER> Press F3 to reboot</FOOTER>"
"<BODY LEFT=3 RIGHT=76><BR><BR>"; // the error message is inserted here
CHAR ErrorScreenTrailer[] =
"An error occurred on the server. Please notify your administrator.<BR>"
"%SUBERROR%<BR>"
"</BODY>"
"</OSCML>";

void
OscCreateWin32SubError(
    PCLIENT_STATE clientState,
    DWORD Error )
/*++
Routine Description:

    Create a OSC Variable SUBERROR with the actual Win32 error code that
    caused the BINL error.

Arguments:

      clientState - client state to add the variable too.

      Error - the Win32 error that occurred.
--*/
{
    DWORD dwLen;
    PWCHAR ErrorResponse = NULL;
    PWCHAR ErrorMsg = NULL;
    BOOL UsedFallback = FALSE;
    PWCHAR pch;
    DWORD ErrorLength;

    const WCHAR UnknownErrorMsg[] = L"Unknown Error.";
    const WCHAR ErrorString[] = L"Error: 0x%08x - %s";

    TraceFunc( "OscCreateWin32SubError( )\n" );

    // Retrieve the error message from system resources.
    dwLen = FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            Error,
                            0,
                            (LPWSTR) &ErrorMsg,
                            0,
                            NULL );
    if ( dwLen == 0 )
        goto Cleanup;

#if DBG
    if ( ErrorMsg )
        DebugMemoryAdd( ErrorMsg, __FILE__, __LINE__, "BINL", LPTR, wcslen(ErrorMsg), "ErrorMsg" );
#endif

    // If all else fails, just print an error code out.
    if ( ErrorMsg == NULL ) {
        UsedFallback = TRUE;
        ErrorMsg = (PWCHAR) &UnknownErrorMsg;
        dwLen = wcslen(ErrorMsg);
    }

    // The + 4 is the extra characters of the "%08x" of the generated error message.
    ErrorLength = dwLen + sizeof( ErrorString ) + 4;
    ErrorResponse = (PWCHAR) BinlAllocateMemory( ErrorLength * sizeof(WCHAR) );
    if ( ErrorResponse == NULL ) {
        goto Cleanup;
    }

    wsprintf( ErrorResponse, ErrorString, Error, ErrorMsg );

    // We need to go through the string and elminate any CRs or LFs that
    // FormatMessageA() might have introduced.
    pch = ErrorResponse;
    while ( *pch )
    {
        if ( *pch == '\r' || * pch == '\n' )
            *pch = 32;  // change to space

        pch++;
    }

    OscAddVariableW( clientState, "SUBERROR", ErrorResponse );

Cleanup:
    if ( ErrorResponse )
        BinlFreeMemory( ErrorResponse );

    if ( ErrorMsg && !UsedFallback )
        BinlFreeMemory( ErrorMsg );
}

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error )
/*++
Routine Description:

    Create a OSC Variable SUBERROR with the actual LDAP error code that
    caused the BINL error.

Arguments:

      clientState - client state to add the variable too.

      Error - the LDAP error that occurred.
--*/
{
    DWORD dwLen;
    PWCHAR ErrorResponse = NULL;
    DWORD ErrorLength;

    const WCHAR LdapErrorMsg[] = L"LDAP Error: 0x%08x";

    TraceFunc( "OscCreateLDAPSubError( )\n" );

    // The + 13 is the "0x12345678 - " of the generated error message.
    ErrorLength = wcslen(LdapErrorMsg) + 1 + 13;
    ErrorResponse = (PWCHAR) BinlAllocateMemory( ErrorLength * sizeof(WCHAR) );
    if ( ErrorResponse == NULL ) {
        goto Cleanup;
    }

    wsprintf( ErrorResponse, LdapErrorMsg, Error );

    OscAddVariableW( clientState, "SUBERROR", ErrorResponse );

Cleanup:
    if ( ErrorResponse )
        BinlFreeMemory( ErrorResponse );
}

//
// This routine was stolen from private\ntos\rtl\sertl.c\RtlRunEncodeUnicodeString().
//

VOID
OscGenerateSeed(
    UCHAR Seed[1]
    )
/*++

Routine Description:

    Generates a one-byte seed for use in run encoding/decoding client
    state variables such as passwords.

Arguments:

    Seed - points to a single byte that holds the generated seed.

Return Value:

    None.

--*/

{
    LARGE_INTEGER Time;
    PUCHAR        LocalSeed;
    NTSTATUS      Status;
    ULONG         i;

    //
    // Use the 2nd byte of current time as the seed.
    // This byte seems to be sufficiently random (by observation).
    //

    Status = NtQuerySystemTime ( &Time );
    BinlAssert(NT_SUCCESS(Status));

    LocalSeed = (PUCHAR)((PVOID)&Time);

    i = 1;

    (*Seed) = LocalSeed[ i ];

    //
    // Occasionally, this byte could be zero.  That would cause the
    // string to become un-decodable, since 0 is the magic value that
    // causes us to re-gen the seed.  This loop makes sure that we
    // never end up with a zero byte (unless time is zero, as well).
    //

    while ( ((*Seed) == 0) && ( i < sizeof( Time ) ) )
    {
        (*Seed) |= LocalSeed[ i++ ] ;
    }

    if ( (*Seed) == 0 )
    {
        (*Seed) = 1;
    }
}

DWORD
OscRunEncode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR Data,
    OUT LPSTR * EncodedData
    )
/*++

Routine Description:

    Calls RtlRunEncodeUnicodeString for the Data, using the client
    state's random seed. Then convert each byte into a 2-byte
    value so that there are no NULLs in the result.

    Each byte is encoded into a 2-byte values as follows:
    The first byte has the low 4 bits of the byte in its low 4 bits,
    with 0xf in the high 4 bits
    The second byte has the high 4 bits of the byte in its high 4 bits,
    with 0xf in the low 4 bits

Arguments:

    ClientState - the client state.

    Data - The data which is to be encoded.

    EncodedData - An allocated buffer which holds the encoded result.

Return Value:

    The result of the operation.

--*/
{
    STRING String;
    ULONG i;
    LPSTR p;

    RtlInitAnsiString(&String, Data);

    *EncodedData = BinlAllocateMemory((String.Length * 2) + 1);
    if (*EncodedData == NULL) {
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    RtlRunEncodeUnicodeString(&ClientState->Seed, (PUNICODE_STRING)&String);

    for (i = 0, p = *EncodedData; i < String.Length; i++) {
        *(p++) = Data[i] | 0xf0;
        *(p++) = Data[i] | 0x0f;
    }
    *p = '\0';

    return ERROR_SUCCESS;

}

DWORD
OscRunDecode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR EncodedData,
    OUT LPSTR * Data
    )
/*++

Routine Description:

    Convert the encoded data (see OscRunEncode) into the real bytes,
    then calls RtlRunDecodeUnicodeString on that, using the client
    state's random seed.

Arguments:

    ClientState - the client state.

    EncodedData - the encoded data from OscRunEncode.

    Data - An allocated buffer which holds the decoded result.

Return Value:

    The result of the operation.

--*/
{
    STRING String;
    ULONG Count = strlen(EncodedData) / 2;
    ULONG i, j;
    LPSTR p;

    *Data = BinlAllocateMemory(Count + 1);
    if (*Data == NULL) {
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    for (i = 0, j = 0, p = *Data; i < Count; i++, j+=2)  {
        *(p++) = (EncodedData[j] & 0x0f) | (EncodedData[j+1] & 0xf0);
    }
    *p = '\0';

    //
    // Set up the string ourselves since there may be NULLs in
    // the decoded data.
    //

    String.Buffer = *Data;
    String.Length = (USHORT)Count;
    String.MaximumLength = (USHORT)(Count+1);

    RtlRunDecodeUnicodeString(ClientState->Seed, (PUNICODE_STRING)&String);

    return ERROR_SUCCESS;
}

//
// This routine was stolen from net\svcdlls\logonsrv\server\ssiauth.c.
//

BOOLEAN
OscGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    )
/*++

Routine Description:

    Generates random bits

Arguments:

    pBuffer - Buffer to fill

    cbBuffer - Number of bytes in buffer

Return Value:

    Status of the operation.

--*/

{
    BOOL Status = TRUE;
    HCRYPTPROV CryptProvider = 0;

    Status = CryptAcquireContext( &CryptProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT );

    if ( Status ) {

        Status = CryptGenRandom( CryptProvider, BufferLen, ( LPBYTE )Buffer );

        CryptReleaseContext( CryptProvider, 0 );

    } else {

        BinlPrintDbg((DEBUG_ERRORS, "CryptAcquireContext failed with %lu\n", GetLastError() ));

    }

    return ( Status != 0);
}

VOID
OscGeneratePassword(
    OUT PWCHAR Password,
    OUT PULONG PasswordLength
    )
{
    ULONG i;
    
    *PasswordLength = LM20_PWLEN * sizeof(WCHAR);
    
    for (i = 0; i < LM20_PWLEN; i++) {
        
        if ( Password[i] == L'\0' ) {
            Password[i] = 0x55;
        } else if ((USHORT)Password[i] < 0x20 || (USHORT)Password[i] > 0x7A) {
            Password[i] = Password[i] % (0x7a-0x20) + 0x20;    
        }
    }
    Password[LM20_PWLEN] = L'\0';
}

//
// GenerateErrorScreen( )
//
DWORD
GenerateErrorScreen(
    PCHAR  *OutMessage,
    PULONG OutMessageLength,
    DWORD  Error,
    PCLIENT_STATE clientState
    )
{
    DWORD Err;
    DWORD dwLen;
    PCHAR ErrorMsg;
    DWORD ErrorScreenLength = strlen(ErrorScreenHeaders) + strlen(ErrorScreenBody) + strlen(ErrorScreenTrailer);
    PCHAR pch;
    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;

    const CHAR UnknownErrorMsg[] = "Unknown Error.";

    TCHAR ErrorMsgFilename[ MAX_PATH ];
    HANDLE hfile;

    LPSTR Messages[5];

    Messages[0] = OscFindVariableA( clientState, "USERNAME" );
    Messages[1] = OscFindVariableA( clientState, "USERDOMAIN" );
    Messages[2] = OscFindVariableA( clientState, "MACHINENAME" );
    Messages[3] = OscFindVariableA( clientState, "SUBERROR" );
    Messages[4] = NULL; // paranoid

    if ( _snwprintf( ErrorMsgFilename,
                     sizeof(ErrorMsgFilename) / sizeof(ErrorMsgFilename[0]),
                     L"%ws\\OSChooser\\%ws\\%08x.OSC",
                     IntelliMirrorPathW,
                     OscFindVariableW( clientState, "LANGUAGE" ),
                     Error ) != -1 ) {

        //
        // If we find the file, load it into memory.
        //
        hfile = CreateFile( ErrorMsgFilename, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if ( hfile != INVALID_HANDLE_VALUE )
        {
            DWORD FileSize;
            //
            // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
            // display it.
            //
            FileSize = GetFileSize( hfile, NULL );
            if ( FileSize != 0xFFFFffff )
            {
                DWORD dwRead = 0;

                RspMessage = BinlAllocateMemory( FileSize + 3 );
                if ( RspMessage == NULL )
                {
                    //
                    // Ignore error and fall thru to generate an error screen
                    //
                }
                else
                {
                    RspMessageLength = 0;
                    RspMessage[0] = '\0';

                    while ( dwRead != FileSize )
                    {
                        BOOL b;
                        DWORD dw;
                        b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                        if (!b)
                        {
                            PWCHAR strings[2];
                            strings[0] = ErrorMsgFilename;
                            strings[1] = NULL;
                            Err = GetLastError( );

                            BinlPrint(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                        dwRead, FileSize - dwRead, ErrorMsgFilename ));

                            BinlReportEventW( EVENT_ERROR_READING_OSC_SCREEN,
                                              EVENTLOG_ERROR_TYPE,
                                              1,
                                              sizeof(Err),
                                              strings,
                                              &Err
                                              );
                            break;
                        }
                        dwRead += dw;
                    }

                    RspMessageLength = dwRead;
                    RspMessage[dwRead] = '\0'; // paranoid

                    CloseHandle( hfile );

                    Err = ERROR_SUCCESS;
                    goto Cleanup;
                }
            }
            else
            {
                BinlPrintDbg((DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not determine file size.\n", GetLastError( )));
                //
                // Ignore error and fall thru to generate an error screen
                //
            }

            CloseHandle( hfile );
        }

    }

    BinlPrintDbg((DEBUG_OSC_ERROR, "no friendly OSC error screen available.\n" ));
    //
    // See if this is a BINL error or a system error and
    // get the text from the error tables.
    //
    dwLen = FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            GetModuleHandle(L"BINLSVC.DLL"),
                            Error,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPSTR) &ErrorMsg,
                            0,
                            (va_list*) &Messages );
    if ( dwLen == 0 )
    {
        BinlAssert( ErrorMsg == NULL );
        Err = GetLastError( );
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - no BINLSVC specific message available.\n", Err ));

        dwLen = FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                Error,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                (LPSTR) &ErrorMsg,
                                0,
                                NULL );
        if ( dwLen == 0 )
        {
            BinlAssert( ErrorMsg == NULL );
            Err = GetLastError( );
            BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - no SYSTEM specific message available.\n", Err ));
        }
    }

#if DBG
    if ( ErrorMsg )
        DebugMemoryAdd( ErrorMsg, __FILE__, __LINE__, "BINL", LPTR, lstrlenA(ErrorMsg), "ErrorMsg" );
#endif

    //
    // If all else fails, just print an error code.
    //
    if ( ErrorMsg == NULL ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "sending using generic error message.\n" ));
        ErrorMsg = (PCHAR) &UnknownErrorMsg;
        dwLen = strlen(ErrorMsg);
    }

#define ERRORITEM "%s%08x%s<BR><BOLD>%s</BOLD><BR><BR>%s"

    //
    // The + 13 is the "0x12345678 - " of the generated error message.
    //
    RspMessageLength = ErrorScreenLength + strlen(ERRORITEM) + dwLen + 1 + 13;
    RspMessage = (PCHAR) BinlAllocateMemory( RspMessageLength );
    if ( RspMessage == NULL )
    {
        Err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto Cleanup;
    }

    wsprintfA( RspMessage, ERRORITEM, ErrorScreenHeaders, Error, ErrorScreenBody, ErrorMsg, ErrorScreenTrailer );

    Err = ERROR_SUCCESS;

Cleanup:
    if ( Err == ERROR_SUCCESS )
    {
        // BinlPrint(( DEBUG_OSC, "Generated Error Response:\n%s\n", RspMessage ));
        *OutMessage = RspMessage;
        *OutMessageLength = RspMessageLength;

        BinlReportEventA( EVENT_ERROR_SERVER_SIDE_ERROR,
                          EVENTLOG_ERROR_TYPE,
                          4,
                          sizeof(Error),
                          Messages,
                          &Error
                          );
    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! Error 0x%08x - Couldn't generate error screen.\n", Err ));

        BinlReportEventA( EVENT_ERROR_GENERATING_SERVER_SIDE_ERROR,
                          EVENTLOG_ERROR_TYPE,
                          4,
                          sizeof(Err),
                          Messages,
                          &Err
                          );

        *OutMessage = NULL;
        *OutMessageLength = 0;

        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
        }
    }

    return Err;
}

//
// Returns a pointer point to the next 'ch' or NULL character.
//
PCHAR
FindNext(
    PCHAR Start,
    CHAR ch,
    PCHAR End
    )
{
    TraceFunc("FindNext( )\n");

    while( Start != End && *Start && *Start !=ch )
        Start++;

    if ( Start != End && *Start ) {
        return Start;
    } else {
        return NULL;
    }
}

//
// Finds the screen name.
//
PCHAR
FindScreenName(
    PCHAR Screen
    )
{
    PCHAR Name;
    TraceFunc("FindScreenName( )\n");

    Name = strstr( Screen, "NAME" );

    if ( Name == NULL )
        return NULL;

    Name += 5;  // "Name" plus space

    return Name;
}

DWORD
OscImpersonate(
    IN PCLIENT_STATE ClientState
    )
/*++

Routine Description:

    Makes the current thread impersonate the client. It is assumed
    that the client has already sent up a login screen. If this call
    succeeds, ClientState->AuthenticatedDCLdapHandle is valid.

Arguments:

    ClientState - The client state.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPSTR pUserName;
    LPSTR pUserDomain;
    LPSTR pUserPassword;
    LPSTR pDecodedPassword = NULL;
    LPSTR tempptr;
    ULONG temp;
    ULONG LdapError = 0;
    SEC_WINNT_AUTH_IDENTITY_A authIdentity;
    BOOL bResult;
    BOOL Impersonating = FALSE;
    LPWSTR pCrossDsDc;

    TraceFunc( "OscImpersonate( ... )\n" );

    pCrossDsDc = OscFindVariableW( ClientState, "DCNAME" );
    if (*pCrossDsDc == L'\0') {
    
        //
        // Clean up any old client state.
        //
    
        if (ClientState->AuthenticatedDCLdapHandle &&
            ClientState->UserToken) {
    
            bResult = ImpersonateLoggedOnUser(ClientState->UserToken);
            if (bResult) {
    
                return STATUS_SUCCESS;
            }
        }

    }

    if (ClientState->AuthenticatedDCLdapHandle) {
        //  Reconnecting again. Use new credentials.
        ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
        ClientState->AuthenticatedDCLdapHandle = NULL;
    }
    if (ClientState->UserToken) {
        CloseHandle(ClientState->UserToken);
        ClientState->UserToken = NULL;
    }

    //
    // Get the login variables from the client state.
    //

    pUserName = OscFindVariableA( ClientState, "USERNAME" );
    pUserDomain = OscFindVariableA( ClientState, "USERDOMAIN" );
    pUserPassword = OscFindVariableA( ClientState, "*PASSWORD" );

    if (pUserName[0] == '\0') {
        OscAddVariableA( ClientState, "SUBERROR", "USERNAME" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto ImpersonateFailed;
    }

    //
    // Decode the password.
    //

    Error = OscRunDecode(ClientState, pUserPassword, &pDecodedPassword);
    if (Error != ERROR_SUCCESS) {
        goto ImpersonateFailed;
    }


    //
    //  if the user didn't enter a domain name, use the server's
    //

    if (pUserDomain == NULL || pUserDomain[0] == '\0') {

        OscAddVariableW( ClientState, "USERDOMAIN", BinlGlobalOurDomainName );
            
        pUserDomain = OscFindVariableA( ClientState, "USERDOMAIN" );
        
    }

    //
    // Do a LogonUser with the credentials, since we
    // need that to change the machine password (even the
    // authenticated LDAP handle won't do that if we don't
    // have 128-bit SSL setup on this machine).
    //

    bResult = LogonUserA(
                  pUserName,
                  pUserDomain,
                  pDecodedPassword,
                  LOGON32_LOGON_NETWORK_CLEARTEXT,
                  LOGON32_PROVIDER_DEFAULT,
                  &ClientState->UserToken);

    if (!bResult) {
        Error = GetLastError();
        BinlPrintDbg(( DEBUG_ERRORS, "LogonUser failed %lx\n", Error));
        ClientState->UserToken = NULL;   // this may be set even on failure
        goto ImpersonateFailed;
    }

    //
    //  if the user didn't enter a domain name, grab it out of the user token.
    //

    if (pUserDomain == NULL || pUserDomain[0] == '\0') {

        PTOKEN_USER userToken;
        DWORD tokenSize = 4096;

        userToken = (PTOKEN_USER) BinlAllocateMemory( tokenSize );

        if (userToken != NULL) {

            DWORD returnLength;
            BOOL bRC;

            bRC = GetTokenInformation( ClientState->UserToken,
                                       TokenUser,
                                       (LPVOID) userToken,
                                       tokenSize,
                                       &returnLength
                                       );

            if (bRC) {

                WCHAR uUser[128];
                DWORD cUser   = 128;
                WCHAR uDomain[128];
                DWORD cDomain = 128;
                SID_NAME_USE peType;

                uDomain[0] = L'\0';
                uUser[0] = L'\0';

                bRC = LookupAccountSidW(   NULL,      // system name
                                           userToken->User.Sid,
                                           uUser,         // user name
                                           &cUser,        // user name count
                                           uDomain,       // domain name
                                           &cDomain,      // domain name count
                                           &peType
                                           );

                if (bRC && uDomain[0] != L'\0') {

                    OscAddVariableW( ClientState, "USERDOMAIN", &uDomain[0] );
                }
            }

            BinlFreeMemory( userToken );
        }
    }

    //
    // Now impersonate the user.
    //

    bResult = ImpersonateLoggedOnUser(ClientState->UserToken);
    if (!bResult) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "ImpersonateLoggedOnUser failed %x\n", GetLastError()));
        Error = GetLastError();
        goto ImpersonateFailed;
    }

    Impersonating = TRUE;

    //
    // Create authenticated DC connection for use in machine object creation
    //  or modification.
    //
    BinlPrintDbg(( DEBUG_OSC,
        "ldap_init %S or %S\n", pCrossDsDc, BinlGlobalDefaultDS ));

    ClientState->AuthenticatedDCLdapHandle = ldap_init( 
                                                (*pCrossDsDc != L'\0')
                                                  ? pCrossDsDc
                                                  : BinlGlobalDefaultDS, 
                                                LDAP_PORT);

    BinlPrintDbg(( DEBUG_OSC,
    "ldap_init handle %x\n", ClientState->AuthenticatedDCLdapHandle ));


    temp = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED;
    ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

    temp = LDAP_VERSION3;
    ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_VERSION, &temp );

    //
    // Tell LDAP to keep connections referenced after searches.
    //

    temp = (ULONG)((ULONG_PTR)LDAP_OPT_ON);
    ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_REF_DEREF_CONN_PER_MSG, &temp);

    LdapError = ldap_connect(ClientState->AuthenticatedDCLdapHandle,0);

    if (LdapError != LDAP_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "this ldap_connect() failed %x\n", LdapError));
        goto ImpersonateFailed;
    }

    //
    // LDAP_AUTH_NEGOTIATE tells it to use the credentials of the user
    // we are impersonating.
    //

    LdapError = ldap_bind_sA(ClientState->AuthenticatedDCLdapHandle,
                             NULL,
                             NULL,
                             LDAP_AUTH_NEGOTIATE);

    if (LdapError != LDAP_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "ldap_bind_s() failed %x\n", LdapError));
        goto ImpersonateFailed;
    }

ImpersonateFailed:

    //
    // If we decoded the password, then erase and free it.
    //

    if (pDecodedPassword != NULL) {
        RtlZeroMemory(pDecodedPassword, strlen(pDecodedPassword));
        BinlFreeMemory(pDecodedPassword);
    }

    if (LdapError != LDAP_SUCCESS) {
        Error = LdapMapErrorToWin32(LdapError);
    }

    if (Error) {
        PWCHAR strings[3];
        strings[0] = OscFindVariableW( ClientState, "USERNAME" );
        strings[1] = OscFindVariableW( ClientState, "USERDOMAIN" );
        strings[2] = NULL;

        BinlReportEventW( ERROR_BINL_ERR_USER_LOGIN_FAILED,
                          EVENTLOG_WARNING_TYPE,
                          2,
                          sizeof(ULONG),
                          strings,
                          &Error
                          );

        if (ClientState->AuthenticatedDCLdapHandle) {
            ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
            ClientState->AuthenticatedDCLdapHandle = NULL;
        }
        if (ClientState->UserToken) {
            CloseHandle(ClientState->UserToken);
            ClientState->UserToken = NULL;
        }
        if (Impersonating) {
            RevertToSelf();
        }
    }

    return Error;
}

DWORD
OscRevert(
    IN PCLIENT_STATE ClientState
    )
/*++

Routine Description:

    Stops the current thread impersonating.

Arguments:

    ClientState - The client state.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOL bResult;

    TraceFunc( "OscRevert( ... )\n" );

    //
    // We are done impersonating for the moment.
    //

    bResult = RevertToSelf();
    if (!bResult) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "RevertToSelf failed %x\n", GetLastError()));
        Error = GetLastError();
    }

    //  keep the ldap handle around in case we need it again.

//  if (ClientState->AuthenticatedDCLdapHandle) {
//      ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
//      ClientState->AuthenticatedDCLdapHandle = NULL;
//  }
//  if (ClientState->UserToken) {
//      CloseHandle(ClientState->UserToken);
//      ClientState->UserToken = NULL;
//  }

    return Error;

}

//
// OscGuidToBytes( )
//
// Change CHAR Guid to bytes
//
DWORD
OscGuidToBytes(
    LPSTR  pszGuid,
    LPBYTE Guid )
{
    PCHAR psz;
    ULONG len;
    ULONG i;

    TraceFunc( "OscGuidToBytes( ... )\n" );

    len = strlen(pszGuid);
    BinlAssert( len == 32 );
    if ( len != 32 )
        return ERROR_BINL_INVALID_GUID;

    psz = pszGuid;
    i = 0;
    while ( i * 2 < 32 )
    {
        //
        // Upper 4-bits
        //
        CHAR c = *psz;
        psz++;
        Guid[i] = ( c > 59 ? (toupper(c) - 55) << 4 : (c - 48) << 4);

        //
        // Lower 4-bits
        //
        c = *psz;
        psz++;
        Guid[i] += ( c > 59 ? (toupper(c) - 55) : (c - 48) );

        //
        // Next byte
        //
        i++;
    }

    return ERROR_SUCCESS;
}


BOOLEAN
OscSifIsSysPrep(
    LPWSTR pSysPrepSifPath
    )
{
    DWORD dwErr;
    WCHAR Buffer[256];
    UNICODE_STRING UnicodeString;

    TraceFunc("OscSifIsSysPrep( )\n");

    Buffer[0] = UNICODE_NULL;
    GetPrivateProfileString(OSCHOOSER_SIF_SECTIONW,
                            L"ImageType",
                            Buffer, // default
                            Buffer,
                            256,
                            pSysPrepSifPath
                           );

    RtlInitUnicodeString(&UnicodeString, Buffer);
    RtlUpcaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);

    if (_wcsicmp(L"SYSPREP", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
OscSifIsCmdConsA(
    PCHAR pSifPath
    )
{
    DWORD dwErr;
    CHAR Buffer[256];

    TraceFunc("OscSifIsCmdCons( )\n");

    Buffer[0] = UNICODE_NULL;
    GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                             "ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_stricmp("CMDCONS", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
OscSifIsASR(
    PCHAR pSifPath
    )
{
    DWORD dwErr;
    CHAR Buffer[256];

    TraceFunc("OscSifIsASR( )\n");

    Buffer[0] = UNICODE_NULL;
    GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                             "ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_stricmp("ASR", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


DWORD
OscGetSkuType(
    PWSTR PathToTxtSetupSif
    )
{
    PWSTR SifFile;
    DWORD SkuType = 0;

    SifFile = BinlAllocateMemory( 
                    (wcslen(PathToTxtSetupSif) +
                     1 + 
                     wcslen(L"txtsetup.sif") +
                     1 ) * sizeof(WCHAR));

    if (!SifFile) {
        return 0; //default to professional on failure
    }

    wcscpy(SifFile, PathToTxtSetupSif);
    if (SifFile[wcslen(SifFile)-1] == L'\\') {
        wcscat( SifFile, L"txtsetup.sif" );
    } else {
        wcscat( SifFile, L"\\txtsetup.sif" );
    }

    SkuType = GetPrivateProfileInt( 
                        L"SetupData", 
                        L"ProductType", 
                        0, 
                        SifFile );

    BinlFreeMemory( SifFile );

    return (SkuType);

}


BOOLEAN
OscGetClosestNt(
    IN LPWSTR PathToKernel,
    IN DWORD  SkuType,
    IN PCLIENT_STATE ClientState,
    OUT LPWSTR SetupPath,
    OUT PBOOLEAN ExactMatch
    )
{
    DWORD Error = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOLEAN Impersonated = FALSE;
    WCHAR Path[MAX_PATH];
    ULONGLONG BestVersion = (ULONGLONG)0;
    ULONGLONG ThisVersion;
    ULONGLONG KernelVersion;
    DWORD dwPathLen;
    BOOLEAN ReturnValue = FALSE;

    TraceFunc("OscGetClosestNt( )\n");

    Error = ImpersonateSecurityContext(&ClientState->ServerContextHandle);
    if (Error != STATUS_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "ImpersonateSecurityContext: 0x%08x\n", Error ));
        goto Cleanup;
    }

    Impersonated = TRUE;

    //
    // Get the version info of the kernel passed in
    //
    if (!OscGetNtVersionInfo(&KernelVersion, PathToKernel, ClientState)) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscGetNtVersionInfo failed\n" ));
        goto Cleanup;
    }

    //
    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\*"
    if ( _snwprintf( Path,
                     sizeof(Path) / sizeof(Path[0]),
                     L"%ws\\Setup\\%ws\\%ws\\*",
                     IntelliMirrorPathW,
                     OscFindVariableW(ClientState, "LANGUAGE"),
                     REMOTE_INSTALL_IMAGE_DIR_W
                     ) == -1 ) {
        goto Cleanup;
    }

    hFind = FindFirstFile(Path, (LPVOID) &FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    dwPathLen = wcslen(Path);

    //
    // Loop enumerating each subdirectory
    //
    do {
        //
        // Ignore directories "." and ".."
        //
        if (wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L"..") &&
            (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DWORD ThisSkuType;
            DWORD dwFileNameLen;
            //
            // Add the sub-directory to the path
            //
            dwFileNameLen = wcslen(FindData.cFileName);
            if (dwPathLen + dwFileNameLen + MAX_ARCHITECTURE_LENGTH + 1 > sizeof(Path)/sizeof(Path[0])) {
                continue;  // path too long, skip it
            }
            wcscpy(&Path[dwPathLen - 1], FindData.cFileName );

            BinlPrintDbg(( DEBUG_OSC, "Found OS Directory: %ws\n", Path ));

            // Resulting string should be something like:
            //      "D:\RemoteInstall\Setup\English\Images\nt50.wks\i386"
            wcscat(Path, L"\\");
            wcscat(Path, OscFindVariableW(ClientState, "MACHINETYPE"));

            ThisSkuType = OscGetSkuType( Path );

#if 0
            //
            // Now look for the kernel. We want to save the best version
            // that is newer or equal to the kernel we are looking for,
            // and older than the previous best version (note that
            // BestVersion is initialized to 0 so we need to check for
            // that also).
            //
            if (OscGetNtVersionInfo(&ThisVersion, Path, ClientState) &&
                    (ThisVersion >= KernelVersion) &&
                    (ThisSkuType == SkuType) &&
                    ((BestVersion == (ULONGLONG)0) || (ThisVersion < BestVersion))) {
                BestVersion = ThisVersion;
                wcscpy(SetupPath, Path);
            }            
#else
            if (OscGetNtVersionInfo(&ThisVersion, Path, ClientState)) {
                //
                // if the sku we're looking for is ads and we've found srv,
                // then lie and say it's really
                // ads.  This gets around a problem where txtsetup.sif didn't
                // specify the SKU type correctly in 2195.
                //
                if (ThisSkuType == 1 && SkuType == 2) {
                    ThisSkuType = 2;
                }

                if ((ThisVersion >= KernelVersion) &&
                    (ThisSkuType == SkuType) &&
                    ((BestVersion == (ULONGLONG)0) || (ThisVersion < BestVersion))) {
                    BestVersion = ThisVersion;
                    wcscpy(SetupPath, Path);
                }
            }            
#endif
        }

    } while (FindNextFile(hFind, (LPVOID) &FindData));

    if (BestVersion != 0) {
        ReturnValue = TRUE;
        *ExactMatch = (BOOLEAN)(BestVersion == KernelVersion);
    } else {
        ReturnValue = FALSE;
    }

Cleanup:

    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if (Impersonated) {
        Error = RevertSecurityContext(&ClientState->ServerContextHandle);
        if (Error != STATUS_SUCCESS) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "RevertSecurityContext: 0x%08x\n", Error ));
            return FALSE;
        }
    }

    return ReturnValue;
}

BOOLEAN
OscGetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir,
    PCLIENT_STATE ClientState
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    ULARGE_INTEGER TmpVersion;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("OscGetNtVersionInfo( )\n");

    if (!SearchDir) {
        goto e0;
    }

    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"
    if (wcslen(SearchDir) + sizeof("\\ntoskrnl.exe") + 1> sizeof(Path)/sizeof(Path[0])) {
        goto e0;   // path too long, skip it
    }
    wcscpy(Path, SearchDir);
    wcscat(Path, L"\\ntoskrnl.exe");

    BinlPrintDbg((DEBUG_OSC, "Checking version: %ws\n", Path));

    FileVersionInfoSize = GetFileVersionInfoSize(Path, &VersionHandle);
    if (FileVersionInfoSize == 0)
        goto e0;

    VersionInfo = BinlAllocateMemory(FileVersionInfoSize);
    if (VersionInfo == NULL)
        goto e0;

    if (!GetFileVersionInfo(
             Path,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo))
        goto e1;

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             &FixedFileInfo,
             &FixedFileInfoLength))
        goto e1;

    TmpVersion.HighPart = FixedFileInfo->dwFileVersionMS;
    TmpVersion.LowPart = FixedFileInfo->dwFileVersionLS;
    *Version = TmpVersion.QuadPart;

    fResult = TRUE;

e1:
    BinlFreeMemory(VersionInfo);
e0:
    return fResult;
}

//
// Send a message on our socket. If the message is too long, then it
// splits it into fragments of MAXIMUM_FRAGMENT_LENGTH bytes.
//

#define MAXIMUM_FRAGMENT_LENGTH 1400

DWORD
SendUdpMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    BOOL bFragment,
    BOOL bResend
    )
{
    DWORD error;
    FRAGMENT_PACKET FragmentHeader;
    USHORT FragmentNumber;
    USHORT FragmentTotal;
    ULONG MessageLengthWithoutHeader;
    ULONG BytesSent;
    ULONG BytesThisSend;
    UCHAR TempMessage[1500];
    FRAGMENT_PACKET UNALIGNED * SendFragmentPacket =
                        (FRAGMENT_PACKET UNALIGNED *)TempMessage;

    TraceFunc("SendUdpMessage( )\n");

    //
    // The message starts with a signature, a length, a sequence number (all
    // four bytes), then two ushorts for fragment count and total. If
    // we have to split it we preserve this header in each packet, with
    // fragment count modified for each one.
    //

    MessageLengthWithoutHeader =
            clientState->LastResponseLength - FRAGMENT_PACKET_DATA_OFFSET;

    if (!bFragment ||
        ((FragmentTotal = (USHORT)((MessageLengthWithoutHeader + MAXIMUM_FRAGMENT_LENGTH - 1) / MAXIMUM_FRAGMENT_LENGTH)) <= 1))
    {
#ifdef _TRACE_FUNC_
        SendFragmentPacket = (FRAGMENT_PACKET UNALIGNED *)clientState->LastResponse;
        TraceFunc("Sending packet with ");
        BinlPrintDbg(( DEBUG_OSC, " SequenceNumber = %u )\n", SendFragmentPacket->SequenceNumber ));
#endif

        error = sendto(
                    RequestContext->ActiveEndpoint->Socket,
                    clientState->LastResponse,
                    clientState->LastResponseLength,
                    0,
                    &RequestContext->SourceName,
                    RequestContext->SourceNameLength
                    );

    } else {

        FragmentHeader = *((FRAGMENT_PACKET UNALIGNED *)clientState->LastResponse);  // struct copy -- save the header
        BytesSent = 0;

        for (FragmentNumber = 0; FragmentNumber < FragmentTotal; FragmentNumber++) {

            if (FragmentNumber == (FragmentTotal - 1)) {
                BytesThisSend = MessageLengthWithoutHeader - BytesSent;
            } else {
                BytesThisSend = MAXIMUM_FRAGMENT_LENGTH;
            }

            memcpy(
                TempMessage + FRAGMENT_PACKET_DATA_OFFSET,
                clientState->LastResponse + FRAGMENT_PACKET_DATA_OFFSET + (FragmentNumber * MAXIMUM_FRAGMENT_LENGTH),
                BytesThisSend);

            memcpy(SendFragmentPacket, &FragmentHeader, FRAGMENT_PACKET_DATA_OFFSET);
            SendFragmentPacket->Length = BytesThisSend + FRAGMENT_PACKET_EMPTY_LENGTH;
            SendFragmentPacket->FragmentNumber = FragmentNumber + 1;
            SendFragmentPacket->FragmentTotal = FragmentTotal;

#ifdef TEST_FAILURE
            if (FailFirstFragment) {
                FailFirstFragment = FALSE;
                BinlPrintDbg((DEBUG_OSC, "NOT sending first fragment, %ld bytes\n", BytesThisSend + FRAGMENT_PACKET_DATA_OFFSET));
                error = ERROR_SUCCESS;
            } else
#endif

            //
            // On resends, wait between fragments in case the resend is
            // because the card can't handle quick bursts of packets.
            //
            if (bResend && (FragmentNumber != 0)) {
                Sleep(10);  // wait 10 milliseconds
            }

            error = sendto(
                        RequestContext->ActiveEndpoint->Socket,
                        TempMessage,
                        BytesThisSend + FRAGMENT_PACKET_DATA_OFFSET,
                        0,
                        &RequestContext->SourceName,
                        RequestContext->SourceNameLength
                        );

            if (error == SOCKET_ERROR) {
                break;
            }

            BytesSent += BytesThisSend;

        }

    }

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sendto() failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    return( error );
}

//
// Verifies the packets signature is authentic
//
DWORD
OscVerifySignature(
    PCLIENT_STATE clientState,
    SIGNED_PACKET UNALIGNED * signedMessage
    )
{
    SECURITY_STATUS SecStatus;
    SecBuffer SigBuffers[2];
    ULONG MessageLength, SignLength;
    SecBufferDesc SignMessage;

    TraceFunc("OscVerifySignature( )\n");

    MessageLength = signedMessage->Length;
    SignLength = signedMessage->SignLength;

    //
    // Verify the signature
    //
    SigBuffers[0].pvBuffer = signedMessage->Data;
    SigBuffers[0].cbBuffer = MessageLength - SIGNED_PACKET_EMPTY_LENGTH;
    SigBuffers[0].BufferType = SECBUFFER_DATA;

    SigBuffers[1].pvBuffer = signedMessage->Sign;
    SigBuffers[1].cbBuffer = SignLength;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
    SecStatus = UnsealMessage(
    &clientState->ServerContextHandle,
    &SignMessage,
    0,
    0 );
#else
    SecStatus = VerifySignature(
    &clientState->ServerContextHandle,
    &SignMessage,
    0,
    0 );
#endif

    if (SecStatus != STATUS_SUCCESS)
    {
        DWORD Error;
        SIGNED_PACKET UNALIGNED * SendSignedMessage;

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sending ERR packet from Verify/Unseal!!\n"));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS)
            return SecStatus;   // we can't send anything back

        SendSignedMessage = (SIGNED_PACKET UNALIGNED *)(clientState->LastResponse);

        memcpy(SendSignedMessage->Signature, ErrorSignedSignature, 4);
        SendSignedMessage->Length = 4;
        SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    }

    return SecStatus;
}

//
//
//
DWORD
OscSendSignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * SendSignedMessage;
    SecBuffer SigBuffers[2];
    SecBufferDesc SignMessage;
    SECURITY_STATUS SecStatus;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendSignedMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SIGNED_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS)
        return Error;

    //
    // copy the message
    //
    SendSignedMessage = (SIGNED_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendSignedMessage->Data, Message, MessageLength);

    //
    // sign the message
    //
    memcpy(SendSignedMessage->Signature, ResponseSignedSignature, 4);
    SendSignedMessage->Length = MessageLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendSignedMessage->FragmentNumber = 1;  // fragment count
    SendSignedMessage->FragmentTotal = 1;  // fragment total

    SendSignedMessage->SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;

#if 0
    //
    // Send out an unsealed copy to a different port.
    //

    {
        USHORT TmpPort;
        PCHAR TmpSignature[4];

        TmpPort = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port;
        memcpy(TmpSignature, SendSignedMessage->Signature, 4);

        ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port = 0xabcd;
        memcpy(SendSignedMessage->Signature, "FAKE", 4);

        Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

        ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port = TmpPort;
        memcpy(SendSignedMessage->Signature, TmpSignature, 4);
    }
#endif

    SigBuffers[0].pvBuffer = SendSignedMessage->Data;
    SigBuffers[0].cbBuffer = MessageLength;
    SigBuffers[0].BufferType = SECBUFFER_DATA;

    SigBuffers[1].pvBuffer = SendSignedMessage->Sign;
    SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
    SecStatus = SealMessage(
                        &clientState->ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );
#else
    SecStatus = MakeSignature(
                        &clientState->ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );
#endif

    //
    // Make sure the signature worked. If not, send error packet.
    //
    if (SecStatus != STATUS_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sending ERR packet from Make/Seal!!\n"));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS)
            return Error;

        memcpy(SendSignedMessage->Signature, ErrorSignedSignature, 4);
        SendSignedMessage->Length = 4;
    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC, "Sending RSPS, %d bytes\n", clientState->LastResponseLength));
    }

#ifdef TEST_FAILURE
    if (FailFirstResponse)
    {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending RSP, %d bytes\n", clientState->LastResponseLength));
        FailFirstResponse = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send RSP message %d\n", Error ));
    }

    return Error;
}

//
//
//
DWORD
OscSendUnsignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * SendSignedMessage;
    SecBuffer SigBuffers[2];
    SecBufferDesc SignMessage;
    SECURITY_STATUS SecStatus;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendUnsignedMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SIGNED_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS)
        return Error;

    //
    // copy the message
    //
    SendSignedMessage = (SIGNED_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendSignedMessage->Data, Message, MessageLength);

    //
    // sign the message
    //
    memcpy(SendSignedMessage->Signature, ResponseUnsignedSignature, 4);
    SendSignedMessage->Length = MessageLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendSignedMessage->FragmentNumber = 1;  // fragment count
    SendSignedMessage->FragmentTotal = 1;  // fragment total
    SendSignedMessage->SignLength = 0;

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send RSU message %d\n", Error ));
    }

    return Error;
}

DWORD
OscSendSetupMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    ULONG RequestType,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SPUDP_PACKET UNALIGNED * SendMessage;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendSetupMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SPUDP_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS) {
        return Error;
    }

    //
    // copy the message
    //
    SendMessage = (SPUDP_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendMessage->Data, Message, MessageLength);

    //
    // fill in the message stuff
    //
    memcpy(SendMessage->Signature, SetupResponseSignature, 4);
    SendMessage->Length = MessageLength + SPUDP_PACKET_EMPTY_LENGTH;
    SendMessage->Status = STATUS_SUCCESS;
    SendMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendMessage->RequestType = RequestType;
    SendMessage->FragmentNumber = 1;  // fragment count
    SendMessage->FragmentTotal = 1;  // fragment total

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send SPR message %d\n", Error ));
    }

    return Error;
}

#ifdef SET_ACLS_ON_CLIENT_DIRS
//
//
//
DWORD
OscSetClientDirectoryPermissions(
    PCLIENT_STATE clientState )
{
    DWORD Err = ERROR_SUCCESS;
    WCHAR DirPath[ MAX_PATH ];
    WCHAR Domain[ 80 ];
    DWORD dwDomainSize = 80;
    PSECURITY_DESCRIPTOR pSD;
    PACL pDACL;
    PSID pSID;
    BOOL bOwnerDefault;
    DWORD dwLengthRequired;
    SID_NAME_USE snu;
    PWCHAR pMachineName = OscFindVariableW( clientState, "MACHINENAME" );

    if ( _snwprintf ( DirPath,
                      sizeof(DirPath) / sizeof(DirPath[0]),
                      L"%ws\\REMINST\\Clients\\%ws",
                      OscFindVariableW( clientState, "SERVERNAME" ),
                      pMachineName ) == -1 ) {
        Err = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    //
    // Figure out how big the machine account's SID is
    //
    LookupAccountName( NULL,
                       pMachineName,
                       pSID,
                       &dwLengthRequired,
                       Domain,
                       &dwDomainSize,
                       &snu );

    //
    // make space
    //
    pSID = (PSID) BinlAllocateMemory( dwLengthRequired );
    if ( pSID == NULL )
        goto OutOfMemory;

    //
    // get the machine account's SID
    //
    if (!LookupAccountName( NULL, pMachineName, pSID, &dwLengthRequired, Domain, &dwDomainSize, &snu ) )
        goto Error;

    dwLengthRequired += sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid ( pSID );
    pDACL = (PACL) BinlAllocateMemory( dwLengthRequired );
    if ( pDACL == NULL )
        goto OutOfMemory;

    pSD = ( PSECURITY_DESCRIPTOR) BinlAllocateMemory( SECURITY_DESCRIPTOR_MIN_LENGTH + dwLengthRequired );
    if ( pSD == NULL )
        goto OutOfMemory;

    if ( !InitializeSecurityDescriptor ( pSD, SECURITY_DESCRIPTOR_REVISION) )
        goto Error;

    if ( !InitializeAcl( pDACL, dwLengthRequired, ACL_REVISION ) )
        goto Error;

    if ( !AddAccessAllowedAce( pDACL, ACL_REVISION, FILE_ALL_ACCESS, pSID ) )
        goto Error;

    if ( !IsValidAcl( pDACL ) )
        goto Error;

    if ( !SetSecurityDescriptorDacl( pSD, TRUE, pDACL, FALSE ) )
        goto Error;

    if ( !SetSecurityDescriptorOwner( pSD, pSID, FALSE ) )
        goto Error;

    if ( ! IsValidSecurityDescriptor ( pSD ) )
        goto Error;

    if ( !SetFileSecurity( DirPath,
                          OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                          pSD ) )
        goto Error;

    goto Cleanup;

OutOfMemory:
    Err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    goto Cleanup;

Error:
    Err = GetLastError( );

Cleanup:
    if ( pSID )
        BinlFreeMemory( pSID );

    if ( pSD )
        BinlFreeMemory( pSD );

    return Err;
}
#endif // SET_ACLS_ON_CLIENT_DIRS

#if 0
VOID
OscGetFlipServerList(
    PUCHAR FlipServerList,
    PULONG FlipServerListLength
    )
/*++

Routine Description:

    This function gets the flip server list using the GPT of the
    currently impersonated user.

Arguments:

    FlipServerList - The location to store the flip server list, which
        is a series of 4-byte IP addresses.

    FlipServerListLength - Returns the length of the flip server list
        if any are stored.

Return Value:

    None.

--*/
{
    LPWSTR GptPath;
    WCHAR NetbootPath[MAX_PATH];
    WCHAR TempServerList[128];
    ULONG TempServerIp[4];
    LPWSTR CurDirLoc, CurDirEnd;
    LPWSTR CurSrvLoc, CurSrvEnd;
    PUCHAR CurFlipLoc;
    ULONG FlipServerCount;

    TraceFunc("OscGetFlipServerList( )\n");

    TempServerList[0] = L'\0';

    //
    // Read the GPT path.
    //

    GptPath = GetGPTPath(NULL, NULL);

    //
    // Scan the GPT path for a netboot.ini file.
    //

    CurDirLoc = GptPath;

    while (*CurDirLoc != L'\0') {

        CurDirEnd = wcschr(CurDirLoc, L';');
        if (CurDirEnd == NULL) {
            wsprintf(NetbootPath, L"%wsnetboot.ini", CurDirLoc);
            CurDirLoc += wcslen(CurDirLoc);  // points to final '\0'
        } else {
            *CurDirEnd = L'\0';   // HACK since %*ws does not seem to work
            wsprintf(NetbootPath, L"%wsnetboot.ini", CurDirLoc);
            *CurDirEnd = L';';
            CurDirLoc = CurDirEnd + 1;       // move past the ';'
        }

        //
        // Check that the file exists.
        //

        if (GetFileAttributes(NetbootPath) == (DWORD)-1) {
            continue;
        }

        //
        // If the file exists, assume it is the right one -- if
        // it doesn't have the right section and key, don't try to
        // look in the next path location.
        //

        GetPrivateProfileString(
            L"BINL Server",
            L"NewAccountServers",
            L"",              // default value is empty string
            TempServerList,
            sizeof(TempServerList),
            NetbootPath
            );

        break;

    }

    //
    // At this point the server list is in TempServerList, which
    // may be of length 0. Parse through it for IP addresses and
    // put them in FlipServerList.
    //

    BinlPrintDbg(( DEBUG_OSC, "TempServerList is <%ws>\n", TempServerList ));

    CurSrvLoc = TempServerList;
    CurFlipLoc = FlipServerList;

    while (*CurSrvLoc != L'\0') {

        CurSrvEnd = wcschr(CurSrvLoc, L',');
        if (CurSrvEnd != NULL) {
            *CurSrvEnd = L'\0';
        }

        swscanf(CurSrvLoc, L"%ld.%ld.%ld.%ld", &TempServerIp[0], &TempServerIp[1], &TempServerIp[2], &TempServerIp[3]);

        CurFlipLoc[0] = (UCHAR)TempServerIp[0];
        CurFlipLoc[1] = (UCHAR)TempServerIp[1];
        CurFlipLoc[2] = (UCHAR)TempServerIp[2];
        CurFlipLoc[3] = (UCHAR)TempServerIp[3];

#if 0
        BinlPrintDbg(( DEBUG_OSC, "FOUND IP address %d.%d.%d.%d\n",
            CurFlipLoc[0],
            CurFlipLoc[1],
            CurFlipLoc[2],
            CurFlipLoc[3]));
#endif

        CurFlipLoc += 4;
        *FlipServerListLength += 4;

        //
        // Only allow MAX_FLIP_SERVER_COUNT servers.
        //

        if (*FlipServerListLength == (MAX_FLIP_SERVER_COUNT*4)) {
            break;
        }

        if (CurSrvEnd != NULL) {
            CurSrvLoc = CurSrvEnd + 1;
        } else {
            break;
        }
    }

    //
    // Randomize the list in FlipServerList.
    //

    FlipServerCount = (*FlipServerListLength) / 4;

    if (FlipServerCount > 1) {

        ULONG RandomSeed;
        ULONG i, j;
        UCHAR TempBuffer[4];

        //
        // For each element except the last, swap it with a random
        // element.
        //

        RandomSeed = GetTickCount();

        for (i = 0; i < FlipServerCount-1; i++) {

            //
            // Pick a random element j between the ith and the end.
            //

            j = i + (RtlRandom(&RandomSeed) % (FlipServerCount - i));

            //
            // Swap ith and jth element, unless i == j.
            //

            if (i != j) {
                memcpy(TempBuffer, &FlipServerList[i*4], 4);
                memcpy(&FlipServerList[i*4], &FlipServerList[j*4], 4);
                memcpy(&FlipServerList[j*4], TempBuffer, 4);
            }
        }
    }

}
#endif  // FlipServer

#ifdef REMOTE_BOOT
//
// Copy any initial files specified in SIF.
//
DWORD
OscCopyTemplateFiles(
    LPWSTR SourcePath,
    LPWSTR ImagePath,
    LPWSTR TemplateFile
    )
{
    #define MAX_FILES_SIZE 2048
    WCHAR   Files[ MAX_FILES_SIZE ];
    DWORD   dwErr = ERROR_SUCCESS;
    LPWSTR  pFilename;
    WCHAR   SrcFilepath[ MAX_PATH ];
    WCHAR   DstFilepath[ MAX_PATH ];

    TraceFunc("OscCopyTemplateFiles( )\n");

    dwErr = GetPrivateProfileSection( L"OSChooserFiles",
                                      Files,
                                      MAX_FILES_SIZE,
                                      TemplateFile );
    BinlAssert( dwErr != MAX_FILES_SIZE - 2 );
    #undef MAX_FILES_SIZE

    pFilename = Files;
    while ( *pFilename )
    {
        BOOL b;
        LPWSTR psz = pFilename;
        while ( *psz && *psz !=L',' )
            psz++;

        if ( *psz == L',' )
        {
            *psz = L'\0';
            psz++;
        }
        else
        {
            psz = pFilename;
        }

        wsprintf( SrcFilepath, L"%ws\\%ws", SourcePath, psz );
        wsprintf( DstFilepath, L"%ws\\%ws", ImagePath, pFilename );

        BinlPrintDbg((DEBUG_OSC, "Copying %ws to %ws...\n", SrcFilepath, DstFilepath));

        b = CopyFile( SrcFilepath, DstFilepath, TRUE );
        if ( !b ) {
            dwErr = GetLastError( );
            goto Error;
        }

        // find the end of the string
        while ( *psz )
            psz++;

        pFilename = ++psz; // skip null
    }

Error:
    return dwErr;
}
#endif  // REMOTE_BOOT

#if DBG && defined(REMOTE_BOOT)
//
// Create MAC Address file -
// This might be turned into a DESKTOP.INI file(?). -gpease
//
DWORD
OscCreateNullFile(
    LPWSTR Image,
    LPWSTR MAC
    )
{
    DWORD  dwErr = ERROR_SUCCESS;
    WCHAR  Path[ MAX_PATH ];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    TraceFunc("OscCreateNullFile( )\n");

    wsprintf( Path, L"%ws\\%ws", Image, MAC );

    //
    // Create NULL length file
    //
    hFile = CreateFile( Path,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,                   // security attribs
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN
                        NULL );                 // template
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle( hFile );
    }

    return dwErr;
}
#endif

DWORD
OscConstructSecret(
    PCLIENT_STATE clientState,
    PWCHAR UnicodePassword,
    ULONG  UnicodePasswordLength,
    PCREATE_DATA CreateData
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;
    WCHAR DomainBuffer[64];
    DWORD SidLength, DomainLength;
    SID_NAME_USE NameUse;
    BOOL  b;
    PCHAR pBootFile;
    PCHAR pSifFile;
#if defined(REMOTE_BOOT)
    PCHAR pNetBIOSName;
    PCHAR pUserDomain;
#endif

    TraceFunc( "OscConstructSecret( )\n" );

    RtlZeroMemory(CreateData, sizeof(CREATE_DATA));

    //
    // Copy the machine data into the response packet
    //
    // The following fields aren't necessary unless we're supporting remote boot.
    //      UCHAR Sid[28];
    //      UCHAR Domain[32];
    //      UCHAR Name[32];
    //      UCHAR Password[32];
    //      ULONG UnicodePasswordLength;  // in bytes
    //      WCHAR UnicodePassword[32];
    //      UCHAR Installation[32];
    //      UCHAR MachineType[6];  // 'i386\0' or 'Alpha\0'
    //

    pBootFile = OscFindVariableA( clientState, "BOOTFILE" );
    if ( pBootFile[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "BOOTFILE" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    pSifFile = OscFindVariableA( clientState, "SIFFILE" );
    if ( pSifFile[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "SIFFILE" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    memcpy( CreateData->Id, "ACCT", 4);
    CreateData->VersionNumber = OSC_CREATE_DATA_VERSION;
    strcpy( CreateData->NextBootfile, pBootFile );
    strcpy( CreateData->SifFile, pSifFile );

#if defined(REMOTE_BOOT)
    pNetBIOSName = OscFindVariableA( clientState, "NETBIOSNAME");
    if ( pNetBIOSName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "NETBIOSNAME" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    pUserDomain = OscFindVariableA( clientState, "USERDOMAIN" );
    if ( pUserDomain[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "USERDOMAIN" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    strcpy( CreateData->Name, OscFindVariableA( clientState, pNetBIOSName ) );
    CreateData->UnicodePasswordLength = UnicodePasswordLength;
    memcpy( CreateData->UnicodePassword, UnicodePassword, CreateData->UnicodePasswordLength );
    strcpy( CreateData->Domain, OscFindVariableA( clientState, pUserDomain ) );

    //
    // We send the password down in Unicode also which is
    // just the machine name.
    // NOTE: We probably need to worry about
    // the code page of the client, for the moment just do
    // the simplest conversion. We may also want to get
    // the machine name/password in Unicode and only convert
    // it to ANSI right here. We'll punt this for the moment,
    // at least the on-the-wire format will be correct.
    //
    //
    // This isn't used right now, we only care about the Unicode password.
    //
    memset( CreateData->Password, '\0', sizeof(CreateData->Password) );

    //
    // Get the SID from the system.
    //
    SidLength = sizeof(CreateData->Sid);
    DomainLength = sizeof(DomainBuffer) / sizeof(WCHAR);

    b = LookupAccountName(
            NULL,
            OscFindVariableW( clientState, "NETBIOSNAME" ),
            CreateData->Sid,
            &SidLength,
            DomainBuffer,
            &DomainLength,
            &NameUse);

    if (!b) {
        DWORD dwErr = GetLastError( );
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! Error 0x%08x - Account lookup failed.\n", dwErr ));
        OscCreateWin32SubError( clientState, dwErr );
        return ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT;;
    }

    // This should be the NETBIOS domain name.
    wcstombs( CreateData->Domain, DomainBuffer, DomainLength + 1 );

    //
    // Sanity check
    //
    BinlAssertMsg( CreateData->Name[0],               "No machine name" );
    // BinlAssertMsg( CreateData->Password[0],           "No machine password" );
    BinlAssertMsg( CreateData->UnicodePasswordLength, "Password length is ZERO" );
    BinlAssertMsg( CreateData->UnicodePassword[0],    "No UNICODE machine password" );
    BinlAssertMsg( CreateData->Domain[0],             "No machine domain" );

#endif
    BinlAssertMsg( CreateData->NextBootfile[0],       "No boot file" );
    return dwErr;
}

DWORD
GetOurServerInfo (
    VOID
    )
//
//  This routine gets several global names that we need to handle client
//  requests.  We store them in globals because they change very infrequently
//  and they're relatively expense to retrieve.
//
{
    PWCHAR fqdn = NULL;
    DWORD uSize;
    DWORD dnsError = ERROR_SUCCESS;
    DWORD fqdnError = ERROR_SUCCESS;
    DWORD netbiosServerError = ERROR_SUCCESS;
    DWORD netbiosDomainError = ERROR_SUCCESS;
    PWCHAR ourDNSName = NULL;
    PWCHAR tmp;
    PWCHAR pDomain;
    WCHAR  ServerName[32] = { 0 };
    DWORD  ServerSize = sizeof(ServerName) / sizeof(WCHAR);
    ULONG Error;

    // first grab the netbios name of our server

    if ( !GetComputerNameEx( ComputerNameNetBIOS, ServerName, &ServerSize ) ) {
        netbiosServerError = GetLastError();
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", netbiosServerError ));
    } else {

        tmp = BinlAllocateMemory( ( lstrlenW( ServerName ) + 1 ) * sizeof(WCHAR) );

        if (tmp == NULL) {

            netbiosServerError = ERROR_NOT_ENOUGH_SERVER_MEMORY;

        } else {

            lstrcpyW( tmp, ServerName );

            EnterCriticalSection( &gcsParameters );

            if (BinlGlobalOurServerName) {
                BinlFreeMemory( BinlGlobalOurServerName );
            }

            BinlGlobalOurServerName = tmp;

            LeaveCriticalSection( &gcsParameters );
        }
    }

    // Next grab the fully qualified domain name of our server
    uSize = 0;
    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &uSize ) ) {
        fqdnError = GetLastError( );
        if ( fqdnError != ERROR_MORE_DATA ) {

            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerObjectName failed.\n", fqdnError ));
            goto GetDNS;
        }
        fqdnError = ERROR_SUCCESS;
    }
    fqdn = BinlAllocateMemory( uSize * sizeof(WCHAR) );
    if ( fqdn ) {
        if ( !GetComputerObjectName( NameFullyQualifiedDN, fqdn, &uSize ) ) {

            fqdnError = GetLastError( );
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerObjectName failed.\n", fqdnError ));

        } else {

            EnterCriticalSection( &gcsParameters );

            tmp = BinlGlobalOurFQDNName;
            BinlGlobalOurFQDNName = fqdn;

            fqdn = tmp;     // we'll free it below

            // next setup the netbios domain name

            pDomain = StrStrIW( BinlGlobalOurFQDNName, L"DC=" );
            if ( pDomain ) {

                PDS_NAME_RESULTW pResults;

                BinlPrintDbg(( DEBUG_OSC, "Converting %ws to a NetBIOS domain name...\n", pDomain ));

                netbiosDomainError = DsCrackNames( INVALID_HANDLE_VALUE,
                                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                      DS_FQDN_1779_NAME,
                                      DS_CANONICAL_NAME,
                                      1,
                                      &pDomain,
                                      &pResults );
                if (netbiosDomainError != ERROR_SUCCESS) {

                    BinlPrint(( DEBUG_ERRORS, "GetOurServerInfo error in DsCrackNames %u\n", netbiosDomainError ));
                }

                if ( netbiosDomainError == ERROR_SUCCESS ) {
                    if ( pResults->cItems == 1
                      && pResults->rItems[0].status == DS_NAME_NO_ERROR
                      && pResults->rItems[0].pName ) {    // paranoid

                        pResults->rItems[0].pName[wcslen(pResults->rItems[0].pName)-1] = L'\0';

                        tmp = BinlAllocateMemory( ( lstrlenW( pResults->rItems[0].pName ) + 1 ) * sizeof(WCHAR) );

                        if (tmp == NULL) {

                            netbiosDomainError = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                        } else {

                            lstrcpyW( tmp, pResults->rItems[0].pName );

                            if (BinlGlobalOurDomainName) {
                                BinlFreeMemory( BinlGlobalOurDomainName );
                            }
                            BinlGlobalOurDomainName = tmp;
                        }
                    }
                    DsFreeNameResult( pResults );
                }
            }
            LeaveCriticalSection( &gcsParameters );
        }
    } else {

        fqdnError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

GetDNS:
    // Retrieve the FQDNS name of the server
    uSize = 0;
    if ( !GetComputerNameEx( ComputerNameDnsFullyQualified, NULL, &uSize ) ) {
        dnsError = GetLastError( );
        if ( dnsError != ERROR_MORE_DATA ) {
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", dnsError ));
            goto returnError;
        }
        dnsError = ERROR_SUCCESS;
    }
    ourDNSName = (PWCHAR) BinlAllocateMemory( uSize * sizeof(WCHAR) );
    if ( ourDNSName ) {
        if ( !GetComputerNameEx( ComputerNameDnsFullyQualified, ourDNSName, &uSize ) ) {

            dnsError = GetLastError( );
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", dnsError ));

        } else {

            EnterCriticalSection( &gcsParameters );

            tmp = BinlGlobalOurDnsName;
            BinlGlobalOurDnsName = ourDNSName;

            LeaveCriticalSection( &gcsParameters );

            ourDNSName = tmp;   // we'll free it below
        }
    } else {
        dnsError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

returnError:

    if (ourDNSName) {
        BinlFreeMemory( ourDNSName );
    }
    if (fqdn) {
        BinlFreeMemory( fqdn );
    }
    if (fqdnError != ERROR_SUCCESS) {
        Error = fqdnError;
    } else if (dnsError != ERROR_SUCCESS) {
        Error = dnsError;
    } else if (netbiosServerError != ERROR_SUCCESS) {
        Error = netbiosServerError;
    } else {
        Error = netbiosDomainError;
    }
    return Error;
}

DWORD
GetDomainNetBIOSName(
    IN PCWSTR DomainNameInAnyFormat,
    OUT PWSTR *NetBIOSName
    )
/*++

Routine Description:

    Retrieves the netbios name for a domain given an input name.  The input
    name may be in DNS form or netbios form, it doesn't really matter.

Arguments:

    DomainNameInAnyFormat - string representing the name of the domain to query

    NetBIOSName - receives string that represents the domain netbios name.  
                  The string must be freed via BinlFreeMemory.

Return Value:

    win32 error code indicating outcome.

--*/
{
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC DomainInfo = NULL;
    DWORD Error;

    Error = DsGetDcName( 
                    NULL, 
                    DomainNameInAnyFormat, 
                    NULL, 
                    NULL, 
                    DS_RETURN_FLAT_NAME, 
                    &DomainControllerInfo );

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "DsGetDcName (%ws) failed, ec = %d.\r\n",
            DomainNameInAnyFormat,
            Error ));
        goto exit;
    }

    Error = DsRoleGetPrimaryDomainInformation(
                                        DomainControllerInfo->DomainControllerName,
                                        DsRolePrimaryDomainInfoBasic,
                                        (PBYTE *) &DomainInfo);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "DsRoleGetPrimaryDomainInformation (%ws) failed, ec = %d.\r\n",
            DomainControllerInfo->DomainControllerName,
            Error ));
        goto exit;
    }

    *NetBIOSName = BinlAllocateMemory( 
                        (wcslen(DomainInfo->DomainNameFlat)+1) * sizeof(WCHAR) );

    if (*NetBIOSName) {
        wcscpy( *NetBIOSName, DomainInfo->DomainNameFlat );
    } else {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "GetDomainNetBIOSName: failed to allocate memory (%d bytes) .\r\n",
            (wcslen(DomainInfo->DomainNameFlat)+1) * sizeof(WCHAR) ));
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

exit:
    if (DomainInfo) {
        DsRoleFreeMemory( DomainInfo );
    }

    if (DomainControllerInfo) {
        NetApiBufferFree( DomainControllerInfo );
    }

    return(Error);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\dhcp_clt.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_cli.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#if defined( _ALPHA_ )
#include <stdarg.h>
#endif

#include "dhcp_cli.h"

#define TYPE_FORMAT_STRING_SIZE   1547                              
#define PROC_FORMAT_STRING_SIZE   2359                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */

handle_t dhcpsrv_bhandle;


static const RPC_CLIENT_INTERFACE dhcpsrv___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE dhcpsrv_ClientIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcClientInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

static RPC_BINDING_HANDLE dhcpsrv__MIDL_AutoBindHandle;


DWORD R_DhcpCreateSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[54],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[54],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out] */ LPDHCP_SUBNET_INFO __RPC_FAR *SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnets( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_IP_ARRAY __RPC_FAR *EnumInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[162],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[162],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[234],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[234],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElements( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[288],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[288],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[372],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[372],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[486],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[486],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [out] */ LPDHCP_OPTION __RPC_FAR *OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[594],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[594],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionID);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_DATA OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[696],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[696],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out] */ LPDHCP_OPTION_VALUE __RPC_FAR *OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[756],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[756],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_VALUE_ARRAY __RPC_FAR *OptionValues,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[816],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[816],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScopeInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[894],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[894],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[948],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[948],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[996],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[996],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1044],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1044],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1098],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1098],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClients( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1146],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1146],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS ClientIpAddress,
    /* [in] */ DHCP_IP_MASK ClientSubnetMask,
    /* [out] */ LPDHCP_OPTION_LIST __RPC_FAR *ClientOptions)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientOptions);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1224],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1224],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetMibInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_MIB_INFO __RPC_FAR *MibInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MibInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1284],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1284],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_ARRAY __RPC_FAR *Options,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1332],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1332],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_VALUE_ARRAY OptionValues)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValues);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1404],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1404],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1458],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1458],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1512],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1512],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpScanDatabase( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DWORD FixFlag,
    /* [out] */ LPDHCP_SCAN_LIST __RPC_FAR *ScanList)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScanList);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1560],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1560],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetVersion( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDWORD MajorVersion,
    /* [out] */ LPDWORD MinorVersion)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MinorVersion);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1620],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1620],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1674],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1674],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElementsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1728],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1728],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1812],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1812],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1872],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1872],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1920],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1920],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO_V4 __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1968],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1968],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClientsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY_V4 __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2022],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2022],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [string][unique][in] */ WCHAR __RPC_FAR *SuperScopeName,
    /* [in] */ BOOL ChangeExisting)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ChangeExisting);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2100],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2100],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSuperScopeInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SUPER_SCOPE_TABLE __RPC_FAR *SuperScopeTable)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeTable);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2160],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2160],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [string][ref][in] */ WCHAR __RPC_FAR *SuperScopeName)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeName);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2208],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2208],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2256],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2256],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO_V4 __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2310],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2310],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];
extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 42 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 46 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 54 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 56 */	NdrFcLong( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
#ifndef _ALPHA_
/* 62 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 64 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 66 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 68 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 76 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 88 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 90 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 96 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 98 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 100 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 130 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 150 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 154 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 162 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x3 ),	/* 3 */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 172 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 174 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 176 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 180 */	NdrFcShort( 0x5c ),	/* 92 */
/* 182 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 184 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 186 */	NdrFcShort( 0x1 ),	/* 1 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 192 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 194 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 196 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 198 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 210 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 214 */	NdrFcShort( 0x50 ),	/* Type Offset=80 */

	/* Parameter ElementsRead */

/* 216 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 230 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x4 ),	/* 4 */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 244 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 246 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 256 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 266 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 276 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 278 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 280 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 288 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x5 ),	/* 5 */
#ifndef _ALPHA_
/* 296 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 298 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 300 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 302 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x32 ),	/* 50 */
/* 306 */	NdrFcShort( 0x5c ),	/* 92 */
/* 308 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 310 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 312 */	NdrFcShort( 0x3 ),	/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 318 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 320 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 322 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 336 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 338 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 348 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 350 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 352 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Parameter ElementsRead */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 356 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 360 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 362 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 368 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 372 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x6 ),	/* 6 */
#ifndef _ALPHA_
/* 380 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 382 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 384 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 386 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 388 */	NdrFcShort( 0xe ),	/* 14 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 394 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x2 ),	/* 2 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 404 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 406 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 414 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 418 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Parameter ForceFlag */

/* 420 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 424 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 442 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 444 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 446 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 448 */	NdrFcShort( 0xe ),	/* 14 */
/* 450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 452 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 454 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 462 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 464 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 466 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 468 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 478 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 486 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 496 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 498 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 500 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 528 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 532 */	NdrFcShort( 0x136 ),	/* Type Offset=310 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 550 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 552 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 554 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 558 */	NdrFcShort( 0x8 ),	/* 8 */
/* 560 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 562 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x4 ),	/* 4 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 570 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 574 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 582 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 586 */	NdrFcShort( 0x136 ),	/* Type Offset=310 */

	/* Return value */

/* 588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 594 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 602 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 604 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 606 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 608 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	NdrFcShort( 0x8 ),	/* 8 */
/* 614 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 616 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 624 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 626 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 636 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 640 */	NdrFcShort( 0x1cc ),	/* Type Offset=460 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 644 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 658 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 660 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 662 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 668 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 670 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 678 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 680 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 682 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 696 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 704 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 706 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 708 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 710 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 718 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 726 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 728 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 730 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 738 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 742 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 744 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 748 */	NdrFcShort( 0x19e ),	/* Type Offset=414 */

	/* Return value */

/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 752 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 756 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 764 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 766 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 768 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 770 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 776 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 778 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	NdrFcShort( 0x1 ),	/* 1 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 786 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 788 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 790 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 802 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 804 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 808 */	NdrFcShort( 0x218 ),	/* Type Offset=536 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 816 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 824 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 826 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 828 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 830 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 832 */	NdrFcShort( 0x24 ),	/* 36 */
/* 834 */	NdrFcShort( 0x5c ),	/* 92 */
/* 836 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 838 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 840 */	NdrFcShort( 0x5 ),	/* 5 */
/* 842 */	NdrFcShort( 0x1 ),	/* 1 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 846 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 848 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 850 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 852 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 856 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter ResumeHandle */

/* 858 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 866 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 870 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 872 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 874 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter OptionsRead */

/* 876 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 878 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 882 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 884 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 890 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 894 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 902 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 904 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 906 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 908 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 916 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* 1 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 924 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 926 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 928 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 940 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 944 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 948 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 958 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 960 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 962 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x8 ),	/* 8 */
/* 968 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 970 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0x1 ),	/* 1 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 978 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 982 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 984 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 986 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 988 */	NdrFcShort( 0x28a ),	/* Type Offset=650 */

	/* Return value */

/* 990 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 992 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 996 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 998 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1002 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1006 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1008 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1010 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1016 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1018 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1026 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1028 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1030 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1036 */	NdrFcShort( 0x28a ),	/* Type Offset=650 */

	/* Return value */

/* 1038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1044 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 1052 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1054 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1056 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1058 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1066 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1068 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1070 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1076 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1078 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1080 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1082 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1084 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 1086 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1088 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1090 */	NdrFcShort( 0x316 ),	/* Type Offset=790 */

	/* Return value */

/* 1092 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1094 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1098 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1100 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1108 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1110 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1112 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1120 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1128 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1130 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1136 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1138 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Return value */

/* 1140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1142 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1146 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1152 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 1154 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1156 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1158 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1160 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1162 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1164 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1166 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1168 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1170 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1178 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1180 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1188 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1200 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1204 */	NdrFcShort( 0x31e ),	/* Type Offset=798 */

	/* Parameter ClientsRead */

/* 1206 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1212 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1214 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1220 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1224 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 1232 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1234 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1236 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1238 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1244 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1246 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1248 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1254 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1256 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1258 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1276 */	NdrFcShort( 0x35a ),	/* Type Offset=858 */

	/* Return value */

/* 1278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1290 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 1292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1294 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1296 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1306 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1308 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1314 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1316 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1318 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1320 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1322 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1324 */	NdrFcShort( 0x376 ),	/* Type Offset=886 */

	/* Return value */

/* 1326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1332 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 1340 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1342 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1344 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1346 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1350 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1352 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1354 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1356 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1364 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1366 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1368 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1374 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1380 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1384 */	NdrFcShort( 0x3b8 ),	/* Type Offset=952 */

	/* Parameter OptionsRead */

/* 1386 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1388 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1392 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1400 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1404 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 1412 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1414 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1416 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1418 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1424 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1426 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1434 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1436 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1438 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1440 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1444 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValues */

/* 1446 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1450 */	NdrFcShort( 0x3ea ),	/* Type Offset=1002 */

	/* Return value */

/* 1452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1458 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x19 ),	/* 25 */
#ifndef _ALPHA_
/* 1466 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1468 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1470 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1472 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1480 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1490 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1492 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1496 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1500 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 1502 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1504 */	NdrFcShort( 0x3ee ),	/* Type Offset=1006 */

	/* Return value */

/* 1506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1512 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x1a ),	/* 26 */
#ifndef _ALPHA_
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1522 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1524 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1526 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1532 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1534 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1544 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1546 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1548 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1552 */	NdrFcShort( 0x422 ),	/* Type Offset=1058 */

	/* Return value */

/* 1554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1560 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x1b ),	/* 27 */
#ifndef _ALPHA_
/* 1568 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1570 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1574 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1576 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1578 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1580 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1582 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1584 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1592 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1608 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1610 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1612 */	NdrFcShort( 0x42a ),	/* Type Offset=1066 */

	/* Return value */

/* 1614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1616 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1620 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1626 */	NdrFcShort( 0x1c ),	/* 28 */
#ifndef _ALPHA_
/* 1628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1630 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1632 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1634 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1640 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1642 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1650 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1652 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1654 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1674 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x1d ),	/* 29 */
#ifndef _ALPHA_
/* 1682 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1684 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1686 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1688 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1694 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1696 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1700 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1704 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1706 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1708 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1716 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1718 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1720 */	NdrFcShort( 0x4b0 ),	/* Type Offset=1200 */

	/* Return value */

/* 1722 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1724 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1728 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1734 */	NdrFcShort( 0x1e ),	/* 30 */
#ifndef _ALPHA_
/* 1736 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 1738 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1740 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1742 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1744 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1746 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1748 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1750 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1752 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1758 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1760 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1762 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1764 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1766 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1772 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1774 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1776 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1778 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1784 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1788 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1790 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1792 */	NdrFcShort( 0x4be ),	/* Type Offset=1214 */

	/* Parameter ElementsRead */

/* 1794 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1796 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1800 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1802 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1808 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1812 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x1f ),	/* 31 */
#ifndef _ALPHA_
/* 1820 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1822 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1824 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1826 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1828 */	NdrFcShort( 0xe ),	/* 14 */
/* 1830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1832 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1834 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1838 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1842 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1844 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1846 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1856 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1858 */	NdrFcShort( 0x4b0 ),	/* Type Offset=1200 */

	/* Parameter ForceFlag */

/* 1860 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1862 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1864 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1868 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1872 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x20 ),	/* 32 */
#ifndef _ALPHA_
/* 1880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1882 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1884 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1886 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1894 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1902 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1904 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1906 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1908 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1912 */	NdrFcShort( 0x4f4 ),	/* Type Offset=1268 */

	/* Return value */

/* 1914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1916 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1920 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1926 */	NdrFcShort( 0x21 ),	/* 33 */
#ifndef _ALPHA_
/* 1928 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1930 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1932 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1934 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1938 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1940 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1942 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1946 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1948 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1952 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1954 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1956 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1958 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1960 */	NdrFcShort( 0x4f4 ),	/* Type Offset=1268 */

	/* Return value */

/* 1962 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1964 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 1968 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1970 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1974 */	NdrFcShort( 0x22 ),	/* 34 */
#ifndef _ALPHA_
/* 1976 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1978 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1982 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1988 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1990 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1992 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1994 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1998 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2000 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2002 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2004 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2006 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2008 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 2010 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2012 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2014 */	NdrFcShort( 0x518 ),	/* Type Offset=1304 */

	/* Return value */

/* 2016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2018 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2022 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2028 */	NdrFcShort( 0x23 ),	/* 35 */
#ifndef _ALPHA_
/* 2030 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 2032 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2034 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2036 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2038 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2040 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2044 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2046 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2050 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2052 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2054 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2056 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2064 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 2066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2070 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2072 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2076 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2078 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2080 */	NdrFcShort( 0x520 ),	/* Type Offset=1312 */

	/* Parameter ClientsRead */

/* 2082 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2084 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2090 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2096 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2100 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2106 */	NdrFcShort( 0x24 ),	/* 36 */
#ifndef _ALPHA_
/* 2108 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2110 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2112 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2114 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2116 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2122 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2130 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2132 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2134 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2136 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2146 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2160 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x25 ),	/* 37 */
#ifndef _ALPHA_
/* 2168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2170 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2172 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2174 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2182 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2192 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2194 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2196 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2200 */	NdrFcShort( 0x55c ),	/* Type Offset=1372 */

	/* Return value */

/* 2202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2208 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x26 ),	/* 38 */
#ifndef _ALPHA_
/* 2216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2218 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2220 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2222 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2230 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2240 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2242 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2244 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2248 */	NdrFcShort( 0x5b2 ),	/* Type Offset=1458 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2256 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x27 ),	/* 39 */
#ifndef _ALPHA_
/* 2264 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2266 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2268 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2270 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2276 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2278 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2284 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2286 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2288 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2290 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2292 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2298 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2302 */	NdrFcShort( 0x5c4 ),	/* Type Offset=1476 */

	/* Return value */

/* 2304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2310 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x28 ),	/* 40 */
#ifndef _ALPHA_
/* 2318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2320 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2322 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2324 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2330 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2332 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2340 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2342 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2344 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2346 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2350 */	NdrFcShort( 0x602 ),	/* Type Offset=1538 */

	/* Return value */

/* 2352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/*  8 */	NdrFcShort( 0x22 ),	/* Offset= 34 (42) */
/* 10 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0xc ),	/* 12 */
/* 14 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 16 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 18 */	NdrFcShort( 0x4 ),	/* 4 */
/* 20 */	NdrFcShort( 0x4 ),	/* 4 */
/* 22 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 24 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 26 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 34 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 36 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0xc ),	/* Offset= 12 (60) */
/* 50 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 52 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 54 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 56 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (10) */
/* 58 */	0xd,		/* FC_ENUM16 */
			0x5b,		/* FC_END */
/* 60 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 66 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 68 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (42) */
/* 76 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 78 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 80 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x12, 0x0,	/* FC_UP */
/* 86 */	NdrFcShort( 0xe ),	/* Offset= 14 (100) */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x4 ),	/* 4 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 98 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x4 ),	/* 4 */
/* 112 */	0x12, 0x0,	/* FC_UP */
/* 114 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (88) */
/* 116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 118 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 120 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 122 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 124 */	
			0x11, 0x0,	/* FC_RP */
/* 126 */	NdrFcShort( 0x78 ),	/* Offset= 120 (246) */
/* 128 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 130 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (138) */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x5 ),	/* 5 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x1c ),	/* Offset= 28 (174) */
/* 148 */	NdrFcLong( 0x1 ),	/* 1 */
/* 152 */	NdrFcShort( 0x22 ),	/* Offset= 34 (186) */
/* 154 */	NdrFcLong( 0x2 ),	/* 2 */
/* 158 */	NdrFcShort( 0x20 ),	/* Offset= 32 (190) */
/* 160 */	NdrFcLong( 0x3 ),	/* 3 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	NdrFcLong( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* Offset= 4 (174) */
/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (178) */
/* 178 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffff4e ),	/* Offset= -178 (10) */
/* 190 */	
			0x12, 0x0,	/* FC_UP */
/* 192 */	NdrFcShort( 0x22 ),	/* Offset= 34 (226) */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x1 ),	/* 1 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 212 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 216 */	NdrFcShort( 0x4 ),	/* 4 */
/* 218 */	0x12, 0x0,	/* FC_UP */
/* 220 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (194) */
/* 222 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 224 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 226 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 232 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 234 */	NdrFcShort( 0x4 ),	/* 4 */
/* 236 */	NdrFcShort( 0x4 ),	/* 4 */
/* 238 */	0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (206) */
/* 242 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 248 */	NdrFcShort( 0x8 ),	/* 8 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x0 ),	/* Offset= 0 (252) */
/* 254 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 256 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff7f ),	/* Offset= -129 (128) */
			0x5b,		/* FC_END */
/* 260 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (264) */
/* 264 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 266 */	NdrFcShort( 0x18 ),	/* Offset= 24 (290) */
/* 268 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 282 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (246) */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 296 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	NdrFcShort( 0x4 ),	/* 4 */
/* 302 */	0x12, 0x0,	/* FC_UP */
/* 304 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (268) */
/* 306 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 308 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 310 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 312 */	NdrFcShort( 0x7a ),	/* Offset= 122 (434) */
/* 314 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 316 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	NdrFcShort( 0x2 ),	/* Offset= 2 (324) */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 334 */	NdrFcLong( 0x1 ),	/* 1 */
/* 338 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 340 */	NdrFcLong( 0x2 ),	/* 2 */
/* 344 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 346 */	NdrFcLong( 0x3 ),	/* 3 */
/* 350 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (178) */
/* 352 */	NdrFcLong( 0x4 ),	/* 4 */
/* 356 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 358 */	NdrFcLong( 0x5 ),	/* 5 */
/* 362 */	NdrFcShort( 0xfffffe98 ),	/* Offset= -360 (2) */
/* 364 */	NdrFcLong( 0x6 ),	/* 6 */
/* 368 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (206) */
/* 370 */	NdrFcLong( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (206) */
/* 376 */	NdrFcShort( 0x0 ),	/* Offset= 0 (376) */
/* 378 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 380 */	NdrFcShort( 0xc ),	/* 12 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* Offset= 0 (384) */
/* 386 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb5 ),	/* Offset= -75 (314) */
			0x5b,		/* FC_END */
/* 392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 406 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (378) */
/* 412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 414 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0x8 ),	/* 8 */
/* 418 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 420 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 424 */	NdrFcShort( 0x4 ),	/* 4 */
/* 426 */	0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (392) */
/* 430 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 434 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 436 */	NdrFcShort( 0x18 ),	/* 24 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0xc ),	/* Offset= 12 (452) */
/* 442 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 444 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 446 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdf ),	/* Offset= -33 (414) */
			0xd,		/* FC_ENUM16 */
/* 450 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 452 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 454 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 456 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 460 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 462 */	NdrFcShort( 0x2 ),	/* Offset= 2 (464) */
/* 464 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 466 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (434) */
/* 468 */	
			0x11, 0x0,	/* FC_RP */
/* 470 */	NdrFcShort( 0x30 ),	/* Offset= 48 (518) */
/* 472 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 474 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 476 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 478 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 480 */	NdrFcShort( 0x2 ),	/* Offset= 2 (482) */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	NdrFcShort( 0x5 ),	/* 5 */
/* 486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* Offset= 0 (490) */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	NdrFcShort( 0x0 ),	/* Offset= 0 (496) */
/* 498 */	NdrFcLong( 0x2 ),	/* 2 */
/* 502 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 504 */	NdrFcLong( 0x3 ),	/* 3 */
/* 508 */	NdrFcShort( 0xfffffeb6 ),	/* Offset= -330 (178) */
/* 510 */	NdrFcLong( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (2) */
/* 516 */	NdrFcShort( 0x0 ),	/* Offset= 0 (516) */
/* 518 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 520 */	NdrFcShort( 0xc ),	/* 12 */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* Offset= 0 (524) */
/* 526 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 528 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (472) */
			0x5b,		/* FC_END */
/* 532 */	
			0x11, 0x0,	/* FC_RP */
/* 534 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (414) */
/* 536 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 538 */	NdrFcShort( 0x2 ),	/* Offset= 2 (540) */
/* 540 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 542 */	NdrFcShort( 0x18 ),	/* Offset= 24 (566) */
/* 544 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 550 */	NdrFcShort( 0x4 ),	/* 4 */
/* 552 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 554 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 558 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (378) */
/* 564 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 566 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 568 */	NdrFcShort( 0xc ),	/* 12 */
/* 570 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 572 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (544) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 586 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 588 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 590 */	NdrFcShort( 0x2 ),	/* Offset= 2 (592) */
/* 592 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 594 */	NdrFcShort( 0x24 ),	/* Offset= 36 (630) */
/* 596 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 598 */	NdrFcShort( 0xc ),	/* 12 */
/* 600 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 606 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 610 */	NdrFcShort( 0xc ),	/* 12 */
/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 618 */	NdrFcShort( 0x8 ),	/* 8 */
/* 620 */	0x12, 0x0,	/* FC_UP */
/* 622 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (544) */
/* 624 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 626 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc3 ),	/* Offset= -61 (566) */
			0x5b,		/* FC_END */
/* 630 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 636 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x4 ),	/* 4 */
/* 642 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 644 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (596) */
/* 646 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 650 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 652 */	NdrFcShort( 0xe ),	/* Offset= 14 (666) */
/* 654 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* 1 */
/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 664 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 666 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 668 */	NdrFcShort( 0x2c ),	/* 44 */
/* 670 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 672 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 674 */	NdrFcShort( 0xc ),	/* 12 */
/* 676 */	NdrFcShort( 0xc ),	/* 12 */
/* 678 */	0x12, 0x0,	/* FC_UP */
/* 680 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (654) */
/* 682 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 686 */	NdrFcShort( 0x10 ),	/* 16 */
/* 688 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 694 */	NdrFcShort( 0x14 ),	/* 20 */
/* 696 */	NdrFcShort( 0x14 ),	/* 20 */
/* 698 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 700 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 702 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 706 */	NdrFcShort( 0x24 ),	/* 36 */
/* 708 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 710 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 712 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 714 */	NdrFcShort( 0x28 ),	/* 40 */
/* 716 */	NdrFcShort( 0x28 ),	/* 40 */
/* 718 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 720 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 724 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 726 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 728 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 730 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdd7 ),	/* Offset= -553 (178) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 734 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd2b ),	/* Offset= -725 (10) */
			0x5b,		/* FC_END */
/* 738 */	
			0x11, 0x0,	/* FC_RP */
/* 740 */	NdrFcShort( 0x24 ),	/* Offset= 36 (776) */
/* 742 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 744 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 746 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 748 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 750 */	NdrFcShort( 0x2 ),	/* Offset= 2 (752) */
/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 754 */	NdrFcShort( 0x3 ),	/* 3 */
/* 756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 762 */	NdrFcLong( 0x1 ),	/* 1 */
/* 766 */	NdrFcShort( 0xfffffdd0 ),	/* Offset= -560 (206) */
/* 768 */	NdrFcLong( 0x2 ),	/* 2 */
/* 772 */	NdrFcShort( 0xfffffcfe ),	/* Offset= -770 (2) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 778 */	NdrFcShort( 0xc ),	/* 12 */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x0 ),	/* Offset= 0 (782) */
/* 784 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 786 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (742) */
			0x5b,		/* FC_END */
/* 790 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 792 */	NdrFcShort( 0x2 ),	/* Offset= 2 (794) */
/* 794 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 796 */	NdrFcShort( 0xffffff7e ),	/* Offset= -130 (666) */
/* 798 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 800 */	NdrFcShort( 0x2 ),	/* Offset= 2 (802) */
/* 802 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 804 */	NdrFcShort( 0x22 ),	/* Offset= 34 (838) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 808 */	NdrFcShort( 0x4 ),	/* 4 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 818 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 820 */	NdrFcShort( 0x4 ),	/* 4 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* 1 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 832 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (666) */
/* 834 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 836 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 838 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 840 */	NdrFcShort( 0x8 ),	/* 8 */
/* 842 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 846 */	NdrFcShort( 0x4 ),	/* 4 */
/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
/* 850 */	0x12, 0x0,	/* FC_UP */
/* 852 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (806) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 858 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 860 */	NdrFcShort( 0x2 ),	/* Offset= 2 (862) */
/* 862 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 864 */	NdrFcShort( 0x2 ),	/* Offset= 2 (866) */
/* 866 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 868 */	NdrFcShort( 0x8 ),	/* 8 */
/* 870 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 872 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 874 */	NdrFcShort( 0x4 ),	/* 4 */
/* 876 */	NdrFcShort( 0x4 ),	/* 4 */
/* 878 */	0x12, 0x0,	/* FC_UP */
/* 880 */	NdrFcShort( 0xfffffee4 ),	/* Offset= -284 (596) */
/* 882 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 886 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 888 */	NdrFcShort( 0x2 ),	/* Offset= 2 (890) */
/* 890 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 892 */	NdrFcShort( 0x1c ),	/* Offset= 28 (920) */
/* 894 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 896 */	NdrFcShort( 0x10 ),	/* 16 */
/* 898 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 900 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 902 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 904 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 906 */	NdrFcShort( 0x10 ),	/* 16 */
/* 908 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 910 */	NdrFcShort( 0x24 ),	/* 36 */
/* 912 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 914 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 916 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (894) */
/* 918 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 920 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 922 */	NdrFcShort( 0x2c ),	/* 44 */
/* 924 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 926 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 928 */	NdrFcShort( 0x28 ),	/* 40 */
/* 930 */	NdrFcShort( 0x28 ),	/* 40 */
/* 932 */	0x12, 0x0,	/* FC_UP */
/* 934 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (904) */
/* 936 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 938 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 940 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 942 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 944 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 946 */	NdrFcShort( 0xfffffd00 ),	/* Offset= -768 (178) */
/* 948 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 954 */	NdrFcShort( 0x2 ),	/* Offset= 2 (956) */
/* 956 */	
			0x12, 0x0,	/* FC_UP */
/* 958 */	NdrFcShort( 0x18 ),	/* Offset= 24 (982) */
/* 960 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 964 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 970 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 974 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 976 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 978 */	NdrFcShort( 0xfffffde0 ),	/* Offset= -544 (434) */
/* 980 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 982 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 984 */	NdrFcShort( 0x8 ),	/* 8 */
/* 986 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 988 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 990 */	NdrFcShort( 0x4 ),	/* 4 */
/* 992 */	NdrFcShort( 0x4 ),	/* 4 */
/* 994 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 996 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (960) */
/* 998 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1000 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1002 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 1004 */	NdrFcShort( 0xfffffe8a ),	/* Offset= -374 (630) */
/* 1006 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 1008 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1010) */
/* 1010 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1012 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1014 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1016 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1018 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1020 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1022 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1024 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1026 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1030 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1032 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1034 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1036 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1038 */	NdrFcShort( 0xc ),	/* 12 */
/* 1040 */	NdrFcShort( 0xc ),	/* 12 */
/* 1042 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1044 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1046 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1048 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1050 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1052 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1054 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1056 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1058 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1060 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1062) */
/* 1062 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 1064 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (1010) */
/* 1066 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1068 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1070) */
/* 1070 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 1072 */	NdrFcShort( 0x24 ),	/* Offset= 36 (1108) */
/* 1074 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1076 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1080 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1080) */
/* 1082 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1092 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1094 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1096 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1100 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1102 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1104 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1074) */
/* 1106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1108 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1110 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1112 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1114 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1116 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1120 */	0x12, 0x0,	/* FC_UP */
/* 1122 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1086) */
/* 1124 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1126 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1128 */	
			0x11, 0x0,	/* FC_RP */
/* 1130 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1200) */
/* 1132 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 1134 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1136 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1138 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1140 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1142) */
/* 1142 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1144 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0xfffffc30 ),	/* Offset= -976 (174) */
/* 1152 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1156 */	NdrFcShort( 0xfffffc36 ),	/* Offset= -970 (186) */
/* 1158 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1162 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1178) */
/* 1164 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1168 */	NdrFcShort( 0xfffffc1e ),	/* Offset= -994 (174) */
/* 1170 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1174 */	NdrFcShort( 0xfffffc18 ),	/* Offset= -1000 (174) */
/* 1176 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1176) */
/* 1178 */	
			0x12, 0x0,	/* FC_UP */
/* 1180 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1182) */
/* 1182 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1184 */	NdrFcShort( 0xc ),	/* 12 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1196) */
/* 1190 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1192 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1194 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1196 */	
			0x12, 0x0,	/* FC_UP */
/* 1198 */	NdrFcShort( 0xfffffc20 ),	/* Offset= -992 (206) */
/* 1200 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1206) */
/* 1208 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1210 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb1 ),	/* Offset= -79 (1132) */
			0x5b,		/* FC_END */
/* 1214 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1216 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1218) */
/* 1218 */	
			0x12, 0x0,	/* FC_UP */
/* 1220 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1244) */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1200) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1248 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1252 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1256 */	0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1262 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1268) */
/* 1268 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1270 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1274 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1296) */
/* 1276 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1280 */	NdrFcShort( 0xfffffbce ),	/* Offset= -1074 (206) */
/* 1282 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1286 */	NdrFcShort( 0xfffffbac ),	/* Offset= -1108 (178) */
/* 1288 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1290 */	NdrFcShort( 0xfffffb00 ),	/* Offset= -1280 (10) */
/* 1292 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1294 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1296 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1298 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1300 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1302 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1304 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1306 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1308) */
/* 1308 */	
			0x12, 0x0,	/* FC_UP */
/* 1310 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1268) */
/* 1312 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1314 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1316) */
/* 1316 */	
			0x12, 0x0,	/* FC_UP */
/* 1318 */	NdrFcShort( 0x22 ),	/* Offset= 34 (1352) */
/* 1320 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1322 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1324 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1328 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1330 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1332 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1334 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1344 */	0x12, 0x0,	/* FC_UP */
/* 1346 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (1268) */
/* 1348 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1352 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1354 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1356 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1358 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1360 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1362 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1364 */	0x12, 0x0,	/* FC_UP */
/* 1366 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1320) */
/* 1368 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1370 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1372 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1374 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1376) */
/* 1376 */	
			0x12, 0x0,	/* FC_UP */
/* 1378 */	NdrFcShort( 0x3a ),	/* Offset= 58 (1436) */
/* 1380 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1382 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1384 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1386 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1388 */	NdrFcShort( 0xc ),	/* 12 */
/* 1390 */	NdrFcShort( 0xc ),	/* 12 */
/* 1392 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1394 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1396 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1398 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1400 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1402 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1404 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1406 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1412 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1414 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1416 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1422 */	NdrFcShort( 0xc ),	/* 12 */
/* 1424 */	NdrFcShort( 0xc ),	/* 12 */
/* 1426 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1428 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1430 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1432 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcb ),	/* Offset= -53 (1380) */
			0x5b,		/* FC_END */
/* 1436 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1438 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1440 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1442 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1444 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1446 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1448 */	0x12, 0x0,	/* FC_UP */
/* 1450 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1402) */
/* 1452 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1454 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1456 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1460 */	
			0x11, 0x0,	/* FC_RP */
/* 1462 */	NdrFcShort( 0xe ),	/* Offset= 14 (1476) */
/* 1464 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1466 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1468 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1470 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1472 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1474 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1476 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1478 */	NdrFcShort( 0x34 ),	/* 52 */
/* 1480 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1482 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1484 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1486 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1488 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1490 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1492 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1494 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1496 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1498 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1500 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1502 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1504 */	NdrFcShort( 0xc ),	/* 12 */
/* 1506 */	NdrFcShort( 0xc ),	/* 12 */
/* 1508 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1510 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1512 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1514 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1516 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1518 */	0x12, 0x0,	/* FC_UP */
/* 1520 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1464) */
/* 1522 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1524 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1530 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1532 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1534 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1536 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1538 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1540 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1542) */
/* 1542 */	
			0x12, 0x0,	/* FC_UP */
/* 1544 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (1476) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)DHCP_SRV_HANDLE_bind,
            (GENERIC_UNBIND_ROUTINE)DHCP_SRV_HANDLE_unbind
         }
        
        };


static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    54,
    108,
    162,
    234,
    288,
    372,
    432,
    486,
    540,
    594,
    648,
    696,
    756,
    816,
    894,
    948,
    996,
    1044,
    1098,
    1146,
    1224,
    1284,
    1332,
    1404,
    1458,
    1512,
    1560,
    1620,
    1674,
    1728,
    1812,
    1872,
    1920,
    1968,
    2022,
    2100,
    2160,
    2208,
    2256,
    2310
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &dhcpsrv_bhandle,
    0,
    BindingRoutines,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_cli.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#if defined( _ALPHA_ )
#include <stdarg.h>
#endif

#include "dhcp_cli.h"

#define TYPE_FORMAT_STRING_SIZE   1331                              
#define PROC_FORMAT_STRING_SIZE   2441                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */

handle_t dhcpsrv_bhandle;


static const RPC_CLIENT_INTERFACE dhcpsrv___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE dhcpsrv_ClientIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcClientInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

static RPC_BINDING_HANDLE dhcpsrv__MIDL_AutoBindHandle;


DWORD R_DhcpCreateSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[56],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[56],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out] */ LPDHCP_SUBNET_INFO __RPC_FAR *SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  ServerIpAddress,
                  SubnetAddress,
                  SubnetInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnets( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_IP_ARRAY __RPC_FAR *EnumInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  ServerIpAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[242],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[242],
                  ServerIpAddress,
                  SubnetAddress,
                  AddElementInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElements( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[298],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[298],
                  ServerIpAddress,
                  SubnetAddress,
                  EnumElementType,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumElementInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[384],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[384],
                  ServerIpAddress,
                  SubnetAddress,
                  RemoveElementInfo,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[446],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[446],
                  ServerIpAddress,
                  SubnetAddress,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[502],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[502],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[558],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[558],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [out] */ LPDHCP_OPTION __RPC_FAR *OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[614],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[614],
                  ServerIpAddress,
                  OptionID,
                  OptionInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionID);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[670],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[670],
                  ServerIpAddress,
                  OptionID);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_DATA OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[720],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[720],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo,
                  OptionValue);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out] */ LPDHCP_OPTION_VALUE __RPC_FAR *OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[782],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[782],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo,
                  OptionValue);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_VALUE_ARRAY __RPC_FAR *OptionValues,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[844],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[844],
                  ServerIpAddress,
                  ScopeInfo,
                  ResumeHandle,
                  PreferredMaximum,
                  OptionValues,
                  OptionsRead,
                  OptionsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScopeInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[924],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[924],
                  ServerIpAddress,
                  OptionID,
                  ScopeInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[980],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[980],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1030],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1030],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1080],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1080],
                  ServerIpAddress,
                  SearchInfo,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1136],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1136],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClients( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1186],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1186],
                  ServerIpAddress,
                  SubnetAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  ClientInfo,
                  ClientsRead,
                  ClientsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS ClientIpAddress,
    /* [in] */ DHCP_IP_MASK ClientSubnetMask,
    /* [out] */ LPDHCP_OPTION_LIST __RPC_FAR *ClientOptions)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientOptions);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1266],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1266],
                  ServerIpAddress,
                  ClientIpAddress,
                  ClientSubnetMask,
                  ClientOptions);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetMibInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_MIB_INFO __RPC_FAR *MibInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MibInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1328],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1328],
                  ServerIpAddress,
                  MibInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_ARRAY __RPC_FAR *Options,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1378],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1378],
                  ServerIpAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  Options,
                  OptionsRead,
                  OptionsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_VALUE_ARRAY OptionValues)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValues);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1452],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1452],
                  ServerIpAddress,
                  ScopeInfo,
                  OptionValues);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1508],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1508],
                  ServerIpAddress,
                  FieldsToSet,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1564],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1564],
                  ServerIpAddress,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpScanDatabase( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DWORD FixFlag,
    /* [out] */ LPDHCP_SCAN_LIST __RPC_FAR *ScanList)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScanList);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1614],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1614],
                  ServerIpAddress,
                  SubnetAddress,
                  FixFlag,
                  ScanList);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetVersion( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDWORD MajorVersion,
    /* [out] */ LPDWORD MinorVersion)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MinorVersion);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1676],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1676],
                  ServerIpAddress,
                  MajorVersion,
                  MinorVersion);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1732],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1732],
                  ServerIpAddress,
                  SubnetAddress,
                  AddElementInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElementsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1788],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1788],
                  ServerIpAddress,
                  SubnetAddress,
                  EnumElementType,
                  ResumeHandle,
                  PreferredMaximum,
                  EnumElementInfo,
                  ElementsRead,
                  ElementsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1874],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1874],
                  ServerIpAddress,
                  SubnetAddress,
                  RemoveElementInfo,
                  ForceFlag);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1936],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1936],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1986],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1986],
                  ServerIpAddress,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO_V4 __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2036],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2036],
                  ServerIpAddress,
                  SearchInfo,
                  ClientInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClientsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY_V4 __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2092],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2092],
                  ServerIpAddress,
                  SubnetAddress,
                  ResumeHandle,
                  PreferredMaximum,
                  ClientInfo,
                  ClientsRead,
                  ClientsTotal);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [string][unique][in] */ WCHAR __RPC_FAR *SuperScopeName,
    /* [in] */ BOOL ChangeExisting)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ChangeExisting);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2172],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2172],
                  ServerIpAddress,
                  SubnetAddress,
                  SuperScopeName,
                  ChangeExisting);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSuperScopeInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SUPER_SCOPE_TABLE __RPC_FAR *SuperScopeTable)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeTable);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2234],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2234],
                  ServerIpAddress,
                  SuperScopeTable);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [string][ref][in] */ WCHAR __RPC_FAR *SuperScopeName)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeName);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2284],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2284],
                  ServerIpAddress,
                  SuperScopeName);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2334],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2334],
                  ServerIpAddress,
                  FieldsToSet,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO_V4 __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2390],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2390],
                  ServerIpAddress,
                  ConfigInfo);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];
extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 38 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 48 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 56 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
/* 64 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 66 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 68 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 70 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 100 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 102 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 104 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 134 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 156 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 160 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 178 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 180 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 182 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 184 */	NdrFcShort( 0x24 ),	/* 36 */
/* 186 */	NdrFcShort( 0x5c ),	/* 92 */
/* 188 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 190 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 192 */	NdrFcShort( 0x1 ),	/* 1 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 202 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 204 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 206 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 212 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 218 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 222 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Parameter ElementsRead */

/* 224 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 230 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 242 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 250 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 252 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 254 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 256 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 264 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 274 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 276 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 278 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 280 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 282 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 286 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 288 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 290 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 298 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x5 ),	/* 5 */
/* 306 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 308 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 310 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 312 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 314 */	NdrFcShort( 0x32 ),	/* 50 */
/* 316 */	NdrFcShort( 0x5c ),	/* 92 */
/* 318 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 320 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 322 */	NdrFcShort( 0x3 ),	/* 3 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 330 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 332 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 334 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 346 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 348 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 360 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 362 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 364 */	NdrFcShort( 0xf2 ),	/* Type Offset=242 */

	/* Parameter ElementsRead */

/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 372 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 374 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 384 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x6 ),	/* 6 */
/* 392 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 394 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 398 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 400 */	NdrFcShort( 0xe ),	/* 14 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 406 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x2 ),	/* 2 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 416 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 418 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 420 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 424 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 428 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 430 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 432 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Parameter ForceFlag */

/* 434 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 436 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 438 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 442 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 446 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x7 ),	/* 7 */
/* 454 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 456 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 458 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 460 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 462 */	NdrFcShort( 0xe ),	/* 14 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 478 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 480 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 482 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 486 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 492 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 494 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 498 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 502 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 512 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 514 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 516 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 522 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 524 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x4 ),	/* 4 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 534 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 536 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 538 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 544 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 546 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 548 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 550 */	NdrFcShort( 0x120 ),	/* Type Offset=288 */

	/* Return value */

/* 552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 558 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x9 ),	/* 9 */
/* 566 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 568 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 570 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 572 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 580 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x4 ),	/* 4 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 592 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 598 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 602 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 604 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 606 */	NdrFcShort( 0x120 ),	/* Type Offset=288 */

	/* Return value */

/* 608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 610 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0xa ),	/* 10 */
/* 622 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 658 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 662 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Return value */

/* 664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 670 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0xb ),	/* 11 */
/* 678 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 680 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 682 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 684 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 690 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 692 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 704 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 706 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 710 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 716 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 720 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 726 */	NdrFcShort( 0xc ),	/* 12 */
/* 728 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 730 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 732 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 734 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 736 */	NdrFcShort( 0x8 ),	/* 8 */
/* 738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 740 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 742 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x5 ),	/* 5 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 752 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 754 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 756 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 760 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 764 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 766 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 768 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 770 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 772 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 774 */	NdrFcShort( 0x18a ),	/* Type Offset=394 */

	/* Return value */

/* 776 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 778 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 782 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0xd ),	/* 13 */
/* 790 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 792 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 794 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 796 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 802 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 804 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 806 */	NdrFcShort( 0x4 ),	/* 4 */
/* 808 */	NdrFcShort( 0x1 ),	/* 1 */
/* 810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 814 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 816 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 818 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 822 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 826 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 828 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 830 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 832 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 834 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 836 */	NdrFcShort( 0x204 ),	/* Type Offset=516 */

	/* Return value */

/* 838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 840 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 844 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 850 */	NdrFcShort( 0xe ),	/* 14 */
/* 852 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 854 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 856 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 858 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 860 */	NdrFcShort( 0x24 ),	/* 36 */
/* 862 */	NdrFcShort( 0x5c ),	/* 92 */
/* 864 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 866 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 868 */	NdrFcShort( 0x5 ),	/* 5 */
/* 870 */	NdrFcShort( 0x1 ),	/* 1 */
/* 872 */	NdrFcShort( 0x0 ),	/* 0 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 878 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 880 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 882 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 884 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 886 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter ResumeHandle */

/* 888 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 890 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 894 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 896 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 900 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 902 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 904 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter OptionsRead */

/* 906 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 908 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 924 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0xf ),	/* 15 */
/* 932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 934 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 936 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 938 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 946 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x1 ),	/* 1 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 960 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 962 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 964 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 968 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 970 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 972 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Return value */

/* 974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 976 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 980 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 990 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 992 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 994 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1000 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1002 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1012 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1014 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1016 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1020 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1022 */	NdrFcShort( 0x24a ),	/* Type Offset=586 */

	/* Return value */

/* 1024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1026 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 1030 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1038 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1040 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1042 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1044 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1052 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1062 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1064 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1066 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1070 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1072 */	NdrFcShort( 0x24a ),	/* Type Offset=586 */

	/* Return value */

/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1076 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1080 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1088 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1090 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1092 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1094 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1102 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1104 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1106 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1112 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1114 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1116 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1118 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1120 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1122 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 1124 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1126 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1128 */	NdrFcShort( 0x2a6 ),	/* Type Offset=678 */

	/* Return value */

/* 1130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1132 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1136 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1146 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1148 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1150 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1156 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1158 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1170 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1172 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1174 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1176 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1178 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1182 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1186 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1194 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1196 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1198 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1200 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1202 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1204 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1206 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1208 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1210 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1222 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1224 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1226 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1230 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1232 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1238 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1242 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1246 */	NdrFcShort( 0x2ae ),	/* Type Offset=686 */

	/* Parameter ClientsRead */

/* 1248 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1250 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1254 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1256 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1262 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1266 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1274 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1276 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1278 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1280 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1282 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1288 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1290 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1298 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1300 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1302 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1306 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1312 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1316 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1318 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1320 */	NdrFcShort( 0x2dc ),	/* Type Offset=732 */

	/* Return value */

/* 1322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1324 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1328 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1334 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1336 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1338 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1340 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1342 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1348 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1350 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1352 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1362 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1364 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1366 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1370 */	NdrFcShort( 0x2f4 ),	/* Type Offset=756 */

	/* Return value */

/* 1372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1374 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1378 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1386 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1388 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1390 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1392 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1394 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1396 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1398 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1400 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1402 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1414 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1416 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1418 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1430 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1432 */	NdrFcShort( 0x330 ),	/* Type Offset=816 */

	/* Parameter OptionsRead */

/* 1434 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1436 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1440 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1442 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1448 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1452 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1458 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1460 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1462 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1464 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1466 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1474 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1478 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1484 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1486 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1488 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1490 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1492 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1494 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValues */

/* 1496 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1498 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x35e ),	/* Type Offset=862 */

	/* Return value */

/* 1502 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1504 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1508 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1510 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1514 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1518 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1520 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1522 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1528 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1530 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1544 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1548 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1552 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1554 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1556 */	NdrFcShort( 0x362 ),	/* Type Offset=866 */

	/* Return value */

/* 1558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1560 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1564 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1570 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1572 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1574 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1576 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1578 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1584 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1586 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1596 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1598 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1600 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1602 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1604 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1606 */	NdrFcShort( 0x386 ),	/* Type Offset=902 */

	/* Return value */

/* 1608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1610 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1620 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1622 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1630 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1638 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1658 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1664 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1668 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1676 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1684 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1686 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1688 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1690 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1692 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1694 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1696 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1698 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1708 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1710 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1712 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1714 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1716 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1720 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1722 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1728 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1732 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1738 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1740 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1742 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1744 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1746 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1752 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1754 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1766 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1768 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1772 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1776 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1778 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1780 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Return value */

/* 1782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1784 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1788 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1794 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1796 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 1798 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1800 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1802 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1804 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1806 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1808 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1810 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1812 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1820 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1822 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1824 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1826 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1828 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1834 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1836 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1838 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1840 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1844 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1846 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1850 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1852 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1854 */	NdrFcShort( 0x420 ),	/* Type Offset=1056 */

	/* Parameter ElementsRead */

/* 1856 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1858 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1862 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1864 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1870 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1874 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1882 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1884 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1886 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1888 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1890 */	NdrFcShort( 0xe ),	/* 14 */
/* 1892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1894 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1896 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1906 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1908 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1910 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1914 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1920 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1922 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Parameter ForceFlag */

/* 1924 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1926 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1928 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1936 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1946 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1948 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1950 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1958 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1968 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1970 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1972 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1974 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1976 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1978 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 1980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1982 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1986 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1992 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1994 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1996 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1998 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2000 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2008 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2020 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2022 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 2024 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2026 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2028 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 2030 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2032 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 2036 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2044 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2046 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2048 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2050 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2056 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2058 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2060 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2062 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2066 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2070 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2072 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2076 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2078 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 2080 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2082 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2084 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2092 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2100 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 2102 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2104 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2106 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2108 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2110 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2112 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2114 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2122 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2124 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2126 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2128 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2130 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2132 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2138 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2142 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2148 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2150 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2152 */	NdrFcShort( 0x47e ),	/* Type Offset=1150 */

	/* Parameter ClientsRead */

/* 2154 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2156 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2162 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2168 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2172 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2180 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2182 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2184 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2186 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2188 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2192 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2204 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2206 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2208 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2210 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2212 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2216 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2218 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2220 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2224 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2230 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x25 ),	/* 37 */
/* 2242 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2244 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2246 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2254 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2256 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2258 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2264 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2268 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2270 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2276 */	NdrFcShort( 0x4ac ),	/* Type Offset=1196 */

	/* Return value */

/* 2278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2280 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x26 ),	/* 38 */
/* 2292 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2294 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2296 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2304 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2316 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2318 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2320 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2322 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2324 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2326 */	NdrFcShort( 0x4ee ),	/* Type Offset=1262 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2330 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2334 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2342 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2344 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2346 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2348 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2354 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2356 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2360 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2366 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2368 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2370 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2374 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2380 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2382 */	NdrFcShort( 0x500 ),	/* Type Offset=1280 */

	/* Return value */

/* 2384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2386 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2390 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2396 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2398 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2400 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2402 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2404 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2412 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2422 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2424 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2426 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2430 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2432 */	NdrFcShort( 0x52a ),	/* Type Offset=1322 */

	/* Return value */

/* 2434 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2436 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/*  8 */	NdrFcShort( 0x18 ),	/* Offset= 24 (32) */
/* 10 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0x18 ),	/* 24 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* Offset= 8 (24) */
/* 18 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 20 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 22 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 24 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 26 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 30 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x38 ),	/* 56 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xe ),	/* Offset= 14 (52) */
/* 40 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 42 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 44 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 46 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (10) */
/* 48 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 50 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 52 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 54 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 56 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 58 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 60 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 66 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (32) */
/* 68 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 70 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x12, 0x0,	/* FC_UP */
/* 78 */	NdrFcShort( 0xe ),	/* Offset= 14 (92) */
/* 80 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 82 */	NdrFcShort( 0x4 ),	/* 4 */
/* 84 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 94 */	NdrFcShort( 0x10 ),	/* 16 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x6 ),	/* Offset= 6 (104) */
/* 100 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 102 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 104 */	
			0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (80) */
/* 108 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 110 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x11, 0x0,	/* FC_RP */
/* 114 */	NdrFcShort( 0x70 ),	/* Offset= 112 (226) */
/* 116 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 118 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x5 ),	/* 5 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1c ),	/* Offset= 28 (162) */
/* 136 */	NdrFcLong( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x22 ),	/* Offset= 34 (174) */
/* 142 */	NdrFcLong( 0x2 ),	/* 2 */
/* 146 */	NdrFcShort( 0x20 ),	/* Offset= 32 (178) */
/* 148 */	NdrFcLong( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0xa ),	/* Offset= 10 (162) */
/* 154 */	NdrFcLong( 0x4 ),	/* 4 */
/* 158 */	NdrFcShort( 0x4 ),	/* Offset= 4 (162) */
/* 160 */	NdrFcShort( 0x0 ),	/* Offset= 0 (160) */
/* 162 */	
			0x12, 0x0,	/* FC_UP */
/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
/* 166 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 170 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 172 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (10) */
/* 178 */	
			0x12, 0x0,	/* FC_UP */
/* 180 */	NdrFcShort( 0x1e ),	/* Offset= 30 (210) */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 194 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x10 ),	/* 16 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x6 ),	/* Offset= 6 (206) */
/* 202 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 204 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 206 */	
			0x12, 0x0,	/* FC_UP */
/* 208 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (182) */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0x6 ),	/* Offset= 6 (222) */
/* 218 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 220 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 222 */	
			0x12, 0x0,	/* FC_UP */
/* 224 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (194) */
/* 226 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x0 ),	/* Offset= 0 (232) */
/* 234 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 236 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 238 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (116) */
/* 240 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 242 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 244 */	NdrFcShort( 0x2 ),	/* Offset= 2 (246) */
/* 246 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 248 */	NdrFcShort( 0x18 ),	/* Offset= 24 (272) */
/* 250 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 254 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 260 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 264 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 266 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (226) */
/* 270 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 272 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 274 */	NdrFcShort( 0x10 ),	/* 16 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x6 ),	/* Offset= 6 (284) */
/* 280 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 282 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (250) */
/* 288 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 290 */	NdrFcShort( 0x78 ),	/* Offset= 120 (410) */
/* 292 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 294 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	NdrFcShort( 0x2 ),	/* Offset= 2 (302) */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 318 */	NdrFcLong( 0x2 ),	/* 2 */
/* 322 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 324 */	NdrFcLong( 0x3 ),	/* 3 */
/* 328 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (166) */
/* 330 */	NdrFcLong( 0x4 ),	/* 4 */
/* 334 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 336 */	NdrFcLong( 0x5 ),	/* 5 */
/* 340 */	NdrFcShort( 0xfffffeae ),	/* Offset= -338 (2) */
/* 342 */	NdrFcLong( 0x6 ),	/* 6 */
/* 346 */	NdrFcShort( 0xffffff68 ),	/* Offset= -152 (194) */
/* 348 */	NdrFcLong( 0x7 ),	/* 7 */
/* 352 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (194) */
/* 354 */	NdrFcShort( 0x0 ),	/* Offset= 0 (354) */
/* 356 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 358 */	NdrFcShort( 0x18 ),	/* 24 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* Offset= 0 (362) */
/* 364 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (292) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 386 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (356) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x6 ),	/* Offset= 6 (406) */
/* 402 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 404 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (372) */
/* 410 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x30 ),	/* 48 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	NdrFcShort( 0xe ),	/* Offset= 14 (430) */
/* 418 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 420 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 428 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 430 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 432 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 438 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (442) */
/* 442 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 444 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (410) */
/* 446 */	
			0x11, 0x0,	/* FC_RP */
/* 448 */	NdrFcShort( 0x30 ),	/* Offset= 48 (496) */
/* 450 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 452 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 454 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 456 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (460) */
/* 460 */	NdrFcShort( 0x8 ),	/* 8 */
/* 462 */	NdrFcShort( 0x5 ),	/* 5 */
/* 464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x0 ),	/* Offset= 0 (468) */
/* 470 */	NdrFcLong( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* Offset= 0 (474) */
/* 476 */	NdrFcLong( 0x2 ),	/* 2 */
/* 480 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 482 */	NdrFcLong( 0x3 ),	/* 3 */
/* 486 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (166) */
/* 488 */	NdrFcLong( 0x4 ),	/* 4 */
/* 492 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (2) */
/* 494 */	NdrFcShort( 0x0 ),	/* Offset= 0 (494) */
/* 496 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 498 */	NdrFcShort( 0x10 ),	/* 16 */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x0 ),	/* Offset= 0 (502) */
/* 504 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 508 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (450) */
/* 510 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 512 */	
			0x11, 0x0,	/* FC_RP */
/* 514 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (394) */
/* 516 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 518 */	NdrFcShort( 0x2 ),	/* Offset= 2 (520) */
/* 520 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 522 */	NdrFcShort( 0x2 ),	/* Offset= 2 (524) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0x18 ),	/* 24 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* Offset= 0 (530) */
/* 532 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (394) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 546 */	NdrFcShort( 0x18 ),	/* Offset= 24 (570) */
/* 548 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 566 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (524) */
/* 568 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 570 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x10 ),	/* 16 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x6 ),	/* Offset= 6 (582) */
/* 578 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 580 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 582 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 584 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (548) */
/* 586 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (590) */
/* 590 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 592 */	NdrFcShort( 0x48 ),	/* 72 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x14 ),	/* Offset= 20 (616) */
/* 598 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 602 */	NdrFcShort( 0xfffffe68 ),	/* Offset= -408 (194) */
/* 604 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 606 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 608 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (166) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (10) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 618 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 620 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 622 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x24 ),	/* Offset= 36 (662) */
/* 628 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 630 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 632 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 634 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	NdrFcShort( 0x10 ),	/* 16 */
/* 640 */	NdrFcShort( 0x3 ),	/* 3 */
/* 642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 648 */	NdrFcLong( 0x1 ),	/* 1 */
/* 652 */	NdrFcShort( 0xfffffe36 ),	/* Offset= -458 (194) */
/* 654 */	NdrFcLong( 0x2 ),	/* 2 */
/* 658 */	NdrFcShort( 0xfffffd70 ),	/* Offset= -656 (2) */
/* 660 */	NdrFcShort( 0x0 ),	/* Offset= 0 (660) */
/* 662 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 664 */	NdrFcShort( 0x18 ),	/* 24 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (628) */
/* 676 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 678 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 680 */	NdrFcShort( 0x2 ),	/* Offset= 2 (682) */
/* 682 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 684 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (590) */
/* 686 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 688 */	NdrFcShort( 0x2 ),	/* Offset= 2 (690) */
/* 690 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 692 */	NdrFcShort( 0x18 ),	/* Offset= 24 (716) */
/* 694 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 704 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 708 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 710 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 712 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (590) */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 718 */	NdrFcShort( 0x10 ),	/* 16 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* Offset= 6 (728) */
/* 724 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x0,	/* FC_UP */
/* 730 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (694) */
/* 732 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 738 */	NdrFcShort( 0x2 ),	/* Offset= 2 (740) */
/* 740 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 742 */	NdrFcShort( 0x10 ),	/* 16 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x6 ),	/* Offset= 6 (752) */
/* 748 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x12, 0x0,	/* FC_UP */
/* 754 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (548) */
/* 756 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 758 */	NdrFcShort( 0x2 ),	/* Offset= 2 (760) */
/* 760 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 762 */	NdrFcShort( 0x1c ),	/* Offset= 28 (790) */
/* 764 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 766 */	NdrFcShort( 0x10 ),	/* 16 */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x10 ),	/* 16 */
/* 778 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 780 */	NdrFcShort( 0x24 ),	/* 36 */
/* 782 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (764) */
/* 788 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x30 ),	/* 48 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x10 ),	/* Offset= 16 (812) */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 802 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd7f ),	/* Offset= -641 (166) */
			0x8,		/* FC_LONG */
/* 810 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 812 */	
			0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (774) */
/* 816 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 818 */	NdrFcShort( 0x2 ),	/* Offset= 2 (820) */
/* 820 */	
			0x12, 0x0,	/* FC_UP */
/* 822 */	NdrFcShort( 0x18 ),	/* Offset= 24 (846) */
/* 824 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 834 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 838 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 840 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 842 */	NdrFcShort( 0xfffffe50 ),	/* Offset= -432 (410) */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x6 ),	/* Offset= 6 (858) */
/* 854 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 856 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 858 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 860 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (824) */
/* 862 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 864 */	NdrFcShort( 0xfffffeda ),	/* Offset= -294 (570) */
/* 866 */	
			0x11, 0x1,	/* FC_RP [all_nodes] */
/* 868 */	NdrFcShort( 0x2 ),	/* Offset= 2 (870) */
/* 870 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 872 */	NdrFcShort( 0x38 ),	/* 56 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0xe ),	/* Offset= 14 (890) */
/* 878 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 880 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 882 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 886 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 888 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 890 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 892 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 904 */	NdrFcShort( 0x2 ),	/* Offset= 2 (906) */
/* 906 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 908 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (870) */
/* 910 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 912 */	NdrFcShort( 0x2 ),	/* Offset= 2 (914) */
/* 914 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 916 */	NdrFcShort( 0x24 ),	/* Offset= 36 (952) */
/* 918 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x0 ),	/* Offset= 0 (924) */
/* 926 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 940 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 944 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 946 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 948 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (918) */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 958 */	NdrFcShort( 0x6 ),	/* Offset= 6 (964) */
/* 960 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 962 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 964 */	
			0x12, 0x0,	/* FC_UP */
/* 966 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (930) */
/* 968 */	
			0x11, 0x0,	/* FC_RP */
/* 970 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1040) */
/* 972 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 974 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x5 ),	/* 5 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (162) */
/* 992 */	NdrFcLong( 0x1 ),	/* 1 */
/* 996 */	NdrFcShort( 0xfffffcca ),	/* Offset= -822 (174) */
/* 998 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1002 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1018) */
/* 1004 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1008 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (162) */
/* 1010 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1014 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (162) */
/* 1016 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1016) */
/* 1018 */	
			0x12, 0x0,	/* FC_UP */
/* 1020 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1022) */
/* 1022 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1024 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1036) */
/* 1030 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1032 */	0x36,		/* FC_POINTER */
			0x2,		/* FC_CHAR */
/* 1034 */	0x43,		/* FC_STRUCTPAD7 */
			0x5b,		/* FC_END */
/* 1036 */	
			0x12, 0x0,	/* FC_UP */
/* 1038 */	NdrFcShort( 0xfffffcb4 ),	/* Offset= -844 (194) */
/* 1040 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1046) */
/* 1048 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 1050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1052 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (972) */
/* 1054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1056 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x12, 0x0,	/* FC_UP */
/* 1062 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1086) */
/* 1064 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1074 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1078 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1080 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1082 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1040) */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1098) */
/* 1094 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1096 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1098 */	
			0x12, 0x0,	/* FC_UP */
/* 1100 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1064) */
/* 1102 */	
			0x11, 0x0,	/* FC_RP */
/* 1104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1106) */
/* 1106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1108 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1134) */
/* 1114 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1116 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1118 */	NdrFcShort( 0xfffffc64 ),	/* Offset= -924 (194) */
/* 1120 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1122 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0xfffffc42 ),	/* Offset= -958 (166) */
/* 1126 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1128 */	NdrFcShort( 0xfffffba2 ),	/* Offset= -1118 (10) */
/* 1130 */	0x2,		/* FC_CHAR */
			0x43,		/* FC_STRUCTPAD7 */
/* 1132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1142 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1144 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1146) */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1106) */
/* 1150 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x12, 0x0,	/* FC_UP */
/* 1156 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1180) */
/* 1158 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1168 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1172 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1174 */	
			0x12, 0x0,	/* FC_UP */
/* 1176 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (1106) */
/* 1178 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1180 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1186 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1192) */
/* 1188 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1190 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1192 */	
			0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1158) */
/* 1196 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1200) */
/* 1200 */	
			0x12, 0x0,	/* FC_UP */
/* 1202 */	NdrFcShort( 0x2a ),	/* Offset= 42 (1244) */
/* 1204 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1206 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1218) */
/* 1212 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1214 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1216 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1218 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1220 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1204) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1256) */
/* 1252 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1254 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1262 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0xe ),	/* Offset= 14 (1280) */
/* 1268 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1270 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1274 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1278 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1280 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1282 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1286 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1306) */
/* 1288 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1290 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1292 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1294 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1298 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1300 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 1302 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1308 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1310 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1312 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1314 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1316 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (1268) */
/* 1322 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1324 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1326) */
/* 1326 */	
			0x12, 0x0,	/* FC_UP */
/* 1328 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1280) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)DHCP_SRV_HANDLE_bind,
            (GENERIC_UNBIND_ROUTINE)DHCP_SRV_HANDLE_unbind
         }
        
        };


static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    56,
    112,
    168,
    242,
    298,
    384,
    446,
    502,
    558,
    614,
    670,
    720,
    782,
    844,
    924,
    980,
    1030,
    1080,
    1136,
    1186,
    1266,
    1328,
    1378,
    1452,
    1508,
    1564,
    1614,
    1676,
    1732,
    1788,
    1874,
    1936,
    1986,
    2036,
    2092,
    2172,
    2234,
    2284,
    2334,
    2390
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &dhcpsrv_bhandle,
    0,
    BindingRoutines,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\opttest.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: test utilility for options api
//================================================================================

#include <windows.h>
#include <winsock.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <dhcplib.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <jet.h>        // for JET_cbColumnMost

LPWSTR       GlobalServerName = L"127.0.0.1" ;
const       DWORD                  ReservedZero = 0;
const       DWORD                  PreferredMax = 0xFFFFFFF;
DHCP_CLASS_INFO                    DhcpGlobalClassInfo;

//================================================================================
//  utilties
//================================================================================
LPWSTR
WSTRING(
    IN      LPSTR                  String
)
{
    LPWSTR                         WString, Tmp;

    WString = DhcpAllocateMemory(sizeof(WCHAR)*(strlen(String)+1));
    if( NULL == WString ) return NULL;
    Tmp = WString;

    while(*Tmp++ = (WCHAR)*String++);
    return WString;
}

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

        DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

//================================================================================
// the main code for each function follows
//================================================================================

DWORD
CreateClass(
    IN      DWORD                  nAargs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    LPDHCP_CLASS_INFO              ClassInfo = &DhcpGlobalClassInfo;

    ClassInfo->ClassName = WSTRING(Args[0]);
    ClassInfo->ClassComment = NULL;
    ClassInfo->ClassDataLength = strlen(Args[1]);
    ClassInfo->ClassData = Args[1];
    Error = DhcpCreateClass(
        GlobalServerName,
        ReservedZero,
        ClassInfo
    );
    DhcpFreeMemory(ClassInfo->ClassName);

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
ModifyClass(
    IN      DWORD                  nAargs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    LPDHCP_CLASS_INFO              ClassInfo = &DhcpGlobalClassInfo;

    ClassInfo->ClassName = WSTRING(Args[0]);
    ClassInfo->ClassComment = NULL;
    ClassInfo->ClassDataLength = strlen(Args[1]);
    ClassInfo->ClassData = Args[1];
    Error = DhcpModifyClass(
        GlobalServerName,
        ReservedZero,
        ClassInfo
    );
    DhcpFreeMemory(ClassInfo->ClassName);

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
DeleteClass(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    LPWSTR                         ClassName;

    ClassName = WSTRING(Args[0]);
    Error = DhcpDeleteClass(
        GlobalServerName,
        ReservedZero,
        ClassName
    );
    DhcpFreeMemory(ClassName);

    printf("Status = %ld\n", Error);
    return Error;
}

VOID
PrintClass(
    IN      LPDHCP_CLASS_INFO      Class
)
{
    DWORD                          Index;
    printf("%S (%S) [%d: ", Class->ClassName, Class->ClassComment, Class->ClassDataLength);
    for( Index = 0; Index < Class->ClassDataLength; Index ++ )
        printf("%02x ", Class->ClassData[Index]);
    printf("\n");
}

DWORD
GetClassInfoX(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    LPDHCP_CLASS_INFO              ClassInfo = &DhcpGlobalClassInfo, OutClassInfo;
    LPWSTR                         ClassName;

    memset(ClassInfo, 0, sizeof(*ClassInfo) );
    ClassInfo->ClassName = WSTRING(Args[0]);
    OutClassInfo = NULL;
    Error = DhcpGetClassInfo(
        GlobalServerName,
        ReservedZero,
        ClassInfo,
        &OutClassInfo
    );
    DhcpFreeMemory(ClassInfo->ClassName);
    if( ERROR_SUCCESS == Error ) {
        PrintClass(OutClassInfo);
        DhcpRpcFreeMemory(OutClassInfo);
        return ERROR_SUCCESS;
    }

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
EnumClasses(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          Index;
    DWORD                          nRead;
    DWORD                          nTotal;
    LPDHCP_CLASS_INFO_ARRAY        OutClasses;
    DHCP_RESUME_HANDLE             Resume = 0;

    OutClasses = NULL;
    Error = DhcpEnumClasses(
        GlobalServerName,
        ReservedZero,
        &Resume,
        PreferredMax,
        &OutClasses,
        &nRead,
        &nTotal
    );

    if( ERROR_SUCCESS == Error ) {
        printf("nRead = %ld nTotal = %ld NumElements = %ld\n",
               nRead, nTotal, OutClasses?OutClasses->NumElements:0
        );
        for( Index = 0; Index < nRead; Index ++ ) {
            PrintClass(&OutClasses->Classes[Index]);
        }
        if( OutClasses) DhcpRpcFreeMemory(OutClasses);
        return ERROR_SUCCESS;
    }

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
CreateOption(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         VendorName;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    BOOL                           IsVendor;
    DHCP_OPTION                    OptInfo;
    DHCP_OPTION_DATA_ELEMENT       DhcpOptionDataElement;

    OptionId = atoi(Args[0]);
    VendorName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));
    OptName = WSTRING(Args[3]);
    OptComment = WSTRING(Args[4]);
    OptionData = atoi(Args[5]);

    OptInfo.OptionID = OptionId;
    OptInfo.OptionName = OptName;
    OptInfo.OptionComment = OptComment;
    OptInfo.OptionType = DhcpDWordOption;
    OptInfo.DefaultValue.NumElements = 1;
    OptInfo.DefaultValue.Elements = &DhcpOptionDataElement;
    DhcpOptionDataElement.Element.DWordOption = OptionData;
    DhcpOptionDataElement.OptionType = DhcpDWordOption;

    Error = DhcpCreateOptionV5(
        GlobalServerName,
        IsVendor?DHCP_FLAGS_OPTION_IS_VENDOR:0,
        OptionId,
        NULL,
        VendorName,
        &OptInfo
    );

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
SetOptionInfo(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    BOOL                           IsVendor;
    DHCP_OPTION                    OptInfo;
    DHCP_OPTION_DATA_ELEMENT       DhcpOptionDataElement;

    OptionId = atoi(Args[0]);
    ClassName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));
    OptName = WSTRING(Args[3]);
    OptComment = WSTRING(Args[4]);
    OptionData = atoi(Args[5]);

    OptInfo.OptionID = OptionId;
    OptInfo.OptionName = OptName;
    OptInfo.OptionComment = OptComment;
    OptInfo.OptionType = DhcpDWordOption;
    OptInfo.DefaultValue.NumElements = 1;
    OptInfo.DefaultValue.Elements = &DhcpOptionDataElement;
    DhcpOptionDataElement.Element.DWordOption = OptionData;
    DhcpOptionDataElement.OptionType = DhcpDWordOption;

    Error = DhcpSetOptionInfoV5(
        GlobalServerName,
        OptionId,
        ClassName,
        IsVendor,
        &OptInfo
    );

    printf("Status = %ld\n", Error);
    return Error;
}

VOID
PrintOptionInfo(
    IN      LPDHCP_OPTION          Option
)
{
    printf("%03ld %S (%S) Type = %ld\n",
           Option->OptionID, Option->OptionName, Option->OptionComment, Option->OptionType
    );
}

DWORD
GetOptionInfo(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         ClassName;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    BOOL                           IsVendor;
    LPDHCP_OPTION                  OptInfo;
    DHCP_OPTION_DATA_ELEMENT       DhcpOptionDataElement;

    OptionId = atoi(Args[0]);
    ClassName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));

    OptInfo = NULL;
    Error = DhcpGetOptionInfoV5(
        GlobalServerName,
        OptionId,
        ClassName,
        IsVendor,
        &OptInfo
    );

    if( ERROR_SUCCESS == Error ) {
        PrintOptionInfo(OptInfo);
        DhcpRpcFreeMemory(OptInfo);
        return ERROR_SUCCESS;
    }
    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
RemoveOption(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         ClassName;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    BOOL                           IsVendor;

    OptionId = atoi(Args[0]);
    ClassName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));

    Error = DhcpRemoveOptionV5(
        GlobalServerName,
        OptionId,
        ClassName,
        IsVendor
    );

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
SetOptionValue(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         ClassName;
    BOOL                           IsVendor;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;
    DHCP_OPTION_DATA               OptData;
    DHCP_OPTION_DATA_ELEMENT       OptDataElement;

    OptionId = atoi(Args[0]);
    ClassName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));
    OptionData = atoi(Args[3]);

    OptData.NumElements = 1;
    OptData.Elements = &OptDataElement;
    OptDataElement.OptionType = DhcpDWordOption;
    OptDataElement.Element.DWordOption = OptionData;
    ScopeInfo.ScopeType = DhcpGlobalOptions;

    Error = DhcpSetOptionValueV5(
        GlobalServerName,
        OptionId,
        ClassName,
        IsVendor,
        &ScopeInfo,
        &OptData
    );

    printf("Status = %ld\n", Error);
    return Error;
}

DWORD
GetOptionValue(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          OptionData;
    LPWSTR                         ClassName;
    BOOL                           IsVendor;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;
    LPDHCP_OPTION_VALUE            OptData;

    OptionId = atoi(Args[0]);
    ClassName = (0 == _stricmp(Args[1], "NULL"))?NULL:WSTRING(Args[1]);
    IsVendor = (0 == _stricmp(Args[2], "IsVendor"));

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    OptData = NULL;
    Error = DhcpGetOptionValueV5(
        GlobalServerName,
        OptionId,
        ClassName,
        IsVendor,
        &ScopeInfo,
        &OptData
    );

    if( ERROR_SUCCESS == Error ) {
        printf("OptionId =%ld NumElements = %ld, Type = %ld\n Data = %ld", OptData->Value.NumElements,
               OptData->OptionID,
               OptData->Value.NumElements?OptData->Value.Elements[0].OptionType:-1,
               OptData->Value.NumElements?OptData->Value.Elements[0].Element.DWordOption:-1
        );
        DhcpRpcFreeMemory(OptData);
        return ERROR_SUCCESS;
    }
    printf("Status = %ld\n", Error);
    return Error;
}

VOID
PrintOptionArray(
    IN      LPDHCP_OPTION_ARRAY    Options
)
{
    DWORD                          Index;

    if( NULL == Options ) return;

    for(Index = 0; Index < Options->NumElements; Index ++ )
        PrintOptionInfo(&Options->Options[Index]);
}

DWORD
GetAllOptions(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Error;
    LPDHCP_ALL_OPTIONS             AllOpts;

    AllOpts = NULL;
    Error = DhcpGetAllOptions(
        GlobalServerName,
        DHCP_OPT_ENUM_IGNORE_VENDOR,
        FALSE,
        NULL,
        &AllOpts
    );

    if( ERROR_SUCCESS == Error ) {
        printf("VendorOptions:\n");
        PrintOptionArray(AllOpts->VendorOptions);
        printf("NonVendorOptions:\n");
        PrintOptionArray(AllOpts->NonVendorOptions);
        DhcpRpcFreeMemory(AllOpts);
        return ERROR_SUCCESS;
    }

    printf("Status = %ld\n", Error);
    return Error;
}

VOID
PrintOptionValueArray(
    IN      LPDHCP_OPTION_VALUE_ARRAY     Array
)
{
    DWORD                          Index;

    if( NULL == Array ) return;

    for(Index = 0; Index < Array->NumElements; Index ++ )
        printf("OptionId = %ld NumElements = %ld Type = %ld Data = %ld\n",
               Array->Values[Index].OptionID, Array->Values[Index].Value.NumElements,
               Array->Values[Index].Value.Elements[0].OptionType,
               Array->Values[Index].Value.Elements[0].Element.DWordOption
        );

}

DWORD
GetAllOptionValues(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    LPDHCP_ALL_OPTION_VALUES       OptionValues;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;
    DWORD                          Error;
    DWORD                          Index;

    OptionValues = NULL;
    ScopeInfo.ScopeType = DhcpGlobalOptions;
    Error = DhcpGetAllOptionValues(
        GlobalServerName,
        DHCP_OPT_ENUM_IGNORE_VENDOR,
        FALSE,
        NULL,
        &ScopeInfo,
        &OptionValues
    );

    if( ERROR_SUCCESS == Error ) {
        printf("Default Vendor option values:\n");
        PrintOptionValueArray(OptionValues->DefaultValues.VendorOptions);
        printf("Default NonVendor option values:\n");
        PrintOptionValueArray(OptionValues->DefaultValues.NonVendorOptions);

        if( OptionValues->ClassInfoArray )
            for(Index = 0; Index < OptionValues->ClassInfoArray->NumElements ; Index ++ ) {
                printf("Class %ws : \n", OptionValues->ClassInfoArray->Classes[Index].ClassName);
                PrintOptionValueArray(OptionValues->VendorOptionValueForClassArray.Elements[Index]);
                PrintOptionValueArray(OptionValues->NonVendorOptionValueForClassArray.Elements[Index]);
            }
        DhcpRpcFreeMemory(OptionValues);
        return ERROR_SUCCESS;
    }

    printf("Status = %ld\n", Error);
    return Error;
}

struct {
    LPSTR                          CmdName;
    DWORD                          MinArgs;
    DWORD                          (*Func)(IN DWORD nArgs, IN LPSTR *Args);
    LPWSTR                         Comment;
} Table[] = {
    "CreateClass",   3,            CreateClass,         L"CreateClass ClassName AsciiStringForClass\n",
    "ModifyClass",   3,            ModifyClass,         L"ModifyClass ClassName AsciiStringForClass\n",
    "DeleteClass",   3,            DeleteClass,         L"DeleteClass ClassName\n",
    "GetClassInfo",  3,            GetClassInfoX,       L"GetClassInfo ClassName\n",
    "EnumClasses",   2,            EnumClasses,         L"EnumClassses\n",
    "CreateOption",  3,            CreateOption,        L"CreateOption OptionId(INT) ClassName \"Is(Not)Vendor\" OptName "
                                                        L"OptionComment OptionData(INT)\n",
    "SetOptionInfo", 3,            SetOptionInfo,       L"SetOptionInfo OptionId(INT) ClassName \"Is(Not)Vendor\" OptName "
                                                        L"OptionComment OptionData(INT)\n",
    "GetOptionInfo", 3,            GetOptionInfo,       L"GetOptionInfo OptionId(INT) ClassName \"Is(Not)Vendor\" \n",
    "RemoveOption",  3,            RemoveOption,        L"RemoveOption OptionId(INT) ClassName \"Is(Not)Vendor\" \n",
    "SetOptionValue",3,            SetOptionValue,      L"SetOptionValue OptionId(INT) ClassName \"Is(Not)Vendor\" OptData(INT)\n",
    "GetOptionValue",3,            GetOptionValue,      L"GetOptionValue OptionId(INT) ClassName \"Is(Not)Vendor\"\n",
    "GetAllOptions", 2,            GetAllOptions,       L"GetAllOptions\n",
    "GetAllOptionValues", 2,       GetAllOptionValues,  L"GetAllOptionValues\n",
};

DWORD
PrintUsage(
    VOID
)
{
    DWORD                          Index;

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]) ; Index ++ )
        printf("%S", Table[Index].Comment);

    return ERROR_SUCCESS;
}

DWORD
Main(
    IN      DWORD                  nArgs,
    IN      LPSTR                 *Args
)
{
    DWORD                          Index;

    if( 1 >= nArgs ) return PrintUsage();

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( 0 == _stricmp(Table[Index].CmdName, Args[1]) )
            if( nArgs < Table[Index].MinArgs ) {
                printf("%S", Table[Index].Comment);
                return ERROR_SUCCESS;
            } else return Table[Index].Func(nArgs-2, Args+2);
    }

    return PrintUsage();
}

void _cdecl main( int argc, char *argv[] )
{
    Main(argc, argv);
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\delete.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module has helper routines to delete the objects recursively.
//
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>

//================================================================================
//  helper functions
//================================================================================
VOID        static
MemFreeFunc(
    IN OUT  LPVOID                 Memory
)
{
    MemFree(Memory);
}

//================================================================================
//  exposed functions
//================================================================================

//BeginExport(function)
//DOC  SubnetDeleteReservation deletes the reservation object from off the DS.
SubnetDeleteReservation(                          // delete reservation from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for resrevation objs
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object in DS
    IN      LPWSTR                 ADsPath,       // path of reservation object
    IN      DWORD                  StoreGetType   // path is relative, abs, or dif server?
)   //EndExport(function)
{
    return StoreDeleteThisObject                  // just delete the reservation object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
}

//BeginExport(function)
//DOC  ServerDeleteSubnet deletes the subnet specified from the DS by removing
//DOC  the subnet object.
ServerDeleteSubnet(                               // remove subnet object from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for subnet objs in Ds
    IN      LPWSTR                 ServerName,    // name of server this deletion is for
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN      LPWSTR                 ADsPath,       // Location of the subnet in DS
    IN      DWORD                  StoreGetType   // path is relative,abs or diff srvr?
)   //EndExport(function)
{
    DWORD                          Err, LastErr, LocType;
    STORE_HANDLE                   hSubnet;
    ARRAY                          Reservations;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         Location;
    LPVOID                         Ptr;

    Err = StoreGetHandle                          // get the server object from the DS
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath,
        /* hStoreOut            */ &hSubnet
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Err = MemArrayInit(&Reservations);            //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list or reservations
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    LastErr = ERROR_SUCCESS;
    for(                                          // delete each subnet
        Err = MemArrayInitLoc(&Reservations, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err;
        Err = MemArrayNextLoc(&Reservations, &Loc)
    ) {
        Err = MemArrayGetElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // reserved address
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // HW address info
            continue;                             // invalid subnet
        }

        if( !IS_ADSPATH_PRESENT(ThisAttrib) ) {   // no location specified
            Location = MakeReservationLocation(ServerName, ThisAttrib->Address1);
            LocType = StoreGetChildType;
            Ptr = Location;
        } else {
            Location = ThisAttrib->ADsPath;
            LocType = ThisAttrib->StoreGetType;
            Ptr = NULL;
        }

        Err = SubnetDeleteReservation             // now delete the reservation
        (
            /* hDhcpC           */ hDhcpC,
            /* ServerName       */ ServerName,
            /* hServer          */ hServer,
            /* hSubnet          */ &hSubnet,
            /* ADsPath          */ Location,
            /* StoreGetType     */ LocType
        );
        if( ERROR_SUCCESS != Err ) LastErr = Err;
        if( Ptr ) MemFree(Ptr);
    }

    MemArrayFree(&Reservations, MemFreeFunc);

    Err = StoreCleanupHandle(&hSubnet, 0);        //= require ERROR_SUCCESS == Err
    Err = StoreDeleteThisObject                   // now really delete the subnet object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
    if( ERROR_SUCCESS != Err ) LastErr = Err;     // try to delete the store object itself

    return LastErr;
}

//BeginExport(function)
//DOC  DeleteServer deletes the server object from the DS and deletes any SUBNET and
//DOC  reservation objects that it may point to.
//DOC  The hDhcpC parameter is the handle of the container where the server object
//DOC  may be located. This used in conjunction with the ADsPath and StoreGetType
//DOC  defines the location of the ServerObject.
DWORD
DeleteServer(                                     // recurse delete server from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where server obj may be
    IN      LPWSTR                 ServerName,    // name of server..
    IN      LPWSTR                 ADsPath,       // path of the server object
    IN      DWORD                  StoreGetType   // is path relative, absolute or dif srvr?
)   //EndExport(function)
{
    DWORD                          Err, LastErr, LocType;
    STORE_HANDLE                   hServer;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         Location;
    LPVOID                         Ptr;

    Err = StoreGetHandle                          // get the server object from the DS
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath,
        /* hStoreOut            */ &hServer
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get subnets and other stuff
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    LastErr = ERROR_SUCCESS;
    for(                                          // delete each subnet
        Err = MemArrayInitLoc(&Subnets, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err;
        Err = MemArrayNextLoc(&Subnets, &Loc)
    ) {
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // subnet mask
            continue;                             // invalid subnet
        }

        if( !IS_ADSPATH_PRESENT(ThisAttrib) ) {   // no location specified
            Location = MakeSubnetLocation(ServerName, ThisAttrib->Address1);
            LocType = StoreGetChildType;
            Ptr = Location;
        } else {
            Location = ThisAttrib->ADsPath;
            LocType = ThisAttrib->StoreGetType;
            Ptr = NULL;
        }

        Err = ServerDeleteSubnet                  // now delete the subnet
        (
            /* hDhcpC           */ hDhcpC,
            /* ServerName       */ ServerName,
            /* hServer          */ &hServer,
            /* ADsPath          */ Location,
            /* StoreGetType     */ LocType
        );
        if( ERROR_SUCCESS != Err ) LastErr = Err;
        if( Ptr ) MemFree(Ptr);
    }

    MemArrayFree(&Subnets, MemFreeFunc);

    Err = StoreCleanupHandle( &hServer, DDS_RESERVED_DWORD );
    Err = StoreDeleteThisObject                   // now really delete the server object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetType,
        /* Path                 */ ADsPath
    );
    if( ERROR_SUCCESS != Err ) LastErr = Err;     // try to delete the store object itself

    return LastErr;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\testapis.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    testapis.c

Abstract:

    This file contains program to test all DHCP APIs.

Author:

    Madan Appiah (madana) 15-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <dhcplib.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define OPTION_DATA_NUM_ELEMENT         4
#define RANDOM_STRING_MAX_LEN           16
#define RANDOM_BINARY_DATA_MAX_LEN      32
#define SCRATCH_BUFFER_SIZE             4096 // 4K
#define SCRATCH_SMALL_BUFFER_SIZE       64
#define CREATE_MAX_OPTION_VALUES        10
#define NUM_KNOWN_OPTIONS               8

#define CLIENT_COUNT                    40


BYTE GlobalScratchBuffer[SCRATCH_BUFFER_SIZE];
LPBYTE GlobalScratchBufferEnd =
            GlobalScratchBuffer + SCRATCH_BUFFER_SIZE;

LPWSTR GlobalServerIpAddress;

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
BYTE
RandN( // return random numbers from 0 to n-1 (max 0xFF)
    BYTE n // range 0 - 0xFF
    )
{
    return( (BYTE)(rand() % n) );

}

BYTE
RandByte( // return 0 - 0xFF
    VOID
    )
{
    return( (BYTE)rand() );
}

WORD
RandWord( // return 0 - 0xFFFF
    VOID
    )
{
    return((WORD)(((WORD)RandByte() << 8) | (WORD)RandByte()));
}

DWORD
RandDWord( // return 0 - 0xFFFFFFFF
    VOID
    )
{
    return(((DWORD)RandWord() << 16) | (DWORD)RandWord());
}

DWORD_DWORD
RandDWordDword(
    VOID
    )
{
    DWORD_DWORD Lg;

    Lg.DWord1 = RandDWord();
    Lg.DWord2 = RandDWord();

    return(Lg);
}

LPWSTR
RandString(
    LPWSTR BufferPtr,
    DWORD *Length
    )
{
    BYTE i;
    LPWSTR BPtr = BufferPtr;

    *Length = RandN( RANDOM_STRING_MAX_LEN );
    for( i = 0; i < *Length; i++) {
        *BPtr++ = L'A' + RandN(26);
    }

    *BPtr++ = L'\0'; // terminate
    *Length += 1;

    return( BufferPtr );
}

VOID
RandBinaryData(
    LPDHCP_BINARY_DATA BinaryData
    )
{
    DWORD Length = 0;
    DWORD i;
    LPBYTE DataPtr;

    //
    // generate a HW address, atlease 6 bytes long.
    //

    while (Length < 6 ) {
        Length = (DWORD)RandN( RANDOM_BINARY_DATA_MAX_LEN );
    }

    BinaryData->DataLength = Length;
    DataPtr = BinaryData->Data;

    for( i = 0; i < Length; i++) {
        *DataPtr++ = RandByte();
    }
}

VOID
CreateOptionValue(
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_DATA OptionData
    )
{
    DWORD i;
    DHCP_OPTION_DATA_TYPE OptionType;
    LPBYTE DataPtr;
    DWORD NumElements;

    NumElements =
        OptionData->NumElements = RandN(OPTION_DATA_NUM_ELEMENT);
    OptionData->Elements= (LPDHCP_OPTION_DATA_ELEMENT)GlobalScratchBuffer;

    OptionType = (DHCP_OPTION_DATA_TYPE)
        (OptionID % (DhcpEncapsulatedDataOption + 1));

    DataPtr = GlobalScratchBuffer +
        NumElements * sizeof( DHCP_OPTION_DATA_ELEMENT );

    for( i = 0; i < NumElements; i++) {
        OptionData->Elements[i].OptionType = OptionType;
        switch( OptionType ) {
        case DhcpByteOption:
            OptionData->Elements[i].Element.ByteOption = RandByte();
            break;

        case DhcpWordOption:
            OptionData->Elements[i].Element.WordOption = RandWord();
            break;

        case DhcpDWordOption:
            OptionData->Elements[i].Element.DWordOption = RandDWord();
            break;

        case DhcpDWordDWordOption:
            OptionData->Elements[i].Element.DWordDWordOption =
                    RandDWordDword();
            break;

        case DhcpIpAddressOption:
            OptionData->Elements[i].Element.IpAddressOption = RandDWord();
            break;

        case DhcpStringDataOption: {
            DWORD Length;

            OptionData->Elements[i].Element.StringDataOption =
                RandString( (LPWSTR)DataPtr, &Length );
            DataPtr += (Length * sizeof(WCHAR));
            break;
        }

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            OptionData->Elements[i].Element.BinaryDataOption.Data = DataPtr;

            RandBinaryData(
                &OptionData->Elements[i].Element.BinaryDataOption );

            DataPtr +=
                OptionData->Elements[i].Element.BinaryDataOption.DataLength;
            break;
        default:
            printf("CreateOptionValue: Unknown OptionType \n");
            break;
        }

        DhcpAssert( DataPtr < GlobalScratchBufferEnd );
    }
}

VOID
CreateOptionValue1(
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_DATA OptionData,
    LPBYTE ScratchBuffer
    )
{
    DWORD i;
    DHCP_OPTION_DATA_TYPE OptionType;
    LPBYTE DataPtr;
    DWORD NumElements;

    NumElements =
        OptionData->NumElements = RandN(OPTION_DATA_NUM_ELEMENT);
    OptionData->Elements= (LPDHCP_OPTION_DATA_ELEMENT)ScratchBuffer;

    OptionType = (DHCP_OPTION_DATA_TYPE)
        (OptionID % (DhcpEncapsulatedDataOption + 1));

    DataPtr = ScratchBuffer +
        NumElements * sizeof( DHCP_OPTION_DATA_ELEMENT );

    for( i = 0; i < NumElements; i++) {
        OptionData->Elements[i].OptionType = OptionType;
        switch( OptionType ) {
        case DhcpByteOption:
            OptionData->Elements[i].Element.ByteOption = RandByte();
            break;

        case DhcpWordOption:
            OptionData->Elements[i].Element.WordOption = RandWord();
            break;

        case DhcpDWordOption:
            OptionData->Elements[i].Element.DWordOption = RandDWord();
            break;

        case DhcpDWordDWordOption:
            OptionData->Elements[i].Element.DWordDWordOption =
                    RandDWordDword();
            break;

        case DhcpIpAddressOption:
            OptionData->Elements[i].Element.IpAddressOption = RandDWord();
            break;

        case DhcpStringDataOption: {
            DWORD Length;

            OptionData->Elements[i].Element.StringDataOption =
                RandString( (LPWSTR)DataPtr, &Length );
            DataPtr += (Length * sizeof(WCHAR));
            break;
        }

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            OptionData->Elements[i].Element.BinaryDataOption.Data = DataPtr;

            RandBinaryData(
                &OptionData->Elements[i].Element.BinaryDataOption );

            DataPtr +=
                OptionData->Elements[i].Element.BinaryDataOption.DataLength;
            break;
        default:
            printf("CreateOptionValue: Unknown OptionType \n");
            break;
        }

        DhcpAssert( DataPtr < (ScratchBuffer + SCRATCH_BUFFER_SIZE) );
    }
}

VOID
PrintOptionValue(
    LPDHCP_OPTION_DATA OptionValue
    )
{
    DWORD NumElements;
    DHCP_OPTION_DATA_TYPE OptionType;
    DWORD i;

    printf("Option Value : \n");
    NumElements = OptionValue->NumElements;

    printf("\tNumber of Option Elements = %ld\n", NumElements );

    if( NumElements == 0 ) {
        return;
    }

    OptionType = OptionValue->Elements[0].OptionType;
    printf("\tOption Elements Type = " );

    switch( OptionType ) {
    case DhcpByteOption:
        printf("DhcpByteOption\n");
        break;

    case DhcpWordOption:
        printf("DhcpWordOption\n");
        break;

    case DhcpDWordOption:
        printf("DhcpDWordOption\n");
        break;

    case DhcpDWordDWordOption:
        printf("DhcpDWordDWordOption\n");
        break;

    case DhcpIpAddressOption:
        printf("DhcpIpAddressOption\n");
        break;

    case DhcpStringDataOption:
        printf("DhcpStringDataOption\n");
        break;

    case DhcpBinaryDataOption:
        printf("DhcpBinaryDataOption\n");
        break;

    case DhcpEncapsulatedDataOption:
        printf("DhcpEncapsulatedDataOption\n");
        break;
    default:
        printf("Unknown\n");
        return;
    }

    for( i = 0; i < OptionValue->NumElements; i++ ) {
        DhcpAssert( OptionType == OptionValue->Elements[i].OptionType );
        printf("Option Element %ld value = ", i );

        switch( OptionType ) {
        case DhcpByteOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.ByteOption );
            break;

        case DhcpWordOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.WordOption );
            break;

        case DhcpDWordOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.DWordOption );
            break;

        case DhcpDWordDWordOption:
            printf("%lx, %lx.\n",
                OptionValue->Elements[i].Element.DWordDWordOption.DWord1,
                OptionValue->Elements[i].Element.DWordDWordOption.DWord2 );

            break;

        case DhcpIpAddressOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.IpAddressOption );
            break;

        case DhcpStringDataOption:
            printf("%ws.\n",
                OptionValue->Elements[i].Element.StringDataOption );
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption: {
            DWORD j;
            DWORD Length;

            Length = OptionValue->Elements[i].Element.BinaryDataOption.DataLength;
            for( j = 0; j < Length; j++ ) {
                printf("%2lx ",
                    OptionValue->Elements[i].Element.BinaryDataOption.Data[j] );
            }
            printf(".\n");
            break;
        }
        default:
            printf("PrintOptionValue: Unknown OptionType.\n");
            break;
        }
    }
}


VOID
PrintOptionInfo(
    LPDHCP_OPTION OptionInfo
    )
{
    printf( "Option Info : \n");
    printf( "\tOptionId : %ld \n", (DWORD)OptionInfo->OptionID );
    printf( "\tOptionName : %ws \n", (DWORD)OptionInfo->OptionName );
    printf( "\tOptionComment : %ws \n", (DWORD)OptionInfo->OptionComment );
    PrintOptionValue( &OptionInfo->DefaultValue );
    printf( "\tOptionType : %ld \n", (DWORD)OptionInfo->OptionType );
}


VOID
TestPrintSubnetEnumInfo(
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY EnumInfo
    )
{
    DWORD i;
    LPDHCP_SUBNET_ELEMENT_DATA Element;

    printf("Subnet Enum Info : \n");
    printf("Number of Elements returned = %ld\n\n",
                EnumInfo->NumElements);

    for( i = 0, Element = EnumInfo->Elements;
            i < EnumInfo->NumElements;
                i++, Element++ ) {

        printf("\tElement %ld : \n", i);

        switch( Element->ElementType ) {
        case DhcpIpRanges:
            printf("\tElement Type : DhcpIpRanges\n");
            printf("\tStartAddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.IpRange->StartAddress));
            printf("\tEndAddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.IpRange->EndAddress));
            break;
        case DhcpSecondaryHosts:
            printf("\tElement Type : DhcpSecondaryHosts\n");
            printf("\tIpaddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.SecondaryHost->IpAddress));
            printf("\tNetBiosName : %ws \n",
                Element->Element.SecondaryHost->NetBiosName);
            printf("\tHostName : %ws\n",
                Element->Element.SecondaryHost->HostName);
            break;
        case DhcpReservedIps:
            printf("\tElement Type : DhcpReservedIps\n");
            printf("\tReservedIpAddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.ReservedIp->ReservedIpAddress)) ;
            break;
        case DhcpExcludedIpRanges:
            printf("\tElement Type : DhcpExcludedIpRanges\n");
            printf("\tStartAddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.ExcludeIpRange->StartAddress));
            printf("\tEndAddress : %s\n",
                    DhcpIpAddressToDottedString(
                        Element->Element.ExcludeIpRange->EndAddress));
            break;
        case DhcpIpUsedClusters:
            printf("\tElement Type : DhcpIpUsedClusters\n");
        default:
            printf("\tElement Type : Unknown\n");
            break;
        }
    }
}

VOID
TestPrintSubnetInfo(
    LPDHCP_SUBNET_INFO SubnetInfo
    )
{
    //
    // print subnet info.
    //

    printf("Subnet Info: \n");
    printf("\tSubnetAddress = %s\n",
        DhcpIpAddressToDottedString(SubnetInfo->SubnetAddress));
    printf("\tSubnetMask = %s\n",
        DhcpIpAddressToDottedString(SubnetInfo->SubnetMask));
    printf("\tSubnetName = %ws\n", SubnetInfo->SubnetName);
    printf("\tSubnetComment = %ws\n", SubnetInfo->SubnetComment);
    printf("\tPrimaryHost IpAddress = %s\n",
        DhcpIpAddressToDottedString(SubnetInfo->PrimaryHost.IpAddress));
    printf("\tPrimaryHost NetBiosName = %ws\n",
                SubnetInfo->PrimaryHost.NetBiosName);
    printf("\tPrimaryHost HostName = %ws\n",
                SubnetInfo->PrimaryHost.HostName);
    printf("\tSubnetState = %d\n", SubnetInfo->SubnetState);
}

DWORD
TestDhcpCreateSubnet(
    LPSTR SubnetAddress,
    DHCP_IP_MASK SubnetMask,
    LPWSTR SubnetName,
    LPWSTR SubnetComment,
    LPSTR PrimaryHostIpAddr,
    LPWSTR PrimaryHostName,
    LPWSTR PrimaryNBName,
    DWORD SubnetState
    )
{
    DWORD Error;
    DHCP_SUBNET_INFO SubnetInfo;

    SubnetInfo.SubnetAddress = DhcpDottedStringToIpAddress(SubnetAddress);
    SubnetInfo.SubnetMask = SubnetMask;
    SubnetInfo.SubnetName = SubnetName;
    SubnetInfo.SubnetComment = SubnetComment;
    SubnetInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(PrimaryHostIpAddr);

    SubnetInfo.PrimaryHost.NetBiosName = PrimaryHostName;
    SubnetInfo.PrimaryHost.HostName = PrimaryNBName;
    SubnetInfo.SubnetState = SubnetState;

    Error = DhcpCreateSubnet(
                GlobalServerIpAddress,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

    return( Error );
}

DWORD
TestDhcpDeleteSubnet(
    LPSTR SubnetAddress
    )
{
    return( DhcpDeleteSubnet(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                DhcpNoForce ) );
}

DWORD
Test1DhcpDeleteSubnet(
    LPSTR SubnetAddress
    )
{
    return( DhcpDeleteSubnet(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                DhcpFullForce ) );
}

DWORD
Test1DhcpCreateSubnet(
    LPSTR SubnetAddress
    )
{
    return( DhcpDeleteSubnet(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                DhcpFullForce ) );
}

DWORD
TestDhcpSetSubnetInfo(
    LPSTR SubnetAddress,
    DHCP_IP_MASK SubnetMask,
    LPWSTR SubnetName,
    LPWSTR SubnetComment,
    LPSTR PrimaryHostIpAddr,
    LPWSTR PrimaryHostName,
    LPWSTR PrimaryNBName,
    DWORD SubnetState
    )
{
    DWORD Error;
    DHCP_SUBNET_INFO SubnetInfo;

    SubnetInfo.SubnetAddress = DhcpDottedStringToIpAddress(SubnetAddress);
    SubnetInfo.SubnetMask = SubnetMask;
    SubnetInfo.SubnetName = SubnetName;
    SubnetInfo.SubnetComment = SubnetComment;
    SubnetInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(PrimaryHostIpAddr);
    SubnetInfo.PrimaryHost.NetBiosName = PrimaryNBName;
    SubnetInfo.PrimaryHost.HostName = PrimaryHostName;
    SubnetInfo.SubnetState = SubnetState;

    Error = DhcpSetSubnetInfo(
                GlobalServerIpAddress,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

    return( Error );
}

DWORD
Test1DhcpSetSubnetInfo(
    LPDHCP_SUBNET_INFO SubnetInfo
    )
{
    DWORD Error;

    Error = DhcpSetSubnetInfo(
                GlobalServerIpAddress,
                SubnetInfo->SubnetAddress,
                SubnetInfo );

    return( Error );
}


DWORD
TestDhcpGetSubnetInfo(
    LPSTR SubnetAddress,
    LPDHCP_SUBNET_INFO *SubnetInfo
    )
{
    DWORD Error;

    Error = DhcpGetSubnetInfo(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                SubnetInfo );

    return( Error );
}

DWORD
TestAddSubnetIpRange(
    LPSTR SubnetAddressString,
    LPSTR IpRangeStartString,
    LPSTR IpRangeEndString
    )
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    IpRange.StartAddress = DhcpDottedStringToIpAddress(IpRangeStartString);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(IpRangeEndString);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element );

    return( Error );
}

DWORD
TestAddSubnetIpRange1(
    LPSTR SubnetAddressString,
    DHCP_IP_MASK SubnetMask
    )
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    IpRange.StartAddress = DhcpDottedStringToIpAddress(SubnetAddressString);
    IpRange.StartAddress = IpRange.StartAddress & SubnetMask;
    IpRange.EndAddress = IpRange.StartAddress | ~SubnetMask;

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddress,
                IpRange.StartAddress,
                &Element );

    return( Error );
}

DWORD
TestRemoveSubnetIpRange(
    LPSTR SubnetAddressString,
    LPSTR IpRangeStartString,
    LPSTR IpRangeEndString
    )
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    IpRange.StartAddress = DhcpDottedStringToIpAddress(IpRangeStartString);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(IpRangeEndString);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element,
                DhcpNoForce );

    return( Error );
}

DWORD
TestAddSecondaryHost(
    LPSTR SubnetAddressString,
    LPSTR HostIpAddressString,
    LPWSTR NetBiosName,
    LPWSTR HostName
    )
{
    DWORD Error;
    DHCP_HOST_INFO HostInfo;
    DHCP_SUBNET_ELEMENT_DATA Element;

    HostInfo.IpAddress = DhcpDottedStringToIpAddress(HostIpAddressString);
    HostInfo.NetBiosName = NetBiosName;
    HostInfo.HostName = HostName;

    Element.ElementType = DhcpSecondaryHosts;
    Element.Element.SecondaryHost = &HostInfo;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element );

    return( Error );
}

DWORD
TestRemoveSecondaryHost(
    LPSTR SubnetAddressString,
    LPSTR HostIpAddressString
    )
{
    DWORD Error;
    DHCP_HOST_INFO HostInfo;
    DHCP_SUBNET_ELEMENT_DATA Element;

    HostInfo.IpAddress = DhcpDottedStringToIpAddress(HostIpAddressString);
    HostInfo.NetBiosName = NULL;
    HostInfo.HostName = NULL;

    Element.ElementType = DhcpSecondaryHosts;
    Element.Element.SecondaryHost = &HostInfo;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element,
                DhcpNoForce );

    return( Error );
}

DWORD
TestAddExcludeSubnetIpRange(
    LPSTR SubnetAddressString,
    LPSTR IpRangeStartString,
    LPSTR IpRangeEndString
    )
{
    DWORD Error;
    DHCP_IP_RANGE ExcludeIpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    ExcludeIpRange.StartAddress =
        DhcpDottedStringToIpAddress(IpRangeStartString);
    ExcludeIpRange.EndAddress =
        DhcpDottedStringToIpAddress(IpRangeEndString);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &ExcludeIpRange;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element );

    return( Error );
}

DWORD
TestRemoveExcludeSubnetIpRange(
    LPSTR SubnetAddressString,
    LPSTR IpRangeStartString,
    LPSTR IpRangeEndString
    )
{
    DWORD Error;
    DHCP_IP_RANGE ExcludeIpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    ExcludeIpRange.StartAddress =
        DhcpDottedStringToIpAddress(IpRangeStartString);
    ExcludeIpRange.EndAddress =
        DhcpDottedStringToIpAddress(IpRangeEndString);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &ExcludeIpRange;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element,
                DhcpNoForce );

    return( Error );
}

DWORD
TestAddReserveIpAddress(
    LPSTR SubnetAddressString,
    LPSTR ReserveIpAddressString,
    LPSTR ClientUIDString
    )
{
    DWORD Error;
    DHCP_IP_RESERVATION ReserveIpInfo;
    DHCP_CLIENT_UID ClientUID;
    DHCP_SUBNET_ELEMENT_DATA Element;

    ClientUID.DataLength = strlen(ClientUIDString) + 1;
    ClientUID.Data = ClientUIDString;

    ReserveIpInfo.ReservedIpAddress =
        DhcpDottedStringToIpAddress(ReserveIpAddressString);
    ReserveIpInfo.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveIpInfo;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element );

    return( Error );
}

DWORD
TestRemoveReserveIpAddress(
    LPSTR SubnetAddressString,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DHCP_IP_RESERVATION ReserveIpInfo;
    DHCP_SUBNET_ELEMENT_DATA Element;

    ReserveIpInfo.ReservedIpAddress =
        DhcpDottedStringToIpAddress(ReserveIpAddressString);
    ReserveIpInfo.ReservedForClient = NULL;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveIpInfo;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                &Element,
                DhcpNoForce );

    return( Error );
}

DWORD
TestDhcpEnumSubnetElements(
    LPSTR SubnetAddressString,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo
    )
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD ElementsRead;
    DWORD ElementsTotal;

    Error = DhcpEnumSubnetElements(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddressString),
                EnumElementType,
                &ResumeHandle,
                0xFFFFFFFF,
                EnumElementInfo,
                &ElementsRead,
                &ElementsTotal
                );

    return( Error );
}

DWORD
Test1DhcpEnumSubnetElements(
    LPSTR SubnetAddressString,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DWORD SmallBufferSize
    )
{
    DWORD Error;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY EnumElementInfo = NULL;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD ElementsRead;
    DWORD ElementsTotal;

    Error = ERROR_MORE_DATA;
    while (Error == ERROR_MORE_DATA) {
        Error = DhcpEnumSubnetElements(
                    GlobalServerIpAddress,
                    DhcpDottedStringToIpAddress(SubnetAddressString),
                    EnumElementType,
                    &ResumeHandle,
                    SmallBufferSize,
                    &EnumElementInfo,
                    &ElementsRead,
                    &ElementsTotal
                    );

        printf("DhcpEnumSubnetElements(%s) result = %ld.\n",
                    SubnetAddressString, Error );

        if( (Error == ERROR_SUCCESS) ||
            (Error == ERROR_MORE_DATA) ) {
            printf("Elements Read = %ld\n", ElementsRead);
            printf("Elements Total = %ld\n", ElementsTotal);
            TestPrintSubnetEnumInfo( EnumElementInfo );
            DhcpRpcFreeMemory( EnumElementInfo );
            EnumElementInfo = NULL;
        }
    }

    return( Error );
}

DWORD
TestDhcpCreateOption(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION OptionInfo;
    WCHAR NameBuffer[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR NameAppend;
    WCHAR CommentBuffer[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR CommentAppend;
    WCHAR IDKey[SCRATCH_SMALL_BUFFER_SIZE];
    DWORD i;

    wcscpy( NameBuffer, L"OptionName ");
    NameAppend = NameBuffer + wcslen(NameBuffer);
    wcscpy( CommentBuffer, L"OptionComment ");
    CommentAppend = CommentBuffer + wcslen(CommentBuffer);

    for( i = 0; i <= NUM_KNOWN_OPTIONS ; i++ ) {

        OptionID = RandByte();
        DhcpRegOptionIdToKey( OptionID, IDKey );
        OptionInfo.OptionID = OptionID;

        wcscpy( NameAppend, IDKey);
        OptionInfo.OptionName = NameBuffer;

        wcscpy( CommentAppend, IDKey);
        OptionInfo.OptionComment = CommentBuffer;

        OptionInfo.DefaultValue;
        CreateOptionValue( OptionID, &OptionInfo.DefaultValue );

        OptionInfo.OptionType = DhcpArrayTypeOption;

        Error = DhcpCreateOption(
                    GlobalServerIpAddress,
                    OptionID,
                    &OptionInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpCreateOption failed to add %ld Option, %ld\n",
                    (DWORD)OptionID, Error );
            ReturnError = Error;
        }
        else {
            printf("Option %ld successfully added.\n", (DWORD)OptionID );
        }
    }
    return( ReturnError );

}

DWORD
TestDhcpSetOptionInfo(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;

    DHCP_OPTION_ID OptionID;
    DHCP_OPTION OptionInfo;
    WCHAR NameBuffer[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR NameAppend;
    WCHAR CommentBuffer[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR CommentAppend;
    WCHAR IDKey[SCRATCH_SMALL_BUFFER_SIZE];

    wcscpy( NameBuffer, L"OptionName (NEW) ");
    NameAppend = NameBuffer + wcslen(NameBuffer);
    wcscpy( CommentBuffer, L"OptionComment (NEW) ");
    CommentAppend = CommentBuffer + wcslen(CommentBuffer);

    ScopeInfo.ScopeType = DhcpDefaultOptions;
    ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;

    Error = DhcpEnumOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptionValues failed %ld\n", Error );
        ReturnError = Error;
    }
    else {
        DWORD i;
        LPDHCP_OPTION_VALUE Options;
        DWORD NumOptions;

        printf("\tDhcpEnumOptionValues successfully returned.\n");

        Options = OptionsArray->Values;
        NumOptions = OptionsArray->NumElements;
        for( i = 0; i < NumOptions; i++, Options++ ) {

            OptionID = Options->OptionID;
            DhcpRegOptionIdToKey( OptionID, IDKey );
            OptionInfo.OptionID = OptionID;

            wcscpy( NameAppend, IDKey);
            OptionInfo.OptionName = NameBuffer;

            wcscpy( CommentAppend, IDKey);
            OptionInfo.OptionComment = CommentBuffer;

            OptionID = Options->OptionID;
            CreateOptionValue( OptionID, &OptionInfo.DefaultValue );

            Error = DhcpSetOptionInfo(
                        GlobalServerIpAddress,
                        OptionID,
                        &OptionInfo );

            if( Error != ERROR_SUCCESS ) {
                printf("DhcpSetOptionInfo failed to set %ld Option, %ld\n",
                        (DWORD)OptionID, Error );
                ReturnError = Error;
            }
            else {
                printf("Option %ld successfully set.\n", (DWORD)OptionID );
            }

        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }
    return( ReturnError );
}

DWORD
TestDhcpGetOptionInfo(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;

    ScopeInfo.ScopeType = DhcpDefaultOptions;
    ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;

    Error = DhcpEnumOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptionValues failed %ld\n", Error );
    }
    else {
        DWORD i;
        LPDHCP_OPTION_VALUE Options;
        DWORD NumOptions;
        LPDHCP_OPTION OptionInfo = NULL;
        DHCP_OPTION_ID OptionID;

        printf("\tDhcpEnumOptionValues successfully returned.\n");

        Options = OptionsArray->Values;
        NumOptions = OptionsArray->NumElements;
        for( i = 0; i < NumOptions; i++, Options++ ) {

             OptionID = Options->OptionID;
             Error = DhcpGetOptionInfo(
                         GlobalServerIpAddress,
                         OptionID,
                         &OptionInfo );

             if( Error != ERROR_SUCCESS ) {
                 printf("DhcpGetOptionInfo failed to retrieve %ld Option, %ld\n",
                             (DWORD)OptionID, Error );
                 ReturnError = Error;
             }
             else {
                 printf("Option %ld successfully Retrived.\n", (DWORD)OptionID );
                 PrintOptionInfo( OptionInfo );
             }

             if( OptionInfo != NULL ) {
                 DhcpRpcFreeMemory( OptionInfo );
                 OptionInfo = NULL;
             }
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }
    return( ReturnError );
}

DWORD
TestDhcpGetOptionInfo1(
    VOID
    )
{
    DWORD Error;
    LPDHCP_OPTION_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;

    printf("+++***********************************************+++" );
    Error = DhcpEnumOptions(
                GlobalServerIpAddress,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptions failed %ld\n", Error );
    }
    else {

        DWORD i;
        LPDHCP_OPTION Options;
        DWORD NumOptions;

        printf("\tDhcpEnumOptions successfully returned.\n");
        printf("\tOptionsRead = %ld.\n", OptionsRead);
        printf("\tOptionsTotal = %ld.\n", OptionsTotal);

        Options = OptionsArray->Options;
        NumOptions = OptionsArray->NumElements;

        for( i = 0; i < NumOptions; i++, Options++ ) {

            PrintOptionInfo( Options );
        }

        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }

    printf("+++***********************************************+++" );
    return( Error );
}

DWORD
TestDhcpRemoveOption(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;

    ScopeInfo.ScopeType = DhcpDefaultOptions;
    ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;

    Error = DhcpEnumOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptionValues failed %ld\n", Error );
        ReturnError = Error;
    }
    else {
        DWORD i;
        LPDHCP_OPTION_VALUE Options;
        DWORD NumOptions;
        DHCP_OPTION_ID OptionID;

        printf("\tDhcpEnumOptionValues successfully returned.\n");

        Options = OptionsArray->Values;
        NumOptions = OptionsArray->NumElements;
        for( i = 0; i < NumOptions; i++, Options++ ) {

             OptionID = Options->OptionID;
             Error = DhcpRemoveOption(
                         GlobalServerIpAddress,
                         OptionID );

             if( Error != ERROR_SUCCESS ) {
                 printf("DhcpRemoveOption failed to remove %ld Option, %ld\n",
                     (DWORD)OptionID, Error );
                 ReturnError = Error;
             }
             else {
                 printf("Option %ld successfully removed.\n",
                         (DWORD)OptionID );
             }
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }
    return( ReturnError );
}

DWORD
TestDhcpSetOptionValue(
    DHCP_OPTION_SCOPE_TYPE Scope,
    LPSTR SubnetAddress,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DWORD i;
    DWORD ReturnError = ERROR_SUCCESS;
    DWORD NumGlobalOption;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    NumGlobalOption = RandN(CREATE_MAX_OPTION_VALUES);

   ScopeInfo.ScopeType = Scope;

   switch( Scope ) {
   case DhcpDefaultOptions:
       printf("Setting Default Option.\n");
       ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
       break;
   case DhcpGlobalOptions:
       printf("Setting Global Option.\n");
       ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
       break;
   case DhcpSubnetOptions:
       printf("Setting Subnet Option.\n");
       ScopeInfo.ScopeInfo.SubnetScopeInfo =
           DhcpDottedStringToIpAddress(SubnetAddress);
       break;
   case DhcpReservedOptions:
       printf("Setting Reserved Option.\n");
       ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
           DhcpDottedStringToIpAddress(SubnetAddress);
       ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
           DhcpDottedStringToIpAddress(ReserveIpAddressString);
       break;
   default:
       printf("TestDhcpSetOptionValue: Unknown OptionType \n");
       return(ERROR_INVALID_PARAMETER);
   }

    for( i = 0; i < NumGlobalOption; i++ ) {

        OptionID = (DHCP_OPTION_ID) RandN(255);
        CreateOptionValue( OptionID, &OptionValue );

        Error = DhcpSetOptionValue(
                    GlobalServerIpAddress,
                    OptionID,
                    &ScopeInfo,
                    &OptionValue );

        if( Error != ERROR_SUCCESS ) {
            printf("\tDhcpSetOptionValue failed to set Option %ld, %ld\n",
                (DWORD)OptionID, Error );
            ReturnError = Error;
        }
        else {
            printf("\tOption %ld successfully set.\n", (DWORD)OptionID);
        }
    }
    return( ReturnError );
}

DWORD
TestDhcpSetOptionValue1(
    DHCP_OPTION_SCOPE_TYPE Scope,
    LPSTR SubnetAddress,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DWORD i;

    DWORD NumGlobalOption;
    DHCP_OPTION_VALUE_ARRAY OptionValues;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    printf("---***********************************************---" );

    NumGlobalOption = RandN(CREATE_MAX_OPTION_VALUES);

    ScopeInfo.ScopeType = Scope;

    OptionValues.NumElements = 0;
    OptionValues.Values = NULL;

    switch( Scope ) {
    case DhcpDefaultOptions:
        printf("Setting Default Option.\n");
        ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
        break;
    case DhcpGlobalOptions:
        printf("Setting Global Option.\n");
        ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
        break;
    case DhcpSubnetOptions:
        printf("Setting Subnet Option.\n");
        ScopeInfo.ScopeInfo.SubnetScopeInfo =
            DhcpDottedStringToIpAddress(SubnetAddress);
        break;
    case DhcpReservedOptions:
        printf("Setting Reserved Option.\n");
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
            DhcpDottedStringToIpAddress(SubnetAddress);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
            DhcpDottedStringToIpAddress(ReserveIpAddressString);
        break;
    default:
        printf("TestDhcpSetOptionValue1: Unknown OptionType \n");
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // allocate memory for option value array.
    //

    OptionValues.NumElements = NumGlobalOption;
    OptionValues.Values = DhcpAllocateMemory(
                            sizeof(DHCP_OPTION_VALUE) *
                            NumGlobalOption );

    if( OptionValues.Values == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    for( i = 0; i < NumGlobalOption; i++ ) {
        LPBYTE ScratchBuffer;

        OptionValues.Values[i].OptionID = (DHCP_OPTION_ID) RandN(255);

        ScratchBuffer = DhcpAllocateMemory( SCRATCH_BUFFER_SIZE );
        if( ScratchBuffer == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        CreateOptionValue1(
            OptionValues.Values[i].OptionID,
            &OptionValues.Values[i].Value,
            ScratchBuffer );
    }

    Error = DhcpSetOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &OptionValues );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpSetOptionValues failed, %ld\n", Error );
    }
    else {
        printf("\tDhcpSetOptionValues successfully set.\n");
    }

Cleanup:

    if( OptionValues.Values != NULL ) {
        for( i = 0; i < NumGlobalOption; i++ ) {
            DhcpFreeMemory( OptionValues.Values[i].Value.Elements );
        }
        DhcpFreeMemory( OptionValues.Values );
    }

    printf("---***********************************************---" );
    return( Error );
}

DWORD
TestDhcpGetOptionValue(
    DHCP_OPTION_SCOPE_TYPE Scope,
    LPSTR SubnetAddress,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DWORD i;
    DWORD ReturnError = ERROR_SUCCESS;
    LPDHCP_OPTION_VALUE OptionValue = NULL;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    ScopeInfo.ScopeType = Scope;
    switch( Scope ) {
    case DhcpDefaultOptions:
        printf("Getting Default Option.\n");
        ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
        break;
    case DhcpGlobalOptions:
        printf("Getting Global Option.\n");
        ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
        break;
    case DhcpSubnetOptions:
        printf("Getting Subnet Option.\n");
        ScopeInfo.ScopeInfo.SubnetScopeInfo =
            DhcpDottedStringToIpAddress(SubnetAddress);
        break;
    case DhcpReservedOptions:
        printf("Getting Reserved Option.\n");
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
            DhcpDottedStringToIpAddress(SubnetAddress);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
            DhcpDottedStringToIpAddress(ReserveIpAddressString);
        break;
    default:
        printf("TestDhcpGetOptionValue: Unknown OptionType \n");
        return(ERROR_INVALID_PARAMETER);
    }

    for( i = 0; i < 255; i++ ) {

        OptionID = (DHCP_OPTION_ID) i;

        Error = DhcpGetOptionValue(
                    GlobalServerIpAddress,
                    OptionID,
                    &ScopeInfo,
                    &OptionValue );

        if( Error != ERROR_SUCCESS ) {
            printf("\tDhcpGetOptionValue failed to get Option %ld, %ld\n",
                (DWORD)OptionID, Error );
            ReturnError = Error;
        }
        else {
            printf("\tOption %ld successfully got.\n",
                (DWORD)OptionValue->OptionID);
            PrintOptionValue( &OptionValue->Value );
            DhcpRpcFreeMemory( OptionValue );
            OptionValue = NULL;
        }
    }

    return( ReturnError );
}

DWORD
TestDhcpEnumOptionValues(
    DHCP_OPTION_SCOPE_TYPE Scope,
    LPSTR SubnetAddress,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;


    ScopeInfo.ScopeType = Scope;

    switch( Scope ) {
    case DhcpDefaultOptions:
        printf("Enum Default Option.\n");
        ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
        break;
    case DhcpGlobalOptions:
        printf("Enum Global Option.\n");
        ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
        break;
    case DhcpSubnetOptions:
        printf("Enum Subnet Option.\n");
        ScopeInfo.ScopeInfo.SubnetScopeInfo =
            DhcpDottedStringToIpAddress(SubnetAddress);
        break;
    case DhcpReservedOptions:
        printf("Enum Reserved Option.\n");
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
            DhcpDottedStringToIpAddress(SubnetAddress);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
            DhcpDottedStringToIpAddress(ReserveIpAddressString);
        break;
    default:
        printf("TestDhcpEnumOptionValues: Unknown OptionType \n");
        return(ERROR_INVALID_PARAMETER);
    }

    Error = DhcpEnumOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptionValues failed %ld\n", Error );
    }
    else {
        DWORD i;
        LPDHCP_OPTION_VALUE Options;
        DWORD NumOptions;

        printf("\tDhcpEnumOptionValues successfully returned.\n");

        Options = OptionsArray->Values;
        NumOptions = OptionsArray->NumElements;
        for( i = 0; i < NumOptions; i++, Options++ ) {
            printf("\tOptionID = %ld\n", (DWORD)Options->OptionID);
            PrintOptionValue( &Options->Value );
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }
    return( Error );
}

DWORD
TestDhcpRemoveOptionValues(
    DHCP_OPTION_SCOPE_TYPE Scope,
    LPSTR SubnetAddress,
    LPSTR ReserveIpAddressString
    )
{
    DWORD Error;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY OptionsArray;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;


    ScopeInfo.ScopeType = Scope;

    switch( Scope ) {
    case DhcpDefaultOptions:
        printf("Removing Default Option.\n");
        ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
        break;
    case DhcpGlobalOptions:
        printf("Removing Global Option.\n");
        ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
        break;
    case DhcpSubnetOptions:
        printf("Removing Subnet Option.\n");
        ScopeInfo.ScopeInfo.SubnetScopeInfo =
            DhcpDottedStringToIpAddress(SubnetAddress);
        break;
    case DhcpReservedOptions:
        printf("Removing Reserved Option.\n");
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
            DhcpDottedStringToIpAddress(SubnetAddress);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
            DhcpDottedStringToIpAddress(ReserveIpAddressString);
        break;
    default:
        printf("TestDhcpRemoveOptionValues: Unknown OptionType \n");
        return(ERROR_INVALID_PARAMETER);
    }

    Error = DhcpEnumOptionValues(
                GlobalServerIpAddress,
                &ScopeInfo,
                &ResumeHandle,
                0xFFFFFFFF,  // get all.
                &OptionsArray,
                &OptionsRead,
                &OptionsTotal );

    if( Error != ERROR_SUCCESS ) {
        printf("\tDhcpEnumOptionValues failed %ld\n", Error );
    }
    else {
        DWORD i;
        LPDHCP_OPTION_VALUE Options;
        DWORD NumOptions;

        printf("\tDhcpEnumOptionValues successfully returned.\n");

        Options = OptionsArray->Values;
        NumOptions = OptionsArray->NumElements;
        for( i = 0; i < NumOptions; i++, Options++ ) {
            DWORD LocalError;

            printf("\tRemoving OptionID = %ld\n", (DWORD)Options->OptionID);

            LocalError = DhcpRemoveOptionValue(
                            GlobalServerIpAddress,
                            Options->OptionID,
                            &ScopeInfo );

            if( LocalError != ERROR_SUCCESS ) {
                printf("\tDhcpRemoveOptionValue failed %ld\n", LocalError );
            }
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }
    return( Error );
}

DWORD
TestDhcpEnumSubnetClients(
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
{
    return( ERROR_CALL_NOT_IMPLEMENTED);
}

DWORD
TestDhcpGetClientOptions(
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    )
{
    return( ERROR_CALL_NOT_IMPLEMENTED);
}

VOID
TestDhcpSubnetAPIs(
    VOID
    )
{
    DWORD Error;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY EnumElementInfo = NULL;

    //
    // test DhcpCreateSubnet
    //

    Error = TestDhcpCreateSubnet(
                "11.1.0.0",
                0xFFFF0000,
                L"Subnet1",
                L"Subnet1 Comment",
                "11.1.1.1",
                L"Subnet1PrimaryHostName",
                L"Subnet1PrimaryNBName",
                DhcpSubnetEnabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.1.0.0", Error );

    Error = TestDhcpCreateSubnet(
                "11.2.0.0",
                0xFFFF0000,
                L"Subnet2",
                L"Subnet2 Comment",
                "11.2.1.1",
                L"Subnet2PrimaryHostName",
                L"Subnet2PrimaryNBName",
                DhcpSubnetDisabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.2.0.0", Error );

    Error = TestDhcpCreateSubnet(
                "11.3.0.0",
                0xFFFF0000,
                L"Subnet3",
                L"Subnet3 Comment",
                "11.3.1.1",
                L"Subnet3PrimaryHostName",
                L"Subnet3PrimaryNBName",
                DhcpSubnetDisabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.3.0.0", Error );

    Error = TestDhcpCreateSubnet(
                "11.4.0.0",
                0xFFFF0000,
                L"Subnet4",
                L"Subnet4 Comment",
                "11.4.1.1",
                L"Subnet4PrimaryHostName",
                L"Subnet4PrimaryNBName",
                DhcpSubnetDisabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.4.0.0", Error );

    Error = TestDhcpCreateSubnet(
                "11.5.0.0",
                0xFFFF0000,
                L"Subnet5",
                L"Subnet5 Comment",
                "11.5.1.1",
                NULL,
                NULL,
                DhcpSubnetDisabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.5.0.0", Error );

    Error = TestDhcpCreateSubnet(
                "11.6.0.0",
                0xFFFF0000,
                L"Subnet6",
                NULL,
                "11.6.1.1",
                NULL,
                NULL,
                DhcpSubnetDisabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n", "11.6.0.0", Error );

    //
    // DhcpSetSubnetInfo
    //

    Error = TestDhcpSetSubnetInfo(
                "11.5.0.0",
                0xFFFF0000,
                L"Subnet5",
                L"Subnet5 Comment",
                "11.5.1.1",
                L"Subnet5PrimaryHostName",
                L"Subnet5PrimaryNBName",
                DhcpSubnetDisabled
                );
    printf("TestDhcpSetSubnetInfo(%s) result = %ld.\n", "11.5.0.0", Error );

    Error = TestDhcpSetSubnetInfo(
                "11.6.0.0",
                0xFFFF0000,
                L"Subnet6",
                L"Subnet6 Comment",
                "11.6.1.1",
                NULL,
                NULL,
                DhcpSubnetDisabled
                );
    printf("TestDhcpSetSubnetInfo(%s) result = %ld.\n", "11.6.0.0", Error );

    //
    // DhcpGetSubnetInfo
    //

    Error = TestDhcpGetSubnetInfo(
                "11.1.0.0",
                &SubnetInfo
                );
    printf("TestDhcpGetSubnetInfo(%s) result = %ld.\n", "11.1.0.0", Error );

    if( Error == ERROR_SUCCESS ) {

        TestPrintSubnetInfo( SubnetInfo );

        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }


    Error = TestDhcpGetSubnetInfo(
                "11.3.0.0",
                &SubnetInfo
                );
    printf("TestDhcpGetSubnetInfo(%s) result = %ld.\n", "11.3.0.0", Error );

    if( Error == ERROR_SUCCESS ) {

        TestPrintSubnetInfo( SubnetInfo );

        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }


    Error = TestDhcpGetSubnetInfo(
                "11.5.0.0",
                &SubnetInfo
                );
    printf("TestDhcpGetSubnetInfo(%s) result = %ld.\n", "11.5.0.0", Error );

    if( Error == ERROR_SUCCESS ) {

        TestPrintSubnetInfo( SubnetInfo );

        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }

    //
    // DhcpGet/SetSubnetInfo
    //

    Error = TestDhcpGetSubnetInfo(
                "11.6.0.0",
                &SubnetInfo
                );
    printf("TestDhcpGetSubnetInfo(%s) result = %ld.\n", "11.6.0.0", Error );

    if( Error == ERROR_SUCCESS ) {

        TestPrintSubnetInfo( SubnetInfo );

        //
        // reset comment.
        //

        SubnetInfo->PrimaryHost.HostName = L"Subnet6PrimaryHostName";
        SubnetInfo->PrimaryHost.NetBiosName = L"Subnet6PrimaryNBName";

        Error = Test1DhcpSetSubnetInfo( SubnetInfo );
        printf("TestDhcpSetSubnetInfo(%s) result = %ld.\n", "11.6.0.0", Error );

        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }

    //
    // add DHCP IP Ranges.
    //

    Error = TestAddSubnetIpRange( "11.1.0.0", "11.1.0.0", "11.1.0.255" );
    printf("TestAddSubnetIpRange(%s) result = %ld.\n", "11.1.0.0", Error );

    //
    // add 2 DHCP IP Ranges.
    //

    Error = TestAddSubnetIpRange( "11.2.0.0", "11.2.1.0", "11.2.1.255" );
    printf("TestAddSubnetIpRange(%s) result = %ld.\n", "11.2.0.0", Error );
    Error = TestAddSubnetIpRange( "11.2.0.0", "11.2.2.0", "11.2.2.255" );
    printf("TestAddSubnetIpRange(%s) result = %ld.\n", "11.2.0.0", Error );

    //
    // add secondary host.
    //

    Error = TestAddSecondaryHost(
                "11.3.0.0", "11.3.11.129",
                L"SecondaryNBName",
                L"SecondaryHostName" );
    printf("TestAddSecondaryHost(%s) result = %ld.\n", "11.3.0.0", Error );


    //
    // Add Reserve IpAddress
    //

    Error = TestAddReserveIpAddress(
                "11.4.0.0", "11.4.111.222", "ReservedIp 11.4.111.222" );
    printf("TestAddReserveIpAddress(%s) result = %ld.\n", "11.4.0.0",
    Error );

    //
    // Add Exclude DHCP IP Ranges.
    //

    Error = TestAddExcludeSubnetIpRange(
                "11.5.0.0",
                "11.5.0.100",
                "11.5.0.255" );
    printf("TestAddExcludeSubnetIpRange(%s) result = %ld.\n",
            "11.5.0.0",
            Error );

    //
    // Exclude 2 DHCP IP Ranges.
    //

    Error = TestAddExcludeSubnetIpRange(
                "11.6.0.0",
                "11.6.3.200",
                "11.6.3.255" );
    printf("TestAddExcludeSubnetIpRange(%s) result = %ld.\n",
                "11.6.0.0",
                Error );
    Error = TestAddExcludeSubnetIpRange(
                "11.6.0.0",
                "11.6.5.100",
                "11.6.5.200" );
    printf("TestAddExcludeSubnetIpRange(%s) result = %ld.\n",
                "11.6.0.0",
                Error );

    //
    // test subnet enum
    //

    Error = TestDhcpEnumSubnetElements(
                "11.2.0.0",
                DhcpIpRanges,
                &EnumElementInfo );
    printf("TestDhcpEnumSubnetElements(%s) result = %ld.\n", "11.2.0.0", Error );

    if( Error == ERROR_SUCCESS ) {
        TestPrintSubnetEnumInfo( EnumElementInfo );
        DhcpRpcFreeMemory( EnumElementInfo );
        EnumElementInfo = NULL;
    }

    Error = TestDhcpEnumSubnetElements(
                "11.3.0.0",
                DhcpSecondaryHosts,
                &EnumElementInfo);
    printf("TestDhcpEnumSubnetElements(%s) result = %ld.\n", "11.3.0.0", Error );


    if( Error == ERROR_SUCCESS ) {
        TestPrintSubnetEnumInfo( EnumElementInfo );
        DhcpRpcFreeMemory( EnumElementInfo );
        EnumElementInfo = NULL;
    }

    Error = TestDhcpEnumSubnetElements(
                "11.4.0.0",
                DhcpReservedIps,
                &EnumElementInfo);
    printf("TestDhcpEnumSubnetElements(%s) result = %ld.\n",
                "11.4.0.0",
                Error );

    Error = TestDhcpEnumSubnetElements(
                "11.6.0.0",
                DhcpExcludedIpRanges,
                &EnumElementInfo);
    printf("TestDhcpEnumSubnetElements(%s) result = %ld.\n",
                "11.6.0.0",
                Error );

    Error = Test1DhcpEnumSubnetElements(
                "11.6.0.0",
                DhcpExcludedIpRanges,
                32 );   // small buffer

    printf("Test1DhcpEnumSubnetElements(%s) result = %ld.\n",
                "11.6.0.0", Error );


}

VOID
TestDhcpOptionAPIs(
    VOID
    )
{
    DWORD Error;

    Error = TestDhcpCreateOption();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpCreateOption failed, %ld.\n", Error );
    }

    Error = TestDhcpGetOptionInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpGetOptionInfo failed, %ld.\n", Error );
    }

    Error = TestDhcpGetOptionInfo1();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpGetOptionInfo1 failed, %ld.\n", Error );
    }

    Error = TestDhcpSetOptionInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionInfo failed, %ld.\n", Error );
    }

    Error = TestDhcpGetOptionInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpGetOptionInfo failed, %ld.\n", Error );
    }


    Error = TestDhcpSetOptionValue(
                DhcpDefaultOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionValue failed, %ld.\n", Error );
    }

    Error = TestDhcpEnumOptionValues(
                DhcpDefaultOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpEnumOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpSetOptionValue(
                DhcpGlobalOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionValue failed, %ld.\n", Error );
    }

    Error = TestDhcpEnumOptionValues(
                DhcpGlobalOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpEnumOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpSetOptionValue1(
                DhcpGlobalOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionValue1 failed, %ld.\n", Error );
    }

    Error = TestDhcpEnumOptionValues(
                DhcpGlobalOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpEnumOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpSetOptionValue(
                DhcpSubnetOptions,
                "11.1.0.0",
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionValue failed, %ld.\n", Error );
    }

    Error = TestDhcpEnumOptionValues(
                DhcpSubnetOptions,
                "11.1.0.0",
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpEnumOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpSetOptionValue(
                DhcpReservedOptions,
                "11.4.0.0",
                "11.4.111.222");
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpSetOptionValue failed, %ld.\n", Error );
    }

    Error = TestDhcpEnumOptionValues(
                DhcpReservedOptions,
                "11.4.0.0",
                "11.4.111.222");
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpEnumOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpRemoveOptionValues(
                DhcpGlobalOptions,
                NULL,
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpRemoveOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpRemoveOptionValues(
                DhcpSubnetOptions,
                "11.1.0.0",
                NULL );
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpRemoveOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpRemoveOptionValues(
                DhcpReservedOptions,
                "11.4.0.0",
                "11.4.111.222");
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpRemoveOptionValues failed, %ld.\n", Error );
    }

    Error = TestDhcpRemoveOption();
    if( Error != ERROR_SUCCESS) {
        printf("TestDhcpRemoveOption failed, %ld.\n", Error );
    }
}

DWORD
TestCreateClient(
    LPSTR SubnetAddress,
    DWORD Count
    )
{
    DWORD Error;
    DWORD ReturnError;
    DWORD i;
    DHCP_CLIENT_INFO ClientInfo;
    DHCP_IP_ADDRESS IpAddress;
    WCHAR ClientName[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR NameAppend;
    WCHAR ClientComment[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR CommentAppend;
    WCHAR Key[SCRATCH_SMALL_BUFFER_SIZE];
    BYTE BinaryData[RANDOM_BINARY_DATA_MAX_LEN];


    //
    // create clients;

    wcscpy( ClientName, L"Client Name ");
    NameAppend = ClientName + wcslen(ClientName);
    wcscpy( ClientComment, L"Client Comment ");
    CommentAppend = ClientComment + wcslen(ClientComment);

    IpAddress = DhcpDottedStringToIpAddress(SubnetAddress);

    ClientInfo.SubnetMask = 0xFFFF0000;
    ClientInfo.ClientName = ClientName;
    ClientInfo.ClientComment = ClientComment;

    ClientInfo.ClientHardwareAddress.DataLength = 0;
    ClientInfo.ClientHardwareAddress.Data = BinaryData;

    ClientInfo.OwnerHost.IpAddress = 0;
    ClientInfo.OwnerHost.NetBiosName = NULL;
    ClientInfo.OwnerHost.HostName = NULL;

    for( i = 1; i < Count; i++) {

        ClientInfo.ClientIpAddress = IpAddress + i;
        RandBinaryData( &ClientInfo.ClientHardwareAddress );

        DhcpRegOptionIdToKey(i, Key);
        wcscpy( NameAppend, Key ); // make "Client Name 001" like this.
        wcscpy( CommentAppend, Key );

        ClientInfo.ClientLeaseExpires = DhcpCalculateTime( RandWord() );

        Error = DhcpCreateClientInfo(
                    GlobalServerIpAddress,
                    &ClientInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpCreateClientInfo failed, %ld.\n", Error );
            ReturnError = Error;
        }

        printf("DhcpCreateClientInfo, %ld.\n", i);
    }

    return( ReturnError );
}

VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    printf("ClientInfo : ");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->SubnetMask));

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    printf("\tClient Hardware Address Length = %ld.\n", DataLength );
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tComment = %ws.\n", ClientInfo->ClientComment);
    printf("\tExpires = %lx %lx.\n",
        ClientInfo->ClientLeaseExpires.dwHighDateTime,
        ClientInfo->ClientLeaseExpires.dwLowDateTime);

    printf("\tOwner Host IP Address = %ld.\n",
                ClientInfo->OwnerHost.IpAddress );
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

}

DWORD
TestGetClientInfo(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    BYTE i;
    WCHAR ClientName[SCRATCH_SMALL_BUFFER_SIZE];
    LPWSTR NameAppend;
    WCHAR Key[SCRATCH_SMALL_BUFFER_SIZE];
    DHCP_SEARCH_INFO SearchInfo;
    LPDHCP_CLIENT_INFO ClientInfo;

    wcscpy( ClientName, L"Client Name ");
    NameAppend = ClientName + wcslen(ClientName);
    SearchInfo.SearchType = DhcpClientName;
    SearchInfo.SearchInfo.ClientName = ClientName;

    for( i = 0; i < CLIENT_COUNT; i++) {

        wcscpy( NameAppend, DhcpRegOptionIdToKey(i, Key) );

        Error = DhcpGetClientInfo(
                    GlobalServerIpAddress,
                    &SearchInfo,
                    &ClientInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpGetClientInfo failed, %ld.\n", Error );
            ReturnError = Error;
            continue;
        }

        PrintClientInfo( ClientInfo );
        DhcpRpcFreeMemory( ClientInfo );
    }

    return( ReturnError );
}

DWORD
TestSetClientInfo(
    VOID
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DHCP_SEARCH_INFO SearchInfo;
    DWORD i;

    Error = DhcpEnumSubnetClients(
                GlobalServerIpAddress,
                0,
                &ResumeHandle,
                (DWORD)(-1),
                &ClientEnumInfo,
                &ClientsRead,
                &ClientsTotal );

    if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
        printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
        return( Error );
    }

    DhcpAssert( ClientEnumInfo != NULL );
    DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

    if( Error == ERROR_MORE_DATA ) {
        printf("DhcpEnumSubnetClients returned ERROR_MORE_DATA.\n");
    }

    //
    // set client info.
    //

    SearchInfo.SearchType = DhcpClientHardwareAddress;

    for( i = 0; i < ClientsRead; i++ ) {

        WCHAR ClientComment[SCRATCH_SMALL_BUFFER_SIZE];
        LPDHCP_CLIENT_INFO ClientInfo = NULL;

        SearchInfo.SearchInfo.ClientHardwareAddress =
            ClientEnumInfo->Clients[i]->ClientHardwareAddress;

        ClientInfo = NULL;
        Error = DhcpGetClientInfo(
                    GlobalServerIpAddress,
                    &SearchInfo,
                    &ClientInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpGetClientInfo failed, %ld.\n", Error );
            ReturnError = Error;
            continue;
        }

        DhcpAssert( ClientInfo != NULL);

        //
        // modify client comment.
        //

        if(  ClientInfo->ClientComment != NULL ) {
            wcscpy( ClientComment, ClientInfo->ClientComment);
            wcscat( ClientComment, L" - New" );
        }
        else {
            wcscpy( ClientComment, L" - New" );
        }

        ClientInfo->ClientComment = ClientComment;

        Error = DhcpSetClientInfo(
                    GlobalServerIpAddress,
                    ClientInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpSetClientInfo failed, %ld.\n", Error );
            ReturnError = Error;
        }
        DhcpRpcFreeMemory( ClientInfo );
        ClientInfo = NULL;
    }

    DhcpRpcFreeMemory( ClientEnumInfo );

    return( ReturnError );
}

DWORD
TestEnumClients(
    LPSTR SubnetAddress
    )
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;

    Error = DhcpEnumSubnetClients(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                &ResumeHandle,
                (DWORD)(-1),
                &ClientEnumInfo,
                &ClientsRead,
                &ClientsTotal );

    if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
        printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
        return( Error );
    }

    DhcpAssert( ClientEnumInfo != NULL );
    DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

    printf("Num Client info read = %ld.\n", ClientsRead );
    printf("Total Client count = %ld.\n", ClientsTotal );

    for( i = 0; i < ClientsRead; i++ ) {
        PrintClientInfo( ClientEnumInfo->Clients[i] );
    }

    DhcpRpcFreeMemory( ClientEnumInfo );

    return(Error);
}

DWORD
TestDeleteClients(
    LPSTR SubnetAddress
    )
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DHCP_SEARCH_INFO SearchInfo;
    DWORD i;

    Error = DhcpEnumSubnetClients(
                GlobalServerIpAddress,
                DhcpDottedStringToIpAddress(SubnetAddress),
                &ResumeHandle,
                (DWORD)(-1),
                &ClientEnumInfo,
                &ClientsRead,
                &ClientsTotal );

    if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
        printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
        return( Error );
    }

    DhcpAssert( ClientEnumInfo != NULL );
    DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

    if( Error == ERROR_MORE_DATA ) {
        printf("DhcpEnumSubnetClients returned ERROR_MORE_DATA.\n");
    }

    //
    // delete clients.
    //

    SearchInfo.SearchType = DhcpClientIpAddress;

    for( i = 0; i < ClientsRead; i++ ) {

        SearchInfo.SearchInfo.ClientIpAddress =
            ClientEnumInfo->Clients[i]->ClientIpAddress;

        Error = DhcpDeleteClientInfo(
                    GlobalServerIpAddress,
                    &SearchInfo );

        if( Error != ERROR_SUCCESS ) {
            printf("DhcpDeleteClientInfo failed, %ld.\n", Error );
            ReturnError = Error;
            continue;
        }
    }

    DhcpRpcFreeMemory( ClientEnumInfo );

    return( ReturnError );
}

VOID
TestDhcpMibApi(
    VOID
    )
{
    DWORD Error;
    LPDHCP_MIB_INFO MibInfo = NULL;
    DWORD i;
    LPSCOPE_MIB_INFO ScopeInfo;
    SYSTEMTIME SystemTime;

    Error = DhcpGetMibInfo(
                GlobalServerIpAddress,
                &MibInfo );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpGetMibInfo failed, %ld.\n", Error );
        return;
    }

    DhcpAssert( MibInfo != NULL );

    printf("Discovers = %d.\n", MibInfo->Discovers);
    printf("Offers = %d.\n", MibInfo->Offers);
    printf("Requests = %d.\n", MibInfo->Requests);
    printf("Acks = %d.\n", MibInfo->Acks);
    printf("Naks = %d.\n", MibInfo->Naks);
    printf("Declines = %d.\n", MibInfo->Declines);
    printf("Releases = %d.\n", MibInfo->Releases);
    printf("ServerStartTime = ");

    if( FileTimeToSystemTime(
            (FILETIME *)(&MibInfo->ServerStartTime),
            &SystemTime ) ) {

        printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    else {
        printf( "Unknown, %ld.\n", GetLastError() );
    }

    printf("Scopes = %d.\n", MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) {
        printf("Subnet = %s.\n",
                    DhcpIpAddressToDottedString(ScopeInfo[i].Subnet));
        printf("\tNumAddressesInuse = %d.\n",
                    ScopeInfo[i].NumAddressesInuse );
        printf("\tNumAddressesFree = %d.\n",
                    ScopeInfo[i].NumAddressesFree );
        printf("\tNumPendingOffers = %d.\n",
                    ScopeInfo[i].NumPendingOffers );
    }

    DhcpRpcFreeMemory( MibInfo );

    return;

}
VOID
TestDhcpClientAPIs(
    VOID
    )
{
    DWORD Error;

    Error = TestCreateClient( "11.1.0.0", CLIENT_COUNT );
    if( Error != ERROR_SUCCESS) {
        printf("TestCreateClient failed, %ld.\n", Error );
    }

    Error = TestGetClientInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestCreateClient failed, %ld.\n", Error );
    }

    Error = TestSetClientInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestCreateClient failed, %ld.\n", Error );
    }

    Error = TestGetClientInfo();
    if( Error != ERROR_SUCCESS) {
        printf("TestCreateClient failed, %ld.\n", Error );
    }

    Error = TestEnumClients("11.1.0.0");
    if( Error != ERROR_SUCCESS) {
        printf("TestEnumClients failed, %ld.\n", Error );
    }

}

VOID
TestDhcpRemoveDhcpAPIs(
    VOID
    )
{
    DWORD Error;

    Error = TestDeleteClients("11.1.0.0");
    if( Error != ERROR_SUCCESS) {
        printf("TestEnumClients failed, %ld.\n", Error );
    }

    //
    // remove Ip Ranges.
    //

    Error = TestRemoveSubnetIpRange( "11.2.0.0", "11.2.1.0", "11.2.1.255" );
    printf("TestRemoveSubnetIpRange(%s) result = %ld.\n", "11.2.0.0", Error );

    //
    // Remove secondary host.
    //

    Error = TestRemoveSecondaryHost( "11.3.0.0", "11.3.11.129" );
    printf("TestRemoveSecondaryHost(%s) result = %ld.\n", "11.3.0.0", Error );

    //
    // Remove Reserve IpAddress
    //

    Error = TestRemoveReserveIpAddress( "11.4.0.0", "11.4.111.222" );
    printf("TestRemoveReserveIpAddress(%s) result = %ld.\n",
                "11.4.0.0",
                Error );

    //
    // Remove Exclude IpRanges
    //

    Error = TestRemoveExcludeSubnetIpRange(
                "11.5.0.0",
                "11.5.0.100",
                "11.5.0.255" );
    printf("TestRemoveExcludeSubnetIpRange(%s) result = %ld.\n",
                "11.5.0.0",
                Error );

    Error = TestRemoveExcludeSubnetIpRange(
                "11.6.0.0",
                "11.6.3.200",
                "11.6.3.255" );
    printf("TestRemoveExcludeSubnetIpRange(%s) result = %ld.\n",
                "11.6.0.0",
                Error );
    Error = TestRemoveExcludeSubnetIpRange(
                "11.6.0.0",
                "11.6.5.100",
                "11.6.5.200" );
    printf("TestRemoveExcludeSubnetIpRange(%s) result = %ld.\n",
                "11.6.0.0",
                Error );

    //
    // remove Subnets.
    //

    Error = TestDhcpDeleteSubnet( "11.1.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.1.0.0", Error );

    Error = TestDhcpDeleteSubnet( "11.2.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.2.0.0", Error );

    Error = Test1DhcpDeleteSubnet( "11.2.0.0" );
    printf("Test1DhcpDeleteSubnet(%s) result = %ld.\n", "11.2.0.0", Error );

    Error = TestDhcpDeleteSubnet( "11.3.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.3.0.0", Error );

    Error = TestDhcpDeleteSubnet( "11.4.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.4.0.0", Error );

    Error = TestDhcpDeleteSubnet( "11.5.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.5.0.0", Error );

    Error = TestDhcpDeleteSubnet( "11.6.0.0" );
    printf("TestDhcpDeleteSubnet(%s) result = %ld.\n", "11.6.0.0", Error );


}

VOID
TestDhcpSpecial(
    LPSTR SubnetAddressString,
    LPSTR SubnetMaskString
    )
{
    DWORD Error;
    DHCP_IP_MASK SubnetMask;

    //
    // create a subnet.
    //

    SubnetMask = DhcpDottedStringToIpAddress(SubnetMaskString);
    Error = TestDhcpCreateSubnet(
                SubnetAddressString,
                SubnetMask,
                L"Subnet1",
                L"Subnet1 Comment",
                "127.0.0.1",
                L"Subnet1PrimaryHostName",
                L"Subnet1PrimaryNBName",
                DhcpSubnetEnabled
                );
    printf("TestDhcpCreateSubnet(%s) result = %ld.\n",
                SubnetAddressString, Error );

    if( Error != ERROR_SUCCESS ) {
        return;
    }

    //
    // add subnet IpAddress Range.
    //

    Error = TestAddSubnetIpRange1(
                SubnetAddressString,
                SubnetMask );

    if( Error != ERROR_SUCCESS ) {
        return;
    }

    Error = TestCreateClient(
                SubnetAddressString,
                (~SubnetMask > 10000 ) ? 10000 : ~SubnetMask );
}

DWORD __cdecl
main(
    int argc,
    char **argv
    )
{
    if( argc < 2 ) {
        printf("usage:testapis server-ipaddress <othertests> \n");
        return(1);
    }

    GlobalServerIpAddress = DhcpOemToUnicode( argv[1], NULL );

    if( GlobalServerIpAddress == NULL ) {
        printf("Insufficient memory\n");
        return(1);
    }

    srand( (DWORD)time( NULL ) );

    if( argc == 2 ) {

        TestDhcpSubnetAPIs();
        TestDhcpOptionAPIs();
        TestDhcpClientAPIs();
        TestDhcpMibApi();
        TestDhcpRemoveDhcpAPIs();

    }
    else if( _stricmp(argv[2], "JetTest") == 0 ) {

        if( argc < 5 ) {
            printf("usage:testapis server-ipaddress JetTest subnet-addr subnet-mask \n");
            return(1);
        }

        TestDhcpSpecial( argv[3], argv[4] );
    }

#if 0
    TestEnumClients( "11.1.0.0" );
#endif

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\ddsdmp.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: Dump the dhcp objects in DS (recursively).
//================================================================================

//BeginExport(overview)
//DOC DDSDMP is a command line for dumping the dhcp objects in DS.
//DOC It takes as parameter the DS DC to contact (optional).
//DOC The output is too fluid to spec out at this moment. Hopefully, it would be
//DOC something that would be understood by DDSINI (whenever that gets written).
//EndExport(overview)

//BeginImports(headers)
#include    <hdrmacro.h>
#include    <store.h>
#include    <stdio.h>
#include    <dhcpbas.h>
//EndImports(headers)

//BeginInternal(globals)
static      DWORD                  nTabs = 0;
static      LPWSTR                 RecurseFilter = L"(|(objectClass=dHCPClass)(objectClass=container))" ;
static      WCHAR                  Buffer[1000];
static      WCHAR                  Strings[30][100];
//EndExport(globals)

VOID
ErrorPrint(
    IN      LPSTORE_HANDLE         hStore,
    IN      DWORD                  Result,
    IN      LPWSTR                 Comment
)
{
    if( NULL != hStore ) {
        printf("\n#%ws\n#%ws (errror %ld, 0x%lx)\n", hStore->Location, Comment, Result, Result );
        return;
    }

    printf("\n#%ws (errror %ld, 0x%lx)\n", Comment, Result, Result);
}

LPWSTR
ConvertDWORD(
    IN      DWORD                  d
)
{
    swprintf(Buffer, L"0x%08lx", d);
    return Buffer;
}

#define     HEX(ch)                ( ((ch) < 10)? ((ch) + L'0') : ((ch) + L'A' - 10))

LPWSTR
ConvertBINARY(
    IN      DWORD                  l,
    IN      LPBYTE                 s
)
{
    DWORD                          i;

    i = 0;
    while( l ) {
        Buffer[i++] = HEX(((*s)>>4));
        Buffer[i++] = HEX(((*s) & 0x0F));
        l --; s ++;
    }

    Buffer[i] = L'\0';
    return Buffer;
}

VOID
Print(
    IN      LPWSTR                 Operation,
    IN      DWORD                  Type,
    IN      LPWSTR                 AttributeName
)
{
    DWORD                          i;

    putchar('\n');
    for(i = 1; i < nTabs; i ++ ) printf("    ");
    printf("%ws %ld :%ws", Operation, Type, AttributeName);
}

VOID
PrintMore(
    IN      LPWSTR                 String
)
{
    printf("=%ws", String);
}


VOID
PrintName(
    IN      LPSTORE_HANDLE         hStore
)
{
    DWORD                          i;

    if( 1 == nTabs ) return;

    putchar('\n');
    for(i = 1; i < nTabs; i ++ ) printf("    ");
    printf("object");
}


DWORD
AttributesDmp(
    IN      LPSTORE_HANDLE         hStore
)
{
    DWORD                          Result;
    DWORD                          FoundParams, Type, MScopeId;
    LARGE_INTEGER                  UniqueKey, Flags;
    LPWSTR                         Name, Description, Location;

    Result = DhcpDsGetAttribs(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hStore,
        /* FoundParams          */ &FoundParams,
        /* UniqueKey            */ &UniqueKey,
        /* Type                 */ &Type,
        /* Flags                */ &Flags,
        /* Name                 */ &Name,
        /* Description          */ &Description,
        /* Location             */ &Location,
        /* MScopeId             */ &MScopeId
    );

    if( ERROR_SUCCESS != Result ) return Result;

    if( !DhcpCheckParams(FoundParams, 0) ) {
        Print(L"clear", 0, DHCP_ATTRIB_UNIQUE_KEY);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_UNIQUE_KEY);
        PrintMore(ConvertDWORD(UniqueKey.LowPart));
        PrintMore(L" ");
        PrintMore(ConvertDWORD(UniqueKey.HighPart));
    }

    if( !DhcpCheckParams(FoundParams, 1) ) {
        Print(L"clear", 0, DHCP_ATTRIB_TYPE);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_TYPE);
        PrintMore(ConvertDWORD(Type));
    }
    if( !DhcpCheckParams(FoundParams, 2) ) {
        Print(L"clear", 0, DHCP_ATTRIB_FLAGS);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_FLAGS);
        PrintMore(ConvertDWORD(Flags.LowPart));
        PrintMore(L" ");
        PrintMore(ConvertDWORD(Flags.HighPart));
    }
    if( !DhcpCheckParams(FoundParams, 3) ) {
        Print(L"clear", 0, DHCP_ATTRIB_OBJ_NAME);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_OBJ_NAME);
        PrintMore(Name?Name:L"");
        if( Name ) MemFree(Name);
    }
    if( !DhcpCheckParams(FoundParams, 4) ) {
        Print(L"clear", 0, DHCP_ATTRIB_OBJ_DESCRIPTION);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_OBJ_DESCRIPTION);
        PrintMore(Description?Description:L"");
        if( Description ) MemFree(Description);
    }
    if( !DhcpCheckParams(FoundParams, 5) ) {
        Print(L"clear", 0, DHCP_ATTRIB_LOCATION_DN);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_LOCATION_DN);
        PrintMore(Location?Location:L"");
        if( Location ) MemFree(Location);
    }
    if( !DhcpCheckParams(FoundParams, 6) ) {
        Print(L"clear", 0, DHCP_ATTRIB_MSCOPEID);
    } else {
        Print(L"update", 0, DHCP_ATTRIB_MSCOPEID);
        PrintMore(ConvertDWORD(MScopeId));
    }
    return ERROR_SUCCESS;
}

DWORD
RecurseDmp(
    IN OUT  LPSTORE_HANDLE         hStore
)
{
    DWORD                          Result;
    STORE_HANDLE                   hStore2;

    nTabs ++;
    PrintName(hStore);

    Result = AttributesDmp(hStore);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"AttributesDmp failed");
    }

    Result = StoreSetSearchOneLevel(hStore, 0);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"StoreSetSearchOneLevel failed");
        nTabs --;
        return Result;
    }

    Result = StoreBeginSearch(hStore, 0, RecurseFilter);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"StoreBeginSearch failed");
    } else {
        while ( ERROR_SUCCESS == Result ) {
            Result = StoreSearchGetNext(hStore, 0, &hStore2);
            if( ERROR_SUCCESS != Result ) {
                if( ERROR_FILE_NOT_FOUND == Result ) break;
                if( ERROR_NO_MORE_ITEMS == Result ) break;
                ErrorPrint(hStore, Result, L"StoreSearchGetNext failed");
                break;
            }

            Result = RecurseDmp(&hStore2);
            if( ERROR_SUCCESS != Result ) {
                ErrorPrint(&hStore2, Result, L"RecurseDmp failed");
                break;
            }

            StoreCleanupHandle(&hStore2, 0);
        }

        StoreEndSearch(hStore, 0);
    }

    nTabs --;
    return ERROR_SUCCESS;
}

LPWSTR
ConvertToLPWSTR(
    IN      LPSTR                  s
)
{
    LPWSTR                         u, v;

    if( NULL == s ) return L"";

    u = LocalAlloc(LMEM_FIXED, (strlen(s)+1)*sizeof(WCHAR));
    if( NULL == u ) return L"";

    v = u;
    while( *v++ = *s++)
        ;

    return u;
}


void _cdecl main(
    int     argc,
    char   *argv[]
)
{
    LPWSTR                         RootName;
    STORE_HANDLE                   Store, Store2;
    DWORD                          Result;

    RootName = NULL;
    if( argc > 2 ) {
        printf("Usage: %s ServerToContact\n", argv[0]);
        return;
    }

    if( 2 == argc ) {
        RootName = ConvertToLPWSTR(argv[1]);
        if( NULL == RootName ) {
            printf("RootDN confusing\n");
            return;
        }
    }

    Result = StoreInitHandle(
        &Store, 0, RootName, NULL, NULL, NULL,
        ADS_SECURE_AUTHENTICATION
        );
    if( ERROR_SUCCESS != Result ) {
        printf("StoreInitHandle: %ld\n", Result);
        return;
    }

    Result = StoreGetHandle(
        /* hStore       */ &Store,
        /* Reserved     */ DDS_RESERVED_DWORD,
        /* StoreGetType */ StoreGetChildType,
        /* Path         */ L"CN=NetServices,CN=Services",
        /* hStoreOut    */ &Store2
    );
    if( ERROR_SUCCESS != Result ) {
        printf("Could not get the netservices container\n");
        return;
    }

    StoreCleanupHandle(&Store,0);

    printf("################################################################################\n");
    printf("##  G E N E R E R A T E D   D D S  D U M P                                    ##\n");
    printf("##  command line : (will be filled in future versions)                        ##\n");
    printf("##  DDSMP.EXE 1.0                                                             ##\n");
    printf("################################################################################\n");
    printf("object %ws", RootName);

    RecurseDmp(&Store2);
    putchar('\n');

    exit(0);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\rpcbind.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the
    DHCP server service.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpcli.h"

static WCHAR LocalMachineName[MAX_COMPUTERNAME_LENGTH + 1] = L"";

DWORD
FindProtocolToUse(
    LPWSTR ServerIpAddress
    )
/*++

Routine Description:

    This function returns the protocol binding to be used. It examines
    the ServerIpAddress string, if it is :

    1. NULL or local IPAddress or Local Name - use "ncalrpc"
    2. IpAddress - (of the  form "ppp.qqq.rrr.sss") -   use "ncacn_ip_tcp"
    3. otherwise use "ncacn_np" protocol.


Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    One of the following values :

        DHCP_SERVER_USE_RPC_OVER_TCPIP  0x1
        DHCP_SERVER_USE_RPC_OVER_NP     0x2
        DHCP_SERVER_USE_RPC_OVER_LPC    0x4

--*/
{
    DWORD DotCount = 0;
    LPWSTR String = ServerIpAddress;
    DWORD ComputerNameLength;

    if( (ServerIpAddress == NULL) ||
            (*ServerIpAddress == L'\0') ) {

        return( DHCP_SERVER_USE_RPC_OVER_LPC );
    }

    while ( (String = wcschr( String, L'.' )) != NULL ) {

        //
        // found another DOT.
        //

        DotCount++;
        String++;   // skip this dot.
    }

    //
    // if the string has 3 DOTs exactly then this string must represent
    // an IpAddress.
    //

    if( DotCount == 3) {

        //
        // if this is local IP Address, use LPC
        //

        if( _wcsicmp(L"127.0.0.1" , ServerIpAddress) == 0 ) {
            return( DHCP_SERVER_USE_RPC_OVER_LPC );
        }

        //
        // ?? determine whether this address is local IPAddress.
        //

        return(DHCP_SERVER_USE_RPC_OVER_TCPIP);
    }

    //
    // It is a computer name string. Check to see this is local
    // computer name. If so use LPC, otherwise use NP.
    //

    if( *LocalMachineName == L'\0' ) {

        DWORD ComputerNameLength;

        ComputerNameLength = MAX_COMPUTERNAME_LENGTH;

        if( !GetComputerName(
                LocalMachineName,
                &ComputerNameLength ) ) {

            *LocalMachineName = L'\0';
        }
    }

    //
    // if know machine ..
    //

    if( (*LocalMachineName != L'\0') ) {

        BOOL LocalMachine;

        //
        // if the machine has "\\" skip it for name compare.
        //

        if( *ServerIpAddress == L'\\' ) {
            LocalMachine = !_wcsicmp( LocalMachineName, ServerIpAddress + 2);
        }
        else {
            LocalMachine = !_wcsicmp( LocalMachineName, ServerIpAddress);
        }

        if( LocalMachine ) {
            return( DHCP_SERVER_USE_RPC_OVER_LPC );
        }

    }

    return( DHCP_SERVER_USE_RPC_OVER_NP );
}


handle_t
DHCP_SRV_HANDLE_bind(
    DHCP_SRV_HANDLE ServerIpAddress
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR binding;
    handle_t bindingHandle;
    DWORD RpcProtocol;

    //
    // examine the ServerIpAddress string, if it is :
    //
    // 1. NULL or local IPAddress or Local Name - use "ncalrpc"
    // 2. IpAddress - (of the  form "ppp.qqq.rrr.sss") -   use "ncacn_ip_tcp"
    // 3. otherwise use "ncacn_np" protocol.
    //

    RpcProtocol = FindProtocolToUse( ServerIpAddress );

    if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_LPC ) {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        NULL,
                        DHCP_LPC_EP,
                        // L"Security=Impersonation Dynamic False",
                        L"Security=Impersonation Static True",
                        &binding);
    }
    else if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_NP ) {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        ServerIpAddress,
                        DHCP_NAMED_PIPE,
                        L"Security=Impersonation Static True",
                        &binding);
    }
    else {

        rpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_ip_tcp",
                        ServerIpAddress,
                        DHCP_SERVER_BIND_PORT,
                        NULL,
                        &binding);
    }



    if ( rpcStatus != RPC_S_OK ) {
        goto Cleanup;
    }

    rpcStatus = RpcBindingFromStringBindingW( binding, &bindingHandle );

    if ( rpcStatus != RPC_S_OK ) {
        goto Cleanup;
    }

    if( RpcProtocol == DHCP_SERVER_USE_RPC_OVER_TCPIP ) {
        //
        // Tell RPC to do the security thing.
        //

        if( DhcpGlobalTryDownlevel ) {
            rpcStatus = RpcBindingSetAuthInfo(
                bindingHandle,                  // binding handle
                DHCP_SERVER_SECURITY,           // app name to security provider
                RPC_C_AUTHN_LEVEL_CONNECT,      // auth level
                DHCP_SERVER_SECURITY_AUTH_ID,   // Auth package ID
                NULL,                           // client auth info, NULL specified logon info.
                RPC_C_AUTHZ_NAME );
        } else {            
            rpcStatus = RpcBindingSetAuthInfo(
                bindingHandle, NULL,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_AUTHZ_NAME );
        }
    }

Cleanup:

    RpcStringFreeW(&binding);

    if ( rpcStatus != RPC_S_OK ) {
        SetLastError( rpcStatus );
        return( NULL );
    }

    return bindingHandle;
}




void
DHCP_SRV_HANDLE_unbind(
    DHCP_SRV_HANDLE ServerIpAddress,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{

    (VOID)RpcBindingFree(&BindHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\rpcstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcstub.c

Abstract:

    Client stubs of the DHCP server service APIs.

Author:

    Madan Appiah (madana) 10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpcli.h"
#include <dhcpds.h>                             // this is from dhcpds directory
#include <stdlib.h>
#include <winsock2.h>
#include <rpcasync.h>

CRITICAL_SECTION DhcpsapiDllCritSect;

static      DWORD                  Initialized = 0;
static      DWORD                  TlsIndex = 0xFFFFFFFF;


BOOLEAN
DhcpStubsDllInit (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This is the DLL initialization routine for dhcpsapi.dll.

Arguments:

    Standard.

Return Value:

    TRUE iff initialization succeeded.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOL  BoolError;
    DWORD Length;

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    //
    // Handle attaching netlogon.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        if ( !DisableThreadLibraryCalls( DllHandle ) ) {
            return( FALSE );
        }

        try {

            InitializeCriticalSection(&DhcpsapiDllCritSect);

        } except ( I_RpcExceptionFilter(RpcExceptionCode())) {

            Error = GetLastError( );
            return FALSE;
        }

    } else if (Reason == DLL_PROCESS_DETACH) {

        DeleteCriticalSection(&DhcpsapiDllCritSect);        
    }

    return( TRUE );
}

    
VOID _cdecl 
DbgPrint( char *, ... );

LPWSTR      _inline
DhcpOemToUnicode(                               // convert from ansi buffer to uni buffer
    IN      LPSTR                  Ansi,
    IN OUT  LPWSTR                 Unicode
)
{
    if( NULL == Unicode || NULL == Ansi ) {     // should not happen
        return NULL;
    }

    if( -1 == mbstowcs(Unicode, Ansi, 1+strlen(Ansi))) {
        return NULL;
    }
    return Unicode;
}


//DOC DhcpDsInit must be called exactly once per process.. this initializes the
//DOC memory and other structures for this process.  This initializes some DS
//DOC object handles (memory), and hence is slow as this has to read from DS.
DWORD
DhcpDsInit(
    VOID
)
{
    DWORD                          Err = NO_ERROR;

    EnterCriticalSection(&DhcpsapiDllCritSect);

    do {

        if( 0 != Initialized ) {
            break;
        }

        TlsIndex = TlsAlloc();
        if( 0xFFFFFFFF == TlsIndex ) {
            Err = GetLastError();
            break;
        }

        Err = DhcpDsInitDS(0, NULL);
        if( ERROR_SUCCESS != Err ) {
            TlsFree(TlsIndex);
            TlsIndex = 0xFFFFFFFF;
        }

        break;
    } while ( 0 );

    if( NO_ERROR == Err ) Initialized ++;

    LeaveCriticalSection(&DhcpsapiDllCritSect);
    return Err;
}

//DOC DhcpDsCleanup undoes the effect of any DhcpDsInit.  This function should be
//DOC called exactly once for each process, and only at termination.  Note that
//DOC it is safe to call this function even if DhcpDsInit does not succeed.
VOID
DhcpDsCleanup(
    VOID
)
{
    EnterCriticalSection(&DhcpsapiDllCritSect);

    do {
        if( 0 == Initialized ) break;
        Initialized --;
        if( 0 != Initialized ) break;

        TlsFree(TlsIndex);
        DhcpDsCleanupDS();
        TlsIndex = 0xFFFFFFFF;

    } while ( 0 );

    LeaveCriticalSection(&DhcpsapiDllCritSect);
}

#define     DHCP_FLAGS_DONT_ACCESS_DS             0x01
#define     DHCP_FLAGS_DONT_DO_RPC                0x02

//DOC DhcpSetThreadOptions currently allows only one option to be set.  This is the
//DOC flag DHCP_FLAGS_DONT_ACCESS_DS.  This affects only the current executing thread.
//DOC When this function is executed, all calls made further DONT access the registry,
//DOC excepting the DhcpEnumServers, DhcpAddServer and DhcpDeleteServer calls.
DWORD
DhcpSetThreadOptions(                             // set options for current thread
    IN      DWORD                  Flags,         // options, currently 0 or DHCP_FLAGS_DONT_ACCESS_DS
    IN      LPVOID                 Reserved       // must be NULL, reserved for future
)
{
    BOOL                           Err;

    Err = TlsSetValue(TlsIndex, ULongToPtr(Flags));
    if( FALSE == Err ) {                          // could not set the value?
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

//DOC DhcpGetThreadOptions retrieves the current thread options as set by DhcpSetThreadOptions.
//DOC If none were set, the return value is zero.
DWORD
DhcpGetThreadOptions(                             // get current thread options
    OUT     LPDWORD                pFlags,        // this DWORD is filled with current optiosn..
    IN OUT  LPVOID                 Reserved       // must be NULL, reserved for future
)
{
    if( NULL == pFlags ) return ERROR_INVALID_PARAMETER;
    *pFlags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex));
    if( 0 == *pFlags ) return GetLastError();     // dont know if there were no options or error
    return ERROR_SUCCESS;
}

//DOC DontAccessDs is an inline that checks to see if requested NOT to access DS ..
BOOL        _inline                               // TRUE ==> Dont access DS.
DontAccessDs(                                     // check to see if requested NOT to access DS
    VOID
)
{
    DWORD                          Flags;

    if( CFLAG_DONT_DO_DSWORK ) return TRUE;       // if DS is turned off return TRUE immediately..

    Flags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex)); // dont bother if it fails, as this would be 0 then.
    return (Flags & DHCP_FLAGS_DONT_ACCESS_DS)? TRUE : FALSE;
}

//DOC DontDoRPC is an inline that checks to see if requested NOT to do RPC (maybe only DS)..
BOOL        _inline                               // TRUE ==> Dont do RPC
DontDoRPC(                                        // check to see if requested not to do RPC
    VOID
)
{
    DWORD                          Flags;
    Flags = (DWORD)((DWORD_PTR)TlsGetValue(TlsIndex)); // dont bother if it fails, as this would be 0 then.
    return (Flags & DHCP_FLAGS_DONT_DO_RPC)? TRUE : FALSE;
}

//
// API proto types
//

//
// Subnet APIs
//

DWORD
DhcpCreateSubnet(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO SubnetInfo
    )
/*++

Routine Description:

    This function creates a new subnet structure in the server
    registry database. The server will start managing the new subnet
    and distribute IP address to clients from that subnet. However
    the administrator should call DhcpAddSubnetElement() to add an
    address range for distribution. The PrimaryHost field specified in
    the SubnetInfo should be same as the server pointed by
    ServerIpAddress.

Arguments:

    ServerIpAddress : IP address string of the DHCP server (Primary).

    SubnetAddress : IP Address of the new subnet.

    SubnetInfo : Pointer to the new subnet information structure.

Return Value:

    ERROR_DHCP_SUBNET_EXISTS - if the subnet is already managed.

    ERROR_INVALID_PARAMETER - if the information structure contains an
        inconsistent fields.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateSubnet(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpCreateSubnetDS(ServerIpAddress, SubnetAddress, SubnetInfo);
}

DWORD
DhcpSetSubnetInfo(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO SubnetInfo
    )
/*++

Routine Description:

    This function sets the information fields of the subnet that is already
    managed by the server. The valid fields that can be modified are 1.
    SubnetName, 2. SubnetComment, 3. PrimaryHost.NetBiosName and 4.
    PrimaryHost.HostName. Other fields can't be modified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to the subnet information structure.


Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/

{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetSubnetInfo(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:


    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetSubnetInfoDS(ServerIpAddress, SubnetAddress, SubnetInfo);
}


DWORD
DhcpGetSubnetInfo(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO *SubnetInfo
    )
/*++

Routine Description:

    This function retrieves the information of the subnet managed by
    the server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to a location where the subnet information
        structure pointer is returned. Caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetSubnetInfo(
                    ServerIpAddress,
                    SubnetAddress,
                    SubnetInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetSubnetInfoDS(ServerIpAddress, SubnetAddress, SubnetInfo);
}


DWORD
DhcpEnumSubnets(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_IP_ARRAY *EnumInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnets(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpEnumSubnetsDS(
        ServerIpAddress, ResumeHandle, PreferredMaximum, EnumInfo, ElementsRead, ElementsTotal
    );
}

DWORD
DhcpAddSubnetElement(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo
    )
/*++

Routine Description:

    This function adds a enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/

{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddSubnetElement(
                    ServerIpAddress,
                    SubnetAddress,
                    AddElementInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpAddSubnetElementDS(ServerIpAddress, SubnetAddress, AddElementInfo);
}


DWORD
DhcpEnumSubnetElements(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetElements(
                    ServerIpAddress,
                    SubnetAddress,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpEnumSubnetElementsDS(
        ServerIpAddress,
        SubnetAddress,
        EnumElementType,
        ResumeHandle,
        PreferredMaximum,
        EnumElementInfo,
        ElementsRead,
        ElementsTotal
    );
}

DWORD
DhcpRemoveSubnetElement(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveSubnetElement(
                    ServerIpAddress,
                    SubnetAddress,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveSubnetElementDS(ServerIpAddress, SubnetAddress, RemoveElementInfo,ForceFlag);
}

DWORD
DhcpDeleteSubnet(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
)
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteSubnet(
                        ServerIpAddress,
                        SubnetAddress,
                        ForceFlag
                        );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpDeleteSubnetDS(ServerIpAddress,SubnetAddress,ForceFlag);
}

//
// Option APIs
//

DWORD
DhcpCreateOption(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION OptionInfo
    )
/*++

Routine Description:

    This function creates a new option that will be managed by the
    server. The optionID specified the ID of the new option, it should
    be within 0-255 range. If no default value is specified for this
    option, then this API automatically adds a default value from RFC
    1122 doc. (if it is defined).

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the new option.

    OptionInfo : Pointer to new option information structure.

Return Value:

    ERROR_DHCP_OPTION_EXISTS - if the option exists already.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateOption(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpCreateOptionDS(ServerIpAddress,OptionID, OptionInfo);
}


DWORD
DhcpSetOptionInfo(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION OptionInfo
    )
/*++

Routine Description:

    This functions sets the Options information fields.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be set.

    OptionInfo : Pointer to new option information structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionInfo(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionInfoDS(ServerIpAddress, OptionID, OptionInfo);
}


DWORD
DhcpGetOptionInfo(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION *OptionInfo
    )
/*++

Routine Description:

    This function retrieves the current information structure of the specified
    option.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be retrieved.

    OptionInfo : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetOptionInfo(
                    ServerIpAddress,
                    OptionID,
                    OptionInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetOptionInfoDS(ServerIpAddress, OptionID, OptionInfo);
}

DWORD
DhcpEnumOptions(
    LPWSTR ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_ARRAY *Options,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    )
/*++

Routine Description:

    This functions retrieves the information of all known options.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    Options : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    OptionsRead : Pointer to a DWORD where the number of options
        in the above buffer is returned.

    OptionsTotal : Pointer to a DWORD where the total number of
        options remaining from the current position is returned.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumOptions(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    Options,
                    OptionsRead,
                    OptionsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;
  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;

    return DhcpEnumOptions(
        ServerIpAddress,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );

}


DWORD
DhcpRemoveOption(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID
    )
/*++

Routine Description:

    This function removes the specified option from the server database.
    Also it browses through the Global/Subnet/ReservedIP
    option lists and deletes them too (?? This will be too expensive.).

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be removed.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveOption(
                    ServerIpAddress,
                    OptionID
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveOptionDS(ServerIpAddress, OptionID);
}


DWORD
DhcpSetOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_DATA OptionValue
    )
/*++

Routine Description:

    The function sets a new option value at the specified scope. If
    there is already a value available for the specified option at
    specified scope then this function will replace it otherwise it will
    create a new entry at that scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option whose value should be set.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to the option value structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_INVALID_PARAMETER - if the scope information specified is invalid.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo,
                    OptionValue
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionValueDS(ServerIpAddress,OptionID,ScopeInfo,OptionValue);
}

DWORD
DhcpSetOptionValues(
    LPWSTR ServerIpAddress,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_VALUE_ARRAY OptionValues
    )
/*++

Routine Description:

    The function sets a set of new options value at the specified scope.
    If there is already a value available for the specified option at
    specified scope then this function will replace it otherwise it will
    create a new entry at that scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to the option value structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_INVALID_PARAMETER - if the scope information specified is invalid.

    other WINDOWS errors.

--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetOptionValues(
                    ServerIpAddress,
                    ScopeInfo,
                    OptionValues
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionValuesDS(ServerIpAddress,ScopeInfo,OptionValues);
}


DWORD
DhcpGetOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    LPDHCP_OPTION_VALUE *OptionValue
    )
/*++

Routine Description:

    This function retrieves the current option value at the specified
    scope. It returns error if there is no option value is available at
    the specified scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option whose value is returned.

    ScopeInfo : Pointer to the scope information structure.

    OptionValue : Pointer to a location where the pointer to the option
        value structure is returned. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option is unknown.

    ERROR_DHCP_NO_OPTION_VALUE - if no the option value is available at
        the specified scope.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo,
                    OptionValue
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetOptionValueDS(
        ServerIpAddress,
        OptionID,
        ScopeInfo,
        OptionValue
    );

}


DWORD
DhcpEnumOptionValues(
    LPWSTR ServerIpAddress,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    )
/*++

Routine Description:

    This function enumerates the available options values at the
    specified scope.

Arguments:
    ServerIpAddress : IP address string of the DHCP server.

    ScopeInfo : Pointer to the scope information structure.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    OptionValues : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    OptionsRead : Pointer to a DWORD where the number of options
        in the above buffer is returned.

    OptionsTotal : Pointer to a DWORD where the total number of
        options remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SCOPE_NOT_PRESENT - if the scope is unknown.

    ERROR_MORE_DATA - if more options available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more option to enumerate.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumOptionValues(
                    ServerIpAddress,
                    ScopeInfo,
                    ResumeHandle,
                    PreferredMaximum,
                    OptionValues,
                    OptionsRead,
                    OptionsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpEnumOptionValuesDS(
        ServerIpAddress,
        ScopeInfo,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );

}


DWORD
DhcpRemoveOptionValue(
    LPWSTR ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION_SCOPE_INFO ScopeInfo
    )
/*++

Routine Description:

    This function removes the specified option from specified scope.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    OptionID : The ID of the option to be removed.

    ScopeInfo : Pointer to the scope information structure.

Return Value:

    ERROR_DHCP_OPTION_NOT_PRESENT - if the option does not exist.

    other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveOptionValue(
                    ServerIpAddress,
                    OptionID,
                    ScopeInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveOptionValueDS(ServerIpAddress,OptionID,ScopeInfo);

}

//
// Client APIs
//

DWORD
DhcpCreateClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}


DWORD
DhcpSetClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_SUCCESS;
    return DhcpSetClientInfoDS(ServerIpAddress, ClientInfo);
}


DWORD
DhcpGetClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientInfo(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetClientInfoDS(ServerIpAddress, SearchInfo, ClientInfo);
}


DWORD
DhcpDeleteClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}


DWORD
DhcpEnumSubnetClients(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClients(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}


DWORD
DhcpGetClientOptions(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    )
/*++

Routine Description:

    This function retrieves the options that are given to the
    specified client on boot request.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientIpAddress : IP Address of the client whose options to be
        retrieved

    ClientSubnetMask : Subnet mask of the client.

    ClientOptions : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the specified client subnet is
        not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientOptions(
                    ServerIpAddress,
                    ClientIpAddress,
                    ClientSubnetMask,
                    ClientOptions
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpGetMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrieves all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMibInfo(
                    ServerIpAddress,
                    MibInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpServerSetConfig(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerSetConfig(
                    ServerIpAddress,
                    FieldsToSet,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpServerGetConfig(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerGetConfig(
                    ServerIpAddress,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpScanDatabase(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpScanDatabase(
                    ServerIpAddress,
                    SubnetAddress,
                    FixFlag,
                    ScanList );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    )
/*++

Routine Description:

    This function returns the major and minor version numbers of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MajorVersion : pointer to a location where the major version of the
        server is returned.

    MinorVersion : pointer to a location where the minor version of the
        server is returned.

Return Value:

    WINDOWS errors.

--*/
{

    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetVersion(
                        ServerIpAddress,
                        MajorVersion,
                        MinorVersion );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}


VOID
DhcpRpcFreeMemory(
    PVOID BufferPointer
    )
/*++

Routine Description:

    This function deallocates the memory that was alloted by the RPC and
    given to the client as part of the retrun info structures.

Arguments:

    BufferPointer : pointer to a memory block that is deallocated.

Return Value:

    none.

--*/
{
    MIDL_user_free( BufferPointer );
}

#if 0
DWORD
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    )
/*++

Routine Description:

    This function returns the major and minor version numbers of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MajorVersion : pointer to a location where the major version of the
        server is returned.

    MinorVersion : pointer to a location where the minor version of the
        server is returned.

Return Value:

    WINDOWS errors.

--*/
{
    DWORD Error;
    handle_t BindingHandle = NULL;
    RPC_IF_ID_VECTOR *InterfaceIdVectors = NULL;
    DWORD i;

    //
    // take a copy of the global client if handle structure (which is read
    // only) to modify.
    //

    RPC_CLIENT_INTERFACE ClientIf =
        *((RPC_CLIENT_INTERFACE *)dhcpsrv_ClientIfHandle);

    //
    // bind to the server.
    //

    BindingHandle = DHCP_SRV_HANDLE_bind( ServerIpAddress );

    if( BindingHandle == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // loop to match the version of the server. We handle only minor
    // versions.
    //

    for (;;) {

        Error = RpcEpResolveBinding(
                        BindingHandle,
                        (RPC_IF_HANDLE)&ClientIf );

        if( Error == RPC_S_OK ) {
            break;
        }

        if( Error != EPT_S_NOT_REGISTERED ){
            goto Cleanup;
        }

        //
        // decrement minor version number and try again, until version
        // becomes 0.
        //

        if( ClientIf.InterfaceId.SyntaxVersion.MinorVersion != 0 ) {

            ClientIf.InterfaceId.SyntaxVersion.MinorVersion--;
        }
        else {
            goto Cleanup;
        }
    }

    Error = RpcMgmtInqIfIds(
                BindingHandle,
                &InterfaceIdVectors );

    if( Error != RPC_S_OK ) {
        goto Cleanup;
    }

    //
    // match uuid.
    //

    for( i = 0; i <  InterfaceIdVectors->Count; i++) {

        RPC_STATUS Result;

        UuidCompare( &InterfaceIdVectors->IfId[i]->Uuid,
                                &ClientIf.InterfaceId.SyntaxGUID,
                                &Result );

        if( Result == 0 ) {

            *MajorVersion = InterfaceIdVectors->IfId[i]->VersMajor;
            *MinorVersion = InterfaceIdVectors->IfId[i]->VersMinor;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
    }

    Error = RPC_S_UNKNOWN_IF;

Cleanup:

    if( InterfaceIdVectors != NULL ) {
        RpcIfIdVectorFree( &InterfaceIdVectors );
    }

    if( BindingHandle != NULL ) {
        DHCP_SRV_HANDLE_unbind( ServerIpAddress, BindingHandle );
    }

    return( Error );
}
#endif // 0

//
// NT4 SP1 interface
//

DWORD
DhcpAddSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * AddElementInfo
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddSubnetElementV4(
                    ServerIpAddress,
                    SubnetAddress,
                    AddElementInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpAddSubnetElementV4DS(ServerIpAddress, SubnetAddress,AddElementInfo);

}



DWORD
DhcpEnumSubnetElementsV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {
        Status = R_DhcpEnumSubnetElementsV4(
                    ServerIpAddress,
                    SubnetAddress,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;

    return DhcpEnumSubnetElementsV4DS(
        ServerIpAddress,
        SubnetAddress,
        EnumElementType,
        ResumeHandle,
        PreferredMaximum,
        EnumElementInfo,
        ElementsRead,
        ElementsTotal
    );
}


DWORD
DhcpRemoveSubnetElementV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveSubnetElementV4(
                    ServerIpAddress,
                    SubnetAddress,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveSubnetElementV4DS(ServerIpAddress,SubnetAddress,RemoveElementInfo,ForceFlag);
}


DWORD
DhcpCreateClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpCreateClientInfoV4(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpGetClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetClientInfoV4(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetClientInfoV4DS(ServerIpAddress, SearchInfo, ClientInfo);
}



DWORD
DhcpSetClientInfoV4(
    LPWSTR ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpSetClientInfoV4(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( DontAccessDs() ) return Status;

    return DhcpSetClientInfoV4DS(ServerIpAddress, ClientInfo);
}

DWORD
DhcpEnumSubnetClientsV4(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClientsV4(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpEnumSubnetClientsV5(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumSubnetClientsV5(
                    ServerIpAddress,
                    SubnetAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;

}


DWORD
DhcpServerSetConfigV4(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerSetConfigV4(
                    ServerIpAddress,
                    FieldsToSet,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}

DWORD
DhcpServerGetConfigV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    Status = ERROR_CALL_NOT_IMPLEMENTED;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {

        Status = R_DhcpServerGetConfigV4(
                    ServerIpAddress,
                    ConfigInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    return Status;
}



DWORD
DhcpSetSuperScopeV4(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_CONST DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST LPWSTR SuperScopeName,
    DHCP_CONST BOOL ChangeExisting
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpSetSuperScopeV4(
                    ServerIpAddress,
                    SubnetAddress,
                    SuperScopeName,
                    ChangeExisting
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetSuperScopeV4DS(ServerIpAddress,SubnetAddress,SuperScopeName,ChangeExisting);
}


DWORD
DhcpDeleteSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST LPWSTR SuperScopeName
    )
{
    DWORD Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpDeleteSuperScopeV4(
                          ServerIpAddress,
                          SuperScopeName
                          );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpDeleteSuperScopeV4DS(ServerIpAddress,SuperScopeName);
}


DWORD
DhcpGetSuperScopeInfoV4(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
    )
{
    DWORD Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetSuperScopeInfoV4(
                    ServerIpAddress,
                    SuperScopeTable
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;

    return DhcpGetSuperScopeInfoV4DS(ServerIpAddress, SuperScopeTable);
}

//================================================================================
//  V5 NT 5.0 Beta2 work (ClassId and Vendor specific stuff)
//  In the following function, if flags is DHCP_FLAGS_OPTION_IS_VENDOR
//  implies the option being considered is vendor, otherwise the option is normal...
//  ClasName = NULL imples there is no class (otherwise the class is named)
//================================================================================

DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpCreateOptionV5(
            ServerIpAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpCreateOptionV5DS(ServerIpAddress,Flags,OptionId,ClassName,VendorName,OptionInfo);
}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionInfoV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionInfoV5DS(ServerIpAddress,Flags,OptionID, ClassName, VendorName, OptionInfo);
}


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfoV5(                              // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetOptionInfoV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            OptionInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetOptionInfoV5DS(
        ServerIpAddress,
        Flags,
        OptionID,
        ClassName,
        VendorName,
        OptionInfo
    );
}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptionsV5(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumOptionsV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpEnumOptionsV5DS(
        ServerIpAddress,
        Flags,
        ClassName,
        VendorName,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOptionV5(                               // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpRemoveOptionV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveOptionV5DS(ServerIpAddress, Flags,OptionID, ClassName, VendorName);
}


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValueV5(                             // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionValueV5DS(ServerIpAddress, Flags, OptionId, ClassName, VendorName, ScopeInfo, OptionValue);
    return Status;
}


DWORD                                             // not atomic!!!!
DhcpSetOptionValuesV5(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpSetOptionValuesV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValues
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpSetOptionValuesV5DS(ServerIpAddress, Flags, ClassName, VendorName, ScopeInfo, OptionValues);
}


DWORD
DhcpGetOptionValueV5(                             // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetOptionValueV5DS(
        ServerIpAddress,
        Flags,
        OptionID,
        ClassName,
        VendorName,
        ScopeInfo,
        OptionValue
    );
}


DWORD
DhcpEnumOptionValuesV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumOptionValuesV5(
            ServerIpAddress,
            Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            ResumeHandle,
            PreferredMaximum,
            OptionValues,
            OptionsRead,
            OptionsTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpEnumOptionValuesV5DS(
        ServerIpAddress,
        Flags,
        ClassName,
        VendorName,
        ScopeInfo,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );
}


DWORD
DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpRemoveOptionValueV5(
            ServerIpAddress,
            Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpRemoveOptionValueV5DS(ServerIpAddress,Flags,OptionID, ClassName, VendorName, ScopeInfo);
}


DWORD
DhcpCreateClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpCreateClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpCreateClassDS(ServerIpAddress, ReservedMustBeZero, ClassInfo);
}


DWORD
DhcpModifyClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpModifyClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpModifyClassDS(ServerIpAddress, ReservedMustBeZero, ClassInfo);
}


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
)
{
    DWORD                          Status;

    Status = ERROR_SUCCESS;
    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpDeleteClass(
            ServerIpAddress,
            ReservedMustBeZero,
            ClassName
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
  SkipRPC:

    if( ERROR_SUCCESS != Status ) return Status;
    if( DontAccessDs() ) return ERROR_SUCCESS;    // dont do ds if asked not to.

    return DhcpDeleteClassDS(ServerIpAddress,ReservedMustBeZero, ClassName);
}


DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpGetClassInfo(
            ServerIpAddress,
            ReservedMustBeZero,
            PartialClassInfo,
            FilledClassInfo
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;
    return DhcpGetClassInfoDS(
        ServerIpAddress,
        ReservedMustBeZero,
        PartialClassInfo,
        FilledClassInfo
    );
}


DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Status;

    *nRead = *nTotal =0;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept  {
        Status = R_DhcpEnumClasses(
            ServerIpAddress,
            ReservedMustBeZero,
            ResumeHandle,
            PreferredMaximum,
            ClassInfoArray,
            nRead,
            nTotal
        );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )  {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_SUCCESS;

    return DhcpEnumClassesDS(
        ServerIpAddress, ReservedMustBeZero, ResumeHandle, PreferredMaximum, ClassInfoArray, nRead, nTotal
    );
}

DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // what do we care about vendor/classid stuff?
    OUT     LPDHCP_ALL_OPTIONS     *OptionStruct   // fill the fields of this structure
)
{
    DWORD                          Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetAllOptions(
            ServerIpAddress,
            Flags,
            OptionStruct
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    if( DontAccessDs() ) return ERROR_INVALID_DATA;

    return DhcpGetAllOptionsDS(
        ServerIpAddress,
        Flags,
        OptionStruct
    );
}

DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
)
{
    DWORD                           Status;

    if( DontDoRPC() ) goto SkipRPC;
    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetAllOptionValues(
            ServerIpAddress,
            Flags,
            ScopeInfo,
            Values
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    
    return Status;

  SkipRPC:

    return DhcpGetAllOptionValuesDS(
        ServerIpAddress,
        Flags,
        ScopeInfo,
        Values
    );
}

//DOC DhcpEnumServers enumerates the list of servers found in the DS.  If the DS
//DOC is not accessible, it returns an error. The only currently used parameter
//DOC is the out parameter Servers.  This is a SLOW call.
DWORD
DhcpEnumServers(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,    // output servers list
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Result;

    Result = DhcpEnumServersDS(Flags,IdInfo,Servers,CallbackFn,CallbackData);

    return Result;
}

//DOC DhcpAddServer tries to add a new server to the existing list of servers in
//DOC the DS. The function returns error if the Server already exists in the DS.
//DOC The function tries to upload the server configuration to the DS..
//DOC This is a SLOW call.  Currently, the DsLocation and DsLocType are not valid
//DOC fields in the NewServer and they'd be ignored. Version must be zero.
DWORD
DhcpAddServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Err, IpAddress;
    WCHAR                          wBuf[sizeof("xxx.xxx.xxx.xxx")];

    Err = DhcpAddServerDS(Flags,IdInfo,NewServer,CallbackFn,CallbackData);
    if( ERROR_SUCCESS != Err ) return Err;

    IpAddress = htonl(NewServer->ServerAddress);
    (void)DhcpServerRedoAuthorization(
        DhcpOemToUnicode( inet_ntoa(*(struct in_addr*)&IpAddress), wBuf),
        0
    );

    return ERROR_SUCCESS;
}

//DOC DhcpDeleteServer tries to delete the server from DS. It is an error if the
//DOC server does not already exist.  This also deletes any objects related to
//DOC this server in the DS (like subnet, reservations etc.).
DWORD
DhcpDeleteServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
)
{
    DWORD                          Err, IpAddress;
    WCHAR                          wBuf[sizeof("xxx.xxx.xxx.xxx")];

    Err = DhcpDeleteServerDS(Flags,IdInfo,NewServer,CallbackFn,CallbackData);
    if( ERROR_SUCCESS != Err ) return Err;

    IpAddress = htonl(NewServer->ServerAddress);
    (void)DhcpServerRedoAuthorization(
        DhcpOemToUnicode( inet_ntoa(*(struct in_addr*)&IpAddress), wBuf),
        0
    );

    return ERROR_SUCCESS;
}

//================================================================================
// Multicast stuff
//================================================================================

DWORD
DhcpSetMScopeInfo(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_MSCOPE_INFO MScopeInfo,
    BOOL NewScope
    )
{
    DWORD Status;

    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpSetMScopeInfo(
                    ServerIpAddress,
                    MScopeName,
                    MScopeInfo,
                    NewScope
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMScopeInfo(
    DHCP_CONST DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_MSCOPE_INFO *MScopeInfo
    )
{
    DWORD Status;

    RedoRpc: RpcTryExcept
    {
        Status = R_DhcpGetMScopeInfo(
                    ServerIpAddress,
                    MScopeName,
                    MScopeInfo
                    );
    }
    RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) )
    {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpEnumMScopes(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopes(
                    ServerIpAddress,
                    ResumeHandle,
                    PreferredMaximum,
                    MScopeTable,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpAddMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    )
/*++

Routine Description:

    This function adds a enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/

{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpAddMScopeElement(
                    ServerIpAddress,
                    MScopeName,
                    AddElementInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpEnumMScopeElements(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopeElements(
                    ServerIpAddress,
                    MScopeName,
                    EnumElementType,
                    ResumeHandle,
                    PreferredMaximum,
                    EnumElementInfo,
                    ElementsRead,
                    ElementsTotal
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpRemoveMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpRemoveMScopeElement(
                    ServerIpAddress,
                    MScopeName,
                    RemoveElementInfo,
                    ForceFlag
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpDeleteMScope(
    LPWSTR ServerIpAddress,
    LPWSTR  MScopeName,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteMScope(
                        ServerIpAddress,
                        MScopeName,
                        ForceFlag
                        );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_MCLIENT_INFO *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMClientInfo(
                    ServerIpAddress,
                    SearchInfo,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpDeleteMClientInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpDeleteMClientInfo(
                    ServerIpAddress,
                    ClientInfo
                    );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpEnumMScopeClients(
    LPWSTR ServerIpAddress,
    LPWSTR MScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpEnumMScopeClients(
                    ServerIpAddress,
                    MScopeName,
                    ResumeHandle,
                    PreferredMaximum,
                    ClientInfo,
                    ClientsRead,
                    ClientsTotal
                    );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;

}

DWORD
DhcpScanMDatabase(
    LPWSTR ServerIpAddress,
    LPWSTR MScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpScanMDatabase(
                    ServerIpAddress,
                    MScopeName,
                    FixFlag,
                    ScanList );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpGetMCastMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrieves all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Status;

    RedoRpc: RpcTryExcept {

        Status = R_DhcpGetMCastMibInfo(
                    ServerIpAddress,
                    MibInfo );

    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpAuditLogSetParams(                            // set some auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpAuditLogSetParams(
            ServerIpAddress,
            Flags,
            AuditLogDir,
            DiskCheckInterval,
            MaxLogFilesSize,
            MinSpaceOnDisk
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpAuditLogGetParams(                                // get the auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
)
{
    DWORD                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpAuditLogGetParams(
            ServerIpAddress,
            Flags,
            AuditLogDir,
            DiskCheckInterval,
            MaxLogFilesSize,
            MinSpaceOnDisk
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerQueryAttribute(                         // get a server status
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      DHCP_ATTRIB_ID         DhcpAttribId,  // the attrib being queried
    OUT     LPDHCP_ATTRIB         *pDhcpAttrib    // fill in this field
)
{
    ULONG                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpServerQueryAttribute(
            ServerIpAddr,
            dwReserved,
            DhcpAttribId,
            pDhcpAttrib
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerQueryAttributes(                        // query multiple attributes
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      ULONG                  dwAttribCount, // # of attribs being queried
    IN      DHCP_ATTRIB_ID         pDhcpAttribs[],// array of attribs
    OUT     LPDHCP_ATTRIB_ARRAY   *pDhcpAttribArr // Ptr is filled w/ array
)
{
    ULONG                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpServerQueryAttributes(
            ServerIpAddr,
            dwReserved,
            dwAttribCount,
            pDhcpAttribs,
            pDhcpAttribArr
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD                                             // Status code
DhcpServerRedoAuthorization(                      // retry the rogue server stuff
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved     // reserved for future
)
{
    ULONG                          Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpServerRedoAuthorization(
            ServerIpAddr,
            dwReserved
        );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * AddElementInfo
    )
{
    ULONG Status;
    
    RedoRpc: RpcTryExcept {
        Status = R_DhcpAddSubnetElementV5(
            ServerIpAddress,
            SubnetAddress,
            AddElementInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpEnumSubnetElementsV5(
            ServerIpAddress,
            SubnetAddress,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            EnumElementInfo,
            ElementsRead,
            ElementsTotal
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpRemoveSubnetElementV5(
            ServerIpAddress,
            SubnetAddress,
            RemoveElementInfo,
            ForceFlag
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpSetServerBindingInfo(
    IN DHCP_CONST WCHAR *ServerIpAddress,
    IN ULONG Flags,
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpSetServerBindingInfo(
            ServerIpAddress,
            Flags,
            BindInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD DHCP_API_FUNCTION
DhcpGetServerBindingInfo(
    IN DHCP_CONST WCHAR *ServerIpAddress,
    IN ULONG Flags,
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpGetServerBindingInfo(
            ServerIpAddress,
            Flags,
            BindInfo
            );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}


DWORD
DhcpServerQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize, //in BYTES
    OUT LPWSTR Uname,
    IN ULONG DomainSize, // in BYTES
    OUT LPWSTR Domain
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpQueryDnsRegCredentials(
            ServerIpAddress,
            UnameSize/sizeof(WCHAR), Uname,
            DomainSize/sizeof(WCHAR), Domain );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD 
DhcpServerSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpSetDnsRegCredentials(
            ServerIpAddress, Uname, Domain, Passwd );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpServerBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpBackupDatabase(
            ServerIpAddress, Path );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}

DWORD
DhcpServerRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    ULONG Status;

    RedoRpc: RpcTryExcept {
        Status = R_DhcpRestoreDatabase(
            ServerIpAddress, Path );
    } RpcExcept(  I_RpcExceptionFilter(RpcExceptionCode()) ) {
        Status = RpcExceptionCode();
    } RpcEndExcept;

    if( Status == RPC_S_UNKNOWN_AUTHN_SERVICE &&
        !DhcpGlobalTryDownlevel ) {
        DhcpGlobalTryDownlevel = TRUE;
        goto RedoRpc;
    }
    

    return Status;
}
    

#define BINL_SVC_NAME  L"binlsvc"

BOOL
BinlServiceInstalled(
    VOID
    )
/*++

Routine Description:

    This routine checks if BINL service has been installed.
    BINL service is "binlsvc"

Return Values;

    TRUE -- binl service is installed
    FALSE -- binl service is not installed
    
--*/
{
    SC_HANDLE hScManager, hService;
    ULONG Error, Attempt;
    SERVICE_STATUS ServiceStatus;

    hScManager = OpenSCManager(
        NULL, NULL,
        STANDARD_RIGHTS_READ | SC_MANAGER_ENUMERATE_SERVICE
        );
    if( NULL == hScManager ) {
        DbgPrint("DHCP: OpenSCManager failed 0x%lx\n", GetLastError());
        //ASSERT(FALSE);
        return FALSE;
    }

    hService = OpenService(
        hScManager, BINL_SVC_NAME,
        SERVICE_QUERY_STATUS
        );

#if DBG
    if( NULL == hService ) {
        ULONG Error;

        Error = GetLastError();
        if( ERROR_SERVICE_DOES_NOT_EXIST != Error ) {
            //ASSERT(FALSE);
        }
        DbgPrint("DHCP: Can't open BINLSVC service: 0x%lx\n", Error);
    }
#endif

    CloseServiceHandle(hService);
    CloseServiceHandle(hScManager);
    
    return (NULL != hService);
}

VOID
WINAPI
DhcpDsClearHostServerEntries(
    VOID
)
/*++

Routine Description:
    This routine clears off any entries in DS for the current host assuming
    it has permissions to do so..

--*/
{
    ULONG Error;
    struct hostent *HostEnt;
    int i, j;
    WSADATA wsadata;
    LPDHCP_SERVER_INFO_ARRAY Servers = NULL;

    if( BinlServiceInstalled() ) {
        //
        // Do not do anything if BINL is installed
        //
        return ;
    }
    
    Error = WSAStartup( 0x0101, &wsadata);
    if( ERROR_SUCCESS != Error ) {
        return;
    }

    do {
        HostEnt = gethostbyname( NULL );
        if( NULL == HostEnt ) break;

        //
        // Now try to start the DS module..
        //
        Error = DhcpDsInit();
        if( ERROR_SUCCESS != Error ) break;

        do {
            Error = DhcpEnumServers(
                0,
                NULL,
                &Servers,
                0,
                0
                );

            if( ERROR_SUCCESS != Error ) break;

            i = 0;
            if( !Servers ) break;
        
            while( HostEnt->h_addr_list[i] ) {
                ULONG Addr = *(ULONG *)(HostEnt->h_addr_list[i]);
                
                i ++;
                if( Addr == 0 || Addr == ~0 || Addr == INADDR_LOOPBACK )
                    continue;
                
                for( j = 0; j < (int)Servers->NumElements; j ++ ) {
                    if( Addr == ntohl(Servers->Servers[j].ServerAddress )) {
                        DhcpDeleteServer(
                            0,
                            NULL,
                            &Servers->Servers[j],
                            NULL,
                            NULL
                            );
                    }
                }
            }

            DhcpRpcFreeMemory( Servers );
        } while ( 0 );

        DhcpDsCleanup();
    } while ( 0 );

    WSACleanup();
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dhcpbas.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This is some functionality essential for the dhcp-ds
//   implementation.
//================================================================================


//================================================================================
//  headers
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>

//================================================================================
// Constants
//================================================================================
//BeginExport(defines)
#define     DDS_RESERVED_DWORD                    0
#define     DDS_RESERVED_PTR                      ((LPVOID)0)

//DOC The following constants are Flag values that maybe passed to different
//DOC functions.
#define     DDS_FLAGS_CREATE                      0x01

//DOC Some standard names and locations in the DS

#define     DHCP_ROOT_OBJECT_LOC                  L"CN=DhcpRoot, CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_PARENT_LOC           L"CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_CN_NAME              L"CN=DhcpRoot"
#define     DHCP_ROOT_OBJECT_NAME                 L"DhcpRoot"

#define     DHCP_ATTRIB_WHEN_CHANGED              L"whenChanged"

//DOC The attributes that are defined for the dhcp class follows.

#define     DHCP_ATTRIB_UNIQUE_KEY                L"dhcpUniqueKey"         // reqd,single,integer8
#define     DHCP_ATTRIB_IDENTIFICATION            L"dhcpIdentification"    // reqd,single,directorystring
#define     DHCP_ATTRIB_TYPE                      L"dhcpType"              // reqd,single,integer
#define     DHCP_ATTRIB_FLAGS                     L"dhcpFlags"             // reqd,single,integer8
#define     DHCP_ATTRIB_DESCRIPTION               L"description"           // -,mv,directorystring
#define     DHCP_ATTRIB_CLASSES                   L"dhcpClasses"           // -,mv,octetstring
#define     DHCP_ATTRIB_MASK                      L"dhcpMask"              // -,mv,printablestring
#define     DHCP_ATTRIB_OBJ_DESCRIPTION           L"dhcpObjDescription"    // -,single,directorystring
#define     DHCP_ATTRIB_OBJ_NAME                  L"dhcpObjName"           // -,single,direcotrystring
#define     DHCP_ATTRIB_OPTIONS                   L"dhcpOptions"           // -,single,octetstring
#define     DHCP_ATTRIB_RANGES                    L"dhcpRanges"            // -,mv,printablestring
#define     DHCP_ATTRIB_RESERVATIONS              L"dhcpReservations"      // -,mv,printablestring
#define     DHCP_ATTRIB_SERVERS                   L"dhcpServers"           // -,mv,printablestring
#define     DHCP_ATTRIB_STATE                     L"dhcpState"             // -,mv,printablestring
#define     DHCP_ATTRIB_SUBNETS                   L"dhcpSubnets"           // -,mv,printablestring
#define     DHCP_ATTRIB_LOCATION_DN               L"locationDN"            // -,single,dn
#define     DHCP_ATTRIB_MSCOPEID                  L"mscopeid"              // -,single,printablestring
#define     DHCP_ATTRIB_ADDRESS                   L"networkAddress"        // -,mv,CaseIgnoreString
#define     DHCP_ATTRIB_OPTIONS_LOC               L"optionsLocation"       // -,mv,printablestring
#define     DHCP_ATTRIB_OPTION_DESCRIPTION        L"optionDescription"     // -,mv,directorystring
#define     DHCP_ATTRIB_SUPERSCOPES               L"superScopes"           // -,mv,printablestring

//DOC The following are the various types of objects recognized by the dhcp server
#define     DHCP_OBJ_TYPE_ROOT                    0                        // dhcp root object
#define     DHCP_OBJ_TYPE_SERVER                  1                        // dhcp server object
#define     DHCP_OBJ_TYPE_SUBNET                  2                        // subnet object
#define     DHCP_OBJ_TYPE_RANGE                   3                        // range object
#define     DHCP_OBJ_TYPE_RESERVATION             4                        // reservation object
#define     DHCP_OBJ_TYPE_OPTION                  5                        // options object
#define     DHCP_OBJ_TYPE_CLASS                   6                        // class object

#define     DHCP_OBJ_TYPE_ROOT_DESC               L"DHCP Root object"
#define     DHCP_OBJ_TYPE_SERVER_DESC             L"DHCP Server object"
#define     DHCP_OBJ_TYPE_SUBNET_DESC             L"Dhcp Subnet object"
#define     DHCP_OBJ_TYPE_RANGE_DESC              L"Dhcp Range object"
#define     DHCP_OBJ_TYPE_RESERVATION_DESC        L"Dhcp Reservation object"
#define     DHCP_OBJ_TYPE_OPTION_DESC             L"Dhcp Option object"
#define     DHCP_OBJ_TYPE_CLASS_DESC              L"Dhcp Class object"


//DOC The following defines are bitmasks and bits in various flags..

//DOC The flag2 portion of Ranges key is used for differntiating between exclusions and ranges
#define     RANGE_TYPE_RANGE                      0
#define     RANGE_TYPE_EXCL                       1
#define     RANGE_TYPE_MASK                       (0x1)

//EndExport(defines)



//================================================================================
// functions
//================================================================================
//BeginExport(function)
//DOC DhcpDsGetDhcpC gets the dhcp container in the DS.. This is usually the
//DOC container CN=Netservices,CN=Services,CN=Configuration etc..
//DOC This is used in many functions, so it is useful to have a central function..
//DOC
DWORD
DhcpDsGetDhcpC(                                   // get dhcp container
    IN      DWORD                  Reserved,      // future use
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // config container handle
    OUT     LPSTORE_HANDLE         hDhcpC         // output dhcp container handle
)   //EndExport(function)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   TmpHandle;

    if( NULL == hStoreCC || NULL == hDhcpC )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_PARENT_LOC,
        /* hStoreOut            */ hDhcpC
    );

    return Result;
}

//BeginExport(function)
//DOC DhcpDsGetRoot gets the dhcp root object given to the configuration container
//DOC This is usually CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration...
//DOC If Flags has the DDS_FLAGS_CREATE bit set, then the root object is created.
//DOC Return Values:
//DOC Store                        any returns returned by the Store module
//DOC ERROR_DDS_NO_DHCP_ROOT       no DhcpRoot object found
//DOC ERROR_DDS_UNEXPECTED_ERROR   the DhcpRoot's parent container not found..
//                                 in this case GetLastError returns ADS error
DWORD
DhcpDsGetRoot(
    IN      DWORD                  Flags,         // 0 or DDS_FLAGS_CREATE
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // configuration container handle
    OUT     LPSTORE_HANDLE         hStoreDhcpRoot // dhcp root object handle
) //EndExport(function)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   TmpHandle;

    SetLastError(NO_ERROR);
    
    if( NULL == hStoreCC || NULL == hStoreDhcpRoot )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Flags && DDS_FLAGS_CREATE != Flags )
        return ERROR_INVALID_PARAMETER;

    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_LOC,
        /* hStoreOut            */ hStoreDhcpRoot
    );
    if( ERROR_SUCCESS == Result ) return ERROR_SUCCESS;

    if( DDS_FLAGS_CREATE != Flags && ERROR_DS_NO_SUCH_OBJECT != Result ) {
        //- MajorFunctionFailure(StoreGetHandle, Result, DHCP_ROOT_OBJECT_LOC);
        SetLastError(Result);
        return Result;
    }

    //= DDS_FLAGS_CREATE == Flags && ERROR_DS_NO_SUCH_OBJECT == Result    
    Result = StoreGetHandle(
        /* hStore               */ hStoreCC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_PARENT_LOC,
        /* hStoreOut            */ &TmpHandle
    );
    if( ERROR_SUCCESS != Result ) {
        SetLastError(Result);
        return ERROR_DDS_UNEXPECTED_ERROR;
    }
    
    if( DDS_FLAGS_CREATE != Flags ) {
        //
        // Could open the config\services\netservices container, but
        // can't open the dhcproot object.  Most likely the dhcproot
        // object ain't there. 
        //
        
        Result2 = StoreCleanupHandle( &TmpHandle, DDS_RESERVED_DWORD );
        //= ERROR_SUCCESS == Result2

        SetLastError(ERROR_DS_NO_SUCH_OBJECT);
        return ERROR_DDS_NO_DHCP_ROOT;
    }

    Result = StoreCreateObject(
        /* hStore               */ &TmpHandle,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ DHCP_ROOT_OBJECT_CN_NAME,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          DHCP_ROOT_OBJECT_NAME,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        0,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, L"This is a server",
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );

    Result2 = StoreCleanupHandle( &TmpHandle, DDS_RESERVED_DWORD );
    //= ERROR_SUCCESS == Result2

    if( ERROR_SUCCESS != Result ) {
        //- MinorFunctionFailure(StoreCleanupHandle, Result)
        return Result;
    }

    return DhcpDsGetRoot( Flags & ~DDS_FLAGS_CREATE, hStoreCC, hStoreDhcpRoot);
}

//BeginExport(function)
//DOC DhcpDsGetLists function retrives a list of attributes and adds it the given array
//DOC allocating each element separateley, and traversing any pointers indicated by
//DOC the value of the attribute.
//DOC Note that even in case of error, the array may still contain some elements.
//DOC This is a best effort even in case of failure.
//DOC Each element of the array must be freed via MemFree, and the array itself
//DOC must be cleaned up via MemArrayCleanup.
//DOC Note that any of the PARRAY type parameters may be NULL, as they are optional.
//DOC but reading these separately is highly inefficient...
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetLists(                                   // get list of different objects
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN      DWORD                  RecursionDepth,// how much nesting allowed? 0 ==> one level only
    IN OUT  PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN OUT  PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN OUT  PARRAY                 Sites,         // dont know what this looks like now
    IN OUT  PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN OUT  PARRAY                 OptionDescription, // <options definition>
    IN OUT  PARRAY                 OptionsLocation, // <Location>
    IN OUT  PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN OUT  PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          LastError;

    if( 0 != Reserved ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;

    LastError = ERROR_SUCCESS;
    if( NULL != Servers ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SERVERS,
            /* ArrayToAddTo     */ Servers,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Subnets ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUBNETS,
            /* ArrayToAddTo     */ Subnets,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != IpAddress ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_ADDRESS,
            /* ArrayToAddTo     */ IpAddress,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Mask ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_MASK,
            /* ArrayToAddTo     */ Mask,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Ranges ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RANGES,
            /* ArrayToAddTo     */ Ranges,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Sites ) {
        // ignored for now
    }

    if( NULL != Reservations ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RESERVATIONS,
            /* ArrayToAddTo     */ Reservations,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != SuperScopes ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUPERSCOPES,
            /* ArrayToAddTo     */ SuperScopes,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != OptionsLocation ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS_LOC,
            /* ArrayToAddTo     */ OptionsLocation,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != OptionDescription ) {
        Result = StoreCollectAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTION_DESCRIPTION,
            /* ArrayToAddTo     */ OptionDescription,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Options ) {
        Result = StoreCollectBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS,
            /* ArrayToAddTo     */ Options,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    if( NULL != Classes ) {
        Result = StoreCollectBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_CLASSES,
            /* ArrayToAddTo     */ Classes,
            /* RecursionDepth   */ RecursionDepth
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
    }

    return LastError;
}

//DOC Clonestring just allocates memory for the string and copies it over and returns
//DOC that.
LPWSTR
CloneString(
    IN      LPWSTR                 Str
)
{
    LPWSTR                         RetVal;

    if( NULL == Str ) return NULL;
    RetVal = MemAlloc( sizeof(WCHAR)*(1+wcslen(Str)));
    if( NULL != RetVal ) wcscpy(RetVal, Str);
    return RetVal;
}

//DOC MarkFoundParam marks the given argno as found (converse of DhcpCheckParams )
VOID        _inline
MarkFoundParam(
    IN OUT  DWORD                 *FoundParams,
    IN      DWORD                  ArgNo
)
{
    (*FoundParams) |= (1 << ArgNo);
}

//BeginExport(function)
//DOC DhcpDsGetAttribs retreives all the miscellaneous attributes (whichever is requested) and
//DOC returns it as XXX_TYPE parameter.   These parameters are allocated within this function
//DOC using MemAlloc and must be freed via MemFree.  Any of the parameters maybe NULL indicating
//DOC lack of interest in that attribute.  (Note that the following parameters are NOT allocated:
//DOC they are just filled in: UniqueKey, Type, Flags, MScopeId, FoundParams)
//DOC Note that some of the parameters may not be found, but this can be checked against the
//DOC value returned in FoundParams (which is a REQUIRED parameter) using the FOUND_ARG(FoundParams,Arg#)
//DOC where the Args are numbered from 0 starting at UniqueKey..
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetAttribs(                                 // get list of attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,
    IN OUT  DWORD                 *FoundParams,   // which of the following params was found?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LARGE_INTEGER         *Flags,         // additional info about the object
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          i;
    DWORD                          nAttribs, nAttributes;
    LPWSTR                         Attribs[10];   // atmost 10 attribs are defined now...
    PADS_ATTR_INFO                 Attributes;

    if( Reserved != 0 ) return ERROR_INVALID_PARAMETER;
    if( NULL == FoundParams ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;

    *FoundParams = 0;                             // nothing has been found yet.
    nAttribs = 0;

    if( UniqueKey ) Attribs[nAttribs++] = DHCP_ATTRIB_UNIQUE_KEY;
    if( Type ) Attribs[nAttribs++] = DHCP_ATTRIB_TYPE;
    if( Flags ) Attribs[nAttribs++] = DHCP_ATTRIB_FLAGS;
    if( Name ) Attribs[nAttribs++] = DHCP_ATTRIB_OBJ_NAME;
    if( Description ) Attribs[nAttribs++] = DHCP_ATTRIB_OBJ_DESCRIPTION;
    if( Location ) Attribs[nAttribs++] = DHCP_ATTRIB_LOCATION_DN;
    if( MScopeId ) Attribs[nAttribs++] = DHCP_ATTRIB_MSCOPEID;

    if( 0 == nAttribs ) return ERROR_INVALID_PARAMETER;

    Attributes = NULL; nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        /* hDSObject            */ hStore->ADSIHandle,
        /* pAttributeNames      */ Attribs,
        /* dwNumberAttributes   */ nAttribs,
        /* ppAttributeEntries   */ &Attributes,
        /* pdwNumAttributesReturned */ &nAttributes
    );

    // hResult can be E_ADS_LDAP_NO_SUCH_ATTRIBUTE if only one attrib was asked for..
    if( FAILED(hResult) ) return ERROR_DDS_UNEXPECTED_ERROR;

    if( 0 == nAttributes ) {
        if( Attributes ) FreeADsMem(Attributes);
        return ERROR_DDS_UNEXPECTED_ERROR;
    }

    for( i = 0; i < nAttributes ; i ++ ) {
        if( ADSTYPE_INVALID == Attributes[i].dwADsType )
            continue;                             //?? should not really happen
        if( 0 == Attributes[i].dwNumValues )      //?? this should not happen either
            continue;

        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_UNIQUE_KEY ) ) {
            if( ADSTYPE_LARGE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *UniqueKey = Attributes[i].pADsValues[0].LargeInteger;
            MarkFoundParam(FoundParams, 0);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_TYPE ) ) {
            if( ADSTYPE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Type = Attributes[i].pADsValues[0].Integer;
            MarkFoundParam(FoundParams, 1);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_FLAGS ) ) {
            if( ADSTYPE_LARGE_INTEGER != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Flags = Attributes[i].pADsValues[0].LargeInteger;
            MarkFoundParam(FoundParams, 2);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_OBJ_NAME ) ) {
            if( ADSTYPE_CASE_IGNORE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Name = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 3);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_OBJ_DESCRIPTION ) ) {
            if( ADSTYPE_CASE_IGNORE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Description = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 4);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_LOCATION_DN ) ) {
            if( ADSTYPE_DN_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *Location = CloneString(Attributes[i].pADsValues[0].CaseIgnoreString);
            MarkFoundParam(FoundParams, 5);
            continue;
        }
        if( 0 == wcscmp(Attributes[i].pszAttrName, DHCP_ATTRIB_MSCOPEID ) ) {
            if( ADSTYPE_PRINTABLE_STRING != Attributes[i].pADsValues[0].dwType )
                continue;                         //?? should not happen
            *MScopeId = _wtol(Attributes[i].pADsValues[0].PrintableString);
            MarkFoundParam(FoundParams, 6);
            continue;
        }
    }

    FreeADsMem(Attributes);
    return ERROR_SUCCESS;
}

//BeginExport(inline)
//DOC DhcpCheckParams checks to see if the argument numbered (ArgNo) was found
//DOC as marked in the bitmap FoundParams.  Essentially used by the DhcpDsGetAttribs function only.
//DOC Return Values:
BOOL        _inline
DhcpCheckParams(                                  // check to see if requested param was returned
    IN      DWORD                  FoundParams,
    IN      DWORD                  ArgNo
)
{
    if( ArgNo > sizeof(FoundParams)*8 ) return FALSE;
    return ((FoundParams) & (1 << ArgNo) )?TRUE:FALSE;
}
//EndExport(inline)


//BeginExport(function)
//DOC DhcpDsSetLists function sets the various list of attributes to the values given.
//DOC it walks the arrays and encapsulates the arrays.
//DOC Note that in case of error, this function returns immediately.
//DOC In case of error, pl check the SetParams parameter with the CheckParams function
//DOC to determine which parameters were set... (no order guarantee is made for setting
//DOC the parameters).
//DOC Any PARRAY parameter may be omitted if it is not required to be modified.
//DOC SetParams is REQUIRED to be present.  See the discussion in DhcpDsGetAttribs for
//DOC the meaning of this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something bad happened
//DOC ERROR_DDS_TOO_MANY_ERRORS    too many simple errors
//DOC Store                        any errors returned by the store module
DWORD
DhcpDsSetLists(                                   // set the list of attributes after encapsulating them
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN OUT  LPDWORD                SetParams,     // which of the following params got modified really?
    IN      PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN      PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN      PARRAY                 Sites,         // dont know what this looks like now
    IN      PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN    PARRAY                   OptionDescription, // option definitions..
    IN      PARRAY                 OptionsLocation, // <Location>
    IN      PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN      PARRAY                 ClassDescription, // <Name, Description, String, Location>
    IN      PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          LastError;
    DWORD                          ArgNo;

    if( 0 != Reserved ) return ERROR_INVALID_PARAMETER;
    if( NULL == hStore || NULL == hStore->ADSIHandle ) return ERROR_INVALID_PARAMETER;
    if( NULL == SetParams ) return ERROR_INVALID_PARAMETER;

    LastError = ERROR_SUCCESS;

    ArgNo = 0;
    if( NULL != Servers ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SERVERS,
            /* ArrayToWrite     */ Servers
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Subnets ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUBNETS,
            /* ArrayToWrite     */ Subnets
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != IpAddress ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_ADDRESS,
            /* ArrayToWrite     */ IpAddress
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Mask ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_MASK,
            /* ArrayToWrite     */ Mask
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Ranges ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RANGES,
            /* ArrayToWrite     */ Ranges
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Sites ) {
        // ignored for now
        MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Reservations ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_RESERVATIONS,
            /* ArrayToWrite     */ Reservations
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != SuperScopes ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_SUPERSCOPES,
            /* ArrayToWrite     */ SuperScopes
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != OptionsLocation ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS_LOC,
            /* ArrayToWrite     */ OptionsLocation
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != OptionDescription ) {
        Result = StoreUpdateAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTION_DESCRIPTION,
            /* ArrayToWrite     */ OptionDescription
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Options ) {
        Result = StoreUpdateBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_OPTIONS,
            /* ArrayToWrite     */ Options
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    ArgNo ++;
    if( NULL != Classes ) {
        Result = StoreUpdateBinaryAttributes(
            /* hStore           */ hStore,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* AttribName       */ DHCP_ATTRIB_CLASSES,
            /* ArrayToWrite     */ Classes
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        else MarkFoundParam(SetParams, ArgNo);
    }

    return LastError;
}

//BeginExport(function)
//DOC DhcpDsSetAttribs sets the miscellaneous single-valued attributes.  Any of the attributes
//DOC may be omitted if not required to be set.  (In this case they must be set to NULL).
//DOC SetParams contains the information on which parameters were actually modified.
//DOC See DhcpDsGetAttribs on using this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something unexpected
//DOC Store                        any errors returned by the Store APIs
DWORD
DhcpDsSetAttribs(                                 // set these attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to set the attributes
    IN OUT  DWORD                 *SetParams,     // which of the following params were actually modified?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) //EndExport(function)
{
    DWORD                          Result, nAttributes, i, ArgNo;
    HRESULT                        hResult;
    ADS_ATTR_INFO                  Attributes[10];
    ADSVALUE                       Values[10];
    WCHAR                          MScopeIdString[20];

    if( NULL == hStore || NULL == hStore->ADSIHandle )
        return ERROR_INVALID_PARAMETER;

    i =  ArgNo = 0;
    if( UniqueKey ) {                             // this attribute is present
        Attributes[i].pszAttrName = DHCP_ATTRIB_UNIQUE_KEY;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwADsType = ADSTYPE_LARGE_INTEGER;
        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_LARGE_INTEGER;
        Attributes[i].pADsValues[0].LargeInteger = *UniqueKey;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    ArgNo ++;
    if( Type ) {                                  // this attribute is present
        Attributes[i].pszAttrName = DHCP_ATTRIB_TYPE;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwADsType = ADSTYPE_INTEGER;
        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_INTEGER;
        Attributes[i].pADsValues[0].Integer = *Type;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    ArgNo ++;
    if( Name ) {                                  // this attribute is present
        Attributes[i].pszAttrName = DHCP_ATTRIB_OBJ_NAME;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwADsType = ADSTYPE_DN_STRING;
        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_DN_STRING;
        Attributes[i].pADsValues[0].DNString = *Name;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    ArgNo ++;
    if( Description ) {                           // this attribute is present
        Attributes[i].pszAttrName = DHCP_ATTRIB_OBJ_DESCRIPTION;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwNumValues = 1;
        Attributes[i].dwADsType = ADSTYPE_DN_STRING;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_DN_STRING;
        Attributes[i].pADsValues[0].DNString = *Description;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    ArgNo ++;
    if( Location ) {                              // this attribute is present
        Attributes[i].pszAttrName = DHCP_ATTRIB_LOCATION_DN ;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwADsType = ADSTYPE_DN_STRING;
        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_DN_STRING;
        Attributes[i].pADsValues[0].DNString = *Location;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    ArgNo ++;
    if( MScopeId ) {                              // this attribute is present
        swprintf(MScopeIdString, L"0x%lx", MScopeIdString);
        Attributes[i].pszAttrName = DHCP_ATTRIB_MSCOPEID;
        Attributes[i].dwControlCode = ADS_ATTR_UPDATE;
        Attributes[i].dwADsType = ADSTYPE_DN_STRING;
        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = &Values[i];
        Attributes[i].pADsValues[0].dwType = ADSTYPE_DN_STRING;
        Attributes[i].pADsValues[0].DNString = MScopeIdString;
        MarkFoundParam(SetParams,ArgNo);
        i ++;
    }

    nAttributes = i;
    hResult = ADSISetObjectAttributes(
        /* hDSObject            */ hStore->ADSIHandle,
        /* pAttributeEntries    */ Attributes,
        /* dwNumAttributes      */ nAttributes,
        /* pdwNumAttributesMo.. */ &i
    );

    if( FAILED(hResult) ) return ERROR_DDS_UNEXPECTED_ERROR;

    return ERROR_SUCCESS;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dhcpbas.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#define     DDS_RESERVED_DWORD                    0
#define     DDS_RESERVED_PTR                      ((LPVOID)0)

//DOC The following constants are Flag values that maybe passed to different
//DOC functions.
#define     DDS_FLAGS_CREATE                      0x01

//DOC Some standard names and locations in the DS

#define     DHCP_ROOT_OBJECT_LOC                  L"CN=DhcpRoot, CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_PARENT_LOC           L"CN=NetServices, CN=Services"
#define     DHCP_ROOT_OBJECT_CN_NAME              L"CN=DhcpRoot"
#define     DHCP_ROOT_OBJECT_NAME                 L"DhcpRoot"

#define     DHCP_ATTRIB_WHEN_CHANGED              L"whenChanged"

//DOC The attributes that are defined for the dhcp class follows.

#define     DHCP_ATTRIB_UNIQUE_KEY                L"dhcpUniqueKey"         // reqd,single,integer8
#define     DHCP_ATTRIB_IDENTIFICATION            L"dhcpIdentification"    // reqd,single,directorystring
#define     DHCP_ATTRIB_TYPE                      L"dhcpType"              // reqd,single,integer
#define     DHCP_ATTRIB_FLAGS                     L"dhcpFlags"             // reqd,single,integer8
#define     DHCP_ATTRIB_DESCRIPTION               L"description"           // -,mv,directorystring
#define     DHCP_ATTRIB_CLASSES                   L"dhcpClasses"           // -,mv,octetstring
#define     DHCP_ATTRIB_MASK                      L"dhcpMask"              // -,mv,printablestring
#define     DHCP_ATTRIB_OBJ_DESCRIPTION           L"dhcpObjDescription"    // -,single,directorystring
#define     DHCP_ATTRIB_OBJ_NAME                  L"dhcpObjName"           // -,single,direcotrystring
#define     DHCP_ATTRIB_OPTIONS                   L"dhcpOptions"           // -,single,octetstring
#define     DHCP_ATTRIB_RANGES                    L"dhcpRanges"            // -,mv,printablestring
#define     DHCP_ATTRIB_RESERVATIONS              L"dhcpReservations"      // -,mv,printablestring
#define     DHCP_ATTRIB_SERVERS                   L"dhcpServers"           // -,mv,printablestring
#define     DHCP_ATTRIB_STATE                     L"dhcpState"             // -,mv,printablestring
#define     DHCP_ATTRIB_SUBNETS                   L"dhcpSubnets"           // -,mv,printablestring
#define     DHCP_ATTRIB_LOCATION_DN               L"locationDN"            // -,single,dn
#define     DHCP_ATTRIB_MSCOPEID                  L"mscopeid"              // -,single,printablestring
#define     DHCP_ATTRIB_ADDRESS                   L"networkAddress"        // -,mv,CaseIgnoreString
#define     DHCP_ATTRIB_OPTIONS_LOC               L"optionsLocation"       // -,mv,printablestring
#define     DHCP_ATTRIB_OPTION_DESCRIPTION        L"optionDescription"     // -,mv,directorystring
#define     DHCP_ATTRIB_SUPERSCOPES               L"superScopes"           // -,mv,printablestring

//DOC The following are the various types of objects recognized by the dhcp server
#define     DHCP_OBJ_TYPE_ROOT                    0                        // dhcp root object
#define     DHCP_OBJ_TYPE_SERVER                  1                        // dhcp server object
#define     DHCP_OBJ_TYPE_SUBNET                  2                        // subnet object
#define     DHCP_OBJ_TYPE_RANGE                   3                        // range object
#define     DHCP_OBJ_TYPE_RESERVATION             4                        // reservation object
#define     DHCP_OBJ_TYPE_OPTION                  5                        // options object
#define     DHCP_OBJ_TYPE_CLASS                   6                        // class object

#define     DHCP_OBJ_TYPE_ROOT_DESC               L"DHCP Root object"
#define     DHCP_OBJ_TYPE_SERVER_DESC             L"DHCP Server object"
#define     DHCP_OBJ_TYPE_SUBNET_DESC             L"Dhcp Subnet object"
#define     DHCP_OBJ_TYPE_RANGE_DESC              L"Dhcp Range object"
#define     DHCP_OBJ_TYPE_RESERVATION_DESC        L"Dhcp Reservation object"
#define     DHCP_OBJ_TYPE_OPTION_DESC             L"Dhcp Option object"
#define     DHCP_OBJ_TYPE_CLASS_DESC              L"Dhcp Class object"


//DOC The following defines are bitmasks and bits in various flags..

//DOC The flag2 portion of Ranges key is used for differntiating between exclusions and ranges
#define     RANGE_TYPE_RANGE                      0
#define     RANGE_TYPE_EXCL                       1
#define     RANGE_TYPE_MASK                       (0x1)



//DOC DhcpDsGetDhcpC gets the dhcp container in the DS.. This is usually the
//DOC container CN=Netservices,CN=Services,CN=Configuration etc..
//DOC This is used in many functions, so it is useful to have a central function..
//DOC
DWORD
DhcpDsGetDhcpC(                                   // get dhcp container
    IN      DWORD                  Reserved,      // future use
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // config container handle
    OUT     LPSTORE_HANDLE         hDhcpC         // output dhcp container handle
) ;


//DOC DhcpDsGetRoot gets the dhcp root object given to the configuration container
//DOC This is usually CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration...
//DOC If Flags has the DDS_FLAGS_CREATE bit set, then the root object is created.
//DOC Return Values:
//DOC Store                        any returns returned by the Store module
//DOC ERROR_DDS_NO_DHCP_ROOT       no DhcpRoot object found
//DOC ERROR_DDS_UNEXPECTED_ERROR   the DhcpRoot's parent container not found..
DWORD
DhcpDsGetRoot(
    IN      DWORD                  Flags,         // 0 or DDS_FLAGS_CREATE
    IN OUT  LPSTORE_HANDLE         hStoreCC,      // configuration container handle
    OUT     LPSTORE_HANDLE         hStoreDhcpRoot // dhcp root object handle
) ;


//DOC DhcpDsGetLists function retrives a list of attributes and adds it the given array
//DOC allocating each element separateley, and traversing any pointers indicated by
//DOC the value of the attribute.
//DOC Note that even in case of error, the array may still contain some elements.
//DOC This is a best effort even in case of failure.
//DOC Each element of the array must be freed via MemFree, and the array itself
//DOC must be cleaned up via MemArrayCleanup.
//DOC Note that any of the PARRAY type parameters may be NULL, as they are optional.
//DOC but reading these separately is highly inefficient...
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetLists(                                   // get list of different objects
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN      DWORD                  RecursionDepth,// how much nesting allowed? 0 ==> one level only
    IN OUT  PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN OUT  PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN OUT  PARRAY                 Sites,         // dont know what this looks like now
    IN OUT  PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN OUT  PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN OUT  PARRAY                 OptionDescription, // <options definition>
    IN OUT  PARRAY                 OptionsLocation, // <Location>
    IN OUT  PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN OUT  PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) ;


//DOC DhcpDsGetAttribs retreives all the miscellaneous attributes (whichever is requested) and
//DOC returns it as XXX_TYPE parameter.   These parameters are allocated within this function
//DOC using MemAlloc and must be freed via MemFree.  Any of the parameters maybe NULL indicating
//DOC lack of interest in that attribute.  (Note that the following parameters are NOT allocated:
//DOC they are just filled in: UniqueKey, Type, Flags, MScopeId, FoundParams)
//DOC Note that some of the parameters may not be found, but this can be checked against the
//DOC value returned in FoundParams (which is a REQUIRED parameter) using the FOUND_ARG(FoundParams,Arg#)
//DOC where the Args are numbered from 0 starting at UniqueKey..
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   some entirely unexpected error
//DOC ERROR_DDS_TOO_MANY_ERRORS    multiple errors occured, and was caught
//DOC Store                        any errors returned by the store apis
DWORD
DhcpDsGetAttribs(                                 // get list of attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,
    IN OUT  DWORD                 *FoundParams,   // which of the following params was found?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LARGE_INTEGER         *Flags,         // additional info about the object
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) ;


//DOC DhcpCheckParams checks to see if the argument numbered (ArgNo) was found
//DOC as marked in the bitmap FoundParams.  Essentially used by the DhcpDsGetAttribs function only.
//DOC Return Values:
BOOL        _inline
DhcpCheckParams(                                  // check to see if requested param was returned
    IN      DWORD                  FoundParams,
    IN      DWORD                  ArgNo
)
{
    if( ArgNo > sizeof(FoundParams)*8 ) return FALSE;
    return ((FoundParams) & (1 << ArgNo) )?TRUE:FALSE;
}


//DOC DhcpDsSetLists function sets the various list of attributes to the values given.
//DOC it walks the arrays and encapsulates the arrays.
//DOC Note that in case of error, this function returns immediately.
//DOC In case of error, pl check the SetParams parameter with the CheckParams function
//DOC to determine which parameters were set... (no order guarantee is made for setting
//DOC the parameters).
//DOC Any PARRAY parameter may be omitted if it is not required to be modified.
//DOC SetParams is REQUIRED to be present.  See the discussion in DhcpDsGetAttribs for
//DOC the meaning of this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something bad happened
//DOC ERROR_DDS_TOO_MANY_ERRORS    too many simple errors
//DOC Store                        any errors returned by the store module
DWORD
DhcpDsSetLists(                                   // set the list of attributes after encapsulating them
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to get the lists for
    IN OUT  LPDWORD                SetParams,     // which of the following params got modified really?
    IN      PARRAY                 Servers,       // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Subnets,       // <Name,Description,IpAddress,Mask,State,Location>
    IN      PARRAY                 IpAddress,     // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Mask,          // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 Ranges,        // <Name,Description,IpAddress1,IpAddress2,State,Location>
    IN      PARRAY                 Sites,         // dont know what this looks like now
    IN      PARRAY                 Reservations,  // <Name,Description,IpAddress,State,Location>
    IN      PARRAY                 SuperScopes,   // <Name,Description,State,DWORD, Location>
    //IN    PARRAY                 SuperScopesDescription, // UNUSED
    IN    PARRAY                   OptionDescription, // option definitions..
    IN      PARRAY                 OptionsLocation, // <Location>
    IN      PARRAY                 Options,       // xxx <Name, Description, String1=HexStream>
    IN      PARRAY                 ClassDescription, // <Name, Description, String, Location>
    IN      PARRAY                 Classes        // xxx <Name, Description, String1=HexStream>
) ;


//DOC DhcpDsSetAttribs sets the miscellaneous single-valued attributes.  Any of the attributes
//DOC may be omitted if not required to be set.  (In this case they must be set to NULL).
//DOC SetParams contains the information on which parameters were actually modified.
//DOC See DhcpDsGetAttribs on using this parameter.
//DOC Return Values:
//DOC ERROR_DDS_UNEXPECTED_ERROR   something unexpected
//DOC Store                        any errors returned by the Store APIs
DWORD
DhcpDsSetAttribs(                                 // set these attributes
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN OUT  LPSTORE_HANDLE         hStore,        // the object to set the attributes
    IN OUT  DWORD                 *SetParams,     // which of the following params were actually modified?
    IN OUT  LARGE_INTEGER         *UniqueKey,     // fill in an unique key
    IN OUT  DWORD                 *Type,          // object type
    IN OUT  LPWSTR                *Name,          // Allocated, name of object
    IN OUT  LPWSTR                *Description,   // Allocated, something that describes this object
    IN OUT  LPWSTR                *Location,      // the reference location from which to do other stuff
    IN OUT  DWORD                 *MScopeId       // what is the scope id used?
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\delete.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC  SubnetDeleteReservation deletes the reservation object from off the DS.
SubnetDeleteReservation(                          // delete reservation from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for resrevation objs
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object in DS
    IN      LPWSTR                 ADsPath,       // path of reservation object
    IN      DWORD                  StoreGetType   // path is relative, abs, or dif server?
) ;


//DOC  ServerDeleteSubnet deletes the subnet specified from the DS by removing
//DOC  the subnet object.
ServerDeleteSubnet(                               // remove subnet object from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for subnet objs in Ds
    IN      LPWSTR                 ServerName,    // name of server this deletion is for
    IN OUT  LPSTORE_HANDLE         hServer,       // server object in DS
    IN      LPWSTR                 ADsPath,       // Location of the subnet in DS
    IN      DWORD                  StoreGetType   // path is relative,abs or diff srvr?
) ;


//DOC  DeleteServer deletes the server object from the DS and deletes any SUBNET and
//DOC  reservation objects that it may point to.
//DOC  The hDhcpC parameter is the handle of the container where the server object
//DOC  may be located. This used in conjunction with the ADsPath and StoreGetType
//DOC  defines the location of the ServerObject.
DWORD
DeleteServer(                                     // recurse delete server from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where server obj may be
    IN      LPWSTR                 ServerName,    // name of server..
    IN      LPWSTR                 ADsPath,       // path of the server object
    IN      DWORD                  StoreGetType   // is path relative, absolute or dif srvr?
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dsdmp.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: command line tool to dump the ds in a way that could be
//    understood by the dsini program.
//================================================================================

//BeginExport(overview)
//DOC DSDMP is a command line too very similar to the REGDMP.
//DOC It takes as parameter the LDAP path of the DS object to root the dumping,
//DOC followed by the list of attributes to look for each object found
//DOC The output of this is in the same format as that of the DSINI program's input.
//EndExport(overview)

//BeginImports(headers)
#include    <hdrmacro.h>
#include    <store.h>
#include    <stdio.h>
//EndImports(headers)

//BeginInternal(globals)
static      DWORD                  nTabs = 0;
static      LPWSTR                 RecurseFilter = L"(name=*)" ;
static      WCHAR                  Buffer[1000];
static      WCHAR                  Strings[30][100];
//EndExport(globals)

VOID
ErrorPrint(
    IN      LPSTORE_HANDLE         hStore,
    IN      DWORD                  Result,
    IN      LPWSTR                 Comment
)
{
    if( NULL != hStore ) {
        printf("\n#%ws\n#%ws (errror %ld, 0x%lx)\n", hStore->Location, Comment, Result, Result );
        return;
    }

    printf("\n#%ws (errror %ld, 0x%lx)\n", Comment, Result, Result);
}

LPWSTR
ConvertDWORD(
    IN      DWORD                  d
)
{
    swprintf(Buffer, L"0x%08lx", d);
    return Buffer;
}

#define     HEX(ch)                ( ((ch) < 10)? ((ch) + L'0') : ((ch) + L'A' - 10))

LPWSTR
ConvertBINARY(
    IN      DWORD                  l,
    IN      LPBYTE                 s
)
{
    DWORD                          i;

    i = 0;
    while( l ) {
        Buffer[i++] = HEX(((*s)>>4));
        Buffer[i++] = HEX(((*s) & 0x0F));
        l --; s ++;
    }

    Buffer[i] = L'\0';
    return Buffer;
}

VOID
Print(
    IN      LPWSTR                 Operation,
    IN      DWORD                  Type,
    IN      LPWSTR                 AttributeName
)
{
    DWORD                          i;

    putchar('\n');
    for(i = 1; i < nTabs; i ++ ) printf("    ");
    printf("%ws %ld :%ws", Operation, Type, AttributeName);
}

VOID
PrintMore(
    IN      LPWSTR                 String
)
{
    printf("=%ws", String);
}


VOID
PrintName(
    IN      LPSTORE_HANDLE         hStore
)
{
    DWORD                          i;

    if( 1 == nTabs ) return;

    putchar('\n');
    for(i = 1; i < nTabs; i ++ ) printf("    ");
    printf("object");
}

DWORD
AttributeDmp(
    IN      ADS_ATTR_INFO          Attribute
)
{
    DWORD                          Result;
    DWORD                          i;

    if( 0 == Attribute.dwNumValues ) {
        Print(L"clear", Attribute.dwADsType, Attribute.pszAttrName);
        return ERROR_SUCCESS;
    }

    for( i = 0; i < Attribute.dwNumValues; i ++ ) {
        if( ADSTYPE_INVALID == Attribute.pADsValues[i].dwType )
            continue;

        Print((i==0) ? L"update" : L"append", Attribute.dwADsType, Attribute.pszAttrName);
        switch(Attribute.pADsValues[i].dwType) {
        case ADSTYPE_INVALID:
            // error!
            break;
        case ADSTYPE_DN_STRING:
            PrintMore(Attribute.pADsValues[i].DNString); break;
        case ADSTYPE_CASE_EXACT_STRING:
            PrintMore(Attribute.pADsValues[i].CaseExactString); break;
        case ADSTYPE_CASE_IGNORE_STRING:
            PrintMore(Attribute.pADsValues[i].CaseIgnoreString); break;
        case ADSTYPE_PRINTABLE_STRING:
            PrintMore(Attribute.pADsValues[i].PrintableString); break;
        case ADSTYPE_NUMERIC_STRING:
            PrintMore(Attribute.pADsValues[i].NumericString); break;
        case ADSTYPE_BOOLEAN:
            PrintMore(ConvertDWORD(Attribute.pADsValues[i].Boolean)); break;
        case ADSTYPE_INTEGER:
            PrintMore(ConvertDWORD(Attribute.pADsValues[i].Integer)); break;
        case ADSTYPE_OCTET_STRING:
            PrintMore(ConvertBINARY(Attribute.pADsValues[i].OctetString.dwLength,
                                    Attribute.pADsValues[i].OctetString.lpValue
            )); break;
        case ADSTYPE_LARGE_INTEGER:
        case ADSTYPE_PROV_SPECIFIC:
            break;
        case ADSTYPE_OBJECT_CLASS:
            PrintMore(Attribute.pADsValues[i].ClassName); break;
        }
    }
    return ERROR_SUCCESS;
}

DWORD
AttributesDmp(
    IN      LPSTORE_HANDLE         hStore,
    IN      DWORD                  nAttribs,
    IN      LPWSTR                *Attribs
)
{
    HRESULT                        hResult;
    DWORD                          Result, i ;
    DWORD                          nAttributes;
    PADS_ATTR_INFO                 Attributes;

    Attributes = NULL; nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        hStore->ADSIHandle,
        Attribs,
        nAttribs,
        &Attributes,
        &nAttributes
    );
    if( FAILED(hResult) ) {
        return ERROR_GEN_FAILURE;
    }

    for( i = 0; i < nAttributes ; i ++ ) {
        Result = AttributeDmp(Attributes[i]);
        if( ERROR_SUCCESS != Result ) {
            ErrorPrint(NULL, Result, L"AttributeDmp");
        }
    }

    if( Attributes ) FreeADsMem(Attributes);
    return ERROR_SUCCESS;
}

DWORD
RecurseDmp(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  nAttribs,
    IN      LPWSTR                 Attribs[]
)
{
    DWORD                          Result;
    STORE_HANDLE                   hStore2;

    nTabs ++;
    PrintName(hStore);

    Result = AttributesDmp(hStore,nAttribs,Attribs);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"AttributesDmp failed");
    }

    Result = StoreSetSearchOneLevel(hStore, 0);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"StoreSetSearchOneLevel failed");
        nTabs --;
        return Result;
    }

    Result = StoreBeginSearch(hStore, 0, RecurseFilter);
    if( ERROR_SUCCESS != Result ) {
        ErrorPrint(hStore, Result, L"StoreBeginSearch failed");
    } else {
        while ( ERROR_SUCCESS == Result ) {
            Result = StoreSearchGetNext(hStore, 0, &hStore2);
            if( ERROR_SUCCESS != Result ) {
                if( ERROR_FILE_NOT_FOUND == Result ) break;
                if( ERROR_NO_MORE_ITEMS == Result ) break;
                ErrorPrint(hStore, Result, L"StoreSearchGetNext failed");
                break;
            }

            Result = RecurseDmp(&hStore2, nAttribs, Attribs);
            if( ERROR_SUCCESS != Result ) {
                ErrorPrint(&hStore2, Result, L"RecurseDmp failed");
                break;
            }

            StoreCleanupHandle(&hStore2, 0);
        }

        StoreEndSearch(hStore, 0);
    }

    nTabs --;
    return ERROR_SUCCESS;
}

LPWSTR
ConvertToLPWSTR(
    IN      LPSTR                  s
)
{
    LPWSTR                         u, v;

    if( NULL == s ) return L"";

    u = LocalAlloc(LMEM_FIXED, (strlen(s)+1)*sizeof(WCHAR));
    if( NULL == u ) return L"";

    v = u;
    while( *v++ = *s++)
        ;

    return u;
}


void _cdecl main(
    int     argc,
    char   *argv[]
)
{
    LPWSTR                         RootName;
    LPWSTR                        *Attribs;
    STORE_HANDLE                   Store, Store2;
    DWORD                          nNames, i;
    DWORD                          Result;

    Attribs = NULL;
    nNames = argc-2 +1;
    if( argc == 1 ) {
        printf("Usage: %s Root-DN-To-DUMP Attribute-names-To-DUMP\n", argv[0]);
        return;
    }

    RootName = ConvertToLPWSTR(argv[1]);
    if( NULL == RootName ) {
        printf("RootDN confusing\n");
        return;
    }

    Attribs = LocalAlloc(LMEM_FIXED, nNames * sizeof(LPWSTR));
    if( NULL == Attribs ) {
        printf("not enough memory\n");
        return;
    }

    Result = StoreInitHandle(
        &Store, 0, NULL, NULL, NULL, NULL,
        ADS_SECURE_AUTHENTICATION
        );
    if( ERROR_SUCCESS != Result ) {
        printf("StoreInitHandle: %ld\n", Result);
        return;
    }

    if( wcslen(RootName) == 0 ) {
        Result = StoreDuplicateHandle(&Store, 0, &Store2);
    } else {
        Result = StoreGetHandle(&Store, 0, StoreGetChildType, RootName, &Store2);
        if( ERROR_SUCCESS != Result )
            Result = StoreGetHandle(&Store, 0, StoreGetAbsoluteSameServerType, RootName, &Store2);
        if( ERROR_SUCCESS != Result )
            Result = StoreGetHandle(&Store, 0, StoreGetAbsoluteOtherServerType, RootName, &Store2);
    }
    if( ERROR_SUCCESS != Result ) {
        printf("could not find %ws\n", RootName);
        return;
    }
    Result = StoreCleanupHandle(&Store, 0);

    printf("################################################################################\n");
    printf("##  G E N E R E R A T E D   D S  D U M P                                      ##\n");
    printf("##  command line : (will be filled in future versions)                        ##\n");
    printf("##  DSDSMP.EXE 1.0                                                            ##\n");
    printf("################################################################################\n");
    printf("object %ws", RootName);

    Attribs[0] = L"name";

    for( i = 1; i < nNames ; i ++ ) {
        Attribs[i] = ConvertToLPWSTR(argv[i+1]);
    }

    RecurseDmp(&Store2, nNames, Attribs);
    putchar('\n');

    exit(0);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dhcpread.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This module implements most of the reading part of the ds access
//================================================================================

//================================================================================
//  headers
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>                            // need all the MM stuff...
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>                     // need all the registry stuff
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>

#define     DONT_USE_PARENT        (0)
//================================================================================
//  misc helper functions
//================================================================================
VOID
ArrayMemFree(                                     // free each ptr of the array using MemFree
    IN OUT  PARRAY                 Array
)
{
    DWORD                          Result;
    ARRAY_LOCATION                 Loc;
    LPVOID                         Ptr;

    Result = MemArrayInitLoc(Array, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(Array, &Loc, &Ptr);
        //- ERROR_SUCCESS == Result
        if( Ptr ) MemFree(Ptr);
        Result = MemArrayNextLoc(Array, &Loc);
    }

    MemArrayCleanup(Array);
}

//================================================================================
//  exported functions and helpers
//================================================================================

DWORD
CheckoutAlternateOptions(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN      PARRAY                 AltAttribs,
    IN OUT  PARRAY                 OptDefAttribs,
    IN OUT  PARRAY                 OptAttribs
);

DWORD
CheckoutAlternateOptions1(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN      PEATTRIB               ThisAttrib,
    IN OUT  PARRAY                 OptDefAttribs,
    IN OUT  PARRAY                 OptAttribs
)
{
    DWORD                          Result;
    STORE_HANDLE                   hStore;
    ARRAY                          AlternateOptAttribs;

    if( !IS_ADSPATH_PRESENT(ThisAttrib) ) return ERROR_SUCCESS;

    Result = StoreGetHandle(
        /* hStore               */ hContainer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ ThisAttrib->StoreGetType,
        /* Path                 */ ThisAttrib->ADsPath,
        /* hStoreOut            */ &hStore
    );
    if( ERROR_DS_NO_SUCH_OBJECT == Result ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Result ) return Result;

    MemArrayInit(&AlternateOptAttribs);
    Result = DhcpDsGetLists(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hStore,
        /* RecursionDepth       */ 0x7FFFFFFF,    // max out recursion
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti      */ OptDefAttribs,
        /* OptionsLocation      */ &AlternateOptAttribs,
        /* Options              */ OptAttribs,
        /* Classes              */ NULL
    );

    CheckoutAlternateOptions(hContainer, &AlternateOptAttribs, OptDefAttribs, OptAttribs);

    StoreCleanupHandle(&hStore, DDS_RESERVED_DWORD );
    ArrayMemFree(&AlternateOptAttribs);

    return ERROR_SUCCESS;
}

DWORD
CheckoutAlternateOptions(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN      PARRAY                 AltAttribs,
    IN OUT  PARRAY                 OptDefAttribs,
    IN OUT  PARRAY                 OptAttribs
)
{
    DWORD                          Result;
    DWORD                          LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(AltAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(AltAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib
        Result = CheckoutAlternateOptions1(hContainer,ThisAttrib, OptDefAttribs, OptAttribs);
        if( ERROR_SUCCESS != Result ) LastError = Result;
        Result = MemArrayNextLoc(AltAttribs, &Loc);
    }

    return LastError;
}

DWORD
DhcpOptClassAddOption(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PEATTRIB               Option
)
{
    DWORD                          Result;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    DWORD                          OptionId, Flags;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPBYTE                         Value;
    PM_OPTION                      NewOption, DeletedOption;
    PM_CLASSDEF                    ThisClassDef;

    if( !IS_BINARY1_PRESENT(Option) || !IS_DWORD1_PRESENT(Option) )
        return ERROR_INVALID_DATA;

    if( IS_STRING4_PRESENT(Option) ) ClassName = Option->String4;
    else ClassName = NULL;

    if( IS_STRING3_PRESENT(Option) ) VendorName = Option->String3;
    else VendorName = NULL;

    OptionId = Option->Dword1;
    if( IS_FLAGS1_PRESENT(Option) ) Flags = Option->Flags1; else Flags = 0;
    Value = Option->Binary1;
    ValueSize = Option->BinLen1;

    if( NULL == ClassName ) ClassId = 0;
    else {
        Result = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Result ) {
            // INVALID_REG("OptDef %ld unknown class %ws, option ignored\n", ClassName);
            ClassId =0;
        } else {
            ClassId = ThisClassDef->ClassId;
            //- ThisClassDef->IsVendor == FALSE
        }
    }

    if( NULL == VendorName ) VendorId = 0;
    else {
        Result = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Result ) {
            // INVALID_REG("OptDef %ld unknown class %ws, option ignored\n", VendorName);
            VendorId =0;
        } else {
            VendorId = ThisClassDef->ClassId;
            //- ThisClassDef->IsVendor == TRUE
        }
    }

    Result = MemOptInit(&NewOption, OptionId, ValueSize, Value);
    if( ERROR_SUCCESS != Result ) return Result;

    DeletedOption = NULL;
    Result = MemOptClassAddOption(OptClass, NewOption, ClassId , VendorId, &DeletedOption);

    if( ERROR_SUCCESS != Result ) {
        MemOptCleanup(NewOption);
    }
    if( DeletedOption ) {
        MemOptCleanup(DeletedOption);
    }

    return Result;
}

DWORD
DhcpOptClassAddOptions(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PARRAY                 OptAttribs
)
{
    DWORD                          Result, LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisOpt;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(OptAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(OptAttribs, &Loc, &ThisOpt);
        //- ERROR_SUCCESS == Result && ThisOpt
        Result = DhcpOptClassAddOption(Server, OptClass,ThisOpt);
        if( ERROR_SUCCESS != Result ) LastError = Result;

        Result = MemArrayNextLoc(OptAttribs, &Loc);
    }
    return LastError;
}

DWORD
FirstAddress(
    IN      PARRAY                 Attribs
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Result;
    PEATTRIB                       ThisAttrib;

    Result = MemArrayInitLoc(Attribs, &Loc);
    if( ERROR_SUCCESS != Result ) return 0;
    Result = MemArrayGetElement(Attribs, &Loc, &ThisAttrib);
    if( ERROR_SUCCESS != Result ) return 0;

    if( IS_ADDRESS1_PRESENT(ThisAttrib) ) return ThisAttrib->Address1;
    return 0;
}

//================================================================================
// operations on the server or global object ONLY
//================================================================================

DWORD
DhcpServerAddClass(
    IN OUT  PM_SERVER              Server,
    IN      PEATTRIB               Class
)
{
    DWORD                          Result;
    DWORD                          Flags;
    DWORD                          ValueSize;
    LPBYTE                         Value;
    LPWSTR                         Name;
    LPWSTR                         Comment;

    if( !IS_STRING1_PRESENT(Class) ||
        !IS_BINARY1_PRESENT(Class) )
        return ERROR_INVALID_PARAMETER;

    Name = Class->String1;
    if( IS_STRING2_PRESENT(Class) ) Comment = Class->String2;
    else Comment = NULL;

    if( IS_FLAGS1_PRESENT(Class) ) Flags = Class->Flags1;
    else Flags = 0;

    Value = Class->Binary1;
    ValueSize = Class->BinLen1;

    Result = MemClassDefListAddClassDef(
        &(Server->ClassDefs),
        MemNewClassId(),
        Flags,
        0, /* dont care about type */
        Name,
        Comment,
        Value,
        ValueSize
    );

    return Result;
}

DWORD
DhcpServerAddClasses(
    IN OUT  PM_SERVER              Server,
    IN      PARRAY                 ClassAttribs
)
{
    DWORD                          Result;
    DWORD                          LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisClass;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(ClassAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(ClassAttribs, &Loc, &ThisClass);
        //- ERROR_SUCCESS == Result && NULL != ThisC;as
        Result = DhcpServerAddClass(Server, ThisClass );
        if( ERROR_SUCCESS != Result ) LastError = Result;

        Result = MemArrayNextLoc(ClassAttribs, &Loc);
    }
    return LastError;
}

DWORD
DhcpServerAddOptDef(
    IN OUT  PM_SERVER              Server,
    IN      PEATTRIB               OptDef
)
{
    DWORD                          Result;
    LPWSTR                         Name,Comment,ClassName, VendorName;
    DWORD                          OptionId, Flags;
    DWORD                          ValueSize;
    DWORD                          ClassId, VendorId;
    LPBYTE                         Value;
    PM_CLASSDEF                    ThisClassDef;

    if( !IS_STRING1_PRESENT(OptDef) || !IS_BINARY1_PRESENT(OptDef) ||
        !IS_DWORD1_PRESENT(OptDef) ) return ERROR_INVALID_DATA;

    Name = OptDef->String1;
    if( IS_STRING2_PRESENT(OptDef) ) Comment = OptDef->String2;
    else Comment = NULL;

    if( IS_STRING4_PRESENT(OptDef) ) ClassName = OptDef->String4;
    else ClassName = NULL;

    if( IS_STRING3_PRESENT(OptDef) ) VendorName = OptDef->String3;
    else VendorName = NULL;

    OptionId = OptDef->Dword1;

    if( IS_FLAGS1_PRESENT(OptDef) ) Flags = OptDef->Flags1; else Flags = 0;

    Value = OptDef->Binary1;
    ValueSize = OptDef->BinLen1;

    if( NULL == ClassName ) ClassId = 0;
    else {
        Result = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Result ) {
            // INVALID_REG("OptDef %ld unknown class %ws, option ignored\n", ClassName);
            ClassId =0;
        } else {
            ClassId = ThisClassDef->ClassId;
            //- ThisClassDef->IsVendor == FALSE
        }
    }

    if( NULL == VendorName ) VendorId = 0;
    else {
        Result = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Result ) {
            // INVALID_REG("OptDef %ld unknown class %ws, option ignored\n", VendorName);
            VendorId =0;
        } else {
            VendorId = ThisClassDef->ClassId;
            //- ThisClassDef->IsVendor == TRUE
        }
    }

    return MemOptClassDefListAddOptDef(
       &(Server->OptDefs),
       ClassId,
       VendorId,
       OptionId,
       Flags,
       Name,
       Comment,
       Value,
       ValueSize
   );
}

DWORD
DhcpServerAddOptionDefs(
    IN OUT  PM_SERVER              Server,
    IN      PARRAY                 OptDefAttribs
)
{
    DWORD                          Result;
    DWORD                          LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisOptDef;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(OptDefAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(OptDefAttribs, &Loc, &ThisOptDef);
        //- ERROR_SUCCESS == Result && NULL != ThisOptDef
        Result = DhcpServerAddOptDef(Server, ThisOptDef );
        if( ERROR_SUCCESS != Result ) LastError = Result;

        Result = MemArrayNextLoc(OptDefAttribs, &Loc);
    }
    return LastError;
}

DWORD
DhcpServerAddOptions(
    IN OUT  PM_SERVER              Server,
    IN      PARRAY                 OptAttribs
)
{
    return DhcpOptClassAddOptions(
        Server,
        &Server->Options,
        OptAttribs
    );
}

DWORD
DhcpSubnetAddOptions(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_SUBNET              Subnet,
    IN      PARRAY                 OptAttribs
)
{
    return DhcpOptClassAddOptions(
        Server,
        &Subnet->Options,
        OptAttribs
    );
}

DWORD
DhcpSubnetAddRanges(
    IN OUT  PM_SUBNET              Subnet,
    IN      PARRAY                 RangeAttribs
)
{
    DWORD                          Result, LastError;
    DWORD                          Type;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisRange;
    PM_RANGE                       OverlappingRange;
    PM_EXCL                        OverlappingExcl;
    ULONG                          State, BootpAllocated, MaxBootpAllocated;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(RangeAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(RangeAttribs, &Loc, &ThisRange);
        //- ERROR_SUCCESS == Result && NULL != ThisRange
        if( !IS_ADDRESS1_PRESENT(ThisRange) ||
            !IS_ADDRESS2_PRESENT(ThisRange) ||
            !IS_FLAGS1_PRESENT(ThisRange) )
            LastError = ERROR_INVALID_DATA;
        else {
            OverlappingRange = NULL;
            OverlappingExcl = NULL;
            if( IS_FLAGS2_PRESENT(ThisRange) ) Type = ThisRange->Flags2;
            else Type = RANGE_TYPE_RANGE;
            BootpAllocated = IS_DWORD1_PRESENT(ThisRange)? ThisRange->Dword1 : 0;
            MaxBootpAllocated = IS_DWORD2_PRESENT(ThisRange) ? ThisRange->Dword2 : ~0;

            if( (Type & RANGE_TYPE_MASK) == RANGE_TYPE_RANGE ) {
                Result = MemSubnetAddRange(
                    Subnet,
                    ThisRange->Address1,
                    ThisRange->Address2,
                    ThisRange->Flags1,
                    BootpAllocated,
                    MaxBootpAllocated,
                    &OverlappingRange
                );
                if( ERROR_SUCCESS != Result || OverlappingRange )
                    LastError = Result;
            } else {
                Result = MemSubnetAddExcl(
                    Subnet,
                    ThisRange->Address1,
                    ThisRange->Address2,
                    &OverlappingExcl
                );
                if( ERROR_SUCCESS != Result || OverlappingExcl )
                    LastError = Result;
            }
        }
        Result = MemArrayNextLoc(RangeAttribs, &Loc);
    }

    return LastError;
}

DWORD
DhcpSubnetAddSuperScopes(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_SUBNET              Subnet,
    IN      PARRAY                 SuperScopeAttribs
)
{
    DWORD                          Result;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    PM_SSCOPE                      SScope;

    Result = MemArrayInitLoc(SuperScopeAttribs, &Loc);
    if( ERROR_SUCCESS != Result ) return ERROR_SUCCESS;

    Result = MemArrayGetElement(SuperScopeAttribs, &Loc, &ThisAttrib);
    if( ERROR_SUCCESS != Result ) return Result;

    if( !IS_STRING1_PRESENT(ThisAttrib) ) return ERROR_INVALID_DATA;

    Result = MemServerFindSScope(
        Server,
        0xFFFFFFFF,                               // invalid scope id ==> use scope name for search
        ThisAttrib->String1,
        &SScope
    );
    if( ERROR_FILE_NOT_FOUND != Result ) {
        if( ERROR_SUCCESS != Result ) return Result;
        Result = MemSubnetSetSuperScope(Subnet, SScope);
        return Result;
    }

    Result = MemSScopeInit(
        &SScope,
        IS_FLAGS2_PRESENT(ThisAttrib)?ThisAttrib->Flags2:0,
        ThisAttrib->String1
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = MemServerAddSScope( Server, SScope );
    if( ERROR_SUCCESS != Result ) {
        MemSScopeCleanup(SScope);
    }

    return Result;
}

DWORD
DhcpSubnetAddReservation(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hSubnet,
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_SUBNET              Subnet,
    IN      PEATTRIB               ReservationAttrib
)
{
    DWORD                          Result;
    DWORD                          Address, State;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    ARRAY                          Options;
    PM_RESERVATION                 Res1;

    if( !IS_ADDRESS1_PRESENT(ReservationAttrib) ||
        !IS_FLAGS1_PRESENT(ReservationAttrib)   ||
        !IS_BINARY1_PRESENT(ReservationAttrib) )
        return ERROR_SUCCESS;

    Address = ReservationAttrib->Address1;
    State = ReservationAttrib->Flags1;
    ClientUID = ReservationAttrib->Binary1;
    nBytes = ReservationAttrib->BinLen1;

    Result = MemReserveAdd(
        &Subnet->Reservations,
        Address,
        State,
        ClientUID,
        nBytes
    );
    if( ERROR_SUCCESS != Result ) return Result;

    if( !IS_ADSPATH_PRESENT(ReservationAttrib) )
        return ERROR_SUCCESS;

    Result = MemReserveFindByAddress(
        &Subnet->Reservations,
        Address,
        &Res1
    );
    if( ERROR_SUCCESS != Result ) return ERROR_DDS_UNEXPECTED_ERROR;

    MemArrayInit(&Options);
    Result = CheckoutAlternateOptions1(
        hContainer,
        ReservationAttrib,
        NULL,
        &Options
    );
    //Ignore Result

    if( 0 == MemArraySize(&Options) ) Result = ERROR_SUCCESS;
    else Result = DhcpOptClassAddOptions(
        Server,
        &Res1->Options,
        &Options
    );
    ArrayMemFree(&Options);

    return Result;
}

DWORD
DhcpSubnetAddReservations(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hSubnet,
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_SUBNET              Subnet,
    IN      PARRAY                 ReservationAttribs
)
{
    DWORD                          Result, LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisReservation;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(ReservationAttribs, &Loc);
    while(ERROR_FILE_NOT_FOUND != Result ) {
        //= ERROR_SUCCESS == Result
        Result = MemArrayGetElement(ReservationAttribs, &Loc, &ThisReservation);
        //- ERROR_SUCCESS == Result && NULL != ThisReservation
        Result = DhcpSubnetAddReservation(hContainer, hDhcpRoot, hSubnet, Server, Subnet, ThisReservation);
        if( ERROR_SUCCESS != Result ) LastError = Result;

        Result = MemArrayNextLoc(ReservationAttribs, &Loc);
    }
    return LastError;
}

DWORD
DhcpServerFillSubnet(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hSubnet,
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_SUBNET              Subnet
)
{
    DWORD                          Result, LastError;
    ARRAY                          RangeAttribs;
    ARRAY                          ReservationAttribs;
    ARRAY                          AddressAttribs;
    ARRAY                          SuperScopeAttribs;
    ARRAY                          OptDefAttribs;
    ARRAY                          AlternateOptAttribs;
    ARRAY                          OptAttribs;
    ARRAY                          ClassAttribs;

    MemArrayInit(&RangeAttribs);
    MemArrayInit(&ReservationAttribs);
    MemArrayInit(&SuperScopeAttribs);
    MemArrayInit(&AlternateOptAttribs);
    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0x7FFFFFFF,    // max out recursion
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ &RangeAttribs,
        /* Sites                */ NULL,
        /* Reservations         */ &ReservationAttribs,
        /* SuperScopes          */ &SuperScopeAttribs,
        /* OptionDescripti      */ NULL,
        /* OptionsLocation      */ &AlternateOptAttribs,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // Ignore Result
    Result = CheckoutAlternateOptions(
        hContainer,
        &AlternateOptAttribs,
        NULL,
        &OptAttribs
    );
    // Ignore Result

    ArrayMemFree(&AlternateOptAttribs);
    LastError = ERROR_SUCCESS;
    Result = DhcpSubnetAddOptions(
        Server,
        Subnet,
        &OptAttribs
    );
    ArrayMemFree(&OptAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    Result = DhcpSubnetAddRanges(
        Subnet,
        &RangeAttribs
    );
    ArrayMemFree(&RangeAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    if( DONT_USE_PARENT ) {                       // we are not peeking at SubnetAttrib, so do this..
        Result = DhcpSubnetAddSuperScopes(
            Server,
            Subnet,
        &SuperScopeAttribs
        );
        ArrayMemFree(&SuperScopeAttribs);
        if( ERROR_SUCCESS != Result ) LastError = Result;
    } else {
        ArrayMemFree(&SuperScopeAttribs);
    }

    Result = DhcpSubnetAddReservations(
        hContainer,
        hDhcpRoot,
        hSubnet,
        Server,
        Subnet,
        &ReservationAttribs
    );
    ArrayMemFree(&ReservationAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    return LastError;
}

DWORD
DhcpServerGetSubnet(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hSubnet,
    IN OUT  PM_SERVER              Server,
    IN      PEATTRIB               SubnetAttrib,
    IN      PM_SUBNET             *Subnet
)
{
    DWORD                          Result;
    DWORD                          FoundParams;
    DWORD                          Type;
    DWORD                          Address, Mask, State, Policy, SScopeId;
    LPWSTR                         Name, Comment;
    LARGE_INTEGER                  Flags;
    ARRAY                          AddressAttribs, MaskAttribs;
    PM_SSCOPE                      SScope;

    if( DONT_USE_PARENT ) {                       // get state frm server obj or root obj?
        FoundParams = 0; Type = 0; Name = NULL; Comment = NULL;
        Result = DhcpDsGetAttribs(
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* hStore           */ hSubnet,
            /* FoundParams      */ &FoundParams,
            /* UniqueKey        */ NULL,
            /* Type             */ &Type,
            /* Flags            */ &Flags,
            /* Name             */ &Name,
            /* Description      */ &Comment,
            /* Location         */ NULL,
            /* MScopeId         */ NULL
        );
        if( ERROR_SUCCESS != Result ) return Result;

        if( !DhcpCheckParams(FoundParams, 3) ) {
            State = Policy = 0;
        } else {
            State = Flags.LowPart; Policy = Flags.HighPart;
        }
    } else {
        if( IS_FLAGS1_PRESENT(SubnetAttrib) ) {
            State = SubnetAttrib->Flags1;
        } else State = 0;
        if( IS_FLAGS2_PRESENT(SubnetAttrib) ) {
            Policy = SubnetAttrib->Flags2;
        } else Policy = 0;
        Name = SubnetAttrib->String1;
        if( IS_STRING2_PRESENT(SubnetAttrib) ) {
            Comment = SubnetAttrib->String2;
        } else Comment = NULL;
    }

    if( DONT_USE_PARENT ) {                       // get info from subnet obj, not server
        MemArrayInit(&AddressAttribs); MemArrayInit(&MaskAttribs);
        Result = DhcpDsGetLists(
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* hStore           */ hSubnet,
            /* RecursionDepth   */ 0x7FFFFFFF,    // max out recursion
            /* Servers          */ NULL,
            /* Subnets          */ NULL,
            /* IpAddress        */ &AddressAttribs,
            /* Mask             */ &MaskAttribs,
            /* Ranges           */ NULL,
            /* Sites            */ NULL,
            /* Reservations     */ NULL,
            /* SuperScopes      */ NULL,
            /* OptionDescripti  */ NULL,
            /* OptionsLocation  */ NULL,
            /* Options          */ NULL,
            /* Classes          */ NULL
        );

        Address = FirstAddress(&AddressAttribs);
        Mask = FirstAddress(&MaskAttribs);
        ArrayMemFree(&AddressAttribs);
        ArrayMemFree(&MaskAttribs);
    } else {                                      // get info frm the subnet attrib
        Address = SubnetAttrib->Address1;
        Mask = SubnetAttrib->Address2;
    }

    SScope = NULL;
    if( !DONT_USE_PARENT ) do {                   // if we can peek into SubnetAttrib
        if( !IS_STRING3_PRESENT(SubnetAttrib) ) { // does this have a superscope name?
            SScopeId = 0;                         // nope, so SScopeId is zero
            break;                                // also, quit from here..
        }
        Result = MemServerFindSScope(             // first see if the superscope already exists
            Server,
            0xFFFFFFFF,
            SubnetAttrib->String3,
            &SScope
        );
        if( ERROR_SUCCESS== Result ) {            // got it.
            SScopeId = SScope->SScopeId;
            break;                                // superscope set.. dont need to worry
        }
        if( ERROR_FILE_NOT_FOUND != Result ) {    // something seriously wrong?
            return Result;                        // cant go on
        }

        //= NULL == SScope
        Result = MemSScopeInit(                   // try to create a new super scope
            &SScope,
            0,
            SubnetAttrib->String3
        );
        if( ERROR_SUCCESS != Result ) {           // hmm.. should not go wrong at all?
            return Result;
        }

        Result = MemServerAddSScope(              // now add it to the server
            Server,
            SScope
        );
        if( ERROR_SUCCESS != Result ) {           // oh boy, not again
            MemSScopeCleanup(SScope);
            return Result;
        }

        SScopeId = SScope->SScopeId;              // finally got the superscope
    } while(0);                                   // not really a loop.. just a programming trick

    Result = MemSubnetInit(
        /* pSubnet              */ Subnet,
        /* Address              */ Address,
        /* Mask                 */ Mask,
        /* State                */ State,
        /* SuperScopeId         */ DONT_USE_PARENT ? 0 : SScopeId,
        /* Name                 */ Name,
        /* Description          */ Comment
    );

    if( DONT_USE_PARENT ) {                       // need to free Name and Comment
        if( Name ) MemFree(Name);
        if( Comment ) MemFree(Comment);
    }

    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpServerFillSubnet(
        hContainer,
        hDhcpRoot,
        hSubnet,
        Server,
        *Subnet
    );

    if( ERROR_SUCCESS != Result ) {
        MemSubnetFree(*Subnet);
        *Subnet = NULL;
    }

    return Result;
}

DWORD
DhcpServerAddSubnet(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hServer,
    IN OUT  PM_SERVER              Server,
    IN      PEATTRIB               SubnetAttrib
)
{
    DWORD                          Result;
    STORE_HANDLE                   hStore;
    PM_SUBNET                      NewSubnet;

    if( !IS_STRING1_PRESENT(SubnetAttrib) ||      // no subnet name
        !IS_ADDRESS1_PRESENT(SubnetAttrib) ||     // no subnet address
        !IS_ADDRESS2_PRESENT(SubnetAttrib) ) {    // no subnet mask
        return ERROR_SUCCESS;                     //= ds inconsistent
    }

    if( !IS_STOREGETTYPE_PRESENT(SubnetAttrib) ) {
        return ERROR_SUCCESS;                     // this is just a dummy here for no reason at all
    }

    Result = StoreGetHandle(
        /* hStore               */ hContainer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ SubnetAttrib->StoreGetType,
        /* Path                 */ SubnetAttrib->ADsPath,
        /* hStoreOut            */ &hStore
    );
    if( ERROR_DS_NO_SUCH_OBJECT == Result ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Result ) return Result;

    NewSubnet = NULL;
    Result = DhcpServerGetSubnet(
        hContainer,
        hDhcpRoot,
        &hStore,
        Server,
        SubnetAttrib,
        &NewSubnet
    );
    StoreCleanupHandle(&hStore, DDS_RESERVED_DWORD);

    if( ERROR_SUCCESS != Result ) return Result;
    Result = MemServerAddSubnet(Server, NewSubnet);
    if( ERROR_SUCCESS != Result ) MemSubnetFree(NewSubnet);
    return Result;
}

DWORD
DhcpServerAddSubnets(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hServer,
    IN OUT  PM_SERVER              Server,
    IN      PARRAY                 SubnetAttribs
)
{
    DWORD                          Result, LastError;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;

    LastError = ERROR_SUCCESS;
    Result = MemArrayInitLoc(SubnetAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(SubnetAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result
        Result = DhcpServerAddSubnet(
            hContainer,
            hDhcpRoot,
            hServer,
            Server,
            ThisAttrib
        );
        if( ERROR_SUCCESS != Result ) LastError = Result;
        Result = MemArrayNextLoc(SubnetAttribs, &Loc);
    }
    return LastError;
}

DWORD
DhcpFillServer(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hServer,
    IN OUT  PM_SERVER              Server
)
{
    DWORD                          Result, LastError;
    DWORD                          Address;
    ARRAY                          SubnetAttribs;
    ARRAY                          AddressAttribs;
    ARRAY                          SuperScopeAttribs;
    ARRAY                          OptDefAttribs;
    ARRAY                          AlternateOptAttribs;
    ARRAY                          OptAttribs;
    ARRAY                          ClassAttribs;

    MemArrayInit(&SubnetAttribs);
    MemArrayInit(&AddressAttribs);
    MemArrayInit(&SuperScopeAttribs);
    MemArrayInit(&OptDefAttribs);
    MemArrayInit(&AlternateOptAttribs);
    MemArrayInit(&OptAttribs);
    MemArrayInit(&ClassAttribs);
    Result = DhcpDsGetLists(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0x7FFFFFFF,    // max out recursion
        /* Servers              */ NULL,
        /* Subnets              */ &SubnetAttribs,
        /* IpAddress            */ &AddressAttribs,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL, // &SuperScopeAttribs,
        /* OptionDescripti      */ &OptDefAttribs,
        /* OptionsLocation      */ &AlternateOptAttribs,
        /* Options              */ &OptAttribs,
        /* Classes              */ &ClassAttribs
    );
    // Ignore Result
    Result = CheckoutAlternateOptions(
        hContainer,
        &AlternateOptAttribs,
        &OptDefAttribs,
        &OptAttribs
    );
    // Ignore Result

    ArrayMemFree(&AlternateOptAttribs);
    LastError = ERROR_SUCCESS;
    Result = DhcpServerAddClasses(
        Server,
        &ClassAttribs
    );
    ArrayMemFree(&ClassAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    Result = DhcpServerAddOptionDefs(
        Server,
        &OptDefAttribs
    );
    ArrayMemFree(&OptDefAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    Result = DhcpServerAddOptions(
        Server,
        &OptAttribs
    );
    ArrayMemFree(&OptAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    Result = DhcpServerAddSubnets(
        hContainer,
        hDhcpRoot,
        hServer,
        Server,
        &SubnetAttribs
    );
    ArrayMemFree(&SubnetAttribs);
    if( ERROR_SUCCESS != Result ) LastError = Result;

    ArrayMemFree(&SuperScopeAttribs);

    Server->Address = FirstAddress(&AddressAttribs);
    ArrayMemFree(&AddressAttribs);

    return LastError;
}

DWORD
DhcpGetServer(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  LPSTORE_HANDLE         hServer,
    IN      PEATTRIB               ServerAttrib,
    OUT     PM_SERVER             *Server
)
{
    DWORD                          Result;
    DWORD                          FoundParams;
    DWORD                          Type;
    DWORD                          State, Policy;
    LPWSTR                         Name, Comment;
    LARGE_INTEGER                  Flags;

    if( DONT_USE_PARENT ) {                       // get state frm server obj or root obj?
        FoundParams = 0; Type = 0; Name = NULL; Comment = NULL;
        Result = DhcpDsGetAttribs(
            /* Reserved        */ DDS_RESERVED_DWORD,
            /* hStore          */ hServer,
            /* FoundParams     */ &FoundParams,
            /* UniqueKey       */ NULL,
            /* Type            */ &Type,
            /* Flags           */ &Flags,
            /* Name            */ &Name,
            /* Description     */ &Comment,
            /* Location        */ NULL,
            /* MScopeId        */ NULL
        );
        if( ERROR_SUCCESS != Result ) return Result;

        if( !DhcpCheckParams(FoundParams, 3) ) {
            State = Policy = 0;
        } else {
            State = Flags.LowPart; Policy = Flags.HighPart;
        }
    } else {
        if( IS_FLAGS1_PRESENT(ServerAttrib) ) {
            State = ServerAttrib->Flags1;
        } else State = 0;
        if( IS_FLAGS2_PRESENT(ServerAttrib) ) {
            Policy = ServerAttrib->Flags2;
        } else Policy = 0;
        Name = ServerAttrib->String1;
        if( IS_STRING2_PRESENT(ServerAttrib) ) {
            Comment = ServerAttrib->String2;
        } else Comment = NULL;
    }

    Result = MemServerInit(
        /* Server               */ Server,
        /* Address              */ 0,             // Address gets filled in DhcpFillServer
        /* State                */ State,
        /* Policy               */ Policy,
        /* Name                 */ Name,
        /* Comment              */ Comment
    );

    if( DONT_USE_PARENT ) {                       // Name and Comment were allocated..
        if( Name ) MemFree(Name);
        if( Comment ) MemFree(Comment);
    }

    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpFillServer(
        hContainer,
        hDhcpRoot,
        hServer,
        *Server
    );
    if( ERROR_SUCCESS != Result ) {
        MemServerFree(*Server);
        *Server = NULL;
    }

    return Result;
}

BOOL        _inline
AddressFoundInHostent(
    IN      DHCP_IP_ADDRESS        AddrToSearch,  // Host-Order addr
    IN      HOSTENT               *ServerEntry    // entry to search for..
)
{
    ULONG                          nAddresses, ThisAddress;

    if( NULL == ServerEntry ) return FALSE;       // no address to search in

    nAddresses = 0;                               // have a host entry to compare for addresses
    while( ServerEntry->h_addr_list[nAddresses] ) {
        ThisAddress = ntohl(*(DHCP_IP_ADDRESS*)ServerEntry->h_addr_list[nAddresses++] );
        if( ThisAddress == AddrToSearch ) {
            return TRUE;                          // yeah address matched.
        }
    }

    return FALSE;
}


DWORD       static
DhcpAddServer(
    IN OUT  LPSTORE_HANDLE         hContainer,
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,
    IN OUT  PARRAY                 Servers,
    IN      PEATTRIB               ServerAttrib,
    IN      HOSTENT               *ServerEntry
)
{
    DWORD                          Result, ServerAddress, State, Policy;
    STORE_HANDLE                   hStore;
    PM_SERVER                      NewServer;
    ARRAY_LOCATION                 Loc;

    if( !IS_STOREGETTYPE_PRESENT(ServerAttrib) )
        return ERROR_SUCCESS;                     // empty server... just there for other reasons

    if( !IS_ADDRESS1_PRESENT(ServerAttrib) ) {
        return ERROR_SUCCESS;                     // invalid attribute?
    }

    for( Result = MemArrayInitLoc(Servers, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search if we've added this before!
         Result = MemArrayNextLoc(Servers, &Loc)
    ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(Servers, &Loc, (LPVOID*)&NewServer);
        //- ERROR_SUCCESS == Result

        if( 0 == wcscmp(NewServer->Name, ServerAttrib->String1) ) {
            return ERROR_SUCCESS;                 // server already added
        }

        if( AddressFoundInHostent(NewServer->Address, ServerEntry) ) {
            return ERROR_SUCCESS;                 // server already added
        }

        //
        //  A better check would be to see if the server object was loaded before..
        //  by looking at the location... welll.. This should be done soon.
        // 
    }

    ServerAddress = ServerAttrib->Address1;
    if( !IS_FLAGS1_PRESENT(ServerAttrib)) State = 0;
    else State = ServerAttrib->Flags1;

    if( !IS_FLAGS2_PRESENT(ServerAttrib)) Policy = 0;
    else State = ServerAttrib->Flags2;

    Result = StoreGetHandle(
        /* hStore               */ hContainer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ ServerAttrib->StoreGetType,
        /* Path                 */ ServerAttrib->ADsPath,
        /* hStoreOut            */ &hStore
    );
    if( ERROR_DS_NO_SUCH_OBJECT == Result ) return ERROR_DDS_DHCP_SERVER_NOT_FOUND;
    if( ERROR_SUCCESS != Result ) return Result;

    NewServer = NULL;
    Result = DhcpGetServer(
        hContainer,
        hDhcpRoot,
        &hStore,
        ServerAttrib,
        &NewServer
    );
    StoreCleanupHandle(&hStore, DDS_RESERVED_DWORD);

    if( ERROR_SUCCESS != Result ) return Result;

    NewServer->Address = ServerAddress;
    NewServer->State = State;
    NewServer->Policy = Policy;

    Result = MemArrayAddElement(Servers, NewServer);

    if( ERROR_SUCCESS != Result ) MemServerFree(NewServer);
    return Result;
}

BOOL        _inline
FoundServer(                                      // does this attrib belong to given server?
    IN      PEATTRIB               ServerAttrib,
    IN      LPWSTR                 ServerName,
    IN      HOSTENT               *ServerEntry
)
{
    ULONG                          nAddresses;
    DHCP_IP_ADDRESS                ThisAddress;

    if( NULL == ServerName ) return TRUE;

    do {                                          // not a loop
        if( !IS_STRING1_PRESENT(ServerAttrib) )
            break ;                               // could not even find any name!
        if( NULL != ServerAttrib->String1 && 0 == wcscmp(ServerName, ServerAttrib->String1) )
            return TRUE;                          // ok, the names match
    } while(0);

    if( IS_ADDRESS1_PRESENT(ServerAttrib) ) {     // this MUST be TRUEEEE
        if( AddressFoundInHostent(ServerAttrib->Address1, ServerEntry) ) {
            return TRUE;                          // yes, there was a match
        }
    }

    return FALSE;                                 // nope, this server is not what we're lookin for
}

//BeginExport(function)
DWORD
DhcpDsGetServers(
    IN OUT  LPSTORE_HANDLE         hContainer,    // the container handle
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,    // OPTIONAL, NULL ==> All servers
    IN OUT  PARRAY                 Servers        // fill in this array with PM_SERVER types
) //EndExport(function)
{
    ARRAY                          ServerAttribs;
    ARRAY_LOCATION                 Loc;
    DWORD                          Result;
    DWORD                          LastError;
    PEATTRIB                       ThisAttrib;
    BOOL                           GotOneServerAtleast;
    HOSTENT                       *ServerEntry;

    if( NULL == hContainer || NULL == hContainer->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot || NULL == hDhcpRoot->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Reserved || NULL == Servers )
        return ERROR_INVALID_PARAMETER;

    MemArrayInit(&ServerAttribs);
    Result = DhcpDsGetLists(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* RecursionDepth       */ 0x7FFFFFFF,    // max out recursion
        /* Servers              */ &ServerAttribs,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti      */ NULL,          // need to do global options, classes etc
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( 0 == MemArraySize(&ServerAttribs) ) {
        if( ERROR_SUCCESS != Result ) return Result;
        return ERROR_DDS_DHCP_SERVER_NOT_FOUND;
    }

    GotOneServerAtleast = FALSE;
    LastError = ERROR_DDS_DHCP_SERVER_NOT_FOUND;
    if( NULL == ServerName ) {
        ServerEntry = NULL;
    } else {
        CHAR TmpBuf[300];
        wcstombs(TmpBuf, ServerName, sizeof(TmpBuf)-1);
        TmpBuf[sizeof(TmpBuf)-1] = '\0';
        ServerEntry = gethostbyname(TmpBuf);
    }

    Result = MemArrayInitLoc(&ServerAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- (ERROR_SUCCESS == Result )
        Result = MemArrayGetElement(&ServerAttribs, &Loc, (LPVOID*)&ThisAttrib);
        if( ERROR_SUCCESS != Result ) {
            //- FALSE
            break;
        }

        if( FoundServer(ThisAttrib, ServerName, ServerEntry) ) {
            Result = DhcpAddServer(hContainer, hDhcpRoot, Servers, ThisAttrib, ServerEntry);
            if( ERROR_SUCCESS != Result ) LastError = Result;
            else GotOneServerAtleast = TRUE;
        }

        MemFree(ThisAttrib);
        Result = MemArrayNextLoc(&ServerAttribs, &Loc);
    }

    if( GotOneServerAtleast ) return ERROR_SUCCESS;
    return LastError;
}

//BeginExport(function)
DWORD
DhcpDsGetEnterpriseServers(                       // get the dhcp servers for the current enterprise
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,
    IN OUT  PARRAY                 Servers
) //EndExport(function)
{
    DWORD                          Result;
    STORE_HANDLE                   hRoot;
    STORE_HANDLE                   hDhcpRoot;
    STORE_HANDLE                   hContainer;

    Result = StoreInitHandle(
        /* hStore               */ &hRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ThisDomain           */ NULL,
        /* UserName             */ NULL,
        /* Password             */ NULL,
        /* AuthFlags            */ ADS_SECURE_AUTHENTICATION
    );
    if( ERROR_SUCCESS != Result ) return ERROR_DDS_NO_DS_AVAILABLE;

    Result = DhcpDsGetRoot(
        /* Flags                */ DDS_FLAGS_CREATE,
        /* hStoreCC             */ &hRoot,
        /* hStoreDhcpRoot       */ &hDhcpRoot
    );
    if( ERROR_SUCCESS != Result ) {
        StoreCleanupHandle(&hRoot, DDS_RESERVED_DWORD);
        return Result;
    }

    Result = StoreGetHandle(
        /* hStore               */ &hRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ StoreGetChildType,
        /* Path                 */ DHCP_ROOT_OBJECT_PARENT_LOC,
        /* hStoreOut            */ &hContainer
    );
    StoreCleanupHandle(&hRoot, DDS_RESERVED_DWORD);

    if( ERROR_SUCCESS != Result ) {
        StoreCleanupHandle(&hRoot, DDS_RESERVED_DWORD);
        return ERROR_DDS_UNEXPECTED_ERROR;
    }

    Result = DhcpDsGetServers(
        /* hContainer           */ &hContainer,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ ServerName,
        /* Servers              */ Servers
    );

    StoreCleanupHandle(&hContainer, DDS_RESERVED_DWORD);
    StoreCleanupHandle(&hDhcpRoot, DDS_RESERVED_DWORD);

    return Result;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dsauth.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ds.c

Abstract:

    This file contains all the routines used in interfacing with the DS.  We go
    to the DS go make sure we are not a Rogue server, and also to retrieve all
    configuration information.

Author:

    Shirish Koti (koti)    26-May-1997

Environment:

    User Mode - Win32

Revision History:


--*/


//
// System Includes
//
#define INC_OLE2


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "activeds.h"
#include "adsi.h"



#if DBG
#define DBGPRINT  printf
#else
#define DBGPRINT
#endif

#include <netlib.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <dnsapi.h>

#include "adsi.h"

#include <dsauth.h>
#include <dhcpapi.h>
#include <dhcpds.h>

DWORD
ValidateService(
    LPWSTR  lpwDomain,          // domain name
    LPWSTR  lpwUserName,        // usually NULL
    LPWSTR  lpwPassword,        // usually NULL
    DWORD   dwAuthFlags,        // ??
    LPWSTR  lpwObjectPath,      // where our things are stored (e.g. DHCP)
    LPWSTR  lpwSrchFilter,      // objects we're looking for (objectClass==DHCP)
    LPWSTR  *ppwAttrName,       // name of the attribute we're looking for
    LPWSTR  lpwAttrVal          // value of the attribute we're looking for
);


LPWSTR  lpwGlbNamingContextString = DHCPDS_NAMING_CONTEXT;



DWORD
DhcpDSGetDomainAndRoot(
    LPWSTR   * ppwDomainName,
    LPWSTR   * ppwRootName,
    BOOLEAN  * fIsStandAlone
)
/*++

Routine Description:

    This function gets the DS Domain and the root of the enterprise that this
    machine is a member of.

    NOTE: Memory is allocated to hold strings pointed to by *ppwDomainName and
          *ppwRootName, and the caller must free that memory.
          One of ppwDomainName or ppwRootName can be NULL, to indicate the caller
          doesn't want that info.  (e.g. only root is needed, not domain)

Arguments:

    ppwDomainName - pointer to a string that will hold domain name
    ppwRootName - pointer to a string that will hold the root of enterprise
    fIsStandAlone - pointer to a boolean: TRUE if this server is Standalone

Return Value:

    Result of the operation
--*/
{
    DWORD                       dwError;
    LPTSTR                      NetbiosDomNamePtr=NULL;
    LPTSTR                      pDomain=NULL;
    LPWSTR                      lpwRetDomainName=NULL;
    LPWSTR                      lpwRetRootName=NULL;
    BOOLEAN                     IsWorkgroup=TRUE;
    PDOMAIN_CONTROLLER_INFO     pDCInfo = NULL;



    // initialize, in case we bail out
    if (ppwDomainName)
    {
        *ppwDomainName = NULL;
    }

    if (ppwRootName)
    {
        *ppwRootName = NULL;
    }

    *fIsStandAlone = FALSE;


    //
    // first, find out which domain we are a member of.
    //
    dwError = NetpGetDomainNameExEx(
                    &NetbiosDomNamePtr,
                    &pDomain,
                    &IsWorkgroup);

    //
    // if NetpGetDomainNameExEx failed, we shouldn't proceed
    //
    if (dwError != NO_ERROR)
    {
        DBGPRINT("DhcpGetDSDomain: NetpGetDomainNameExEx failed (%ld)\n",dwError);
        return(dwError);
    }

    // we don't care about this domain name: free the buffer
    if (NetbiosDomNamePtr)
    {
        NetApiBufferFree(NetbiosDomNamePtr);
    }

    // if this is a standalone server, we're done here
    if (IsWorkgroup)
    {
        DBGPRINT("DhcpGetDSDomain: server is part of a workgroup\n");

        *fIsStandAlone = TRUE;

        if (pDomain)
        {
            NetApiBufferFree(pDomain);
        }

        return(NO_ERROR);
    }

    // if pDomain is NULL, it means that the DNS domain isn't configured.
    // For the purpose of rogue-detection, we will assume it to be a workgroup
    // though in the strictest sense that's not true.
    if (pDomain == NULL)
    {
        DBGPRINT("DhcpGetDSDomain: pDomain is NULL: assuming part of workgroup\n");

        *fIsStandAlone = TRUE;

        return(NO_ERROR);
    }


    //
    // if the caller wants DomainName, allocate space, and copy it in
    //
    if (ppwDomainName)
    {
        lpwRetDomainName = (LPWSTR)LocalAlloc(
                                        LPTR,
                                        (wcslen(pDomain)+1)*sizeof(WCHAR) );

        if (lpwRetDomainName == NULL)
        {
            DBGPRINT("DhcpGetDSDomain: malloc 1 failed (%ld)\n",
                (wcslen(pDomain)+1)*sizeof(WCHAR));

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto DhcpGetDSDomain_ErrExit;
        }

        // copy the name in
        wcscpy(lpwRetDomainName, pDomain);

        *ppwDomainName = lpwRetDomainName;
    }


    //
    // See if the caller wants DS Root as well
    // get the info about this domain controller (the only thing we want
    // from all the good info in pDCInfo is the DS root name (DnsForestName field)
    //

    if (ppwRootName)
    {
        dwError = DsGetDcName(
                        NULL,               // server name
                        pDomain,            // domain name
                        NULL,               // domain guid
                        NULL,               // site name
                        DS_IS_DNS_NAME,
                        &pDCInfo);

        if (dwError != NO_ERROR)
        {
            DBGPRINT("DhcpGetDSDomain: DsGetDcName failed %ld\n",dwError);

            goto DhcpGetDSDomain_ErrExit;
        }


        //
        // RootName: allocate space, and copy the root name in
        //

        lpwRetRootName = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    (wcslen(pDCInfo->DnsForestName)+1)*sizeof(WCHAR) );

        if (lpwRetRootName == NULL)
        {
            DBGPRINT("DhcpGetDSDomain: malloc 2 failed (%ld)\n",
                (wcslen(pDCInfo->DnsForestName)+1)*sizeof(WCHAR));

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto DhcpGetDSDomain_ErrExit;
        }

        // copy the name in
        wcscpy(lpwRetRootName, pDCInfo->DnsForestName);

        *ppwRootName = lpwRetRootName;

        NetApiBufferFree(pDCInfo);
    }

    NetApiBufferFree(pDomain);

    return(NO_ERROR);


DhcpGetDSDomain_ErrExit:

    DBGPRINT("DhcpGetDSDomain: executing error path, dwError = %ld\n",dwError);

    //
    // free the things that were given to us (or we took!)
    //
    if (pDomain)
    {
        NetApiBufferFree(pDomain);
    }

    if (pDCInfo)
    {
        NetApiBufferFree(pDCInfo);
    }

    if (lpwRetDomainName)
    {
        LocalFree(lpwRetDomainName);
    }

    if (lpwRetRootName)
    {
        LocalFree(lpwRetRootName);
    }

    if (ppwDomainName)
    {
        *ppwDomainName = NULL;
    }

    if (ppwRootName)
    {
        *ppwRootName = NULL;
    }

    return(dwError);
}

//BeginExport(function)
//DOC DhcpDSValidateServer validates the server in the DS by looking for the server
//DOC object and checking to see if the given IpAddress is present in the DS.
//DOC This calls the other helper routine in DhcpDs.dll to do the real work.
//DOC Returns one of
//DOC DHCPDSERR_DS_OPERATION_FAILED
//DOC DHCPDSERR_ENTRY_NOT_FOUND
//DOC DHCPDSERR_ENTRY_FOUND
//DOC DHCPDSERR_SERVER_IS_STANDALONE
DWORD
DhcpDSValidateServer(                             // validate in DS
    IN      LPWSTR                 lpwDomain,     // OPTIONAL NULL ==> Default domain
    IN      DWORD                 *lpIpAddress,   // one of the IpAddresses that must exist in DS
    IN      ULONG                  dwIpAddressCount, // # of ip addresses supplied..
    IN      LPWSTR                 lpwUserName,   // OPTIONAL NULL ==> m/c account
    IN      LPWSTR                 lpwPassword,   // OPTIONAL password to use
    IN      DWORD                  dwAuthFlags    // MUST BE ZERO? 
)   //EndExport(function)
{
    DWORD                          Error;
    BOOL                           Found;
    BOOL                           IsStandAlone;

    IsStandAlone = FALSE;
    Found = FALSE;
    Error = DhcpDsValidateService                 // check to validate for dhcp
    (
        lpwDomain,
        lpIpAddress,
        dwIpAddressCount,
        lpwUserName,
        lpwPassword,
        dwAuthFlags,
        &Found,
        &IsStandAlone
    );

    if( ERROR_SUCCESS != Error )
        return DHCPDSERR_DS_OPERATION_FAILED;

    if( IsStandAlone ) return DHCPDSERR_SERVER_IS_STANDALONE;

    return Found? DHCPDSERR_ENTRY_FOUND : DHCPDSERR_ENTRY_NOT_FOUND;
}

DWORD
DhcpDSMapDomainToCNPath(
    LPWSTR  lpwDomain,
    LPWSTR  lpwUserName,
    LPWSTR  lpwPassword,
    DWORD   dwAuthFlags,
    LPWSTR  *ppwCNPath
)
/*++

Routine Description:

    This function retrieves the full path to the Configuration Container, given
    the name of the domain.  If the domain name is not specified, server's domain
    name is assumed.

    NOTE: memory is allocated for ppwCNPath on successful return.  Caller must
          free this memory.

Arguments:

    lpwDomain - domain name in which to validate the service.  Can be NULL to
                indicate the server's domain
    lpwUserName - account name to use during DS lookup.  Usually, NULL (default)
    lpwPassword - password for the above user
    dwAuthFlags - flags to use
    ppwCNPath - pointer to string containing the path, on return.

Return Value:

    Result of the operation
--*/
{
    HRESULT                     hr=S_OK;
    LPWSTR                      pCanonName;
    LPWSTR                      lpwLocalDomain=NULL;
    LPWSTR                      lpwDomainToContact=NULL;
    LPWSTR                      lpwDCName;
    HANDLE                      handle = NULL;
    PDOMAIN_CONTROLLER_INFO     pDCInfo = NULL;
    DWORD                       dwCanonNameLen;
    PADS_ATTR_INFO              pAttributeEntries=NULL;
    DWORD                       dwNumAttributesReturned=0;
    BOOLEAN                     fIsStandAlone;
    BOOLEAN                     fCNStringFound;
    DWORD                       dwRetCode;
    DWORD                       index;


    *ppwCNPath = NULL;

    lpwDomainToContact = lpwDomain;

    //
    // if domain name is not supplied, find local domain first
    //
    if (!lpwDomain)
    {
        dwRetCode = DhcpDSGetDomainAndRoot(
                        &lpwLocalDomain,
                        NULL,
                        &fIsStandAlone);

        if (dwRetCode != NO_ERROR)
        {
            DBGPRINT("DhcpDSMap..CNPath: GetLocalDom.. failed (0x%x)\n",dwRetCode);
            return(dwRetCode);
        }

        //
        // are we a standalone server?  if so, return error since there is no
        // local domain (and the caller didn't specify a domain)
        //
        if (fIsStandAlone)
        {
            DBGPRINT("DhcpDSMap..CNPath: standalone has no domain!\n");
            return(DHCPDSERR_SERVER_IS_STANDALONE);
        }

        lpwDomainToContact = lpwLocalDomain;
    }

    //
    // first, find a DC for this domain
    //
    dwRetCode = DsGetDcName(
                   NULL,               // server name
                   lpwDomainToContact, // domain name
                   NULL,               // domain guid
                   NULL,               // site name
                   DS_IS_DNS_NAME,     // what flag(s) to use?
                   &pDCInfo);

    // if we first obtained local domain, free it here
    if (lpwLocalDomain != NULL)
    {
        LocalFree((PCHAR)lpwLocalDomain);
    }

    if (dwRetCode != NO_ERROR)
    {
        DBGPRINT("MapDomainToCNPath: DsGetDcName failed %ld\n",dwRetCode);

        return(dwRetCode);
    }


    lpwDCName = pDCInfo->DomainControllerName;

    // skip the two leading '\'
    lpwDCName += 2;

    // also, skip the trailing '.'
    lpwDCName[wcslen(lpwDCName)-1] = 0;

    dwCanonNameLen = sizeof(DHCPDS_ROOTDSE_PRE) +
                     (wcslen(lpwDCName)+1)*sizeof(WCHAR) +
                     sizeof(DHCPDS_ROOTDSE_POST) +
                     sizeof(WCHAR);

    pCanonName = (LPWSTR)LocalAlloc(LPTR, dwCanonNameLen);

    if (pCanonName == NULL)
    {
        DBGPRINT("DhcpDSMapDomainToCNPath: malloc 1 failed (%ld)\n",dwCanonNameLen);

        NetApiBufferFree(pDCInfo);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // copy the LDAP:// string
    wcscpy(pCanonName, DHCPDS_ROOTDSE_PRE);


    // append the server name
    wcscat(pCanonName, lpwDCName);

    // then append the RootDSE part
    wcscat(pCanonName, DHCPDS_ROOTDSE_POST);

    // don't need this nomore: free it now
    NetApiBufferFree(pDCInfo);

    // now, open the RootDSE "object"
    hr = ADSIOpenDSObject(
                pCanonName,
                lpwUserName,
                lpwPassword,
                dwAuthFlags,
                &handle
                );

    // free this first: don't need this nomore
    LocalFree((PCHAR)pCanonName);

    if (FAILED(hr))
    {
        DBGPRINT("ADSIOpenDSObject (RootDSE) failed with 0x%x\n",hr);
        return(DHCPDSERR_DS_OPERATION_FAILED);
    }


    // now, get all the attributes on this object
    hr = ADSIGetObjectAttributes(
                handle,
                &lpwGlbNamingContextString,
                1,
                &pAttributeEntries,
                &dwNumAttributesReturned);

    if (FAILED(hr))
    {
        DBGPRINT("ADSIGetObjectAttributes (RootDSE) failed with 0x%x\n",hr);

        dwRetCode = DHCPDSERR_DS_OPERATION_FAILED;
        goto DhcpDSMapDomainToCNPath_Exit;
    }


    fCNStringFound = FALSE;

    //
    // now, of all the values returned, find the one that we are
    // interested in (the one starts with CN=Configuration,)
    //
    for (index=0; index<pAttributeEntries->dwNumValues; index++)
    {
        if (pAttributeEntries->pADsValues[index].dwType != ADSTYPE_CASE_IGNORE_STRING)
        {
            continue;
        }

        if (wcsncmp(pAttributeEntries->pADsValues[index].CaseIgnoreString,
                    DHCPDS_CN_STRING,
                    wcslen(DHCPDS_CN_STRING)) == 0)
        {
            fCNStringFound = TRUE;
            break;
        }
    }

    if (!fCNStringFound)
    {
        DBGPRINT("MapDomainToCNPath: %d values returned, but not ours\n",
            pAttributeEntries->dwNumValues);

        dwRetCode = DHCPDSERR_DS_OPERATION_FAILED;
        goto DhcpDSMapDomainToCNPath_Exit;
    }

    dwCanonNameLen = (wcslen(pAttributeEntries->pADsValues[index].CaseIgnoreString) +
                      1) * sizeof(WCHAR);

    (*ppwCNPath) = (LPWSTR)LocalAlloc(LPTR, dwCanonNameLen);

    if ((*ppwCNPath) == NULL)
    {
        DBGPRINT("MapDomainToCNPath: malloc 2 failed (%ld)\n",dwCanonNameLen);

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto DhcpDSMapDomainToCNPath_Exit;
    }

    // now, copy the-path-to-Configuration string
    wcscpy((*ppwCNPath),pAttributeEntries->pADsValues[index].CaseIgnoreString);

    dwRetCode = 0;

DhcpDSMapDomainToCNPath_Exit:

    // free pAttributeEntries
    if (pAttributeEntries)
    {
        FreeADsMem(pAttributeEntries);
    }

    ADSICloseDSObject( handle );

    return(dwRetCode);
}




DWORD
ValidateService(
    LPWSTR  lpwDomain,
    LPWSTR  lpwUserName,
    LPWSTR  lpwPassword,
    DWORD   dwAuthFlags,
    LPWSTR  lpwObjectPath,
    LPWSTR  lpwSrchFilter,
    LPWSTR  *ppwAttrName,
    LPWSTR  lpwAttrVal
)
/*++

Routine Description:

    This function determines if the given attribute (ipaddress in case of
    DHCP) is present in the list of authorized entities (DHCP Servers) on the DS
    enterprise.

Arguments:

    lpwDomain - domain name in which to validate the service.  Can be NULL to
                indicate the server's domain
    lpwUserName - account name to use during DS lookup.  Usually, NULL (default)
    lpwPassword - password for the above user
    dwAuthFlags - flags to use
    lpwObjectPath - path to where the "entities" are stored
    lpwSrchFilter - the filter to use to get our "entities" (e.g.(objectClass==DHCPClass)
    ppwAttrName - name of the attribute we're looking for (e.g. IpAddress)
    lpwAttrVal - value of the attribute (e.g. the server's ipaddress to validate)

Return Value:

    Result of the operation
--*/
{

    HRESULT             hr=S_OK;
    HANDLE              handle = NULL;
    ADS_SEARCH_HANDLE   hSearchHandle=NULL;
    ADS_SEARCH_COLUMN   Column;
    DWORD               dwRetCode;
    DWORD               i;
    LPWSTR              lpwCNPath=NULL;
    LPWSTR              lpwFullDSPath=NULL;
    DWORD               dwLen;
    BOOLEAN             fObjectFound=FALSE;



    dwRetCode = DHCPDSERR_ENTRY_NOT_FOUND;

    //
    // first, we need to get the full ads path to our container within the
    // configuration container, from the domain name
    //
    dwRetCode = DhcpDSMapDomainToCNPath(
                    lpwDomain,
                    lpwUserName,
                    lpwPassword,
                    dwAuthFlags,
                    &lpwCNPath);

    if (dwRetCode != 0)
    {
        DBGPRINT("ValidateService: MapDomainToCNPath failed with 0x%x\n",dwRetCode);
        goto ValidateService_Exit;
    }

    dwLen = (wcslen(lpwObjectPath)+1)*sizeof(WCHAR) +
            (wcslen(lpwCNPath)+1)*sizeof(WCHAR);

    lpwFullDSPath = (LPWSTR)LocalAlloc(LPTR, dwLen);

    if (lpwFullDSPath == NULL)
    {
        DBGPRINT("ValidateService: malloc failed (%ld)\n",dwLen);

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto ValidateService_Exit;
    }

    // copy the lpwObjectPath (e.g. LDAP://CN=DHCP) string
    wcscpy(lpwFullDSPath, lpwObjectPath);

    // now, concatenate the path to the configuration container
    wcscat(lpwFullDSPath, lpwCNPath);

    hr = ADSIOpenDSObject(
                lpwFullDSPath,
                lpwUserName,
                lpwPassword,
                dwAuthFlags,
                &handle
                );


    if (FAILED(hr))
    {
        DBGPRINT("ValidateService: ADSIOpenDSObject failed with 0x%x\n",hr);
        dwRetCode = DHCPDSERR_DS_OPERATION_FAILED;
        goto ValidateService_Exit;
    }


    hr = ADSIExecuteSearch(
             handle,
             lpwSrchFilter,
             ppwAttrName,
             -1,                // ok to always pass this?
             &hSearchHandle
              );

    if (FAILED(hr))
    {
        DBGPRINT("ADSIExecuteSearch failed with 0x%x\n",hr);
        dwRetCode = DHCPDSERR_DS_OPERATION_FAILED;
        goto ValidateService_Exit;
    }


    hr = ADSIGetNextRow(
             handle,
             hSearchHandle
             );

    if (FAILED(hr))
    {
        DBGPRINT("ADSIGetNextRow failed with 0x%x\n",hr);
        dwRetCode = DHCPDSERR_DS_OPERATION_FAILED;
        goto ValidateService_Exit;
    }

    while (hr != S_ADS_NOMORE_ROWS && !fObjectFound)
    {
        //
        // get the values for the attribute requested (e.g. ipaddress)
        //
        hr = ADSIGetColumn(
                 handle,
                 hSearchHandle,
                 ppwAttrName[0],      // for now, only first one is needed
                 &Column
                 );

        if (SUCCEEDED(hr))
        {
            //
            // if the attribute is multivalued, compare all the values to see
            // if we find the one we want
            //
            for (i=0; i < Column.dwNumValues; i++)
            {
                if (_wcsnicmp(
                        Column.pADsValues[i].CaseIgnoreString,
                        lpwAttrVal,
                        wcslen(lpwAttrVal)) == 0)
                {
                    fObjectFound = TRUE;
                    break;
                }
            }

            // free the column
            ADSIFreeColumn(
                handle,
                &Column);
        }

        //
        // it's strange if this attribute is not defined for this object since
        // it's one of our objects.  But, nevertheless, just skip it
        //
        else
        {
            DBGPRINT("ADSIGetColumn failed with hr = 0x%x\n",hr);
        }

        // move to the next object
        hr = ADSIGetNextRow(
                 handle,
                 hSearchHandle
                 );
    }


    dwRetCode = (fObjectFound)? DHCPDSERR_ENTRY_FOUND : DHCPDSERR_ENTRY_NOT_FOUND;

ValidateService_Exit:

    if (hSearchHandle)
    {
        ADSICloseSearchHandle(
            handle,
            hSearchHandle);
    }

    if (handle)
    {
        ADSICloseDSObject( handle );
    }

    if (lpwCNPath)
    {
        LocalFree((PCHAR)lpwCNPath);
    }

    if (lpwFullDSPath)
    {
        LocalFree((PCHAR)lpwFullDSPath);
    }

    return(dwRetCode) ;
}


DWORD
DhcpDSSameEnterprise(
    LPWSTR   lpwDomainName,
    LPWSTR   lpwRootName,
    BOOLEAN *fIsSameEnterprise
)
/*++

Routine Description:

    This function checks if the given domain is part of the given DS Tree (in other
    words, we want to find out if this domain belongs to another enterprise)

Arguments:

    lpwDomainName - name of the domain in question
    lpwRootName   - root of the DS Tree to test against
    fIsSameEnterprise - on return, TRUE or FALSE

Return Value:

    result of the operation

--*/
{

    PDOMAIN_CONTROLLER_INFO  pDCInfo = NULL;
    DWORD                    dwRetCode;


    //
    // until we can definitely verify that the root of the given domain is
    // the same as the one that is supplied, we return FALSE.
    //
    (*fIsSameEnterprise) = FALSE;

    if (!lpwRootName)
    {
        DBGPRINT("DhcpDSSameEnterprise: C'mon, don't pass me a NULL!\n");
        return(0);
    }

    dwRetCode = DsGetDcName(
                    NULL,               // server name
                    lpwDomainName,      // domain name
                    NULL,               // domain guid
                    NULL,               // site name
                    DS_IS_DNS_NAME,     // what flag(s) to use?
                    &pDCInfo);

    if (dwRetCode != NO_ERROR)
    {
        DBGPRINT("DhcpDSSameEnterprise: DsGetDcName failed (%ld)\n",dwRetCode);

        return(dwRetCode);
    }

    // moment of truth: are the two roots the same?
    (*fIsSameEnterprise) = (DnsCompareName(lpwRootName, pDCInfo->DnsForestName) != 0);

    NetApiBufferFree(pDCInfo);

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\hdrmacro.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: common headers for dhcp ds stuff.. used by both the core <store>
// and by the dhcp-ds implementation..
//================================================================================

#define INC_OLE2
#include    <mm/mm.h>
#include    <mm/array.h>
#include    <activeds.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <align.h>
#include    <lmcons.h>

#include    <netlib.h>
#include    <lmapibuf.h>
#include    <dsgetdc.h>
#include    <dnsapi.h>
#include    <adsi.h>

//================================================================================
//  defines and constants
//================================================================================
#define     DHCP_OBJECTS_LOCATION  L"CN=NetServices,CN=Services"
#define     DHCP_SEARCH_FILTER     L"(objectClass=dHCPClass)"
#define     DHCP_ADDRESS_ATTRIB    L"ipAddress"

// global attribute names
#define     ATTRIB_NAME            L"name"
#define     ATTRIB_DN_NAME         L"cn"
#define     ATTRIB_INSTANCE_TYPE   L"instanceType"

// dhcp only attribute names
#define     ATTRIB_IPADDR_OBSOLETE L"IPAddress"
#define     ATTRIB_DHCP_UNIQUE_KEY L"dhcpUniqueKey"
#define     ATTRIB_DHCP_TYPE       L"dhcpType"
#define     ATTRIB_DHCP_IDENTIFICATION L"dhcpIdentification"
#define     ATTRIB_DHCP_FLAGS      L"dhcpFlags"
#define     ATTRIB_OBJECT_CLASS    L"objectClass"
#define     ATTRIB_OBJECT_CATEGORY L"objectCategory"
#define     ATTRIB_DHCP_SERVERS    L"dhcpServers"
#define     ATTRIB_DHCP_OPTIONS    L"dhcpOptions"

// default attribute values
#define     DEFAULT_DHCP_CLASS_ATTRIB_VALUE       L"dHCPClass"
#define     DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE    4

//================================================================================
//  defines and constants
//================================================================================
#define     DEFAULT_LDAP_ROOTDSE   L"LDAP://ROOTDSE"
#define     LDAP_PREFIX            L"LDAP://"
#define     ROOTDSE_POSTFIX        L"/ROOTDSE"
#define     ENT_ROOT_PREFIX        L"CN=Configuration"
#define     CONNECTOR              L","
#define     LDAP_JOIN              L"="
#define     ENT_ROOT_PREFIX_LEN    16

// other stuff
#define     Investigate            Require
#define     ALIGN(X)               ((X) = ROUND_UP_COUNT((X), ALIGN_WORST))

#if 0
#define     DhcpDsDbgPrint         printf
#define     StoreTrace2            printf
#define     StoreTrace3            printf
#else
#define     DhcpDsDbgPrint         (void)
#define     StoreTrace2            (void)
#define     StoreTrace3            (void)
#endif

static      const
LPWSTR      constNamingContextString = L"configurationNamingContext";
static      const                                 // cn is NOT mandatory..what is?
LPWSTR      constCNAttrib = L"cn";                // the attribute that is unique,mandator for each object..

//================================================================================
//  interal helpers
//================================================================================
LPWSTR      _inline
DuplicateString(                                  // allocate and copy this LPWSTR value
    IN      LPWSTR                 StringIn,
    IN      BOOL                   EmptyString    // convert empty string to L"" ?
)
{
    LPWSTR                         StringOut;

    if( NULL == StringIn ) {
        if( FALSE  == EmptyString ) return NULL;
        StringIn = L"";
    }

    StringOut = MemAlloc(sizeof(WCHAR)*(1 + wcslen(StringIn)));
    if( NULL == StringOut) return NULL;
    wcscpy(StringOut, StringIn);
    return StringOut;
}

DWORD       _inline
SizeString(                                       // # of bytes to copy the string
    IN      LPWSTR                 StringIn,      // OPTIONAL
    IN      BOOL                   EmptyString    // Convert NULL to L"" ?
)
{
    if( NULL == StringIn ) {
        return EmptyString? sizeof(WCHAR) : 0;
    }

    return sizeof(WCHAR)*(1+wcslen(StringIn));
}

LPWSTR      _inline
MakeColumnName(
    IN      LPWSTR                 RawColumnName
)
{
    LPWSTR                         RetVal;

    RetVal = MemAlloc(SizeString(constCNAttrib,FALSE) + sizeof(LDAP_JOIN) + sizeof(WCHAR)*wcslen(RawColumnName));
    if( NULL == RetVal ) return RetVal;

    wcscpy(RetVal, constCNAttrib);
    wcscat(RetVal, LDAP_JOIN);
    wcscat(RetVal, RawColumnName);

    return RetVal;
}

LPWSTR      _inline
MakeSubnetLocation(                               // make a DN name out of servername. address
    IN      LPWSTR                 ServerName,    // name of server
    IN      DWORD                  IpAddress      // subnet address
)
{
    DWORD                          Size;
    LPWSTR                         RetVal;
    LPSTR                          AddrString;

    Size = SizeString(constCNAttrib,FALSE) + sizeof(LDAP_JOIN) + sizeof(WCHAR)*wcslen(ServerName);
    Size += sizeof(WCHAR) + sizeof(L"000.000.000.000");

    RetVal = MemAlloc(Size);
    if( NULL == RetVal ) return NULL;             // not enough memory

    wcscpy(RetVal, constCNAttrib);
    wcscat(RetVal, LDAP_JOIN);
    wcscat(RetVal, ServerName);
    wcscat(RetVal, L"!" );

    IpAddress = htonl(IpAddress);                 // convert to network order before writing...
    AddrString = inet_ntoa(*(struct in_addr *)&IpAddress);
    mbstowcs(&RetVal[wcslen(RetVal)], AddrString, 1+strlen(AddrString));

    return RetVal;
}

LPWSTR      _inline
MakeReservationLocation(                          // make a DN name out of server name. address
    IN      LPWSTR                 ServerName,    // name of server
    IN      DWORD                  IpAddress      // subnet address
)
{
    return MakeSubnetLocation(ServerName, IpAddress);
}


DWORD       _inline
ConvertHresult(                                   // try to convert HRESULT to Win32 errors
    IN      HRESULT                HResult
)
{
    if( 0 == (((ULONG)(HRESULT_FACILITY(HResult))) & ~0xF )) {
        return HRESULT_CODE(HResult);             // known result
    }

    return HResult ;                              // unknown facility
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcapi2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: most of the rpc apis are here and some miscellaneous functions too
//  all the functions here go to the DS directly.
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <st_srvr.h>
#include    <upndown.h>
#include    <dnsapi.h>


//================================================================================
// helper functions
//================================================================================

#include <rpcapi2.h>

//
// Allow Debug prints to ntsd or kd
//

//  #ifdef DBG
//  #define DsAuthPrint(_x_) DsAuthDebugPrintRoutine _x_

//  #else
//  #define DebugPrint(_x_)
//  #endif


extern LPWSTR
CloneString( IN LPWSTR String );

typedef enum {
    LDAP_OPERATOR_EQUAL_TO,
    LDAP_OPERATOR_APPROX_EQUAL_TO,
    LDAP_OPERATOR_LESS_OR_EQUAL_TO,
    LDAP_OPERATOR_GREATER_OR_EQUAL_TO,
    LDAP_OPERATOR_AND,
    LDAP_OPERATOR_OR,
    LDAP_OPERATOR_NOT,
    
    LDAP_OPERATOR_TOTAL
} LDAP_OPERATOR_ENUM;

LPWSTR LdapOperators[ LDAP_OPERATOR_TOTAL ] =
    { L"=", L"~=", L"<=", L">=", L"&", L"|", L"!" };


VOID DsAuthPrintRoutine(
    LPWSTR Format,
    ...
)
{
    WCHAR   buf[2 * 256];
    va_list arg;
    DWORD   len;

    va_start( arg, Format );
    len = wsprintf(buf, L"DSAUTH: ");
    wvsprintf( &buf[ len ], Format, arg );

    va_end( arg );

    OutputDebugString( buf );
} // DsAuthPrint()

//
// This function creates an LDAP query filter string
// with the option type, value and operator.
// 
// Syntax: 
//   primitive : <filter>=(<attribute><operator><value>)
//   complex   : (<operator><filter1><filter2>)
//

LPWSTR
MakeLdapFilter(
    IN   LPWSTR             Operand1,
    IN   LDAP_OPERATOR_ENUM Operator,
    IN   LPWSTR             Operand2,
    IN   BOOL               Primitive
)
{
    LPWSTR Result;
    DWORD  Size;
    DWORD  Len;
    
    CHAR   buffer[100];

    Result = NULL;

    AssertRet((( NULL != Operand1 ) && 
	       ( NULL != Operand2 ) &&
	       (( Operator >= 0 ) && ( Operator < LDAP_OPERATOR_TOTAL ))),
	       NULL );
    
    // calculate the amount of memory needed
    Size = 0;
    Size += ROUND_UP_COUNT( sizeof( L"(" ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( sizeof( L")" ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( Operand1 ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( Operand2 ), ALIGN_WORST );
    Size += ROUND_UP_COUNT( wcslen( LdapOperators[ Operator ] ), ALIGN_WORST );
    Size += 16; // padding

    Result = MemAlloc( Size * sizeof( WCHAR ));
    if ( NULL == Result ) {
	return NULL;
    }

    if ( Primitive ) {
	Len = wsprintf( Result, 
			L"(%ws%ws%ws)",
			Operand1, LdapOperators[ Operator ], Operand2
			);
    }
    else {
	Len = wsprintf( Result,
			L"(%ws%ws%ws)",
			LdapOperators[ Operator ], Operand1, Operand2
			);
	
    } // else

    AssertRet( Len <= Size, NULL );
    
    return Result;
} // MakeLdapFilter()

//
// Make a LDAP query filter like this:
// (&(objectCategory=dHCPClass)(|(dhcpServer="i<ip>*")(dhcpServer="*s<hostname>*")))
// 

LPWSTR
MakeFilter(
   LPWSTR LookupServerIP,   // Printable IP addr
   LPWSTR HostName
)
{
    LPWSTR Filter1, Filter2, Filter3, Filter4, SearchFilter;
    LPWSTR Buf;
    DWORD Len, CopiedLen;

    AssertRet((( NULL != LookupServerIP ) &&
	       ( NULL != HostName )), NULL );

    Filter1 = NULL;
    Filter2 = NULL;
    Filter3 = NULL;
    Filter4 = NULL;
    SearchFilter = NULL;

    do {

	Len = wcslen( HostName ) + 10 ;
	Buf = MemAlloc( Len * sizeof( WCHAR ));
	if ( NULL == Buf ) {
	    break;
	}

	// make (objectCategory=dHCPClass)
	Filter1 = MakeLdapFilter( ATTRIB_OBJECT_CATEGORY,
				  LDAP_OPERATOR_EQUAL_TO,
				  DEFAULT_DHCP_CLASS_ATTRIB_VALUE,
				  TRUE );

	if ( NULL == Filter1 ) {
	    break;
	}

	// The IP needs to be sent as i<ip>* to match the query
	
	// make (dhcpServers="i<ip>*")
	CopiedLen = _snwprintf( Buf, Len, L"i%ws*", LookupServerIP );
	Require( CopiedLen > 0 );
	Filter2 = MakeLdapFilter( DHCP_ATTRIB_SERVERS,
				  LDAP_OPERATOR_EQUAL_TO, Buf, TRUE );
	if ( NULL == Filter2 ) {
	    break;
	}

	// make (dhcpServers="*s<hostname>*")
	CopiedLen = _snwprintf( Buf, Len, L"*s%ws*", HostName );
	Require( CopiedLen > 0 );
	Filter3 = MakeLdapFilter( DHCP_ATTRIB_SERVERS, 
				  LDAP_OPERATOR_EQUAL_TO, Buf, TRUE );
	
	if ( NULL == Filter3 ) {
	    break;
	}

	// make (|(<ipfilter>)(<hostfilter))
	Filter4 = MakeLdapFilter( Filter2, LDAP_OPERATOR_OR,
				  Filter3, FALSE );

	if ( NULL == Filter4 ) {
	    break;
	}

	// Finally make the filter to be returned
	SearchFilter = MakeLdapFilter( Filter1, LDAP_OPERATOR_AND,
				       Filter4, FALSE );

    } while ( FALSE );
    
    if ( NULL != Buf ) {
	MemFree( Buf );
    }
    if ( NULL != Filter1 ) {
	MemFree( Filter1 );
    }
    if ( NULL != Filter2 ) {
	MemFree( Filter2 );
    }
    if ( NULL != Filter3 ) {
	MemFree( Filter3 );
    }
    if ( NULL != Filter4 ) {
	MemFree( Filter4 );
    }
    
    return SearchFilter;
} // MakeFilter()

//================================================================================
//  This function computes the unique identifier for a client; this is just
//  client subnet + client hw address type + client hw address. note that client
//  hardware address type is hardcoded as HARDWARE_TYPE_10MB_EITHERNET as there
//  is no way in the ui to specify type of reservations..
//  Also, DhcpValidateClient (cltapi.c?) uses the subnet address for validation.
//  Dont remove that.
//================================================================================
DWORD
DhcpMakeClientUID(                 // compute unique identifier for the client
    IN      LPBYTE                 ClientHardwareAddress,
    IN      DWORD                  ClientHardwareAddressLength,
    IN      BYTE                   ClientHardwareAddressType,
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    OUT     LPBYTE                *ClientUID,          // will be allocated by function
    OUT     DWORD                 *ClientUIDLength
)
{
    LPBYTE                         Buffer;
    LPBYTE                         ClientUIDBuffer;
    BYTE                           ClientUIDBufferLength;

    if( NULL == ClientUID || NULL == ClientUIDLength || 0 == ClientHardwareAddressLength )
        return ERROR_INVALID_PARAMETER;

    // see comment about on hardcoded hardware address type
    ClientHardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;

    ClientUIDBufferLength  =  sizeof(ClientSubnetAddress);
    ClientUIDBufferLength +=  sizeof(ClientHardwareAddressType);
    ClientUIDBufferLength +=  (BYTE)ClientHardwareAddressLength;

    ClientUIDBuffer = MemAlloc( ClientUIDBufferLength );

    if( ClientUIDBuffer == NULL ) {
        *ClientUIDLength = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Buffer = ClientUIDBuffer;
    RtlCopyMemory(Buffer,&ClientSubnetAddress,sizeof(ClientSubnetAddress));

    Buffer += sizeof(ClientSubnetAddress);
    RtlCopyMemory(Buffer,&ClientHardwareAddressType,sizeof(ClientHardwareAddressType) );

    Buffer += sizeof(ClientHardwareAddressType);
    RtlCopyMemory(Buffer,ClientHardwareAddress,ClientHardwareAddressLength );

    *ClientUID = ClientUIDBuffer;
    *ClientUIDLength = ClientUIDBufferLength;

    return ERROR_SUCCESS;
}

VOID        static
MemFreeFunc(                                      // free memory
    IN OUT  LPVOID                 Memory
)
{
    MemFree(Memory);
}

//DOC ServerAddAddress should add the new address to the server's attribs
//DOC it should take this opportunity to reconcile the server.
//DOC Currently it does nothing. (at the least it should probably try to
//DOC check if the object exists, and if not create it.)
//DOC
DWORD
ServerAddAddress(                                 // add server and do misc work
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for server obj
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ADsPath,       // ADS path of the server
    IN      DWORD                  IpAddress,     // IpAddress to add to server
    IN      DWORD                  State          // state of server
)
{
    return AddServer(hDhcpC, ServerName, ADsPath, IpAddress, State);
}

//DOC CreateServerObject creates the server object in the DS. It takes the
//DOC ServerName parameter and names the object using this.
//DOC The server is created with default values for most attribs.
//DOC Several attribs are just not set.
//DOC This returns ERROR_DDS_UNEXPECTED_ERROR if any DS operation fails.
DWORD
CreateServerObject(                               // create dhcp srvr obj in ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container to creat obj in
    IN      LPWSTR                 ServerName     // [DNS?] name of server
)
{
    DWORD                          Err;
    LPWSTR                         ServerCNName;  // container name

    ServerCNName = MakeColumnName(ServerName);    // convert from "name" to "CN=name"
    if( NULL == ServerCNName ) return ERROR_NOT_ENOUGH_MEMORY;

    Err = StoreCreateObject                       // now create the object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ ServerCNName,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          ServerName,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        DHCP_OBJ_TYPE_SERVER,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, DHCP_OBJ_TYPE_SERVER_DESC,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );
    if( ERROR_ALREADY_EXISTS == Err ) {           // if object exists, ignore this..
        Err = ERROR_SUCCESS;
    }

    MemFree(ServerCNName);
    return Err;
}

//DOC CreateSubnetObject creates the subnet object in the DS by cooking up a
//DOC name that is just a concatenation of the server name and the subnet address.
//DOC The object is set with some default values for most attribs.
//DOC This fn returns ERROR_DDS_UNEXPECTED_ERROR if any DS operation fails.
DWORD
CreateSubnetObject(                               // create dhcp subnet obj in ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container obj
    IN      LPWSTR                 SubnetCNName   // subnet name in "CN=xx" fmt
)
{
    DWORD                          Err;
    LPWSTR                         SubnetName;

    SubnetName = SubnetCNName + 3;                // skip the "CN=" part

    Err = StoreCreateObject                       // now create the object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ SubnetCNName,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          SubnetName,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        DHCP_OBJ_TYPE_SUBNET,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, DHCP_OBJ_TYPE_SUBNET_DESC,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );
    if( ERROR_ALREADY_EXISTS == Err ) {           // if object exists, ignore this..
        Err = ERROR_SUCCESS;
    }

    return Err;
}

//DOC CreateReservationObject creates a reservation object in the DS.
//DOC It just fills in some reasonable information for all the required fields.
//DOC If fails if the object already exists
//DOC
DWORD
CreateReservationObject(                          // create reservation object in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container obj
    IN      LPWSTR                 ReserveCNName  // reservation name in "CN=X" fmt
)
{
    DWORD                          Err;
    LPWSTR                         ReserveName;

    ReserveName = ReserveCNName+ 3;

    Err = StoreCreateObject                       // now create the object
    (
        /* hStore               */ hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ ReserveCNName,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          ReserveName,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        DHCP_OBJ_TYPE_RESERVATION,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, DHCP_OBJ_TYPE_RESERVATION_DESC,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );
    if( ERROR_ALREADY_EXISTS == Err ) {           // if object exists, ignore this..
        Err = ERROR_SUCCESS;
    }

    return Err;
}

//DOC FindCollisions walks through an array of attribs and compares each
//DOC against the parameters to see if there is a collision.. If the parameters
//DOC passed have type RANGE, then an extension of a range is allowed.
//DOC If not, anything is allowed.  In case there is an extension, the Extender
//DOC parameter is filled with the attrib that gets extended..
//DOC This function returns TRUE if there is a collision and FALSE if ok.
BOOL
FindCollisions(                                   // find range vs range collisions
    IN      PARRAY                 Attribs,       // array of PEATTRIB's
    IN      DWORD                  RangeStart,
    IN      DWORD                  RangeEnd,
    IN      DWORD                  RangeType,     // RANGE_TYPE_RANGE || RANGE_TYPE_EXCL
    OUT     PEATTRIB              *Extender       // this attrib needs to be extended
)
{
    DWORD                          Err, Cond;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;

    *Extender = NULL;
    if( (RangeType & RANGE_TYPE_MASK) == RANGE_TYPE_EXCL ) {
        return ERROR_SUCCESS;                     // anything is ok for excl
    }

    for(                                          // walk thru the array
        Err = MemArrayInitLoc(Attribs, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(Attribs, &Loc)
    ) {
        Err = MemArrayGetElement(Attribs, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no range start
            !IS_ADDRESS2_PRESENT(ThisAttrib) ||   // no range end
            !IS_FLAGS1_PRESENT(ThisAttrib) ) {    // range state?
            continue;                             //=  ds inconsistent
        }

        if( IS_FLAGS2_PRESENT(ThisAttrib) &&
            (RANGE_TYPE_MASK & ThisAttrib->Flags2) == RANGE_TYPE_EXCL ) {
            continue;                             // skip exclusions
        }

        if( ThisAttrib->Address2 < ThisAttrib->Address1 ) {
            continue;                             //=  ds inconsistent
        }

        Cond = MemRangeCompare(
            RangeStart,RangeEnd,                  // range X and below is range Y
            ThisAttrib->Address1, ThisAttrib->Address2
        );
        switch(Cond) {                            // make comparisons on 2 ranges
        case X_LESSTHAN_Y_OVERLAP:
        case Y_LESSTHAN_X_OVERLAP:
            if( NULL != *Extender ) return TRUE;  // double extensions not allowed
            *Extender = ThisAttrib;
            break;
        case X_IN_Y:
        case Y_IN_X:
            return TRUE;                          // head on collision is fatal
        }
    }
    return FALSE;
}

BOOL
ServerMatched(
    IN PEATTRIB ThisAttrib,
    IN LPWSTR ServerName,
    IN ULONG IpAddress,
    OUT BOOL *fExactMatch
    )
{
    BOOL fIpMatch, fNameMatch, fWildcardIp;
    
    (*fExactMatch) = FALSE;

    fIpMatch = (ThisAttrib->Address1 == IpAddress);
    if( INADDR_BROADCAST == ThisAttrib->Address1 ||
        INADDR_BROADCAST == IpAddress ) {
        fWildcardIp = TRUE;
    } else {
        fWildcardIp = FALSE;
    }
    
    if( FALSE == fIpMatch ) {
        //
        // If IP Addresses don't match, then check to see if
        // one of the IP addresses is a broadcast address..
        //
        if( !fWildcardIp ) return FALSE;
    }

    fNameMatch = DnsNameCompare_W(ThisAttrib->String1, ServerName);
    if( FALSE == fNameMatch ) {
        //
        // If names don't match _and_ IP's don't match, no match.
        //
        if( FALSE == fIpMatch || fWildcardIp ) return FALSE;
    } else {
        if( FALSE == fIpMatch ) return TRUE;
        
        (*fExactMatch) = TRUE;
    }
    return TRUE;
}

DWORD
GetListOfAllServersMatchingFilter(
    IN OUT LPSTORE_HANDLE hDhcpC,
    IN OUT PARRAY Servers,
    IN     LPWSTR SearchFilter  OPTIONAL
)
{
    DWORD Err, LastErr;
    STORE_HANDLE hContainer;
    LPWSTR Filter;

    AssertRet( ( NULL != hDhcpC ) && ( NULL != Servers ),
	       ERROR_INVALID_PARAMETER );

    Err = StoreSetSearchOneLevel(
        hDhcpC, DDS_RESERVED_DWORD );
    AssertRet( Err == NO_ERROR, Err );

    if ( NULL == SearchFilter ) {
	Filter = DHCP_SEARCH_FILTER;
    }
    else {
	Filter = SearchFilter;
    }
    AssertRet( NULL != Filter, ERROR_INVALID_PARAMETER );

    Err = StoreBeginSearch(
        hDhcpC, DDS_RESERVED_DWORD, Filter );
    AssertRet( Err == NO_ERROR, Err );

    while( TRUE ) {
        Err = StoreSearchGetNext(
            hDhcpC, DDS_RESERVED_DWORD, &hContainer );

        if( ERROR_DS_INVALID_DN_SYNTAX == Err ) {
            //
            // This nasty problem is because of an upgrade issue
            // in DS where some bad-named objects may exist..
            //
            Err = NO_ERROR;
            continue;
        }

        if( NO_ERROR != Err ) break;
        
        Err = DhcpDsGetLists
        (
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* hStore               */ &hContainer,
            /* RecursionDepth       */ 0xFFFFFFFF,
            /* Servers              */ Servers,      // array of PEATTRIB 's
            /* Subnets              */ NULL,
            /* IpAddress            */ NULL,
            /* Mask                 */ NULL,
            /* Ranges               */ NULL,
            /* Sites                */ NULL,
            /* Reservations         */ NULL,
            /* SuperScopes          */ NULL,
            /* OptionDescription    */ NULL,
            /* OptionsLocation      */ NULL,
            /* Options              */ NULL,
            /* Classes              */ NULL
        );

        StoreCleanupHandle( &hContainer, DDS_RESERVED_DWORD );

        if( NO_ERROR != Err ) break;

    }

    if( Err == ERROR_NO_MORE_ITEMS ) Err = NO_ERROR;
    
    LastErr = StoreEndSearch( hDhcpC, DDS_RESERVED_DWORD );
    //Require( LastErr == NO_ERROR );

    return Err;
}

DWORD
DhcpDsAddServerInternal(                          // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    BOOL                           fServerExists;
    LPWSTR                         ServerLocation, Tmp;
    DWORD                          ServerLocType;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of servers
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Tmp = NULL; ServerLocation = NULL;
    fServerExists = FALSE;                        // did we find the same servername?
    for(                                          // search list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
        ) {
        BOOL fExactMatch = FALSE;
        
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        if( ServerMatched(ThisAttrib, ServerName, IpAddress, &fExactMatch ) ) {
            //
            // Server found in the list of servers.  Exact match not allowed.
            //
            if( fExactMatch ) {
                MemArrayFree(&Servers,MemFreeFunc);// free allocated memory
                return ERROR_DDS_SERVER_ALREADY_EXISTS;
            }
                
            fServerExists = TRUE;
            if( IS_ADDRESS1_PRESENT(ThisAttrib) &&
                NULL == ServerLocation ) {        // remember location in DS.
                ServerLocation = ThisAttrib->ADsPath;
                ServerLocType = ThisAttrib->StoreGetType;
            }
        }            
    }


    if( !fServerExists ) {                        // if freshly adding a server, create obj
        WCHAR Buf[sizeof("000.000.000.000")];
        LPWSTR SName;
        
        if( L'\0' != ServerName[0] ) {
            SName = ServerName;
        } else {
            ULONG IpAddr;
            LPSTR IpAddrString;

            IpAddr = htonl(IpAddress);
            IpAddrString = inet_ntoa(*(struct in_addr *)&IpAddr);
            Err = mbstowcs(Buf, IpAddrString, sizeof(Buf)/sizeof(WCHAR));
            if( -1 == Err ) {
                MemArrayFree(&Servers, MemFreeFunc);
                return ERROR_CAN_NOT_COMPLETE;
            }
            SName = Buf;
        }
        
        ServerLocation = Tmp = MakeColumnName(SName);
        ServerLocType = StoreGetChildType;
    }

    NothingPresent(&DummyAttrib);                 // fill in attrib w/ srvr info
    STRING1_PRESENT(&DummyAttrib);                // name
    ADDRESS1_PRESENT(&DummyAttrib);               // ip addr
    FLAGS1_PRESENT(&DummyAttrib);                 // state
    DummyAttrib.String1 = ServerName;
    DummyAttrib.Address1 = IpAddress;
    DummyAttrib.Flags1 = State;
    if( ServerLocation ) {
        ADSPATH_PRESENT(&DummyAttrib);            // ADsPath of location of server object
        STOREGETTYPE_PRESENT(&DummyAttrib);
        DummyAttrib.ADsPath = ServerLocation;
        DummyAttrib.StoreGetType = ServerLocType;
    }

    Err = MemArrayAddElement(&Servers, &DummyAttrib);
    if( ERROR_SUCCESS != Err ) {                  // could not add this to attrib array
        MemArrayFree(&Servers, MemFreeFunc);      // free allocated memory
        if( Tmp ) MemFree(Tmp);                   // if allocate mem for ServerLocation..
        return Err;
    }

    Err = DhcpDsSetLists                          // now set the new attrib list
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* SetParams            */ &unused,
        /* Servers              */ &Servers,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );

    Err2 = MemArrayLastLoc(&Servers, &Loc);       // theres atleast 1 elt in array
    //= require ERROR_SUCCESS == Err2
    Err2 = MemArrayDelElement(&Servers, &Loc, &ThisAttrib);
    //= require ERROR_SUCCESS == Err2 && ThisAttrib == &DummyAttrib
    MemArrayFree(&Servers, MemFreeFunc);          // free allocated memory

    if( ERROR_SUCCESS != Err || fServerExists ) {
        if( Tmp ) MemFree(Tmp);                   // if allocated memory for ServerLocation..
        if( ERROR_SUCCESS != Err) return Err;     // check err for DhcpDsSetLists

        //: This wont do if there is a problem...
        if( fServerExists ) return ERROR_SUCCESS; // if server already existed.. not much work needed?
    }
    
    if( Tmp ) MemFree(Tmp);

    return Err;
}

//================================================================================
//  exported functions
//================================================================================

//BeginExport(function)
//DOC DhcpDsAddServer adds a server's entry in the DS.  Note that only the name
//DOC uniquely determines the server. There can be one server with many ip addresses.
//DOC If the server is created first time, a separate object is created for the
//DOC server. : TO DO: The newly added server should also have its data
//DOC updated in the DS uploaded from the server itself if it is still up.
//DOC Note that it takes as parameter the Dhcp root container.
//DOC If the requested address already exists in the DS (maybe to some other
//DOC server), then the function returns ERROR_DDS_SERVER_ALREADY_EXISTS
DWORD
DhcpDsAddServer(                                  // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
)   //EndExport(function)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           fServerExists;
    LPWSTR                         ServerLocation, Tmp;
    DWORD                          ServerLocType;
    STORE_HANDLE                   hDhcpServer;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err

    DsAuthPrint(( L"DhcpAddServer() \n" ));

    Err = GetListOfAllServersMatchingFilter( hDhcpC, &Servers,
					     DHCP_SEARCH_FILTER );
    if( ERROR_SUCCESS != Err ) return Err;

    Tmp = NULL; ServerLocation = NULL;
    fServerExists = FALSE;                        // did we find the same servername?
    for(                                          // search list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        BOOL fExactMatch = FALSE;
        
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        if( ServerMatched(ThisAttrib, ServerName, IpAddress, &fExactMatch ) ) {
            //
            // Server found in the list of servers.  Exact match not allowed.
            //
            if( fExactMatch ) {
                MemArrayFree(&Servers,MemFreeFunc);// free allocated memory
                return ERROR_DDS_SERVER_ALREADY_EXISTS;
            }
                
            fServerExists = TRUE;
            if( IS_ADDRESS1_PRESENT(ThisAttrib) &&
                NULL == ServerLocation ) {        // remember location in DS.
                ServerLocation = ThisAttrib->ADsPath;
                ServerLocType = ThisAttrib->StoreGetType;
            }
        }            
    } // for

    if( !fServerExists ) {                        // if freshly adding a server, create obj
        WCHAR Buf[sizeof("000.000.000.000")];
        LPWSTR SName;
        
        if( L'\0' != ServerName[0] ) {
	    // do not use the name. Use the printable IP addr instead
            SName = ServerName;
        } else {
            ULONG IpAddr;
            LPSTR IpAddrString;

            IpAddr = htonl(IpAddress);
            IpAddrString = inet_ntoa(*(struct in_addr *)&IpAddr);
            Err = mbstowcs(Buf, IpAddrString, sizeof(Buf)/sizeof(WCHAR));
            if( -1 == Err ) {
                MemArrayFree(&Servers, MemFreeFunc);
                return ERROR_CAN_NOT_COMPLETE;
            }
            SName = Buf;
        }
        
        Err = CreateServerObject(
            /*  hDhcpC          */ hDhcpC,
            /*  ServerName      */ SName
        );
        if( ERROR_SUCCESS != Err ) {              // dont add server if obj cant be created
            MemArrayFree(&Servers, MemFreeFunc);  // free allocated memory
            return Err;
        }
        ServerLocation = Tmp = MakeColumnName(SName);
        ServerLocType = StoreGetChildType;
    }

    Err = StoreGetHandle(
        hDhcpC, 0, ServerLocType, ServerLocation, &hDhcpServer );
    if( NO_ERROR == Err ) {
        Err = DhcpDsAddServerInternal(
            hDhcpC, &hDhcpServer, Reserved, ServerName, ReservedPtr,
            IpAddress, State );
        StoreCleanupHandle( &hDhcpServer, 0 );
    }

    MemArrayFree(&Servers, MemFreeFunc);          // free allocated memory

    if( ERROR_SUCCESS != Err || fServerExists ) {
        if( Tmp ) MemFree(Tmp);                   // if allocated memory for ServerLocation..
        if( ERROR_SUCCESS != Err) return Err;     // check err for DhcpDsSetLists

        //: This wont do if there is a problem...
        if( fServerExists ) return ERROR_SUCCESS; // if server already existed.. not much work needed?
    }
    
    Err = ServerAddAddress                        // add the info into the server
    (
        /* hDhcpC               */ hDhcpC,
        /* ServerName           */ ServerName,
        /* ADsPath              */ ServerLocation,
        /* IpAddress            */ IpAddress,
        /* State                */ State
    );
    if( Tmp ) MemFree(Tmp);

    return Err;
}

DWORD
DhcpDsDelServerInternal(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib, SavedAttrib;
    BOOL                           fServerExists;
    BOOL                           fServerDeleted;
    LPWSTR                         SName;
    LPWSTR                         ServerLoc = NULL;
    DWORD                          ServerLocType;
    WCHAR                          Buf[sizeof("000.000.000.000")];
        
    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of servers
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    SavedAttrib = NULL;
    fServerExists = fServerDeleted = FALSE;
    for(                                          // search list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        BOOL fExactMatch = FALSE;
            
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        if( ServerMatched(ThisAttrib, ServerName, IpAddress, &fExactMatch ) ) {
            //
            // Server found. If exact match, remove the element from list.
            //
            if( fExactMatch ) {
                Err2 = MemArrayDelElement(&Servers, &Loc, &ThisAttrib);
                //= ERROR_SUCCESS == Err2 && NULL != ThisAttrib
            }

            if( (NULL == ServerLoc || fExactMatch)
                && IS_ADSPATH_PRESENT(ThisAttrib) ) {
                ServerLocType = ThisAttrib->StoreGetType;
                ServerLoc = ThisAttrib->ADsPath;  // remember this path..
                SavedAttrib = ThisAttrib;         // remember this attrib.. to del later
            } else {                              // this attrib is useless, free it
                if( fExactMatch ) MemFree(ThisAttrib);
            }

            if( fExactMatch ) fServerDeleted = TRUE;
            else fServerExists = TRUE;
        }
    }

    if( !fServerDeleted ) {                       // never found the requested entry..
        MemArrayFree(&Servers, MemFreeFunc);      // free up memory
        return ERROR_DDS_SERVER_DOES_NOT_EXIST;
    }

    Err = DhcpDsSetLists                          // now set the new attrib list
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hDhcpRoot,
        /* SetParams            */ &unused,
        /* Servers              */ &Servers,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );
    MemArrayFree(&Servers, MemFreeFunc);          // free allocated memory
    if( ERROR_SUCCESS != Err) {                   // check err for DhcpDsSetLists
        if(SavedAttrib) MemFree(SavedAttrib);
        return Err;
    }

    if( fServerExists ) {                         // still some addr left for this srvr
        if( SavedAttrib ) MemFree(SavedAttrib);
        return ERROR_SUCCESS;
    }

    if( SavedAttrib ) MemFree(SavedAttrib);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsDelServer removes the requested servername-ipaddress pair from the ds.
//DOC If this is the last ip address for the given servername, then the server
//DOC is also removed from memory.  But objects referred by the Server are left in
//DOC the DS as they may also be referred to from else where.  This needs to be
//DOC fixed via references being tagged as direct and symbolic -- one causing deletion
//DOC and other not causing any deletion.  THIS NEEDS TO BE FIXED. 
DWORD
DhcpDsDelServer(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
) //EndExport(function)
{
    DWORD Err, LastErr, ReturnError;
    STORE_HANDLE hDhcpServer;
    ARRAY Servers;
    BOOL fEmpty;
    LPWSTR Location;
    LPWSTR IsDhcpRoot = NULL;
    
    MemArrayInit(&Servers);

    Err = StoreSetSearchOneLevel(
        hDhcpC, DDS_RESERVED_DWORD );
    AssertRet( Err == NO_ERROR, Err );

    Err = StoreBeginSearch(
        hDhcpC, DDS_RESERVED_DWORD, DHCP_SEARCH_FILTER );
    AssertRet( Err == NO_ERROR, Err );

    //
    // Look at each dhcp object in container
    //

    ReturnError = ERROR_DDS_SERVER_DOES_NOT_EXIST;

    while( TRUE ) {
        Err = StoreSearchGetNext(
            hDhcpC, DDS_RESERVED_DWORD, &hDhcpServer );

        if( ERROR_DS_INVALID_DN_SYNTAX == Err ) {
            //
            // This nasty problem is because of an upgrade issue
            // in DS where some bad-named objects may exist..
            //
            Err = NO_ERROR;
            continue;
        }

        if( NO_ERROR != Err ) break;

        //
        // Attempt to delete reqd server
        //

        Err = DhcpDsDelServerInternal(
            hDhcpC, &hDhcpServer, Reserved, ServerName,
            ReservedPtr, IpAddress );

        if( ERROR_DDS_SERVER_DOES_NOT_EXIST == Err ) {
            StoreCleanupHandle( &hDhcpServer, DDS_RESERVED_DWORD );
            continue;
        }
        
        if( NO_ERROR != Err ) {
            StoreCleanupHandle( &hDhcpServer, DDS_RESERVED_DWORD );
            break;
        }
        
        ReturnError = NO_ERROR;
        
        //
        // If the above succeeded, then check if the container
        // has no servers defined -- in this case we can delete
        // the container itself
        //
        
        Err = DhcpDsGetLists
        (
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* hStore               */ &hDhcpServer,
            /* RecursionDepth       */ 0xFFFFFFFF,
            /* Servers              */ &Servers,      // array of PEATTRIB 's
            /* Subnets              */ NULL,
            /* IpAddress            */ NULL,
            /* Mask                 */ NULL,
            /* Ranges               */ NULL,
            /* Sites                */ NULL,
            /* Reservations         */ NULL,
            /* SuperScopes          */ NULL,
            /* OptionDescription    */ NULL,
            /* OptionsLocation      */ NULL,
            /* Options              */ NULL,
            /* Classes              */ NULL
            );
        
        if( NO_ERROR != Err ) {
            StoreCleanupHandle( &hDhcpServer, DDS_RESERVED_DWORD );
            break;
        }
        
        fEmpty = (0 == MemArraySize(&Servers));
        MemArrayFree(&Servers, MemFreeFunc);
        
        Location = CloneString(hDhcpServer.Location);
        StoreCleanupHandle( &hDhcpServer, DDS_RESERVED_DWORD );
        
        if( NULL == Location ) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        IsDhcpRoot = wcsstr( Location, DHCP_ROOT_OBJECT_NAME );

        if( fEmpty && ( IsDhcpRoot == NULL ) )
            Err = StoreDeleteThisObject(
                                        hDhcpC, 
                                        DDS_RESERVED_DWORD,
                                        StoreGetAbsoluteOtherServerType, 
                                        Location );


        MemFree( Location );

        if( NO_ERROR != Err ) break;
    }

    if( Err == ERROR_NO_MORE_ITEMS ) Err = NO_ERROR;
    
    LastErr = StoreEndSearch( hDhcpC, DDS_RESERVED_DWORD );
    //Require( LastErr == NO_ERROR );

    if( NO_ERROR == Err ) Err = ReturnError;
    
    return Err;
} // DhcpDsDelServer()

//BeginExport(function)
BOOL
DhcpDsLookupServer(                               // get info about a server
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 LookupServerIP,// Server to lookup IP
    IN      LPWSTR                 HostName      // Hostname to lookup
) //EndExport(function)
{
    DWORD                          Err, Err2, Size, Size2, i, N;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCPDS_SERVERS               LocalServers;
    LPBYTE                         Ptr;
    LPWSTR                         SearchFilter;
    STORE_HANDLE                   hContainer;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return FALSE;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return FALSE;

    if (( NULL == HostName ) ||
	( NULL == LookupServerIP )) {
	return FALSE;
    }

    SearchFilter = MakeFilter( LookupServerIP, HostName );
    if ( NULL == SearchFilter ) {
	return FALSE;
    }

    DsAuthPrint(( L"hostname = %ws, IP = %ws, Filter = %ws\n",
		  HostName, LookupServerIP, SearchFilter ));

    Err = StoreSetSearchOneLevel( hDhcpC, DDS_RESERVED_DWORD );
    AssertRet( Err == NO_ERROR, Err );

    Err = StoreBeginSearch( hDhcpC, DDS_RESERVED_DWORD, SearchFilter );
    MemFree( SearchFilter );
    AssertRet( Err == NO_ERROR, Err );

    Err = StoreSearchGetNext( hDhcpC, DDS_RESERVED_DWORD, &hContainer );

    StoreEndSearch( hDhcpC, DDS_RESERVED_DWORD );
    return ( NO_ERROR == Err );
} // DhcpDsLookupServer()


//BeginExport(function)
//DOC DhcpDsEnumServers retrieves a bunch of information about each server that
//DOC has an entry in the Servers attribute of the root object. There are no guarantees
//DOC on the order..
//DOC The memory for this is allocated in ONE shot -- so the output can be freed in
//DOC one shot too.
//DOC
DWORD
DhcpDsEnumServers(                                // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCPDS_SERVERS      *ServersInfo    // array of servers
) //EndExport(function)
{
    DWORD                          Err, Err2, Size, Size2, i, N;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCPDS_SERVERS               LocalServers;
    LPBYTE                         Ptr;
    LPWSTR                         Filter1, Filter2, Filter3;

    if( NULL == hDhcpRoot || NULL == hDhcpC )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpRoot->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( 0 != Reserved || NULL == ServersInfo )
        return ERROR_INVALID_PARAMETER;

    *ServersInfo = NULL; i = N = Size = Size2 = 0;

    Err = MemArrayInit(&Servers);                 // cant fail
    //= require ERROR_SUCCESS == Err

    DsAuthPrint(( L"DhcpDsEnumServers \n" ));

    Err = GetListOfAllServersMatchingFilter( hDhcpC, &Servers,
					     DHCP_SEARCH_FILTER );
    if( ERROR_SUCCESS != Err ) return Err;

    Size = Size2 = 0;
    for(                                          // walk thru list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        Size2 = sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        if( IS_ADSPATH_PRESENT(ThisAttrib) ) {    // if ADsPath there, account for it
            Size2 += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->ADsPath));
        }

        Size += Size2;                            // keep track of total mem reqd
        i ++;
    }

    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVERS), ALIGN_WORST);
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVER)*i, ALIGN_WORST);
    Ptr = MemAlloc(Size);                         // allocate memory
    if( NULL == Ptr ) {
        MemArrayFree(&Servers, MemFreeFunc );     // free allocated memory
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalServers = (LPDHCPDS_SERVERS)Ptr;
    LocalServers->NumElements = i;
    LocalServers->Flags = 0;
    Size = 0;                                     // start from offset 0
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVERS), ALIGN_WORST);
    LocalServers->Servers = (LPDHCPDS_SERVER)(Size + Ptr);
    Size += ROUND_UP_COUNT(sizeof(DHCPDS_SERVER)*i, ALIGN_WORST);

    i = Size2 = 0;
    for(                                          // copy list of servers
        Err = MemArrayInitLoc(&Servers, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Servers, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        LocalServers->Servers[i].Version =0;      // version is always zero in this build
        LocalServers->Servers[i].State=0;
        LocalServers->Servers[i].ServerName = (LPWSTR)(Size + Ptr);
        wcscpy((LPWSTR)(Size+Ptr), ThisAttrib->String1);
        Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        LocalServers->Servers[i].ServerAddress = ThisAttrib->Address1;
        if( IS_FLAGS1_PRESENT(ThisAttrib) ) {     // State present
            LocalServers->Servers[i].Flags = ThisAttrib->Flags1;
        } else {
            LocalServers->Servers[i].Flags = 0;   // if no flags present, use zero
        }
        if( IS_ADSPATH_PRESENT(ThisAttrib) ) {    // if ADsPath there, copy it too
            LocalServers->Servers[i].DsLocType = ThisAttrib->StoreGetType;
            LocalServers->Servers[i].DsLocation = (LPWSTR)(Size + Ptr);
            wcscpy((LPWSTR)(Size + Ptr), ThisAttrib->ADsPath);
            Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->ADsPath));
        } else {                                  // no ADsPath present
            LocalServers->Servers[i].DsLocType = 0;
            LocalServers->Servers[i].DsLocation = NULL;
        }
        i ++;
    }

    *ServersInfo = LocalServers;
    MemArrayFree(&Servers, MemFreeFunc );         // free allocated memory
    return ERROR_SUCCESS;
} // DhcpDsEnumServers()

//BeginExport(function)
//DOC DhcpDsSetSScope modifies the superscope that a subnet belongs to.
//DOC The function tries to set the superscope of the subnet referred by
//DOC address IpAddress to SScopeName.  It does not matter if the superscope
//DOC by that name does not exist, it is automatically created.
//DOC If the subnet already had a superscope, then the behaviour depends on
//DOC the flag ChangeSScope.  If this is TRUE, it sets the new superscopes.
//DOC If the flag is FALSE, it returns ERROR_DDS_SUBNET_HAS_DIFF_SSCOPE.
//DOC This flag is ignored if the subnet does not have a superscope already.
//DOC If SScopeName is NULL, the function removes the subnet from any superscope
//DOC if it belonged to one before.
//DOC If the specified subnet does not exist, it returns ERROR_DDS_SUBNET_NOT_PRESENT.
DWORD
DhcpDsSetSScope(                                  // change superscope of subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      DWORD                  IpAddress,     // subnet address to use
    IN      LPWSTR                 SScopeName,    // sscope it must now be in
    IN      BOOL                   ChangeSScope   // if it already has a SScope, change it?
)   //EndExport(function)
{
    DWORD                          Err, unused;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           SubnetPresent;

    if( 0 != Reserved )                           // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpC || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer || NULL == hServer->ADSIHandle )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // fetch subnet array
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;        // shouldn't really fail

    SubnetPresent = FALSE;
    for(                                          // search for specified subnet
        Err = MemArrayInitLoc(&Subnets, &Loc)     // init
        ; ERROR_FILE_NOT_FOUND != Err ;           // 'til v run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next elt
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no subnet name
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no subnet address
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 != IpAddress ) { // not this subnet we're looking for
            continue;
        }

        SubnetPresent = TRUE;                     // found the subnet we're intersted in
        break;
    }

    if( !SubnetPresent ) {                        // did not even find the subnet?
        MemArrayFree(&Subnets, MemFreeFunc);      // free up memory taken
        return ERROR_DDS_SUBNET_NOT_PRESENT;
    }

    if( NULL == SScopeName ) {                    // we're trying to remove from sscope
        if( !IS_STRING3_PRESENT(ThisAttrib) ) {   // does not belong to any sscope ?
            MemArrayFree(&Subnets, MemFreeFunc);
            return ERROR_SUCCESS;                 // return as no change reqd
        }
        STRING3_ABSENT(ThisAttrib);               // remove SScope..
    } else {
        if( IS_STRING3_PRESENT(ThisAttrib) ) {    // sscope present.. trying to change it
            if( FALSE == ChangeSScope ) {         // we were not asked to do this
                MemArrayFree(&Subnets, MemFreeFunc);
                return ERROR_DDS_SUBNET_HAS_DIFF_SSCOPE;
            }
        }

        STRING3_PRESENT(ThisAttrib);
        ThisAttrib->String3 = SScopeName;         // set the new SScope for this
    }

    Err = DhcpDsSetLists                          // now write back the new info onto the DS
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    MemArrayFree(&Subnets, MemFreeFunc);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsDelSScope deletes the superscope and removes all elements
//DOC that belong to that superscope in one shot. There is no error if the
//DOC superscope does not exist.
DWORD
DhcpDsDelSScope(                                  // delete superscope off DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 SScopeName     // sscope to delete
)   //EndExport(function)
{
    DWORD                          Err, unused;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           AnythingChanged;

    if( 0 != Reserved || NULL == SScopeName )     // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpC || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer || NULL == hServer->ADSIHandle )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // fetch subnet array
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;        // shouldn't really fail

    AnythingChanged = FALSE;
    for(                                          // search for specified SScope
        Err = MemArrayInitLoc(&Subnets, &Loc)     // init
        ; ERROR_FILE_NOT_FOUND != Err ;           // 'til v run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next elt
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no subnet name
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no subnet address
            continue;                             //=  ds inconsistent
        }

        if( !IS_STRING3_PRESENT(ThisAttrib) ) {   // this subnet does not have a sscope anyways
            continue;
        }

        if( 0 != wcscmp(ThisAttrib->String3, SScopeName) ) {
            continue;                             // not the same superscope
        }

        STRING3_ABSENT(ThisAttrib);               // kill the superscope
        AnythingChanged = TRUE;
    }

    if( !AnythingChanged ) {
        Err = ERROR_SUCCESS;                      // nothing more to do now..
    } else {
        Err = DhcpDsSetLists                      // now write back the new info onto the DS
        (
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* hStore           */ hServer,
            /* SetParams        */ &unused,
            /* Servers          */ NULL,
            /* Subnets          */ &Subnets,
            /* IpAddress        */ NULL,
            /* Mask             */ NULL,
            /* Ranges           */ NULL,
            /* Sites            */ NULL,
            /* Reservations     */ NULL,
            /* SuperScopes      */ NULL,
            /* OptionDescripti..*/ NULL,
            /* OptionsLocation  */ NULL,
            /* Options          */ NULL,
            /* ClassDescriptio..*/ NULL,
            /* Classes          */ NULL
        );
    }

    MemArrayFree(&Subnets, MemFreeFunc);
    return Err;
}

//BeginExport(function)
//DOC DhcpDsGetSScopeInfo retrieves the SuperScope table for the server of interest.
//DOC The table itself is allocated in one blob, so it can be freed lateron.
//DOC The SuperScopeNumber is garbage (always zero) and the NextInSuperScope reflects
//DOC the order in the DS which may/maynot be the same in the DHCP server.
//DOC SuperScopeName is NULL in for subnets that done have a sscope.
DWORD
DhcpDsGetSScopeInfo(                              // get superscope table from ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SScopeTbl   // allocated by this func in one blob
)   //EndExport(function)
{
    DWORD                          Err, unused, Size, Size2, i;
    DWORD                          Index, nSubnets;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCP_SUPER_SCOPE_TABLE       LocalTbl;
    LPBYTE                         Ptr;

    if( 0 != Reserved )                           // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpC || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer || NULL == hServer->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == SScopeTbl ) return ERROR_INVALID_PARAMETER;

    *SScopeTbl = NULL;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // fetch subnet array
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;        // shouldn't really fail

    Size = Size2 = i = 0;
    for(                                          // search for specified SScope
        Err = MemArrayInitLoc(&Subnets, &Loc)     // init
        ; ERROR_FILE_NOT_FOUND != Err ;           // 'til v run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next elt
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no subnet name
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no subnet address
            continue;                             //=  ds inconsistent
        }

        if( IS_STRING3_PRESENT(ThisAttrib) ) {    // make space for sscope name
            Size += sizeof(WCHAR)*(1+wcslen(ThisAttrib->String3));
        }
        i ++;                                     // keep right count of # of subnets
    }

    Size += ROUND_UP_COUNT(sizeof(DHCP_SUPER_SCOPE_TABLE),ALIGN_WORST);
    Size += ROUND_UP_COUNT(i*sizeof(DHCP_SUPER_SCOPE_TABLE_ENTRY), ALIGN_WORST);

    Ptr = MemAlloc(Size);                         // allocate the blob
    if( NULL == Ptr ) {
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalTbl = (LPDHCP_SUPER_SCOPE_TABLE)Ptr;
    Size = ROUND_UP_COUNT(sizeof(DHCP_SUPER_SCOPE_TABLE),ALIGN_WORST);
    LocalTbl->cEntries = i;
    if( i ) LocalTbl->pEntries = (LPDHCP_SUPER_SCOPE_TABLE_ENTRY)(Size+Ptr);
    else LocalTbl->pEntries = NULL;
    Size += ROUND_UP_COUNT(i*sizeof(DHCP_SUPER_SCOPE_TABLE_ENTRY), ALIGN_WORST);

    i = 0;
    for(                                          // search for specified SScope
        Err = MemArrayInitLoc(&Subnets, &Loc)     // init
        ; ERROR_FILE_NOT_FOUND != Err ;           // 'til v run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next elt
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no subnet name
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no subnet address
            continue;                             //=  ds inconsistent
        }

        LocalTbl->pEntries[i].SubnetAddress = ThisAttrib->Address1;
        LocalTbl->pEntries[i].SuperScopeNumber = 0;
        LocalTbl->pEntries[i].NextInSuperScope = 0;
        LocalTbl->pEntries[i].SuperScopeName = NULL;

        if( !IS_STRING3_PRESENT(ThisAttrib) ) {   // no sscope, nothin to do
            i ++;
            continue;
        }

        LocalTbl->pEntries[i].SuperScopeName = (LPWSTR)(Size + Ptr);
        wcscpy((LPWSTR)(Size+Ptr), ThisAttrib->String3);
        Size += sizeof(WCHAR)*(1+wcslen(ThisAttrib->String3));
        i ++;                                     // keep right count of # of subnets
    }

    MemArrayFree(&Subnets, MemFreeFunc);

    nSubnets = i;
    for( Index = 0; Index < nSubnets ; Index ++){ // calculate for each Index, next value
        if( NULL == LocalTbl->pEntries[Index].SuperScopeName)
            continue;                             // skip subnets that dont have sscope

        LocalTbl->pEntries[Index].NextInSuperScope = Index;

        for( i = 0; i < Index ; i ++ ) {          // first set it to just prev subnet
            if( NULL == LocalTbl->pEntries[i].SuperScopeName)
                continue;
            if( 0 == wcscmp(
                LocalTbl->pEntries[Index].SuperScopeName,
                LocalTbl->pEntries[i].SuperScopeName)
            ) {                                   // both subnets have same superscope
                LocalTbl->pEntries[Index].NextInSuperScope = i;
                // set next as last match in array before position Index
            }
        }

        for( i = Index + 1; i < nSubnets; i ++ ) {// check to see if any real next exists
            if( NULL == LocalTbl->pEntries[i].SuperScopeName)
                continue;
            if( 0 == wcscmp(
                LocalTbl->pEntries[Index].SuperScopeName,
                LocalTbl->pEntries[i].SuperScopeName)
            ) {                                   // both subnets have same superscope
                LocalTbl->pEntries[Index].NextInSuperScope = i;
                break;
            }
        }
    }

    *SScopeTbl = LocalTbl;                        // done.
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC DhcpDsServerAddSubnet tries to add a subnet to a given server. Each subnet
//DOC address has to be unique, but the other parameters dont have to.
//DOC The subnet address being added should not belong to any other subnet.
//DOC In this case it returns error ERROR_DDS_SUBNET_EXISTS
DWORD
DhcpDsServerAddSubnet(                            // create a new subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
)   //EndExport(function)
{
    DWORD                          Err, Err2, unused, i;
    DWORD                          Index, nSubnets;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        Dummy;
    LPWSTR                         SubnetObjName;

    if( 0 != Reserved )                           // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hDhcpC || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer || NULL == hServer->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Info ||  NULL == ServerName )
        return ERROR_INVALID_PARAMETER;
    if( Info->SubnetAddress != (Info->SubnetAddress & Info->SubnetMask ) )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // fetch subnet array
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;        // shouldn't really fail

    for(                                          // search for specified SScope
        Err = MemArrayInitLoc(&Subnets, &Loc)     // init
        ; ERROR_FILE_NOT_FOUND != Err ;           // 'til v run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next elt
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( (Info->SubnetAddress & ThisAttrib->Address2 ) == ThisAttrib->Address1 ) {
            return ERROR_DDS_SUBNET_EXISTS;       // Info belongs to this subnet
        }

        if( Info->SubnetAddress == (ThisAttrib->Address1 & Info->SubnetMask) ) {
            return ERROR_DDS_SUBNET_EXISTS;       // Info subsumes some other subnet
        }
    }

    SubnetObjName = MakeSubnetLocation(ServerName, Info->SubnetAddress);
    if( NULL == SubnetObjName ) {                 // not enough memory?
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Err = CreateSubnetObject                      // try creating the subnet obj 1st
    (
        /* hDhcpC               */ hDhcpC,        // create obj here..
        /* SubnetName           */ SubnetObjName
    );
    if( ERROR_SUCCESS != Err ) {                  // could not create obj, dont proceed
        MemArrayFree(&Subnets, MemFreeFunc);
        MemFree(SubnetObjName);
        return Err;
    }

    NothingPresent(&Dummy);                       // prepare info for new subnet
    ADDRESS1_PRESENT(&Dummy);                     // subnet address
    Dummy.Address1 = Info->SubnetAddress;
    ADDRESS2_PRESENT(&Dummy);                     // subnet mask
    Dummy.Address2 = Info->SubnetMask;
    FLAGS1_PRESENT(&Dummy);                       // subnet state
    Dummy.Flags1 = Info->SubnetState;
    if( Info->SubnetName ) {                      // subnet name
        STRING1_PRESENT(&Dummy);
        Dummy.String1 = Info->SubnetName;
    }
    if( Info->SubnetComment ) {                   // subnet comment
        STRING2_PRESENT(&Dummy);
        Dummy.String2 = Info->SubnetComment;
    }
    ADSPATH_PRESENT(&Dummy);                      // subnet obj location
    STOREGETTYPE_PRESENT(&Dummy);
    Dummy.ADsPath = SubnetObjName;
    Dummy.StoreGetType = StoreGetChildType;

    Err = MemArrayAddElement(&Subnets, &Dummy);   // add new attrib at end

    if( ERROR_SUCCESS != Err ) {                  // add failed for some reason
        MemFree(SubnetObjName);
        MemArrayFree(&Subnets, MemFreeFunc);      // cleanup any mem used
        return Err;
    }

    Err = DhcpDsSetLists                          // write back new info onto DS
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    MemFree(SubnetObjName);
    Err2 = MemArrayLastLoc(&Subnets, &Loc);       //= require ERROR_SUCCESS == Err
    Err2 = MemArrayDelElement(&Subnets, &Loc, &ThisAttrib);

    MemArrayFree(&Subnets, MemFreeFunc);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsServerDelSubnet removes a subnet from a given server. It removes not
//DOC just the subnet, but also all dependent objects like reservations etc.
//DOC This fn returns ERROR_DDS_SUBNET_NOT_PRESENT if the subnet is not found.
DWORD
DhcpDsServerDelSubnet(                            // Delete the subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create obj
    IN      LPSTORE_HANDLE         hServer,       // server obj
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 ServerName,    // name of dhcp server 2 del off
    IN      DWORD                  IpAddress      // ip address of subnet to del
)   //EndExport(function)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           fSubnetExists;
    BOOL                           fSubnetDeleted;
    LPWSTR                         SubnetCNName;
    LPWSTR                         SubnetLoc;
    DWORD                          SubnetLocType;

    if( NULL == hServer || NULL == hDhcpC )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,      // array of PEATTRIB 's
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    fSubnetExists = fSubnetDeleted = FALSE;
    for(                                          // search list of subnets
        Err = MemArrayInitLoc(&Subnets, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == IpAddress ) { // matching address?
            fSubnetExists = TRUE;
            Err2 = MemArrayDelElement(&Subnets, &Loc, &ThisAttrib);
            //= ERROR_SUCCESS == Err2 && NULL != ThisAttrib
            break;
        }
    }

    if( !fSubnetExists ) {                        // no matching subnet found
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_DDS_SUBNET_NOT_PRESENT;
    }

    Err = DhcpDsSetLists                          // now set the new attrib list
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );
    MemArrayFree(&Subnets, MemFreeFunc);          // free allocated memory
    if( ERROR_SUCCESS != Err) {                   // check err for DhcpDsSetLists
        MemFree(ThisAttrib);
        return Err;
    }

    if( IS_ADSPATH_PRESENT(ThisAttrib) ) {        // remember the location to delete
        SubnetLocType = ThisAttrib->StoreGetType;
        SubnetLoc = ThisAttrib->ADsPath;
    } else {
        SubnetLoc = NULL;
    }

    if( NULL == SubnetLoc ) {                     // Dont know location
        SubnetCNName = MakeSubnetLocation(ServerName,IpAddress);
        SubnetLoc = SubnetCNName;                 // set name for subnet obj
        SubnetLocType = StoreGetChildType;        // assume located in DhcpC container
    } else {
        SubnetCNName = NULL;                      // Did not allocate subnet name
    }

    if( NULL == SubnetLoc ) {                     // MakeSubnetLocation failed
        Err = ERROR_NOT_ENOUGH_MEMORY;
    } else {                                      // lets try to delete the subnet
        Err = ServerDeleteSubnet                  // delete the dhcp subnet object
        (
            /* hDhcpC              */ hDhcpC,
            /* ServerName          */ ServerName,
            /* hServer             */ hServer,
            /* ADsPath             */ SubnetLoc,
            /* StoreGetType        */ SubnetLocType
        );
    }

    if( SubnetCNName ) MemFree(SubnetCNName);     // if we allocated mem, free it
    MemFree(ThisAttrib);                          // lonely attrib needs to be freed

    return Err;
}

//BeginExport(function)
//DOC DhcpDsServerModifySubnet changes the subnet name, comment, state, mask
//DOC fields of the subnet.  Actually, currently, the mask should probably not
//DOC be changed, as no checks are performed in this case.  The address cannot
//DOC be changed.. If the subnet is not present, the error returned is
//DOC ERROR_DDS_SUBNET_NOT_PRESENT
DWORD
DhcpDsServerModifySubnet(                         // modify subnet info
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
)   //EndExport(function)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    BOOL                           fSubnetExists, fSubnetDeleted;

    if( NULL == hDhcpC )                          // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Info )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,      // array of PEATTRIB 's
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    fSubnetExists = fSubnetDeleted = FALSE;
    for(                                          // search list of subnets
        Err = MemArrayInitLoc(&Subnets, &Loc)     // initialize
        ; ERROR_FILE_NOT_FOUND != Err ;           // until we run out of elts
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next element
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == Info->SubnetAddress ) {
            fSubnetExists = TRUE;                 // matching address?
            break;
        }
    }

    if( !fSubnetExists ) {                        // no matching subnet found
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_DDS_SUBNET_NOT_PRESENT;
    }

    ThisAttrib->Address2 = Info->SubnetMask;      // alter information
    FLAGS1_PRESENT(ThisAttrib);
    ThisAttrib->Flags1 = Info->SubnetState;
    if( NULL == Info->SubnetName ) {
        STRING1_ABSENT(ThisAttrib);
    } else {
        STRING1_PRESENT(ThisAttrib);
        ThisAttrib->String1 = Info->SubnetName;
    }
    if( NULL == Info->SubnetComment ) {
        STRING2_ABSENT(ThisAttrib);
    } else {
        STRING2_PRESENT(ThisAttrib);
        ThisAttrib->String2 = Info->SubnetComment;
    }

    Err = DhcpDsSetLists                          // now set the new attrib list
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );
    MemArrayFree(&Subnets, MemFreeFunc);          // free allocated memory

    return Err;
}

//BeginExport(function)
//DOC DhcpDsServerEnumSubnets is not yet implemented.
DWORD
DhcpDsServerEnumSubnets(                          // get subnet list
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_IP_ARRAY       *SubnetsArray   // give array of subnets
)   //EndExport(function)
{
    LPDHCP_IP_ARRAY                LocalSubnetArray;
    DWORD                          Err, Err2, unused, Size;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;

    if( NULL == hDhcpC )                          // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == SubnetsArray )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,      // array of PEATTRIB 's
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    LocalSubnetArray = MemAlloc(sizeof(DHCP_IP_ARRAY));
    if( NULL == LocalSubnetArray ) {
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalSubnetArray->NumElements = 0;
    LocalSubnetArray->Elements = NULL;
    Size = sizeof(DHCP_IP_ADDRESS)*MemArraySize(&Subnets);
    if( Size ) LocalSubnetArray->Elements = MemAlloc(Size);

    for(                                          // accumulate the subnets
        Err = MemArrayInitLoc(&Subnets, &Loc)     // for each subnet
        ; ERROR_FILE_NOT_FOUND != Err ;           // until there are no more
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next
    ) {
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        LocalSubnetArray->Elements[LocalSubnetArray->NumElements++] = ThisAttrib->Address1;
    }

    MemArrayFree(&Subnets, MemFreeFunc);
    *SubnetsArray = LocalSubnetArray;
    return ERROR_SUCCESS;

}

//BeginExport(function)
//DOC DhcpDsServerGetSubnetInfo is not yet implemented.
DWORD
DhcpDsServerGetSubnetInfo(                        // get info on subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_IP_ADDRESS        SubnetAddress, // address of subnet to get info for
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo     // o/p: allocated info
)   //EndExport(function)
{
    DWORD                          Err, Err2, unused;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPDHCP_SUBNET_INFO             Info;
    BOOL                           fSubnetExists;

    if( NULL == hDhcpC )                          // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == SubnetInfo )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Subnets);                 //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,      // array of PEATTRIB 's
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    fSubnetExists = FALSE;
    for(                                          // accumulate the subnets
        Err = MemArrayInitLoc(&Subnets, &Loc)     // for each subnet
        ; ERROR_FILE_NOT_FOUND != Err ;           // until there are no more
        Err = MemArrayNextLoc(&Subnets, &Loc)     // skip to next
    ) {
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == SubnetAddress ) {
            fSubnetExists = TRUE;                 // found the required subnet
            break;
        }
    }

    if( !fSubnetExists ) {                        // no subnet matching address
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_DDS_SUBNET_NOT_PRESENT;
    }

    Info = MemAlloc(sizeof(LPDHCP_SUBNET_INFO));
    if( NULL == Info) {
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Info->SubnetAddress = ThisAttrib->Address1;   // subnet address
    Info->SubnetMask = ThisAttrib->Address2;      // subnet mask

    if( !IS_STRING1_PRESENT(ThisAttrib) ) {       // subnet name?
        Info->SubnetName = NULL;
    } else {
        Info->SubnetName = MemAlloc(sizeof(WCHAR) * (1+wcslen(ThisAttrib->String1)));
        if( NULL != Info->SubnetName ) {
            wcscpy(Info->SubnetName, ThisAttrib->String1);
        }
    }

    if( !IS_STRING2_PRESENT(ThisAttrib) ) {       // subnet comment?
        Info->SubnetComment = NULL;               // no subnet comment
    } else {
        Info->SubnetComment = MemAlloc(sizeof(WCHAR) * (1+wcslen(ThisAttrib->String2)));
        if( NULL != Info->SubnetComment ) {
            wcscpy(Info->SubnetComment, ThisAttrib->String2);
        }
    }

    if( !IS_FLAGS1_PRESENT(ThisAttrib) ) {        // subnet state information
        Info->SubnetState = DhcpSubnetEnabled;
    } else {
        Info->SubnetState = ThisAttrib->Flags1;
    }

    MemArrayFree(&Subnets, MemFreeFunc);          // clear up memory
    *SubnetInfo = Info;

    Info->PrimaryHost.IpAddress = 0;              // : unsupported fields..
    Info->PrimaryHost.NetBiosName = NULL;
    Info->PrimaryHost.HostName = NULL;

    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC DhcpDsSubnetAddRangeOrExcl adds a range/excl to an existing subnet.
//DOC If there is a collision with between ranges, then the error code returned
//DOC is ERROR_DDS_POSSIBLE_RANGE_CONFLICT. Note that no checks are made for
//DOC exclusions though.  Also, if a RANGE is extended via this routine, then
//DOC there is no error returned, but a limitation currently is that multiple
//DOC ranges (two only right) cannot be simultaneously extended.
//DOC BUBGUG: The basic check of whether the range belongs in the subnet is
//DOC not done..
DWORD
DhcpDsSubnetAddRangeOrExcl(                       // add a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, unused;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        Dummy;
    ARRAY                          Ranges;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hSubnet || NULL == hSubnet->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( Start > End ) return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Ranges);                  //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ &Ranges,       // array of PEATTRIB 's
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Type = (RangeOrExcl? RANGE_TYPE_RANGE: RANGE_TYPE_EXCL);
    ThisAttrib = NULL;
    if( FindCollisions(&Ranges,Start,End,Type, &ThisAttrib) ) {
        MemArrayFree(&Ranges, MemFreeFunc);
        return ERROR_DDS_POSSIBLE_RANGE_CONFLICT; // hit a range conflict!
    }

    if( NULL != ThisAttrib ) {                    // this is a collision case
        if( Start == ThisAttrib->Address2 ) {     // this is the collapse point
            ThisAttrib->Address2 = End;
        } else {
            ThisAttrib->Address1 = Start;
        }
    } else {                                      // not a collision
        NothingPresent(&Dummy);                   // create a new range
        ADDRESS1_PRESENT(&Dummy);                 // range start
        Dummy.Address1 = Start;
        ADDRESS2_PRESENT(&Dummy);                 // range end
        Dummy.Address2 = End;
        FLAGS1_PRESENT(&Dummy);
        Dummy.Flags1 = 0;
        FLAGS2_PRESENT(&Dummy);                   // range type or excl type?
        Dummy.Flags2 = Type;

        Err = MemArrayAddElement(&Ranges, &Dummy);
        if( ERROR_SUCCESS != Err ) {              // could not create new lists
            MemArrayFree(&Ranges, MemFreeFunc);
            return Err;
        }
    }

    Err = DhcpDsSetLists                          // write back new list to ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ &Ranges,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );

    if( NULL == ThisAttrib ) {                    // in case we added the new range
        Err2 = MemArrayLastLoc(&Ranges, &Loc);    // try to delete frm mem the new elt
        Err2 = MemArrayDelElement(&Ranges, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && ThisAttrib == &Dummy
    }

    MemArrayFree(&Ranges, MemFreeFunc);
    return Err;                                   // DhcpDsSetLists's ret code
}

//BeginExport(function)
//DOC DhcpDsSubnetDelRangeOrExcl deletes a range or exclusion from off the ds.
//DOC To specify range, set the RangeOrExcl parameter to TRUE.
DWORD
DhcpDsSubnetDelRangeOrExcl(                       // del a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, ThisType, unused;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ARRAY                          Ranges;
    BOOL                           Changed;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hSubnet || NULL == hSubnet->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( Start > End ) return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Ranges);                  //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ &Ranges,       // array of PEATTRIB 's
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Type = (RangeOrExcl? RANGE_TYPE_RANGE: RANGE_TYPE_EXCL);
    Changed = FALSE;

    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(&Ranges, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Ranges, &Loc)
    ) {
        Err = MemArrayGetElement(&Ranges, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( !IS_FLAGS2_PRESENT(ThisAttrib) ) {    // this is a RANGE_TYPE_RANGE
            ThisType = RANGE_TYPE_RANGE;
        } else ThisType = ThisAttrib->Flags2;

        if( Start != ThisAttrib->Address1  ||
            End != ThisAttrib->Address2 ) {       // range mismatch
            continue;
        }

        if(Type != ThisType ) {                   // looking for x, bug this is !x.
            continue;
        }

        Err2 = MemArrayDelElement(&Ranges, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib
        MemFreeFunc(ThisAttrib);
        Changed = TRUE;
    }

    if( !Changed ) {                              // nothing found ni registry
        Err = ERROR_DDS_RANGE_DOES_NOT_EXIST;
    } else {
        Err = DhcpDsSetLists                      // write back new list to ds
        (
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* hStore           */ hSubnet,
            /* SetParams        */ &unused,
            /* Servers          */ NULL,
            /* Subnets          */ NULL,
            /* IpAddress        */ NULL,
            /* Mask             */ NULL,
            /* Ranges           */ &Ranges,
            /* Sites            */ NULL,
            /* Reservations     */ NULL,
            /* SuperScopes      */ NULL,
            /* OptionDescription..  */ NULL,
            /* OptionsLocation  */ NULL,
            /* Options          */ NULL,
            /* ClassDescription */ NULL,
            /* Classes          */ NULL
        );
    }

    MemArrayFree(&Ranges, MemFreeFunc);
    return Err;                                   // DhcpDsSetLists's ret code
}

DWORD
ConvertAttribToRanges(                            // convert from array of attribs ..
    IN      DWORD                  nRanges,       // # of ranges,
    IN      PARRAY                 Ranges,        // input array of attribs
    IN      ULONG                  Type,          // TYPE_RANGE_TYPE or TYPE_EXCLUSION_TYPE?
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pRanges //output array..
)
{
    DWORD                          Err;
    ULONG                          Count, ThisType;
    PEATTRIB                       ThisAttrib;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 localRanges;
    ARRAY_LOCATION                 Loc;
    DHCP_IP_RANGE                 *ThisRange;

    localRanges = MemAlloc(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    *pRanges = localRanges;
    if( NULL == localRanges ) return ERROR_NOT_ENOUGH_MEMORY;

    if( 0 == nRanges ) {
        localRanges->NumElements = 0;
        localRanges->Elements = NULL;
        return ERROR_SUCCESS;
    }

    localRanges->Elements = MemAlloc(nRanges*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == localRanges->Elements ) {
        MemFree(localRanges);
        *pRanges = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    localRanges->NumElements = nRanges;
    for( Count = 0 ; Count < nRanges ; Count ++ ) {
        localRanges->Elements[Count].Element.IpRange =
        localRanges->Elements[Count].Element.ExcludeIpRange =
        ThisRange = MemAlloc(sizeof(DHCP_IP_RANGE));
        if( NULL == ThisRange ) {                 // oops could not allocate ? free everything and bail!
            while( Count != 0 ) {                 // remember Count is unsigned ..
                Count --;
                MemFree(localRanges->Elements[Count].Element.IpRange);
            }
            MemFree(localRanges->Elements);
            MemFree(localRanges);
            *pRanges = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Count = 0;
    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(Ranges, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(Ranges, &Loc)
    ) {
        Err = MemArrayGetElement(Ranges, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( !IS_FLAGS2_PRESENT(ThisAttrib) ) {    // this is a RANGE_TYPE_RANGE
            ThisType = RANGE_TYPE_RANGE;
        } else ThisType = ThisAttrib->Flags2;

        if(Type != ThisType ) {                   // looking for x, bug this is !x.
            continue;
        }

        //= require ThisAttrib->Address1 < ThisAttrib->Address2

        if( RANGE_TYPE_RANGE == Type ) {
            localRanges->Elements[Count].ElementType = DhcpIpRanges ;
            localRanges->Elements[Count].Element.IpRange->StartAddress = ThisAttrib->Address1;
            localRanges->Elements[Count].Element.IpRange->EndAddress = ThisAttrib->Address2;
        } else {
            localRanges->Elements[Count].ElementType =  DhcpExcludedIpRanges;
            localRanges->Elements[Count].Element.ExcludeIpRange->StartAddress = ThisAttrib->Address1;
            localRanges->Elements[Count].Element.ExcludeIpRange->EndAddress = ThisAttrib->Address2;
        }

        Count ++;
    }

    return ERROR_SUCCESS;
}


//BeginExport(function)
//DOC DhcpDsEnumRangesOrExcl is not yet implemented.
DWORD
DhcpDsEnumRangesOrExcl(                           // enum list of ranges 'n excl
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      BOOL                   RangeOrExcl,   // TRUE ==> Range, FALSE ==> Excl
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pRanges
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, ThisType, unused;
    DWORD                          Count;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ARRAY                          Ranges;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == hSubnet || NULL == hSubnet->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Ranges);                  //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ &Ranges,       // array of PEATTRIB 's
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Type = (RangeOrExcl? RANGE_TYPE_RANGE: RANGE_TYPE_EXCL);

    Count = 0;
    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(&Ranges, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Ranges, &Loc)
    ) {
        Err = MemArrayGetElement(&Ranges, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no subnet address
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no subnet mask
            continue;                             //=  ds inconsistent
        }

        if( !IS_FLAGS2_PRESENT(ThisAttrib) ) {    // this is a RANGE_TYPE_RANGE
            ThisType = RANGE_TYPE_RANGE;
        } else ThisType = ThisAttrib->Flags2;

        if(Type != ThisType ) {                   // looking for x, bug this is !x.
            continue;
        }

        Count ++;
    }

    Err = ConvertAttribToRanges(Count, &Ranges, Type, pRanges);
    MemArrayFree(&Ranges, MemFreeFunc);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsSubnetAddReservation tries to add a reservation object in the DS.
//DOC Neither the ip address not hte hw-address must exist in the DS prior to this.
//DOC If they do exist, the error returned is ERROR_DDS_RESERVATION_CONFLICT.
//DOC No checks are made on the sanity of the address in this subnet..
DWORD
DhcpDsSubnetAddReservation(                       // add a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr,  // reservation ip address to add
    IN      LPBYTE                 HwAddr,        // RAW [ethernet?] hw addr of the client
    IN      DWORD                  HwAddrLen,     // length in # of bytes of hw addr
    IN      DWORD                  ClientType     // client is BOOTP, DHCP, or both?
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, ClientUIDSize, unused;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        Dummy;
    ARRAY                          Reservations;
    LPBYTE                         ClientUID;
    LPWSTR                         ReservationCNName;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == HwAddr || 0 == HwAddrLen )
        return ERROR_INVALID_PARAMETER;

    ClientUID = NULL;
    Err = DhcpMakeClientUID(
        HwAddr,
        HwAddrLen,
        HARDWARE_TYPE_10MB_EITHERNET,
        ReservedAddr,
        &ClientUID,
        &ClientUIDSize
    );
    if( ERROR_SUCCESS != Err ) {                  // should not happen
        return Err;
    }

    Err = MemArrayInit(&Reservations);            //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) {
        MemFree(ClientUID);
        return Err;
    }

    for(                                          // search for existing reservation
        Err = MemArrayInitLoc(&Reservations, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Reservations, &Loc)
    ) {
        BOOL                           Mismatch;

        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib)      // no address for reservations
            || !IS_BINARY1_PRESENT(ThisAttrib)    // no hw len specified
            || !IS_FLAGS1_PRESENT(ThisAttrib) ) { // no client type present
            continue;                             //=  ds inconsistent
        }

        Mismatch = FALSE;
        if( ThisAttrib->Address1 == ReservedAddr ) {
            Mismatch = TRUE;                      // address already reserved
        }

        if( ThisAttrib->BinLen1 == ClientUIDSize  // see if hw address matches
            && 0 == memcmp(ThisAttrib->Binary1, ClientUID, ClientUIDSize)
        ) {
            Mismatch = TRUE;
        }

        if( Mismatch ) {                          // ip addr or hw-addr in use
            MemArrayFree(&Reservations, MemFreeFunc);
            MemFree(ClientUID);
            return ERROR_DDS_RESERVATION_CONFLICT;
        }
    }

    ReservationCNName = MakeReservationLocation(ServerName, ReservedAddr);
    if( NULL == ReservationCNName ) {             // not enough mem to create string
        Err = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Err = CreateReservationObject             // create the new reservation object
        (
            /* hDhcpC           */ hDhcpC,        // container to create obj in
            /* ReserveCNName    */ ReservationCNName
        );
    }
    if( ERROR_SUCCESS != Err ) {                  // could not create reservation object
        MemArrayFree(&Reservations, MemFreeFunc);
        MemFree(ClientUID);
        return Err;
    }

    NothingPresent(&Dummy);                       // create a new reservation
    ADDRESS1_PRESENT(&Dummy);                     // ip address
    Dummy.Address1 = ReservedAddr;
    FLAGS1_PRESENT(&Dummy);                       // client type
    Dummy.Flags1 = ClientType;
    BINARY1_PRESENT(&Dummy);                      // client uid
    Dummy.BinLen1 = ClientUIDSize;
    Dummy.Binary1 = ClientUID;
    STOREGETTYPE_PRESENT(&Dummy);                 // relative location for reservation obj
    ADSPATH_PRESENT(&Dummy);
    Dummy.StoreGetType = StoreGetChildType;
    Dummy.ADsPath = ReservationCNName;

    Err = MemArrayAddElement(&Reservations,&Dummy);
    if( ERROR_SUCCESS != Err ) {                  // oops, cannot add reservation
        MemArrayFree(&Reservations, MemFreeFunc);
        MemFree(ClientUID);
        MemFree(ReservationCNName);
        return Err;
    }

    Err = DhcpDsSetLists                          // write back new list to ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );

    Err2 = MemArrayLastLoc(&Reservations, &Loc);  // try to delete frm mem the new elt
    Err2 = MemArrayDelElement(&Reservations, &Loc, &ThisAttrib);
    //= require ERROR_SUCCESS == Err && ThisAttrib == &Dummy

    MemArrayFree(&Reservations, MemFreeFunc);
    MemFree(ClientUID);
    MemFree(ReservationCNName);
    return Err;                                   // DhcpDsSetLists's ret code
}

//BeginExport(function)
//DOC DhcpDsSubnetDelReservation deletes a reservation from the DS.
//DOC If the reservation does not exist, it returns ERROR_DDS_RESERVATION_NOT_PRESENT.
//DOC Reservations cannot be deleted by anything but ip address for now.
DWORD
DhcpDsSubnetDelReservation(                       // delete a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr   // ip address to delete reserv. by
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, ThisType, unused;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ARRAY                          Reservations;
    BOOL                           ReservationExists;
    LPWSTR                         ReservationLocPath, ReservationCNName;
    DWORD                          ReservationLocType;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Reservations);            //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    ReservationExists = FALSE;
    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(&Reservations, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Reservations, &Loc)
    ) {
        Err = MemArrayGetElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no reservation address
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // no hw addr specified
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 != ReservedAddr ) {
            continue;                             // not this reservation
        }

        ReservationExists = TRUE;
        Err2 = MemArrayDelElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib
        break;
    }

    if( !ReservationExists ) {                    // no matching reservation found
        MemArrayFree(&Reservations, MemFreeFunc);
        return ERROR_DDS_RESERVATION_NOT_PRESENT;
    }

    Err = DhcpDsSetLists                          // write back new list to ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription..  */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescription     */ NULL,
        /* Classes              */ NULL
    );
    MemArrayFree(&Reservations, MemFreeFunc);
    if( ERROR_SUCCESS != Err ) {
        MemFree(ThisAttrib);
        return Err;
    }

    if( IS_ADSPATH_PRESENT(ThisAttrib) ) {        // deleted reservation's location in ds
        ReservationLocType = ThisAttrib->StoreGetType;
        ReservationLocPath = ThisAttrib->ADsPath;
    } else {
        ReservationLocPath = NULL;
    }

    if( NULL == ReservationLocPath ) {            // no path present, but guess it anyways
        ReservationCNName = MakeReservationLocation(ServerName,ReservedAddr);
        ReservationLocPath = ReservationCNName;   // same name that is used generally
        ReservationLocType = StoreGetChildType;   // child object
    } else {
        ReservationCNName = NULL;                 // NULL indicating no alloc
    }

    if( NULL == ReservationLocPath ) {            // dont know what to delete..
        Err = ERROR_NOT_ENOUGH_MEMORY;            // MakeReservationLocation failed
    } else {                                      // try to delete subnet object
        Err = SubnetDeleteReservation             // actual delete in ds
        (
            /* hDhcpC           */ hDhcpC,
            /* ServerName       */ ServerName,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* ADsPath          */ ReservationLocPath,
            /* StoreGetType     */ ReservationLocType
        );
    }

    if( ReservationCNName ) MemFree(ReservationCNName);
    MemFree(ThisAttrib);                          // free all ptrs left..

    return Err;
}


LPBYTE _inline
DupeBytes(                                        // allocate mem and copy bytes
    IN      LPBYTE                 Data,
    IN      ULONG                  DataLen
)
{
    LPBYTE                         NewData;

    if( 0 == DataLen ) return NULL;
    NewData = MemAlloc(DataLen);
    if( NULL != NewData ) {
        memcpy(NewData, Data, DataLen);
    }
    return NewData;
}


DWORD
ConvertAttribToReservations(                      // convert from arry of attribs ..
    IN       DWORD                 nRes,          // # of reservatiosn to convert
    IN       PARRAY                Res,           // the actual array of reservations
    OUT      LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pResInfo
)
{
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 localRes;
    DWORD                          Err, Count;
    LPWSTR                         ReservationLocPath, ReservationCNName;
    DWORD                          ReservationLocType;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ARRAY                          Reservations;
    LPDHCP_IP_RESERVATION_V4       ThisRes;
    LPVOID                         Data;

    localRes = MemAlloc(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    *pResInfo = localRes;
    if( NULL == localRes ) return ERROR_NOT_ENOUGH_MEMORY;

    if( 0 == nRes ) {
        localRes->NumElements = 0;
        localRes->Elements = NULL;
        return ERROR_SUCCESS;
    }

    localRes->Elements = MemAlloc(nRes*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == localRes->Elements ) {
        MemFree(localRes);
        *pResInfo = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    localRes->NumElements = nRes;
    for( Count = 0 ; Count < nRes ; Count ++ ) {
        localRes->Elements[Count].Element.ReservedIp =
        ThisRes = MemAlloc(sizeof(DHCP_IP_RESERVATION_V4));
        if( NULL != ThisRes ) {                   // successfull allocation..
            ThisRes->ReservedForClient = MemAlloc(sizeof(DHCP_CLIENT_UID));
            if( NULL == ThisRes->ReservedForClient) {
                MemFree(ThisRes);                 // duh it failed here..
                ThisRes = NULL;                   // fake an upper level fail
            }
        }

        if( NULL == ThisRes ) {                   // oops could not allocate ? free everything and bail!
            while( Count != 0 ) {                 // remember Count is unsigned ..
                Count --;
                MemFree(localRes->Elements[Count].Element.ReservedIp->ReservedForClient);
                MemFree(localRes->Elements[Count].Element.ReservedIp);
            }
            MemFree(localRes->Elements);
            MemFree(localRes);
            *pResInfo = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Count = 0;
    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(Res, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(Res, &Loc)
    ) {
        Err = MemArrayGetElement(Res, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no reservation address
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // no hw addr specified
            continue;                             //=  ds inconsistent
        }

        localRes->Elements[Count].ElementType = DhcpReservedIps;
        if( IS_FLAGS1_PRESENT(ThisAttrib) ) {
            localRes->Elements[Count].Element.ReservedIp->bAllowedClientTypes = (BYTE)ThisAttrib->Flags1;
        } else {
            localRes->Elements[Count].Element.ReservedIp->bAllowedClientTypes = 0;
        }

        localRes->Elements[Count].Element.ReservedIp->ReservedIpAddress = ThisAttrib->Address1;
        localRes->Elements[Count].Element.ReservedIp->ReservedForClient->Data =
        Data = DupeBytes(ThisAttrib->Binary1, ThisAttrib->BinLen1);
        if( NULL == Data ) {                      // could not allocate memory..
            localRes->Elements[Count].Element.ReservedIp->ReservedForClient->DataLength = 0;
        } else {
            localRes->Elements[Count].Element.ReservedIp->ReservedForClient->DataLength = ThisAttrib->BinLen1;
        }

        Count++;
    }

    return ERROR_SUCCESS;
}


//BeginExport(function)
//DOC DhcpDsEnumReservations enumerates the reservations..
DWORD
DhcpDsEnumReservations(                           // enumerate reservations frm DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pReservations
)   //EndExport(function)
{
    DWORD                          Err, Err2, Type, ThisType, unused;
    DWORD                          Count;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ARRAY                          Reservations;

    if( NULL == hDhcpC || NULL == hServer )       // check params
        return ERROR_INVALID_PARAMETER;
    if( NULL == hServer->ADSIHandle || NULL == hDhcpC->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == ServerName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;

    Err = MemArrayInit(&Reservations);            //= require ERROR_SUCCESS == Err
    Err = DhcpDsGetLists                          // get list of ranges frm ds
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Reservations,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    Count = 0;
    for(                                          // look for matching range/excl
        Err = MemArrayInitLoc(&Reservations, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Reservations, &Loc)
    ) {
        Err = MemArrayGetElement(&Reservations, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no reservation address
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // no hw addr specified
            continue;                             //=  ds inconsistent
        }

    }

    Err = ConvertAttribToReservations(Count, &Reservations, pReservations);

    MemArrayFree(&Reservations, MemFreeFunc);
    return Err;
}

//BeginExport(function)
//DOC DhcpDsEnumSubnetElements enumerates the list of subnet elements in a
//DOC subnet... such as IpRanges, Exclusions, Reservations..
//DOC
DWORD
DhcpDsEnumSubnetElements(
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_SUBNET_ELEMENT_TYPE ElementType, // what kind of elt to enum?
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *ElementInfo
)   //EndExport(function)
{
    DWORD                          Err;

    switch(ElementType) {
    case DhcpIpRanges:
        Err = DhcpDsEnumRangesOrExcl(
            hDhcpC,
            hServer,
            hSubnet,
            Reserved,
            ServerName,
            TRUE,
            ElementInfo
        );
        break;
    case DhcpExcludedIpRanges:
        Err = DhcpDsEnumRangesOrExcl(
            hDhcpC,
            hServer,
            hSubnet,
            Reserved,
            ServerName,
            FALSE,
            ElementInfo
        );
        break;
    case DhcpReservedIps:
        Err = DhcpDsEnumReservations(
            hDhcpC,
            hServer,
            hSubnet,
            Reserved,
            ServerName,
            ElementInfo
        );
        break;
    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    return Err;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\dhcpread.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpDsGetServers(
    IN OUT  LPSTORE_HANDLE         hContainer,    // the container handle
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,    // OPTIONAL, NULL ==> All servers
    IN OUT  PARRAY                 Servers        // fill in this array with PM_SERVER types
) ;


DWORD
DhcpDsGetEnterpriseServers(                       // get the dhcp servers for the current enterprise
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,
    IN OUT  PARRAY                 Servers
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcapi1.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC DhcpDsCreateOptionDef tries to create an option definition in the DS with the
//DOC given attributes.  The option must not exist in the DS prior to this call.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsCreateOptionDef(                            // create option definition
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 Name,          // option name
    IN      LPWSTR                 Comment,       // OPTIONAL option comment
    IN      LPWSTR                 ClassName,     // OPTIONAL unused, opt class
    IN      DWORD                  OptId,         // # between 0-255 per DHCP draft
    IN      DWORD                  OptType,       // some option flags
    IN      LPBYTE                 OptVal,        // default option value
    IN      DWORD                  OptLen         // # of bytes of above
) ;


//DOC DhcpDsModifyOptionDef tries to modify an existing optdef in the DS with the
//DOC given attributes.  The option must exist in the DS prior to this call.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsModifyOptionDef(                            // modify option definition
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 Name,          // option name
    IN      LPWSTR                 Comment,       // OPTIONAL option comment
    IN      LPWSTR                 ClassName,     // OPTIONAL unused, opt class
    IN      DWORD                  OptId,         // # between 0-255 per DHCP draft
    IN      DWORD                  OptType,       // some option flags
    IN      LPBYTE                 OptVal,        // default option value
    IN      DWORD                  OptLen         // # of bytes of above
) ;


//DOC DhcpDsEnumOptionDefs gets the list of options defined for the given class.
//DOC Currently, class is ignored as option defs dont have classes associated.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsEnumOptionDefs(                             // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      BOOL                   IsVendor,      // vendor only? non-vendor only?
    OUT     LPDHCP_OPTION_ARRAY   *RetOptArray    // allocated and fill this.
) ;


//DOC DhcpDsDeleteOptionDef deletes an option definition in the DS based on the option id.
//DOC Note that the ClassName field is currently ignored.
//DOC No error is reported if the option is not present in the DS.
//DOC
DWORD
DhcpDsDeleteOptionDef(                            // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      DWORD                  OptId
) ;


//DOC DhcpDsDeleteOptionDef deletes an option definition in the DS based on the option id.
//DOC Note that the ClassName field is currently ignored.
//DOC No error is reported if the option is not present in the DS.
//DOC
DWORD
DhcpDsGetOptionDef(                            // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      DWORD                  OptId,
    OUT     LPDHCP_OPTION         *OptInfo
) ;


//DOC DhcpDsSetOptionValue sets the required option value in the DS.
//DOC Note that if the option existed earlier, it is overwritten. Also, the
//DOC option definition is not checked against -- so there need not be an
//DOC option type specified.
//DOC Also, this function works assuming that the option has to be written
//DOC to the current object in DS as given by hObject ptr.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsSetOptionValue(                             // set option value
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // name of user class for this opt
    IN      DWORD                  OptId,         // option id
    IN      LPDHCP_OPTION_DATA     OptData        // what is the option
) ;


//DOC DhcpDsRemoveOptionValue deletes the required option value from DS
//DOC the specific option value should exist in DS, else error.
//DOC Also, this function works assuming that the option has been written
//DOC to the current object in DS as given by hObject ptr.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsRemoveOptionValue(                          // remove option value
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // user class for opt
    IN      DWORD                  OptId          // option id
) ;


//DOC DhcpDsGetOptionValue retrieves the particular option value in question.
//DOC This function returns ERROR_DDS_OPTION_DOES_NOT_EXIST if the option was
//DOC not found.
DWORD
DhcpDsGetOptionValue(                             // get option value frm DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // user class this opt belongs 2
    IN      DWORD                  OptId,         // option id
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate and fill this ptr
) ;


//DOC DhcpDsEnumOptionValues enumerates the list of options for a given class
//DOC Also, depending on whether IsVendor is TRUE or false, this function enumerates
//DOC only vendor specific or only non-vendor-specific options respectively.
//DOC This function gets the whole bunch in one shot.
DWORD
DhcpDsEnumOptionValues(                           // get option values  from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // for which user class?
    IN      DWORD                  IsVendor,      // enum only vendor/non-vendor?
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues // allocate option values..
) ;


//DOC DhcpDsCreateClass creates a given class in the DS. The class should not
//DOC exist prior to this in the DS (if it does, this fn returns error
//DOC ERROR_DDS_CLASS_EXISTS).
DWORD
DhcpDsCreateClass(                                // create this class in the ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class..
    IN      LPWSTR                 ClassComment,  // comment for this class
    IN      LPBYTE                 ClassData,     // the bytes that form the class data
    IN      DWORD                  ClassDataLen,  // # of bytes of above
    IN      BOOL                   IsVendor       // is this a vendor class?
) ;


//DOC DhcpDsDeleteClass deletes the class from off the DS, and returns an error
//DOC if the class did not exist in the DS for hte given server object.
DWORD
DhcpDsDeleteClass(                                // delete the class from the ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName      // name of class..
) ;


//DOC this is not yet implemented.
DWORD
DhcpDsModifyClass(                                // modify a class in the DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class -- this is the key
    IN      LPWSTR                 ClassComment,  // comment for this class
    IN      LPBYTE                 ClassData,     // the bytes that form the class data
    IN      DWORD                  ClassDataLen   // # of bytes of above
) ;


//DOC DhcpDsGetClassInfo get information on a class by doing a search based
//DOC on either the class name or the class data fields.  ClassName is guaranteed
//DOC to be unique. ClassData may/maynot be unique.  The search is done in the DS,
//DOC so things are likely to be a lot slower than they should be.
//DOC This should be fixed by doing some intelligent searches.
//DOC Note that the hServer and the hDhcpC handles should point to the right objects.
//DOC
DWORD
DhcpDsGetClassInfo(                               // get class details for given class
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL search on class name
    IN      LPBYTE                 ClassData,     // OPTIONAL srch on class data
    IN      DWORD                  ClassDataLen,  // # of bytes of ClassData
    OUT     LPDHCP_CLASS_INFO     *ClassInfo      // allocate and copy ptr
) ;


//DOC DhcpDsEnumClasses enumerates the classes for a given server (as specified
//DOC via the hServer object.)
//DOC The memory for Classes is allocated by this function.
DWORD
DhcpDsEnumClasses(                                // get the list of classes frm ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    OUT     LPDHCP_CLASS_INFO_ARRAY *Classes      // allocate memory for this
) ;


//DOC This function retrieves all the option valuesdefined for this object frm th dS
DWORD
DhcpDsGetAllOptionValues(
    IN      LPSTORE_HANDLE         hDhcpC,
    IN      LPSTORE_HANDLE         hObject,
    IN      DWORD                  Reserved,
    OUT     LPDHCP_ALL_OPTION_VALUES *OptionValues
) ;


//DOC This function retrieves all the optiosn defined for this server.. frm the DS
DWORD
DhcpDsGetAllOptions(
    IN      LPSTORE_HANDLE         hDhcpC,
    IN      LPSTORE_HANDLE         hServer,
    IN      DWORD                  Reserved,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcapi1.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: most of the rpc apis are here and some miscellaneous functions too
//  all the functions here go to the DS directly.
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>

//================================================================================
//   THE FOLLOWING FUNCTIONS HAVE BEEN COPIED OVER FROM RPCAPI1.C (IN THE
//   DHCP\SERVER\SERVER DIRECTORY).
//================================================================================
#undef   DhcpPrint
#define  DhcpPrint(X)
#define  DhcpAssert(X)

typedef  struct _OPTION_BIN {
    DWORD                          DataSize;
    DHCP_OPTION_DATA_TYPE          OptionType;
    DWORD                          NumElements;
    BYTE                           Data[0];
} OPTION_BIN, *LPOPTION_BIN;

#define IS_SPACE_AVAILABLE(FilledSize, AvailableSize, RequiredSpace )   ((FilledSize) + (RequiredSpace) <= (AvailableSize) )

BOOL        _inline
CheckForVendor(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return (256 <= OptId);
    return 256 > OptId;
}

DWORD       _inline
ConvertOptIdToRPCValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendorUnused
)
{
    return OptId % 256;
}

DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}

DWORD
DhcpConvertOptionRPCToRegFormat(
    IN      LPDHCP_OPTION_DATA     Option,
    IN OUT  LPBYTE                 RegBuffer,     // OPTIONAL
    IN OUT  DWORD                 *BufferSize     // input: buffer size, output: filled buffer size
)
{
    OPTION_BIN                     Dummy;
    DWORD                          AvailableSize;
    DWORD                          FilledSize;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          DataLength;
    DWORD                          Length;
    DHCP_OPTION_DATA_TYPE          OptType;
    LPBYTE                         BufStart;

    AvailableSize = *BufferSize;
    FilledSize = 0;
    BufStart = RegBuffer;

    Dummy.DataSize = sizeof(Dummy);
    Dummy.OptionType = DhcpByteOption;
    Dummy.NumElements = 0;
    FilledSize = ROUND_UP_COUNT(sizeof(Dummy), ALIGN_WORST);

    RegBuffer += FilledSize;                      // will do this actual filling at the very end

    if( NULL == Option || 0 == Option->NumElements ) {
        OptType = DhcpByteOption;
        nElements =0;
    } else {
        OptType = Option->Elements[0].OptionType;
        nElements = Option->NumElements;
    }

    for( i = 0; i < nElements ; i ++ ) {          // marshal each argument in
        if( OptType != Option->Elements[i].OptionType ) {
            return ERROR_INVALID_PARAMETER;       // do not allow random option types, all got to be same
        }

        switch(OptType) {
        case DhcpByteOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.ByteOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.WordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD) )) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.DWordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD_DWORD)) ) {
                *((LPDWORD_DWORD)RegBuffer) = Option->Elements[i].Element.DWordDWordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD_DWORD);
            break;
        case DhcpIpAddressOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DHCP_IP_ADDRESS)) ) {
                *((LPDHCP_IP_ADDRESS)RegBuffer) = Option->Elements[i].Element.IpAddressOption;
                RegBuffer += sizeof(DHCP_IP_ADDRESS);
            }
            FilledSize += sizeof(DHCP_IP_ADDRESS);
            break;
        case DhcpStringDataOption:
            if( NULL == Option->Elements[i].Element.StringDataOption ) {
                DataLength = ROUND_UP_COUNT((FilledSize + sizeof(DWORD) + sizeof(WCHAR)), ALIGN_DWORD);
                DataLength -= FilledSize;
                if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength ) ) {
                    *(LPDWORD)RegBuffer = (DWORD) sizeof(WCHAR);
                    RegBuffer += sizeof(DWORD);
                    *(LPWSTR)RegBuffer = L'\0';
                    RegBuffer += ROUND_UP_COUNT(sizeof(WCHAR), ALIGN_DWORD);
                    DhcpAssert(sizeof(DWORD) + ROUND_UP_COUNT(sizeof(WCHAR),ALIGN_DWORD) == DataLength);
                }
                FilledSize += DataLength;
                break;
            }

            Length = (1+wcslen(Option->Elements[i].Element.StringDataOption))*sizeof(WCHAR);
            DataLength = ROUND_UP_COUNT((Length + FilledSize + sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.StringDataOption, Length );
                RegBuffer += ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(ROUND_UP_COUNT(Length,ALIGN_DWORD) + sizeof(DWORD) == DataLength);
            }
            FilledSize += DataLength;
            break;
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            Length = Option->Elements[i].Element.BinaryDataOption.DataLength;
            DataLength = ROUND_UP_COUNT((FilledSize+Length+sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.BinaryDataOption.Data, Length);
                Length = ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(Length + sizeof(DWORD) == DataLength);
                RegBuffer += Length;
            }
            FilledSize += DataLength;
            break;
        default:
            return ERROR_INVALID_PARAMETER;       // Dont support any other kind of options
        }
    }
    // Length = ROUND_UP_COUNT(FilledSize, ALIGN_WORST);
    *BufferSize = FilledSize;
    if( AvailableSize < FilledSize ) return ERROR_MORE_DATA;

    Dummy.NumElements = nElements;
    Dummy.DataSize = *BufferSize;
    Dummy.OptionType = OptType;
    memcpy(BufStart, (LPBYTE)&Dummy, sizeof(Dummy));
    return ERROR_SUCCESS;
}


//================================================================================
//  helper routines for ds..
//================================================================================

VOID        static
MemFreeFunc(
    IN OUT  LPVOID                 Memory
)
{
    MemFree(Memory);
}

//DOC DhcpConvertOptionRegToRPCFormat2 converts from the registry format option
//DOC to the RPC format. Additionally, it packs the whole stuff in one buffer.
//DOC If the Option buffer size (in bytes) as specified for input, is insufficient
//DOC to hold all the data, then, the function returns ERROR_MORE_DATA and sets
//DOC the same Size parameter to hold the actual # of bytes space required.
//DOC On a successful conversion, Size holds the total # of bytes copied.
//DOC Most of the code is same as for DhcpConvertOptionRegToRPCFormat
//DOC
DWORD
DhcpConvertOptionRegToRPCFormat2(                 // convert from Reg fmt to RPC..
    IN      LPBYTE                 Buffer,        // reg fmt option buffer
    IN      DWORD                  BufferSize,    // size of above in bytes
    IN OUT  LPDHCP_OPTION_DATA     Option,        // where to fill the option data
    IN OUT  LPBYTE                 OptBuf,        // buffer for internal option data..
    IN OUT  DWORD                 *Size           // i/p: sizeof(Option) o/p: reqd size
)
{
    LPOPTION_BIN                   OptBin;
    LPBYTE                         OptData;
    LPBYTE                         DataBuffer;
    DWORD                          OptSize;
    DWORD                          OptType;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          NetworkULong;
    DWORD                          DataLength;
    DWORD                          FilledSize;
    DWORD                          AvailableSize;
    WORD                           NetworkUShort;
    LPDHCP_OPTION_DATA_ELEMENT     Elements;

    if( !Buffer || !BufferSize || !Size ) return ERROR_INVALID_PARAMETER;
    AvailableSize = *Size;
    FilledSize = *Size = 0;

    OptBin = (LPOPTION_BIN)Buffer;

    if(OptBin->DataSize != BufferSize) {          // internal error!
        DhcpPrint((DEBUG_ERRORS, "Internal error while parsing options\n"));
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    OptType = OptBin->OptionType;                 // copy highly used stuff
    nElements = OptBin->NumElements;
    OptData = OptBin->Data;
    OptData = ROUND_UP_COUNT(sizeof(OPTION_BIN), ALIGN_WORST) + (LPBYTE)OptBin;

    if( Option ) {
        Option->NumElements = 0;
        Option->Elements = NULL;
    }

    if( 0 == nElements ) {
        return ERROR_SUCCESS;
    }

    Elements = (LPVOID)OptBuf;
    FilledSize += nElements * ROUND_UP_COUNT(sizeof(DHCP_OPTION_DATA_ELEMENT), ALIGN_WORST);
    if( !IS_SPACE_AVAILABLE(FilledSize, AvailableSize, 0 ) ) {
        Elements = NULL;                          // not enough space is really available..
    }

    for(i = 0; i < nElements ; i ++ ) {           // marshal the elements in the data buffer
        if( Elements ) {                          // copy only when space is there
            Elements[i].OptionType = OptType;
        }

        switch( OptType ) {                       // each type has diff fields to look at
        case DhcpByteOption:
            if( Elements ) {
                Elements[i].Element.ByteOption = *((LPBYTE)OptData);
            }
            OptData += sizeof(DWORD);
            break;
        case DhcpWordOption:
            if( Elements ) {
                Elements[i].Element.WordOption = (WORD)(*((LPDWORD)OptData));
            }
            OptData += sizeof(DWORD);
            break;
        case DhcpDWordOption:
            if( Elements ) {
                Elements[i].Element.DWordOption = *((LPDWORD)OptData);
            }
            OptData += sizeof(DWORD);
            break;
        case DhcpDWordDWordOption:
            if( Elements ) {
                Elements[i].Element.DWordDWordOption = *((LPDWORD_DWORD)OptData);
            }
            OptData += sizeof(DWORD_DWORD);
            break;
        case DhcpIpAddressOption:
            if( Elements ) {
                Elements[i].Element.IpAddressOption = *((LPDHCP_IP_ADDRESS)OptData);
            }
            OptData += sizeof(DHCP_IP_ADDRESS);
            break;
        case DhcpStringDataOption:
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            DataLength = *((LPWORD)OptData);
            OptData += sizeof(DWORD);

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                DataBuffer = (LPVOID)(FilledSize + OptBuf);
            } else {
                DataBuffer = NULL;
            }

            FilledSize += DataLength;

            if( DataBuffer ) {
                RtlCopyMemory( DataBuffer, OptData, DataLength );
            }
            OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);

            if( Elements ) {
                if( OptType == DhcpStringDataOption ) {
                    Elements[i].Element.StringDataOption = (LPWSTR)DataBuffer;
                } else {
                    Elements[i].Element.BinaryDataOption.DataLength = DataLength;
                    Elements[i].Element.BinaryDataOption.Data = DataBuffer;
                }
            }

            DhcpAssert( i == 0 );                 // should not be more than one binary element specified
            if( i > 0 ) {
                DhcpPrint(( DEBUG_OPTIONS, "Multiple Binary option packed\n"));
            }
            break;
        default:
            DhcpPrint(( DEBUG_OPTIONS, "Unknown option found\n"));
            break;
        }
    }

    if( Option ) {
        Option->NumElements = i;                  // nElements maybe?
        Option->Elements = Elements;
    }

    *Size = FilledSize;

    if( FilledSize <= AvailableSize ) return ERROR_SUCCESS;
    return ERROR_MORE_DATA;                       // did not copy everything actually.
}

//================================================================================
//  DS Access Routines
//================================================================================

//BeginExport(function)
//DOC DhcpDsCreateOptionDef tries to create an option definition in the DS with the
//DOC given attributes.  The option must not exist in the DS prior to this call.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsCreateOptionDef(                            // create option definition
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 Name,          // option name
    IN      LPWSTR                 Comment,       // OPTIONAL option comment
    IN      LPWSTR                 ClassName,     // OPTIONAL unused, opt class
    IN      DWORD                  OptId,         // # between 0-255 per DHCP draft
    IN      DWORD                  OptType,       // some option flags
    IN      LPBYTE                 OptVal,        // default option value
    IN      DWORD                  OptLen         // # of bytes of above
) //EndExport(function)
{
    DWORD                          Result, unused;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;

    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
                continue;                         // mismatch
            }

            if( ClassName ) {                     // need to check class name
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ThisAttrib->String3, ClassName) ) continue;
            }

            Result = ERROR_DDS_OPTION_ALREADY_EXISTS;
            goto Cleanup;
        }
    }

    NothingPresent(&DummyAttrib);                 // prepare an elt to add to list
    STRING1_PRESENT(&DummyAttrib);
    if( Comment ) STRING2_PRESENT(&DummyAttrib);
    if( ClassName ) STRING3_PRESENT(&DummyAttrib);
    DWORD1_PRESENT(&DummyAttrib);
    BINARY1_PRESENT(&DummyAttrib);
    FLAGS1_PRESENT(&DummyAttrib);

    DummyAttrib.String1 = Name;                   // fill in reqd fields only
    if( Comment ) DummyAttrib.String2 = Comment;
    if( ClassName ) DummyAttrib.String3 = ClassName;
    DummyAttrib.Dword1 = OptId;
    DummyAttrib.Flags1 = OptType;
    DummyAttrib.Binary1 = OptVal;
    DummyAttrib.BinLen1 = OptLen;

    Result = MemArrayAddElement(&OptDefAttribs, &DummyAttrib);
    if( ERROR_SUCCESS != Result ) goto Cleanup;   // Add dummy element to list

    Result = DhcpDsSetLists(                      // set the new list in DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    (void)MemArrayLastLoc(&OptDefAttribs, &Loc);  // clear up list to way it was
    //- ERROR_SUCCESS == Result
    (void)MemArrayDelElement(&OptDefAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result && ThisAttrib == &DummyAttrib

  Cleanup:                                        // free up any memory used

    (void)MemArrayFree(&OptDefAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsModifyOptionDef tries to modify an existing optdef in the DS with the
//DOC given attributes.  The option must exist in the DS prior to this call.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsModifyOptionDef(                            // modify option definition
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 Name,          // option name
    IN      LPWSTR                 Comment,       // OPTIONAL option comment
    IN      LPWSTR                 ClassName,     // OPTIONAL unused, opt class
    IN      DWORD                  OptId,         // # between 0-255 per DHCP draft
    IN      DWORD                  OptType,       // some option flags
    IN      LPBYTE                 OptVal,        // default option value
    IN      DWORD                  OptLen         // # of bytes of above
) //EndExport(function)
{
    DWORD                          Result, unused;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;

    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
                continue;                         // mismatch
            }

            if( ClassName ) {                     // need to check class name
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ThisAttrib->String3, ClassName) ) continue;
            }

            Result = MemArrayDelElement(&OptDefAttribs, &Loc, &ThisAttrib);
            //- ERROR_SUCCESS == Result
            MemFreeFunc(ThisAttrib);
            Result = ERROR_SUCCESS;
            break;
        }
    }

    if( ERROR_SUCCESS != Result ) {               // option def was not found
        Result = ERROR_DDS_OPTION_DOES_NOT_EXIST;
    }

    NothingPresent(&DummyAttrib);                 // prepare an elt to add to list
    STRING1_PRESENT(&DummyAttrib);
    if( Comment ) STRING2_PRESENT(&DummyAttrib);
    if( ClassName ) STRING3_PRESENT(&DummyAttrib);
    DWORD1_PRESENT(&DummyAttrib);
    BINARY1_PRESENT(&DummyAttrib);
    FLAGS1_PRESENT(&DummyAttrib);

    DummyAttrib.String1 = Name;                   // fill in reqd fields only
    if( Comment ) DummyAttrib.String2 = Comment;
    if( ClassName )DummyAttrib.String3 = ClassName;
    DummyAttrib.Dword1 = OptId;
    DummyAttrib.Flags1 = OptType;
    DummyAttrib.Binary1 = OptVal;
    DummyAttrib.BinLen1 = OptLen;

    Result = MemArrayAddElement(&OptDefAttribs, &DummyAttrib);
    if( ERROR_SUCCESS != Result ) goto Cleanup;   // Add dummy element to list

    Result = DhcpDsSetLists(                      // set the new list in DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    (void)MemArrayLastLoc(&OptDefAttribs, &Loc);  // clear up list to way it was
    //- ERROR_SUCCESS == Result
    (void)MemArrayDelElement(&OptDefAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result && ThisAttrib == &DummyAttrib

  Cleanup:                                        // free up any memory used

    (void)MemArrayFree(&OptDefAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsEnumOptionDefs gets the list of options defined for the given class.
//DOC Currently, class is ignored as option defs dont have classes associated.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsEnumOptionDefs(                             // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      BOOL                   IsVendor,      // vendor only? non-vendor only?
    OUT     LPDHCP_OPTION_ARRAY   *RetOptArray    // allocated and fill this.
) //EndExport(function)
{
    DWORD                          Result, Result2, unused, Size, Size2, i, AllocSize;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_ARRAY            OptArray;
    LPBYTE                         Ptr;

    *RetOptArray = NULL;
    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Size = i = 0;                                 // calculate size
    Size += ROUND_UP_COUNT(sizeof(DHCP_OPTION_ARRAY), ALIGN_WORST);

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib)
            || !IS_DWORD1_PRESENT(ThisAttrib) ) { // invalid attrib
            continue;                             // skip it
        }

        if( !CheckForVendor(ThisAttrib->Dword1, IsVendor) ) {
            continue;                             // separate vendor and non-vendor
        }

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( ClassName ) {                         // need to have matching class
            if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
        }

        Size2 = 0;
        Result2 = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer           */ ThisAttrib->Binary1,
            /* BufferSize       */ ThisAttrib->BinLen1,
            /* Option           */ NULL,          // will allocate this later
            /* OptBuf           */ NULL,
            /* Size             */ &Size2
        );
        if( ERROR_MORE_DATA == Result2 ) Result2 = ERROR_SUCCESS;
        if( ERROR_SUCCESS != Result2 ) continue;  // errors? skip this attrib

        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        Size2 = sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        if( IS_STRING2_PRESENT(ThisAttrib) ) {    // if comment is present..
            Size2 += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String2));
        }
        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);

        i ++;
    }

    Size += ROUND_UP_COUNT(i* sizeof(DHCP_OPTION), ALIGN_WORST);

    Ptr = MemAlloc(AllocSize = Size);
    OptArray = (LPVOID)Ptr;
    if( NULL == OptArray ) return ERROR_NOT_ENOUGH_MEMORY;

    Size = 0;                                     // this time, fill in the values
    Size += ROUND_UP_COUNT(sizeof(DHCP_OPTION_ARRAY), ALIGN_WORST);
    Ptr += Size;
    OptArray->NumElements = i;
    OptArray->Options = (LPVOID)Ptr;
    Size += ROUND_UP_COUNT(i* sizeof(DHCP_OPTION), ALIGN_WORST);
    Ptr  += ROUND_UP_COUNT(i* sizeof(DHCP_OPTION), ALIGN_WORST);

    i = 0;
    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib)
            || !IS_DWORD1_PRESENT(ThisAttrib) ) { // invalid attrib
            continue;                             // skip it
        }

        if( !CheckForVendor(ThisAttrib->Dword1, IsVendor) ) {
            continue;                             // separate vendor and non-vendor
        }

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( ClassName ) {                         // need to have matching class
            if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
        }

        Size2 = AllocSize - Size;
        Result2 = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer           */ ThisAttrib->Binary1,
            /* BufferSize       */ ThisAttrib->BinLen1,
            /* Option           */ &OptArray->Options[i].DefaultValue,
            /* OptBuf           */ Ptr,
            /* Size             */ &Size2
        );
        //- ERROR_MORE_DATA != Result2
        if( ERROR_SUCCESS != Result2 ) continue;  // errors? skip this attrib

        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        Ptr  += ROUND_UP_COUNT(Size2, ALIGN_WORST);

        OptArray->Options[i].OptionID = ConvertOptIdToRPCValue(ThisAttrib->Dword1, TRUE);
        if( IS_FLAGS1_PRESENT(ThisAttrib) ) {     // if some flags present
            OptArray->Options[i].OptionType = ThisAttrib->Flags1;
        } else {                                  // if no flags present, assume 0 type
            OptArray->Options[i].OptionType = 0;
        }

        OptArray->Options[i].OptionName = (LPVOID)Ptr;
        wcscpy((LPWSTR)Ptr, ThisAttrib->String1);
        Ptr += sizeof(WCHAR)*(1+wcslen((LPWSTR)Ptr));

        Size2 = sizeof(WCHAR)*(1+wcslen(ThisAttrib->String1));
        if( IS_STRING2_PRESENT(ThisAttrib) ) {    // if comment is present..
            Size2 += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String2));
            OptArray->Options[i].OptionComment = (LPVOID)Ptr;
            wcscpy((LPWSTR)Ptr, ThisAttrib->String2);
        } else {
            OptArray->Options[i].OptionComment = NULL;
        }

        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        Ptr = ROUND_UP_COUNT(Size2, ALIGN_WORST) + (LPBYTE)(OptArray->Options[i].OptionName);

        i ++;
    }

    //- OptArray->NumElements == i
    *RetOptArray = OptArray;
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC DhcpDsDeleteOptionDef deletes an option definition in the DS based on the option id.
//DOC Note that the ClassName field is currently ignored.
//DOC No error is reported if the option is not present in the DS.
//DOC
DWORD
DhcpDsDeleteOptionDef(                            // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      DWORD                  OptId
) //EndExport(function)
{
    DWORD                          Result, Result2, unused;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;

    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( ClassName ) {                     // need to have matching class
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
            }

            Result = MemArrayDelElement(&OptDefAttribs, &Loc, &ThisAttrib);
            //- ERROR_SUCCESS == Result
            MemFreeFunc(ThisAttrib);
            Result = ERROR_SUCCESS;
            break;
        }
    }

    if( ERROR_SUCCESS != Result ) {               // could not find the option in DS
        Result = ERROR_SUCCESS;                   // pretend everything was fine
    } else {
        Result = DhcpDsSetLists(                  // set the new list in DS
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* hStore               */ hServer,
            /* SetParams            */ &unused,
            /* Servers              */ NULL,
            /* Subnets              */ NULL,
            /* IpAddress            */ NULL,
            /* Mask                 */ NULL,
            /* Ranges               */ NULL,
            /* Sites                */ NULL,
            /* Reservations         */ NULL,
            /* SuperScopes          */ NULL,
            /* OptionDescripti..    */ &OptDefAttribs,
            /* OptionsLocation      */ NULL,
            /* Options              */ NULL,
            /* ClassDescriptio..    */ NULL,
            /* Classes              */ NULL
        );
    }

    (void) MemArrayFree(&OptDefAttribs, MemFreeFunc);

    return Result;
}

//BeginExport(function)
//DOC DhcpDsDeleteOptionDef deletes an option definition in the DS based on the option id.
//DOC Note that the ClassName field is currently ignored.
//DOC No error is reported if the option is not present in the DS.
//DOC
DWORD
DhcpDsGetOptionDef(                            // enum list of opt defs in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL, unused.
    IN      DWORD                  OptId,
    OUT     LPDHCP_OPTION         *OptInfo
) //EndExport(function)
{
    DWORD                          Result, Result2, unused;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;

    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            // invalid attributes?
            continue;
        }

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( ClassName ) {                     // need to have matching class
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
            }

            Result = ERROR_SUCCESS;
            break;
        }
    }

    if( ERROR_SUCCESS == Result ) do {
        ULONG                      Size, Size2;
        LPBYTE                     Ptr;

        Size2 = Size = 0;
        Result = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer           */ ThisAttrib->Binary1,
            /* BufferSize       */ ThisAttrib->BinLen1,
            /* Option           */ NULL,          // will allocate this later
            /* OptBuf           */ NULL,
            /* Size             */ &Size2
        );
        if( ERROR_MORE_DATA == Result ) Result = ERROR_SUCCESS;
        if( ERROR_SUCCESS != Result ) break;   // errors? skip this attrib

        Size = ROUND_UP_COUNT(sizeof(DHCP_OPTION), ALIGN_WORST);
        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String1));
        if( IS_STRING2_PRESENT(ThisAttrib) ) {
            Size += sizeof(WCHAR)*(1 + wcslen(ThisAttrib->String2));
        }

        (*OptInfo) = (LPVOID)Ptr = MemAlloc(Size);
        if( NULL == *OptInfo ) { Result = ERROR_NOT_ENOUGH_MEMORY ; break; }
        Ptr += ROUND_UP_COUNT(sizeof(DHCP_OPTION), ALIGN_WORST);
        (*OptInfo)->OptionID = ConvertOptIdToRPCValue(ThisAttrib->Dword1, TRUE);
        if( IS_FLAGS1_PRESENT(ThisAttrib) ) (*OptInfo)->OptionType = ThisAttrib->Flags1;
        else (*OptInfo)->OptionType = 0;

        Size2 = Size - ROUND_UP_COUNT(sizeof(DHCP_OPTION), ALIGN_WORST);
        Result = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer           */ ThisAttrib->Binary1,
            /* BufferSize       */ ThisAttrib->BinLen1,
            /* Option           */ &((*OptInfo)->DefaultValue),
            /* OptBuf           */ Ptr,
            /* Size             */ &Size2
        );
        Ptr += Size2;
        (*OptInfo)->OptionName = (LPVOID)Ptr; wcscpy((LPWSTR)Ptr, ThisAttrib->String1);
        if( !IS_STRING2_PRESENT(ThisAttrib) ) (*OptInfo)->OptionComment = NULL;
        else {
            Ptr += sizeof(WCHAR)*(1+ wcslen(ThisAttrib->String1));
            (*OptInfo)->OptionComment = (LPVOID)Ptr;
            wcscpy((LPWSTR)Ptr, ThisAttrib->String2);
        }

        Result = ERROR_SUCCESS;
    } while(0);

    (void) MemArrayFree(&OptDefAttribs, MemFreeFunc);

    return Result;
}

//BeginExport(function)
//DOC DhcpDsSetOptionValue sets the required option value in the DS.
//DOC Note that if the option existed earlier, it is overwritten. Also, the
//DOC option definition is not checked against -- so there need not be an
//DOC option type specified.
//DOC Also, this function works assuming that the option has to be written
//DOC to the current object in DS as given by hObject ptr.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsSetOptionValue(                             // set option value
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // name of user class for this opt
    IN      DWORD                  OptId,         // option id
    IN      LPDHCP_OPTION_DATA     OptData        // what is the option
) //EndExport(function)
{
    DWORD                          Result, Result2, unused, ValueSize;
    ARRAY                          OptAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;
    LPBYTE                         Value;

    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for option w/ <OptId>
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( NULL == UserClass && IS_STRING4_PRESENT(ThisAttrib) ) {
            continue;                             // user class mismatch
        }

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( ClassName ) {                     // need to have matching class
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
            }
            if( UserClass ) {                     // need to 've matchin user class
                if( !IS_STRING4_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(UserClass, ThisAttrib->String4) ) continue;
            }

            Result = MemArrayDelElement(&OptAttribs, &Loc, &ThisAttrib);
            //- ERROR_SUCCESS == Result
            MemFreeFunc(ThisAttrib);
            break;
        }
    }

    NothingPresent(&DummyAttrib);                 // prepare an elt to add to list
    // STRING1_PRESENT(&DummyAttrib);             // No name or comment
    // if( Comment ) STRING2_PRESENT(&DummyAttrib);
    if( ClassName ) STRING3_PRESENT(&DummyAttrib);// class name?
    if( UserClass ) STRING4_PRESENT(&DummyAttrib);// user class?
    DWORD1_PRESENT(&DummyAttrib);                 // this is option id
    BINARY1_PRESENT(&DummyAttrib);                // value is this
    // FLAGS1_PRESENT(&DummyAttrib);              // flags are not currently used

    Value = NULL;
    ValueSize = 0;                                // dont know the size, find out
    Result = DhcpConvertOptionRPCToRegFormat(     // first convert to Reg fmt
        OptData,
        NULL,
        &ValueSize
    );
    if( ERROR_MORE_DATA != Result ) {             // oops unexpected turn of evts
        Result = ERROR_DDS_UNEXPECTED_ERROR;
        goto Cleanup;
    }
    Value = MemAlloc(ValueSize);                  // got the size, allocate the mem
    if( NULL == Value ) {                         // this shouldnt happen actually
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Result = DhcpConvertOptionRPCToRegFormat(     // now convert to Reg fmt
        OptData,
        Value,
        &ValueSize
    );
    if( ERROR_SUCCESS != Result ) {               // this should not happen either
        return ERROR_DDS_UNEXPECTED_ERROR;
    }

    DummyAttrib.Dword1 = OptId;                   // option Id
    DummyAttrib.String3 = ClassName;              // class Name
    DummyAttrib.String4 = UserClass;              // user class
    DummyAttrib.Binary1 = Value;
    DummyAttrib.BinLen1 = ValueSize;

    Result = MemArrayAddElement(&OptAttribs, &DummyAttrib);
    if( ERROR_SUCCESS != Result ) goto Cleanup;   // Add dummy element to list

    Result = DhcpDsSetLists(                      // set the new list in DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    (void)MemArrayLastLoc(&OptAttribs, &Loc);  // clear up list to way it was
    //- ERROR_SUCCESS == Result
    (void)MemArrayDelElement(&OptAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result && ThisAttrib == &DummyAttrib

  Cleanup:                                        // free up any memory used

    (void)MemArrayFree(&OptAttribs, MemFreeFunc);
    if( Value ) MemFree(Value);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsRemoveOptionValue deletes the required option value from DS
//DOC the specific option value should exist in DS, else error.
//DOC Also, this function works assuming that the option has been written
//DOC to the current object in DS as given by hObject ptr.
//DOC There are requirements on the fmt used in the DS.
DWORD
DhcpDsRemoveOptionValue(                          // remove option value
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // user class for opt
    IN      DWORD                  OptId          // option id
) //EndExport(function)
{
    DWORD                          Result, Result2, unused, ValueSize;
    ARRAY                          OptAttribs;
    PEATTRIB                       ThisAttrib;
    ARRAY_LOCATION                 Loc;

    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for option w/ <OptId>
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( NULL == UserClass && IS_STRING4_PRESENT(ThisAttrib) ) {
            continue;                             // user class mismatch
        }

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( ClassName ) {                     // need to have matching class
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
            }
            if( UserClass ) {                     // need to 've matchin user class
                if( !IS_STRING4_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(UserClass, ThisAttrib->String4) ) continue;
            }

            Result = ERROR_SUCCESS;
            break;
        }
    }

    if( ERROR_SUCCESS != Result ) {               // option was not present in DS
        return ERROR_DDS_OPTION_DOES_NOT_EXIST;
    }

    Result = MemArrayDelElement(&OptAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result
    MemFreeFunc(ThisAttrib);

    Result = DhcpDsSetLists(                      // set the new list in DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ NULL
    );

    (void)MemArrayFree(&OptAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsGetOptionValue retrieves the particular option value in question.
//DOC This function returns ERROR_DDS_OPTION_DOES_NOT_EXIST if the option was
//DOC not found.
DWORD
DhcpDsGetOptionValue(                             // get option value frm DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // user class this opt belongs 2
    IN      DWORD                  OptId,         // option id
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate and fill this ptr
) //EndExport(function)
{
    DWORD                          Result, Result2, unused, Size, Size2;
    ARRAY                          OptAttribs;
    PEATTRIB                       ThisAttrib;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE            LocalOptionValue;

    *OptionValue = NULL;
    LocalOptionValue = NULL;
    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for option w/ <OptId>
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( NULL == UserClass && IS_STRING4_PRESENT(ThisAttrib) ) {
            continue;                             // user class mismatch
        }

        if( IS_DWORD1_PRESENT(ThisAttrib) && OptId == ThisAttrib->Dword1 ) {
            if( ClassName ) {                     // need to have matching class
                if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
            }
            if( UserClass ) {                     // need to 've matchin user class
                if( !IS_STRING4_PRESENT(ThisAttrib) ) continue;
                if( 0 != wcscmp(UserClass, ThisAttrib->String4) ) continue;
            }

            Result = ERROR_SUCCESS;
            break;
        }

        Result = ERROR_SUCCESS;                   // perfect match
        break;
    }

    if( ERROR_SUCCESS != Result ) {               // option was not present in DS
        return ERROR_DDS_OPTION_DOES_NOT_EXIST;
    }

    Size2 = 0;                                    // calculate the size reqd for mem
    Size = ROUND_UP_COUNT(sizeof(*LocalOptionValue), ALIGN_WORST);
    Result = DhcpConvertOptionRegToRPCFormat2(    // convert from RPC to registry fmt
        /* Buffer               */ ThisAttrib->Binary1,
        /* BufferSize           */ ThisAttrib->BinLen1,
        /* Option               */ NULL,
        /* OptBuf               */ NULL,
        /* Size                 */ &Size2         // just calculate the size..
    );
    if( ERROR_MORE_DATA != Result ) {             // cant really go wrong
        Result = ERROR_DDS_UNEXPECTED_ERROR;
        goto Cleanup;
    }

    LocalOptionValue = MemAlloc(Size);
    if( NULL == LocalOptionValue ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalOptionValue->OptionID = ConvertOptIdToRPCValue(OptId, TRUE);
    Size2 = Size - ROUND_UP_COUNT(sizeof(*LocalOptionValue), ALIGN_WORST);
    Result = DhcpConvertOptionRegToRPCFormat2(    // convert from RPC to registry fmt
        /* Buffer               */ ThisAttrib->Binary1,
        /* BufferSize           */ ThisAttrib->BinLen1,
        /* Option               */ &LocalOptionValue->Value,
        /* OptBuf               */ ROUND_UP_COUNT(sizeof(*LocalOptionValue), ALIGN_WORST) + (LPBYTE)LocalOptionValue,
        /* Size                 */ &Size2         // just calculate the size..
    );
    if( ERROR_SUCCESS != Result ) {               // cant really go wrong
        if( ERROR_MORE_DATA == Result ) {         // this can cause confusion..
            Result = ERROR_DDS_UNEXPECTED_ERROR;
        }
        goto Cleanup;
    }

    *OptionValue = LocalOptionValue;

  Cleanup:

    if( ERROR_SUCCESS != Result ) {
        if( LocalOptionValue ) MemFreeFunc(LocalOptionValue);
        *OptionValue = NULL;
    }

    (void)MemArrayFree(&OptAttribs, MemFreeFunc);
    return Result;

}

//BeginExport(function)
//DOC DhcpDsEnumOptionValues enumerates the list of options for a given class
//DOC Also, depending on whether IsVendor is TRUE or false, this function enumerates
//DOC only vendor specific or only non-vendor-specific options respectively.
//DOC This function gets the whole bunch in one shot.
DWORD
DhcpDsEnumOptionValues(                           // get option values  from DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hObject,       // handle to object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class for this opt
    IN      LPWSTR                 UserClass,     // for which user class?
    IN      DWORD                  IsVendor,      // enum only vendor/non-vendor?
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues // allocate option values..
) //EndExport(function)
{
    DWORD                          Result, Result2, unused, Size, Size2, i;
    DWORD                          AllocSize;
    ARRAY                          OptAttribs;
    PEATTRIB                       ThisAttrib;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptionValueArray;
    LPBYTE                         Ptr;

    *OptionValues = NULL;
    LocalOptionValueArray = NULL;
    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    Size = i = 0;
    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // go thru each option, calc size
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_DWORD1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // illegal attrib, or not this opt
        }

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( NULL == UserClass && IS_STRING4_PRESENT(ThisAttrib) ) {
            continue;                             // user class mismatch
        }

        if( ClassName ) {                         // need to have matching class
            if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
        }
        if( UserClass ) {                         // need to 've matchin user class
            if( !IS_STRING4_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(UserClass, ThisAttrib->String4) ) continue;
        }

        Size2 = 0;                                 // calculate the size reqd for mem
        Result2= DhcpConvertOptionRegToRPCFormat2(// convert from RPC to registry fmt
            /* Buffer               */ ThisAttrib->Binary1,
	        /* BufferSize           */ ThisAttrib->BinLen1,
            /* Option               */ NULL,
            /* OptBuf               */ NULL,
            /* Size                 */ &Size2     // just calculate the size..
        );
        if( ERROR_MORE_DATA != Result2 ) {        // cant really go wrong
            continue;                             // skip this attrib in this case
        }

        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        i ++;
    }
    Size += ROUND_UP_COUNT( i * sizeof(DHCP_OPTION_VALUE), ALIGN_WORST);
    Size += ROUND_UP_COUNT( sizeof(DHCP_OPTION_VALUE_ARRAY ), ALIGN_WORST);

    Ptr = MemAlloc(AllocSize = Size); LocalOptionValueArray = (LPVOID)Ptr;
    if( NULL == LocalOptionValueArray ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Ptr += ROUND_UP_COUNT( sizeof(DHCP_OPTION_VALUE_ARRAY ), ALIGN_WORST);
    LocalOptionValueArray->Values = (LPVOID)Ptr;
    Ptr += ROUND_UP_COUNT( i * sizeof(DHCP_OPTION_VALUE), ALIGN_WORST);

    Size = i = 0;
    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // go thru each opt, fill data
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_DWORD1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // illegal attrib, or not this opt
        }

        if( NULL == ClassName && IS_STRING3_PRESENT(ThisAttrib) ) {
            continue;                             // classname mismatch
        }

        if( NULL == UserClass && IS_STRING4_PRESENT(ThisAttrib) ) {
            continue;                             // user class mismatch
        }

        if( ClassName ) {                         // need to have matching class
            if( !IS_STRING3_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(ClassName, ThisAttrib->String3) ) continue;
        }
        if( UserClass ) {                         // need to 've matchin user class
            if( !IS_STRING4_PRESENT(ThisAttrib) ) continue;
            if( 0 != wcscmp(UserClass, ThisAttrib->String4) ) continue;
        }

        Size2 = AllocSize - Size;
        Result2= DhcpConvertOptionRegToRPCFormat2(// convert from RPC to registry fmt
            /* Buffer               */ ThisAttrib->Binary1,
	        /* BufferSize           */ ThisAttrib->BinLen1,
            /* Option               */ &LocalOptionValueArray->Values[i].Value,
            /* OptBuf               */ Ptr,
            /* Size                 */ &Size2     // just calculate the size..
        );
        if( ERROR_SUCCESS != Result2 ) {          // cant really go wrong
            continue;                             // skip this attrib in this case
        }

        LocalOptionValueArray->Values[i].OptionID = ConvertOptIdToRPCValue(ThisAttrib->Dword1, TRUE);
        Size += ROUND_UP_COUNT(Size2, ALIGN_WORST);
        Ptr  += ROUND_UP_COUNT(Size2, ALIGN_WORST);

        i ++;
    }

    LocalOptionValueArray->NumElements = i;
    *OptionValues = LocalOptionValueArray;

  Cleanup:

    if( ERROR_SUCCESS != Result ) {
        if( LocalOptionValueArray ) MemFreeFunc(LocalOptionValueArray);
        *OptionValues = NULL;
    }

    (void)MemArrayFree(&OptAttribs, MemFreeFunc);
    return Result;

}

//BeginExport(function)
//DOC DhcpDsCreateClass creates a given class in the DS. The class should not
//DOC exist prior to this in the DS (if it does, this fn returns error
//DOC ERROR_DDS_CLASS_EXISTS).
DWORD
DhcpDsCreateClass(                                // create this class in the ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class..
    IN      LPWSTR                 ClassComment,  // comment for this class
    IN      LPBYTE                 ClassData,     // the bytes that form the class data
    IN      DWORD                  ClassDataLen,  // # of bytes of above
    IN      BOOL                   IsVendor       // is this a vendor class?
) //EndExport(function)
{
    DWORD                          Result, Result2, unused;
    ARRAY                          ClassAttribs;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;

    if( NULL == ClassName || NULL == ClassData || 0 == ClassDataLen )
        return ERROR_INVALID_PARAMETER;

    MemArrayInit(&ClassAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ &ClassAttribs
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    Result = MemArrayInitLoc(&ClassAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {     // search for existing class
        Result = MemArrayGetElement(&ClassAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib
        Result = MemArrayNextLoc(&ClassAttribs, &Loc);

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // invalid attrib for a class
        }

        if( 0 == wcscmp(ClassName, ThisAttrib->String1) ) {
            Result = ERROR_DDS_CLASS_EXISTS;      // gotcha! same name
            goto Cleanup;
        }
    }

    NothingPresent(&DummyAttrib);                 // create an attrib for the class
    STRING1_PRESENT(&DummyAttrib);                // class name
    if( ClassComment ) {
        STRING2_PRESENT(&DummyAttrib);            // class comment
    }
    BINARY1_PRESENT(&DummyAttrib);                // class data
    FLAGS1_PRESENT(&DummyAttrib);                 // vendorclass etc information

    DummyAttrib.String1 = ClassName;              // now fill in the actual values
    DummyAttrib.String2 = ClassComment;
    DummyAttrib.Binary1 = ClassData;
    DummyAttrib.BinLen1 = ClassDataLen;
    DummyAttrib.Flags1 = IsVendor;

    Result = MemArrayAddElement(&ClassAttribs, &DummyAttrib);
    if( ERROR_SUCCESS != Result ) {               // could not add an elt? uh uh.
        goto Cleanup;
    }

    Result = DhcpDsSetLists(                      // write back the modified list
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ &ClassAttribs
    );

    // now try to remove the dummy element that was added..
    Result2 = MemArrayLastLoc(&ClassAttribs, &Loc);
    //- ERROR_SUCCESS == Result2
    Result2 = MemArrayDelElement(&ClassAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result2 && ThisAttrib == &DummyAttrib

  Cleanup:

    (void) MemArrayFree(&ClassAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsDeleteClass deletes the class from off the DS, and returns an error
//DOC if the class did not exist in the DS for hte given server object.
DWORD
DhcpDsDeleteClass(                                // delete the class from the ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName      // name of class..
) //EndExport(function)
{
    DWORD                          Result, Result2, unused;
    ARRAY                          ClassAttribs;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;

    if( NULL == ClassName ) return ERROR_INVALID_PARAMETER;

    MemArrayInit(&ClassAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ &ClassAttribs
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    for( Result = MemArrayInitLoc(&ClassAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for existing class
         Result = MemArrayNextLoc(&ClassAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&ClassAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // invalid attrib for a class
        }

        if( 0 == wcscmp(ClassName, ThisAttrib->String1) ) {
            Result = ERROR_SUCCESS;               // gotcha! same name
            break;
        }

    }

    if( ERROR_SUCCESS != Result ) {
        Result = ERROR_DDS_CLASS_DOES_NOT_EXIST;
        goto Cleanup;
    }

    Result = MemArrayDelElement(&ClassAttribs, &Loc, &ThisAttrib);
    //- ERROR_SUCCESS == Result && NULL != ThisAttrib
    MemFreeFunc(ThisAttrib);

    Result = DhcpDsSetLists(                      // write back the modified list
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* SetParams            */ &unused,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescripti..    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* ClassDescriptio..    */ NULL,
        /* Classes              */ &ClassAttribs
    );

  Cleanup:
    (void) MemArrayFree(&ClassAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC this is not yet implemented.
DWORD
DhcpDsModifyClass(                                // modify a class in the DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // name of class -- this is the key
    IN      LPWSTR                 ClassComment,  // comment for this class
    IN      LPBYTE                 ClassData,     // the bytes that form the class data
    IN      DWORD                  ClassDataLen   // # of bytes of above
)   //EndExport(function)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//BeginExport(function)
//DOC DhcpDsGetClassInfo get information on a class by doing a search based
//DOC on either the class name or the class data fields.  ClassName is guaranteed
//DOC to be unique. ClassData may/maynot be unique.  The search is done in the DS,
//DOC so things are likely to be a lot slower than they should be.
//DOC This should be fixed by doing some intelligent searches.
//DOC Note that the hServer and the hDhcpC handles should point to the right objects.
//DOC
DWORD
DhcpDsGetClassInfo(                               // get class details for given class
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ClassName,     // OPTIONAL search on class name
    IN      LPBYTE                 ClassData,     // OPTIONAL srch on class data
    IN      DWORD                  ClassDataLen,  // # of bytes of ClassData
    OUT     LPDHCP_CLASS_INFO     *ClassInfo      // allocate and copy ptr
) //EndExport(function)
{
    DWORD                          Result, Result2, Size;
    DWORD                          IsVendor, Flags;
    ARRAY                          ClassAttribs;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    LPDHCP_CLASS_INFO              LocalClassInfo;
    LPBYTE                         Ptr;
    LPWSTR                         ClassComment;

    if( NULL == ClassName || NULL == ClassData || 0 == ClassDataLen )
        return ERROR_INVALID_PARAMETER;

    LocalClassInfo = *ClassInfo = NULL;
    MemArrayInit(&ClassAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ &ClassAttribs
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    Result = MemArrayInitLoc(&ClassAttribs, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {     // search for existing class
        Result = MemArrayGetElement(&ClassAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib
        Result = MemArrayNextLoc(&ClassAttribs, &Loc);

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // invalid attrib for a class
        }

        if( 0 == ThisAttrib->BinLen1 ) {          // invalid attrib for this class
            continue;
        }

        if( ClassName ) {                         // if srching on ClassName field
            if( 0 == wcscmp(ClassName, ThisAttrib->String1) ) {
                Result = ERROR_SUCCESS;           // gotcha! same name
                break;
            }
        } else {                                  // srching on ClassData field
            if( ClassDataLen != ThisAttrib->BinLen1 )
                continue;                         // nope mismatch
            if( 0 == memcpy(ClassData, ThisAttrib->Binary1, ClassDataLen) ) {
                Result = ERROR_SUCCESS;           // gotcha! matching bits
                break;
            }
        }
    }

    if( ERROR_SUCCESS != Result ) {               // did not find the class
        Result = ERROR_DDS_CLASS_DOES_NOT_EXIST;
        goto Cleanup;
    }

    ClassName = ThisAttrib->String1;
    if( IS_STRING2_PRESENT(ThisAttrib) ) {
        ClassComment = ThisAttrib->String2;
    } else {
        ClassComment = NULL;
    }
    ClassData = ThisAttrib->Binary1;
    ClassDataLen = ThisAttrib->BinLen1;
    if( IS_FLAGS1_PRESENT(ThisAttrib) ) {
        IsVendor = ThisAttrib->Flags1;
    } else IsVendor = 0;
    if( IS_FLAGS2_PRESENT(ThisAttrib) ) {
        Flags = ThisAttrib->Flags2;
    } else Flags = 0;


    Size = 0;                                     // calculate size reqd
    Size = ROUND_UP_COUNT(sizeof(DHCP_CLASS_INFO),ALIGN_WORST);
    Size += sizeof(WCHAR)*(wcslen(ClassName)+1);  // alloc space for name
    if( ClassComment ) {                          // alloc space for comment
        Size += sizeof(WCHAR)*(wcslen(ClassComment) +1);
    }
    Size += ThisAttrib->BinLen1;                  // alloc space for data

    Ptr = MemAlloc(Size);                         // allocate memory
    LocalClassInfo =  (LPVOID)Ptr;
    if( NULL == LocalClassInfo ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Size = 0;                                     // copy the stuff in
    Size = ROUND_UP_COUNT(sizeof(DHCP_CLASS_INFO),ALIGN_WORST);

    LocalClassInfo->ClassName = (LPVOID)(Size + Ptr);
    wcscpy(LocalClassInfo->ClassName, ClassName);
    Size += sizeof(WCHAR)*(wcslen(ClassName)+1);
    if( NULL == ClassComment ) {
        LocalClassInfo->ClassComment = NULL;
    } else {
        LocalClassInfo->ClassComment = (LPVOID)(Size + Ptr);
        wcscpy(LocalClassInfo->ClassComment, ThisAttrib->String2 );
        Size += sizeof(WCHAR)*(wcslen(ThisAttrib->String2) +1);
    }
    LocalClassInfo->ClassDataLength = ThisAttrib->BinLen1;
    LocalClassInfo->ClassData = Size+Ptr;
    memcpy(LocalClassInfo->ClassData, ThisAttrib->Binary1, ThisAttrib->BinLen1);
    LocalClassInfo->IsVendor = IsVendor;
    LocalClassInfo->Flags = Flags;

    *ClassInfo = LocalClassInfo;
    Result = ERROR_SUCCESS;

  Cleanup:

    (void) MemArrayFree(&ClassAttribs, MemFreeFunc);
    return Result;
}

//BeginExport(function)
//DOC DhcpDsEnumClasses enumerates the classes for a given server (as specified
//DOC via the hServer object.)
//DOC The memory for Classes is allocated by this function.
DWORD
DhcpDsEnumClasses(                                // get the list of classes frm ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hServer,       // handle to server object in DS
    IN      DWORD                  Reserved,      // must be zero, future use
    OUT     LPDHCP_CLASS_INFO_ARRAY *Classes      // allocate memory for this
) //EndExport(function)
{
    DWORD                          Result, Result2, Size, Size2, i;
    DWORD                          ClassDataLen, IsVendor, Flags;
    ARRAY                          ClassAttribs;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    LPDHCP_CLASS_INFO_ARRAY        LocalClassInfoArray;
    LPBYTE                         Ptr, ClassData;
    LPWSTR                         ClassName, ClassComment;

    LocalClassInfoArray = *Classes = NULL;
    MemArrayInit(&ClassAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ &ClassAttribs
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    Result = MemArrayInitLoc(&ClassAttribs, &Loc);
    for(Size = i = 0                              // search for existing classes
        ; ERROR_FILE_NOT_FOUND != Result;
        Result = MemArrayNextLoc(&ClassAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&ClassAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // invalid attrib for a class
        }

        if( 0 == ThisAttrib->BinLen1 ) {          // invalid attrib for this class
            continue;
        }

        ClassName = ThisAttrib->String1;
        if( IS_STRING2_PRESENT(ThisAttrib) ) {
            ClassComment = ThisAttrib->String2;
        } else {
            ClassComment = NULL;
        }
        ClassData = ThisAttrib->Binary1;
        ClassDataLen = ThisAttrib->BinLen1;

        Size += sizeof(WCHAR)*(wcslen(ClassName)+1);
        if( ClassComment ) {                      // alloc space for comment
            Size += sizeof(WCHAR)*(wcslen(ClassComment) +1);
        }
        Size += ROUND_UP_COUNT(ClassDataLen,ALIGN_WORST);

        i ++;
    }

    Size += ROUND_UP_COUNT(i*sizeof(DHCP_CLASS_INFO), ALIGN_WORST);
    Size += ROUND_UP_COUNT(sizeof(DHCP_CLASS_INFO_ARRAY), ALIGN_WORST);

    Ptr = MemAlloc(Size);                         // allocate memory
    LocalClassInfoArray = (LPVOID)Ptr;
    if( NULL == LocalClassInfoArray ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Size = 0;                                     // copy the stuff in
    LocalClassInfoArray->NumElements = i;
    Size += ROUND_UP_COUNT(sizeof(DHCP_CLASS_INFO_ARRAY), ALIGN_WORST);
    LocalClassInfoArray->Classes = (LPVOID) (Size + Ptr);
    Size += ROUND_UP_COUNT(i*sizeof(DHCP_CLASS_INFO), ALIGN_WORST);

    Result = MemArrayInitLoc(&ClassAttribs, &Loc);
    for(i = 0                                     // fill in the array with details
        ; ERROR_FILE_NOT_FOUND != Result;
        Result = MemArrayNextLoc(&ClassAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&ClassAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // invalid attrib for a class
        }

        if( 0 == ThisAttrib->BinLen1 ) {          // invalid attrib for this class
            continue;
        }

        ClassName = ThisAttrib->String1;
        if( IS_STRING2_PRESENT(ThisAttrib) ) {
            ClassComment = ThisAttrib->String2;
        } else {
            ClassComment = NULL;
        }
        ClassData = ThisAttrib->Binary1;
        ClassDataLen = ThisAttrib->BinLen1;

        LocalClassInfoArray->Classes[i].ClassName = (LPVOID)(Size + Ptr);
        wcscpy(LocalClassInfoArray->Classes[i].ClassName, ClassName);
        Size += sizeof(WCHAR)*(wcslen(ClassName)+1);
        if( NULL == ClassComment ) {
            LocalClassInfoArray->Classes[i].ClassComment = NULL;
        } else {
            LocalClassInfoArray->Classes[i].ClassComment = (LPVOID)(Size + Ptr);
            wcscpy(LocalClassInfoArray->Classes[i].ClassComment, ThisAttrib->String2 );
            Size += sizeof(WCHAR)*(wcslen(ClassComment) +1);
        }
        LocalClassInfoArray->Classes[i].ClassDataLength = ClassDataLen;
        LocalClassInfoArray->Classes[i].ClassData = Size+Ptr;
        memcpy(LocalClassInfoArray->Classes[i].ClassData, ClassData,ClassDataLen);
        Size += ROUND_UP_COUNT(ClassDataLen,ALIGN_WORST);

        if( IS_FLAGS1_PRESENT(ThisAttrib) ) {
            IsVendor = ThisAttrib->Flags1;
        } else IsVendor = 0;
        if( IS_FLAGS2_PRESENT(ThisAttrib) ) {
            Flags = ThisAttrib->Flags2;
        } else Flags = 0;

        LocalClassInfoArray->Classes[i].IsVendor = IsVendor;
        LocalClassInfoArray->Classes[i].Flags = Flags;

        i ++;
    }

    *Classes = LocalClassInfoArray;
    Result = ERROR_SUCCESS;

  Cleanup:

    (void) MemArrayFree(&ClassAttribs, MemFreeFunc);
    return Result;
}

//================================================================================
//  get all optinos and get all option values code
//================================================================================

BOOL
TripletNewlyAdded(                                // check to see if triplet is old or new
    IN      PARRAY                 UClasses,      // array of strings
    IN      PARRAY                 VClasses,      // array of strings again
    IN      PARRAY                 IsVendorVals,  // this is an array of booleans..
    IN      LPWSTR                 UClass,        // user class
    IN      LPWSTR                 VClass,        // venodr class
    IN      ULONG                  IsVendor       // is this vendor or not?
)
{
    ARRAY_LOCATION                 Loc1, Loc2, Loc3;
    DWORD                          Result, Size, ThisIsVendor;
    LPWSTR                         ThisUClass, ThisVClass;

    Result = MemArrayInitLoc(UClasses, &Loc1);
    Result = MemArrayInitLoc(VClasses, &Loc2);
    Result = MemArrayInitLoc(IsVendorVals, &Loc3);
    for(
         ; ERROR_FILE_NOT_FOUND != Result ;
         Result = MemArrayNextLoc(UClasses, &Loc1),
         Result = MemArrayNextLoc(VClasses, &Loc2),
         Result = MemArrayNextLoc(IsVendorVals, &Loc3)
    ) {
        MemArrayGetElement(UClasses, &Loc1, &ThisUClass);
        MemArrayGetElement(VClasses, &Loc2, &ThisVClass);
        MemArrayGetElement(IsVendorVals, &Loc3, (LPVOID *)&ThisIsVendor);

        if( ThisIsVendor != IsVendor ) continue;

        if( NULL == ThisUClass && NULL != UClass ||
            NULL == UClass && NULL != ThisUClass ) continue;
        if( NULL != ThisUClass && 0 != wcscmp(ThisUClass, UClass) ) continue;

        if( NULL == ThisVClass && NULL != VClass ||
            NULL == VClass && NULL != ThisVClass ) continue;
        if( NULL != ThisVClass && 0 != wcscmp(ThisVClass, VClass) ) continue;

        return FALSE;                             // triplet already found!
    }

    // New triplet try to add..
    Result = MemArrayAddElement(IsVendorVals, ULongToPtr(IsVendor));
    if( ERROR_SUCCESS != Result ) return FALSE;

    Result = MemArrayAddElement(VClasses, VClass);
    if( ERROR_SUCCESS != Result ) return FALSE;

    Result = MemArrayAddElement(UClasses, UClass);
    if ( ERROR_SUCCESS != Result ) return FALSE;

    return TRUE;
}

DWORD
ClassifyAndAddOptionValues(                       // find if this combo is alreayd there?
    IN      PEATTRIB               ThisAttrib,    // attribute to process
    IN      PARRAY                 UClasses,      // array of user class strings +
    IN      PARRAY                 VClasses,      // array of vernor class strings +
    IN      PARRAY                 IsVendorVals,  // array of isvendor values
    IN OUT  PULONG                 StringSpace,   // amout of space reqd to store strings
    IN OUT  PULONG                 BinSpace,      // amount of space required to store bins..
    IN OUT  PULONG                 OptionCount    // # of option values in all.
)
{
    ULONG                          Err, Size;
    LPWSTR                         UClass, VClass;
    ULONG                          IsVendor;

    UClass = IS_STRING4_PRESENT(ThisAttrib)? ThisAttrib->String4 : NULL;
    VClass = IS_STRING3_PRESENT(ThisAttrib)? ThisAttrib->String3 : NULL;
    IsVendor = CheckForVendor(ThisAttrib->Dword1, TRUE);

    if( TripletNewlyAdded(UClasses, VClasses, IsVendorVals, UClass, VClass, IsVendor) ) {
        // this triplet was not present before but was just added... need to make space..
        if( UClass ) (*StringSpace) += 1 + wcslen(UClass);
        if( VClass ) (*StringSpace) += 1 + wcslen(VClass);
    }

    Size = 0;
    Err = DhcpConvertOptionRegToRPCFormat2(
        /* Buffer               */ ThisAttrib->Binary1,
        /* BufferSize           */ ThisAttrib->BinLen1,
        /* Option               */ NULL,
        /* OptBuf               */ NULL,
        /* Size                 */ &Size          // just calculate the size..
    );
    if( ERROR_MORE_DATA != Err && ERROR_SUCCESS != Err ) {
        return Err;                               // oops strange error..
    }

    (*BinSpace) += Size;                          // ok additional binary space is this..
    (*OptionCount) ++;                            // one more option..

    return ERROR_SUCCESS;
}

DWORD
CalculateOptionValuesSize(                        // amount of space required for storing...
    IN      ULONG                  nElements,     // # of triples of <classid/vendorid/isvendor>
    IN      ULONG                  StringSpace,   // # of WCHARs of strings requried
    IN      ULONG                  BinSpace,      // # of bytes of space requried for storage of bin..
    IN      ULONG                  OptCount       // total # of options values
)
{
    ULONG                          Size;          // return value.
    DHCP_ALL_OPTION_VALUES         AllValues;

    // basic strucutre
    Size = ROUND_UP_COUNT(sizeof(AllValues), ALIGN_WORST);

    // array of triplets
    Size += nElements * ( sizeof(*(AllValues.Options)) );
    Size = ROUND_UP_COUNT( Size, ALIGN_WORST);

    // each triplet also has an array in it.. the basic struc..
    Size += nElements * ( sizeof(*(AllValues.Options->OptionsArray)) );
    Size = ROUND_UP_COUNT( Size, ALIGN_WORST);

    // now comes the arrays of options actually
    Size += OptCount * sizeof(DHCP_OPTION_VALUE);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    // now the space to store the strings..
    Size += sizeof(WCHAR)*StringSpace;

    // now to store the binaries..
    Size += BinSpace;

    return Size;
}

DWORD
AddSpecificOptionValues(                          // for this triple, add all options to array
    IN OUT  LPDHCP_OPTION_VALUE_ARRAY Values,     // array to fill
    IN      LPWSTR                 UClass,        // the user class of this set of values
    IN      LPWSTR                 VClass,        // the vendor class of this set of values
    IN      ULONG                  IsVendor,      // is it vendor or not?
    IN      PARRAY                 InputValues,   // array of PEATTRIB types from DS
    IN OUT  LPDHCP_OPTION_VALUE   *OptionValues,  // use this for space and update it..
    IN OUT  LPBYTE                *Ptr            // use this for binary space and update it..
)
{
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    DWORD                          Result, Size, ThisIsVendor;
    LPWSTR                         ThisUClass, ThisVClass;

    Values->NumElements = 0;
    Values->Values = (*OptionValues);

    for( Result = MemArrayInitLoc(InputValues, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;
         Result = MemArrayNextLoc(InputValues, &Loc)
    ) {
        MemArrayGetElement(InputValues, &Loc, &ThisAttrib);

        ThisUClass = IS_STRING4_PRESENT(ThisAttrib)? ThisAttrib->String4 : NULL;
        ThisVClass = IS_STRING3_PRESENT(ThisAttrib)? ThisAttrib->String3 : NULL;
        ThisIsVendor = CheckForVendor(ThisAttrib->Dword1, TRUE);

        if( ThisIsVendor != IsVendor ) continue;

        if( NULL == ThisUClass && NULL != UClass ||
            NULL == UClass && NULL != ThisUClass ) continue;
        if( NULL != ThisUClass && 0 != wcscmp(ThisUClass, UClass) ) continue;

        if( NULL == ThisVClass && NULL != VClass ||
            NULL == VClass && NULL != ThisVClass ) continue;
        if( NULL != ThisVClass && 0 != wcscmp(ThisVClass, VClass) ) continue;

        // matched.. increase count.. convert option.. move pointers..
        Values->NumElements ++;

        (*OptionValues)->OptionID = ThisAttrib->Dword1;
        Size = 0xFFFFFFFF;                        // dont know size but definitely enough
        Result = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer               */ ThisAttrib->Binary1,
            /* BufferSize           */ ThisAttrib->BinLen1,
            /* Option               */ &(*OptionValues)->Value,
            /* OptBuf               */ (*Ptr),
            /* Size                 */ &Size      // just calculate the size..
        );
        if( ERROR_MORE_DATA != Result && ERROR_SUCCESS != Result ) {
            return Result;                        // oops strange error..
        }

        (*OptionValues) ++;
        (*Ptr) += Size;
    }

    return ERROR_SUCCESS;
}


DWORD
FillOptionValues(                                 // fill optiosn according to pattern laid out above..
    IN      PARRAY                 Options,       // teh options to fill
    IN      PARRAY                 UClasses,      // the user classes
    IN      PARRAY                 VClasses,      // the vendor classes
    IN      PARRAY                 IsVendorVals,  // Isvenodr values
    IN      ULONG                  StringSpace,   // how much space for strings?
    IN      ULONG                  BinSpace,      // how much space for bins?
    IN      ULONG                  OptCount,      // total # of options
    OUT     LPDHCP_ALL_OPTION_VALUES Values      // fill this out and returns
)
{
    DHCP_ALL_OPTION_VALUES         AllValues;
    ULONG                          Result, nElements, Size;
    LPBYTE                         Ptr = (LPBYTE)Values;
    LPWSTR                         Strings;
    LPDHCP_OPTION_VALUE            OptionValuesArray;
    int                            i;
    ARRAY_LOCATION                 Loc1, Loc2, Loc3;
    LPVOID                         ThisElt;

    // basic strucutre
    Size = ROUND_UP_COUNT(sizeof(AllValues), ALIGN_WORST);
    Ptr = Size + (LPBYTE)Values;

    Values->NumElements = nElements = MemArraySize(UClasses);
    Values->Flags = 0;
    Values->Options = (LPVOID)Ptr;

    // array of triplets
    Size += nElements * ( sizeof(*(AllValues.Options)) );
    Size = ROUND_UP_COUNT( Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)Values;

    // each triplet also has an array in it.. the basic struc..
    for( i = 0; i < (int)nElements; i ++ ) {
        Values->Options[i].OptionsArray = (LPVOID)Ptr;
        Ptr += sizeof(*(AllValues.Options->OptionsArray));
    }

    Size += nElements * ( sizeof(*(AllValues.Options->OptionsArray)) );
    Size = ROUND_UP_COUNT( Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)Values;

    // now comes the arrays of options actually
    OptionValuesArray = (LPVOID) Ptr;

    Size += OptCount * sizeof(DHCP_OPTION_VALUE);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)Values;

    // now the space to store the strings..
    Strings = (LPWSTR)Ptr;
    Size += sizeof(WCHAR)*StringSpace;

    // now to store the binaries..
    Ptr = Size + (LPBYTE)Values;
    Size += BinSpace;

    // now do the filling in earnestly.
    MemArrayInitLoc(UClasses, &Loc1);
    MemArrayInitLoc(VClasses, &Loc2);
    MemArrayInitLoc(IsVendorVals, &Loc3);
    for( i = 0; i < (int)nElements ; i ++ ) {
        LPWSTR UClass, VClass;
        ULONG  IsVendor;

        MemArrayGetElement(UClasses, &Loc1, &UClass);
        MemArrayGetElement(VClasses, &Loc2, &VClass);
        MemArrayGetElement(IsVendorVals, &Loc3, (LPVOID *)&IsVendor);

        MemArrayNextLoc(UClasses, &Loc1);
        MemArrayNextLoc(VClasses, &Loc2);
        MemArrayNextLoc(IsVendorVals, &Loc3);

        if( NULL == UClass ) {
            Values->Options[i].ClassName = NULL;
        } else {
            Values->Options[i].ClassName = Strings;
            wcscpy(Strings, UClass);
            Strings += 1 + wcslen(UClass);
        }

        if( NULL == VClass ) {
            Values->Options[i].VendorName = NULL;
        } else {
            Values->Options[i].VendorName = Strings;
            wcscpy(Strings, VClass);
            Strings += 1 + wcslen(VClass);
        }

        Values->Options[i].IsVendor = IsVendor;

        Result = AddSpecificOptionValues(
            Values->Options[i].OptionsArray,
            UClass, VClass, IsVendor,
            Options,
            &OptionValuesArray,
            &Ptr
        );

        if( ERROR_SUCCESS != Result ) return Result;
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC This function retrieves all the option valuesdefined for this object frm th dS
DWORD
DhcpDsGetAllOptionValues(
    IN      LPSTORE_HANDLE         hDhcpC,
    IN      LPSTORE_HANDLE         hObject,
    IN      DWORD                  Reserved,
    OUT     LPDHCP_ALL_OPTION_VALUES *OptionValues
)   //EndExport(function)
{
    DWORD                          Result, Result2, unused, Size, Size2, i;
    DWORD                          AllocSize;
    ARRAY                          OptAttribs;
    PEATTRIB                       ThisAttrib;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptionValueArray;
    LPBYTE                         Ptr;
    ARRAY                          UserClassNames;
    ARRAY                          VendorClassNames;
    ARRAY                          IsVendorValues;
    ULONG                          StringSpace, BinSpace;
    ULONG                          OptionCount, ElementCount;

    *OptionValues = NULL;
    LocalOptionValueArray = NULL;
    MemArrayInit(&OptAttribs);
    Result = DhcpDsGetLists(                      // get list of options frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hObject,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ &OptAttribs,
        /* Classes              */ NULL
    );
    // if( ERROR_SUCCESS != Result ) return Result;

    StringSpace = 0; BinSpace = 0; OptionCount = 0;
    MemArrayInit(&UserClassNames);
    MemArrayInit(&VendorClassNames);
    MemArrayInit(&IsVendorValues);
    for( Result = MemArrayInitLoc(&OptAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // go thru each option, calc size
         Result = MemArrayNextLoc(&OptAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_DWORD1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib) ) {
            continue;                             // illegal attrib, or not this opt
        }

        Result = ClassifyAndAddOptionValues(
            ThisAttrib, &UserClassNames, &VendorClassNames, &IsVendorValues,
            &StringSpace, &BinSpace, &OptionCount
        );
        if( ERROR_SUCCESS != Result ) goto Cleanup;
    }

    // total space required calculation...
    ElementCount = MemArraySize(&UserClassNames); // same as vendor class etc..

    Size = CalculateOptionValuesSize(ElementCount, StringSpace, BinSpace, OptionCount);

    (*OptionValues) = MemAlloc(Size);
    if( NULL == (*OptionValues) ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Result = FillOptionValues(
        &OptAttribs, &UserClassNames, &VendorClassNames, &IsVendorValues,
        StringSpace, BinSpace, OptionCount,
        (*OptionValues)
    );
    if( ERROR_SUCCESS != Result ) {
        MemFree(*OptionValues);
        *OptionValues = NULL;
    }

  Cleanup:
    MemArrayFree(&OptAttribs, MemFreeFunc);
    MemArrayFree(&UserClassNames, MemFreeFunc);
    MemArrayFree(&VendorClassNames, MemFreeFunc);
    MemArrayFree(&IsVendorValues, MemFreeFunc);

    return Result;
}

DWORD
ClassifyAndAddOption(                             // classify as vendor/non-vendor etc
    IN      PEATTRIB               ThisAttrib,    // attrib to classify
    IN      PULONG                 StringSpace,   // add to this the space reqd for strings
    IN      PULONG                 BinSpace,      // add to this the space reqd for bin.
    IN      PULONG                 VendorCount,   // increment if vendor
    IN      PULONG                 NonVendorCount // increment if non-vendor
)
{
    BOOL                           IsVendor;
    ULONG                          Result, Size;

    if( CheckForVendor(ThisAttrib->Dword1, TRUE) ) {
        (*VendorCount) ++;                        // vendor specific option..
        IsVendor = TRUE;
        if( IS_STRING3_PRESENT(ThisAttrib) ) {    // got a class name
            (*StringSpace) += 1+wcslen(ThisAttrib->String3);
        }
    } else {
        (*NonVendorCount) ++;                     // not a vendor option
        IsVendor = FALSE;
    }

    (*StringSpace) += 1+wcslen(ThisAttrib->String1);
    if( IS_STRING2_PRESENT(ThisAttrib) ) {        // string1 is name, string2 is comment
        (*StringSpace) += 1+wcslen(ThisAttrib->String2);
    }

    Size = 0;
    Result = DhcpConvertOptionRegToRPCFormat2(
        /* Buffer           */ ThisAttrib->Binary1,
        /* BufferSize       */ ThisAttrib->BinLen1,
        /* Option           */ NULL,
        /* OptBuf           */ NULL,
        /* Size             */ &Size
    );
    if( ERROR_MORE_DATA != Result && ERROR_SUCCESS != Result ) {
        return Result;
    }

    (*BinSpace) += Size;
    return ERROR_SUCCESS;
}

DWORD
CalculateOptionsSize(                        // calc amt storage reqd for this..
    IN      ULONG                  VendorCount,   // # of vendor options
    IN      ULONG                  NonVendorCount,// # of non-vendor options
    IN      ULONG                  StringSpace,   // # of WCHAR string chars
    IN      ULONG                  BinSpace       // # of bytes for binary data..
)
{
    ULONG                          Size;
    LPDHCP_ALL_OPTIONS             AllOptions;    // dummy structure..

    // First comes the structure itself
    Size = ROUND_UP_COUNT(sizeof(*AllOptions), ALIGN_WORST);

    // Next comes the space for a NonVendorOptions array
    Size += sizeof(*(AllOptions->NonVendorOptions));
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    // Next comes the non-vendor optiosn themselves
    Size += NonVendorCount * sizeof(DHCP_OPTION);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    // Next comes the vendor options structure..
    Size += VendorCount * sizeof(*(AllOptions->VendorOptions));
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    // Next store the strings..
    Size += sizeof(WCHAR)*StringSpace;

    // Next store the binary information..
    Size += BinSpace;

    return Size;
}

DWORD
AddSpecificOptions(                               // fill in the structure of optiosn..
    IN OUT  LPDHCP_ALL_OPTIONS     AllOptions,    // this is the structure to fill in
    IN      LPWSTR                 Strings,       // Buffer to use to fill in all strings
    IN      LPBYTE                 BinarySpace,   // this is the space to use for bin..
    IN      PARRAY                 OptDefs        // the array to pick off hte options from
)
{
    ULONG                          Err, Size;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    ULONG                          nVendorOpts, nNonVendorOpts;
    BOOL                           IsVendor;
    ULONG                          OptId, OptType;
    LPWSTR                         OptionName;
    LPWSTR                         OptionComment;
    LPWSTR                         VendorName;
    LPDHCP_OPTION                  ThisOption;

    AllOptions->Flags = 0;
    nVendorOpts = nNonVendorOpts = 0;

    for( Err = MemArrayInitLoc(OptDefs, &Loc)
         ; ERROR_SUCCESS == Err ;
         Err = MemArrayNextLoc(OptDefs, &Loc)
    ) {                                           // process each option

        Err = MemArrayGetElement(OptDefs, &Loc, &ThisAttrib);

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib)
            || !IS_DWORD1_PRESENT(ThisAttrib) ) { // invalid attrib
            continue;                             // skip it
        }

        IsVendor = CheckForVendor(ThisAttrib->Dword1, TRUE );
        OptId = ConvertOptIdToRPCValue(ThisAttrib->Dword1, TRUE);
        OptType = IS_FLAGS1_PRESENT(ThisAttrib) ? ThisAttrib->Flags1 : 0;
        OptionName = ThisAttrib->String1;
        OptionComment = IS_STRING2_PRESENT(ThisAttrib) ? ThisAttrib->String2 : NULL;
        VendorName = IS_STRING3_PRESENT(ThisAttrib) ? ThisAttrib->String3 : NULL;

        if( !IsVendor ) {                         // fill in the non-vendor part..
            ThisOption = &AllOptions->NonVendorOptions->Options[nNonVendorOpts++];
        } else {
            ThisOption = &AllOptions->VendorOptions[nVendorOpts].Option;
            if( !VendorName ) {
                AllOptions->VendorOptions[nVendorOpts].VendorName = NULL;
            } else {
                wcscpy(Strings, VendorName);
                AllOptions->VendorOptions[nVendorOpts].VendorName = Strings;
                Strings += 1+wcslen(Strings);
            }
            AllOptions->VendorOptions[nVendorOpts++].ClassName = NULL;
        }

        Size = 0xFFFFFFFF;                        // databuffer size is sufficient.. but unkonwn..
        Err = DhcpConvertOptionRegToRPCFormat2(
            /* Buffer           */ ThisAttrib->Binary1,
            /* BufferSize       */ ThisAttrib->BinLen1,
            /* Option           */ &ThisOption->DefaultValue,
            /* OptBuf           */ BinarySpace,
            /* Size             */ &Size
        );
        if( ERROR_SUCCESS != Err ) return Err;    // barf
        BinarySpace += Size;                      // update sapce ..

        ThisOption->OptionID = OptId;
        ThisOption->OptionType = OptType;
        ThisOption->OptionName = Strings;
        wcscpy(Strings, OptionName); Strings += 1+wcslen(Strings);
        if( NULL == OptionComment ) {
            ThisOption->OptionComment = NULL;
        } else {
            ThisOption->OptionComment = Strings;
            wcscpy(Strings, OptionComment);
            Strings += 1 + wcslen(Strings);
        }

    }

    if( AllOptions->NumVendorOptions != nVendorOpts ||
        AllOptions->NonVendorOptions->NumElements != nNonVendorOpts ) {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD
FillOptions(                                      // fill in the optinos..
    IN      PARRAY                 OptDefs,       // each attrib isz an option to fill in
    IN      ULONG                  VendorCount,   // # of vendor options
    IN      ULONG                  NonVendorCount,// # of non-vendor options
    IN      ULONG                  StringSpace,   // sapce for strings
    IN      ULONG                  BinSpace,      // space for binary..
    OUT     LPDHCP_ALL_OPTIONS     AllOptions     // fill this in..
)
{
    LPBYTE                         Ptr;
    ULONG                          Size,Result;
    LPWSTR                         Strings;
    LPBYTE                         Binary;

    // first comes the structure itself..
    AllOptions->Flags = 0;
    AllOptions->NumVendorOptions = VendorCount;
    Size = ROUND_UP_COUNT(sizeof(*AllOptions), ALIGN_WORST);
    Ptr = Size + (LPBYTE)AllOptions;

    // next comes NonVendorOptions array
    AllOptions->NonVendorOptions = (LPVOID)Ptr;
    AllOptions->NonVendorOptions->NumElements = NonVendorCount;
    Size += sizeof(*(AllOptions->NonVendorOptions));
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)AllOptions;

    if( 0 == NonVendorCount ) {
        AllOptions->NonVendorOptions->Options = NULL;
    } else {
        AllOptions->NonVendorOptions->Options = (LPVOID)Ptr;
    }

    // Next comes the non-vendor optiosn themselves
    Size += NonVendorCount * sizeof(DHCP_OPTION);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)AllOptions;

    // Next comes the vendor options structure..
    AllOptions->VendorOptions = (LPVOID)Ptr;

    Size += VendorCount * sizeof(*(AllOptions->VendorOptions));
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Ptr = Size + (LPBYTE)AllOptions;

    // Next store the strings..
    Strings = (LPWSTR)Ptr;
    Size += sizeof(WCHAR)*StringSpace;
    Ptr = Size + (LPBYTE)AllOptions;

    // Next store the binary information..
    Binary = Ptr;

    return AddSpecificOptions(
        AllOptions,
        Strings,
        Binary,
        OptDefs
    );
}

//BeginExport(function)
//DOC This function retrieves all the optiosn defined for this server.. frm the DS
DWORD
DhcpDsGetAllOptions(
    IN      LPSTORE_HANDLE         hDhcpC,
    IN      LPSTORE_HANDLE         hServer,
    IN      DWORD                  Reserved,
    OUT     LPDHCP_ALL_OPTIONS    *Options
)   //EndExport(function)
{
    DWORD                          Result, Result2, unused, Size, Size2, i, AllocSize;
    ARRAY                          OptDefAttribs;
    PEATTRIB                       ThisAttrib;
    EATTRIB                        DummyAttrib;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_ARRAY            OptArray;
    ULONG                          StringSpace, BinSpace;
    ULONG                          VendorCount, NonVendorCount;

    *Options = NULL;
    MemArrayInit(&OptDefAttribs);
    Result = DhcpDsGetLists(                      // get list of opt defs frm DS
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ &OptDefAttribs,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Result ) return Result;

    StringSpace = 0; BinSpace = 0;
    VendorCount = NonVendorCount = 0;

    for( Result = MemArrayInitLoc(&OptDefAttribs, &Loc)
         ; ERROR_FILE_NOT_FOUND != Result ;       // search for optdef w/ <OptId>
         Result = MemArrayNextLoc(&OptDefAttribs, &Loc)
    ) {
        Result = MemArrayGetElement(&OptDefAttribs, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) || !IS_BINARY1_PRESENT(ThisAttrib)
            || !IS_DWORD1_PRESENT(ThisAttrib) ) { // invalid attrib
            continue;                             // skip it
        }

        Result = ClassifyAndAddOption(
            ThisAttrib, &StringSpace, &BinSpace, &VendorCount, &NonVendorCount
        );
        if( ERROR_SUCCESS != Result ) goto Cleanup;
    }

    Size = CalculateOptionsSize(
        VendorCount, NonVendorCount, StringSpace, BinSpace
    );

    (*Options) = MemAlloc(Size);
    if( NULL == (*Options) ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Result = FillOptions(
        &OptDefAttribs, VendorCount, NonVendorCount, StringSpace, BinSpace,
        (*Options)
    );
    if( ERROR_SUCCESS == Result ) return ERROR_SUCCESS;

    MemFree(*Options);
    *Options = NULL;

  Cleanup:
    MemArrayFree(&OptDefAttribs, MemFreeFunc);

    return Result;
}

//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\sterr.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: per thread error status
//================================================================================

#include    <hdrmacro.h>

const
DWORD       nErrorsToStore         = 4;           // the size of the array is 1+nErrorsToStore
DWORD       StErrTlsIndex[5]       = { -1, -1, -1, -1, -1 };

//BeginExport(function)
DWORD
StErrInit(
    VOID
) //EndExport(function)
{
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
StErrCleanup(
    VOID
) //EndExport(function)
{
}

//BeginExport(function)
VOID 
SetInternalFormatError(
    IN      DWORD                  Code,
    IN      BOOL                   ReallyDoIt
)
{
#ifdef DBG
    if(ReallyDoIt) {
//          printf("InternalError: %lx\n", Code);	
    }
#endif // DBG
}
//EndExport(function)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcstubs.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef CONVERT_NAMES
#define DhcpCreateSubnet DhcpCreateSubnetDS
#define DhcpSetSubnetInfo DhcpSetSubnetInfoDS
#define DhcpGetSubnetInfo DhcpGetSubnetInfoDS
#define DhcpEnumSubnets DhcpEnumSubnetsDS
#define DhcpDeleteSubnet DhcpDeleteSubnetDS
#define DhcpCreateOption DhcpCreateOptionDS
#define DhcpSetOptionInfo DhcpSetOptionInfoDS
#define DhcpGetOptionInfo DhcpGetOptionInfoDS
#define DhcpRemoveOption DhcpRemoveOptionDS
#define DhcpSetOptionValue DhcpSetOptionValueDS
#define DhcpGetOptionValue DhcpGetOptionValueDS
#define DhcpEnumOptionValues DhcpEnumOptionValuesDS
#define DhcpRemoveOptionValue DhcpRemoveOptionValueDS
#define DhcpEnumOptions DhcpEnumOptionsDS
#define DhcpSetOptionValues DhcpSetOptionValuesDS
#define DhcpAddSubnetElement DhcpAddSubnetElementDS
#define DhcpEnumSubnetElements DhcpEnumSubnetElementsDS
#define DhcpRemoveSubnetElement DhcpRemoveSubnetElementDS
#define DhcpAddSubnetElementV4 DhcpAddSubnetElementV4DS
#define DhcpEnumSubnetElementsV4 DhcpEnumSubnetElementsV4DS
#define DhcpRemoveSubnetElementV4 DhcpRemoveSubnetElementV4DS
#define DhcpSetSuperScopeV4 DhcpSetSuperScopeV4DS
#define DhcpGetSuperScopeInfoV4 DhcpGetSuperScopeInfoV4DS
#define DhcpDeleteSuperScopeV4 DhcpDeleteSuperScopeV4DS

#define DhcpSetClientInfo DhcpSetClientInfoDS
#define DhcpGetClientInfo DhcpGetClientInfoDS
#define DhcpSetClientInfoV4 DhcpSetClientInfoV4DS
#define DhcpGetClientInfoV4 DhcpGetClientInfoV4DS

#define DhcpCreateOptionV5 DhcpCreateOptionV5DS
#define DhcpSetOptionInfoV5 DhcpSetOptionInfoV5DS
#define DhcpGetOptionInfoV5 DhcpGetOptionInfoV5DS
#define DhcpEnumOptionsV5 DhcpEnumOptionsV5DS
#define DhcpRemoveOptionV5 DhcpRemoveOptionV5DS
#define DhcpSetOptionValueV5 DhcpSetOptionValueV5DS
#define DhcpSetOptionValuesV5 DhcpSetOptionValuesV5DS
#define DhcpGetOptionValueV5 DhcpGetOptionValueV5DS
#define DhcpEnumOptionValuesV5 DhcpEnumOptionValuesV5DS
#define DhcpRemoveOptionValueV5 DhcpRemoveOptionValueV5DS
#define DhcpCreateClass DhcpCreateClassDS
#define DhcpModifyClass DhcpModifyClassDS
#define DhcpDeleteClass DhcpDeleteClassDS
#define DhcpGetClassInfo DhcpGetClassInfoDS
#define DhcpEnumClasses DhcpEnumClassesDS
#define DhcpGetAllOptions DhcpGetAllOptionsDS
#define DhcpGetAllOptionValues DhcpGetAllOptionValuesDS

#endif  CONVERT_NAMES


//DOC Create an option in DS. Checkout DhcpDsCreateOptionDef for more info...
DWORD
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC Modify existing option's fields in the DS. See DhcpDsModifyOptionDef for more
//DOC details
DWORD
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC not yet supported at this level... (this is supported in a
//DOC DhcpDs function, no wrapper yet)
DWORD
DhcpGetOptionInfoV5(                              // retrieve option info from off ds structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory
) ;


//DOC See DhcpDsEnumOptionDefs for more info on this function.. but essentially, all this
//DOC does is to read thru the options and create a list of options..
DWORD
DhcpEnumOptionsV5(                                // create list of all options in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Delete an option from off the DS. See DhcpDsDeleteOptionDef for
//DOC more details.
DWORD
DhcpRemoveOptionV5(                               // remove an option from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


//DOC Set the specified option value in the DS.  For more information,
//DOC see DhcpDsSetOptionValue.
DWORD
DhcpSetOptionValueV5(                             // set the option value in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


//DOC This function just calls the SetOptionValue function N times.. this is not
//DOC atomic (), but even worse, it is highly inefficient, as it creates the
//DOC required objects over and over again!!!!!
//DOC This has to be fixed..
DWORD
DhcpSetOptionValuesV5(                            // set a series of option values
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


//DOC This function retrives the value of an option from the DS.  For more info,
//DOC pl check DhcpDsGetOptionValue.
DWORD
DhcpGetOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue
) ;


//DOC Get the list of option values defined in DS. For more information,
//DOC check DhcpDsEnumOptionValues.
DWORD
DhcpEnumOptionValuesV5(                           // get list of options defined in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Remove the option value from off the DS.  See DhcpDsRemoveOptionValue
//DOC for further information.
DWORD
DhcpRemoveOptionValueV5(                          // remove option value from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC Create a class in the DS.  Please see DhcpDsCreateClass for more
//DOC details on this function.
DWORD
DhcpCreateClass(                                  // create a class in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Modify an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpModifyClass(                                  // modify existing class
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Delete an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpDeleteClass(                                  // delete a class from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


//DOC DhcpGetClassInfo completes the information provided for a class in struct
//DOC PartialClassInfo.  For more details pl see DhcpDsGetClassInfo.
DWORD
DhcpGetClassInfo(                                 // fetch complete info frm DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


//DOC This is implememented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOption(                                 // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfo(                                // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfo(                                // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptions(                                  // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOption(                                 // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValue(                               // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValues(                              // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValue(                               // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC This function sets the superscope of a subnet, thereby creating the superscope
//DOC if required.  Please see DhcpDsSetSScope for more details.
DWORD
DhcpSetSuperScopeV4(                              // set superscope in DS.
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


//DOC This function removes the superscope, and resets any subnet with this
//DOC superscope.. so that all those subnets end up with no superscopes..
//DOC Please see DhcpDsDelSScope for more details.
DWORD
DhcpDeleteSuperScopeV4(                           // delete subnet sscope from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


//DOC This function retrievs the supercsope info for each subnet that is
//DOC present for the given server.  Please see DhcpDsGetSScopeInfo for more
//DOC details on this..
DWORD
DhcpGetSuperScopeInfoV4(                          // get sscope tbl from DS
    IN      LPWSTR                 ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


//DOC This function creates a subnet in the DS with the specified params.
//DOC Please see DhcpDsServerAddSubnet for more details on this function.
DWORD
DhcpCreateSubnet(                                 // add subnet 2 DS for this srvr
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Modify existing subnet with new parameters... some restrictions apply.
//DOC Please see DhcpDsServerModifySubnet for further details.
DWORD
DhcpSetSubnetInfo(                                // modify existing subnet params
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpGetSubnetInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpEnumSubnets(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


//DOC This function deletes the subnet from the DS.  For further information, pl
//DOC see DhcpDsServerDelSubnet..
DWORD
DhcpDeleteSubnet(                                 // Del subnet from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function sets some particular information for RESERVATIONS only
//DOC all other stuff it just ignores and returns success..
DWORD
DhcpSetClientInfo(
    IN      LPWSTR                 ServerIpAddresess,
    IN      LPDHCP_CLIENT_INFO     ClientInfo
) ;


//DOC This function retrieves some particular client's information
//DOC for RESERVATIONS only.. For all other stuff it returns CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_SEARCH_INFO     SearchInfo,
    OUT      LPDHCP_CLIENT_INFO    *ClientInfo
) ;


//DOC This function sets the client informatoin for RESERVATIONS only in DS
//DOC For all toher clients it returns ERROR_SUCCESS w/o doing anything
DWORD
DhcpSetClientInfoV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_CLIENT_INFO_V4  ClientInfo
) ;


//DOC Thsi function sets the client information for RESERVATIONS only
//DOC For all others it returns ERROR_CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfoV4(
    IN     LPWSTR                  ServerIpAddress,
    IN     LPDHCP_SEARCH_INFO      SearchInfo,
    OUT    LPDHCP_CLIENT_INFO_V4  *ClientInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElement(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA  AddElementInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElementsV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElements(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElement(                          // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElementV4(                        // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


#ifndef CONVERT_NAMES
#undef DhcpCreateSubnet
#undef DhcpSetSubnetInfo
#undef DhcpGetSubnetInfo
#undef DhcpEnumSubnets
#undef DhcpDeleteSubnet
#undef DhcpCreateOption
#undef DhcpSetOptionInfo
#undef DhcpGetOptionInfo
#undef DhcpRemoveOption
#undef DhcpSetOptionValue
#undef DhcpGetOptionValue
#undef DhcpEnumOptionValues
#undef DhcpRemoveOptionValue
#undef DhcpEnumOptions
#undef DhcpSetOptionValues
#undef DhcpAddSubnetElementV4
#undef DhcpEnumSubnetElementsV4
#undef DhcpRemoveSubnetElementV4
#undef DhcpAddSubnetElement
#undef DhcpEnumSubnetElements
#undef DhcpRemoveSubnetElement
#undef DhcpSetSuperScopeV4
#undef DhcpGetSuperScopeInfoV4
#undef DhcpDeleteSuperScopeV4

#undef DhcpSetClientInfo
#undef DhcpGetClientInfo
#undef DhcpSetClientInfoV4
#undef DhcpGetClientInfoV4

#undef DhcpCreateOptionV5
#undef DhcpSetOptionInfoV5
#undef DhcpGetOptionInfoV5
#undef DhcpEnumOptionsV5
#undef DhcpRemoveOptionV5
#undef DhcpSetOptionValueV5
#undef DhcpSetOptionValuesV5
#undef DhcpGetOptionValueV5
#undef DhcpEnumOptionValuesV5
#undef DhcpRemoveOptionValueV5
#undef DhcpCreateClass
#undef DhcpModifyClass
#undef DhcpDeleteClass
#undef DhcpGetClassInfo
#undef DhcpEnumClasses
#undef DhcpGetAllOptions
#undef DhcpGetAllOptionValues
#endif CONVERT_NAMES


#define     DHCP_SERVER_ANOTHER_ENTERPRISE        0x01
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;


//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) ;


//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) ;


//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//DOC DhcpDsGetLastUpdateTime is defined in upndown.c --> see there for more details.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcstubs.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description:  Actual stubs that are the equivalent the rpcapi1.c and rpcapi2.c
// in the server\server directory.. (or more accurately, the implementations are
// the same as for the functions defined in server\client\dhcpsapi.def)
// NOTE: THE FOLLOWING FUNCTIONS ARE NOT RPC, BUT THEY BEHAVE JUST THE SAME AS
// THE DHCP RPC CALLS, EXCEPT THEY ACCESS THE DS DIRECTLY.
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <rpcapi1.h>
#include    <st_srvr.h>
#include    <rpcapi2.h>

//================================================================================
//  global variables..
//================================================================================
BOOL
StubInitialized                    = FALSE;
STORE_HANDLE                       hDhcpC, hDhcpRoot;
CRITICAL_SECTION                   DhcpDsDllCriticalSection;

//================================================================================
//   THE FOLLOWING FUNCTIONS HAVE BEEN COPIED OVER FROM RPCAPI1.C (IN THE
//   DHCP\SERVER\SERVER DIRECTORY).
//================================================================================

#undef      DhcpPrint
#define     DhcpPrint(X)
#define     DhcpAssert(X)

typedef  struct _OPTION_BIN {
    DWORD                          DataSize;
    DHCP_OPTION_DATA_TYPE          OptionType;
    DWORD                          NumElements;
    BYTE                           Data[0];
} OPTION_BIN, *LPOPTION_BIN;

#define IS_SPACE_AVAILABLE(FilledSize, AvailableSize, RequiredSpace )   ((FilledSize) + (RequiredSpace) <= (AvailableSize) )

BOOL        _inline
CheckForVendor(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return (256 <= OptId);
    return 256 > OptId;
}

DWORD       _inline
ConvertOptIdToRPCValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendorUnused
)
{
    return OptId % 256;
}

DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}

extern                                            // defined in rpcapi1.c
DWORD
DhcpConvertOptionRPCToRegFormat(
    IN      LPDHCP_OPTION_DATA     Option,
    IN OUT  LPBYTE                 RegBuffer,     // OPTIONAL
    IN OUT  DWORD                 *BufferSize     // input: buffer size, output: filled buffer size
);

DWORD
ConvertOptionInfoRPCToMemFormat(
    IN      LPDHCP_OPTION          OptionInfo,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *OptId,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
)
{
    DWORD                          Error;

    if( Name ) *Name = OptionInfo->OptionName;
    if( Comment ) *Comment = OptionInfo->OptionComment;
    if( OptId ) *OptId = (DWORD)(OptionInfo->OptionID);
    if( Value ) {
        *Value = NULL;
        if( !ValueSize ) return ERROR_INVALID_PARAMETER;
        *ValueSize = 0;
        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            NULL,
            ValueSize
        );

        if( ERROR_MORE_DATA != Error ) return Error;
        DhcpAssert(0 != *ValueSize);

        *Value = MemAlloc(*ValueSize);
        if( NULL == *Value ) {
            *ValueSize = 0;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            *Value,
            ValueSize
        );

        DhcpAssert(ERROR_MORE_DATA != Error);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( ERROR_SUCCESS != Error ) {
            MemFree(*Value);
            *Value = NULL;
            *ValueSize = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

//================================================================================
//  helper routines
//================================================================================

VOID
MemFreeFunc(                                      // free memory
    IN OUT  LPVOID                 Mem
)
{
    MemFree(Mem);
}

//
// ErrorNotInitialized used to be ZERO.. but why would we NOT return an error?
// so changed it to return errors..
//
#define ErrorNotInitialized        Err
#define STUB_NOT_INITIALIZED(Err)  ( !StubInitialized && ((Err) = StubInitialize()))

//DOC StubInitialize initializes all the modules involved in the dhcp ds dll.
//DOC It also sets a global variable StubInitialized to TRUE to indicate that
//DOC initialization went fine.  This should be called as part of DllInit so that
//DOC everything can be done at this point..
DWORD
StubInitialize(                                   // initialize all global vars
    VOID
)
{
    DWORD                          Err,Err2;
    STORE_HANDLE                   ConfigC;

    if( StubInitialized ) return ERROR_SUCCESS;   // already initialized

    Err = Err2 = ERROR_SUCCESS;
    EnterCriticalSection( &DhcpDsDllCriticalSection );
    do {
        if( StubInitialized ) break;
        Err = StoreInitHandle(
            /* hStore               */ &ConfigC,
            /* Reserved             */ DDS_RESERVED_DWORD,
            /* ThisDomain           */ NULL,      // current domain
            /* UserName             */ NULL,      // current user
            /* Password             */ NULL,      // current credentials
            /* AuthFlags            */ ADS_SECURE_AUTHENTICATION
            );
        if( ERROR_SUCCESS != Err ) {
            Err = ERROR_DDS_NO_DS_AVAILABLE;      // could not get config hdl
            break;
        }
        
        Err = DhcpDsGetDhcpC(
            DDS_RESERVED_DWORD, &ConfigC, &hDhcpC
            );
        
        if( ERROR_SUCCESS == Err ) {
            Err2 = DhcpDsGetRoot(                 // now try to get root handle
                DDS_FLAGS_CREATE, &ConfigC, &hDhcpRoot
                );
        }

        StoreCleanupHandle(&ConfigC, DDS_RESERVED_DWORD);
    } while (0);

    if( ERROR_SUCCESS != Err2 ) {                 // could not get dhcp root hdl
        DhcpAssert(ERROR_SUCCESS == Err);
        StoreCleanupHandle(&hDhcpC, DDS_RESERVED_DWORD);
        Err = Err2;
    }

    StubInitialized = (ERROR_SUCCESS == Err );
    LeaveCriticalSection( &DhcpDsDllCriticalSection );
    return Err;
}

//DOC StubCleanup de-initializes all the modules involved in the dhcp ds dll.
//DOC its effect is to undo everything done by StubInitialize
VOID
StubCleanup(                                      // undo StubInitialize
    VOID
)
{
    if( ! StubInitialized ) return;               // never initialized anyways
    EnterCriticalSection(&DhcpDsDllCriticalSection);
    if( StubInitialized ) {
        StoreCleanupHandle(&hDhcpC, DDS_RESERVED_DWORD);
        StoreCleanupHandle(&hDhcpRoot, DDS_RESERVED_DWORD);
        StubInitialized = FALSE;
    }
    LeaveCriticalSection(&DhcpDsDllCriticalSection);
}

//DOC DhcpDsLock is not yet implemented
DWORD
DhcpDsLock(                                       // lock the ds
    IN OUT  LPSTORE_HANDLE         hDhcpRoot      // dhcp root object to lock via
)
{

    EnterCriticalSection(&DhcpDsDllCriticalSection);
    
    return ERROR_SUCCESS;
}

//DOC DhcpDsUnlock not yet implemented
VOID
DhcpDsUnlock(
    IN OUT  LPSTORE_HANDLE         hDhcpRoot      // dhcp root object..
)
{
    LeaveCriticalSection(&DhcpDsDllCriticalSection);
}

//DOC GetServerNameFromAddr gets the server name given ip address
DWORD
GetServerNameFromAddr(                            // get server name from ip addr
    IN      DWORD                  IpAddress,     // look for server w/ this addr
    OUT     LPWSTR                *ServerName     // fill this with matching name
)
{
    DWORD                          Err, Err2;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         ThisStr, AllocStr;

    MemArrayInit(&Servers);
    Err = DhcpDsGetLists                          // get list of servers
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    ThisStr = NULL;
    for(                                          // find name for ip-address
        Err = MemArrayInitLoc(&Servers,&Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Servers, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //= ds inconsistent
        }

        ThisStr = ThisAttrib->String1;
        break;
    }

    AllocStr = NULL;
    if( NULL == ThisStr ) {                       // didnt find server name
        Err = ERROR_FILE_NOT_FOUND;
    } else {                                      // found the server name
        AllocStr = MemAlloc(sizeof(WCHAR)*(1+wcslen(ThisStr)));
        if( NULL == AllocStr ) {                  // couldnt alloc mem?
            Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {                                  // now just copy the str over
            wcscpy(AllocStr, ThisStr);
            Err = ERROR_SUCCESS;
        }
    }

    MemArrayFree(&Servers, MemFreeFunc);
    *ServerName = AllocStr;
    return Err;
}

//DOC GetServerNameFromStr gets the server name given ip address string
DWORD
GetServerNameFromStr(                             // get srvr name from ip string
    IN      LPWSTR                 Str,           // ip address string
    OUT     LPWSTR                *ServerName     // output the server name
)
{
    DWORD                          Err, Err2;
    DWORD                          IpAddress;
    CHAR                           IpAddressBuf[sizeof("000.000.000.000")];

    Err = wcstombs(IpAddressBuf, Str, sizeof(IpAddressBuf));
    if( -1 == Err ) {                             // could not convert address
        return ERROR_INVALID_DATA;
    }
    IpAddress = ntohl(inet_addr(IpAddressBuf));   // convert to DWORD Address, host order
    return GetServerNameFromAddr(IpAddress, ServerName);
}

//DOC TouchServer writes the "instancetype" attrib w/ default value so that the time
//DOC stamp on the server object is brought up to date..
DWORD
TouchServer(                                      // touch server object
    IN      LPSTORE_HANDLE         hServer
)
{
    DWORD                          nAttribs = 1;
    return StoreSetAttributesVA(
        hServer,0, &nAttribs,
        ADSTYPE_INTEGER, ADS_ATTR_UPDATE, ATTRIB_INSTANCE_TYPE, DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,
        ADSTYPE_INVALID
    );
}

//DOC GetServer translates the server ip address to a server object in DS.
DWORD
GetServer(                                        // get a server object frm ip-addr
    OUT     LPSTORE_HANDLE         hServer,       // fill up this object
    IN      LPWSTR                 Address        // server ip address
)
{
    DWORD                          Err, Err2;
    DWORD                          IpAddress;
    CHAR                           IpAddressBuf[sizeof("000.000.000.000")];
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         ServerLocation, ServerName;
    DWORD                          ServerGetType;

    if( NULL == Address ) {                       // if DhcpRoot object requested
        return DhcpDsGetRoot( 0, &hDhcpC, hServer );
    }
    Err = wcstombs(IpAddressBuf, Address, sizeof(IpAddressBuf));
    if( -1 == Err ) {                             // could not convert address
        return ERROR_INVALID_DATA;
    }
    IpAddress = ntohl(inet_addr(IpAddressBuf));   // convert to DWORD Address, host order

    MemArrayInit(&Servers);
    Err = DhcpDsGetLists                          // get list of servers
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ &hDhcpRoot,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ &Servers,      // array of PEATTRIB 's
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    ServerLocation = ServerName = NULL;           // havent found server yet
    for(                                          // find name for ip-address
        Err = MemArrayInitLoc(&Servers,&Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Servers, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_STRING1_PRESENT(ThisAttrib) ||    // no name for this server
            !IS_ADDRESS1_PRESENT(ThisAttrib) ) {  // no address for this server
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == IpAddress ) { // matching address?
            if( IS_ADSPATH_PRESENT(ThisAttrib) ) {// found location
                ServerLocation = ThisAttrib->ADsPath;
                ServerGetType = ThisAttrib->StoreGetType;
                ServerName = NULL;
                break;
            } else {                              // location not found
                ServerName = ThisAttrib->String1; // remember server name
            }
        }
    }

    if( NULL == ServerLocation ) {                // did not find location
        if( NULL == ServerName ) {                // did not find server name either
            MemArrayFree(&Servers, MemFreeFunc);
            return ERROR_DDS_DHCP_SERVER_NOT_FOUND;
        }
        ServerName = MakeColumnName(ServerName);  // make this into a "CN=X" types
        if( NULL == ServerName ) {                // could not allocate mme
            MemArrayFree(&Servers, MemFreeFunc);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ServerGetType = StoreGetChildType;        // search in hDhcpC container
        ServerLocation = ServerName;
    }

    Err = StoreGetHandle                          // now try to open server object
    (
        /* hStore               */ &hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ ServerGetType,
        /* Path                 */ ServerLocation,
        /* hStoreOut            */ hServer
    );

    MemArrayFree(&Servers, MemFreeFunc);
    if( ServerName ) MemFree(ServerName);

    if( ERROR_SUCCESS == Err ) {                  // update the last changed time on server
        TouchServer(hServer);
    }

    return Err;
}


//DOC GetSubnet translates an ip-address to a subnet object.
//DOC : if the subnet attrib does not have an ADsPath this does not guess..
DWORD
GetSubnet(
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    OUT     LPSTORE_HANDLE         hSubnet,       // fill this subnet object
    IN      DWORD                  IpAddress
)
{
    DWORD                          Err, Err2;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         SubnetLocation;
    DWORD                          SubnetGetType;

    MemArrayInit(&Subnets);
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hServer,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ &Subnets,      // array of PEATTRIB 's
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ NULL,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    SubnetLocation = NULL;
    for(                                          // find match for ip-address
        Err = MemArrayInitLoc(&Subnets,&Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Subnets, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Subnets, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no address for this subnet
            !IS_ADDRESS2_PRESENT(ThisAttrib) ) {  // no mask for this subnet
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == IpAddress ) { // matching address?
            if( IS_ADSPATH_PRESENT(ThisAttrib) ) {// found location
                SubnetLocation = ThisAttrib->ADsPath;
                SubnetGetType = ThisAttrib->StoreGetType;
                break;
            } else {                              // oops..  need to hdl this!
                MemArrayFree(&Subnets, MemFreeFunc);
                return ERROR_DDS_UNEXPECTED_ERROR;
            }
        }
    }

    if( NULL == SubnetLocation ) {                // did not find location
        MemArrayFree(&Subnets, MemFreeFunc);
        return ERROR_DDS_SUBNET_NOT_PRESENT;
    }

    Err = StoreGetHandle                          // now try to open server object
    (
        /* hStore               */ &hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ SubnetGetType,
        /* Path                 */ SubnetLocation,
        /* hStoreOut            */ hSubnet
    );

    MemArrayFree(&Subnets, MemFreeFunc);
    return Err;
}


//DOC GetReservationInternal translates an ip-address to a reservation object.
//DOC : if the Reservation attrib does not have an ADsPath this does not guess..
DWORD
GetReservationInternal(
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN OUT  LPSTORE_HANDLE         hReservation,  // fill this with reservation object
    IN      DWORD                  IpAddress      // reserved ip address to search for
)
{
    DWORD                          Err, Err2;
    ARRAY                          Res;
    ARRAY_LOCATION                 Loc;
    PEATTRIB                       ThisAttrib;
    LPWSTR                         ResLocation;
    DWORD                          ResGetType;

    MemArrayInit(&Res);
    Err = DhcpDsGetLists                          // get list of subnets
    (
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* hStore               */ hSubnet,
        /* RecursionDepth       */ 0xFFFFFFFF,
        /* Servers              */ NULL,
        /* Subnets              */ NULL,
        /* IpAddress            */ NULL,
        /* Mask                 */ NULL,
        /* Ranges               */ NULL,
        /* Sites                */ NULL,
        /* Reservations         */ &Res,
        /* SuperScopes          */ NULL,
        /* OptionDescription    */ NULL,
        /* OptionsLocation      */ NULL,
        /* Options              */ NULL,
        /* Classes              */ NULL
    );
    if( ERROR_SUCCESS != Err ) return Err;

    ResLocation = NULL;
    for(                                          // find match for ip-address
        Err = MemArrayInitLoc(&Res,&Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Res, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Res, &Loc, &ThisAttrib);
        //= require ERROR_SUCCESS == Err && NULL != ThisAttrib

        if( !IS_ADDRESS1_PRESENT(ThisAttrib) ||   // no address for this reservation
            !IS_BINARY1_PRESENT(ThisAttrib) ) {   // no client uid for this res.
            continue;                             //=  ds inconsistent
        }

        if( ThisAttrib->Address1 == IpAddress ) { // matching address?
            if( IS_ADSPATH_PRESENT(ThisAttrib) ) {// found location
                ResLocation = ThisAttrib->ADsPath;
                ResGetType = ThisAttrib->StoreGetType;
                break;
            } else {                              // oops..  need to hdl this!
                MemArrayFree(&Res, MemFreeFunc);
                return ERROR_DDS_UNEXPECTED_ERROR;
            }
        }
    }

    if( NULL == ResLocation ) {                  // did not find location
        MemArrayFree(&Res, MemFreeFunc);
        return ERROR_DDS_RESERVATION_NOT_PRESENT;
    }

    Err = StoreGetHandle                          // now try to open server object
    (
        /* hStore               */ &hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ ResGetType,
        /* Path                 */ ResLocation,
        /* hStoreOut            */ hReservation
    );

    MemArrayFree(&Res, MemFreeFunc);
    return Err;
}

//DOC GetReservation translates an ip-address to a subnet object.
//DOC : if the Reservation attrib does not have an ADsPath this does not guess..
DWORD
GetReservation(
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hReservation,  // fill this with reservation object
    IN      DWORD                  SubnetAddr,    // address of subnet
    IN      DWORD                  IpAddress
)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hSubnet;

    Err = GetSubnet(hServer, &hSubnet, SubnetAddr);
    if( ERROR_SUCCESS != Err) return Err;         // try to get the subnet obj first

    Err = GetReservationInternal(hServer, &hSubnet, hReservation, IpAddress);

    StoreCleanupHandle(&hSubnet, 0);
    return Err;
}

//DOC AddSubnetElementOld adds one of Excl,Ip Range or Reservation to the subnet
//DOC object specified in the DS.
DWORD
AddSubnetElementOld(                              // add excl/range/res. to subnet
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet obj in DS
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN      LPDHCP_SUBNET_ELEMENT_DATA Elt        // the element to add
)
{
    DWORD                          Err;

    if( DhcpIpRanges == Elt->ElementType ) {      // add a new range
        Err = DhcpDsSubnetAddRangeOrExcl          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.IpRange->StartAddress,
            /* End              */ Elt->Element.IpRange->EndAddress,
            /* RangeOrExcl      */ TRUE // range
        );
    } else if( DhcpExcludedIpRanges == Elt->ElementType ) {
        Err = DhcpDsSubnetAddRangeOrExcl          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.ExcludeIpRange->StartAddress,
            /* End              */ Elt->Element.ExcludeIpRange->EndAddress,
            /* RangeOrExcl      */ FALSE // excl
        );
    } else if( DhcpReservedIps == Elt->ElementType ) {
        Err = DhcpDsSubnetAddReservation          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* ReservedAddddr   */ Elt->Element.ReservedIp->ReservedIpAddress,
            /* HwAddr           */ Elt->Element.ReservedIp->ReservedForClient->Data,
            /* HwAddrLen        */ Elt->Element.ReservedIp->ReservedForClient->DataLength,
            /* ClientType       */ CLIENT_TYPE_DHCP
        );
    } else {
        Err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return Err;
}

//DOC AddSubnetElement adds one of Excl,Ip Range or Reservation to the subnet
//DOC object specified in the DS.
DWORD
AddSubnetElement(                                 // add excl/range/res. to subnet
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet obj in DS
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 Elt     // the element to add
)
{
    DWORD                          Err;

    if( DhcpIpRanges == Elt->ElementType ) {      // add a new range
        Err = DhcpDsSubnetAddRangeOrExcl          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.IpRange->StartAddress,
            /* End              */ Elt->Element.IpRange->EndAddress,
            /* RangeOrExcl      */ TRUE // range
        );
    } else if( DhcpExcludedIpRanges == Elt->ElementType ) {
        Err = DhcpDsSubnetAddRangeOrExcl          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.ExcludeIpRange->StartAddress,
            /* End              */ Elt->Element.ExcludeIpRange->EndAddress,
            /* RangeOrExcl      */ FALSE // excl
        );
    } else if( DhcpReservedIps == Elt->ElementType ) {
        Err = DhcpDsSubnetAddReservation          // add its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* ReservedAddddr   */ Elt->Element.ReservedIp->ReservedIpAddress,
            /* HwAddr           */ Elt->Element.ReservedIp->ReservedForClient->Data,
            /* HwAddrLen        */ Elt->Element.ReservedIp->ReservedForClient->DataLength,
            /* ClientType       */ Elt->Element.ReservedIp->bAllowedClientTypes
        );
    } else {
        Err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return Err;
}

//DOC DelSubnetElementOld deltes one of Excl,Ip Range or Reservation to frm subnet
//DOC object specified in the DS.
DWORD
DelSubnetElementOld(                              // del excl/range/res. frm subnet
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet obj in DS
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN      LPDHCP_SUBNET_ELEMENT_DATA Elt        // the element to add
)
{
    DWORD                          Err;

    if( DhcpIpRanges == Elt->ElementType ) {      // del a new range
        Err = DhcpDsSubnetDelRangeOrExcl          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.IpRange->StartAddress,
            /* End              */ Elt->Element.IpRange->EndAddress,
            /* RangeOrExcl      */ TRUE // range
        );
    } else if( DhcpExcludedIpRanges == Elt->ElementType ) {
        Err = DhcpDsSubnetDelRangeOrExcl          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.ExcludeIpRange->StartAddress,
            /* End              */ Elt->Element.ExcludeIpRange->EndAddress,
            /* RangeOrExcl      */ FALSE // excl
        );
    } else if( DhcpReservedIps == Elt->ElementType ) {
        Err = DhcpDsSubnetDelReservation          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* ReservedAddddr   */ Elt->Element.ReservedIp->ReservedIpAddress
        );
    } else {
        Err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return Err;
}

//DOC DelSubnetElement deltes one of Excl,Ip Range or Reservation to frm subnet
//DOC object specified in the DS.
DWORD
DelSubnetElement(                                 // del excl/range/res. frm subnet
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet obj in DS
    IN      LPWSTR                 ServerName,    // name of dhcp server
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 Elt     // the element to add
)
{
    DWORD                          Err;

    if( DhcpIpRanges == Elt->ElementType ) {      // del a new range
        Err = DhcpDsSubnetDelRangeOrExcl          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.IpRange->StartAddress,
            /* End              */ Elt->Element.IpRange->EndAddress,
            /* RangeOrExcl      */ TRUE // range
        );
    } else if( DhcpExcludedIpRanges == Elt->ElementType ) {
        Err = DhcpDsSubnetDelRangeOrExcl          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Start            */ Elt->Element.ExcludeIpRange->StartAddress,
            /* End              */ Elt->Element.ExcludeIpRange->EndAddress,
            /* RangeOrExcl      */ FALSE // excl
        );
    } else if( DhcpReservedIps == Elt->ElementType ) {
        Err = DhcpDsSubnetDelReservation          // del its
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ hServer,
            /* hSubnet          */ hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* ReservedAddddr   */ Elt->Element.ReservedIp->ReservedIpAddress
        );
    } else {
        Err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return Err;
}


//================================================================================
//  the following functions are NOT based on RPC, but actually direct calls to
//  the DS. But, they have the same interface as the RPC stubs in dhcpsapi.dll.
//================================================================================

//================================================================================
//  Names for functions here and in dhcpsapi.dll should not be same. So, here is
//  a bunch of hash defines to take care fo that problem..
//================================================================================

//BeginExport(defines)
#ifndef CONVERT_NAMES
#define DhcpCreateSubnet DhcpCreateSubnetDS
#define DhcpSetSubnetInfo DhcpSetSubnetInfoDS
#define DhcpGetSubnetInfo DhcpGetSubnetInfoDS
#define DhcpEnumSubnets DhcpEnumSubnetsDS
#define DhcpDeleteSubnet DhcpDeleteSubnetDS
#define DhcpCreateOption DhcpCreateOptionDS
#define DhcpSetOptionInfo DhcpSetOptionInfoDS
#define DhcpGetOptionInfo DhcpGetOptionInfoDS
#define DhcpRemoveOption DhcpRemoveOptionDS
#define DhcpSetOptionValue DhcpSetOptionValueDS
#define DhcpGetOptionValue DhcpGetOptionValueDS
#define DhcpEnumOptionValues DhcpEnumOptionValuesDS
#define DhcpRemoveOptionValue DhcpRemoveOptionValueDS
#define DhcpEnumOptions DhcpEnumOptionsDS
#define DhcpSetOptionValues DhcpSetOptionValuesDS
#define DhcpAddSubnetElement DhcpAddSubnetElementDS
#define DhcpEnumSubnetElements DhcpEnumSubnetElementsDS
#define DhcpRemoveSubnetElement DhcpRemoveSubnetElementDS
#define DhcpAddSubnetElementV4 DhcpAddSubnetElementV4DS
#define DhcpEnumSubnetElementsV4 DhcpEnumSubnetElementsV4DS
#define DhcpRemoveSubnetElementV4 DhcpRemoveSubnetElementV4DS
#define DhcpSetSuperScopeV4 DhcpSetSuperScopeV4DS
#define DhcpGetSuperScopeInfoV4 DhcpGetSuperScopeInfoV4DS
#define DhcpDeleteSuperScopeV4 DhcpDeleteSuperScopeV4DS

#define DhcpSetClientInfo DhcpSetClientInfoDS
#define DhcpGetClientInfo DhcpGetClientInfoDS
#define DhcpSetClientInfoV4 DhcpSetClientInfoV4DS
#define DhcpGetClientInfoV4 DhcpGetClientInfoV4DS

#define DhcpCreateOptionV5 DhcpCreateOptionV5DS
#define DhcpSetOptionInfoV5 DhcpSetOptionInfoV5DS
#define DhcpGetOptionInfoV5 DhcpGetOptionInfoV5DS
#define DhcpEnumOptionsV5 DhcpEnumOptionsV5DS
#define DhcpRemoveOptionV5 DhcpRemoveOptionV5DS
#define DhcpSetOptionValueV5 DhcpSetOptionValueV5DS
#define DhcpSetOptionValuesV5 DhcpSetOptionValuesV5DS
#define DhcpGetOptionValueV5 DhcpGetOptionValueV5DS
#define DhcpEnumOptionValuesV5 DhcpEnumOptionValuesV5DS
#define DhcpRemoveOptionValueV5 DhcpRemoveOptionValueV5DS
#define DhcpCreateClass DhcpCreateClassDS
#define DhcpModifyClass DhcpModifyClassDS
#define DhcpDeleteClass DhcpDeleteClassDS
#define DhcpGetClassInfo DhcpGetClassInfoDS
#define DhcpEnumClasses DhcpEnumClassesDS
#define DhcpGetAllOptions DhcpGetAllOptionsDS
#define DhcpGetAllOptionValues DhcpGetAllOptionValuesDS

#endif  CONVERT_NAMES
//EndExport(defines)

BOOLEAN
DhcpDsDllInit(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:
    This routine is the standard DLL initialization
    routine and all it does is intiialize a critical section
    for actual initialization to be done at startup elsewhere.

Arguments:
    DllHandle -- handle to current module
    Reason -- reason for DLL_PROCESS_ATTACH.. DLL_PROCESS_DETACH

Return Value:
    TRUE -- success, FALSE -- failure

--*/
{
    if( DLL_PROCESS_ATTACH == Reason ) {
        //
        // First disable further calls to DllInit
        //
        if( !DisableThreadLibraryCalls( DllHandle ) ) return FALSE;

        //
        // Now try to create critical section
        //
        try {
            InitializeCriticalSection(&DhcpDsDllCriticalSection);
        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            // shouldnt happen but you never know.
            return FALSE;
        }

    } else if( DLL_PROCESS_DETACH == Reason ) {
        //
        // Cleanup the initialization critical section
        //
        DeleteCriticalSection(&DhcpDsDllCriticalSection);
    }

    //
    // InitializeCriticalSection does not fail, just throws exception..
    // so we always return success.
    //
    return TRUE;
}

//================================================================================
//================================================================================
//  OPTIONS STUFF.  Several of the "get" api's are not yet implemneted here.. but
//  it is a straigthforward thing to call the DhcpDs versions... they will get
//  filled here someday soon.
//================================================================================
//================================================================================

//BeginExport(function)
//DOC Create an option in DS. Checkout DhcpDsCreateOptionDef for more info...
DWORD
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPBYTE                         OptVal;
    DWORD                          OptLen, OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;


    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);
    Err = ConvertOptionInfoRPCToMemFormat(OptionInfo, NULL, NULL, NULL, &OptVal, &OptLen);
    if( ERROR_SUCCESS != Err ) {                  // could not convert to easy format
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        if( OptVal ) MemFree(OptVal);
        return Err;
    }

    Err = DhcpDsCreateOptionDef                   // create the required option
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* Name                 */ OptionInfo->OptionName,
        /* Comment              */ OptionInfo->OptionComment,
        /* ClassName            */ VendorName,
        /* OptId                */ OptId,
        /* OptType              */ OptionInfo->OptionType,
        /* OptVal               */ OptVal,
        /* OptLen               */ OptLen
    );

    if( OptVal ) MemFree(OptVal);
    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Modify existing option's fields in the DS. See DhcpDsModifyOptionDef for more
//DOC details
DWORD
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPBYTE                         OptVal;
    DWORD                          OptLen, OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( STUB_NOT_INITIALIZED(Err)) return ErrorNotInitialized;
    
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;


    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);
    Err = ConvertOptionInfoRPCToMemFormat(OptionInfo, NULL, NULL, NULL, &OptVal, &OptLen);
    if( ERROR_SUCCESS != Err ) {                  // could not convert to easy format
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        if( OptVal ) MemFree(OptVal);
        return Err;
    }

    Err = DhcpDsModifyOptionDef                   // modify the required option
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* Name                 */ OptionInfo->OptionName,
        /* Comment              */ OptionInfo->OptionComment,
        /* ClassName            */ VendorName,
        /* OptId                */ OptId,
        /* OptType              */ OptionInfo->OptionType,
        /* OptVal               */ OptVal,
        /* OptLen               */ OptLen
    );

    if( OptVal ) MemFree(OptVal);
    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC not yet supported at this level... (this is supported in a
//DOC DhcpDs function, no wrapper yet)
DWORD
DhcpGetOptionInfoV5(                              // retrieve option info from off ds structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPBYTE                         OptVal;
    DWORD                          OptLen, OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    OptionId = ConvertOptIdToMemValue(OptionId, IsVendor);

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsGetOptionDef                      // get the option info from DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* OptId                */ OptionId,
        /* OptInfo              */ OptionInfo
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}
//BeginExport(function)
//DOC See DhcpDsEnumOptionDefs for more info on this function.. but essentially, all this
//DOC does is to read thru the options and create a list of options..
DWORD
DhcpEnumOptionsV5(                                // create list of all options in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == OptionsRead || NULL == OptionsTotal
        || NULL == Options || NULL == ResumeHandle ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsEnumOptionDefs                    // get opt list from ds
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* IsVendor             */ IsVendor,
        /* RetOptArray          */ Options
    );
    if( ERROR_SUCCESS == Err ) {
        *OptionsRead = (*Options)->NumElements;
        *OptionsTotal = *OptionsRead;
    }

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Delete an option from off the DS. See DhcpDsDeleteOptionDef for
//DOC more details.
DWORD
DhcpRemoveOptionV5(                               // remove an option from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    DWORD                          OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;


    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsDeleteOptionDef                   // delete the required option
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* OptId                */ OptId
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Set the specified option value in the DS.  For more information,
//DOC see DhcpDsSetOptionValue.
DWORD
DhcpSetOptionValueV5(                             // set the option value in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_CALL_NOT_IMPLEMENTED;
#if 0
        return DhcpSetOptionInfoV5(               // setting default options?
            ServerIpAddress,
            OptionId,
            ClassName,
            IsVendor,
            OptionInfo
        );
#endif
    }

    if( NULL == OptionValue ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);
    Err = DhcpDsSetOptionValue                    // set the option value in DS now
    (
        /* hDhcpC               */ &hDhcpC,
        /* hObject              */ hObject,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* UserClass            */ ClassName,
        /* OptId                */ OptId,
        /* OptData              */ OptionValue
    );

    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function just calls the SetOptionValue function N times.. this is not
//DOC atomic (), but even worse, it is highly inefficient, as it creates the
//DOC required objects over and over again!!!!!
//DOC This has to be fixed..
DWORD
DhcpSetOptionValuesV5(                            // set a series of option values
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId, i, OptionId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_CALL_NOT_IMPLEMENTED;
#if 0
        for( i = 0; i < OptionValues->NumElements; i ++ ) {
            Err = DhcpSetOptionInfoV5(            // setting default options?
                ServerIpAddress,
                OptionValues->Values[i].OptionID,
                ClassName,
                IsVendor,
                &OptionValues->Values[i].Value
            );
            if( ERROR_SUCCESS != Err ) break;
        }
        return Err;
#endif
    }

    if( NULL == OptionValues ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    for( i = 0; i < OptionValues->NumElements; i ++ ) {
        OptionId = OptionValues->Values[i].OptionID;
        OptId = ConvertOptIdToMemValue(OptionId, IsVendor);
        Err = DhcpDsSetOptionValue                // set the option value in DS now
        (
            /* hDhcpC           */ &hDhcpC,
            /* hObject          */ hObject,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ClassName        */ VendorName,
            /* UserClass        */ ClassName,
            /* OptId            */ OptId,
            /* OptData          */ &OptionValues->Values[i].Value
        );
        if( ERROR_SUCCESS != Err ) break;         // not atomic, so break whenever err
    }

    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function retrives the value of an option from the DS.  For more info,
//DOC pl check DhcpDsGetOptionValue.
DWORD
DhcpGetOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_CALL_NOT_IMPLEMENTED;
#if 0
        return DhcpGetOptionInfoV5(               // getting default options?
            ServerIpAddress,
            OptionId,
            ClassName,
            IsVendor,
            OptionValue
        );
#endif 0
    }

    if( NULL == OptionValue ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = DhcpDsGetOptionValue                    // get the option value in DS now
    (
        /* hDhcpC               */ &hDhcpC,
        /* hObject              */ hObject,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* UserClass            */ ClassName,
        /* OptId                */ OptId,
        /* OptData              */ OptionValue
    );


    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Get the list of option values defined in DS. For more information,
//DOC check DhcpDsEnumOptionValues.
DWORD
DhcpEnumOptionValuesV5(                           // get list of options defined in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_INVALID_PARAMETER;           // : totally suspcicious..
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = DhcpDsEnumOptionValues                  // remove opt val frm DS now
    (
        /* hDhcpC               */ &hDhcpC,
        /* hObject              */ hObject,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* UserClass            */ ClassName,
        /* IsVendor             */ IsVendor,
        /* OptionValues         */ OptionValues
    );
    if( ERROR_SUCCESS == Err ) {                  // set the read etc params
        *OptionsRead = *OptionsTotal = (*OptionValues)->NumElements;
    }

    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Remove the option value from off the DS.  See DhcpDsRemoveOptionValue
//DOC for further information.
DWORD
DhcpRemoveOptionValueV5(                          // remove option value from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId;
    BOOL                           IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));

    if( Flags & ~DHCP_FLAGS_OPTION_IS_VENDOR ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_INVALID_PARAMETER;           // : totally suspcicious..
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = DhcpDsRemoveOptionValue                 // remove opt val frm DS now
    (
        /* hDhcpC               */ &hDhcpC,
        /* hObject              */ hObject,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ VendorName,
        /* UserClass            */ ClassName,
        /* OptId                */ OptId
    );

    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Create a class in the DS.  Please see DhcpDsCreateClass for more
//DOC details on this function.
DWORD
DhcpCreateClass(                                  // create a class in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == ClassInfo || 0 != ReservedMustBeZero ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsCreateClass                       // create the class
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ ClassInfo->ClassName,
        /* ClassComment         */ ClassInfo->ClassComment,
        /* ClassData            */ ClassInfo->ClassData,
        /* ClassDataLength      */ ClassInfo->ClassDataLength,
        /* IsVendor             */ ClassInfo->IsVendor
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Modify an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpModifyClass(                                  // modify existing class
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == ClassInfo || 0 != ReservedMustBeZero ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsModifyClass                       // modify the class
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ ClassInfo->ClassName,
        /* ClassComment         */ ClassInfo->ClassComment,
        /* ClassData            */ ClassInfo->ClassData,
        /* ClassDataLength      */ ClassInfo->ClassDataLength
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Delete an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpDeleteClass(                                  // delete a class from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == ClassName || 0 != ReservedMustBeZero ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsDeleteClass                       // delete the class
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ ClassName
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC DhcpGetClassInfo completes the information provided for a class in struct
//DOC PartialClassInfo.  For more details pl see DhcpDsGetClassInfo.
DWORD
DhcpGetClassInfo(                                 // fetch complete info frm DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == PartialClassInfo || 0 != ReservedMustBeZero ) {
        return ERROR_INVALID_PARAMETER;
    }
    if( NULL == FilledClassInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsGetClassInfo                      // get class info from DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ClassName            */ PartialClassInfo->ClassName,
        /* ClassData            */ PartialClassInfo->ClassData,
        /* ClassDataLen         */ PartialClassInfo->ClassDataLength,
        /* ClassInfo            */ FilledClassInfo
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == ClassInfoArray ) return ERROR_INVALID_PARAMETER;
    *nRead = *nTotal = 0;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsEnumClasses                       // get list of classes
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* Classes              */ ClassInfoArray
    );
    if( ERROR_SUCCESS == Err ) {                  // filled nRead&nTotal
        *nRead = *nTotal = (*ClassInfoArray)->NumElements;
    }

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;

}

//BeginExport(function)
//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet,hReservation;
    LPSTORE_HANDLE                 hObject;
    DWORD                          OptId;

    if( 0 != Flags ) return ERROR_INVALID_PARAMETER;

    if( NULL == ScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if( NULL == Values ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    if( DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        hObject = &hServer;                       // server level options
        Err = ERROR_SUCCESS;
    } else {
        if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
            Err = GetSubnet(&hServer, &hSubnet, ScopeInfo->ScopeInfo.SubnetScopeInfo);
            hObject = &hSubnet;                   // subnet level options
        } else if( DhcpReservedOptions != ScopeInfo->ScopeType ) {
            Err = ERROR_INVALID_PARAMETER;
        } else {                                  // reservation level options
            Err = GetReservation(
                &hServer,
                &hReservation,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress,
                ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress
            );
            hObject = &hReservation;
        }
    }
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = DhcpDsGetAllOptionValues                // get all the option values from DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hObject              */ hObject,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* Values               */ Values
    );

    StoreCleanupHandle(&hServer, 0);
    if( hObject != &hServer ) StoreCleanupHandle(hObject, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This is implememented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( NULL == Options || 0 != Flags ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsGetAllOptions                     // get opt list from ds
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* Options              */ Options
    );

    StoreCleanupHandle(&hServer, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//================================================================================
//  NT 5 beta1 and before -- the stubs for those are here...
//================================================================================
//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOption(                                 // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return DhcpCreateOptionV5(
        ServerIpAddress,
        0,
        OptionId,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfo(                                // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return DhcpSetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfo(                                // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) //EndExport(function)
{
    return DhcpGetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptions(                                  // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) //EndExport(function)
{
    return DhcpEnumOptionsV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOption(                                 // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) //EndExport(function)
{
    return DhcpRemoveOptionV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL
    );
}

//BeginExport(function)
DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValue(                               // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    return DhcpSetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD                                             // not atomic!!!!
DhcpSetOptionValues(                              // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) //EndExport(function)
{
    return DhcpSetOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        OptionValues
    );
}

//BeginExport(function)
DWORD
DhcpGetOptionValue(                               // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) //EndExport(function)
{
    return DhcpGetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD
DhcpEnumOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    return DhcpEnumOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD
DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    return DhcpRemoveOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo
    );
}

//================================================================================
//================================================================================
//  The following are the miscellaneous APIs found in rpcapi2.c.  Most of the
//  following APIs are not really implementable with the DS alone, and so they
//  just return error.  They are provided here so that the dhcpds.dll can be linked
//  to the dhcpcmd.exe program instead of the other dll.
//================================================================================
//================================================================================

//BeginExport(function)
//DOC This function sets the superscope of a subnet, thereby creating the superscope
//DOC if required.  Please see DhcpDsSetSScope for more details.
DWORD
DhcpSetSuperScopeV4(                              // set superscope in DS.
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsSetSScope                         // set the sscope in DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* IpAddress            */ SubnetAddress,
        /* SScopeName           */ SuperScopeName,
        /* ChangeSScope         */ ChangeExisting
    );

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function removes the superscope, and resets any subnet with this
//DOC superscope.. so that all those subnets end up with no superscopes..
//DOC Please see DhcpDsDelSScope for more details.
DWORD
DhcpDeleteSuperScopeV4(                           // delete subnet sscope from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsDelSScope                         // delete the sscope in DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* SScopeName           */ SuperScopeName
    );

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function retrievs the supercsope info for each subnet that is
//DOC present for the given server.  Please see DhcpDsGetSScopeInfo for more
//DOC details on this..
DWORD
DhcpGetSuperScopeInfoV4(                          // get sscope tbl from DS
    IN      LPWSTR                 ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = DhcpDsGetSScopeInfo                     // get sscope tbl frm DS
    (
        /* hDhcpC               */ &hDhcpC,
        /* hServer              */ &hServer,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* SScopeTbl            */ SuperScopeTable
    );

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function creates a subnet in the DS with the specified params.
//DOC Please see DhcpDsServerAddSubnet for more details on this function.
DWORD
DhcpCreateSubnet(                                 // add subnet 2 DS for this srvr
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsServerAddSubnet               // add a new subnet to this srvr
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Info             */ SubnetInfo
        );
        MemFree(ServerName);
    }

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Modify existing subnet with new parameters... some restrictions apply.
//DOC Please see DhcpDsServerModifySubnet for further details.
DWORD
DhcpSetSubnetInfo(                                // modify existing subnet params
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsServerModifySubnet            // modify subnet for this srvr
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* Info             */ SubnetInfo
        );
        MemFree(ServerName);
    }

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpGetSubnetInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsServerGetSubnetInfo           // get subnet info for server
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* SubnetAddress    */ SubnetAddress,
            /* Info             */ SubnetInfo
        );
        MemFree(ServerName);
    }

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpEnumSubnets(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    *EnumInfo = NULL;
    *ElementsRead = *ElementsTotal = 0;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsServerEnumSubnets             // enum subnets for this srvr
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* SubnetsArray     */ EnumInfo
        );
        MemFree(ServerName);
        if( ERROR_SUCCESS == Err ) {
            *ElementsTotal = (*EnumInfo)->NumElements;
            *ElementsRead = *ElementsTotal;
        }
    }

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function deletes the subnet from the DS.  For further information, pl
//DOC see DhcpDsServerDelSubnet..
DWORD
DhcpDeleteSubnet(                                 // Del subnet from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsServerDelSubnet               // Del subnet for this srvr
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* IpAddress        */ SubnetAddress
        );
        MemFree(ServerName);
    }

    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This function sets some particular information for RESERVATIONS only
//DOC all other stuff it just ignores and returns success..
DWORD
DhcpSetClientInfo(
    IN      LPWSTR                 ServerIpAddresess,
    IN      LPDHCP_CLIENT_INFO     ClientInfo
)   //EndExport(function)
{
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC This function retrieves some particular client's information
//DOC for RESERVATIONS only.. For all other stuff it returns CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_SEARCH_INFO     SearchInfo,
    OUT      LPDHCP_CLIENT_INFO    *ClientInfo
)   //EndExport(function)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//BeginExport(function)
//DOC This function sets the client informatoin for RESERVATIONS only in DS
//DOC For all toher clients it returns ERROR_SUCCESS w/o doing anything
DWORD
DhcpSetClientInfoV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_CLIENT_INFO_V4  ClientInfo
)   //EndExport(function)
{
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC Thsi function sets the client information for RESERVATIONS only
//DOC For all others it returns ERROR_CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfoV4(
    IN     LPWSTR                  ServerIpAddress,
    IN     LPDHCP_SEARCH_INFO      SearchInfo,
    OUT    LPDHCP_CLIENT_INFO_V4  *ClientInfo
)   //EndExport(function)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//BeginExport(function)
//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElement(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA  AddElementInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( NULL == AddElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetSubnet(&hServer, &hSubnet, SubnetAddress);
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = AddSubnetElementOld(                // now add subnet to DS
            &hServer,
            &hSubnet,
            ServerName,
            AddElementInfo
        );
        MemFree(ServerName);
    }

    StoreCleanupHandle(&hServer, 0);
    StoreCleanupHandle(&hSubnet, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;

}

//BeginExport(function)
//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( NULL == AddElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetSubnet(&hServer, &hSubnet, SubnetAddress);
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = AddSubnetElement(                   // now add subnet to DS
            &hServer,
            &hSubnet,
            ServerName,
            AddElementInfo
        );
        MemFree(ServerName);
    }

    StoreCleanupHandle(&hServer, 0);
    StoreCleanupHandle(&hSubnet, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;

}

//BeginExport(function)
//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElementsV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    *ElementsRead = *ElementsTotal = 0;

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetSubnet(&hServer, &hSubnet, SubnetAddress);
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DhcpDsEnumSubnetElements            // enumerate subnet elements..
        (
            /* hDhcpC           */ &hDhcpC,
            /* hServer          */ &hServer,
            /* hSubnet          */ &hSubnet,
            /* Reserved         */ DDS_RESERVED_DWORD,
            /* ServerName       */ ServerName,
            /* ElementType      */ EnumElementType,
            /* EnumElementInfo  */ EnumElementInfo
        );
        if( ERROR_SUCCESS == Err ) {
            *ElementsRead = *ElementsTotal = (*EnumElementInfo)->NumElements;
        }

        MemFree(ServerName);
    }

    StoreCleanupHandle(&hServer, 0);
    StoreCleanupHandle(&hSubnet, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}

//BeginExport(function)
//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElements(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pEnumElementInfoV4;
    DWORD                          Result;

    pEnumElementInfoV4 = NULL;
    Result = DhcpEnumSubnetElementsV4(
        ServerIpAddress,
        SubnetAddress,
        EnumElementType,
        ResumeHandle,
        PreferredMaximum,
        &pEnumElementInfoV4,
        ElementsRead,
        ElementsTotal
    );
    if( ERROR_SUCCESS == Result || ERROR_MORE_DATA == Result ) {
        // since the only difference between DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 and
        // DHCP_SUBNET_ELEMENT_INFO_ARRAY are a couple of fields at the end of the
        // embedded DHCP_IP_RESERVATION_V4 struct, it is safe to simply return the
        // V4 struct.

        *EnumElementInfo = ( DHCP_SUBNET_ELEMENT_INFO_ARRAY *) pEnumElementInfoV4;
    } else {
        DhcpAssert( !pEnumElementInfoV4 );
    }

    return Result;
}


//BeginExport(function)
//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElement(                          // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( NULL == RemoveElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetSubnet(&hServer, &hSubnet, SubnetAddress);
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DelSubnetElementOld(                // now del subnt elt frm DS
            &hServer,
            &hSubnet,
            ServerName,
            RemoveElementInfo
        );
        MemFree(ServerName);
    }

    StoreCleanupHandle(&hServer, 0);
    StoreCleanupHandle(&hSubnet, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;
}


//BeginExport(function)
//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElementV4(                        // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer,hSubnet;
    LPWSTR                         ServerName;

    if( NULL == RemoveElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( STUB_NOT_INITIALIZED(Err) ) return ErrorNotInitialized;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = GetServer(&hServer, ServerIpAddress );
    if( ERROR_SUCCESS != Err ) {                  // get the server object
        DhcpDsUnlock(&hDhcpRoot);
        return Err;
    }

    Err = GetSubnet(&hServer, &hSubnet, SubnetAddress);
    if( ERROR_SUCCESS != Err ) {
        DhcpDsUnlock(&hDhcpRoot);
        StoreCleanupHandle(&hServer, 0);
        return Err;
    }

    Err = GetServerNameFromStr(ServerIpAddress, &ServerName);
    if( ERROR_SUCCESS == Err ) {
        Err = DelSubnetElement(                   // now del subnt elt frm DS
            &hServer,
            &hSubnet,
            ServerName,
            RemoveElementInfo
        );
        MemFree(ServerName);
    }

    StoreCleanupHandle(&hServer, 0);
    StoreCleanupHandle(&hSubnet, 0);
    DhcpDsUnlock(&hDhcpRoot);
    return Err;

}

//================================================================================
//  get rid of the defines so far as exports are concerned. (rpcstubs.h)
//================================================================================
//BeginExport(defines)
#ifndef CONVERT_NAMES
#undef DhcpCreateSubnet
#undef DhcpSetSubnetInfo
#undef DhcpGetSubnetInfo
#undef DhcpEnumSubnets
#undef DhcpDeleteSubnet
#undef DhcpCreateOption
#undef DhcpSetOptionInfo
#undef DhcpGetOptionInfo
#undef DhcpRemoveOption
#undef DhcpSetOptionValue
#undef DhcpGetOptionValue
#undef DhcpEnumOptionValues
#undef DhcpRemoveOptionValue
#undef DhcpEnumOptions
#undef DhcpSetOptionValues
#undef DhcpAddSubnetElementV4
#undef DhcpEnumSubnetElementsV4
#undef DhcpRemoveSubnetElementV4
#undef DhcpAddSubnetElement
#undef DhcpEnumSubnetElements
#undef DhcpRemoveSubnetElement
#undef DhcpSetSuperScopeV4
#undef DhcpGetSuperScopeInfoV4
#undef DhcpDeleteSuperScopeV4

#undef DhcpSetClientInfo
#undef DhcpGetClientInfo
#undef DhcpSetClientInfoV4
#undef DhcpGetClientInfoV4

#undef DhcpCreateOptionV5
#undef DhcpSetOptionInfoV5
#undef DhcpGetOptionInfoV5
#undef DhcpEnumOptionsV5
#undef DhcpRemoveOptionV5
#undef DhcpSetOptionValueV5
#undef DhcpSetOptionValuesV5
#undef DhcpGetOptionValueV5
#undef DhcpEnumOptionValuesV5
#undef DhcpRemoveOptionValueV5
#undef DhcpCreateClass
#undef DhcpModifyClass
#undef DhcpDeleteClass
#undef DhcpGetClassInfo
#undef DhcpEnumClasses
#undef DhcpGetAllOptions
#undef DhcpGetAllOptionValues
#endif CONVERT_NAMES
//EndExport(defines)

//BeginExport(typedef)
#define     DHCP_SERVER_ANOTHER_ENTERPRISE        0x01
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;
//EndExport(typedef)

//================================================================================
//  DS only NON-rpc stubs
//================================================================================

//BeginExport(function)
//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2, Size,i;
    LPDHCPDS_SERVERS               DhcpDsServers;

    AssertRet(Servers, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);
    *Servers = NULL;

    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    DhcpDsServers = NULL;
    Err = DhcpDsEnumServers                       // get the list of servers
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServersInfo          */ &DhcpDsServers
    );

    DhcpDsUnlock(&hDhcpRoot);

    if( ERROR_SUCCESS != Err ) return Err;        // return err..

    *Servers = DhcpDsServers;
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2;
    WCHAR                          TmpBuf[sizeof(L"000.000.000.000")];
    
    AssertRet(NewServer, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);
    
    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = DhcpDsAddServer                         // add the new server
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ NewServer->ServerName,
        /* ReservedPtr          */ DDS_RESERVED_PTR,
        /* IpAddress            */ NewServer->ServerAddress,
        /* State                */ Flags
    );

    DhcpDsUnlock(&hDhcpRoot);

    return Err;
}

//BeginExport(function)
//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) //EndExport(function)
{
    DWORD                          Err, Err2;

    AssertRet(NewServer, ERROR_INVALID_PARAMETER);
    AssertRet(!Flags, ERROR_INVALID_PARAMETER);

    if( STUB_NOT_INITIALIZED(Err) ) return ERROR_DDS_NO_DS_AVAILABLE;
    Err = DhcpDsLock(&hDhcpRoot);                 // take a lock on the DS
    if( ERROR_SUCCESS != Err ) return ERROR_DDS_NO_DS_AVAILABLE;

    Err = DhcpDsDelServer                         // del this server
    (
        /* hDhcpC               */ &hDhcpC,
        /* hDhcpRoot            */ &hDhcpRoot,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ NewServer->ServerName,
        /* ReservedPtr          */ DDS_RESERVED_PTR,
        /* IpAddress            */ NewServer->ServerAddress
    );

    DhcpDsUnlock(&hDhcpRoot);

    return Err;
}

//BeginExport(function)
//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) //EndExport(function)
{
    return StubInitialize();
}

//BeginExport(function)
//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) //EndExport(function)
{
    StubCleanup();
}

//BeginExport(header)
//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//DOC DhcpDsGetLastUpdateTime is defined in upndown.c --> see there for more details.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
);
//EndExport(header)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\rpcapi2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef _DHCPDS_RPCAPI2_H
#define _DHCPDS_RPCAPI2_H

//DOC DhcpDsAddServer adds a server's entry in the DS.  Note that only the name
//DOC uniquely determines the server. There can be one server with many ip addresses.
//DOC If the server is created first time, a separate object is created for the
//DOC server. TO DO: The newly added server should also have its data
//DOC updated in the DS uploaded from the server itself if it is still up.
//DOC Note that it takes as parameter the Dhcp root container.
//DOC If the requested address already exists in the DS (maybe to some other
//DOC server), then the function returns ERROR_DDS_SERVER_ALREADY_EXISTS
DWORD
DhcpDsAddServer(                                  // add a server in DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, future use
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ReservedPtr,   // Server location? future use
    IN      DWORD                  IpAddress,     // ip address of server
    IN      DWORD                  State          // currently un-interpreted
) ;


//DOC DhcpDsDelServer removes the requested servername-ipaddress pair from the ds.
//DOC If this is the last ip address for the given servername, then the server
//DOC is also removed from memory.  But objects referred by the Server are left in
//DOC the DS as they may also be referred to from else where.  This needs to be
//DOC fixed via references being tagged as direct and symbolic -- one causing deletion
//DOC and other not causing any deletion.  THIS NEEDS TO BE FIXED. 
DWORD
DhcpDsDelServer(                                  // Delete a server from memory
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 ServerName,    // which server to delete for
    IN      LPWSTR                 ReservedPtr,   // server location ? future use
    IN      DWORD                  IpAddress      // the IpAddress to delete..
) ;


BOOL
DhcpDsLookupServer(                               // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 LookupServerIP,// Server to lookup IP
    IN      LPWSTR                 HostName      // Hostname to lookup
);

//DOC DhcpDsEnumServers retrieves a bunch of information about each server that
//DOC has an entry in the Servers attribute of the root object. There are no guarantees
//DOC on the order..
//DOC The memory for this is allocated in ONE shot -- so the output can be freed in
//DOC one shot too.
//DOC
DWORD
DhcpDsEnumServers(                                // get info abt all existing servers
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for dhcp objects
    IN OUT  LPSTORE_HANDLE         hDhcpRoot,     // dhcp root object handle
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCPDS_SERVERS      *ServersInfo    // array of servers
) ;


//DOC DhcpDsSetSScope modifies the superscope that a subnet belongs to.
//DOC The function tries to set the superscope of the subnet referred by
//DOC address IpAddress to SScopeName.  It does not matter if the superscope
//DOC by that name does not exist, it is automatically created.
//DOC If the subnet already had a superscope, then the behaviour depends on
//DOC the flag ChangeSScope.  If this is TRUE, it sets the new superscopes.
//DOC If the flag is FALSE, it returns ERROR_DDS_SUBNET_HAS_DIFF_SSCOPE.
//DOC This flag is ignored if the subnet does not have a superscope already.
//DOC If SScopeName is NULL, the function removes the subnet from any superscope
//DOC if it belonged to one before.
//DOC If the specified subnet does not exist, it returns ERROR_DDS_SUBNET_NOT_PRESENT.
DWORD
DhcpDsSetSScope(                                  // change superscope of subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      DWORD                  IpAddress,     // subnet address to use
    IN      LPWSTR                 SScopeName,    // sscope it must now be in
    IN      BOOL                   ChangeSScope   // if it already has a SScope, change it?
) ;


//DOC DhcpDsDelSScope deletes the superscope and removes all elements
//DOC that belong to that superscope in one shot. There is no error if the
//DOC superscope does not exist.
DWORD
DhcpDsDelSScope(                                  // delete superscope off DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    IN      LPWSTR                 SScopeName     // sscope to delete
) ;


//DOC DhcpDsGetSScopeInfo retrieves the SuperScope table for the server of interest.
//DOC The table itself is allocated in one blob, so it can be freed lateron.
//DOC The SuperScopeNumber is garbage (always zero) and the NextInSuperScope reflects
//DOC the order in the DS which may/maynot be the same in the DHCP server.
//DOC SuperScopeName is NULL in for subnets that done have a sscope.
DWORD
DhcpDsGetSScopeInfo(                              // get superscope table from ds
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container where dhcp objects are stored
    IN OUT  LPSTORE_HANDLE         hServer,       // the server object referred
    IN      DWORD                  Reserved,      // must be zero, for future use
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SScopeTbl   // allocated by this func in one blob
) ;


//DOC DhcpDsServerAddSubnet tries to add a subnet to a given server. Each subnet
//DOC address has to be unique, but the other parameters dont have to.
//DOC The subnet address being added should not belong to any other subnet.
//DOC In this case it returns error ERROR_DDS_SUBNET_EXISTS
DWORD
DhcpDsServerAddSubnet(                            // create a new subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
) ;


//DOC DhcpDsServerDelSubnet removes a subnet from a given server. It removes not
//DOC just the subnet, but also all dependent objects like reservations etc.
//DOC This fn returns ERROR_DDS_SUBNET_NOT_PRESENT if the subnet is not found.
DWORD
DhcpDsServerDelSubnet(                            // Delete the subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create obj
    IN      LPSTORE_HANDLE         hServer,       // server obj
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 ServerName,    // name of dhcp server 2 del off
    IN      DWORD                  IpAddress      // ip address of subnet to del
) ;


//DOC DhcpDsServerModifySubnet changes the subnet name, comment, state, mask
//DOC fields of the subnet.  Actually, currently, the mask should probably not
//DOC be changed, as no checks are performed in this case.  The address cannot
//DOC be changed.. If the subnet is not present, the error returned is
//DOC ERROR_DDS_SUBNET_NOT_PRESENT
DWORD
DhcpDsServerModifySubnet(                         // modify subnet info
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      LPDHCP_SUBNET_INFO     Info           // info on new subnet to create
) ;


//DOC DhcpDsServerEnumSubnets is not yet implemented.
DWORD
DhcpDsServerEnumSubnets(                          // get subnet list
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_IP_ARRAY       *SubnetsArray   // give array of subnets
) ;


//DOC DhcpDsServerGetSubnetInfo is not yet implemented.
DWORD
DhcpDsServerGetSubnetInfo(                        // get info on subnet
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_IP_ADDRESS        SubnetAddress, // address of subnet to get info for
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo     // o/p: allocated info
) ;


//DOC DhcpDsSubnetAddRangeOrExcl adds a range/excl to an existing subnet.
//DOC If there is a collision with between ranges, then the error code returned
//DOC is ERROR_DDS_POSSIBLE_RANGE_CONFLICT. Note that no checks are made for
//DOC exclusions though.  Also, if a RANGE is extended via this routine, then
//DOC there is no error returned, but a limitation currently is that multiple
//DOC ranges (two only right) cannot be simultaneously extended.
//DOC BUBGUG: The basic check of whether the range belongs in the subnet is
//DOC not done..
DWORD
DhcpDsSubnetAddRangeOrExcl(                       // add a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
) ;


//DOC DhcpDsSubnetDelRangeOrExcl deletes a range or exclusion from off the ds.
//DOC To specify range, set the RangeOrExcl parameter to TRUE.
DWORD
DhcpDsSubnetDelRangeOrExcl(                       // del a range or exclusion
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  Start,         // start addr in range
    IN      DWORD                  End,           // end addr in range
    IN      BOOL                   RangeOrExcl    // TRUE ==> Range,FALSE ==> Excl
) ;


//DOC DhcpDsEnumRangesOrExcl is not yet implemented.
DWORD
DhcpDsEnumRangesOrExcl(                           // enum list of ranges 'n excl
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      BOOL                   RangeOrExcl,   // TRUE ==> Range, FALSE ==> Excl
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pRanges
) ;


//DOC DhcpDsSubnetAddReservation tries to add a reservation object in the DS.
//DOC Neither the ip address not hte hw-address must exist in the DS prior to this.
//DOC If they do exist, the error returned is ERROR_DDS_RESERVATION_CONFLICT.
//DOC No checks are made on the sanity of the address in this subnet..
DWORD
DhcpDsSubnetAddReservation(                       // add a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr,  // reservation ip address to add
    IN      LPBYTE                 HwAddr,        // RAW [ethernet?] hw addr of the client
    IN      DWORD                  HwAddrLen,     // length in # of bytes of hw addr
    IN      DWORD                  ClientType     // client is BOOTP, DHCP, or both?
) ;


//DOC DhcpDsSubnetDelReservation deletes a reservation from the DS.
//DOC If the reservation does not exist, it returns ERROR_DDS_RESERVATION_NOT_PRESENT.
//DOC Reservations cannot be deleted by anything but ip address for now.
DWORD
DhcpDsSubnetDelReservation(                       // delete a reservation
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DWORD                  ReservedAddr   // ip address to delete reserv. by
) ;


//DOC DhcpDsEnumReservations enumerates the reservations..
DWORD
DhcpDsEnumReservations(                           // enumerate reservations frm DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pReservations
) ;


//DOC DhcpDsEnumSubnetElements enumerates the list of subnet elements in a
//DOC subnet... such as IpRanges, Exclusions, Reservations..
//DOC
DWORD
DhcpDsEnumSubnetElements(
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // root container to create objects
    IN OUT  LPSTORE_HANDLE         hServer,       // server object
    IN OUT  LPSTORE_HANDLE         hSubnet,       // subnet object
    IN      DWORD                  Reserved,      // for future use, reserved
    IN      LPWSTR                 ServerName,    // name of server we're using
    IN      DHCP_SUBNET_ELEMENT_TYPE ElementType, // what kind of elt to enum?
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *ElementInfo
) ;

//
// Allow Debug prints to ntsd or kd
//

#ifdef DBG
#define DsAuthPrint(_x_) DsAuthPrintRoutine _x_

VOID DsAuthPrintRoutine(
    LPWSTR Format,
    ...
);
 
#else
#define DsAuthPrint(_x_)
#endif


#endif 
//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\st_srvr.h ===
//================================================================================
//  Copyright 1997 (C) Microsoft Corporation
//  Author: RameshV
//  Description: This is the structure of the server information passed to
//  user via dhcpds.dll.
//================================================================================

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

//BeginExport(typedef)
typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;
//EndExport(typedef)

#endif      _ST_SRVR_H_

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\sterr.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
StErrInit(
    VOID
) ;


VOID
StErrCleanup(
    VOID
) ;

VOID
SetInternalFormatError(
    IN      DWORD                  Code,
    IN      BOOL                   ReallyDoIt
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\store.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _STORE_HANDLE {                    // this is what is used almost always
    DWORD                          MustBeZero;    // for future use
    LPWSTR                         Location;      // where does this refer to?
    LPWSTR                         UserName;      // who is the user?
    LPWSTR                         Password;      // what is the password?
    DWORD                          AuthFlags;     // what permission was this opened with?
    HANDLE                         ADSIHandle;    // handle to within ADSI
    ADS_SEARCH_HANDLE              SearchHandle;  // any searches going on?
    LPVOID                         Memory;        // memory allocated for this call..
    DWORD                          MemSize;       // how much was really allocated?
    BOOL                           SearchStarted; // Did we start the search?
} STORE_HANDLE, *LPSTORE_HANDLE, *PSTORE_HANDLE;


DWORD
StoreInitHandle(                                  // initialize a handle
    IN OUT  STORE_HANDLE          *hStore,        // will be filled in with stuff..
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN      LPWSTR                 Domain,        // OPTIONAL NULL==>default Domain
    IN      LPWSTR                 UserName,      // OPTIONAL NULL==>default credentials
    IN      LPWSTR                 Password,      // OPTIONAL used only if UserName given
    IN      DWORD                  AuthFlags      // OPTIONAL 0 ==> default??????
) ;


DWORD
StoreCleanupHandle(                               // cleanup the handle
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


enum {
    StoreGetChildType,
    StoreGetAbsoluteSameServerType,
    StoreGetAbsoluteOtherServerType
} _StoreGetType;


DWORD
StoreGetHandle(                                   // get handle to child object, absolute object..
    IN OUT  LPSTORE_HANDLE         hStore,        // this gets modified..
    IN      DWORD                  Reserved,
    IN      DWORD                  StoreGetType,  // same server? just a simple child?
    IN      LPWSTR                 Path,
    IN OUT  STORE_HANDLE          *hStoreOut      // new handle created..
) ;


DWORD
StoreSetSearchOneLevel(                          // search will return everything one level below
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD
StoreSetSearchSubTree(                            // search will return the subtree below in ANY order
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD
StoreBeginSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 SearchFilter
) ;


DWORD
StoreEndSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) ;


DWORD                                             // ERROR_NO_MORE_ITEMS if exhausted
StoreSearchGetNext(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    OUT     LPSTORE_HANDLE         hStoreOut
) ;


DWORD
StoreCreateObjectVA(                              // create a new object - var-args ending with ADSTYPE_INVALID
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,    // name of the new object -- must be "CN=name" types
    ...                                           // fmt is AttrType, AttrName, AttrValue [AttrValueLen]
) ;


DWORD
StoreCreateObjectL(                              // create the object as an array
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,   // must be "CN=XXX" types
    IN      PADS_ATTR_INFO         Attributes,   // the required attributes
    IN      DWORD                  nAttributes   // size of above array
) ;


#define     StoreCreateObject      StoreCreateObjectVA


DWORD
StoreDeleteObject(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ObjectName
) ;


//DOC StoreDeleteThisObject deletes the object defined by hStore,StoreGetType and ADsPath.
//DOC The refer to the object just the same way as for StoreGetHandle.
DWORD
StoreDeleteThisObject(                            // delete an object
    IN      LPSTORE_HANDLE         hStore,        // point of anchor frm which reference is done
    IN      DWORD                  Reserved,      // must be zero, reserved for future use
    IN      DWORD                  StoreGetType,  // path is relative, absolute or diff server?
    IN      LPWSTR                 Path           // ADsPath to the object or relative path
) ;


DWORD
StoreSetAttributesVA(                             // set the attributes, var_args interface (nearly similar to CreateVA)
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    ...                                           // fmt is {ADSTYPE, CtrlCode, AttribName, Value}* ending in ADSTYPE_INVALID
) ;


DWORD
StoreSetAttributesL(                              // PADS_ATTR_INFO array equiv for SetAttributesVA
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    IN      PADS_ATTR_INFO         AttribArray,
    IN      DWORD                  nAttributes
) ;


typedef     struct                 _EATTRIB {     // encapsulated attribute
    unsigned int                   Address1_present     : 1;
    unsigned int                   Address2_present     : 1;
    unsigned int                   Address3_present     : 1;
    unsigned int                   ADsPath_present      : 1;
    unsigned int                   StoreGetType_present : 1;
    unsigned int                   Flags1_present       : 1;
    unsigned int                   Flags2_present       : 1;
    unsigned int                   Dword1_present       : 1;
    unsigned int                   Dword2_present       : 1;
    unsigned int                   String1_present      : 1;
    unsigned int                   String2_present      : 1;
    unsigned int                   String3_present      : 1;
    unsigned int                   String4_present      : 1;
    unsigned int                   Binary1_present      : 1;
    unsigned int                   Binary2_present      : 1;

    DWORD                          Address1;      // character "i"
    DWORD                          Address2;      // character "j"
    DWORD                          Address3;      // character "k"
    LPWSTR                         ADsPath;       // character "p" "r" "l"
    DWORD                          StoreGetType;  // "p,r,l" ==> sameserver, child, otherserver
    DWORD                          Flags1;        // character "f"
    DWORD                          Flags2;        // character "g"
    DWORD                          Dword1;        // character "d"
    DWORD                          Dword2;        // character "e"
    LPWSTR                         String1;       // character "s"
    LPWSTR                         String2;       // character "t"
    LPWSTR                         String3;       // character "u"
    LPWSTR                         String4;       // character "v"
    LPBYTE                         Binary1;       // character "b"
    DWORD                          BinLen1;       // # of bytes of above
    LPBYTE                         Binary2;       // character "d"
    DWORD                          BinLen2;       // # of bytes of above
} EATTRIB, *PEATTRIB, *LPEATTRIB;


#define     IS_ADDRESS1_PRESENT(pEA)              ((pEA)->Address1_present)
#define     IS_ADDRESS1_ABSENT(pEA)               (!IS_ADDRESS1_PRESENT(pEA))
#define     ADDRESS1_PRESENT(pEA)                 ((pEA)->Address1_present = 1 )
#define     ADDRESS1_ABSENT(pEA)                  ((pEA)->Address1_present = 0 )

#define     IS_ADDRESS2_PRESENT(pEA)              ((pEA)->Address2_present)
#define     IS_ADDRESS2_ABSENT(pEA)               (!IS_ADDRESS2_PRESENT(pEA))
#define     ADDRESS2_PRESENT(pEA)                 ((pEA)->Address2_present = 1 )
#define     ADDRESS2_ABSENT(pEA)                  ((pEA)->Address2_present = 0 )

#define     IS_ADDRESS3_PRESENT(pEA)              ((pEA)->Address3_present)
#define     IS_ADDRESS3_ABSENT(pEA)               (!IS_ADDRESS3_PRESENT(pEA))
#define     ADDRESS3_PRESENT(pEA)                 ((pEA)->Address3_present = 1 )
#define     ADDRESS3_ABSENT(pEA)                  ((pEA)->Address3_present = 0 )

#define     IS_ADSPATH_PRESENT(pEA)               ((pEA)->ADsPath_present)
#define     IS_ADSPATH_ABSENT(pEA)                (!IS_ADSPATH_PRESENT(pEA))
#define     ADSPATH_PRESENT(pEA)                  ((pEA)->ADsPath_present = 1)
#define     ADSPATH_ABSENT(pEA)                   ((pEA)->ADsPath_present = 0)

#define     IS_STOREGETTYPE_PRESENT(pEA)          ((pEA)->StoreGetType_present)
#define     IS_STOREGETTYPE_ABSENT(pEA)           (!((pEA)->StoreGetType_present))
#define     STOREGETTYPE_PRESENT(pEA)             ((pEA)->StoreGetType_present = 1)
#define     STOREGETTYPE_ABSENT(pEA)              ((pEA)->StoreGetType_present = 0)

#define     IS_FLAGS1_PRESENT(pEA)                ((pEA)->Flags1_present)
#define     IS_FLAGS1_ABSENT(pEA)                 (!((pEA)->Flags1_present))
#define     FLAGS1_PRESENT(pEA)                   ((pEA)->Flags1_present = 1)
#define     FLAGS1_ABSENT(pEA)                    ((pEA)->Flags1_present = 0)

#define     IS_FLAGS2_PRESENT(pEA)                ((pEA)->Flags2_present)
#define     IS_FLAGS2_ABSENT(pEA)                 (!((pEA)->Flags2_present))
#define     FLAGS2_PRESENT(pEA)                   ((pEA)->Flags2_present = 1)
#define     FLAGS2_ABSENT(pEA)                    ((pEA)->Flags2_present = 0)

#define     IS_DWORD1_PRESENT(pEA)                ((pEA)->Dword1_present)
#define     IS_DWORD1_ABSENT(pEA)                 (!((pEA)->Dword1_present))
#define     DWORD1_PRESENT(pEA)                   ((pEA)->Dword1_present = 1)
#define     DWORD1_ABSENT(pEA)                    ((pEA)->Dword1_present = 0)

#define     IS_DWORD2_PRESENT(pEA)                ((pEA)->Dword2_present)
#define     IS_DWORD2_ABSENT(pEA)                 (!((pEA)->Dword2_present))
#define     DWORD2_PRESENT(pEA)                   ((pEA)->Dword2_present = 1)
#define     DWORD2_ABSENT(pEA)                    ((pEA)->Dword2_present = 0)

#define     IS_STRING1_PRESENT(pEA)               ((pEA)->String1_present)
#define     IS_STRING1_ABSENT(pEA)                (!((pEA)->String1_present))
#define     STRING1_PRESENT(pEA)                  ((pEA)->String1_present = 1)
#define     STRING1_ABSENT(pEA)                   ((pEA)->String1_present = 0)

#define     IS_STRING2_PRESENT(pEA)               ((pEA)->String2_present)
#define     IS_STRING2_ABSENT(pEA)                (!((pEA)->String2_present))
#define     STRING2_PRESENT(pEA)                  ((pEA)->String2_present = 1)
#define     STRING2_ABSENT(pEA)                   ((pEA)->String2_present = 0)

#define     IS_STRING3_PRESENT(pEA)               ((pEA)->String3_present)
#define     IS_STRING3_ABSENT(pEA)                (!((pEA)->String3_present))
#define     STRING3_PRESENT(pEA)                  ((pEA)->String3_present = 1)
#define     STRING3_ABSENT(pEA)                   ((pEA)->String3_present = 0)

#define     IS_STRING4_PRESENT(pEA)               ((pEA)->String4_present)
#define     IS_STRING4_ABSENT(pEA)                (!((pEA)->String4_present))
#define     STRING4_PRESENT(pEA)                  ((pEA)->String4_present = 1)
#define     STRING4_ABSENT(pEA)                   ((pEA)->String4_present = 0)

#define     IS_BINARY1_PRESENT(pEA)               ((pEA)->Binary1_present)
#define     IS_BINARY1_ABSENT(pEA)                (!((pEA)->Binary1_present))
#define     BINARY1_PRESENT(pEA)                  ((pEA)->Binary1_present = 1)
#define     BINARY1_ABSENT(pEA)                   ((pEA)->Binary1_present = 0)

#define     IS_BINARY2_PRESENT(pEA)               ((pEA)->Binary2_present)
#define     IS_BINARY2_ABSENT(pEA)                (!((pEA)->Binary2_present))
#define     BINARY2_PRESENT(pEA)                  ((pEA)->Binary2_present = 1)
#define     BINARY2_ABSENT(pEA)                   ((pEA)->Binary2_present = 0)


BOOL        _inline
IsAnythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    || IS_ADDRESS2_PRESENT(pEA)
    || IS_ADDRESS3_PRESENT(pEA)
    || IS_ADSPATH_PRESENT(pEA)
    || IS_STOREGETTYPE_PRESENT(pEA)
    || IS_FLAGS1_PRESENT(pEA)
    || IS_FLAGS2_PRESENT(pEA)
    || IS_DWORD1_PRESENT(pEA)
    || IS_DWORD2_PRESENT(pEA)
    || IS_STRING1_PRESENT(pEA)
    || IS_STRING2_PRESENT(pEA)
    || IS_STRING3_PRESENT(pEA)
    || IS_STRING4_PRESENT(pEA)
    || IS_BINARY1_PRESENT(pEA)
    || IS_BINARY2_PRESENT(pEA)
    ;
}


BOOL        _inline
IsEverythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    && IS_ADDRESS2_PRESENT(pEA)
    && IS_ADDRESS3_PRESENT(pEA)
    && IS_ADSPATH_PRESENT(pEA)
    && IS_STOREGETTYPE_PRESENT(pEA)
    && IS_FLAGS1_PRESENT(pEA)
    && IS_FLAGS2_PRESENT(pEA)
    && IS_DWORD1_PRESENT(pEA)
    && IS_DWORD2_PRESENT(pEA)
    && IS_STRING1_PRESENT(pEA)
    && IS_STRING2_PRESENT(pEA)
    && IS_STRING3_PRESENT(pEA)
    && IS_STRING4_PRESENT(pEA)
    && IS_BINARY1_PRESENT(pEA)
    && IS_BINARY2_PRESENT(pEA)
    ;
}


VOID        _inline
EverythingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_PRESENT(pEA);
    ADDRESS2_PRESENT(pEA);
    ADDRESS3_PRESENT(pEA);
    ADSPATH_PRESENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_PRESENT(pEA);
    FLAGS2_PRESENT(pEA);
    DWORD1_PRESENT(pEA);
    DWORD2_PRESENT(pEA);
    STRING1_PRESENT(pEA);
    STRING2_PRESENT(pEA);
    STRING3_PRESENT(pEA);
    STRING4_PRESENT(pEA);
    BINARY1_PRESENT(pEA);
    BINARY2_PRESENT(pEA);
}


VOID        _inline
NothingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_ABSENT(pEA);
    ADDRESS2_ABSENT(pEA);
    ADDRESS3_ABSENT(pEA);
    ADSPATH_ABSENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_ABSENT(pEA);
    FLAGS2_ABSENT(pEA);
    DWORD1_ABSENT(pEA);
    DWORD2_ABSENT(pEA);
    STRING1_ABSENT(pEA);
    STRING2_ABSENT(pEA);
    STRING3_ABSENT(pEA);
    STRING4_ABSENT(pEA);
    BINARY1_ABSENT(pEA);
    BINARY2_ABSENT(pEA);
}


DWORD
StoreCollectAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // this attrib must be some kind of a text string
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) ;


DWORD
StoreCollectBinaryAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // accept only attrib type OCTET_STRING
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) ;


//DOC StoreUpdateAttributes is sort of the converse of StoreCollectAttributes.
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function does not work when the attrib is of type
//DOC OCTET_STRING etc.  It works only with types that can be derived from
//DOC PrintableString.
DWORD
StoreUpdateAttributes(                            // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array          // list of attribs
) ;


//DOC StoreUpdateBinaryAttributes is sort of the converse of StoreCollectBinaryAttributes
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function works only when the attrib is of type
//DOC OCTET_STRING etc.  It doesnt work with types that can be derived from
//DOC PrintableString!!!.
DWORD
StoreUpdateBinaryAttributes(                      // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be OCTET_STRING type
    IN      PARRAY                 Array          // list of attribs
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\store.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV (critical code borrowed from shirish koti)
//  Description: This makes somethings easy for accessing the DS.
//================================================================================

#include    <hdrmacro.h>
#include    <sterr.h>                             // error reporting stuff

enum        /* anonymous */ {
    REPEATED_ADDRESS1      = 0x01,                // dont start error code with zero!
    REPEATED_ADDRESS2,
    REPEATED_ADDRESS3,
    INVALID_ADDRESS1,
    INVALID_ADDRESS2,
    INVALID_ADDRESS3,
    REPEATED_ADSPATH,
    INVALID_ADSPATH,
    REPEATED_FLAGS1,
    REPEATED_FLAGS2,
    INVALID_FLAGS1,
    INVALID_FLAGS2,
    REPEATED_DWORD1,
    REPEATED_DWORD2,
    INVALID_DWORD1,
    INVALID_DWORD2,
    REPEATED_STRING1,
    REPEATED_STRING2,
    REPEATED_STRING3,
    REPEATED_STRING4,
    INVALID_STRING1,
    INVALID_STRING2,
    INVALID_STRING3,
    INVALID_STRING4,
    REPEATED_BINARY1,
    REPEATED_BINARY2,
    INVALID_BINARY1,
    INVALID_BINARY2,
    INVALID_ATTRIB_FIELD,
    INVALID_BINARY_CODING,
    UNEXPECTED_COLLECTION_TYPE,
    UNEXPECTED_INTERNAL_ERROR,
};

//
// Constants
//

// Retrive 256 rows per query
#define DHCPDS_DS_SEARCH_PAGESIZE 256


//================================================================================
//  structures
//================================================================================
//BeginExport(typedef)
typedef struct _STORE_HANDLE {                    // this is what is used almost always
    DWORD                          MustBeZero;    // for future use
    LPWSTR                         Location;      // where does this refer to?
    LPWSTR                         UserName;      // who is the user?
    LPWSTR                         Password;      // what is the password?
    DWORD                          AuthFlags;     // what permission was this opened with?
    HANDLE                         ADSIHandle;    // handle to within ADSI
    ADS_SEARCH_HANDLE              SearchHandle;  // any searches going on?
    LPVOID                         Memory;        // memory allocated for this call..
    DWORD                          MemSize;       // how much was really allocated?
    BOOL                           SearchStarted; // Did we start the search?
} STORE_HANDLE, *LPSTORE_HANDLE, *PSTORE_HANDLE;
//EndExport(typedef)

LPWSTR      _inline
MakeRootDSEString(                                // given DSDC or domain name, produce ROOT DSE name
    IN      LPWSTR                 Server
)
{
    LPWSTR                         RootDSE;

    if( NULL == Server ) {
        RootDSE = MemAlloc( sizeof(DEFAULT_LDAP_ROOTDSE) ) ;
        if( NULL == RootDSE ) return NULL;
        wcscpy(RootDSE, DEFAULT_LDAP_ROOTDSE);
        return RootDSE;
    }

    RootDSE = MemAlloc(sizeof(LDAP_PREFIX) + SizeString(Server,FALSE) + sizeof(ROOTDSE_POSTFIX));
    if( NULL == RootDSE ) return NULL;

    wcscpy(RootDSE, LDAP_PREFIX);
    wcscat(RootDSE, Server);
    wcscat(RootDSE, ROOTDSE_POSTFIX);

    return RootDSE;
}

LPWSTR      _inline
MakeServerLocationString(
    IN      LPWSTR                 Server,
    IN      LPWSTR                 Location
)
{
    LPWSTR                         RetVal;

    Require(Location);

    RetVal = MemAlloc(sizeof(LDAP_PREFIX) + sizeof(WCHAR) + SizeString(Server,FALSE) + SizeString(Location,FALSE));
    if( NULL == RetVal ) return NULL;

    wcscpy(RetVal, LDAP_PREFIX);
    if( NULL != Server ) {
        wcscat(RetVal, Server);
        wcscat(RetVal, L"/");
    }
    wcscat(RetVal, Location);

    return RetVal;
}

HRESULT
GetEnterpriseRootFromRootHandle(                  // given /ROOTDSE object handle, get enterprise config root handle..
    IN      HANDLE                 DSERootHandle,
    IN      LPWSTR                 Server,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    IN OUT  LPWSTR                *RootLocation,
    IN OUT  HANDLE                *hRoot
)
{
    HRESULT                        hResult;
    DWORD                          Chk;
    DWORD                          i, j;
    DWORD                          nAttributes;
    PADS_ATTR_INFO                 Attributes;
    BOOL                           Found;

    *RootLocation = NULL;
    hResult = ADSIGetObjectAttributes(
        DSERootHandle,
        (LPWSTR *)&constNamingContextString,
        1,
        &Attributes,
        &nAttributes
    );

    if( FAILED(hResult) ) return hResult;
    if( 0 == nAttributes ) {
        return E_ADS_PROPERTY_NOT_FOUND;
    }

    Found = FALSE;
    for( i = 0; i < Attributes->dwNumValues ; i ++ ) {
        if( Attributes->pADsValues[i].dwType != ADSTYPE_CASE_IGNORE_STRING &&
            Attributes->pADsValues[i].dwType != ADSTYPE_DN_STRING )
            continue;

        Chk = _wcsnicmp(
            ENT_ROOT_PREFIX,
            Attributes->pADsValues[i].CaseIgnoreString,
            ENT_ROOT_PREFIX_LEN
        );
        if( 0 == Chk ) break;
    }

    if( i < Attributes->dwNumValues ) {
        *RootLocation = MakeServerLocationString(
            Server,
            Attributes->pADsValues[i].CaseIgnoreString
        );
        Found = TRUE;
    }

    FreeADsMem(Attributes);
    if( FALSE == Found ) return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    if( NULL == *RootLocation ) return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    hResult = ADSIOpenDSObject(
        *RootLocation,
        UserName,
        Password,
        AuthFlags,
        hRoot
    );

    if( SUCCEEDED(hResult) ) return S_OK;

    MemFree(*RootLocation);
    *RootLocation = NULL;
    return hResult;
}

DWORD
GetEnterpriseRootObject(                          // get the /ROOTDSE object's naming context object..
    IN      LPWSTR                 Server,        // domain controller name or domain dns name
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    IN OUT  LPWSTR                *RootLocation,  // what is the value of the nameingContext attrib that we used?
    IN OUT  HANDLE                *hRoot          // handle to the above object..
)
{
    DWORD                          Result;
    LPWSTR                         RootDSEString;
    LPWSTR                         RootEnterpriseString;
    HANDLE                         hRootDSE;
    HRESULT                        hResult;

    *RootLocation = NULL; *hRoot = NULL;
    RootDSEString = MakeRootDSEString(Server);
    if( NULL == RootDSEString ) return ERROR_NOT_ENOUGH_MEMORY;

    hResult = ADSIOpenDSObject(
        RootDSEString,
        UserName,
        Password,
        AuthFlags,
        &hRootDSE
    );
    MemFree(RootDSEString);

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    hResult = GetEnterpriseRootFromRootHandle(
        hRootDSE,
        Server,
        UserName,
        Password,
        AuthFlags,
        RootLocation,
        hRoot
    );
    ADSICloseDSObject(hRootDSE);

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    Require(hRoot && RootLocation);
    return ERROR_SUCCESS;
}

//================================================================================
//  exported functions
//================================================================================
//BeginExport(function)
DWORD
StoreInitHandle(                                  // initialize a handle
    IN OUT  STORE_HANDLE          *hStore,        // will be filled in with stuff..
    IN      DWORD                  Reserved,      // must be zero -- for future use
    IN      LPWSTR                 Domain,        // OPTIONAL NULL==>default Domain
    IN      LPWSTR                 UserName,      // OPTIONAL NULL==>default credentials
    IN      LPWSTR                 Password,      // OPTIONAL used only if UserName given
    IN      DWORD                  AuthFlags      // OPTIONAL 0 ==> default??????
) //EndExport(function)
{
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         EnterpriseRootLocation;
    HANDLE                         RootServer;
    LPBYTE                         Memory;

    Result = GetEnterpriseRootObject(
        Domain,
        UserName,
        Password,
        AuthFlags,
        &EnterpriseRootLocation,
        &RootServer
    );
    if( ERROR_SUCCESS != Result) return Result;

    Require(RootServer && EnterpriseRootLocation);

    Size =  sizeof(LONG);
    Size += SizeString(UserName, FALSE);
    Size += SizeString(Password, FALSE);

    Memory = MemAlloc(Size);
    if( NULL == Memory ) {
        MemFree(EnterpriseRootLocation);
        ADSICloseDSObject(RootServer);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hStore->MemSize = Size;
    Size = sizeof(LONG);
    hStore->MustBeZero = 0;
    hStore->Location = EnterpriseRootLocation;
    hStore->UserName = (LPWSTR)&Memory[Size]; Size += SizeString(UserName, FALSE);
    hStore->Password = (LPWSTR)&Memory[Size]; Size += SizeString(Password, FALSE);
    hStore->AuthFlags = AuthFlags;
    hStore->ADSIHandle = RootServer;
    hStore->SearchHandle = NULL;
    hStore->Memory = Memory;

    if( NULL == UserName ) hStore->UserName = NULL;
    else wcscpy(hStore->UserName, UserName);
    if( NULL == Password ) hStore->Password = NULL;
    else wcscpy(hStore->Password,Password);

    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD
StoreCleanupHandle(                               // cleanup the handle
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    DWORD                          Result;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);

    MemFree(hStore->Location);
    MemFree(hStore->Memory);
    if(hStore->SearchHandle)
        ADSICloseSearchHandle(hStore->ADSIHandle, hStore->SearchHandle);
    ADSICloseDSObject(hStore->ADSIHandle);
//      memset(hStore, 0, sizeof(*hStore));
    hStore->Location = NULL;
    hStore->UserName = NULL;
    hStore->Password = NULL;
    hStore->AuthFlags = 0;
    hStore->ADSIHandle = 0;
    hStore->Memory = NULL;
    hStore->MemSize = 0;
//      hStore->SearchStarted = FALSE;

    return ERROR_SUCCESS;
}


//BeginExport(enum)
enum {
    StoreGetChildType,
    StoreGetAbsoluteSameServerType,
    StoreGetAbsoluteOtherServerType
} _StoreGetType;
//EndExport(enum)

DWORD
ConvertPath(                                      // convert a "CN=X" type spec to "LDAP://Server/CN=X"..
    IN      LPSTORE_HANDLE         hStore,        // needed to get the initial strings bits
    IN      DWORD                  StoreGetType,
    IN      LPWSTR                 PathIn,
    OUT     LPWSTR                *PathOut
)
{
    DWORD                          Size;
    DWORD                          PrefixSize;
    DWORD                          SuffixSize;
    LPWSTR                         TmpString;
    LPWSTR                         PrefixString;

    *PathOut = NULL;

    if( StoreGetChildType == StoreGetType ) {
        TmpString = PrefixString = hStore->Location;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        if( wcschr(TmpString, L'/') ) {
            TmpString = wcschr(TmpString, L'/'); TmpString ++;
        }
        PrefixSize = sizeof(WCHAR)*(DWORD)(TmpString - PrefixString );
        SuffixSize = SizeString(hStore->Location, FALSE)-PrefixSize;
    } else if( StoreGetAbsoluteSameServerType == StoreGetType ) {
        TmpString = PrefixString = hStore->Location;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        TmpString = wcschr(TmpString, L'/'); Require(TmpString); TmpString ++;
        if( wcschr(TmpString, L'/') ) {
            TmpString = wcschr(TmpString, L'/'); TmpString ++;
        }
        PrefixSize = sizeof(WCHAR)*(DWORD)(TmpString - PrefixString );
        SuffixSize = 0;
    } else if( StoreGetAbsoluteOtherServerType == StoreGetType ) {
        PrefixSize = 0;                           // use the path given by the user
        SuffixSize = 0;
    } else {
        Require(FALSE);
        PrefixSize = SuffixSize = 0;
    }

    Size = PrefixSize + SuffixSize + SizeString(PathIn,FALSE) + sizeof(CONNECTOR) - sizeof(WCHAR);
    TmpString = MemAlloc(Size);
    if( NULL == TmpString ) return ERROR_NOT_ENOUGH_MEMORY;

    if( PrefixSize ) {
        memcpy((LPBYTE)TmpString, (LPBYTE)PrefixString, PrefixSize);
    }
    wcscpy((LPWSTR)(PrefixSize + (LPBYTE)TmpString), PathIn);
    if( SuffixSize ) {
        wcscat(TmpString, CONNECTOR);
        wcscat(TmpString, (LPWSTR)(PrefixSize+(LPBYTE)PrefixString));
    }

    *PathOut = TmpString;
    StoreTrace2("ConvertedPath: %ws\n", TmpString);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreGetHandle(                                   // get handle to child object, absolute object..
    IN OUT  LPSTORE_HANDLE         hStore,        // this gets modified..
    IN      DWORD                  Reserved,
    IN      DWORD                  StoreGetType,  // same server? just a simple child?
    IN      LPWSTR                 Path,
    IN OUT  STORE_HANDLE          *hStoreOut      // new handle created..
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         ConvertedPath;
    HANDLE                         ObjectHandle;
    LPBYTE                         Memory;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);
    AssertRet(Path, ERROR_INVALID_PARAMETER);
    AssertRet(hStoreOut, ERROR_INVALID_PARAMETER);

    Result = ConvertPath(hStore, StoreGetType, Path, &ConvertedPath);
    if( ERROR_SUCCESS != Result ) return Result;

    Require(ConvertedPath);
    Memory = MemAlloc(hStore->MemSize);
    if( NULL == Memory ) {
        MemFree(ConvertedPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hResult = ADSIOpenDSObject(
        ConvertedPath,
        hStore->UserName,
        hStore->Password,
        hStore->AuthFlags,
        &ObjectHandle
    );
    if( FAILED(hResult) ) {
        MemFree(ConvertedPath);
        MemFree(Memory);
        return ConvertHresult(hResult);
    }

    memcpy(Memory, hStore->Memory, hStore->MemSize);
    Size = sizeof(LONG);
    hStoreOut->MemSize = hStore->MemSize;
    hStoreOut->MustBeZero = 0;
    hStoreOut->Location = ConvertedPath;
    hStoreOut->UserName = (LPWSTR)&Memory[Size]; Size += SizeString(hStore->UserName, FALSE);
    hStoreOut->Password = (LPWSTR)&Memory[Size]; Size += SizeString(hStore->Password, FALSE);
    hStoreOut->AuthFlags = hStore->AuthFlags;
    hStoreOut->ADSIHandle = ObjectHandle;
    hStoreOut->SearchHandle = NULL;
    hStoreOut->Memory = Memory;

    if( NULL == hStore->UserName ) hStoreOut->UserName = NULL;
    if( NULL == hStore->Password ) hStoreOut->Password = NULL;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreSetSearchOneLevel(                          // search will return everything one level below
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;
    ADS_SEARCHPREF_INFO            SearchPref[3];

    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = DHCPDS_DS_SEARCH_PAGESIZE;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hResult = ADSISetSearchPreference(
        /* hDSObject           */  hStore->ADSIHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  2 // sizeof( SearchPref ) / sizeof( SearchPref[ 0 ])
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreSetSearchSubTree(                            // search will return the subtree below in ANY order
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;
    ADS_SEARCHPREF_INFO            SearchPref[3];

    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = DHCPDS_DS_SEARCH_PAGESIZE;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hResult = ADSISetSearchPreference(
        /* hDSObject           */  hStore->ADSIHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  sizeof( SearchPref ) / sizeof( SearchPref[ 0 ])
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreBeginSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 SearchFilter
) //EndExport(function)
{
    HRESULT                        hResult;
    LPWSTR                         nameAttrib;

    nameAttrib = ATTRIB_NAME;
    AssertRet(hStore && hStore->ADSIHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);
    hResult = ADSIExecuteSearch(
        hStore->ADSIHandle,
        SearchFilter,
        (LPWSTR *)&nameAttrib,
        1,
        &(hStore->SearchHandle)
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    hStore->SearchStarted = FALSE;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
StoreEndSearch(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved
) //EndExport(function)
{
    HRESULT                        hResult;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->SearchHandle, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    hResult = ADSICloseSearchHandle(hStore->ADSIHandle, hStore->SearchHandle);
    hStore->SearchHandle = NULL;

    hStore->SearchStarted = FALSE;
    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD                                             // ERROR_NO_MORE_ITEMS if exhausted
StoreSearchGetNext(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    OUT     LPSTORE_HANDLE         hStoreOut
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    ADS_SEARCH_COLUMN              Column;
    LPWSTR                         ColumnName;

    AssertRet(hStore && hStore->ADSIHandle && hStoreOut, ERROR_INVALID_PARAMETER);
    AssertRet(Reserved == 0, ERROR_INVALID_PARAMETER);

    if ( !hStore->SearchStarted ) {
	hResult = ADSIGetFirstRow( hStore->ADSIHandle,
				   hStore->SearchHandle
				   );
	hStore->SearchStarted = TRUE;
    }
    else {
	hResult = ADSIGetNextRow( hStore->ADSIHandle,
				  hStore->SearchHandle
				  );
    }

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    if( S_ADS_NOMORE_ROWS == hResult ) return ERROR_NO_MORE_ITEMS;

    hResult = ADSIGetColumn(
        hStore->ADSIHandle,
        hStore->SearchHandle,
        ATTRIB_NAME,
        &Column
    );
    if( FAILED(hResult) ) {
        Require(FALSE);
        return ConvertHresult(hResult);
    }

    Require(1==Column.dwNumValues);               // single valued
    if( Column.pADsValues[0].dwType == ADSTYPE_DN_STRING ) {
        Require(Column.pADsValues[0].DNString);
        ColumnName = MakeColumnName(Column.pADsValues[0].DNString);
    } else if( Column.pADsValues[0].dwType == ADSTYPE_CASE_IGNORE_STRING ) {
        Require(Column.pADsValues[0].CaseIgnoreString);
        ColumnName = MakeColumnName(Column.pADsValues[0].CaseIgnoreString);
    } else {
        Require(FALSE);
        ColumnName = NULL;
    }
    
    if( NULL == ColumnName ) Result = ERROR_NOT_ENOUGH_MEMORY;
    else {
        Result = StoreGetHandle(
            hStore,
            Reserved,
            StoreGetChildType,
            ColumnName,
            hStoreOut
        );
        MemFree(ColumnName);
    }

    ADSIFreeColumn(
        hStore->ADSIHandle,
        &Column
    );

    return Result;
}

//BeginExport(function)
DWORD
StoreCreateObjectVA(                              // create a new object - var-args ending with ADSTYPE_INVALID
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,    // name of the new object -- must be "CN=name" types
    ...                                           // fmt is AttrType, AttrName, AttrValue [AttrValueLen]
) //EndExport(function)                           // LARGE_INTEGER type has hi_word followed by low_word
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          i;
    DWORD                          ArgType;
    DWORD                          nArgs;
    DWORD                          Arg1;
    va_list                        Args;
    PADS_ATTR_INFO                 Attributes;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(NewObjName, ERROR_INVALID_PARAMETER);

    nArgs = 0;
    va_start(Args, NewObjName);
    do {
        ArgType = va_arg(Args, DWORD);
        if( ADSTYPE_INVALID == ArgType ) break;
        va_arg(Args, LPWSTR);                     // skip the name of attrib
        switch(ArgType) {
        case ADSTYPE_DN_STRING :
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
        case ADSTYPE_UTC_TIME:
        case ADSTYPE_OBJECT_CLASS:
            va_arg(Args, LPWSTR);
            break;
            
        case ADSTYPE_BOOLEAN:
        case ADSTYPE_INTEGER:
            va_arg(Args, DWORD);
            break;
            
        case ADSTYPE_OCTET_STRING:
            va_arg(Args, LPBYTE);
            va_arg(Args, DWORD);                  // additional DWORD values for these..
            break;
        case ADSTYPE_LARGE_INTEGER:
            va_arg(Args, LONG);
            va_arg(Args, DWORD);                  // additional DWORD values for these..
            break;
        default:
            return ERROR_INVALID_PARAMETER;
        }
        nArgs ++;
    } while( 1 );

    if( 0 == nArgs ) {
        Attributes = NULL;
    } else {
        Attributes = MemAlloc(nArgs * sizeof(*Attributes));
        if( NULL == Attributes ) return ERROR_NOT_ENOUGH_MEMORY;

        memset(Attributes, 0, sizeof(*Attributes));
    }

    va_start(Args, NewObjName);
    for(i = 0; i < nArgs; i ++ ) {
        ArgType = va_arg(Args, DWORD);
        Require(ADSTYPE_INVALID != ArgType);

        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = MemAlloc(sizeof(*Attributes[i].pADsValues));
        if( NULL == Attributes[i].pADsValues ) {
            nArgs = i;
            goto Cleanup;
        }

        Attributes[i].pszAttrName = (LPWSTR)va_arg(Args, LPWSTR);
        Attributes[i].dwControlCode = ADS_ATTR_APPEND;
        Attributes[i].dwADsType = ArgType;
        Attributes[i].pADsValues[0].dwType = ArgType;

        switch(ArgType) {
        case ADSTYPE_DN_STRING :
            Attributes[i].pADsValues[0].DNString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_EXACT_STRING:
            Attributes[i].pADsValues[0].CaseExactString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_IGNORE_STRING:
            Attributes[i].pADsValues[0].CaseIgnoreString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_PRINTABLE_STRING:
            Attributes[i].pADsValues[0].PrintableString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_NUMERIC_STRING:
            Attributes[i].pADsValues[0].NumericString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_BOOLEAN:
            Attributes[i].pADsValues[0].Boolean = va_arg(Args,DWORD); break;
        case ADSTYPE_INTEGER:
            Attributes[i].pADsValues[0].Integer = va_arg(Args,DWORD); break;
        case ADSTYPE_OBJECT_CLASS:
            Attributes[i].pADsValues[0].ClassName = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_OCTET_STRING:
            Attributes[i].pADsValues[0].OctetString.lpValue = (LPBYTE)va_arg(Args,LPBYTE);
            Attributes[i].pADsValues[0].OctetString.dwLength = va_arg(Args, DWORD);
            break;
        case ADSTYPE_LARGE_INTEGER:
            Attributes[i].pADsValues[0].LargeInteger.HighPart = (LONG)va_arg(Args,LONG);
            Attributes[i].pADsValues[0].LargeInteger.LowPart = va_arg(Args, ULONG);
            break;
        case ADSTYPE_UTC_TIME:
            Attributes[i].pADsValues[0].UTCTime = *((ADS_UTC_TIME*)va_arg(Args,PVOID));
            break;
        default:
            nArgs = i;
            Result =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    hResult = ADSICreateDSObject(
        hStore->ADSIHandle,
        NewObjName,
        Attributes,
        nArgs
    );

    if( HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hResult ||
        HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) == hResult ||
        E_ADS_OBJECT_EXISTS == hResult ) {
        Result = ERROR_ALREADY_EXISTS;
    } else if( FAILED(hResult) ) {
        Result = ConvertHresult(hResult);
    } else {
        Result = ERROR_SUCCESS;
    }

  Cleanup:

    if( NULL != Attributes ) {
        for( i = 0; i < nArgs ; i ++ ) {
            if( Attributes[i].pADsValues ) MemFree(Attributes[i].pADsValues);
        }
        MemFree(Attributes);
    }

    return Result;
}

//BeginExport(function)
DWORD
StoreCreateObjectL(                              // create the object as an array
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 NewObjName,   // must be "CN=XXX" types
    IN      PADS_ATTR_INFO         Attributes,   // the required attributes
    IN      DWORD                  nAttributes   // size of above array
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;

    hResult = ADSICreateDSObject(
        hStore->ADSIHandle,
        NewObjName,
        Attributes,
        nAttributes
    );
    if( HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hResult ||
        HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) == hResult ||
        E_ADS_OBJECT_EXISTS == hResult ) {
        Result = ERROR_ALREADY_EXISTS;
    } else if( FAILED(hResult) ) {
        Result = ConvertHresult(hResult);
    } else {
        Result = ERROR_SUCCESS;
    }
    return Result;
}

//BeginExport(defines)
#define     StoreCreateObject      StoreCreateObjectVA
//EndExport(defines)


//BeginExport(function)
DWORD
StoreDeleteObject(
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ObjectName
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(ObjectName, ERROR_INVALID_PARAMETER);

    hResult = ADSIDeleteDSObject(
        hStore->ADSIHandle,
        ObjectName
    );

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC StoreDeleteThisObject deletes the object defined by hStore,StoreGetType and ADsPath.
//DOC The refer to the object just the same way as for StoreGetHandle.
DWORD
StoreDeleteThisObject(                            // delete an object
    IN      LPSTORE_HANDLE         hStore,        // point of anchor frm which reference is done
    IN      DWORD                  Reserved,      // must be zero, reserved for future use
    IN      DWORD                  StoreGetType,  // path is relative, absolute or diff server?
    IN      LPWSTR                 Path           // ADsPath to the object or relative path
)   //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Size;
    LPWSTR                         ConvertedPath, ChildNameStart,ChildNameEnd;
    LPWSTR                         ChildName;
    HANDLE                         ParentObject;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->Location, ERROR_INVALID_PARAMETER);
    AssertRet(Path, ERROR_INVALID_PARAMETER);

    Result = ConvertPath(hStore, StoreGetType, Path, &ConvertedPath);
    if( ERROR_SUCCESS != Result ) return Result;

    Require(ConvertedPath);
    ChildNameStart = wcschr(ConvertedPath, L'/'); Require(ChildNameStart); ChildNameStart++;
    ChildNameStart = wcschr(ChildNameStart, L'/'); Require(ChildNameStart); ChildNameStart++;
    if( wcschr(ChildNameStart, L'/') ) {
        ChildNameStart = wcschr(ChildNameStart, L'/'); 
        Require(ChildNameStart); ChildNameStart++;
    }
    ChildNameEnd = wcschr(ChildNameStart, L','); Require(ChildNameEnd); *ChildNameEnd++ = L'\0';

    ChildName = MemAlloc((DWORD)((LPBYTE)ChildNameEnd - (LPBYTE)ChildNameStart));
    if( NULL == ChildName ) {
        MemFree(ConvertPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(ChildName, ChildNameStart, (int)((LPBYTE)ChildNameEnd - (LPBYTE)ChildNameStart));
    wcscpy(ChildNameStart, ChildNameEnd);         // remove child name from ConvertPath

    hResult = ADSIOpenDSObject(                   // open the parent object
        ConvertedPath,
        hStore->UserName,
        hStore->Password,
        hStore->AuthFlags,
        &ParentObject
    );
    MemFree(ConvertedPath);

    if( FAILED(hResult) ) {
        MemFree(ChildName);
        return ConvertHresult(hResult);
    }

    hResult = ADSIDeleteDSObject(                 // delete the required child object
        ParentObject,
        ChildName
    );
    MemFree(ChildName);
    ADSICloseDSObject(ParentObject);              // free up handles and memory

    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;                         // : need to have better error messages than this
}

//BeginExport(function)
DWORD
StoreSetAttributesVA(                             // set the attributes, var_args interface (nearly similar to CreateVA)
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    ...                                           // fmt is {ADSTYPE, CtrlCode, AttribName, Value}* ending in ADSTYPE_INVALID
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          i;
    DWORD                          ArgType;
    DWORD                          nArgs;
    va_list                        Args;
    PADS_ATTR_INFO                 Attributes;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->ADSIHandle, ERROR_INVALID_PARAMETER);

    nArgs = 0;
    va_start(Args, nAttributesModified);
    do {
        ArgType = va_arg(Args, DWORD);
        if( ADSTYPE_INVALID == ArgType ) break;
        va_arg(Args, DWORD);                      // skip control code
        va_arg(Args, LPWSTR);                     // skip the name of attrib
        switch(ArgType) {
        case ADSTYPE_DN_STRING :
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
        case ADSTYPE_OBJECT_CLASS:
        case ADSTYPE_UTC_TIME:
            va_arg(Args,LPWSTR);
            break;

        case ADSTYPE_BOOLEAN:
        case ADSTYPE_INTEGER:
            va_arg( Args, DWORD);
            break;
            
        case ADSTYPE_OCTET_STRING:
            va_arg(Args, LPBYTE);
            va_arg(Args, DWORD);                  // additional DWORD values for these..
        case ADSTYPE_LARGE_INTEGER:
            va_arg(Args, LONG);
            va_arg(Args, DWORD);                  // additional DWORD values for these..
            break;
        default:
            return ERROR_INVALID_PARAMETER;
        }
        nArgs ++;
    } while( 1 );

    if( 0 == nArgs ) {
        Attributes = NULL;
    } else {
        Attributes = MemAlloc(nArgs * sizeof(*Attributes));
        if( NULL == Attributes ) return ERROR_NOT_ENOUGH_MEMORY;

        memset(Attributes, 0, sizeof(*Attributes));
    }

    va_start(Args, nAttributesModified);
    for(i = 0; i < nArgs; i ++ ) {
        ArgType = va_arg(Args, DWORD);
        Require(ADSTYPE_INVALID != ArgType);

        Attributes[i].dwNumValues = 1;
        Attributes[i].pADsValues = MemAlloc(sizeof(*Attributes[i].pADsValues));
        if( NULL == Attributes[i].pADsValues ) {
            nArgs = i;
            goto Cleanup;
        }

        Attributes[i].dwControlCode = (DWORD)va_arg(Args, DWORD);
        Attributes[i].pszAttrName = (LPWSTR)va_arg(Args, LPWSTR);
        Attributes[i].dwADsType = ArgType;
        Attributes[i].pADsValues[0].dwType = ArgType;

        switch(ArgType) {
        case ADSTYPE_DN_STRING :
            Attributes[i].pADsValues[0].DNString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_EXACT_STRING:
            Attributes[i].pADsValues[0].CaseExactString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_CASE_IGNORE_STRING:
            Attributes[i].pADsValues[0].CaseIgnoreString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_PRINTABLE_STRING:
            Attributes[i].pADsValues[0].PrintableString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_NUMERIC_STRING:
            Attributes[i].pADsValues[0].NumericString = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_BOOLEAN:
            Attributes[i].pADsValues[0].Boolean = va_arg(Args,DWORD); break;
        case ADSTYPE_INTEGER:
            Attributes[i].pADsValues[0].Integer = va_arg(Args,DWORD); break;
        case ADSTYPE_OBJECT_CLASS:
            Attributes[i].pADsValues[0].ClassName = (LPWSTR)va_arg(Args,LPWSTR); break;
        case ADSTYPE_OCTET_STRING:
            Attributes[i].pADsValues[0].OctetString.lpValue = (LPBYTE)va_arg(Args,LPBYTE);
            Attributes[i].pADsValues[0].OctetString.dwLength = va_arg(Args, DWORD);
            break;
        case ADSTYPE_LARGE_INTEGER:
            Attributes[i].pADsValues[0].LargeInteger.HighPart = (LONG)va_arg(Args,LONG);
            Attributes[i].pADsValues[0].LargeInteger.LowPart = va_arg(Args, ULONG);
            break;
        case ADSTYPE_UTC_TIME:
            Attributes[i].pADsValues[0].UTCTime = *((ADS_UTC_TIME*)va_arg(Args,PVOID));
            break;
        default:
            nArgs = i;
            Result =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    hResult = ADSISetObjectAttributes(
        hStore->ADSIHandle,
        Attributes,
        nArgs,
        nAttributesModified
    );
    if( FAILED(hResult) ) return ConvertHresult(hResult);

    Result = ERROR_SUCCESS;

  Cleanup:

    if( NULL != Attributes ) {
        for( i = 0; i < nArgs ; i ++ ) {
            if( Attributes[i].pADsValues ) MemFree(Attributes[i].pADsValues);
        }
        MemFree(Attributes);
    }

    return Result;
}

//BeginExport(function)
DWORD
StoreSetAttributesL(                              // PADS_ATTR_INFO array equiv for SetAttributesVA
    IN OUT  LPSTORE_HANDLE         hStore,
    IN      DWORD                  Reserved,
    IN OUT  DWORD*                 nAttributesModified,
    IN      PADS_ATTR_INFO         AttribArray,
    IN      DWORD                  nAttributes
) //EndExport(function)
{
    HRESULT                        hResult;

    AssertRet(hStore, ERROR_INVALID_PARAMETER);
    AssertRet(hStore->ADSIHandle, ERROR_INVALID_PARAMETER);

    hResult = ADSISetObjectAttributes(
        hStore->ADSIHandle,
        AttribArray,
        nAttributes,
        nAttributesModified
    );
    if( FAILED(hResult) ) return ConvertHresult(hResult);
    return ERROR_SUCCESS;
}

//================================================================================
// dhcp specific stuff follow here..
//================================================================================

//BeginExport(typedef)
typedef     struct                 _EATTRIB {     // encapsulated attribute
    unsigned int                   Address1_present     : 1;
    unsigned int                   Address2_present     : 1;
    unsigned int                   Address3_present     : 1;
    unsigned int                   ADsPath_present      : 1;
    unsigned int                   StoreGetType_present : 1;
    unsigned int                   Flags1_present       : 1;
    unsigned int                   Flags2_present       : 1;
    unsigned int                   Dword1_present       : 1;
    unsigned int                   Dword2_present       : 1;
    unsigned int                   String1_present      : 1;
    unsigned int                   String2_present      : 1;
    unsigned int                   String3_present      : 1;
    unsigned int                   String4_present      : 1;
    unsigned int                   Binary1_present      : 1;
    unsigned int                   Binary2_present      : 1;

    DWORD                          Address1;      // character "i"
    DWORD                          Address2;      // character "j"
    DWORD                          Address3;      // character "k"
    LPWSTR                         ADsPath;       // character "p" "r" "l"
    DWORD                          StoreGetType;  // "p,r,l" ==> sameserver, child, otherserver
    DWORD                          Flags1;        // character "f"
    DWORD                          Flags2;        // character "g"
    DWORD                          Dword1;        // character "d"
    DWORD                          Dword2;        // character "e"
    LPWSTR                         String1;       // character "s"
    LPWSTR                         String2;       // character "t"
    LPWSTR                         String3;       // character "u"
    LPWSTR                         String4;       // character "v"
    LPBYTE                         Binary1;       // character "b"
    DWORD                          BinLen1;       // # of bytes of above
    LPBYTE                         Binary2;       // character "d"
    DWORD                          BinLen2;       // # of bytes of above
} EATTRIB, *PEATTRIB, *LPEATTRIB;
//EndExport(typedef)

//BeginExport(defines)
#define     IS_ADDRESS1_PRESENT(pEA)              ((pEA)->Address1_present)
#define     IS_ADDRESS1_ABSENT(pEA)               (!IS_ADDRESS1_PRESENT(pEA))
#define     ADDRESS1_PRESENT(pEA)                 ((pEA)->Address1_present = 1 )
#define     ADDRESS1_ABSENT(pEA)                  ((pEA)->Address1_present = 0 )

#define     IS_ADDRESS2_PRESENT(pEA)              ((pEA)->Address2_present)
#define     IS_ADDRESS2_ABSENT(pEA)               (!IS_ADDRESS2_PRESENT(pEA))
#define     ADDRESS2_PRESENT(pEA)                 ((pEA)->Address2_present = 1 )
#define     ADDRESS2_ABSENT(pEA)                  ((pEA)->Address2_present = 0 )

#define     IS_ADDRESS3_PRESENT(pEA)              ((pEA)->Address3_present)
#define     IS_ADDRESS3_ABSENT(pEA)               (!IS_ADDRESS3_PRESENT(pEA))
#define     ADDRESS3_PRESENT(pEA)                 ((pEA)->Address3_present = 1 )
#define     ADDRESS3_ABSENT(pEA)                  ((pEA)->Address3_present = 0 )

#define     IS_ADSPATH_PRESENT(pEA)               ((pEA)->ADsPath_present)
#define     IS_ADSPATH_ABSENT(pEA)                (!IS_ADSPATH_PRESENT(pEA))
#define     ADSPATH_PRESENT(pEA)                  ((pEA)->ADsPath_present = 1)
#define     ADSPATH_ABSENT(pEA)                   ((pEA)->ADsPath_present = 0)

#define     IS_STOREGETTYPE_PRESENT(pEA)          ((pEA)->StoreGetType_present)
#define     IS_STOREGETTYPE_ABSENT(pEA)           (!((pEA)->StoreGetType_present))
#define     STOREGETTYPE_PRESENT(pEA)             ((pEA)->StoreGetType_present = 1)
#define     STOREGETTYPE_ABSENT(pEA)              ((pEA)->StoreGetType_present = 0)

#define     IS_FLAGS1_PRESENT(pEA)                ((pEA)->Flags1_present)
#define     IS_FLAGS1_ABSENT(pEA)                 (!((pEA)->Flags1_present))
#define     FLAGS1_PRESENT(pEA)                   ((pEA)->Flags1_present = 1)
#define     FLAGS1_ABSENT(pEA)                    ((pEA)->Flags1_present = 0)

#define     IS_FLAGS2_PRESENT(pEA)                ((pEA)->Flags2_present)
#define     IS_FLAGS2_ABSENT(pEA)                 (!((pEA)->Flags2_present))
#define     FLAGS2_PRESENT(pEA)                   ((pEA)->Flags2_present = 1)
#define     FLAGS2_ABSENT(pEA)                    ((pEA)->Flags2_present = 0)

#define     IS_DWORD1_PRESENT(pEA)                ((pEA)->Dword1_present)
#define     IS_DWORD1_ABSENT(pEA)                 (!((pEA)->Dword1_present))
#define     DWORD1_PRESENT(pEA)                   ((pEA)->Dword1_present = 1)
#define     DWORD1_ABSENT(pEA)                    ((pEA)->Dword1_present = 0)

#define     IS_DWORD2_PRESENT(pEA)                ((pEA)->Dword2_present)
#define     IS_DWORD2_ABSENT(pEA)                 (!((pEA)->Dword2_present))
#define     DWORD2_PRESENT(pEA)                   ((pEA)->Dword2_present = 1)
#define     DWORD2_ABSENT(pEA)                    ((pEA)->Dword2_present = 0)

#define     IS_STRING1_PRESENT(pEA)               ((pEA)->String1_present)
#define     IS_STRING1_ABSENT(pEA)                (!((pEA)->String1_present))
#define     STRING1_PRESENT(pEA)                  ((pEA)->String1_present = 1)
#define     STRING1_ABSENT(pEA)                   ((pEA)->String1_present = 0)

#define     IS_STRING2_PRESENT(pEA)               ((pEA)->String2_present)
#define     IS_STRING2_ABSENT(pEA)                (!((pEA)->String2_present))
#define     STRING2_PRESENT(pEA)                  ((pEA)->String2_present = 1)
#define     STRING2_ABSENT(pEA)                   ((pEA)->String2_present = 0)

#define     IS_STRING3_PRESENT(pEA)               ((pEA)->String3_present)
#define     IS_STRING3_ABSENT(pEA)                (!((pEA)->String3_present))
#define     STRING3_PRESENT(pEA)                  ((pEA)->String3_present = 1)
#define     STRING3_ABSENT(pEA)                   ((pEA)->String3_present = 0)

#define     IS_STRING4_PRESENT(pEA)               ((pEA)->String4_present)
#define     IS_STRING4_ABSENT(pEA)                (!((pEA)->String4_present))
#define     STRING4_PRESENT(pEA)                  ((pEA)->String4_present = 1)
#define     STRING4_ABSENT(pEA)                   ((pEA)->String4_present = 0)

#define     IS_BINARY1_PRESENT(pEA)               ((pEA)->Binary1_present)
#define     IS_BINARY1_ABSENT(pEA)                (!((pEA)->Binary1_present))
#define     BINARY1_PRESENT(pEA)                  ((pEA)->Binary1_present = 1)
#define     BINARY1_ABSENT(pEA)                   ((pEA)->Binary1_present = 0)

#define     IS_BINARY2_PRESENT(pEA)               ((pEA)->Binary2_present)
#define     IS_BINARY2_ABSENT(pEA)                (!((pEA)->Binary2_present))
#define     BINARY2_PRESENT(pEA)                  ((pEA)->Binary2_present = 1)
#define     BINARY2_ABSENT(pEA)                   ((pEA)->Binary2_present = 0)
//EndExport(defines)

//BeginExport(inline)
BOOL        _inline
IsAnythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    || IS_ADDRESS2_PRESENT(pEA)
    || IS_ADDRESS3_PRESENT(pEA)
    || IS_ADSPATH_PRESENT(pEA)
    || IS_STOREGETTYPE_PRESENT(pEA)
    || IS_FLAGS1_PRESENT(pEA)
    || IS_FLAGS2_PRESENT(pEA)
    || IS_DWORD1_PRESENT(pEA)
    || IS_DWORD2_PRESENT(pEA)
    || IS_STRING1_PRESENT(pEA)
    || IS_STRING2_PRESENT(pEA)
    || IS_STRING3_PRESENT(pEA)
    || IS_STRING4_PRESENT(pEA)
    || IS_BINARY1_PRESENT(pEA)
    || IS_BINARY2_PRESENT(pEA)
    ;
}
//EndExport(inline)

//BeginExport(inline)
BOOL        _inline
IsEverythingPresent(
    IN      PEATTRIB               pEA
)
{
    return IS_ADDRESS1_PRESENT(pEA)
    && IS_ADDRESS2_PRESENT(pEA)
    && IS_ADDRESS3_PRESENT(pEA)
    && IS_ADSPATH_PRESENT(pEA)
    && IS_STOREGETTYPE_PRESENT(pEA)
    && IS_FLAGS1_PRESENT(pEA)
    && IS_FLAGS2_PRESENT(pEA)
    && IS_DWORD1_PRESENT(pEA)
    && IS_DWORD2_PRESENT(pEA)
    && IS_STRING1_PRESENT(pEA)
    && IS_STRING2_PRESENT(pEA)
    && IS_STRING3_PRESENT(pEA)
    && IS_STRING4_PRESENT(pEA)
    && IS_BINARY1_PRESENT(pEA)
    && IS_BINARY2_PRESENT(pEA)
    ;
}
//EndExport(inline)

//BeginExport(inline)
VOID        _inline
EverythingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_PRESENT(pEA);
    ADDRESS2_PRESENT(pEA);
    ADDRESS3_PRESENT(pEA);
    ADSPATH_PRESENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_PRESENT(pEA);
    FLAGS2_PRESENT(pEA);
    DWORD1_PRESENT(pEA);
    DWORD2_PRESENT(pEA);
    STRING1_PRESENT(pEA);
    STRING2_PRESENT(pEA);
    STRING3_PRESENT(pEA);
    STRING4_PRESENT(pEA);
    BINARY1_PRESENT(pEA);
    BINARY2_PRESENT(pEA);
}
//EndExport(inline)

//BeginExport(inline)
VOID        _inline
NothingPresent(
    IN      PEATTRIB               pEA
)
{
    ADDRESS1_ABSENT(pEA);
    ADDRESS2_ABSENT(pEA);
    ADDRESS3_ABSENT(pEA);
    ADSPATH_ABSENT(pEA);
    STOREGETTYPE_ABSENT(pEA);
    FLAGS1_ABSENT(pEA);
    FLAGS2_ABSENT(pEA);
    DWORD1_ABSENT(pEA);
    DWORD2_ABSENT(pEA);
    STRING1_ABSENT(pEA);
    STRING2_ABSENT(pEA);
    STRING3_ABSENT(pEA);
    STRING4_ABSENT(pEA);
    BINARY1_ABSENT(pEA);
    BINARY2_ABSENT(pEA);
}
//EndExport(inline)


const       char
ch_Address1          = L'i' ,
ch_Address2          = L'j' ,
ch_Address3          = L'k' ,
ch_ADsPath_relative  = L'r' ,
ch_ADsPath_absolute  = L'p' ,
ch_ADsPath_diff_srvr = L'l' ,
ch_Flags1            = L'f' ,
ch_Flags2            = L'g' ,
ch_Dword1            = L'd' ,
ch_Dword2            = L'e' ,
ch_String1           = L's' ,
ch_String2           = L't' ,
ch_String3           = L'u' ,
ch_String4           = L'v' ,
ch_Binary1           = L'b' ,
ch_Binary2           = L'c' ,
ch_FieldSep          = L'$' ;

DWORD
StringToIpAddress(                                // convert a string to an ip-address
    IN      LPWSTR                 String,
    IN OUT  DWORD                 *Address
)
{
    CHAR                           Buffer[20];    // large enough to hold any ip address stuff
    DWORD                          Count;
    LPSTR                          SkippedWhiteSpace;

    Count = wcstombs(Buffer, String, sizeof(Buffer) - 1); // save space for '\0'
    if( -1 == Count ) return ERROR_INVALID_DATA;
    Buffer[Count] = '\0';

    SkippedWhiteSpace = Buffer;
    while(( ' ' == *SkippedWhiteSpace || '\t' == *SkippedWhiteSpace) &&
	  ( SkippedWhiteSpace < &Buffer[Count])) {
        SkippedWhiteSpace++;
    }

    *Address= ntohl(inet_addr(SkippedWhiteSpace));// address is in host order..
    if( '\0' == *SkippedWhiteSpace ) return ERROR_INVALID_DATA;

    return Count <= sizeof("000.000.000.000") ? ERROR_SUCCESS : ERROR_INVALID_DATA;
}

DWORD       _inline
StringToFlags(                                    // convert a string to a DWORD
    IN      LPWSTR                 String,
    IN OUT  DWORD                 *Flags
)
{
    DWORD                          Count;
    LPWSTR                         Remaining;

    *Flags = ntohl(wcstoul(String, &Remaining,0));// see input for # base. conv to host order

    if( *Remaining == L'\0' ) return ERROR_SUCCESS;
    return ERROR_INVALID_DATA;
}

BYTE        _inline
Hex(
    IN      WCHAR                  wCh
)
{
    if( wCh >= '0' && wCh <= '9' ) return wCh - '0';
    if( wCh >= 'A' && wCh <= 'F' ) return wCh - 'A' + 10;
    if( wCh >= 'a' && wCh <= 'f' ) return wCh - 'a' + 10;
    return 0x0F+1;                                // this means error!!!
}

DWORD       _inline
StringToBinary(                                   // inline conversion of a string to binary
    IN OUT  LPWSTR                 String,        // this string is mangled while converting
    IN OUT  LPBYTE                *Bytes,         // this ptr is set to some memory in String..
    IN OUT  DWORD                 *nBytes         // # of hex bytes copied into location Bytes
) {
    LPBYTE                         HexString;
    DWORD                          n;
    BYTE                           ch1, ch2;

    HexString = *Bytes = (LPBYTE)String;
    n = 0;

    while( *String != L'\0' ) {                   // look at each character
        ch1 = Hex(*String++);
        ch2 = Hex(*String++);
        if( ch1 > 0xF || ch2 > 0xF ) {            // invalid hex bytes for input?
            return ERROR_INVALID_DATA;
        }
        *HexString ++ = (ch1 << 4 ) | ch2;
        n ++;
    }
    *nBytes = n;

    return ERROR_SUCCESS;
}

DWORD
ConvertStringtoEAttrib(                           // parse and get the fields out
    IN OUT  LPWSTR                 String,        // may be destroyed in the process
    IN OUT  PEATTRIB               Attrib         // fill this in
)
{
    DWORD                          Result;
    DWORD                          Address;
    DWORD                          Flags;
    WCHAR                          ThisChar;
    LPWSTR                         ThisString;
    CHAR                           Dummy[20];
    WCHAR                          Sep;

    Require(Attrib);
    NothingPresent(Attrib);

    if( String ) StoreTrace2("ConvertStringtoEAttrib(%ws) called\n", String);
    Sep = ch_FieldSep;

    while(String && *String && (ThisChar = *String ++)) {
        ThisString = String;
        do {                                      // skip to the next attrib
            String = wcschr(String, Sep);
            if( NULL == String ) break;
            if( String[1] == Sep ) {              // double consequtive field-sep's stand for the real thing..
                wcscpy(String, &String[1]);       // remove one of the field-separators, and try looking for one lateron.
                String ++;
                continue;
            }
            *String++ = L'\0';                    // ok, got a real separator: mark that zero and prepare for next
            break;
        } while(1);                               // this could as well be while(0) ??

        if( ch_Address1 == ThisChar ) {           // this is address1
            SetInternalFormatError(REPEATED_ADDRESS1, IS_ADDRESS1_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS1, TRUE);
            } else {
                ADDRESS1_PRESENT(Attrib);
                Attrib->Address1 = Address;
                StoreTrace2("Found address1 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address2 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS2, IS_ADDRESS2_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS2, TRUE);
            } else {
                ADDRESS2_PRESENT(Attrib);
                Attrib->Address2 = Address;
                StoreTrace2("Found address2 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address3 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS3, IS_ADDRESS3_PRESENT(Attrib));
            Result = StringToIpAddress(
                ThisString,
                &Address
            );
            if( ERROR_SUCCESS != Result ) {       // should not happen
                SetInternalFormatError(INVALID_ADDRESS3, TRUE);
            } else {
                ADDRESS3_PRESENT(Attrib);
                Attrib->Address3 = Address;
                StoreTrace2("Found address3 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_ADsPath_relative == ThisChar ||
            ch_ADsPath_absolute == ThisChar ||
            ch_ADsPath_diff_srvr == ThisChar ) {
            SetInternalFormatError(REPEATED_ADSPATH, IS_ADSPATH_PRESENT(Attrib));
            ADSPATH_PRESENT(Attrib);
            STOREGETTYPE_PRESENT(Attrib);
            Attrib->ADsPath = ThisString;
            if( ch_ADsPath_relative == ThisChar )
                Attrib->StoreGetType = StoreGetChildType;
            else if(ch_ADsPath_absolute == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteSameServerType;
            else if(ch_ADsPath_diff_srvr == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteOtherServerType;
            StoreTrace3("Found path [%ld] [%ws]\n", Attrib->StoreGetType, ThisString);
            continue;
        }

        if( ch_String1 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING1, IS_STRING1_PRESENT(Attrib));
            STRING1_PRESENT(Attrib);
            Attrib->String1 = ThisString;
            StoreTrace2("Found string1 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String2 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING2, IS_STRING2_PRESENT(Attrib));
            STRING2_PRESENT(Attrib);
            Attrib->String2 = ThisString;
            StoreTrace2("Found string2 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String3 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING3, IS_STRING3_PRESENT(Attrib));
            STRING3_PRESENT(Attrib);
            Attrib->String3 = ThisString;
            StoreTrace2("Found string3 [%ws]\n", ThisString);
            continue;
        }

        if( ch_String4 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING4, IS_STRING4_PRESENT(Attrib));
            STRING4_PRESENT(Attrib);
            Attrib->String4 = ThisString;
            StoreTrace2("Found string4 [%ws]\n", ThisString);
            continue;
        }

        if( ch_Flags1 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS1, IS_FLAGS1_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_FLAGS1, TRUE);
            } else {
                FLAGS1_PRESENT(Attrib);
                Attrib->Flags1 = Flags;
                StoreTrace2("Found flags1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Flags2 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS2, IS_FLAGS2_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_FLAGS2, TRUE);
            } else {
                FLAGS2_PRESENT(Attrib);
                Attrib->Flags2 = Flags;
                StoreTrace2("Found flags2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword1 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD1, IS_DWORD1_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_DWORD1, TRUE);
            } else {
                DWORD1_PRESENT(Attrib);
                Attrib->Dword1 = Flags;
                StoreTrace2("Found dword1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword2 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD2, IS_DWORD2_PRESENT(Attrib));
            Result = StringToFlags(
                ThisString,
                &Flags
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_DWORD2, TRUE);
            } else {
                DWORD2_PRESENT(Attrib);
                Attrib->Dword2 = Flags;
                StoreTrace2("Found dword2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Binary1 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY1, IS_BINARY1_PRESENT(Attrib));
            Result = StringToBinary(
                ThisString,
                &Attrib->Binary1,
                &Attrib->BinLen1
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_BINARY1, TRUE);
                BINARY1_ABSENT(Attrib);
            } else {
                BINARY1_PRESENT(Attrib);
                StoreTrace2("Found Binary1 of length %ld\n", Attrib->BinLen1);
            }
            continue;
        }

        if( ch_Binary2 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY2, IS_BINARY2_PRESENT(Attrib));
            Result = StringToBinary(
                ThisString,
                &Attrib->Binary2,
                &Attrib->BinLen2
            );
            if( ERROR_SUCCESS != Result ) {
                SetInternalFormatError(INVALID_BINARY2, TRUE);
                BINARY2_ABSENT(Attrib);
            } else {
                BINARY2_PRESENT(Attrib);
                StoreTrace2("Found Binary2 of length %ld\n", Attrib->BinLen2);
            }
            continue;
        }

        SetInternalFormatError(INVALID_ATTRIB_FIELD, TRUE);
    }

    return IsAnythingPresent(Attrib)? ERROR_SUCCESS : ERROR_INVALID_DATA;
}

BOOL        _inline
InvalidStringInBinary(                            // check if the given binary stream forms a LPWSTR
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLen
)
{
    if( 0 == DataLen ) return TRUE;
    if( DataLen % sizeof(WCHAR) ) return TRUE;
    DataLen /= sizeof(WCHAR);
    if( L'\0' != ((LPWSTR)Data)[DataLen-1] ) return TRUE;
    return FALSE;
}

DWORD
ConvertBinarytoEAttrib(                           // parse and get the fields out
    IN OUT  LPBYTE                 Data,          // input free format data
    IN      DWORD                  DataLen,       // bytes for data length
    IN OUT  PEATTRIB               Attrib         // fill this in
)
{
    DWORD                          Result;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          Offset;
    DWORD                          ThisDataLen;
    DWORD                          xDataLen;
    LPBYTE                         xData;
    LPBYTE                         ThisData;
    WCHAR                          ThisChar;
    CHAR                           Dummy[20];

    Require(Attrib);
    NothingPresent(Attrib);

    Offset = 0;
    while( Data && DataLen >= sizeof(BYTE) + sizeof(WORD) ) {
        ThisChar = ntohs(*(LPWORD)Data);
        Data += sizeof(WORD); DataLen -= sizeof(WORD);
        ThisDataLen = ntohs(*(LPWORD)Data);
        Data += sizeof(WORD); DataLen -= sizeof(WORD);
        if( ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD) > DataLen ) {
            SetInternalFormatError(INVALID_BINARY_CODING, TRUE);
            break;
        }
        ThisData = Data;
        Data += ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD);
        DataLen -= ROUND_UP_COUNT(ThisDataLen, ALIGN_WORD);

        if( ch_Address1 == ThisChar ) {           // this is address1
            SetInternalFormatError(REPEATED_ADDRESS1, IS_ADDRESS1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS1, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS1_PRESENT(Attrib);
                Attrib->Address1 = Address;
                StoreTrace2("Found address1 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address2 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS2, IS_ADDRESS2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS2, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS2_PRESENT(Attrib);
                Attrib->Address2 = Address;
                StoreTrace2("Found address2 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_Address3 == ThisChar ) {
            SetInternalFormatError(REPEATED_ADDRESS3, IS_ADDRESS3_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_ADDRESS3, TRUE);
            } else {
                Address = ntohl(*(DWORD UNALIGNED *)ThisData);
                ADDRESS3_PRESENT(Attrib);
                Attrib->Address3 = Address;
                StoreTrace2("Found address3 %s\n", inet_ntoa(*(struct in_addr*)&Address));
            }
            continue;
        }

        if( ch_ADsPath_relative == ThisChar ||
            ch_ADsPath_absolute == ThisChar ||
            ch_ADsPath_diff_srvr == ThisChar ) {
            SetInternalFormatError(REPEATED_ADSPATH, IS_ADSPATH_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_ADSPATH, TRUE);
                continue;
            }

            ADSPATH_PRESENT(Attrib);
            STOREGETTYPE_PRESENT(Attrib);
            Attrib->ADsPath = (LPWSTR)ThisData;
            if( ch_ADsPath_relative == ThisChar )
                Attrib->StoreGetType = StoreGetChildType;
            else if(ch_ADsPath_absolute == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteSameServerType;
            else if(ch_ADsPath_diff_srvr == ThisChar )
                Attrib->StoreGetType = StoreGetAbsoluteOtherServerType;
            StoreTrace3("Found path [%ld] [%ws]\n", Attrib->StoreGetType, (LPWSTR)ThisData);
            continue;
        }

        if( ch_String1 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING1, IS_STRING1_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING1, TRUE);
                continue;
            }
            STRING1_PRESENT(Attrib);
            Attrib->String1 = (LPWSTR)ThisData;
            StoreTrace2("Found string1 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String2 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING2, IS_STRING2_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING2, TRUE);
                continue;
            }
            STRING2_PRESENT(Attrib);
            Attrib->String2 = (LPWSTR)ThisData;
            StoreTrace2("Found string2 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String3 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING3, IS_STRING3_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING3, TRUE);
                continue;
            }
            STRING3_PRESENT(Attrib);
            Attrib->String3 = (LPWSTR)ThisData;
            StoreTrace2("Found string3 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_String4 == ThisChar ) {
            SetInternalFormatError(REPEATED_STRING4, IS_STRING4_PRESENT(Attrib));
            if( InvalidStringInBinary(ThisData, ThisDataLen) ) {
                SetInternalFormatError(INVALID_STRING4, TRUE);
                continue;
            }
            STRING4_PRESENT(Attrib);
            Attrib->String4 = (LPWSTR)ThisData;
            StoreTrace2("Found string4 [%ws]\n", (LPWSTR)ThisData);
            continue;
        }

        if( ch_Flags1 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS1, IS_FLAGS1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_FLAGS1, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                FLAGS1_PRESENT(Attrib);
                Attrib->Flags1 = Flags;
                StoreTrace2("Found flags1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Flags2 == ThisChar ) {
            SetInternalFormatError(REPEATED_FLAGS2, IS_FLAGS2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_FLAGS2, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                FLAGS2_PRESENT(Attrib);
                Attrib->Flags2 = Flags;
                StoreTrace2("Found flags2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword1 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD1, IS_DWORD1_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_DWORD1, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                DWORD1_PRESENT(Attrib);
                Attrib->Dword1 = Flags;
                StoreTrace2("Found dword1: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Dword2 == ThisChar ) {
            SetInternalFormatError(REPEATED_DWORD2, IS_DWORD2_PRESENT(Attrib));
            if( sizeof(DWORD) != ThisDataLen ) {
                SetInternalFormatError(INVALID_DWORD2, TRUE);
            } else {
                Flags = ntohl(*(DWORD UNALIGNED *)ThisData);
                DWORD2_PRESENT(Attrib);
                Attrib->Dword2 = Flags;
                StoreTrace2("Found dword2: 0x%lx\n", Flags);
            }
            continue;
        }

        if( ch_Binary1 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY1, IS_BINARY1_PRESENT(Attrib));
            BINARY1_PRESENT(Attrib);
            Attrib->Binary1 = ThisData;
            Attrib->BinLen1 = ThisDataLen;
            StoreTrace2("Found %ld bytes of binary 1 data\n", ThisDataLen);
            continue;
        }

        if( ch_Binary2 == ThisChar ) {
            SetInternalFormatError(REPEATED_BINARY2, IS_BINARY2_PRESENT(Attrib));
            BINARY2_PRESENT(Attrib);
            Attrib->Binary2 = ThisData;
            Attrib->BinLen2 = ThisDataLen;
            StoreTrace2("Found %ld bytes of binary 2 data\n", ThisDataLen);
            continue;
        }

        SetInternalFormatError(INVALID_ATTRIB_FIELD, TRUE);
    }

    return IsAnythingPresent(Attrib) ? ERROR_SUCCESS: ERROR_INVALID_DATA;
}

PEATTRIB
CloneAttrib(
    IN      PEATTRIB               Attrib
)
{
    PEATTRIB                       RetVal;
    DWORD                          Size;

    Size = sizeof(*Attrib);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->ADsPath));
    }
    if( IS_STRING1_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String1));
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String2));
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String3));
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String4));
    }

    if( IS_BINARY1_PRESENT(Attrib) ) Size += Attrib->BinLen1;
    if( IS_BINARY2_PRESENT(Attrib) ) Size += Attrib->BinLen2;

    RetVal = (PEATTRIB)MemAlloc(Size);
    if( NULL == RetVal ) return NULL;

    Size = sizeof(*Attrib);
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    *RetVal = *Attrib;

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        RetVal->ADsPath = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->ADsPath));
        wcscpy(RetVal->ADsPath, Attrib->ADsPath);
    }
    if( IS_STRING1_PRESENT(Attrib) ) {
        RetVal->String1 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String1));
        wcscpy(RetVal->String1, Attrib->String1);
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        RetVal->String2 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String2));
        wcscpy(RetVal->String2, Attrib->String2);
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        RetVal->String3 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String3));
        wcscpy(RetVal->String3, Attrib->String3);
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        RetVal->String4 = (LPWSTR)(Size + (LPBYTE)RetVal);
        Size += sizeof(WCHAR)*(1 + wcslen(Attrib->String4));
        wcscpy(RetVal->String4, Attrib->String4);
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        RetVal->Binary1 = (Size + (LPBYTE)RetVal);
        Size += Attrib->BinLen1;
        memcpy(RetVal->Binary1, Attrib->Binary1, Attrib->BinLen1);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        RetVal->Binary2 = (Size + (LPBYTE)RetVal);
        Size += Attrib->BinLen2;
        memcpy(RetVal->Binary2, Attrib->Binary2, Attrib->BinLen2);
    }

    return RetVal;
}

DWORD
AddAttribToArray(
    IN OUT  PARRAY                 Array,
    IN      PEATTRIB               Attrib
)
{
    DWORD                          Result;

    Require(Attrib);

    Attrib = CloneAttrib(Attrib);
    if( NULL == Attrib) return ERROR_NOT_ENOUGH_MEMORY;
    Result = MemArrayAddElement(Array, (LPVOID)Attrib);
    if( ERROR_SUCCESS == Result ) return ERROR_SUCCESS;
    MemFree(Attrib);
    return Result;
}

BOOL        _inline
OnlyADsPathPresent(
    IN      PEATTRIB               pEA
)
{
    if( ! IS_ADSPATH_PRESENT(pEA) ) return FALSE;
    return IS_ADDRESS1_ABSENT(pEA)
    && IS_ADDRESS2_ABSENT(pEA)
    && IS_ADSPATH_ABSENT(pEA)
    && IS_STOREGETTYPE_ABSENT(pEA)
    && IS_FLAGS1_ABSENT(pEA)
    && IS_FLAGS2_ABSENT(pEA)
    && IS_STRING1_ABSENT(pEA)
    && IS_STRING2_ABSENT(pEA)
    && IS_BINARY1_ABSENT(pEA)
    && IS_BINARY2_ABSENT(pEA)
    ;
}

DWORD
StoreCollectAttributes(                           // fwd declaration
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,
    IN      DWORD                  RecursionDepth
);

DWORD       _inline
StoreCollectAttributesInternal(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      PEATTRIB               Attrib,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   hStore2;

    if( 0 == RecursionDepth ) {
        Result = AddAttribToArray(ArrayToAddTo, Attrib);
        if( ERROR_SUCCESS != Result ) SetInternalFormatError(UNEXPECTED_INTERNAL_ERROR, TRUE);
        return ERROR_STACK_OVERFLOW;
    }

    StoreTrace2("Recursing to %ws\n", Attrib->ADsPath);
    Result = StoreGetHandle(
        hStore,
        /*Reserved*/ 0,
        Attrib->StoreGetType,
        Attrib->ADsPath,
        &hStore2
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = StoreCollectAttributes(
        &hStore2,
        Reserved,
        AttribName,
        ArrayToAddTo,
        RecursionDepth-1
    );

    Result2 = StoreCleanupHandle( &hStore2, 0 );

    return Result;
}

//BeginExport(function)
DWORD
StoreCollectAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // this attrib must be some kind of a text string
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Error;
    DWORD                          nAttributes;
    DWORD                          i;
    PADS_ATTR_INFO                 Attributes;
    LPWSTR                         Attribs[1];
    LPWSTR                         ThisAttribStr;
    EATTRIB                        ThisEAttrib;

    Attribs[0] = AttribName;
    Attributes = NULL;
    nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        hStore->ADSIHandle,
        Attribs,
        sizeof(Attribs)/sizeof(Attribs[0]),
        &Attributes,
        &nAttributes
    );
    if( HRESULT_FROM_WIN32( ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == hResult ) {
        return ERROR_SUCCESS;
    }

    if( FAILED(hResult) ) return ConvertHresult(hResult);

    if( 0 == nAttributes || NULL == Attributes )
        return ERROR_SUCCESS;

    Require( 1 == nAttributes );
    Error = ERROR_SUCCESS;

    for( i = 0; i < Attributes[0].dwNumValues ; i ++ ) {
        switch(Attributes[0].pADsValues[i].dwType) {
        case ADSTYPE_DN_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].DNString; break;
        case ADSTYPE_CASE_EXACT_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].CaseExactString; break;
        case ADSTYPE_CASE_IGNORE_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].CaseIgnoreString; break;
        case ADSTYPE_PRINTABLE_STRING:
            ThisAttribStr = Attributes[0].pADsValues[i].PrintableString; break;
        default:
            SetInternalFormatError(UNEXPECTED_COLLECTION_TYPE, TRUE);
            continue;
        }
        Require(ThisAttribStr);
        Result = ConvertStringtoEAttrib(ThisAttribStr, &ThisEAttrib);
        if( ERROR_SUCCESS == Result ) {
            if( OnlyADsPathPresent(&ThisEAttrib) ) {
                Result = StoreCollectAttributesInternal(
                    hStore,
                    Reserved,
                    &ThisEAttrib,
                    AttribName,
                    ArrayToAddTo,
                    RecursionDepth
                );
            } else {
                Result = AddAttribToArray(ArrayToAddTo, &ThisEAttrib);
            }
            if( ERROR_SUCCESS != Result ) Error = Result;
        } else Error = Result;
    }

    FreeADsMem(Attributes);

    return Error;
}

DWORD
StoreCollectBinaryAttributes(                     // fwd declaration
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,
    IN      DWORD                  RecursionDepth
);

DWORD       _inline
StoreCollectBinaryAttributesInternal(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      PEATTRIB               Attrib,
    IN      LPWSTR                 AttribName,
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
)
{
    DWORD                          Result, Result2;
    STORE_HANDLE                   hStore2;

    if( 0 == RecursionDepth ) {
        Result = AddAttribToArray(ArrayToAddTo, Attrib);
        if( ERROR_SUCCESS != Result ) SetInternalFormatError(UNEXPECTED_INTERNAL_ERROR, TRUE);
        return ERROR_STACK_OVERFLOW;
    }

    StoreTrace2("Recursing to %ws\n", Attrib->ADsPath);
    Result = StoreGetHandle(
        hStore,
        /*Reserved*/ 0,
        Attrib->StoreGetType,
        Attrib->ADsPath,
        &hStore2
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = StoreCollectBinaryAttributes(
        &hStore2,
        Reserved,
        AttribName,
        ArrayToAddTo,
        RecursionDepth-1
    );

    Result2 = StoreCleanupHandle( &hStore2, 0 );

    return Result;
}

//BeginExport(function)
DWORD
StoreCollectBinaryAttributes(
    IN OUT  PSTORE_HANDLE          hStore,
    IN      DWORD                  Reserved,
    IN      LPWSTR                 AttribName,    // accept only attrib type OCTET_STRING
    IN OUT  PARRAY                 ArrayToAddTo,  // array of PEATTRIBs
    IN      DWORD                  RecursionDepth // 0 ==> no recursion
) //EndExport(function)
{
    HRESULT                        hResult;
    DWORD                          Result;
    DWORD                          Error;
    DWORD                          nAttributes;
    DWORD                          i;
    DWORD                          DataLength;
    PADS_ATTR_INFO                 Attributes;
    LPWSTR                         Attribs[1];
    LPBYTE                         Data;
    EATTRIB                        ThisEAttrib;

    Attribs[0] = AttribName;
    Attributes = NULL;
    nAttributes = 0;
    hResult = ADSIGetObjectAttributes(
        hStore->ADSIHandle,
        Attribs,
        sizeof(Attribs)/sizeof(Attribs[0]),
        &Attributes,
        &nAttributes
    );

    if( HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) == hResult ) {
        return ERROR_SUCCESS;
    }
    if( FAILED(hResult) ) return ConvertHresult(hResult);

    if( 0 == nAttributes || NULL == Attributes )
        return ERROR_SUCCESS;

    Require( 1 == nAttributes );
    Error = ERROR_SUCCESS;

    for( i = 0; i < Attributes[0].dwNumValues ; i ++ ) {
        if( ADSTYPE_OCTET_STRING != Attributes[0].pADsValues[i].dwType ) {
            SetInternalFormatError(UNEXPECTED_COLLECTION_TYPE, TRUE);
            continue;
        }

        Data = Attributes[0].pADsValues[i].OctetString.lpValue;
        DataLength = Attributes[0].pADsValues[i].OctetString.dwLength;

        Result = ConvertBinarytoEAttrib(Data, DataLength, &ThisEAttrib);
        if( ERROR_SUCCESS == Result ) {
            if( OnlyADsPathPresent(&ThisEAttrib) ) {
                Result = StoreCollectBinaryAttributesInternal(
                    hStore,
                    Reserved,
                    &ThisEAttrib,
                    AttribName,
                    ArrayToAddTo,
                    RecursionDepth
                );
            } else {
                Result = AddAttribToArray(ArrayToAddTo, &ThisEAttrib);
            }
            if( ERROR_SUCCESS != Result ) Error = Result;
        } else Error = Result;
    }

    FreeADsMem(Attributes);

    return Error;
}

DWORD       _inline
SizeAfterSeparation(                              // the field separation character has to doubled.
    IN      LPWSTR                 String,        // string with field separation character not escape'ed.
    IN      WCHAR                  Sep
)
{
    DWORD                          RetVal;

    RetVal = wcslen(String);
    while(String = wcschr(String, Sep ) ) {
        RetVal ++;
    }

    return RetVal;
}

LPWSTR
ConvertStringToString(                            // duplicate any field_sep characters found
    IN      LPWSTR                 InStr,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str,           // copy into this pre-allocated buffer
    IN      WCHAR                  Sep
)
{
    *Str++ = PrefixChar;
    while( *InStr ) {
        if( Sep != *InStr ) {
            *Str ++ = *InStr;
        } else {
            *Str ++ = Sep;
            *Str ++ = Sep;
        }
        InStr ++;
    }

    *Str = L'\0';
    return Str;
}

LPWSTR                                            // Return the ptr to where the '\0' is stored
ConvertAddressToString(                           // convert ip address to dotted notation LPWSTR
    IN      DWORD                  Address,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str            // copy into this pre-allocated buffer
)
{
    LPSTR                          AsciiStr;

    Address = htonl(Address);                     // convert to n/w order before making string..
    *Str ++ = PrefixChar;
    AsciiStr = inet_ntoa(*(struct in_addr *)&Address);

    while( *Str ++ = (WCHAR) *AsciiStr ++ )
        ;

    Str --; *Str = L'\0';
    return Str;
}

LPWSTR
ConvertDwordToString(                             // convert a DWORD to string in 0x.... fmt
    IN      DWORD                  Dword,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str            // copy into this pre-allocated buffer
)
{
    UCHAR                          Ch;
    LPWSTR                         Stream;
    DWORD                          i;

    Dword = htonl(Dword);                         // convert to n/w order before making string.
    *Str ++ = PrefixChar;
    *Str ++ = L'0'; *Str ++ = L'x' ;

    Stream = Str; Str += sizeof(Dword)*2;
    for( i = sizeof(Dword); i ; i -- ) {
        Ch = (BYTE)(Dword & 0x0F);
        Dword >>= 4;
        Stream[i*2 -1] = (Ch < 10)? (L'0'+Ch) : (Ch-10 + L'A');
        Ch = (BYTE)(Dword & 0x0F);
        Dword >>= 4;
        Stream[i*2 -2] = (Ch < 10)? (L'0'+Ch) : (Ch-10 + L'A');
    }
    *Str = L'\0';
    return Str;
}

LPWSTR
ConvertBinaryToString(                            // convert a binary byte sequence to a string as 0F321B etc..
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes,
    IN      WCHAR                  PrefixChar,
    IN      LPWSTR                 Str
)
{
    BYTE                           Ch, Ch1, Ch2;
    DWORD                          i;

    *Str ++ = PrefixChar;

    for( i = 0;  i < nBytes; i ++ ) {
        Ch = *Bytes ++;
        Ch1 = Ch >> 4;
        Ch2 = Ch & 0x0F;

        if( Ch1 >= 10 ) *Str ++ = Ch1 - 10 + L'A';
        else *Str ++ = Ch1 + L'0';

        if( Ch2 >= 10 ) *Str ++ = Ch2 - 10 + L'A';
        else *Str ++ = Ch2 + L'0';
    }

    *Str = L'\0';
    return Str;
}

DWORD
ConvertEAttribToString(                           // inverse of ConvertStringtoEAttrib
    IN      PEATTRIB               Attrib,        // the attrib to encapsulate
    IN OUT  LPWSTR                *String,        // allocated string
    IN      WCHAR                  Sep
)
{
    DWORD                          nChars;
    LPWSTR                         Str;
    WCHAR                          PrefixChar;
    
    AssertRet(String && Attrib, ERROR_INVALID_PARAMETER);
    *String = NULL;

    nChars = 0;
    if( IS_ADDRESS1_PRESENT(Attrib) ) nChars += sizeof(L"$i000.000.000.000");
    if( IS_ADDRESS2_PRESENT(Attrib) ) nChars += sizeof(L"$j000.000.000.000");
    if( IS_ADDRESS3_PRESENT(Attrib) ) nChars += sizeof(L"$k000.000.000.000");

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        AssertRet( IS_STOREGETTYPE_PRESENT(Attrib), ERROR_INVALID_PARAMETER );
        AssertRet( Attrib->ADsPath, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->ADsPath,Sep);
        nChars += sizeof(L"$p");
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) nChars += sizeof(L"$f0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_FLAGS2_PRESENT(Attrib) ) nChars += sizeof(L"$g0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_DWORD1_PRESENT(Attrib) ) nChars += sizeof(L"$d0x") + sizeof(DWORD)*2*sizeof(WCHAR);
    if( IS_DWORD2_PRESENT(Attrib) ) nChars += sizeof(L"$e0x") + sizeof(DWORD)*2*sizeof(WCHAR);

    if( IS_STRING1_PRESENT(Attrib) ) {
        AssertRet( Attrib->String1, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String1,Sep);
        nChars += sizeof(L"$s");
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        AssertRet( Attrib->String2, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String2,Sep);
        nChars += sizeof(L"$t");
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        AssertRet( Attrib->String3, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String3,Sep);
        nChars += sizeof(L"$u");
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        AssertRet( Attrib->String4, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WCHAR) * SizeAfterSeparation(Attrib->String4,Sep);
        nChars += sizeof(L"$v");
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        nChars += sizeof(WCHAR) * 2 * Attrib->BinLen1;
        nChars += sizeof(L"$b");
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        nChars += sizeof(WCHAR) * 2 * Attrib->BinLen2;
        nChars += sizeof(L"$c");
    }

    if( 0 == nChars ) return ERROR_SUCCESS;       // nothing is present really.

    Str = MemAlloc(nChars + sizeof(L"") );        // take care of terminating the string
    if( NULL == Str ) return ERROR_NOT_ENOUGH_MEMORY;

    *String = Str;                                // save the return value, as Str keeps changing
    if( IS_ADDRESS1_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address1, ch_Address1, Str);
        *Str++ = Sep;
    }
    if( IS_ADDRESS2_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address2, ch_Address2, Str);
        *Str++ = Sep;
    }
    if( IS_ADDRESS3_PRESENT(Attrib) ) {
        Str = ConvertAddressToString(Attrib->Address3, ch_Address3, Str);
        *Str++ = Sep;
    }

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        switch(Attrib->StoreGetType) {
        case StoreGetChildType:
            PrefixChar = ch_ADsPath_relative; break;
        case StoreGetAbsoluteSameServerType:
            PrefixChar = ch_ADsPath_absolute; break;
        case StoreGetAbsoluteOtherServerType:
            PrefixChar = ch_ADsPath_diff_srvr; break;
        default:
            Require(FALSE);                       // too late to do anything about this now.
            PrefixChar = ch_ADsPath_diff_srvr; break;
        }
        Str = ConvertStringToString(Attrib->ADsPath, PrefixChar, Str,Sep);
        *Str++ = Sep;
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Flags1, ch_Flags1, Str);
        *Str++ = Sep;
    }
    if( IS_FLAGS2_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Flags2, ch_Flags2, Str);
        *Str++ = Sep;
    }
    if( IS_DWORD1_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Dword1, ch_Dword1, Str);
        *Str++ = Sep;
    }
    if( IS_DWORD2_PRESENT(Attrib) ) {
        Str = ConvertDwordToString(Attrib->Dword2, ch_Dword2, Str);
        *Str++ = Sep;
    }

    if( IS_STRING1_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String1, ch_String1, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String2, ch_String2, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String3, ch_String3, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        Str = ConvertStringToString(Attrib->String4, ch_String4, Str,Sep);
        *Str++ = Sep;
    }
    if( IS_BINARY1_PRESENT(Attrib) ) {
        Str = ConvertBinaryToString(Attrib->Binary1, Attrib->BinLen1, ch_Binary1, Str);
        *Str++ = Sep;
    }
    if( IS_BINARY2_PRESENT(Attrib) ) {
        Str = ConvertBinaryToString(Attrib->Binary2, Attrib->BinLen2, ch_Binary2, Str);
    }

    *Str = L'\0';
    Require(((LPBYTE)Str) < nChars + 1 + ((LPBYTE)(*String)) );

    return ERROR_SUCCESS;
}

LPBYTE
ConvertDwordToBinary(                             // pack a DWORD in binary format
    IN      DWORD                  Dword,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    *(LPWORD)Buffer = htons(Character); Buffer += sizeof(WORD);
    *(LPWORD)Buffer = htons(sizeof(DWORD)); Buffer += sizeof(WORD);
    *(DWORD UNALIGNED *)Buffer = htonl(Dword);
    Buffer += sizeof(DWORD);
    return Buffer;
}

LPBYTE
ConvertAddressToBinary(                           // pack an address to binary format..
    IN      DWORD                  Address,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    return ConvertDwordToBinary(Address,Character,Buffer);
}

LPBYTE
ConvertStringToBinary(                            // pack a string in binary format
    IN      LPWSTR                 Str,
    IN      WCHAR                  Character,
    IN      LPBYTE                 Buffer
)
{
    DWORD                          Size;

    Size = sizeof(WCHAR)*(1+wcslen(Str));

    *(LPWORD)Buffer = htons(Character); Buffer += sizeof(WORD);
    *(LPWORD)Buffer = htons((WORD)Size); Buffer += sizeof(WORD);
    memcpy(Buffer, Str, Size);
    Buffer += ROUND_UP_COUNT(Size, ALIGN_WORD);

    return Buffer;
}

DWORD
ConvertEAttribToBinary(                           // inverse of ConvertBinarytoEAttrib
    IN      PEATTRIB               Attrib,        // the attrib to encapsulate
    IN OUT  LPBYTE                *Bytes,         // allocated buffer
    IN OUT  DWORD                 *nBytes         // # of bytes allocated
)
{
    DWORD                          nChars;
    LPBYTE                         Buf;
    WCHAR                          PrefixChar;

    AssertRet(Bytes && Attrib && nBytes, ERROR_INVALID_PARAMETER);
    *Bytes = NULL; *nBytes =0;

    nChars = 0;                                   // WCHAR_opcode ~ WORD_size ~ DWORD_ipAddress
    if( IS_ADDRESS1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_ADDRESS2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_ADDRESS3_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        AssertRet( IS_STOREGETTYPE_PRESENT(Attrib), ERROR_INVALID_PARAMETER );
        AssertRet( Attrib->ADsPath, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1+ wcslen(Attrib->ADsPath));
    }

                                                  // WCHAR_opcode ~ WORD_size ~ DWORD_flags
    if( IS_FLAGS1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_FLAGS2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_DWORD1_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);
    if( IS_DWORD2_PRESENT(Attrib) ) nChars += sizeof(WORD) + sizeof(WORD) + sizeof(DWORD);

    if( IS_STRING1_PRESENT(Attrib) ) {
        AssertRet( Attrib->String1, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String1));
    }
    if( IS_STRING2_PRESENT(Attrib) ) {
        AssertRet( Attrib->String2, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String2));
    }
    if( IS_STRING3_PRESENT(Attrib) ) {
        AssertRet( Attrib->String3, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String3));
    }
    if( IS_STRING4_PRESENT(Attrib) ) {
        AssertRet( Attrib->String4, ERROR_INVALID_PARAMETER );
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += sizeof(WCHAR) * (1 + wcslen(Attrib->String4));
    }

    if( IS_BINARY1_PRESENT(Attrib) ) {
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += ROUND_UP_COUNT(Attrib->BinLen1, ALIGN_WORD);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        nChars += sizeof(WORD) + sizeof(WORD);    // WCHAR_opcode ~ WORD_size
        nChars += ROUND_UP_COUNT(Attrib->BinLen2, ALIGN_WORD);
    }

    if( 0 == nChars ) return ERROR_SUCCESS;       // nothing is present really.

    Buf = MemAlloc(nChars);
    if( NULL == Buf ) return ERROR_NOT_ENOUGH_MEMORY;

    *Bytes = Buf;                                 // save the return value.. Buf itself is changed..
    *nBytes = nChars;
    if( IS_ADDRESS1_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address1, ch_Address1, Buf);
    if( IS_ADDRESS2_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address2, ch_Address2, Buf);
    if( IS_ADDRESS3_PRESENT(Attrib) ) Buf = ConvertAddressToBinary(Attrib->Address3, ch_Address3, Buf);

    if( IS_ADSPATH_PRESENT(Attrib) ) {
        switch(Attrib->StoreGetType) {
        case StoreGetChildType:
            PrefixChar = ch_ADsPath_relative; break;
        case StoreGetAbsoluteSameServerType:
            PrefixChar = ch_ADsPath_absolute; break;
        case StoreGetAbsoluteOtherServerType:
            PrefixChar = ch_ADsPath_diff_srvr; break;
        default:
            Require(FALSE);                       // too late to do anything about this now.
            PrefixChar = ch_ADsPath_diff_srvr; break;
        }
        Buf = ConvertStringToBinary(Attrib->ADsPath, PrefixChar, Buf);
    }

    if( IS_FLAGS1_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Flags1, ch_Flags1, Buf);
    if( IS_FLAGS2_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Flags2, ch_Flags2, Buf);
    if( IS_DWORD1_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Dword1, ch_Dword1, Buf);
    if( IS_DWORD2_PRESENT(Attrib) ) Buf = ConvertDwordToBinary(Attrib->Dword2, ch_Dword2, Buf);

    if( IS_STRING1_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String1, ch_String1, Buf);
    if( IS_STRING2_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String2, ch_String2, Buf);
    if( IS_STRING3_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String3, ch_String3, Buf);
    if( IS_STRING4_PRESENT(Attrib) ) Buf = ConvertStringToBinary(Attrib->String4, ch_String4, Buf);

    if( IS_BINARY1_PRESENT(Attrib) ) {
        *(LPWORD)Buf = htons(ch_Binary1); Buf += sizeof(WORD);
        *(LPWORD)Buf = htons((WORD)Attrib->BinLen1); Buf += sizeof(WORD);
        memcpy(Buf, Attrib->Binary1, Attrib->BinLen1);
        Buf += ROUND_UP_COUNT(Attrib->BinLen1, ALIGN_WORD);
    }

    if( IS_BINARY2_PRESENT(Attrib) ) {
        *(LPWORD)Buf = htons(ch_Binary2); Buf += sizeof(WORD);
        *(LPWORD)Buf = htons((WORD)Attrib->BinLen2); Buf += sizeof(WORD);
        memcpy(Buf, Attrib->Binary2, Attrib->BinLen2);
        Buf += ROUND_UP_COUNT(Attrib->BinLen2, ALIGN_WORD);
    }

    Require( Buf  == nChars + (*Bytes) );

    return ERROR_SUCCESS;
}

StoreUpdateAttributesInternal(                    // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array,         // list of attribs
    IN      WCHAR                  Sep
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    LONG                           nValues, i;
    ADS_ATTR_INFO                  Attribute;
    PADSVALUE                      Values;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         Str;
    PEATTRIB                       ThisAttrib;

    if( NULL == hStore || NULL == hStore->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == AttribName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Array )
        return ERROR_INVALID_PARAMETER;

    nValues = MemArraySize(Array);

    if( 0 == nValues ) {                         // delete the attribute
        Attribute.pszAttrName = AttribName;
        Attribute.dwControlCode = ADS_ATTR_CLEAR;
        Attribute.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
        Attribute.pADsValues = NULL;
        Attribute.dwNumValues = 0;

        hResult = ADSISetObjectAttributes(
            /* hDSObject        */ hStore->ADSIHandle,
            /* pAttributeEntr.. */ &Attribute,
            /* dwNumAttributes  */ 1,
            /* pdwNumAttribut.. */ &nValues
        );
        if( FAILED(hResult) || 1 != nValues ) {   // something went wrong
            return ConvertHresult(hResult);
        }
        return ERROR_SUCCESS;
    }

    Values = MemAlloc(nValues * sizeof(ADSVALUE));
    if( NULL == Values ) {                        // could not allocate ADs array
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0, Result = MemArrayInitLoc(Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Result ;        // convert to PADS_ATTR_INFO
        i ++ , Result = MemArrayNextLoc(Array, &Loc)
    ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        Str = NULL;
        Result = ConvertEAttribToString(ThisAttrib, &Str, Sep);
        if( ERROR_SUCCESS != Result ) {           // something went wrong!
            goto Cleanup;                         // free allocated memory
        }

        Values[i].dwType = ADSTYPE_CASE_IGNORE_STRING;
        Values[i].CaseIgnoreString = Str;
    }

    Attribute.pszAttrName = AttribName;
    Attribute.dwControlCode = ADS_ATTR_UPDATE;
    Attribute.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    Attribute.pADsValues = Values;
    Attribute.dwNumValues = nValues;

    hResult = ADSISetObjectAttributes(
        /* hDSObject        */ hStore->ADSIHandle,
        /* pAttributeEntr.. */ &Attribute,
        /* dwNumAttributes  */ 1,
        /* pdwNumAttribut.. */ &nValues
    );
    if( FAILED(hResult) || 1 != nValues ) {       // something went wrong
        Result = ConvertHresult(hResult);
    } else Result = ERROR_SUCCESS;

  Cleanup:

    if( Values ) {                                // got to free allocated memory
        while( i -- ) {                           // got to free converted strings
            if( Values[i].CaseIgnoreString )
                MemFree(Values[i].CaseIgnoreString);
        }
        MemFree(Values);
    }

    return Result;
}


//BeginExport(function)
//DOC StoreUpdateAttributes is sort of the converse of StoreCollectAttributes.
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function does not work when the attrib is of type
//DOC OCTET_STRING etc.  It works only with types that can be derived from
//DOC PrintableString.
DWORD
StoreUpdateAttributes(                            // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be string type
    IN      PARRAY                 Array          // list of attribs
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;

    Result = StoreUpdateAttributesInternal(
        hStore, Reserved, AttribName, Array, ch_FieldSep );

    return Result;
}

//BeginExport(function)
//DOC StoreUpdateBinaryAttributes is sort of the converse of StoreCollectBinaryAttributes
//DOC This function takes an array of type EATTRIB elements and updates the DS
//DOC with this array.  This function works only when the attrib is of type
//DOC OCTET_STRING etc.  It doesnt work with types that can be derived from
//DOC PrintableString!!!.
DWORD
StoreUpdateBinaryAttributes(                      // update a list of attributes
    IN OUT  LPSTORE_HANDLE         hStore,        // handle to obj to update
    IN      DWORD                  Reserved,      // for future use, must be zero
    IN      LPWSTR                 AttribName,    // name of attrib, must be OCTET_STRING type
    IN      PARRAY                 Array          // list of attribs
) //EndExport(function)
{
    DWORD                          Result;
    HRESULT                        hResult;
    LONG                           nValues, i, nBytes;
    ADS_ATTR_INFO                  Attribute;
    PADSVALUE                      Values;
    ARRAY_LOCATION                 Loc;
    LPBYTE                         Bytes;
    PEATTRIB                       ThisAttrib;

    if( NULL == hStore || NULL == hStore->ADSIHandle )
        return ERROR_INVALID_PARAMETER;
    if( NULL == AttribName || 0 != Reserved )
        return ERROR_INVALID_PARAMETER;
    if( NULL == Array )
        return ERROR_INVALID_PARAMETER;

    nValues = MemArraySize(Array);

    if( 0 == nValues ) {                         // delete the attribute
        Attribute.pszAttrName = AttribName;
        Attribute.dwControlCode = ADS_ATTR_CLEAR;
        Attribute.dwADsType = ADSTYPE_OCTET_STRING;
        Attribute.pADsValues = NULL;
        Attribute.dwNumValues = 0;

        hResult = ADSISetObjectAttributes(
            /* hDSObject        */ hStore->ADSIHandle,
            /* pAttributeEntr.. */ &Attribute,
            /* dwNumAttributes  */ 1,
            /* pdwNumAttribut.. */ &nValues
        );
        if( FAILED(hResult) || 1 != nValues ) {   // something went wrong
            return ConvertHresult(hResult);
        }
        return ERROR_SUCCESS;
    }

    Values = MemAlloc(nValues * sizeof(ADSVALUE));
    if( NULL == Values ) {                        // could not allocate ADs array
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0, Result = MemArrayInitLoc(Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Result ;        // convert to PADS_ATTR_INFO
        i ++ , Result = MemArrayNextLoc(Array, &Loc)
    ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisAttrib);
        //- ERROR_SUCCESS == Result && NULL != ThisAttrib

        Bytes = NULL; nBytes =0;
        Result = ConvertEAttribToBinary(ThisAttrib, &Bytes, &nBytes);
        if( ERROR_SUCCESS != Result ) {           // something went wrong!
            goto Cleanup;                         // free allocated memory
        }

        Values[i].dwType = ADSTYPE_OCTET_STRING;
        Values[i].OctetString.dwLength = nBytes;
        Values[i].OctetString.lpValue = Bytes;
    }

    Attribute.pszAttrName = AttribName;
    Attribute.dwControlCode = ADS_ATTR_UPDATE;
    Attribute.dwADsType = ADSTYPE_OCTET_STRING;
    Attribute.pADsValues = Values;
    Attribute.dwNumValues = nValues;

    hResult = ADSISetObjectAttributes(
        /* hDSObject        */ hStore->ADSIHandle,
        /* pAttributeEntr.. */ &Attribute,
        /* dwNumAttributes  */ 1,
        /* pdwNumAttribut.. */ &nValues
    );
    if( FAILED(hResult) || 1 != nValues ) {       // something went wrong
        Result = ConvertHresult(hResult);
    } else Result = ERROR_SUCCESS;

  Cleanup:

    if( Values ) {                                // got to free allocated memory
        while( i -- ) {                           // got to free converted strings
            if( Values[i].OctetString.lpValue )
                MemFree(Values[i].OctetString.lpValue);
        }
        MemFree(Values);
    }

    return Result;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\tvalidate.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Abstract:

   Test the DS routines for memory, handle leaks.

Author:

   Ramesh V (05/18/1998)

Environment:

   User mode only.

--*/

#include    <windows.h>
#include    <dhcpapi.h>
#include    <dsauth.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <wchar.h>
#include    <winsock.h>

void _cdecl main(void) {
    char   buf[1000];
    DWORD  IpAddress, Error;

    printf("What is the IP address to validate for? :");
    scanf("%s", buf);

    IpAddress = inet_addr(buf);

    while(1) {
        Error = DhcpDSValidateServer(
            NULL,
            ntohl(IpAddress),
            NULL,
            NULL,
            0
        );
        printf(" DhcpDSValidateServer returned %ld\n", Error);
        Sleep(25*1000);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\tdhcpds2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This is the test program that tests the dhcpds functionality..
//================================================================================

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpapi.h>
#include    <dhcpbas.h>
#include    <rpcapi1.h>
#include    <rpcapi2.h>
#include    <dhcpds.h>

//================================================================================
//  testing the DS functionality
//================================================================================
VOID
PrintAndFreeServers(
    IN      LPDHCPDS_SERVERS Servers
)
{
    DWORD                          i;

    for( i = 0; i < Servers->NumElements; i ++ ) {
        printf("Server %ws Address 0x%lx\n", Servers->Servers[i].ServerName, Servers->Servers[i].IpAddress);
    }

    LocalFree(Servers);
    // must do MIDL_user_free here..
}

void
TestNew1(
    VOID
)
{
    DWORD                          Result;
    DWORD                          IpAddress;
    WCHAR                          ServerName[256];
    CHAR                           IpAddressString[256];
    LPDHCPDS_SERVERS               Servers;
    LPDHCPDS_SERVER                ThisServer;
    LPSTORE_HANDLE                 tDhcpGetGlobalDhcpRoot(VOID);

    Result = DhcpDsInit(
        0,
        NULL
    );
    if( ERROR_SUCCESS != Result ) {
        printf("DhcpDsInit: %ld (0x%lx)\n", Result, Result);
        return;
    }

    Result = StoreCreateObject(
        /* hStore               */ tDhcpGetGlobalDhcpRoot(),
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* NewObjName           */ DHCP_ROOT_OBJECT_CN_NAME,
        /* ...                  */
        /* Identification       */
        ADSTYPE_DN_STRING,         ATTRIB_DN_NAME,          DHCP_ROOT_OBJECT_NAME,
        ADSTYPE_DN_STRING,         ATTRIB_OBJECT_CLASS,     DEFAULT_DHCP_CLASS_ATTRIB_VALUE,

        /* systemMustContain    */
        ADSTYPE_INTEGER,           ATTRIB_DHCP_UNIQUE_KEY,  0,
        ADSTYPE_INTEGER,           ATTRIB_DHCP_TYPE,        0,
        ADSTYPE_DN_STRING,         ATTRIB_DHCP_IDENTIFICATION, L"This is a server",
        ADSTYPE_INTEGER,           ATTRIB_DHCP_FLAGS,       0,
        ADSTYPE_INTEGER,           ATTRIB_INSTANCE_TYPE,    DEFAULT_INSTANCE_TYPE_ATTRIB_VALUE,

        /* terminator           */
        ADSTYPE_INVALID
    );
    if( ERROR_SUCCESS != Result ) {
        printf("StoreCreateObject(ROOT): %ld\n", Result);
    }

#if 0
    Servers = NULL;
    Result = DhcpDsEnumServers(
        &1,
        &Servers,
        NULL,
        NULL
    );
    printf("DhcpEnumServers:0x%lx (%ld)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) PrintAndFreeServers(Servers);

    printf("ServerName: ");
    memset(ServerName, 0, sizeof(ServerName));
    scanf("%ws", ServerName);
    printf("ServerAddress: ");
    memset(IpAddressString, 0, sizeof(IpAddressString));
    scanf("%s", IpAddressString);

    ThisServer.ServerName = ServerName;
    ThisServer.ServerAddress = inet_addr(IpAddressString);
    printf("DhcpAddServer(%ws, %s): ", ThisServer.ServerName, inet_ntoa(*(struct in_addr *)&ThisServer.ServerAddress));
    Result = DhcpAddServer(0, NULL, &ThisServer, NULL, NULL);
    printf("0x%lx (%ld)\n", Result, Result);

    printf("ServerName: ");
    memset(ServerName, 0, sizeof(ServerName));
    scanf("%ws", ServerName);
    printf("ServerAddress: ");
    memset(IpAddressString, 0, sizeof(IpAddressString));
    scanf("%s", IpAddressString);

    ThisServer.ServerName = ServerName;
    ThisServer.ServerAddress = inet_addr(IpAddressString);
    printf("DhcpDeleteServer(%ws, %s): ", ThisServer.ServerName, inet_ntoa(*(struct in_addr *)&ThisServer.ServerAddress));
    Result = DhcpDeleteServer(0, NULL, &ThisServer, NULL, NULL);
    printf("0x%lx (%ld)\n", Result, Result);

#endif 0
    DhcpDsCleanup();
}

VOID
TestAll(
    VOID
)
{
    TestNew1();
}

void _cdecl main(
    VOID
)
{
    TestAll();
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\tdsopen.c ===
/*++

  Copyright (C) 1998 Microsoft Corporation

  Abstract:

     Test the ADSOpenDSObject call to see if it leaks memory

  Author:

     RameshV RameshV, 19-May-98 04:06

  Environment:

     User mode only

--*/

#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dsauth.h>

void _cdecl main(void) {
    HRESULT  Result, Error;
    HANDLE   Handle;
    ULONG    i,j;


    printf("how many iterations?: ");
    scanf("%ld", &i);
    printf("starting...");

    Sleep(60*1000);
    printf(" %ld iterations\n", i);

    for( j = 0; j < i ; j ++ ) {
        Result = ADSIOpenDSObject(
            L"LDAP://ntdev.microsoft.com/ROOTDSE",
            NULL,
            NULL,
            0,
            &Handle
        );

        if( FAILED(Result) ) {
            printf("ADSIOpenDSObject failed %lx\n", Result);
            // return;
            continue;
        }

        ADSICloseDSObject(Handle);

        printf("Completed round %i\n", j + 1);
    }

    printf("Done......");
    Sleep(5*60*1000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\tdhcpds.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This is the test program that tests the dhcpds functionality..
//================================================================================

#include    <windows.h>
#include    <dhcpds.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <wchar.h>
#include    <winsock.h>

//================================================================================
//  testing the DS functionality
//================================================================================
VOID
PrintAndFreeServers(
    IN      LPDHCP_SERVER_INFO_ARRAY Servers
)
{
    DWORD                          i;

    for( i = 0; i < Servers->NumElements; i ++ ) {
        printf("Server %ws Address 0x%lx\n", Servers->Servers[i].ServerName, Servers->Servers[i].ServerAddress);
    }

    LocalFree(Servers);
    // must do MIDL_user_free here..
}

void
TestNew1(
    VOID
)
{
    DWORD                          Result;
    DWORD                          IpAddress;
    WCHAR                          ServerName[256];
    CHAR                           IpAddressString[256];
    LPDHCP_SERVER_INFO_ARRAY       Servers;
    DHCP_SERVER_INFO               ThisServer = {
        0 /* Flags */, 0 /* State */, NULL /* ServerName */, 0 /* ServerAddress */
    };

    Result = DhcpDsInit(
        0,
        NULL
    );
    if( ERROR_SUCCESS != Result ) {
        printf("DhcpDsInit: %ld (0x%lx)\n", Result, Result);
        return;
    }

    Servers = NULL;
    Result = DhcpEnumServers(
        0,
        NULL,
        &Servers,
        NULL,
        NULL
    );
    printf("DhcpEnumServers:0x%lx (%ld)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) PrintAndFreeServers(Servers);

    printf("ServerName: ");
    memset(ServerName, 0, sizeof(ServerName));
    scanf("%ws", ServerName);
    printf("ServerAddress: ");
    memset(IpAddressString, 0, sizeof(IpAddressString));
    scanf("%s", IpAddressString);

    ThisServer.ServerName = ServerName;
    ThisServer.ServerAddress = inet_addr(IpAddressString);
    printf("DhcpAddServer(%ws, %s): ", ThisServer.ServerName, inet_ntoa(*(struct in_addr *)&ThisServer.ServerAddress));
    Result = DhcpAddServer(0, NULL, &ThisServer, NULL, NULL);
    printf("0x%lx (%ld)\n", Result, Result);

    printf("ServerName: ");
    memset(ServerName, 0, sizeof(ServerName));
    scanf("%ws", ServerName);
    printf("ServerAddress: ");
    memset(IpAddressString, 0, sizeof(IpAddressString));
    scanf("%s", IpAddressString);

    ThisServer.ServerName = ServerName;
    ThisServer.ServerAddress = inet_addr(IpAddressString);
    printf("DhcpDeleteServer(%ws, %s): ", ThisServer.ServerName, inet_ntoa(*(struct in_addr *)&ThisServer.ServerAddress));
    Result = DhcpDeleteServer(0, NULL, &ThisServer, NULL, NULL);
    printf("0x%lx (%ld)\n", Result, Result);

    DhcpDsCleanup();
}

VOID
TestAll(
    VOID
)
{
    TestNew1();
}

void _cdecl main(
    VOID
)
{
    TestAll();
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\tdhcpread.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: Rameshv
// Description: this program tests the dhcpread.c module.
//================================================================================

//================================================================================
//  headers
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>                            // need all the MM stuff...
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>                     // need all the registry stuff
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpread.h>
#include    <dhcpapi.h>
#include    <dhcpds.h>
#include    <mm\mmdump.h>

void _cdecl main(int argc, char *argv[]) {
    ARRAY                          TestArray;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      ThisServer;
    DWORD                          Result;
    LPWSTR                         ServerName;
    WCHAR                          Buf[1000];

    if( 1 == argc ) {                             // no arguments?  then dump full ds
        printf("================================================================================\n");
        printf("                     Dump of all DHCP servers in DS\n");
        printf("================================================================================\n");
        printf("***      Use: %s <server-name> to dump for required dhcp server alone        ***\n", argv[0]);
        printf("================================================================================\n");
        ServerName = NULL;
    } else if( 2 == argc ) {
        int i = 0;

        while(Buf[i] = (WCHAR)argv[1][i]) i ++;
        ServerName = Buf;
        printf("================================================================================\n");
        printf("                     Dump DHCP server <%ws>\n", ServerName);
        printf("================================================================================\n");
        printf("***      Use: %s <server-name> to dump for required dhcp server alone        ***\n", argv[0]);
        printf("================================================================================\n");
    } else {
        printf("Usage: %s [dns-name-of-dhcp-server-to-dump]\n", argv[0]);
        return;
    }

    Result = DhcpDsInitDS(0, NULL);
    if( ERROR_SUCCESS != Result ) {
        printf("DhcpDsInitDS failed: 0x%lx (%ld)\n", Result, Result);
        return;
    }

    MemArrayInit(&TestArray);
    Result = DhcpDsGetEnterpriseServers(
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServerName           */ ServerName,
        /* Servers              */ &TestArray
    );

    printf("DhcpDsGetEnterpriseServers(): 0x%lx (%ld)\n", Result, Result);
    printf("TestArray'Size = %ld\n", MemArraySize(&TestArray));

    for( Result = MemArrayInitLoc(&TestArray, &Loc)
         ; ERROR_SUCCESS == Result ;
         Result = MemArrayNextLoc(&TestArray, &Loc)
    ) {
        Result = MemArrayGetElement(&TestArray, &Loc, &ThisServer);
        MmDumpServer(0, ThisServer);
        MemServerFree(ThisServer);
    }
    printf("================================================================================\n");
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\upndown.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC DhcpDsGetLastUpdateTime gets the last update time for the server
//DOC specified by name. If the server does not exist, or if server object doesnt
//DOC exist, then an error is returned.  If the time value
//DOC does not exist on the server object, again, an error is returned.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
) ;


//DOC AddServer should add the new address to the server's attribs
//DOC it should take this opportunity to reconcile the server.
//DOC Currently it does nothing. (at the least it should probably try to
//DOC check if the object exists, and if not create it.)
//DOC
DWORD
AddServer(                                        // add server and do misc work
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for server obj
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ADsPath,       // ADS path to server object
    IN      DWORD                  IpAddress,     // IpAddress to add to server
    IN      DWORD                  State          // state of server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\upndown.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: Download and Upload related code.
//================================================================================

//================================================================================
//  includes
//================================================================================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpapi.h>
#include    <delete.h>
#include    <st_srvr.h>
#include    <rpcapi2.h>
#include    <rpcstubs.h>

//================================================================================
//  utilities
//================================================================================

//DOC DhcpDsServerGetLastUpdateTime gets the last update time for this server in the DS
DWORD
DhcpDsServerGetLastUpdateTime(                     // get last update time for server
    IN      LPSTORE_HANDLE         hServer,        // server to get last update time of
    IN OUT  LPFILETIME             Time            // set this struct appropriately
)
{
    HRESULT                        Err;
    DWORD                          nAttributes;
    LPWSTR                         TimeAttrName;   // attribute name for time..
    PADS_ATTR_INFO                 Attributes;
    SYSTEMTIME                     SysTime;

    TimeAttrName = DHCP_ATTRIB_WHEN_CHANGED;

    Attributes = NULL; nAttributes = 0;
    Err = ADSIGetObjectAttributes                  // now read the last changed time attr
    (
        hServer->ADSIHandle,
        &TimeAttrName,
        1,                                         // only 1 attribute in above array
        &Attributes,
        &nAttributes
    );
    if( FAILED(Err) || 0 == nAttributes || 0 == Attributes->dwNumValues ) {
        if( Attributes ) {
            FreeADsMem(Attributes);
            return ERROR_GEN_FAILURE;              // blanket error? maybe better err msg..
        }
        return ConvertHresult(Err);
    }

    if( Attributes->pADsValues[0].dwType != ADSTYPE_UTC_TIME ) {
        FreeADsMem(Attributes);
        return ERROR_GEN_FAILURE;                  // unexpected data format
    }

    SysTime = Attributes->pADsValues[0].UTCTime;   // copy time structs
    FreeADsMem(Attributes);

    Err = SystemTimeToFileTime(&SysTime, Time);    // try to convert to filetime struct
    if( FAILED( Err ) ) return GetLastError();      // something went wrong?
    return ERROR_SUCCESS;
}

BOOL        _inline
AddressFoundInHostent(
    IN      DHCP_IP_ADDRESS        AddrToSearch,  // Host-Order addr
    IN      HOSTENT               *ServerEntry    // entry to search for..
)
{
    ULONG                          nAddresses, ThisAddress;

    if( NULL == ServerEntry ) return FALSE;       // no address to search in

    nAddresses = 0;                               // have a host entry to compare for addresses
    while( ServerEntry->h_addr_list[nAddresses] ) {
        ThisAddress = ntohl(*(DHCP_IP_ADDRESS*)ServerEntry->h_addr_list[nAddresses++] );
        if( ThisAddress == AddrToSearch ) {
            return TRUE;                          // yeah address matched.
        }
    }

    return FALSE;
}


//================================================================================
//  exports
//================================================================================
//BeginExport(function)
//DOC DhcpDsGetLastUpdateTime gets the last update time for the server
//DOC specified by name. If the server does not exist, or if server object doesnt
//DOC exist, then an error is returned.  If the time value
//DOC does not exist on the server object, again, an error is returned.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
)   //EndExport(function)
{
    DWORD                          Err,i, LocType ;
    LPDHCPDS_SERVERS               Servers;
    extern STORE_HANDLE            hDhcpC, hDhcpRoot; // From rpcstubs.c
    LPWSTR                         Location, LocStr;
    BOOL                           Found;
    STORE_HANDLE                   hServer;
    HOSTENT                       *ServerEntry;

    if( NULL == ServerName ) return ERROR_INVALID_PARAMETER;
    do {                                          // name to IP lookup
        CHAR TmpBuf[300];
        wcstombs(TmpBuf, ServerName, sizeof(TmpBuf)-1);
        TmpBuf[sizeof(TmpBuf)-1] = '\0';
        ServerEntry = gethostbyname(TmpBuf);
    } while(0);

    Servers = NULL;
    Err = DhcpDsEnumServers                       // first get a list of servers
    (
        /* hDhcpC               */ &hDhcpC,       // frm rpcstubs.c, opened in DhcpDsInitDS
        /* hDhcpRoot            */ &hDhcpRoot,    // ditto
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ServersInfo          */ &Servers
    );
    if( ERROR_SUCCESS != Err ) {
        Time->dwLowDateTime = Time->dwHighDateTime = 0;
        return Err;                               // error.. return w/ no time
    }

    Found = FALSE;
    LocStr = Location = NULL;                     // initialize..
    for( i = 0; i < Servers->NumElements ; i ++ ) {
        if( 0 != _wcsicmp(ServerName, Servers->Servers[i].ServerName) &&
            !AddressFoundInHostent(Servers->Servers[i].ServerAddress, ServerEntry) ) {

            continue;                             // ughm.. not the same server..

        } else {                                  // ok got the server

            Location = Servers->Servers[i].DsLocation;
            LocType = Servers->Servers[i].DsLocType;
            Found = TRUE;
            if( NULL != Location ) break;
        }
    }

    if( ! Found ) {                               // could not find server in list..?
        MemFree(Servers);
        return ERROR_FILE_NOT_FOUND;
    }

    if( NULL == Location ) {                      // could not find server location?
        MemFree(Servers);                         // dont need this anymore
        Servers = NULL;
        Location  = MakeColumnName(ServerName);   // just presume it is under hDhcpC container
        LocType = StoreGetChildType;              // child type
        if( NULL == Location ) return ERROR_NOT_ENOUGH_MEMORY;
    }

    Err = StoreGetHandle                          // now try to open the server object
    (
        /* hStore               */ &hDhcpC,
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* StoreGetType         */ LocType,
        /* Path                 */ Location,
        /* hStoreOut            */ &hServer
    );

    if( Servers ) {                               // Location points into this
        MemFree(Servers);                         // freeing this also free Location
    } else {                                      // Location is allocated memory
        MemFree(Location);
    }

    if( ERROR_SUCCESS != Err ) return Err;        // some DS trouble?

    Err = DhcpDsServerGetLastUpdateTime(&hServer, Time);

    (void)StoreCleanupHandle(&hServer, 0);        // assume this wont fail.

    return Err;
}

//DOC ServerUploadClasses does rpc calls to server and copies stuff over to DS.
DWORD
ServerUploadClasses(                              // upload classes info to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress  // server ip address
)
{
    DWORD                          Err, Resume, PrefMax, i, nRead, nTotal;
    LPDHCP_CLASS_INFO_ARRAY        ClassesInfo;

    Resume = 0; PrefMax = 0xFFFFFFFF; nRead = nTotal = 0;
    ClassesInfo = NULL;
    Err = DhcpEnumClasses(ServerAddress, 0, &Resume, PrefMax, &ClassesInfo, &nRead, &nTotal);
    if( ERROR_NO_MORE_ITEMS == Err ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Err ) return Err;        // could not enumerate classes.

    for( i = 0; i < ClassesInfo->NumElements; i ++ ) {
        Err = DhcpCreateClassDS(ServerAddress, 0, &ClassesInfo->Classes[i]);
        if( ERROR_SUCCESS != Err ) break;
#if 0
        Err = ServerUploadOptDefsForClass(
            hDhcpC,
            hServer,
            ServerAddress,
            ClassesInfo->Classes[i].ClassName
        );
        if( ERROR_SUCCESS != Err ) break;
#endif
    }

    if( ClassesInfo ) MemFree(ClassesInfo);
    return Err;
}

//DOC ServerUploadOptdefs does rpc calls to server and copies stuff over to DS
DWORD
ServerUploadOptdefs(                              // upload opt defs info to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress  // server ip address
)
{
    DWORD                          Err, i;
    LPDHCP_ALL_OPTIONS             Options;

    Options = NULL;
    Err = DhcpGetAllOptions(ServerAddress,0, &Options);
    if( ERROR_NO_MORE_ITEMS == Err ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Err ) return Err;

    if( Options->NonVendorOptions ) {
        for( i = 0; i < Options->NonVendorOptions->NumElements; i ++ ) {
            Err = DhcpCreateOptionV5DS(
                ServerAddress,
                0,
                Options->NonVendorOptions->Options[i].OptionID,
                NULL /* no class */,
                NULL /* no vendor */,
                &Options->NonVendorOptions->Options[i]
            );
            if( ERROR_SUCCESS != Err ) break;
        }
    }

    if( ERROR_SUCCESS != Err ) {
        MemFree(Options);
        return Err;
    }


    for( i = 0; i < Options->NumVendorOptions; i ++ ) {
        Err = DhcpCreateOptionV5DS(
            ServerAddress,
            DHCP_FLAGS_OPTION_IS_VENDOR,
            Options->VendorOptions[i].Option.OptionID,
            Options->VendorOptions[i].ClassName,
            Options->VendorOptions[i].VendorName,
            &Options->VendorOptions[i].Option
        );
        if( ERROR_SUCCESS != Err ) break;
    }

    if( ERROR_SUCCESS != Err ) {
        MemFree(Options);
        return Err;
    }

    if( Options ) MemFree(Options);
    return Err;
}

//DOC UploadOptiosn does rpc calls to server and copies stuff over to DS
UploadOptions(                                    // upload options to DS
    IN      LPWSTR                 ServerAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          Err, Resume, PrefMax, i, nRead, nTotal;
    LPDHCP_ALL_OPTION_VALUES       Options;

    Resume = 0; PrefMax = 0xFFFFFFFF; nRead = nTotal = 0;
    Options = NULL;
    Err = DhcpGetAllOptionValues(                 // get list of default opt values
        ServerAddress,
        0,
        ScopeInfo,
        &Options
    );
    if( ERROR_NO_MORE_ITEMS == Err ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Err ) return Err;        // oops could not do this simple task?

    for( i = 0; i < Options->NumElements; i ++ ) {// now try to set each list of options..
        if( NULL == Options->Options[i].OptionsArray ) {
            continue;                             // uh? another way to say no options..
        }

        Err = DhcpSetOptionValuesV5DS   (
            ServerAddress,
            Options->Options[i].IsVendor? DHCP_FLAGS_OPTION_IS_VENDOR:0,
            Options->Options[i].ClassName,
            Options->Options[i].VendorName,
            ScopeInfo,
            Options->Options[i].OptionsArray
        );
        if( ERROR_SUCCESS != Err ) {
            MemFree(Options);
            return Err;
        }
    }

    return ERROR_SUCCESS;                         // saved it
}

//DOC ServerUploadOptions does rpc calls to server and copies stuff over to DS
DWORD
ServerUploadOptions(                              // upload options info to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress  // server ip address
)
{
    DWORD                          Err;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;

#if 0
    ScopeInfo.ScopeInfo.DefaultScopeInfo = NULL;
    ScopeInfo.ScopeType = DhcpDefaultOptions;
    Err = UploadOptions(ServerAddress, &ScopeInfo);
    if( ERROR_SUCCESS != Err ) return Err;        // could not save default options..
#endif

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;
    Err = UploadOptions(ServerAddress, &ScopeInfo);
    if( ERROR_SUCCESS != Err ) return Err;        // could not save global options..

    return ERROR_SUCCESS;
}

//DOC ReservationUploadOptions does rpc calls to server and copies stuff to DS
DWORD
ReservationUploadOptions(                         // upload reservation options to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress, // server ip address
    IN      DWORD                  SubnetAddress, // add of subnet to add
    IN      DWORD                  ReserveAddress // address of reservation
)
{
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = SubnetAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = ReserveAddress;
    return UploadOptions(ServerAddress, &ScopeInfo);
}

//DOC SubnetUploadOptions does rpc calls to server and copies stuff to DS
DWORD
SubnetUploadOptions(                              // upload subnet options to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress, // server ip address
    IN      DWORD                  SubnetAddress  // add of subnet to add
)
{
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo = SubnetAddress;
    return UploadOptions(ServerAddress, &ScopeInfo);
}

//DOC ServerUploadSubnet does rpc calls to server and copies stuff over to DS
DWORD
ServerUploadSubnet(                               // upload subnet and relevant info to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress, // server ip address
    IN      DWORD                  SubnetAddress  // add of subnet to add
)
{
    DWORD                          Err, Resume, PrefMax, i, nRead, nTotal;
    LPDHCP_SUBNET_INFO             SubnetInfo;
    DHCP_SUBNET_ELEMENT_TYPE       SubnetEltType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 EltInfo;
    LPDHCP_SUPER_SCOPE_TABLE       SScopeTbl;

    Err = DhcpGetSubnetInfo(ServerAddress, SubnetAddress, &SubnetInfo);
    if( ERROR_SUCCESS != Err ) return Err;        // could not get subnet info..

    Err = DhcpCreateSubnetDS(ServerAddress, SubnetAddress, SubnetInfo);
    if( SubnetInfo ) MemFree(SubnetInfo);
    if( ERROR_SUCCESS != Err ) return Err;        // could not save onto DS

    SScopeTbl = NULL;
    Err = DhcpGetSuperScopeInfoV4(                // get superscope table
        ServerAddress,
        &SScopeTbl
    );
    if( ERROR_SUCCESS == Err ) {                  // could get superscope table
        for( i = 0; i < SScopeTbl->cEntries ; i ++ ) {
            if( SScopeTbl->pEntries[i].SubnetAddress == SubnetAddress ) {
                Err = DhcpSetSuperScopeV4DS(
                    ServerAddress,
                    SubnetAddress,
                    SScopeTbl->pEntries[i].SuperScopeName,
                    TRUE /* change superscope if it exists..*/
                );
                break;
            }
        }
        MemFree(SScopeTbl);
        if( ERROR_SUCCESS != Err ) return Err;    // could not set superscope..
    }

    Resume = 0; PrefMax = 0xFFFFFFFF;
    EltInfo = NULL; nRead = nTotal = 0;
    Err = DhcpEnumSubnetElementsV4(               // enumerate ranges
        ServerAddress,
        SubnetAddress,
        DhcpIpRanges,
        &Resume,
        PrefMax,
        &EltInfo,
        &nRead,
        &nTotal
    );
    if( ERROR_SUCCESS != Err ) return Err;        // could not get ranges

    for( i = 0; i < EltInfo->NumElements; i ++ ) {// try to add each range
        Err = DhcpAddSubnetElementV4DS(
            ServerAddress,
            SubnetAddress,
            &EltInfo->Elements[i]
        );
        if( ERROR_SUCCESS != Err ) break;
    }
    if( EltInfo ) MemFree(EltInfo);               // free-up memory
    if( ERROR_SUCCESS != Err ) return Err;        // could not add ranges

    Resume = 0; PrefMax = 0xFFFFFFFF;
    EltInfo = NULL;
    Err = DhcpEnumSubnetElementsV4(               // enumerate reservations
        ServerAddress,
        SubnetAddress,
        DhcpReservedIps,
        &Resume,
        PrefMax,
        &EltInfo,
        &nRead,
        &nTotal
    );
    if( ERROR_NO_MORE_ITEMS == Err ) goto try_Excl;
    if( ERROR_SUCCESS != Err ) return Err;        // could not get exclusions

    for( i = 0; i < EltInfo->NumElements; i ++ ) {// try to add each reservation
        Err = DhcpAddSubnetElementV4DS(
            ServerAddress,
            SubnetAddress,
            &EltInfo->Elements[i]
        );
        if( ERROR_SUCCESS != Err ) break;         // could not add reseration in DS

        Err = ReservationUploadOptions(
            hDhcpC,
            hServer,
            ServerAddress,
            SubnetAddress,
            EltInfo->Elements[i].Element.ReservedIp->ReservedIpAddress
        );
        if( ERROR_SUCCESS != Err ) break;         // could not add reservaation options
    }
    if( EltInfo ) MemFree(EltInfo);               // free-up memory
    if( ERROR_SUCCESS != Err ) return Err;        // could not add exclusions

  try_Excl:

    Resume = 0; PrefMax = 0xFFFFFFFF;
    EltInfo = NULL;
    Err = DhcpEnumSubnetElementsV4(               // enumerate exclusions
        ServerAddress,
        SubnetAddress,
        DhcpReservedIps,
        &Resume,
        PrefMax,
        &EltInfo,
        &nRead,
        &nTotal
    );
    if( ERROR_NO_MORE_ITEMS == Err ) goto try_Options;
    if( ERROR_SUCCESS != Err ) return Err;        // could not get exclusions

    for( i = 0; i < EltInfo->NumElements; i ++ ) {// try to add each exclusion
        Err = DhcpAddSubnetElementV4DS(
            ServerAddress,
            SubnetAddress,
            &EltInfo->Elements[i]
        );
        if( ERROR_SUCCESS != Err ) break;
    }
    if( EltInfo ) MemFree(EltInfo);               // free-up memory
    if( ERROR_SUCCESS != Err ) return Err;        // could not add exclusions

  try_Options:
    return SubnetUploadOptions(hDhcpC,hServer,ServerAddress,SubnetAddress);
}

//DOC ServerUploadSubnets does rpc calls to server and copies stuff over to DS
DWORD
ServerUploadSubnets(                              // upload subnets info to DS
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // dhcp container to store at
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerAddress  // server ip address
)
{
    DWORD                          Err, Resume, PrefMax, i, nRead, nTotal;
    LPDHCP_IP_ARRAY                Subnets;

    Resume = 0; PrefMax = 0xFFFFFFFF; nRead = nTotal = 0;
    Subnets = NULL;
    Err = DhcpEnumSubnets(ServerAddress, &Resume, PrefMax, &Subnets, &nRead, &nTotal);
    if( ERROR_NO_MORE_ITEMS == Err ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Err ) return Err;        // could not get list of elements?

    for( i = 0; i < Subnets->NumElements ; i ++ ) {
        Err = ServerUploadSubnet(hDhcpC, hServer, ServerAddress, Subnets->Elements[i]);
        if( ERROR_SUCCESS != Err ) break;
    }

    if( Subnets ) MemFree(Subnets);
    return Err;
}

//DOC UploadServer downloads the server info by making RPC calls..
DWORD
UploadServer(                                     // make rpc calls and pull up info to DS.
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // general container where info is stored
    IN OUT  LPSTORE_HANDLE         hServer,       // server obj in DS
    IN      LPWSTR                 ServerName,    // name of server
    IN      DWORD                  IpAddress      // ip address of server
)
{
    DWORD                          Err;
    LPSTR                          IpAddrStr;
    WCHAR                          ServerAddress[sizeof("000.000.000.000")];

    IpAddress = htonl(IpAddress);                 // use n/w order ip address..
    IpAddrStr = inet_ntoa(*(struct in_addr *)&IpAddress);
    Err = mbstowcs(ServerAddress, IpAddrStr, ( sizeof(ServerAddress)/sizeof( WCHAR ) ) );
    if( -1 == Err ) {                             // could not convert to LPWSTR
        return ERROR_GEN_FAILURE;
    }

    Err = ServerUploadClasses(hDhcpC, hServer, ServerAddress);
    if( ERROR_SUCCESS != Err ) {                  // could not upload server classes info
        return Err;
    }

    Err = ServerUploadOptdefs(hDhcpC, hServer, ServerAddress);
    if( ERROR_SUCCESS != Err ) {                  // could not upload option defs ?
        return Err;
    }

    Err = ServerUploadOptions(hDhcpC, hServer, ServerAddress);
    if( ERROR_SUCCESS != Err ) {                  // could not upload options?
        return Err;
    }

    Err = ServerUploadSubnets(hDhcpC, hServer, ServerAddress);
    if( ERROR_SUCCESS != Err ) {                  // could not upload subnets?
        return Err;
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
//DOC AddServer should add the new address to the server's attribs
//DOC it should take this opportunity to reconcile the server.
//DOC Currently it does nothing. (at the least it should probably try to
//DOC check if the object exists, and if not create it.)
//DOC
DWORD
AddServer(                                        // add server and do misc work
    IN OUT  LPSTORE_HANDLE         hDhcpC,        // container for server obj
    IN      LPWSTR                 ServerName,    // [DNS?] name of server
    IN      LPWSTR                 ADsPath,       // ADS path to server object
    IN      DWORD                  IpAddress,     // IpAddress to add to server
    IN      DWORD                  State          // state of server
)   //EndExport(function)
{
    DWORD                          Err, Err2;
    STORE_HANDLE                   hServer;

    Err = StoreGetHandle(                         // get the server obj..
        hDhcpC,
        DDS_RESERVED_DWORD,
        StoreGetChildType,
        ADsPath,
        &hServer
    );

    if( ERROR_SUCCESS != Err ) return Err;        // could be because server obj elsewhere??

    if( !CFLAG_DONT_DO_DSWORK ) {                 // if DS stuff is enabled in the first place
        Err = UploadServer(hDhcpC, &hServer, ServerName, IpAddress);
    }

    StoreCleanupHandle(&hServer, 0);              // cleanup this server..

    return Err;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\test\makefile.inc ===
dhcpmsg.h dhcpmsg.rc msg00001.bin: dhcpmsg.mc
    mc -d -r .\ dhcpmsg.mc

clean::
    -del dhcpmsg.h dhcpmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\validate.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: Koti, modified by RameshV
// Description: Validates a service against the DS
//================================================================================

#include <hdrmacro.h>
#include <store.h>
#include <dhcpmsg.h>
#include <wchar.h>
#include <dhcpbas.h>
#include <dhcpapi.h>
#include <st_srvr.h>
#include <rpcapi2.h>
#undef   NET_API_FUNCTION
#include <iphlpapi.h>
#include <dnsapi.h>
#include <mmreg\regutil.h>

//
// Retrieve a list of IP addresses for the interfaces
// 

DWORD
GetIpAddressList(
    IN OUT PDWORD *Addresses,
    IN OUT DWORD  *nAddresses
)
{
    DWORD             Size, Error, i;
    PMIB_IPADDRTABLE  IpAddrTable;

    AssertRet((( Addresses != NULL ) && ( nAddresses != NULL)),
	      ERROR_INVALID_PARAMETER );

    Size = 0;

    // Get the required size
    Error = GetIpAddrTable( NULL, &Size, FALSE );

    if( ERROR_INSUFFICIENT_BUFFER != Error ) {
	return Error;
    }
    
    IpAddrTable = MemAlloc( Size );
    if ( NULL == IpAddrTable ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = GetIpAddrTable( IpAddrTable, &Size, FALSE );
    if (( NO_ERROR != Error ) ||
	( 0 == IpAddrTable->dwNumEntries )) {
	*Addresses = NULL;
	*nAddresses = 0;
	MemFree(IpAddrTable);
	return Error;
    }

    *Addresses = MemAlloc( IpAddrTable->dwNumEntries * sizeof( DWORD ));
    if ( NULL == *Addresses ) {
	*nAddresses = 0;
	MemFree( IpAddrTable );
	return ERROR_NOT_ENOUGH_MEMORY;
    }
    *nAddresses = IpAddrTable->dwNumEntries ;
    
    for( i = 0; i < *nAddresses; i ++ ) {
	(*Addresses)[i] = IpAddrTable->table[i].dwAddr;
    }

    MemFree( IpAddrTable );
    return ERROR_SUCCESS;
} // GetIpAddressList()

LPWSTR GetHostName(
   VOID
)
{
    LPWSTR  HostName;
    DWORD   Length;
    DWORD   Error;

    // Get the required length
    Length = 0;
    GetComputerNameExW( ComputerNameDnsFullyQualified,
			NULL, &Length );

    HostName = MemAlloc( Length * sizeof( WCHAR ));
    if ( NULL == HostName ) {
	return NULL;
    }

    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
			      HostName, &Length )) {
	MemFree( HostName );
	return NULL;
    }

    return HostName;
    
} // GetHostName()

//BeginExport(function)
//DOC This function is declared in dhcpds.c..
//DOC DhcpDsValidateService checks the given service in the DS to see if it exists
//DOC If the machine is a standalone, it sets IsStandAlone and returns ERROR_SUCCESS
//DOC If the entry for the given Address is found, it sets Found to TRUE and returns
//DOC ERROR_SUCCESS. If the DhcpRoot node is found, but entry is not Found, it sets
//DOC Found to FALSE and returns ERROR_SUCCESS; If the DS could not be reached, it
//DOC returns ERROR_FILE_NOT_FOUND or probably other DS errors.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses, OPTIONAL
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone // not used
)   //EndExport(function)
{
    DWORD               Result, Error,i;
    STORE_HANDLE        hStoreCC, hDhcpC, hDhcpRoot;
    DWORD              *Addr;
    BOOL                TableAddr;
    WCHAR               PrintableIp[ 20 ]; // 000.000.000.000
    LPWSTR              HostName;          
 
    if( NULL == Found || NULL == IsStandAlone ) {
        return ERROR_INVALID_PARAMETER;
    }

    *IsStandAlone = FALSE;

    Result = StoreInitHandle                      // get the config container handle
    (
        /* hStore               */ &hStoreCC,     // config container
        /* Reserved             */ DDS_RESERVED_DWORD,
        /* ThisDomain           */ Domain,
        /* UserName             */ UserName,
        /* Password             */ Password,
        /* AuthFlags            */ AuthFlags
    );
    if( ERROR_SUCCESS != Result ) return Result;  // DS error

    Result = DhcpDsGetRoot                        // get dhcp root object
    (
        /* Flags                */ 0,             // no flags
        /* hStoreCC             */ &hStoreCC,
        /* hDhcpRoot            */ &hDhcpRoot
    );

    if( ERROR_SUCCESS != Result ) {
        
        //
        // If the failure is because the dhcp root object
        // can't be seen, then treat that as positive failure
        // to authorize.
        //
        
        if( ERROR_DDS_NO_DHCP_ROOT == Result ) {
            Result = NO_ERROR;
        } else {
            Result = GetLastError();
        }
        
        StoreCleanupHandle(&hStoreCC, 0);
        return Result;
    }

    Result = DhcpDsGetDhcpC
    (
        /* Flags                */ 0,             // no flags
        /* hStoreCC             */ &hStoreCC,
        /* hDhcpC               */ &hDhcpC
    );

    if( ERROR_SUCCESS != Result ) {
        StoreCleanupHandle(&hStoreCC, 0);
        StoreCleanupHandle(&hDhcpRoot, 0);
        return Result;
    }

    do {
	// if addresses are not specified, get it from the ipaddr table
	
	if( NULL != Addresses && 0 != nAddresses ) {
	    Addr = Addresses;
	    TableAddr = FALSE;
	}
	else {
	    Error = GetIpAddressList( &Addr, &nAddresses );
	    if ( ERROR_SUCCESS != Error) {
		break;
	    }
	    TableAddr = TRUE;
	} // else

	
	
	//
	// Check to see if any of the ip addresses or hostname are authorized
	// A seperate call to check for hostname is not necessary because, 
	// the hostname is also added to the filter.
	//
	
	*Found = FALSE;
	
	HostName = GetHostName();
	if ( NULL == HostName ) {
	    Error = GetLastError();
	    break;
	}
	
	for ( i = 0; i < nAddresses; i++ ) {
	    
	    // skip loopback IP 127.0.0.1
	    if ( INADDR_LOOPBACK == htonl( Addr [ i ] )) {
		continue;
	    }
	    
	    ConvertAddressToLPWSTR( htonl( Addr[ i ] ), PrintableIp );
	    
	    Result = DhcpDsLookupServer( &hDhcpC, &hDhcpRoot,
					 DDS_RESERVED_DWORD,
					 PrintableIp, HostName );
	    if ( Result ) {
		*Found = TRUE;
		Error = ERROR_SUCCESS;
		break;
	    }
	} // for i
    } while ( FALSE );

    StoreCleanupHandle(&hStoreCC, 0);             // free ds handle
    StoreCleanupHandle(&hDhcpRoot, 0);            // free ds handle
    StoreCleanupHandle(&hDhcpC, 0);               // free ds handle
    
    if( TableAddr && NULL != Addr ) {
	MemFree( Addr );
    }

    return Error;
} // DhcpDsValidateService()

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\test\engine.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: generic testing engine
//================================================================================

//===============================
//  headers
//===============================
#include    <hdrmacro.h>
#include    <store.h>
#include    <dhcpmsg.h>
#include    <wchar.h>
#include    <dhcpbas.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <dhcpread.h>
#include    <dhcpapi.h>
#include    <rpcapi1.h>
#include    <rpcapi2.h>

//BeginExport(typedefs)
// supported data types are listed. any new datatypes should be added here.
typedef     enum /* anonymous */ {
    Char,
    wChar,
    Word,
    DWord,
    String,
    wString,
    IpAddress,
    xBytes,
    Invalid
}   NJIN_TYPES, *LPNJIN_TYPES;

typedef    struct /* anonymous */ {
    union         /* anonymous */ {
        CHAR                      *Char;
        WCHAR                     *wChar;
        WORD                      *Word;
        DWORD                     *DWord;
        LPSTR                      String;
        LPWSTR                     wString;
        DWORD                     *IpAddress;
        struct    /* anonymous */ {
            DWORD                 *xBytesLen;
            LPBYTE                 xBytesBuf;
        };
    };
}   NJIN_DATA, *LPNJIN_DATA;

typedef     struct /* anonymous */ {
    LPWSTR                         VarName;
    NJIN_TYPES                     VarType;
    NJIN_DATA                      VarData;
    VOID                           (*VarFunc)(LPWSTR VarName);
    BOOL                           ReadOnly;
}   NJIN_VAR, *LPNJIN_VAR;

typedef     struct /* anonymous */ {
    WCHAR                          cComment;
    WCHAR                          cEquals;
    WCHAR                          cReturn;
    WCHAR                          cEndOfLine;
    WCHAR                          cCharFmtActual;
    WCHAR                          cCharFmtNum;
    BOOL                           fEcho;
    BOOL                           fVerbose;
}   NJIN_ENV, *LPNJIN_ENV;
//EndExport(typedefs)

#define     verbose                if( Env->fVerbose) printf
#define     echo                   if( Env->fEcho) printf

DWORD
ConvertToIntegral(
    IN      LPWSTR                 Str
)
{
    return _wtol(Str);
}

DWORD
ConvertToAddress(
    IN      LPWSTR                 Str
)
{
    CHAR                           Buf[1000];
    LPSTR                          s;

    s = Buf;
    while(*s ++ = (CHAR) *Str++ )
        /* skip */;

    return inet_addr(Buf);
}

DWORD
CloneWString(
    IN      LPWSTR                 Buf,
    IN      LPWSTR                 Dest
)
{
    wcscpy(Dest, Buf);
    return ERROR_SUCCESS;
}

DWORD
CloneString(
    IN      LPWSTR                 Str,
    IN      LPSTR                  s
)
{
    while(*s ++ = (CHAR) *Str ++ )
        /* skip */;

    return ERROR_SUCCESS;
}

BYTE
Hex(
    IN      WCHAR                  C
)
{
    if( C >= L'0' && C <= L'9' ) return C - L'0';
    if( C >= L'A' && C <= L'F' ) return C - L'A' + 10;
    if( C >= L'a' && C <= L'f' ) return C - L'a' + 10;
    return 0x55;
}

DWORD
ConvertToHexBytes(
    IN      LPWSTR                 Str,
    IN OUT  LPBYTE                 Buf,
    IN OUT  LPDWORD                BufLen
)
{
    BYTE                           ch, ch2;

    *BufLen = 0;
    while( (ch = Hex(*Str++)) <= 0xF) {
        ch2 = Hex(*Str++);
        if( ch2 > 0xF ) {
            printf("illegal character found, ignored\n");
            ch2 = 0;
        }
        Buf[(*BufLen)++] = (ch <<4) | ch2;
    }

    return ERROR_SUCCESS;
}

DWORD
ConvertDataType(
    IN      LPNJIN_ENV             Env,
    IN      LPWSTR                 Buf,
    IN      DWORD                  VarType,
    IN      NJIN_DATA             *VarData
)
{
    switch(VarType) {
    case Char:
        if( Env->cCharFmtActual == Buf[0] ) {
            *VarData->Char = (CHAR) Buf[1];
        } else if( Env->cCharFmtNum == Buf[0] ) {
            *VarData->Char = (CHAR) ConvertToIntegral(&Buf[1]);
        } else return ERROR_INVALID_DATA;
        return ERROR_SUCCESS;
    case wChar:
        if( Env->cCharFmtActual == Buf[0] ) {
            *VarData->wChar = Buf[1];
        } else if( Env->cCharFmtNum == Buf[0] ) {
            *VarData->wChar = (WCHAR) ConvertToIntegral(&Buf[1]);
        } else return ERROR_INVALID_DATA;
        return ERROR_SUCCESS;
    case Word:
        *VarData->Word = (WORD) ConvertToIntegral(Buf);
        return ERROR_SUCCESS;
    case DWord:
        *VarData->DWord = ConvertToIntegral(Buf);
        return ERROR_SUCCESS;
    case wString:
        return CloneWString(Buf, VarData->wString);
    case String:
        return CloneString(Buf, VarData->String);
    case IpAddress:
        *VarData->IpAddress = ConvertToAddress(Buf);
        return ERROR_SUCCESS;
    case xBytes:
        return ConvertToHexBytes(Buf, VarData->xBytesBuf, VarData->xBytesLen);
    default:
        verbose("unknown variable type\n");
        return ERROR_INVALID_DATA;
    }
}

//BeginExport(function)
DWORD
NjinExecuteLineA(
    IN      LPNJIN_ENV             Env,
    IN OUT  LPNJIN_VAR             Vars,
    IN      DWORD                  nVars,
    IN      LPWSTR                 Cmd
) //EndExport(function)
{
    CHAR                           Ch, LastCh;
    DWORD                          i, Result;
    LPWSTR                         Var;
    LPWSTR                         Value;

    Var = NULL; Value = NULL;
    for( i = 0; Cmd[i] != L'\0' ; i ++ ) {
        if( Env->cEquals == Cmd[i] ) break;
    }

    if( Cmd[i] ) {
        Cmd[i] = L'\0';
        Var = Cmd;
        Value = &Cmd[i+1];
    } else {
        verbose("No parameter passed\n");
        return ERROR_INVALID_DATA;
    }

    for( i = 0; i < nVars; i ++ ) {
        if( !Vars[i].ReadOnly && 0 == wcscmp(Vars[i].VarName, Var) )
            break;
    }

    if( i >= nVars ) {
        verbose("No such variable or operation\n");
        return ERROR_FILE_NOT_FOUND;
    }

    Result = ConvertDataType(Env, Value, Vars[i].VarType, &Vars[i].VarData);
    if( ERROR_SUCCESS != Result ) {
        verbose("ConvertDataType: 0x%lx (%ld)\n", Result, Result );
        return Result;
    }

    if( Vars[i].VarFunc ) Vars[i].VarFunc(Vars[i].VarName );
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
NjinExecute(
    IN      LPNJIN_ENV             Env,
    IN OUT  LPNJIN_VAR             Vars,
    IN      DWORD                  nVars
) //EndExport(function)
{
    char                           ch, lastch;
    WCHAR                          buffer[1000];
    unsigned int                   i;
    DWORD                          Result;

    verbose("NjinExecute called\n");

    i = 0; lastch = (CHAR)Env->cEndOfLine;
    while ((ch = getchar()) != EOF ) {
        if( Env->cReturn == ch ) ch = (CHAR)Env->cEndOfLine;
        if( Env->cEndOfLine == lastch && Env->cComment == ch ) {
            while((ch = getchar()) != EOF && Env->cEndOfLine != ch )
                ;
            lastch = ch;
            continue;
        }

        if( Env->cEndOfLine == ch ) {
            if( i ) {
                buffer[i] = L'\0';
                Result = NjinExecuteLineA(Env,Vars,nVars, buffer);
                if( ERROR_SUCCESS != Result ) {
                    verbose("Error: %ld (0x%lx)\n", Result, Result);
                return Result;
                }
            }
            i = 0;
        } else {
            buffer[i++] = (WCHAR)ch;
        }
        lastch = ch;
    }

    return ERROR_SUCCESS;
}

//================================================================================
//  DHCP SNAPIN DS WORK -- helper routines
//================================================================================

STORE_HANDLE                       hStore1, hStore2, hStore3, hStore4;
LPSTORE_HANDLE                     hRoot = NULL, hDhcpC = NULL, hObject = NULL, hDhcpRoot = NULL;
WCHAR                              gDsServer[100], gObject[100], gName[100], gComment[100];
WCHAR                              gClassName[100], gClassComment[100];
WCHAR                              Dummy[100];
WCHAR                              gOptName[100], gOptComment[100];
WCHAR                              gServerName[256];

DWORD                              gServerAddress, gServerState;
DWORD                              gOptId, gOptType, gOptLen, gIsVendor;
DWORD                              gDwordOptData;
BYTE                               gOptVal[255], gClassData[255];
DWORD                              gClassDataLen;

VOID
print_DHCP_OPTION_DATA(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_DATA     OptData
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld, Type=%ld [0x%lx]\n",
           OptData->NumElements, OptData->Elements[0].OptionType, OptData->Elements[0].Element.DWordOption
    );
}

VOID
print_DHCP_OPTION(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION          Option
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("Option [x%03x] %ws %ws Type= %ld\n",
           Option->OptionID, Option->OptionName, Option->OptionComment?Option->OptionComment:L"", Option->OptionType
    );

    print_DHCP_OPTION_DATA(nTabs+1, &Option->DefaultValue);
}

VOID
print_DHCP_OPTION_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');
    printf("NumElements= %ld\n", OptArray->NumElements);

    for( i = 0; i < OptArray->NumElements; i++ )
        print_DHCP_OPTION(nTabs+1, &OptArray->Options[i]);
}

VOID
print_DHCP_OPTION_VALUE(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_VALUE    OptVal
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("OptionId=%ld\n", OptVal->OptionID);
    print_DHCP_OPTION_DATA(nTabs+1, &OptVal->Value);
}

VOID
print_DHCP_OPTION_VALUE_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_OPTION_VALUE_ARRAY  OptValues
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", OptValues->NumElements);
    for( i = 0; i < OptValues->NumElements ; i ++ )
        print_DHCP_OPTION_VALUE(nTabs+1, &OptValues->Values[i]);
}

VOID
print_DHCP_CLASS_INFO(
    IN      DWORD                  nTabs,
    IN      LPDHCP_CLASS_INFO      ClassInfo
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("ClassName= %ws ClassComment= %ws DataLength = %ld\n",
           ClassInfo->ClassName, ClassInfo->ClassComment, ClassInfo->ClassDataLength
    );
}

VOID
print_DHCP_CLASS_INFO_ARRAY(
    IN      DWORD                  nTabs,
    IN      LPDHCP_CLASS_INFO_ARRAY ClassInfoArray
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", ClassInfoArray->NumElements);
    for( i = 0; i < ClassInfoArray->NumElements ; i ++ )
        print_DHCP_CLASS_INFO(nTabs+1, &ClassInfoArray->Classes[i]);
}

VOID
print_DHCPDS_SERVER(
    IN      DWORD                  nTabs,
    IN      LPDHCPDS_SERVER        Server
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("Name=[%ws] State=%ld Address=%s Loc=[%ws] Type=%ld\n",
           Server->ServerName, Server->Flags, inet_ntoa(*(struct in_addr *)&Server->IpAddress),
           Server->DsLocation? Server->DsLocation: L"(NULL)",
           Server->DsLocType
    );
}

VOID
print_DHCPDS_SERVERS(
    IN      DWORD                  nTabs,
    IN      LPDHCPDS_SERVERS       Servers
)
{
    DWORD                          i;

    i = nTabs;
    while(i--) putchar('\t');

    printf("NumElements=%ld\n", Servers->NumElements);
    for( i = 0; i < Servers->NumElements ; i ++ )
        print_DHCPDS_SERVER(nTabs+1, &Servers->Servers[i]);
}

VOID
SetDsServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Err;

    if( NULL != hRoot ) {
        StoreCleanupHandle(hRoot, 0, TRUE);
    }

    hRoot = &hStore1;
    Err = StoreInitHandle(
        hRoot,
        0,
        wcslen(gDsServer)?gDsServer:NULL,
        NULL,
        NULL,
        NULL,
        0
    );
    if( ERROR_SUCCESS != Err ) {
        printf("StoreInitHandle():%ld 0x%lx\n", Err, Err);
        hRoot = NULL;
        return ;
    }

    if( hDhcpC ) StoreCleanupHandle(hDhcpC, 0, TRUE);
    hDhcpC = &hStore2;

    Err = StoreGetHandle(
        hRoot,
        0,
        StoreGetChildType,
        DHCP_ROOT_OBJECT_PARENT_LOC,
        hDhcpC
    );
    if( ERROR_SUCCESS != Err ) {
        printf("StoreInitHandle():%ld 0x%lx\n", Err, Err);
        hRoot = NULL;
        return ;
    }

    if( hDhcpRoot ) StoreCleanupHandle(hDhcpRoot, 0, TRUE);
    hDhcpRoot = &hStore4;
    Err = DhcpDsGetRoot(
        DDS_FLAGS_CREATE,
        hRoot,
        hDhcpRoot
    );

    if( ERROR_SUCCESS != Err) {
        printf("DhcpDsGetRoot(): %ld 0x%lx", Err, Err);
        hDhcpRoot = NULL;
    }
}

VOID
SetObject(
    IN      LPWSTR                 VarNameUnused
)
{
}

VOID
CreateOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsCreateOptionDef(
        hDhcpC,
        hObject,
        0,
        gOptName,
        wcslen(gOptComment)?gOptComment:NULL,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        gOptType,
        gOptVal,
        gOptLen
    );

    printf("DhcpDsCreateOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
ModifyOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsModifyOptionDef(
        hDhcpC,
        hObject,
        0,
        gOptName,
        wcslen(gOptComment)?gOptComment:NULL,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        gOptType,
        gOptVal,
        gOptLen
    );

    printf("DhcpDsModifyOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
DeleteOptDef(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDeleteOptionDef(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gOptId
    );

    printf("DhcpDsDeleteOptionDef: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumOptDefs(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_ARRAY            OptArray = NULL;

    Result = DhcpDsEnumOptionDefs(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gIsVendor,
        &OptArray
    );

    printf("DhcpDsEnumOptionDefs: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_ARRAY(0, OptArray);
    if( NULL != OptArray ) LocalFree(OptArray);
}

VOID
SetOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    DHCP_OPTION_DATA               OptData;
    DHCP_OPTION_DATA_ELEMENT       OptDataElement;

    OptData.NumElements = 1;
    OptData.Elements = &OptDataElement;
    OptDataElement.OptionType = DhcpDWordOption;
    OptDataElement.Element.DWordOption = gDwordOptData;

    Result = DhcpDsSetOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)?gClassName: NULL,
        gOptId,
        &OptData
    );

    printf("DhcpDsSetOptionValue: %ld (0x%lx)\n", Result, Result);
}

VOID
RemoveOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsRemoveOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gOptId
    );

    printf("DhcpDsRemoveOptionValue: %ld (0x%lx)\n", Result, Result);
}

VOID
GetOptValue(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_VALUE            OptVal = NULL;

    Result = DhcpDsGetOptionValue(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gOptId,
        &OptVal
    );

    printf("DhcpDsGetOptionValue: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_VALUE(0, OptVal);
    if( OptVal ) LocalFree(OptVal);
}

VOID
EnumOptValues(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_OPTION_VALUE_ARRAY      OptValues = NULL;

    Result = DhcpDsEnumOptionValues(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        gIsVendor,
        &OptValues
    );

    printf("DhcpDsEnumOptionValue: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_OPTION_VALUE_ARRAY(0, OptValues);
    if( OptValues ) LocalFree(OptValues);
}

VOID
CreateClass(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsCreateClass(
        hDhcpC,
        hObject,
        0,
        wcslen(gClassName)? gClassName : NULL,
        wcslen(gClassComment)? gClassComment : NULL,
        gClassData,
        gClassDataLen
    );
    printf("DhcpDsCreateClass: %ld (0x%lx)\n", Result, Result);
}

VOID
DeleteClass(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDeleteClass(
        hDhcpC,
        hObject,
        0,
        gClassName
    );
    printf("DhcpDsDeleteClass: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumClasses(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCP_CLASS_INFO_ARRAY        Classes = NULL;

    Result = DhcpDsEnumClasses(
        hDhcpC,
        hObject,
        0,
        &Classes
    );

    printf("DhcpDsEnumClasses: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCP_CLASS_INFO_ARRAY(0, Classes);
    if( Classes ) LocalFree(Classes);
}

VOID
AddServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsAddServer(
        hDhcpC,
        hDhcpRoot,
        0,
        gServerName,
        NULL,
        gServerAddress,
        gServerState
    );

    printf("DhcpDsAddServer: %ld (0x%lx)\n", Result, Result);
}

VOID
DelServer(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;

    Result = DhcpDsDelServer(
        hDhcpC,
        hDhcpRoot,
        0,
        gServerName,
        NULL,
        gServerAddress
    );

    printf("DhcpDsDelServer: %ld (0x%lx)\n", Result, Result);
}

VOID
EnumServers(
    IN      LPWSTR                 VarNameUnused
)
{
    DWORD                          Result;
    LPDHCPDS_SERVERS               Servers;

    Servers = NULL;
    Result = DhcpDsEnumServers(
        hDhcpC,
        hDhcpRoot,
        0,
        &Servers
    );

    printf("DhcpDsEnumServer: %ld (0x%lx)\n", Result, Result);
    if( ERROR_SUCCESS == Result ) print_DHCPDS_SERVERS( 0, Servers);
    if( Servers ) MemFree(Servers);
}


NJIN_VAR VarTable[] = {
    L"DsServer",   wString, { (LPVOID) &gDsServer }, SetDsServer, FALSE,   //0
    L"Object",     wString, { (LPVOID) &gObject }, SetObject,  FALSE,      //1
    L"OptName",    wString, { (LPVOID) &gOptName }, NULL, FALSE,           //2
    L"OptComment", wString, { (LPVOID) &gOptComment }, NULL, FALSE,        //3
    L"ClassName",  wString, { (LPVOID) &gClassName }, NULL, FALSE,         //4
    L"ClassComment",wString,{ (LPVOID) &gClassComment }, NULL, FALSE,      //5
    L"OptId",      DWord, { (LPVOID) &gOptId }, NULL, FALSE,               //6
    L"OptType",    DWord, { (LPVOID) &gOptType }, NULL, FALSE,             //7
    L"OptData",    xBytes, { (LPVOID) NULL }, NULL, FALSE, //############ -> Need to fill pointer..
    L"IsVendor",   DWord, { (LPVOID) &gIsVendor }, NULL, FALSE,            //9
    L"DwordOptData", DWord, { (LPVOID) &gDwordOptData }, NULL, FALSE,      //10
    L"ClassData",  xBytes, { (LPVOID) NULL }, NULL, FALSE, //############ -> need to fill pointer
    L"ServerName", wString, { (LPVOID) &gServerName }, NULL, FALSE,
    L"ServerAddress", IpAddress, { (LPVOID) &gServerAddress }, NULL, FALSE,
    L"ServerState", DWord, { (LPVOID) &gServerState }, NULL, FALSE,

    L"CreateOptionDef", wString, { (LPVOID) &Dummy }, CreateOptDef, FALSE, //12
    L"ModifyOptionDef", wString, { (LPVOID) &Dummy }, ModifyOptDef, FALSE,
    L"EnumOptionDefs",  wString, { (LPVOID) &Dummy }, EnumOptDefs, FALSE,
    L"SetOptionValue",  wString, { (LPVOID) &Dummy }, SetOptValue, FALSE,
    L"RemoveOptionValue", wString, { (LPVOID) &Dummy }, RemoveOptValue, FALSE,
    L"GetOptionValue",    wString, { (LPVOID) &Dummy }, GetOptValue, FALSE,
    L"EnumOptionValues",  wString, { (LPVOID) &Dummy }, EnumOptValues, FALSE,
    L"CreateClass",       wString, { (LPVOID) &Dummy }, CreateClass, FALSE,
    L"DeleteClass",       wString, { (LPVOID) &Dummy }, DeleteClass, FALSE,
    L"EnumClasses",       wString, { (LPVOID) &Dummy }, EnumClasses, FALSE,
    L"AddServer",         wString, { (LPVOID) &Dummy }, AddServer, FALSE,
    L"DelServer",         wString, { (LPVOID) &Dummy }, DelServer, FALSE,
    L"EnumServers",       wString, { (LPVOID) &Dummy }, EnumServers, FALSE,
};

NJIN_ENV Env[] = {
    L'#',
    L'=',
    L'\r',
    L'\n',
    L' ',
    L'#',
    TRUE,
    TRUE
};

#define  VarTableSz                (sizeof(VarTable)/sizeof(VarTable[0]))

void _cdecl main (void) {
    DWORD                          Result;
    DWORD                          i;

    VarTable[8].VarData.xBytesLen = &gOptLen;
    VarTable[8].VarData.xBytesBuf = gOptVal;
    VarTable[11].VarData.xBytesLen = &gClassDataLen;
    VarTable[11].VarData.xBytesBuf = gClassData;

    Result = NjinExecute(
        Env,
        VarTable,
        VarTableSz
    );

    if( ERROR_SUCCESS != Result ) {
        printf("\nResult = %ld\n", Result);
    }
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\test\adsitst.c ===
//================================================================================
//  Copyright (C) 2000 Microsoft Corporation
//  Author : ThiruB
//  Description: ADSI test app
//================================================================================

#define INC_OLE2
#include <activeds.h>
#include <stdio.h>
#include <stdlib.h>
#include <align.h>
#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <adsi.h>

LPWSTR
ConvertToLPWSTR(
		IN     /* LPSTR  */ char *                 s
)
{
    LPWSTR                         u, v;

    if( NULL == s ) return L"";

    u = LocalAlloc(LMEM_FIXED, (strlen(s)+1)*sizeof(WCHAR));
    if( NULL == u ) return L"";

    v = u;
    while( *v++ = *s++)
        ;

    return u;
} // ConvertToLPWSTR()

void PrintRow( HANDLE            lh, 
	       ADS_SEARCH_HANDLE sh,
	       LPWSTR            attribs[], 
	       DWORD             count
	       )
{
    DWORD i, j;
    HRESULT hr;
    ADS_SEARCH_COLUMN col;

    for ( i = 0; i < count; i++ ) {
	hr = ADSIGetColumn( lh, sh, attribs[ i ], &col );

	if ( FAILED( hr)) {
	    printf( "Failed for attribute : %ws, ErrorCode: %ld\n",
		    attribs[ i ],
		    GetLastError());
	    continue;
	}
	printf( "AttrName : %ws\n", col.pszAttrName );
	for ( j = 0; j < col.dwNumValues; j++ ) {
	    printf( "\tAttr Value : %ws\n", col.pADsValues[j].DNString );
	}
    } // for
} // PrintRow()

void DumpObject( LPWSTR url, LPWSTR searchFilter )
{

    HANDLE ldapHandle;
    ADS_SEARCH_HANDLE sh;
    HRESULT hr;

    ADS_SEARCHPREF_INFO SearchPref[3];

    LPWSTR attribs[] = { L"name", L"dhcpServers" };
//      LPWSTR attribs[] = { L"dhcpServers" };
//      LPWSTR searchFilter = L"(objectClass=dHCPClass)";
//      LPWSTR searchFilter = L"(dhcpServers~=127)";
    
    hr = ADSIOpenDSObject( url, NULL, NULL, ADS_SECURE_AUTHENTICATION, &ldapHandle );

    if ( SUCCEEDED( hr )) {
	printf( "Successfully opened %ws\n", url );
    } 
    else {
	printf( "Failed to open : %ws\n", url );
	return;
    }

    SearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer = ADS_SCOPE_SUBTREE;

//      SearchPref.dwStatus = ERROR_SUCCESS;

    SearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer = 250;

    // Make it cache the results at the client side. This is
    // default, but try it anyway.
    SearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    SearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
    SearchPref[2].vValue.Boolean = TRUE;

    hr = ADSISetSearchPreference(
        /* hDSObject           */  ldapHandle,
        /* pSearchPrefs        */  SearchPref,
        /* dwNumPrefs          */  3
    );
    if ( FAILED( hr )) {
	printf( "SetSearchPrefs failed\n");
	return;
    }

    // Begin Search
    hr = ADSIExecuteSearch( ldapHandle,
			    searchFilter,
			    attribs,
			    sizeof(attribs) / sizeof(*attribs),
			    &sh);
    if ( FAILED( hr)) {
	printf( "Search failed for %ws\n", searchFilter );
	return;
    }


    // Search
    
    hr = ADSIGetFirstRow ( ldapHandle, sh );
    if ( !FAILED( hr ) ) {
	PrintRow( ldapHandle, sh,
		  attribs, sizeof(attribs) / sizeof(*attribs) );
    }
    else {
	printf( "GetFirstRow failed \n");
	return;
    }

    while ( 1 ) {
	hr =  ADSIGetNextRow( ldapHandle, sh );
	if ((SUCCEEDED( hr )) &&
	    (hr != S_ADS_NOMORE_ROWS)) {
	    PrintRow ( ldapHandle, sh,
		       attribs, sizeof(attribs) / sizeof(*attribs) );
	}
	else {
            break;
	}
    } // while 
    
    // End Search
    hr = ADSICloseSearchHandle( ldapHandle, sh );
    ADSICloseDSObject( ldapHandle );


} // DumpObject


void _cdecl main( int argc, char *argv[] ) {
    LPWSTR url;
    LPWSTR filter;

    if ( argc > 2 ) {
	url = ConvertToLPWSTR( argv[ 1 ] );
	filter = ConvertToLPWSTR( argv[ 2 ] );
	DumpObject( url, filter );
    } 
} // main()

void _cdecl _bad_main(int argc, char *argv[]) {

   HANDLE  ldapHandle;
   HRESULT hr;
   DWORD   dwLastError;
   WCHAR   szErrorBuf[MAX_PATH];
   WCHAR   szNameBuf[MAX_PATH];
   HRESULT hr_return = S_OK;

   hr = ADSIOpenDSObject( 
			 L"LDAP://192.168.73.1/ROOTDSE",
			 NULL,
			 NULL,
			 0,
			 &ldapHandle );

    if ( SUCCEEDED( hr ) )
    {
        printf( "Successfully opened the ROOTDSE object! \n" );
        ADSICloseDSObject( ldapHandle );
    }
    else
    {
        printf( "Falied to open ROOTDSE ..\n" );
    }

   hr = ADSIOpenDSObject(
//  			 L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,DC=rterala-test1,DC=officenet",
			 L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,CN=rterala-test1.rterala.officenet",
			 NULL,
			 NULL,
			 ADS_SECURE_AUTHENTICATION,
			 &ldapHandle );

   if ( SUCCEEDED( hr ) )
    {
        printf( "Successfully opened the DhcpRoot object in RCOST.COM! \n" );
        ADSICloseDSObject( ldapHandle );
    }
    else
    {
        if ( FAILED( hr ) )
        {
            printf( "Failed to open the DHCP ROOT object Errcode is 0x%Xh \n", hr  );

            if (HRESULT_FACILITY(hr)==FACILITY_WIN32)
            {
                hr_return = ADsGetLastError( &dwLastError,
                                             szErrorBuf,
                                             MAX_PATH-1,
                                             szNameBuf,
                                             MAX_PATH-1);
                if (SUCCEEDED(hr_return))
                {
                    wprintf(L"Error Code: %d\n Error Text: %ws\n Provider: %ws\n", dwLastError, szErrorBuf, szNameBuf);
                }
            }

        }
    }

    hr = ADSIOpenDSObject( L"LDAP://192.168.73.1/CN=DhcpRoot,CN=NetServices,CN=Services,CN=Configuration,DC=rterala-test1,DC=officenet",
//                             L"Administrator",
//                             L"b4,checkin",
			   NULL, NULL,
                           ADS_SECURE_AUTHENTICATION,
                           &ldapHandle );

   if ( SUCCEEDED( hr ) ) 
   {
        printf( "Successfully opened the DhcpRoot object in RCOST.COM! \n" );
        ADSICloseDSObject( &ldapHandle );
   }
   else
   {
        if ( FAILED( hr ) )
        {
           printf( "Failed to open the DHCP ROOT object Errcode is 0x%Xh \n", hr );
        }

        if ( HRESULT_FACILITY(hr) == FACILITY_WIN32 )
        {
            hr_return = ADsGetLastError( &dwLastError,
                                         szErrorBuf,
                                         MAX_PATH-1,
                                         szNameBuf,
                                         MAX_PATH-1 );

            if ( SUCCEEDED( hr_return ) )
            {
                wprintf(L"Error code: %d \n Error Text: %ws\n Provider: %ws \n", dwLastError, szErrorBuf, szNameBuf );
            
            }
             
        }       
   }

   exit(0);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximdlg.cpp ===
// DhcpEximDlg.cpp : implementation file
//

#include "stdafx.h"
#include "DhcpEximx.h"
#include "DhcpEximDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg dialog

CDhcpEximDlg::CDhcpEximDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDhcpEximDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpEximDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDhcpEximDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpEximDlg)
    DDX_Control(pDX, IDC_RADIO_EXPORT, m_ExportButton);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDhcpEximDlg, CDialog)
	//{{AFX_MSG_MAP(CDhcpEximDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg message handlers

BOOL CDhcpEximDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
    
	// TODO: Add extra initialization here
	m_ExportButton.SetCheck(1);     // Set default as export
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDhcpEximDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDhcpEximDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


void CDhcpEximDlg::OnOK() 
{
	// TODO: Add extra validation here

	// Check whether export or import was chosen by user
	m_fExport = ( m_ExportButton.GetCheck() == 1 ) ;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximdlg.h ===
// DhcpEximDlg.h : header file
//

#if !defined(AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_)
#define AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximDlg dialog

class CDhcpEximDlg : public CDialog
{
// Construction
public:
	CDhcpEximDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpEximDlg)
	enum { IDD = IDD_DHCPEXIM_DIALOG };
	CButton	m_ExportButton;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpEximDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CDhcpEximDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    BOOL m_fExport;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIMDLG_H__2EE7F593_59A2_4FD6_ADA0_1356016342BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximlistdlg.cpp ===
// DhcpEximListDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dhcpeximx.h"
extern "C" {
#include <dhcpexim.h>
}
#include "DhcpEximListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg dialog

DhcpEximListDlg::DhcpEximListDlg(CWnd* pParent /*=NULL*/, PDHCPEXIM_CONTEXT Ctxtx , DWORD IDD)
    : CDialog(IDD, pParent)
{
    
	//{{AFX_DATA_INIT(DhcpEximListDlg)
	m_Message = _T("");
	//}}AFX_DATA_INIT
	m_PathName = Ctxtx->FileName;
	m_fExport = Ctxtx->fExport;
    Ctxt = Ctxtx;
    
	CString Str1(_T("&Select the scopes that will be exported to ") );
	CString Str2(_T("&Select the scopes that will be imported from ") );
	CString PathNameStr(m_PathName);
	CString Dot(_T("."));

	// TODO: Add extra initialization here
	if( m_fExport ) 
	{
		m_Message = Str1 + PathNameStr + Dot;
	}
	else
	{
		m_Message = Str2 + PathNameStr + Dot;
	}

}


void DhcpEximListDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DhcpEximListDlg)
	DDX_Control(pDX, IDC_LIST1, m_List);
	DDX_Text(pDX, IDC_STATIC_ACTION, m_Message);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DhcpEximListDlg, CDialog)
	//{{AFX_MSG_MAP(DhcpEximListDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg message handlers

BOOL DhcpEximListDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	for ( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        m_List.InsertItem(i, Ctxt->Scopes[i].SubnetName );
    }
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}




void DhcpEximListDlg::OnOk() 
{
	for( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        if( m_List.GetItemState( i, LVIS_SELECTED) == LVIS_SELECTED)
        {
            Ctxt->Scopes[i].fSelected = TRUE;
        }
        else
        {
            Ctxt->Scopes[i].fSelected = FALSE;
        }
    }

    if( m_fExport ) {
        Ctxt->fDisableExportedScopes = (0 != IsDlgButtonChecked(IDC_CHECK1));
    }

    CDialog::OnOK();
}

void DhcpEximListDlg::OnCancel() 
{
	// TODO: Add your control notification handler code here
	for( DWORD i = 0; i < Ctxt->nScopes; i ++ )
    {
        Ctxt->Scopes[i].fSelected = FALSE;
    }

    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpds\validate.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

//DOC This function is declared in dhcpds.c..
//DOC DhcpDsValidateService checks the given service in the DS to see if it exists
//DOC If the machine is a standalone, it sets IsStandAlone and returns ERROR_SUCCESS
//DOC If the entry for the given Address is found, it sets Found to TRUE and returns
//DOC ERROR_SUCCESS. If the DhcpRoot node is found, but entry is not Found, it sets
//DOC Found to FALSE and returns ERROR_SUCCESS; If the DS could not be reached, it
//DOC returns ERROR_FILE_NOT_FOUND
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses, OPTIONAL
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximx.h ===
// DhcpExim.h : main header file for the DHCPEXIM application
//

#if !defined(AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_)
#define AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp:
// See DhcpExim.cpp for the implementation of this class
//

class CDhcpEximApp : public CWinApp
{
public:
	CDhcpEximApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpEximApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDhcpEximApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIM_H__AE7A8DB3_03A5_426B_8B03_105934DB8466__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximlistdlg.h ===
#if !defined(AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_)
#define AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DhcpEximListDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DhcpEximListDlg dialog

class DhcpEximListDlg : public CDialog
{
// Construction
public:
	DhcpEximListDlg(CWnd* pParent = NULL,
                    PDHCPEXIM_CONTEXT Ctxt = NULL,
                    DWORD IDD=IDD_EXIM_LISTVIEW_DIALOG);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DhcpEximListDlg)
	CListCtrl m_List;
	CString	m_Message;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DhcpEximListDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DhcpEximListDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnOk();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	//
	// local variables
	//

	BOOL m_fExport;
	LPTSTR m_PathName;
    PDHCPEXIM_CONTEXT Ctxt;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPEXIMLISTDLG_H__43CC976B_6C5A_4933_B8C8_44FEAE403B00__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DhcpExim.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\dhcpeximx.cpp ===
// DhcpExim.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DhcpEximx.h"
#include "DhcpEximDlg.h"
#include "CommDlg.h"
extern "C" {
#include <dhcpexim.h>
}
#include "DhcpEximListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp

BEGIN_MESSAGE_MAP(CDhcpEximApp, CWinApp)
	//{{AFX_MSG_MAP(CDhcpEximApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp construction

CDhcpEximApp::CDhcpEximApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDhcpEximApp object

CDhcpEximApp theApp;

CString
ConvertErrorToString(
    IN DWORD Error
    )
{
    CString RetVal;
    LPTSTR Buffer = NULL;
    
    if( 0 != FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, Error, 0, (LPTSTR)&Buffer, 100, NULL ) ) {
        RetVal = Buffer;
        LocalFree( Buffer );
        return RetVal;
    }

    //
    // Just print out the error as a number:
    //

    RetVal.Format(TEXT("%ld."), Error );
    return RetVal;
}


VOID DoImportExport(BOOL fExport)
{
    BOOL fSuccess, fAbort;
    OPENFILENAME ofn;
    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    DWORD dwWindowsMinorVersion =  (DWORD)(HIBYTE(LOWORD(dwVersion)));
    TCHAR FileNameBuffer[MAX_PATH];
    CString Str;
    
    ZeroMemory( &ofn, sizeof(ofn));
    ZeroMemory( FileNameBuffer, sizeof(FileNameBuffer));
    
    if( (dwWindowsMajorVersion >= 5) )
    {
        //use the NT dialog file box
        ofn.lStructSize=sizeof(ofn);
    }
    else
    {
        //use the NT 4 dialog boxes
        ofn.lStructSize=76;
    }

    //determine the parent and instance of the file dialog
    //ofn.hwndOwner=m_hWnd;
    //ofn.hInstance=(HINSTANCE)GetWindowLongPtr(m_hWnd,GWLP_HINSTANCE);

    ofn.lpstrFile=(LPTSTR)FileNameBuffer;
    if( fExport )
    {
        Str.FormatMessage( IDS_EXPORT_TO_FILE );
    }
    else
    {
        Str.FormatMessage( IDS_IMPORT_FROM_FILE );
    }

    ofn.lpstrTitle = Str;
    ofn.lpstrFilter = TEXT("All Files\0*.*\0\0");
    ofn.nMaxFile=MAX_PATH;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_EXPLORER | OFN_HIDEREADONLY ;
    ofn.Flags |= OFN_NOCHANGEDIR;
    
    //
    // for some vague reason, MFC requires me to run this twice!
    //
    

    if( fExport ) {
        fSuccess = GetSaveFileName(&ofn);
        fSuccess = GetSaveFileName(&ofn);
    } else {
        fSuccess = GetOpenFileName(&ofn);
        fSuccess = GetOpenFileName(&ofn);
    }

    //
    // If user cancelled this, silently return
    //
    
	if( !fSuccess ) return;

    DHCPEXIM_CONTEXT Ctxt;

    DWORD Error = DhcpEximInitializeContext(
        &Ctxt, FileNameBuffer, fExport );
    if( NO_ERROR != Error )
    {
        CString Str;

        Str.FormatMessage(
            IDS_ERROR_INITIALIZATION, (LPCTSTR)ConvertErrorToString(Error) );
        AfxMessageBox(Str);
        return;
    }

    //
    // The file to export to is FileNameBuffer.  Open the next window
    //

    DhcpEximListDlg Dlg(
        NULL, &Ctxt,
        fExport ? IDD_EXIM_LISTVIEW_DIALOG :
        IDD_EXIM_LISTVIEW_DIALOG2 );

    //
    // Now perform the operation
    //

    fAbort = (IDOK != Dlg.DoModal() );
    
	Error = DhcpEximCleanupContext( &Ctxt, fAbort  );
    if( NO_ERROR != Error )
    {

        if( ERROR_CAN_NOT_COMPLETE != Error ) {
            Str.FormatMessage(
                IDS_ERROR_CLEANUP, (LPCTSTR)ConvertErrorToString(Error) );
            AfxMessageBox( Str );
        }
    }
    else if( !fAbort )
    {
        Str.FormatMessage( IDS_SUCCEEDED );
        AfxMessageBox( Str );
    }
        
}


/////////////////////////////////////////////////////////////////////////////
// CDhcpEximApp initialization

BOOL CDhcpEximApp::InitInstance()
{
	int nResponse;
	BOOL fExport;

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    CDhcpEximDlg dlg;
    m_pMainWnd = &dlg;
    nResponse = (int)dlg.DoModal();
    fExport = dlg.m_fExport;

	if (nResponse == IDOK)
	{
        DoImportExport(fExport);
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

//
// Need to implement these routines..
// 

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_CLASS_CONFLICT, SvcClass, ConfigClass );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_OPTDEF_CONFLICT, SvcOptdef, ConfigOptdef );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    )
{
    CString Str;
    DWORD MsgId;
    
    if( NULL == SubnetName ) {
        MsgId = IDS_ERROR_OPTION_CONFLICT;
    } else if( NULL == ResAddress ) {
        MsgId = IDS_ERROR_SUBNET_OPTION_CONFLICT;
    } else {
        MsgId = IDS_ERROR_RES_OPTION_CONFLICT;
    }

    if( NULL == UserClass ) UserClass = L"";
    if( NULL == VendorClass ) VendorClass = L"";
    
    Str.FormatMessage(
         MsgId, OptId, UserClass, VendorClass, SubnetName, ResAddress );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    )
{
    CString Str;
    
    Str.FormatMessage(
        IDS_ERROR_SUBNET_NOT_FOUND, SubnetAddress );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    )
{
    CString Str;

    if( NULL == SubnetName ) SubnetName = L"";
    Str.FormatMessage(
         IDS_ERROR_SUBNET_CONFLICT, SubnetAddress, SubnetName );
    AfxMessageBox( Str );
}

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    )
{
    CString Str;
    WCHAR ErrStr[30];
    
    wsprintf(ErrStr, L"%ld", Error );

    Str.FormatMessage(
        IDS_ERROR_DBENTRY_FAILED, ClientAddress, ClientHwAddress,
        ErrStr);
    (*fAbort) = ( IDYES == AfxMessageBox( Str, MB_YESNO ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_)
#define AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0BD5FBCA_CF28_490E_BBAF_CDDE921E6E14__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DhcpExim.rc
//
#define IDS_EXPORT_TO_FILE              1
#define IDS_IMPORT_FROM_FILE            2
#define IDS_ERROR_INITIALIZATION        3
#define IDS_ERROR_CLEANUP               4
#define IDS_ERROR_CLASS_CONFLICT        5
#define IDS_ERROR_OPTDEF_CONFLICT       6
#define IDS_ERROR_OPTION_CONFLICT       7
#define IDS_ERROR_SUBNET_OPTION_CONFLICT 8
#define IDS_ERROR_RES_OPTION_CONFLICT   9
#define IDS_ERROR_SUBNET_NOT_FOUND      10
#define IDS_ERROR_SUBNET_CONFLICT       11
#define IDS_ERROR_DBENTRY_FAILED        12
#define IDS_SUCCEEDED                   13

#define IDD_DHCPEXIM_DIALOG             102
#define IDD_EXIM_LISTVIEW_DIALOG        103
#define IDD_EXIM_LISTVIEW_DIALOG2       104
#define IDR_MAINFRAME                   128
#define IDC_RADIO_EXPORT                1000
#define IDC_RADIO_IMPORT                1001
#define IDC_BUTTON_CANCEL               1002
#define IDC_BUTTON_OK                   1003
#define IDC_LIST1                       1004
#define IDC_LIST2                       1005
#define IDC_STATIC_ACTION               1006
#define IDC_CHECK1                      1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\convert.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include <precomp.h>
#include <winnls.h>


#undef DhcpFreeMemory
#undef DhcpAllocateMemory

VOID
DhcpFreeMemory(
    PVOID Mem
    )
{
    LocalFree( Mem );
}

PVOID
DhcpAllocateMemory(
    IN ULONG Size
    )
{
    return LocalAlloc( LPTR, Size );
}

    

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
        }
        return NULL;
    }

    return UnicodeString.Buffer;

}


LPWSTR
DhcpOemToUnicode(
    IN      LPSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}


ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    )
/*++

Routine Description:

    This routine returns the number of bytes requried
    to store the OEM string equivalent of the provided
    UNICODE string.

Arguments:

    Unicode -- the input unicode string.

Return Values:

    0 -- if the string cannot be converted or is NULL
    number of bytes of storage required

--*/
{
    UNICODE_STRING UnicodeString;

    if( NULL == Unicode ) return 0;
    
    RtlInitUnicodeString( &UnicodeString, Unicode );
    return (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );
}

    

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    Unicodestring - Pointer to the unicodestring

    UnicodeLength - Length of above string, or pass -1 if the above string is
                    NULL terminated.

    UTF8String - Buffer to receive UTF8String. If this is null then the function
                    returns the # of bytes needed for this buffer for conversion.

    UTF8Length - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD   Result;
    Result = WideCharToMultiByte(
                CP_UTF8,
                0,
                UnicodeString,
                UnicodeLength,
                UTF8String,
                UTF8Length,
                NULL,
                NULL
                );
    if (Result == 0 ) {
        ASSERT(FALSE);
    }
    return Result;
}

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    UTF8String - Buffer to UTFString.

    UTF8Length - Length of above buffer ; or pass -1 if the above string is NULL terminated.

    Unicodestring - Pointer to the buffer receiving unicodestring.

    UnicodeLength - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD Result;
    Result = MultiByteToWideChar(
                CP_UTF8,
                0,
                UTF8String,
                UTF8Length,
                UnicodeString,
                UnicodeLength
                );
    if (Result == 0 ) {
        ASSERT(FALSE);
    }
    return Result;

}


VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NULL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}


VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}


VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}


DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}


LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}


DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}


#if 0


DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    NetworkOrderAddress - A network order IP address.

Return Value:

    The host order IP address.

--*/
{
    return( ntohl( NetworkOrderAddress ) );
}


DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS HostOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    HostOrderAddress - A host order IP address.

Return Value:

    The network order IP address.

--*/
{
    return( htonl( HostOrderAddress ) );
}


VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD IpAddress
    )
/*++

Routine Description:

    This function converts an IP address from host order ASCII form.

Arguments:

    Buffer - Points to a buffer to the receive the ASCII form.  The
        buffer must be at least 8 WCHARs long.

    IpAddress - The IP address to convert.

Return Value:

    Nothing.

--*/
{
    int i;
    int j;

    for (i = 7; i >= 0; i-- ) {
        j = IpAddress & 0xF;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        IpAddress >>=4;
    }

    return;
}



VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    )
/*++

Routine Description:

    This function converts an ASCII string IP Address to binary format.

Arguments:

    Buffer - Pointer to buffer containing the IP address.

    IpAddress - Points to a buffer to contain the binary format IP address.

    NetOrder - If TRUE, the address is converted to a network order address.
               If FALSE, the address is converted to a host order address.

Return Value:

    None.

--*/
{
    DWORD value;

    value = strtol( Buffer, NULL, 16 );

    if ( NetOrder ) {
        *IpAddress = htonl( value );
    } else {
        *IpAddress = value;
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\merge.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    merge.c

Abstract:

    this module merges the configurations provided via a pair of
    MM datastructures..

--*/

#include <precomp.h>

BOOL
ClassesConflict(
    IN PM_CLASSDEF Class1,
    IN PM_CLASSDEF Class2
    )
{
    LPWSTR Comment1, Comment2;
    
    if( Class1->IsVendor != Class2->IsVendor ) return TRUE;
    if( wcscmp(Class1->Name, Class2->Name) ) return TRUE;
    Comment1 = Class1->Comment; Comment2 = Class2->Comment;
    if( NULL == Comment1 ) Comment1 = L"";
    if( NULL == Comment2 ) Comment2 = L"";
    if( wcscmp(Comment1, Comment2) ) return TRUE;
    if( Class1->nBytes != Class2->nBytes ) return TRUE;
    if( memcmp(Class1->ActualBytes, Class2->ActualBytes,
               Class1->nBytes ) ) {
        return TRUE;
    }

    return FALSE;
}

DWORD
AddClassesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    PM_CLASSDEF ClassDef;
    
    Error = MemServerGetClassDef(
        Server, 0,
        Ctxt->ClassDef->Name,
        Ctxt->ClassDef->nBytes,
        Ctxt->ClassDef->ActualBytes,
        &ClassDef );
    if( NO_ERROR == Error ) {
        //
        // Check if the classdef matches
        //

        if( ClassesConflict( ClassDef, Ctxt->ClassDef ) ) {
            Tr("Class %ws conflicts with class %ws\n",
               ClassDef->Name, Ctxt->ClassDef->Name );
            DhcpEximErrorClassConflicts(
                ClassDef->Name, Ctxt->ClassDef->Name );
            return ERROR_CAN_NOT_COMPLETE;
        }
        return NO_ERROR;
    }
    
    return MemServerAddClassDef(
        Server, MemNewClassId(),
        Ctxt->ClassDef->IsVendor,
        Ctxt->ClassDef->Name,
        Ctxt->ClassDef->Comment,
        Ctxt->ClassDef->nBytes,
        Ctxt->ClassDef->ActualBytes );
}

DWORD
GetClassIdByName(
    IN PM_SERVER Server,
    IN LPWSTR Name
    )
{
    PM_CLASSDEF ClassDef;
    DWORD Error;
    
    Error = MemServerGetClassDef(
        Server, 0, Name, 0, NULL, &ClassDef );
    if( NO_ERROR != Error ) return 0;
    return ClassDef->ClassId;
}

BOOL
OptDefsConflict(
    IN PM_OPTDEF OptDef1,
    IN PM_OPTDEF OptDef2
    )
{
    LPWSTR Comment1, Comment2;

    if( OptDef1->OptId != OptDef2->OptId ) return TRUE;
    if( wcscmp(OptDef1->OptName, OptDef2->OptName ) ) return TRUE;
    Comment1 = OptDef1->OptComment; Comment2 = OptDef2->OptComment;
    if( NULL == Comment1 ) Comment1 = L"";
    if( NULL == Comment2 ) Comment2 = L"";
    if( wcscmp(Comment1, Comment2) ) return TRUE;
    if( OptDef1->OptValLen != OptDef2->OptValLen ) return TRUE;
    if( memcmp(OptDef1->OptVal, OptDef2->OptVal,
               OptDef1->OptValLen)) return TRUE;
    
    return FALSE;
}

DWORD
AddOptdefsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error, ClassId, VendorId;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    PM_OPTDEF OptDef;
    
    //
    // Get the user and vendor class id's
    //
    
    if( Ctxt->UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, Ctxt->UserClass->Name );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", Ctxt->UserClass->Name );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( Ctxt->VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, Ctxt->VendorClass->Name );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", Ctxt->VendorClass->Name );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    //
    // Next check if the specified optdef exists already
    //

    Error = MemServerGetOptDef(
        Server, ClassId, VendorId, Ctxt->OptDef->OptId,
        Ctxt->OptDef->OptName, &OptDef );
    if( NO_ERROR == Error ) {
        if( OptDefsConflict( OptDef, Ctxt->OptDef ) ) {
            Tr("Optdef %ws conflicts with %ws\n",
               OptDef->OptName, Ctxt->OptDef->OptName );

            //
            // attempt to overwrite existing optdef
            //
            //DhcpEximErrorOptdefConflicts(
            //   OptDef->OptName, Ctxt->OptDef->OptName );
            // return ERROR_CAN_NOT_COMPLETE;
            return NO_ERROR;
        }
        return NO_ERROR;
    }

    //
    // Now add the optdef
    //

    return MemServerAddOptDef(
        Server, ClassId, VendorId, Ctxt->OptDef->OptId,
        Ctxt->OptDef->OptName, Ctxt->OptDef->OptComment,
        Ctxt->OptDef->Type, Ctxt->OptDef->OptVal,
        Ctxt->OptDef->OptValLen );
}    

        
DWORD static
SetOptionValue(
    IN PM_SERVER Server,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL,
    IN ULONG OptId,
    IN LPWSTR UserClass,
    IN LPWSTR VendorClass,
    IN LPBYTE Val,
    IN ULONG Len
)
{
    DWORD Error, ClassId, VendorId;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DeletedOption;

    //
    // Get the user and vendor class id's
    //
    
    if( UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, UserClass );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", UserClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, VendorClass );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", VendorClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }
    
    Error = MemOptInit( &Option, OptId, Len, Val );
    if( ERROR_SUCCESS != Error ) return Error;

    DeletedOption = NULL;

    if( NULL != Res ) {
        OptClass = &Res->Options;
    } else if( NULL != Subnet ) {
        OptClass = &Subnet->Options;
    } else {
        OptClass = &Server->Options;
    }
    
    Error = MemOptClassAddOption(
        OptClass, Option, ClassId, VendorId, &DeletedOption );

    if( ERROR_SUCCESS == Error && DeletedOption ) {
        MemFree(DeletedOption);               // if we did replace, free the old option
    }

    if( ERROR_SUCCESS != Error ) {                // something went wrong, clean up
        ULONG LocalError = MemOptCleanup(Option);
        ASSERT(ERROR_SUCCESS == LocalError);
    }

    return Error;
}

DWORD
GetOptionValue(
    IN PM_SERVER Server,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL,
    IN ULONG OptId,
    IN LPWSTR UserClass,
    IN LPWSTR VendorClass,
    OUT LPBYTE *Val,
    OUT ULONG *Len
    )
{
    DWORD Error, ClassId, VendorId;
    PM_OPTCLASS OptClass;
    PM_OPTLIST OptList;
    PM_OPTION Opt;

    //
    // Get the user and vendor class id's
    //
    
    if( UserClass == NULL ) ClassId = 0;
    else {
        ClassId = GetClassIdByName( Server, UserClass );
        if( 0 == ClassId ) {
            Tr("Class %ws doesnt exist\n", UserClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    if( VendorClass == NULL ) VendorId = 0;
    else {
        VendorId = GetClassIdByName( Server, VendorClass );
        if( 0 == VendorId ) {
            Tr("Class %ws doesnt exist\n", VendorClass );
            return ERROR_DHCP_CLASS_NOT_FOUND;
        }
    }

    //
    // get the options
    //
    
    if( NULL != Res ) {
        OptClass = &Res->Options;
    } else if( NULL != Subnet ) {
        OptClass = &Subnet->Options;
    } else {
        OptClass = &Server->Options;
    }

    //
    // Check if option exists
    //
    
    Error = MemOptClassFindClassOptions(
        OptClass, ClassId, VendorId, &OptList );
    if( NO_ERROR == Error ) {

        Error = MemOptListFindOption( OptList, OptId, &Opt );

        if( NO_ERROR == Error ) {

            *Val = Opt->Val;
            *Len = Opt->Len;
            return NO_ERROR;
        }
    }

    return ERROR_DHCP_OPTION_NOT_PRESENT;
}

DWORD
AddOptionsCallbackEx(
    IN OUT PMM_ITERATE_CTXT Ctxt,
    IN PM_SUBNET Subnet OPTIONAL,
    IN PM_RESERVATION Res OPTIONAL
    )
{
    DWORD Error, Len;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    LPBYTE Val;
    WCHAR Buff1[10], Buf2[30];
    LPWSTR ResAddress = NULL, OptId, SubnetName = NULL;
    
    //
    // Check for option conflict
    //

    wsprintf(Buff1, L"%ld", Ctxt->Option->OptId );
    OptId = (LPWSTR)Buff1;
    
    if( Res ) {
        Subnet = (PM_SUBNET) Res->SubnetPtr;
        IpAddressToStringW( Res->Address, Buf2);
        ResAddress = (LPWSTR)Buf2;
    }
    
    if( Subnet ) {
        Server = (PM_SERVER) Subnet->ServerPtr;
        SubnetName = Subnet->Name;
    }
    
    Error = GetOptionValue(
        Server, Subnet, Res, Ctxt->Option->OptId,
        Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
        Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL,
        &Val , &Len );
    if( NO_ERROR == Error ) {
        if( Len != Ctxt->Option->Len ||
            memcmp( Ctxt->Option->Val, Val, Len ) ) {
            
            Tr("Options conflict for opt id %ld\n", Ctxt->Option->OptId );
            DhcpEximErrorOptionConflits(
                SubnetName, ResAddress, OptId,
                Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
                Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL
                );
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    } else if( ERROR_DHCP_OPTION_NOT_PRESENT != Error ) {
        Tr("GetOptionValue: %ld\n", Error );
        return Error;
    }
    
    //
    // Create option
    //

    return SetOptionValue( 
        Server, Subnet, Res, Ctxt->Option->OptId,
        Ctxt->UserClass ? Ctxt->UserClass->Name : NULL,
        Ctxt->VendorClass ? Ctxt->VendorClass->Name : NULL,
        Ctxt->Option->Val, Ctxt->Option->Len );
}

DWORD
AddOptionsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, NULL, NULL );
}

DWORD
AddSubnetOptionsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, (PM_SUBNET)Ctxt->ExtraCtxt, NULL );

}

DWORD
AddReservationOptionsCallback(
    IN PMM_ITERATE_CTXT Ctxt
    )
{
    return AddOptionsCallbackEx(
        Ctxt, NULL, (PM_RESERVATION)Ctxt->ExtraCtxt );
}

DWORD
AddReservationsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    PM_SERVER Server;
    PM_SUBNET Subnet;
    PM_RESERVATION Res;

    //
    // Create the reservations
    //

    Server = ((PM_SUBNET)Ctxt->ExtraCtxt)->ServerPtr;
    Error = MemServerGetAddressInfo(
        Server, Ctxt->Res->Address, &Subnet, NULL, NULL, NULL );
    ASSERT( NO_ERROR == Error );
    
    Error = MemReserveAdd(
        &Subnet->Reservations, Ctxt->Res->Address,
        Ctxt->Res->Flags, Ctxt->Res->ClientUID, Ctxt->Res->nBytes ); 
    if( NO_ERROR != Error ) return Error;

    Error = MemServerGetAddressInfo(
        Server, Ctxt->Res->Address, NULL, NULL, NULL, &Res );
    ASSERT( NO_ERROR == Error );
    
    //
    // Now add subnet options
    //

    Res->SubnetPtr = Subnet;
    Error = IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Res, AddReservationOptionsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddReservationOptionsCallback: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}

    
DWORD
AddSubnetsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error, SScopeId;
    PM_SUBNET Subnet;
    PM_SSCOPE SScope;
    PM_SERVER Server = Ctxt->ExtraCtxt;
    WCHAR SubnetIpAdress[30];

    IpAddressToStringW(Ctxt->Scope->Address, (LPWSTR)SubnetIpAdress);

    //
    // First locate the superscope and create it if needed
    //

    SScopeId = 0;
    if( NULL != Ctxt->SScope ) {
        Error = MemServerFindSScope(
            Server, 0, Ctxt->SScope->Name, &SScope );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = MemSScopeInit(
                &SScope, 0, Ctxt->SScope->Name );
            if( NO_ERROR != Error ) return Error;
            
            Error = MemServerAddSScope(Server,SScope);
            ASSERT( NO_ERROR == Error );
            if( NO_ERROR != Error ) return Error;

        } else if( NO_ERROR != Error ) {
            
            Tr("FindSScope(%ws):%ld\n", Ctxt->SScope->Name, Error);
            return Error;
        }

        SScopeId = SScope->SScopeId;
    }
    
    //
    // Create the subnet..
    //

    Error = MemSubnetInit(
        &Subnet,
        Ctxt->Scope->Address,
        Ctxt->Scope->Mask,
        Ctxt->Scope->State,
        SScopeId,
        Ctxt->Scope->Name,
        Ctxt->Scope->Description
    );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // Add the subnet..
    //
    
    Error = MemServerAddSubnet( Server, Subnet );
    if( NO_ERROR != Error ) {
        MemSubnetCleanup( Subnet );

        if( ERROR_OBJECT_ALREADY_EXISTS == Error ) {
            //
            // Subnet already exists -- this is a conflict
            //
            DhcpEximErrorSubnetAlreadyPresent(
                (LPWSTR)SubnetIpAdress, Ctxt->Scope->Name );
                
            Error = ERROR_CAN_NOT_COMPLETE;
        }

        Tr("AddSubnet %ws failed: %ld\n", Ctxt->Scope->Name, Error );
        return Error;
    }

    //
    // Before adding the options, first copy the ranges and
    // exclusions.. 
    //

    Subnet->Ranges = Ctxt->Scope->Ranges;
    Subnet->Exclusions = Ctxt->Scope->Exclusions;
    MemArrayInit( &Ctxt->Scope->Ranges );
    MemArrayInit( &Ctxt->Scope->Exclusions );
    
    //
    // now add the other stuff
    //
    
    Error = IterateScopeOptions(
        Ctxt->Scope, Subnet, AddSubnetOptionsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddSubnetOptionsCallback: %ld\n", Error );
        return Error;
    }

    Error = IterateScopeReservations(
        Ctxt->Scope, Subnet, AddReservationsCallback );

    if( NO_ERROR != Error ) {
        Tr("AddReservationsCallback: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}

DWORD
MergeConfigurations(
    IN OUT PM_SERVER DestServer,
    IN OUT PM_SERVER Server
    )
/*++

Routine Description:

    This routine merges the configuration provided in "Server"
    onto the configuration already present in "DestServer".

    Rule 1.  The subnets that exist in DestServer should not
    conflict with the subnets that are to be merged from Server.

    Rule 2.  The classes that exist in DestServer should not
    conflict the classes that are to be added from Server.  

    Rule 3.  The optdefs that exist in DestServer should not
    conflict the optdefs that are to be added from Server.

    Rule 4.  The options that exist in DestServer shoult not
    conflict with the options that are to be added from Server.
      
    For all but the first rule, exact duplicates are not
    considered conflicts. 

    Note:  When subnet ranges and exclusions are merged in, they
    are also removed from "Server"...
    
--*/
{
    DWORD Error;

    Tr("Entering MergeConfigurations\n");
    
    //
    // Add the class defs first
    //
    
    Error = IterateClasses(
        Server, DestServer, AddClassesCallback );
    if( NO_ERROR != Error ) {
        Tr("AddClassesCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the optdefs
    //

    Error = IterateOptDefs(
        Server, DestServer, AddOptdefsCallback );
    if( NO_ERROR != Error ) {
        Tr("AddOptdefsCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the global options..
    //

    Error = IterateServerOptions(
        Server, DestServer, AddOptionsCallback );
    if( NO_ERROR != Error ) {
        Tr("AddOptionsCallback: %ld\n", Error );
        return Error;
    }

    //
    // Add the subnets
    //

    Error = IterateScopes(
        Server, DestServer, AddSubnetsCallback );
    if( NO_ERROR != Error ) {
        Tr("IterateScopes: %ld\n", Error );
        return Error;
    }

    //
    // done..
    //
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\main.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   main.c

Abstract:

   main module
   
--*/

#include <precomp.h>
#include <dhcpexim.h>

BOOL GlobalIsNT4, GlobalIsNT5;
WCHAR CurrentDir[MAX_PATH*2];

CRITICAL_SECTION DhcpGlobalMemoryCritSect;
CRITICAL_SECTION DhcpGlobalInProgressCritSect;
CHAR DhcpEximOemDatabaseName[2048];
CHAR DhcpEximOemDatabasePath[2048];
HANDLE hLog;

BOOL IsNT4( VOID ) {
    return GlobalIsNT4;
}

BOOL IsNT5( VOID ) {
    return GlobalIsNT5;
}

#define MAX_PRINTF_LEN 4096
char OutputBuf[MAX_PRINTF_LEN];

VOID
StartDebugLog(
    VOID
    )
{
    CHAR Buffer[MAX_PATH*2];

    if( NULL != hLog ) return;
    
    if( 0 == GetWindowsDirectoryA( Buffer, MAX_PATH )) {
        ZeroMemory(Buffer, sizeof(Buffer));
    }

    if( Buffer[strlen(Buffer)-1] != '\\' ) {
        strcat(Buffer, "\\");
    }
    strcat(Buffer, "dhcpexim.log");
    
    hLog = CreateFileA(
        Buffer, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL );

    if( hLog == INVALID_HANDLE_VALUE) {
        hLog = NULL;
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //

        SetFilePointer(hLog,0,NULL,FILE_END);
    }
}

VOID
CloseDebugLog(
    VOID
    )
{
    if( hLog ) {
        CloseHandle( hLog );
        hLog = NULL;
    }
}

DWORD
Tr(
    IN LPSTR Format,
    ...
    )
{
    va_list ArgList;
    ULONG Length;

    strcpy(OutputBuf, "[DHCP] ");
    Length = strlen(OutputBuf);

    va_start(ArgList, Format);
    Length = vsprintf(&OutputBuf[Length], Format, ArgList );
    va_end(ArgList);

#if DBG
    DbgPrint( (PCH)OutputBuf );
#endif
    
    if( hLog ) {
        DWORD Size = strlen(OutputBuf);
        WriteFile(
            hLog, OutputBuf, Size, &Size, NULL );
    }

    return NO_ERROR;
}

BOOL
IsPostW2k(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;


    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed
    //

    return (Error == NO_ERROR );
}

DWORD
ReconcileLocalService(
    IN PULONG Subnets,
    IN DWORD nSubnets OPTIONAL
    )
/*++

Routine Description:

    This routine reconciles the specified scopes.
    This is needed after importing as the import doesnt
    actually get the bitmask, but only the database entries.

--*/
{
    DWORD Error, FinalError, nRead, nTotal, i;
    DHCP_RESUME_HANDLE Resume = 0;
    LPDHCP_IP_ARRAY IpArray;
    
    if( 0 == nSubnets ) {
        IpArray = NULL;
        Error = DhcpEnumSubnets(
            L"127.0.0.1", &Resume, (ULONG)(-1), &IpArray, &nRead,
            &nTotal );
        if( NO_ERROR != Error ) {
            Tr("DhcpEnumSubnets: %ld\n", Error);
            return Error;
        }

        if( 0 == nRead || 0 == nTotal || IpArray->NumElements == 0 ) {
            Tr("DhcpEnumSubnets returned none." );
            return NO_ERROR;
        }

        Error = ReconcileLocalService(
            IpArray->Elements, IpArray->NumElements );

        DhcpRpcFreeMemory( IpArray );

        return Error;
    }

    //
    // Reconcile each of the specified scopes
    //

    FinalError = NO_ERROR;
    for( i = 0; i < nSubnets ; i ++ ) {
        LPDHCP_SCAN_LIST ScanList = NULL;
        
        Error = DhcpScanDatabase(
            L"127.0.0.1", Subnets[i], TRUE, &ScanList);

        if( NULL != ScanList ) DhcpRpcFreeMemory( ScanList );

        if( NO_ERROR != Error ) {
            Tr("DhcpScanDatabase(0x%lx): %ld\n", Subnets[i], Error);
            FinalError = Error;
        }
    }

    return FinalError;
}
    
DWORD
InitializeAndGetServiceConfig(
    OUT PM_SERVER *pServer
    )
/*++

Routine Description:

    This routine initializes all the modules and obtains the
    configuration for the service

--*/
{
    DWORD Error;
    OSVERSIONINFO Ver;
    extern DWORD  ClassIdRunningCount; // defined in mm\classdefl.c

    //
    // Initialize globals
    //
    
    GlobalIsNT4 = FALSE;
    GlobalIsNT5 = FALSE;
        
    try {
        InitializeCriticalSection( &DhcpGlobalMemoryCritSect );
        InitializeCriticalSection( &DhcpGlobalInProgressCritSect );
    }except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Error = GetLastError( );
        return Error;
    }

    ClassIdRunningCount = 0x1000;
    
    //
    // Other initialization
    //
    
    Error = NO_ERROR;
    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return GetLastError();
    if( Ver.dwMajorVersion == 4 ) GlobalIsNT4 = TRUE;
    else if( Ver.dwMajorVersion == 5 ) GlobalIsNT5 = TRUE;
    else if( Ver.dwMajorVersion < 4 ) return ERROR_NOT_SUPPORTED;

    if( GlobalIsNT5 && IsPostW2k() ) GlobalIsNT5 = FALSE;

#if DBG
    DbgPrint("Is NT4: %s, Is NT5: %s\n",
             GlobalIsNT4 ? "yes" : "no",
             GlobalIsNT5 ? "yes" : "no" );
    
    StartDebugLog();
#endif 
    
    //
    //
    //
    SaveBufSize = 0;
    SaveBuf = LocalAlloc( LPTR, SAVE_BUF_SIZE );
    if( NULL == SaveBuf ) {
        return GetLastError();
    }
    
    
    Error = GetCurrentDirectoryW(
        sizeof(CurrentDir)/sizeof(WCHAR), CurrentDir );
    if( 0 != Error ) {
        Error = NO_ERROR;
    } else {
        Error = GetLastError();
        Tr("GetCurrentDirectoryW: %ld\n", Error );
        return Error;
    }


    //
    // Set right permissions on the db directory etc..
    //

    Error = InitializeDatabaseParameters();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabaseParameters: %ld\n", Error );
        return Error;
    }
    
    //
    // Now obtain the configuration
    //

    if( !GlobalIsNT4 && !GlobalIsNT5 ) {
        //
        // Whistler configuration should be read from the
        // database.. 
        //

        Error = DhcpeximReadDatabaseConfiguration(pServer);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximReadDatabaseConfiguration: %ld\n", Error );
        }
    } else {

        //
        // NT4 or W2K configuration should be read from registry..
        //
        
        Error = DhcpeximReadRegistryConfiguration(pServer);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximReadRegistryConfiguration: %ld\n", Error );
        }
    }

    return Error;
}

DWORD
CleanupServiceConfig(
    IN OUT PM_SERVER Server
    )
{
    DWORD Error;

    if( NULL != SaveBuf ) LocalFree(SaveBuf);
    SaveBuf = NULL;
    SaveBufSize = 0;
    
    if( NULL != Server ) MemServerFree(Server);
    Error =  CleanupDatabaseParameters();
    if( NO_ERROR != Error ) {
        Tr("CleanupServiceConfig: %ld\n", Error );
    }

    if( FALSE == SetCurrentDirectoryW(CurrentDir) ) {
        if( NO_ERROR == Error ) Error = GetLastError();
        Tr("SetCurrentDirectoryW: %ld\n", GetLastError());
    }

    CloseDebugLog();

    DeleteCriticalSection( &DhcpGlobalMemoryCritSect );
    DeleteCriticalSection( &DhcpGlobalInProgressCritSect );

    return Error;
}

DWORD
ExportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN HANDLE hFile
    )
/*++
    
Routine Description:

    This routine attempts to save the service configuration to a
    file after selecting the required subnets.  

--*/
{
    DWORD Error;

    //
    // First select the required subnets and get this
    // configuration alone.
    //

    Error = SelectConfiguration( SvcConfig, Subnets, nSubnets );
    if( NO_ERROR != Error ) return Error;

    //
    // Save the configuration to the specified file handle
    //
    
    hTextFile = hFile;
    Error = SaveConfigurationToFile(SvcConfig);
    if( NO_ERROR != Error ) return Error;

    //
    // Now try to save the database entries to file
    //

    Error = SaveDatabaseEntriesToFile(Subnets, nSubnets);
    if( NO_ERROR != Error ) return Error;

    Tr("ExportConfiguration succeeded\n");
    return NO_ERROR;
}

DWORD
ImportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN LPBYTE Mem, // import file : shared mem
    IN ULONG MemSize // shared mem size
    )
{
    DWORD Error;
    PM_SERVER Server;
    
    //
    // First obtain the configuration from the file
    //
    
    Error = ReadDbEntries( &Mem, &MemSize, &Server );
    if( NO_ERROR != Error ) {
        Tr("ReadDbEntries: %ld\n", Error );
        return Error;
    }

    //
    // Select the configuration required
    //

    Error = SelectConfiguration( Server, Subnets, nSubnets );
    if( NO_ERROR != Error ) return Error;

    //
    // Merge the configuration along with the svc configuration
    //
    Error = MergeConfigurations( SvcConfig, Server );
    if( NO_ERROR != Error ) {
        Tr("MergeConfigurations: %ld\n", Error );
    }

    MemServerFree( Server );

    if( NO_ERROR != Error ) return Error;

    //
    // Now save the new configuration to registry/disk
    //
    if( !GlobalIsNT5 && !GlobalIsNT4 ) {
        //
        // Whistler has config in database
        //
        Error = DhcpeximWriteDatabaseConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
        }
    } else {
        Error = DhcpeximWriteRegistryConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
        }
    }

    if( NO_ERROR != Error ) return Error;

    //
    // Now read the database entries from file and stash them
    // into the db.
    // 

    Error = SaveFileEntriesToDatabase(
        Mem, MemSize, Subnets, nSubnets );
    if( NO_ERROR != Error ) {
        Tr("SaveFileEntriesToDatabase: %ld\n", Error );
    }

    return Error;
}

VOID
IpAddressToStringW(
    IN DWORD IpAddress,
    IN LPWSTR String // must have enough space preallocated
    )
{
   PUCHAR pAddress;
   ULONG Size;

   pAddress = (PUCHAR)&IpAddress;
   wsprintf(String, L"%ld.%ld.%ld.%ld",
            pAddress[3], pAddress[2], pAddress[1], pAddress[0] );
}

DWORD
StringToIpAddressW(
    LPWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = DhcpUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = DhcpDottedStringToIpAddress(pszString);
    }

    return dwRes;
}
        
DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    )
{
    //
    // Syntax: Import <filename> <ALL/subnets>
    //
    LPWSTR FileName;
    ULONG Subnets[1024],*pSubnets, nSubnets, MemSize, Error;
    HANDLE hFile;
    LPBYTE Mem;
    PM_SERVER SvcConfig, FileConfig;
    
    if( nArgs == 1 ) return ERROR_BAD_ARGUMENTS;

    FileName = Args[0]; Args ++ ; nArgs --;

    //
    // First open the file 
    //

    Error = OpenTextFile(
        FileName, TRUE, &hFile, &Mem, &MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead: %ld\n", Error );
        return Error;
    }

    //
    // Now try to parse the rest of the arguments to see if they
    // are all ok
    //

    if( _wcsicmp(Args[0],L"ALL") == 0 ) {
        nSubnets = 0; pSubnets = NULL;
    } else {
        pSubnets = Subnets;
        nSubnets = 0;
        while( nArgs -- ) {
            pSubnets[nSubnets++] = StringToIpAddressW(*Args++);
            if( pSubnets[nSubnets-1] == INADDR_ANY ||
                pSubnets[nSubnets-1] == INADDR_NONE ) {
                Error = ERROR_BAD_ARGUMENTS;
                goto Cleanup;
            }
        }
    }

    //
    // Initialize parameters
    //

    Error = InitializeAndGetServiceConfig( &SvcConfig );
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );
        goto Cleanup;
    }

    Error = ImportConfiguration(
        SvcConfig, pSubnets, nSubnets, Mem, MemSize );
    if( NO_ERROR != Error ) {
        Tr("ImportConfiguration: %ld\n", Error );
    }
    
    //
    // Finally cleanup
    //

    CleanupServiceConfig(SvcConfig);

    //
    // Also reconcile local server
    //

    ReconcileLocalService(pSubnets, nSubnets);
    
 Cleanup:

    CloseTextFile( hFile, Mem );
    return Error;
}

    
DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    )
{
    //
    // Syntax: Import <filename> <ALL/subnets>
    //
    LPWSTR FileName;
    ULONG Subnets[1024],*pSubnets, nSubnets, MemSize, Error;
    HANDLE hFile;
    LPBYTE Mem;
    PM_SERVER SvcConfig, FileConfig;
    
    if( nArgs == 1 ) return ERROR_BAD_ARGUMENTS;

    FileName = Args[0]; Args ++ ; nArgs --;

    //
    // First open the file 
    //

    Error = OpenTextFile(
        FileName, FALSE, &hFile, &Mem, &MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead: %ld\n", Error );
        return Error;
    }

    //
    // Now try to parse the rest of the arguments to see if they
    // are all ok
    //

    if( _wcsicmp(Args[0],L"ALL") == 0 ) {
        nSubnets = 0; pSubnets = NULL;
    } else {
        pSubnets = Subnets;
        nSubnets = 0;
        while( nArgs -- ) {
            pSubnets[nSubnets++] = StringToIpAddressW(*Args++);
            if( pSubnets[nSubnets-1] == INADDR_ANY ||
                pSubnets[nSubnets-1] == INADDR_NONE ) {
                Error = ERROR_BAD_ARGUMENTS;
                goto Cleanup;
            }
        }
    }

    //
    // Initialize parameters
    //

    Error = InitializeAndGetServiceConfig( &SvcConfig );
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );
        goto Cleanup;
    }

    //
    //  Export configuration
    //

    Error = ExportConfiguration(
        SvcConfig, pSubnets, nSubnets, hFile );
    if( NO_ERROR != Error ) {
        Tr("ExportConfiguration: %ld\n", Error );
    }
    
    //
    // Finally cleanup
    //

    CleanupServiceConfig(SvcConfig);
    
 Cleanup:

    CloseTextFile( hFile, Mem );
    return Error;
}

PM_SERVER
DhcpGetCurrentServer(
    VOID
)
{
    ASSERT( FALSE );
    //
    // This is there only to let teh compiler compile without
    // having to include dhcpssvc.lib.  This routine should never
    // be called at all
    //
    return NULL;
}

BOOL
SubnetMatches(
    IN DWORD IpAddress,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    if( 0 == nSubnets || NULL == Subnets ) return TRUE;
    while( nSubnets -- ) {
        if( IpAddress == *Subnets ++) return TRUE;
    }

    return FALSE;
}
    
VOID
DisableLocalScopes(
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;
    PM_SERVER SvcConfig;
    ARRAY_LOCATION Loc;
    PM_SUBNET Subnet;
    
    Error = InitializeAndGetServiceConfig(&SvcConfig);
    if( NO_ERROR != Error ) {
        Tr("DisableLocalScopes: Init: %ld\n", Error );
        return;
    }

    Error = MemArrayInitLoc(&SvcConfig->Subnets, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &SvcConfig->Subnets, &Loc, &Subnet);
        ASSERT( NO_ERROR == Error && NULL != Subnet );

        //
        // Disable the subnet
        //

        if( SubnetMatches(Subnet->Address, Subnets, nSubnets ) ) {
            Subnet->State = DISABLED(Subnet->State);
        }

        Error = MemArrayNextLoc(
            &SvcConfig->Subnets, &Loc);
    }

    //
    // Now save the new configuration to registry/disk
    //

    if( !GlobalIsNT5 && !GlobalIsNT4 ) {
        //
        // Whistler has config in database
        //
        Error = DhcpeximWriteDatabaseConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
        }
    } else {
        Error = DhcpeximWriteRegistryConfiguration(SvcConfig);
        if( NO_ERROR != Error ) {
            Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
        }
    }

    CleanupServiceConfig(SvcConfig);
}


LPWSTR
MakeName(
    IN DWORD IpAddress,
    IN LPWSTR Name
    )
{
    static WCHAR Buffer[40];
    PUCHAR pAddress;
    LPWSTR RetVal;
    ULONG Size;
    
    pAddress = (PUCHAR)&IpAddress;
    wsprintf(Buffer, L"[%d.%d.%d.%d]  ", pAddress[3], pAddress[2],
            pAddress[1], pAddress[0] );

    Size = wcslen(Buffer)+1;
    if( NULL != Name ) Size += wcslen(Name);

    RetVal = LocalAlloc( LPTR, Size * sizeof(WCHAR));
    if( NULL == RetVal ) return NULL;

    wcscpy(RetVal, Buffer);
    if( NULL != Name ) wcscat(RetVal, Name );
    
    return RetVal;
}    
DWORD
InitializeCtxt(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error,i, Size;
    ARRAY_LOCATION Loc;
    PM_SUBNET Subnet;
    
    //
    // First find the # of subnets and allocate array
    //
    Ctxt->nScopes = i = MemArraySize(&Server->Subnets);
    Ctxt->Scopes = LocalAlloc(LPTR,  i * sizeof(Ctxt->Scopes[0]) );
    if( NULL == Ctxt->Scopes ) {
        Ctxt->nScopes = 0;
        return GetLastError();
    }

    //
    // Walk through the array and setup each element
    //

    i = 0;
    Error = MemArrayInitLoc( &Server->Subnets, &Loc );
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &Subnet );
        ASSERT(NO_ERROR == Error );

        Ctxt->Scopes[i].SubnetAddress = Subnet->Address;
        Ctxt->Scopes[i].SubnetName = MakeName(Subnet->Address, Subnet->Name);
        if( NULL == Ctxt->Scopes[i].SubnetName ) return GetLastError();

        i ++;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc );
    }

    return NO_ERROR;
}
    
DWORD
DhcpEximInitializeContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN LPWSTR FileName,
    IN BOOL fExport
    )
{
    DWORD Error;
    LPVOID Mem;
    
    ZeroMemory(Ctxt, sizeof(*Ctxt));

    //
    // First set the FileName and fExport fields
    //
    Ctxt->FileName = FileName;
    Ctxt->fExport = fExport;

    //
    // Next open the file.
    //
    Error = OpenTextFile(
        FileName, !fExport, &Ctxt->hFile, &Ctxt->Mem,
        &Ctxt->MemSize );
    if( NO_ERROR != Error ) {
        Tr("OpenTextFileForRead:%ld\n", Error );
        return Error;
    }

    //
    // Initialize parameters and obtain config
    //

    Error = InitializeAndGetServiceConfig(
        (PM_SERVER*)&Ctxt->SvcConfig);
    if( NO_ERROR != Error ) {
        Tr("InitializeAndGetServiceConfig: %ld\n", Error );

        CloseTextFile(Ctxt->hFile, Ctxt->Mem);
        return Error;
    }

    do {
        //
        // If this is an import, the configuration from the file
        // should also be read.
        //
        
        if( !fExport ) {

            Error = ReadDbEntries(
                &Ctxt->Mem, &Ctxt->MemSize,
                (PM_SERVER*)&Ctxt->FileConfig );
            if( NO_ERROR != Error ) {
                Tr("ReadDbEntries: %ld\n", Error );

                break;
            }
        }
        
        //
        // Allocate and initialize the Ctxt data structures with the
        // service scopes info in case of EXPORT
        //
        
        Error = InitializeCtxt(
            Ctxt, fExport ? Ctxt->SvcConfig : Ctxt->FileConfig );
        
        if( NO_ERROR != Error ) {
            Tr("InitializeCtxt: %ld\n", Error );

            break;
        }
    } while( 0 );

    if( NO_ERROR != Error ) {

        CleanupServiceConfig( Ctxt->SvcConfig );
        if( NULL != Ctxt->FileConfig ) {
            MemServerFree( (PM_SERVER)Ctxt->FileConfig );
        }
        CloseTextFile( Ctxt->hFile, Ctxt->Mem );
    }

    return Error;
}

DWORD
CalculateSubnets(
    IN PDHCPEXIM_CONTEXT Ctxt,
    OUT PULONG *Subnets,
    OUT ULONG *nSubnets
    )
{
    DWORD Error, i;
    PULONG pSubnets;
    
    //
    // First check if there is atleast one unselected subnet
    //
    (*nSubnets) = 0;
    
    for( i = 0; i < Ctxt->nScopes; i ++ ) {
        if( Ctxt->Scopes[i].fSelected ) (*nSubnets) ++;
    }

    //
    // Special case if all subnets are selected
    //
                                          
    if( *nSubnets == Ctxt->nScopes ) {
        *nSubnets = 0;
        *Subnets = NULL;
        return NO_ERROR;
    }

    //
    // Allocate memory
    //

    *Subnets = LocalAlloc( LPTR, sizeof(DWORD)* (*nSubnets));
    if( NULL == *Subnets ) return GetLastError();

    //
    // Copy the subnets
    //

    (*nSubnets) = 0;
    for( i = 0; i < Ctxt->nScopes; i ++ ) {
        if( Ctxt->Scopes[i].fSelected ) {
            (*Subnets)[(*nSubnets)++] = Ctxt->Scopes[i].SubnetAddress;
        }
    }

    return NO_ERROR;
}

DWORD
DhcpEximCleanupContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN BOOL fAbort
    )
{
    DWORD Error, i;
    DWORD *Subnets, nSubnets;
    
    Error = NO_ERROR;
    Subnets = NULL;
    nSubnets = 0;
    
    //
    // If not aborting, attempt to execute the operation
    //
    if( !fAbort ) do {
        Error = CalculateSubnets( Ctxt, &Subnets, &nSubnets );
        if( NO_ERROR != Error ) {
            Tr("CalculateSubnets: %ld\n", Error );
            break;
        }

        if( Ctxt->fExport ) {
            // 
            // Export the specified subnets out
            //

            Error = SelectConfiguration(
                Ctxt->SvcConfig, Subnets, nSubnets );
            
            if( NO_ERROR != Error ) {
                Tr("SelectConfiguration: %ld\n", Error );
                break;
            }
            
            Error = SaveConfigurationToFile( Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("SaveConfigurationToFile: %ld\n", Error );
                break;
            }

            //
            // Now try to save the database entries to file
            //
            
            Error = SaveDatabaseEntriesToFile(Subnets, nSubnets);
            if( NO_ERROR != Error ) {
                Tr("SaveDatabaseEntriesToFile: %ld\n", Error );
            }

            break;
        } 

        //
        // Import the specified subnets in
        //
        
        Error = SelectConfiguration(
            Ctxt->FileConfig, Subnets, nSubnets );
        
        if( NO_ERROR != Error ) {
            Tr("SelectConfiguration: %ld\n", Error );
            break;
        }
        
        Error = MergeConfigurations(
            Ctxt->SvcConfig, Ctxt->FileConfig );
        
        if( NO_ERROR != Error ) {
            Tr("MergeConfigurations: %ld\n", Error );
            break;
        } 
        
        
        //
        // Now save the new configuration to registry/disk
        //
        if( !GlobalIsNT5 && !GlobalIsNT4 ) {
            //
            // Whistler has config in database
            //
            Error = DhcpeximWriteDatabaseConfiguration(Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("DhcpeximWriteDatabaseConfiguration: %ld\n", Error );
            }
        } else {
            Error = DhcpeximWriteRegistryConfiguration(Ctxt->SvcConfig);
            if( NO_ERROR != Error ) {
                Tr("DhcpeximWriteRegistryConfiguration: %ld\n", Error );
            }
        }
        
        if( NO_ERROR != Error ) break;
        
        //
        // Now read the database entries from file and stash them
        // into the db.
        // 
            
        Error = SaveFileEntriesToDatabase(
            Ctxt->Mem, Ctxt->MemSize, Subnets, nSubnets );
        if( NO_ERROR != Error ) {
            Tr("SaveFileEntriesToDatabase: %ld\n", Error );
        }
        
    } while( 0 );
        

    //
    // Cleanup
    //

    if( NULL != Ctxt->SvcConfig ) {
        CleanupServiceConfig( Ctxt->SvcConfig );
    }

    if( NULL != Ctxt->FileConfig ) {
        MemServerFree( (PM_SERVER)Ctxt->FileConfig );
    }

    if( !fAbort  && Ctxt->fExport == FALSE ) {
        //
        // Also reconcile local server
        //
        
        ReconcileLocalService( Subnets, nSubnets );
    }        

    CloseTextFile( Ctxt->hFile, Ctxt->Mem );

    //
    // Walk through the array and free up pointers
    //

    for( i = 0 ; i < Ctxt->nScopes ; i ++ ) {
        if( Ctxt->Scopes[i].SubnetName ) {
            LocalFree( Ctxt->Scopes[i].SubnetName );
        }
    }
    if( Ctxt->Scopes ) LocalFree( Ctxt->Scopes );
    Ctxt->Scopes = NULL; Ctxt->nScopes = 0;

    if( !fAbort && Ctxt->fExport && Ctxt->fDisableExportedScopes  ) {
        //
        // Fix the local scopes to all be disabled
        //

        DisableLocalScopes(Subnets, nSubnets);
    }

    if( NULL != Subnets && 0 != nSubnets ) {
        LocalFree( Subnets );
    }
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\precomp.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    precompiled header

--*/


//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

//
//  NT public header files
//



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <shellapi.h>
#include <align.h>
#include <time.h>

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>

#include <winsock2.h>
#include <excpt.h>
#include <accctrl.h>


//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// MM related files
//

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <winsock2.h>
#include    <dhcpupg.h>
#include    <esent.h>
#include    <dhcpmsg.h>
#include    <dhcplib.h>
#include    <dhcpexim.h>
#include    <dhcpapi.h>

//
// Constants
//

#define DHCPEXIM_REG_CFG_LOC5 TEXT("Software\\Microsoft\\DHCPServer\\Configuration")
#define DHCPEXIM_REG_CFG_LOC4 TEXT("System\\CurrentControlSet\\Services\\DHCPServer\\Configuration")

#define SAVE_BUF_SIZE (1004096L)

extern CHAR DhcpEximOemDatabaseName[2048];
extern CHAR DhcpEximOemDatabasePath[2048];
extern HANDLE hTextFile; // defined in dbfile.c
extern PUCHAR SaveBuf; // defined in dbfile.c
extern ULONG SaveBufSize; //defined in dbfile.c

enum {
    LoadJet200,
    LoadJet500,
    LoadJet97,  /* Win2K, ESENT */
    LoadJet2001 /* Whistler, ESENT */
};


typedef struct _MM_ITERATE_CTXT {
    //
    // This is filled in for all Iterate* routines
    //
    
    PM_SERVER Server;
    PVOID ExtraCtxt;

    //
    // This is filled in for IterateClasses
    //
    
    PM_CLASSDEF ClassDef;

    //
    // This is filled in for IterateOptDefs
    //

    PM_OPTDEF OptDef;


    //
    // This is filled in for IterateOptions 
    //

    PM_OPTION Option;

    //
    // These two are filled in by both IterateOptDefs and IterateOptions
    //
    
    PM_CLASSDEF UserClass; 
    PM_CLASSDEF VendorClass;
    
    //
    // This is used by IterateScopes
    //

    PM_SUBNET Scope;
    PM_SSCOPE SScope;

    //
    // This is used by IterateScopeRanges
    //

    PM_RANGE Range;

    //
    // This is used by IterateScopeExclusions
    //

    PM_EXCL Excl;

    //
    // This is used by IterateScopeReservations
    //

    PM_RESERVATION Res;
    
}MM_ITERATE_CTXT, *PMM_ITERATE_CTXT;

DWORD
IterateClasses(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateOptDefs(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateOptionsOnOptClass(
    IN PM_SERVER Server,
    IN PM_OPTCLASS OptClass,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateServerOptions(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeOptions(
    IN PM_SUBNET Subnet,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateReservationOptions(
    IN PM_SERVER Server,
    IN PM_RESERVATION Res,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopes(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeRanges(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeExclusions(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );

DWORD
IterateScopeReservations(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    );


//
// readreg.c
//

DWORD
DhcpeximReadRegistryConfiguration(
    IN OUT PM_SERVER *Server
    );


DWORD
DhcpeximReadRegistryParameters(
    VOID
    );

//
// writereg.c
//

DWORD
DhcpeximWriteRegistryConfiguration(
    IN PM_SERVER Server
    );

//
// readdb.c
//

DWORD
DhcpeximReadDatabaseConfiguration(
    IN OUT PM_SERVER *Server
    );

//
// writedb.c
//

DWORD
DhcpeximWriteDatabaseConfiguration(
    IN PM_SERVER Server
    );

//
// dbfile.c
//

DWORD
AddRecordNoSize(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
InitializeDatabaseParameters(
    VOID
    );

DWORD
CleanupDatabaseParameters(
    VOID
    );

DWORD
SaveDatabaseEntriesToFile(
    IN PULONG Subnets,
    IN ULONG nSubnets
    );

DWORD
SaveFileEntriesToDatabase(
    IN LPBYTE Mem,
    IN ULONG MemSize,
    IN PULONG Subnets,
    IN ULONG nSubnets
    );

DWORD
OpenTextFile(
    IN LPWSTR FileName,
    IN BOOL fRead,
    OUT HANDLE *hFile,
    OUT LPBYTE *Mem,
    OUT ULONG *MemSize
    );

VOID
CloseTextFile(
    IN OUT HANDLE hFile,
    IN OUT LPBYTE Mem
    );

//
// mmfile.c
//

DWORD
SaveConfigurationToFile(
    IN PM_SERVER Server
    );

DWORD
ReadDbEntries(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN OUT PM_SERVER *Server
    );

//
// merge.c
//

DWORD
MergeConfigurations(
    IN OUT PM_SERVER DestServer,
    IN OUT PM_SERVER Server
    );

//
// main.c
//

DWORD
Tr(
    IN LPSTR Format, ...
    );

BOOL IsNT4();
BOOL IsNT5(); 

VOID
IpAddressToStringW(
    IN DWORD IpAddress,
    IN LPWSTR String // must have enough space preallocated
    );

DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
ImportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN LPBYTE Mem, // import file : shared mem
    IN ULONG MemSize // shared mem size
    );

DWORD
ExportConfiguration(
    IN OUT PM_SERVER SvcConfig,
    IN ULONG *Subnets,
    IN ULONG nSubnets,
    IN HANDLE hFile
    );

DWORD
CleanupServiceConfig(
    IN OUT PM_SERVER Server
    );

DWORD
InitializeAndGetServiceConfig(
    OUT PM_SERVER *pServer
    );

//
// select.c
//

DWORD
SelectConfiguration(
    IN OUT PM_SERVER Server,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    );

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\iterate.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    iterate.c

Abstract:

    This module contains routines that iterate over the MM data structures

--*/

#include <precomp.h>

DWORD
IterateClasses(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_CLASSDEF ClassDef;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->ClassDefs.ClassDefArray, &Loc );
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->ClassDefs.ClassDefArray, &Loc, &ClassDef );
        ASSERT( NO_ERROR == Error );

        Ctxt.ClassDef = ClassDef;
        Error = Callback( &Ctxt );
        if( ERROR_KEY_DELETED == Error ) {
            //
            // Delete this class ..
            //
            MemArrayDelElement(
                &Server->ClassDefs.ClassDefArray, &Loc, &ClassDef );
            MemClassDefFree( ClassDef );

            Error = MemArrayAdjustLocation(
                &Server->ClassDefs.ClassDefArray, &Loc );
        } else {
            if( NO_ERROR != Error ) return Error;
            
            Error = MemArrayNextLoc(
                &Server->ClassDefs.ClassDefArray, &Loc );
        }
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

PM_CLASSDEF
FindClass(
    IN PM_SERVER Server,
    IN ULONG ClassId
    )
{
    DWORD Error;
    PM_CLASSDEF Class;

    if( 0 == ClassId ) return NULL;
    
    Error = MemServerGetClassDef(
        Server, ClassId, NULL, 0, NULL, &Class );
    ASSERT( NO_ERROR == Error );
    
    if( NO_ERROR == Error ) return Class;
    return NULL;
}

DWORD
IterateOptDefs(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc, Loc2;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_OPTDEF OptDef;
    PM_OPTCLASSDEFL_ONE OptClassDefList;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->OptDefs.Array, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->OptDefs.Array, &Loc, &OptClassDefList );
        ASSERT( NO_ERROR == Error );

        Ctxt.UserClass = FindClass( Server, OptClassDefList->ClassId );
        Ctxt.VendorClass = FindClass( Server, OptClassDefList->VendorId );
        
        Error = MemArrayInitLoc(
            &OptClassDefList->OptDefList.OptDefArray, &Loc2 );
        while( NO_ERROR == Error ) {

            Error = MemArrayGetElement(
                &OptClassDefList->OptDefList.OptDefArray, &Loc2,
                &OptDef );
            ASSERT( NO_ERROR == Error );

            Ctxt.OptDef = OptDef;
            Error = Callback( &Ctxt );
            if( ERROR_KEY_DELETED == Error ) {
                //
                // Delete this optdef..
                //
                MemArrayDelElement(
                    &OptClassDefList->OptDefList.OptDefArray,
                    &Loc2, &OptDef );
                MemOptDefFree( OptDef );

                Error = MemArrayAdjustLocation(
                    &OptClassDefList->OptDefList.OptDefArray,
                    &Loc2 );
            } else {
                if( NO_ERROR != Error ) return Error;

                Error = MemArrayNextLoc(
                    &OptClassDefList->OptDefList.OptDefArray, &Loc2 );
            }
        }
        
        if( ERROR_FILE_NOT_FOUND != Error ) return Error;
                                     
        Error = MemArrayNextLoc( &Server->OptDefs.Array, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateOptionsOnOptClass(
    IN PM_SERVER Server,
    IN PM_OPTCLASS OptClass,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc, Loc2;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_OPTION Option;
    PM_ONECLASS_OPTLIST OptList;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &OptClass->Array, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &OptClass->Array, &Loc, &OptList );
        ASSERT( NO_ERROR == Error );

        Ctxt.UserClass = FindClass( Server, OptList->ClassId );
        Ctxt.VendorClass = FindClass( Server, OptList->VendorId );
        
        Error = MemArrayInitLoc( &OptList->OptList, &Loc2 );
        while( NO_ERROR == Error ) {

            Error = MemArrayGetElement(
                &OptList->OptList, &Loc2, &Option );
            ASSERT( NO_ERROR == Error );

            Ctxt.Option = Option;
            Error = Callback( &Ctxt );
            if( NO_ERROR != Error ) return Error;

            Error = MemArrayNextLoc( &OptList->OptList, &Loc2 );
        }
        if( ERROR_FILE_NOT_FOUND != Error ) return Error;
                                     
        Error = MemArrayNextLoc( &OptClass->Array, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}
    

DWORD
IterateServerOptions(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    return IterateOptionsOnOptClass(
        Server, &Server->Options, ExtraCtxt, Callback );
}

DWORD
IterateScopeOptions(
    IN PM_SUBNET Subnet,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    return IterateOptionsOnOptClass(
        (PM_SERVER)Subnet->ServerPtr,
        &Subnet->Options, ExtraCtxt, Callback );
}

DWORD
IterateReservationOptions(
    IN PM_SERVER Server,
    IN PM_RESERVATION Res,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    PM_SUBNET Subnet = NULL;

    MemServerGetUAddressInfo(
        Server, Res->Address, &Subnet, NULL, NULL, NULL );
    
    return IterateOptionsOnOptClass(
        Server, &Res->Options, ExtraCtxt, Callback );
}    

PM_SSCOPE
FindSScope(
    IN PM_SERVER Server,
    IN DWORD SScopeId
    )
{
    DWORD Error;
    PM_SSCOPE SScope;

    if( SScopeId == INVALID_SSCOPE_ID ) return NULL;
    Error = MemServerFindSScope(
        Server, SScopeId, NULL, &SScope );
    if( NO_ERROR != Error ) return NULL;
    return SScope;
}

DWORD
IterateScopes(
    IN PM_SERVER Server,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_SUBNET Scope;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = Server;
    Error = MemArrayInitLoc( &Server->Subnets, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Server->Subnets, &Loc, &Scope );
        ASSERT( NO_ERROR == Error );

        Ctxt.SScope = FindSScope( Server, Scope->SuperScopeId );
        Ctxt.Scope = Scope;
        Error = Callback( &Ctxt );

        if( ERROR_KEY_DELETED == Error ) {
            //
            // Delete this scope
            //
            MemArrayDelElement(
                &Server->Subnets, &Loc, &Scope );
            MemSubnetFree( Scope );

            Error = MemArrayAdjustLocation(
                &Server->Subnets, &Loc );
        } else {
            if( NO_ERROR != Error ) return Error;
            
            Error = MemArrayNextLoc( &Server->Subnets, &Loc );
        }
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeRanges(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_RANGE Range;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Ranges, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Ranges, &Loc, &Range );
        ASSERT( NO_ERROR == Error );

        Ctxt.Range = Range;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Ranges, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeExclusions(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_EXCL Excl;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Exclusions, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Exclusions, &Loc, &Excl );
        ASSERT( NO_ERROR == Error );

        Ctxt.Excl = Excl;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Exclusions, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}

DWORD
IterateScopeReservations(
    IN PM_SUBNET Scope,
    IN PVOID ExtraCtxt,
    IN DWORD (*Callback)( IN OUT PMM_ITERATE_CTXT )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    MM_ITERATE_CTXT Ctxt;
    PM_RESERVATION Res;
    
    Ctxt.ExtraCtxt = ExtraCtxt;
    Ctxt.Server = (PM_SERVER)Scope->ServerPtr;
    Error = MemArrayInitLoc( &Scope->Reservations, &Loc );

    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement(
            &Scope->Reservations, &Loc, &Res );
        ASSERT( NO_ERROR == Error );

        Ctxt.Res = Res;
        Error = Callback( &Ctxt );
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Scope->Reservations, &Loc ); 
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\dbfile.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   db2file.c

Abstract:

   This module reads the database records and writes them into a
   file format.

--*/

#include <precomp.h>

enum {
    RecordTypeDbEntry,
    RecordTypeMcastDbEntry,
};

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10


#define SAVE_THRESHOLD (1000000L)

//
// Globals
//

DWORD JetVersion;
CHAR DatabaseName[1024], DatabasePath[1024];
HMODULE hJet;
JET_INSTANCE JetInstance;
JET_SESID JetSession;
JET_DBID JetDb;
JET_TABLEID JetTbl;
PUCHAR SaveBuf;
ULONG SaveBufSize;
HANDLE hTextFile, hMapping;
PVOID FileView;
WCHAR Winnt32Path[MAX_PATH*2];
CHAR System32Path[MAX_PATH*2];

JET_ERR (JET_API *pJetSetCurrentIndex)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName
    );
JET_ERR (JET_API *pJetRetrieveColumn)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR (JET_API *pJetSetColumn)(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    JET_COLUMNID    columnid,
    const void      *pvData,
    unsigned long   cbData,
    JET_GRBIT       grbit,
    JET_SETINFO     *psetinfo );

JET_ERR (JET_API *pJetMove)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetSetSystemParameter)(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		lParam,
	const char		*sz );

JET_ERR (JET_API *pJetBeginTransaction)(
    JET_SESID sesid
    );
JET_ERR (JET_API *pJetPrepareUpdate)(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        unsigned long   prep );

JET_ERR (JET_API *pJetUpdate)(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        void                    *pvBookmark,
        unsigned long   cbBookmark,
        unsigned long   *pcbActual);

JET_ERR (JET_API *pJetCommitTransaction)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetRollback)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetTerm)( JET_INSTANCE instance );

JET_ERR (JET_API *pJetTerm2)( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR (JET_API *pJetEndSession)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetBeginSession)(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR (JET_API *pJetInit)( JET_INSTANCE *pinstance);

JET_ERR (JET_API *pJetDetachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR (JET_API *pJetAttachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetCloseDatabase)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenTable)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR (JET_API *pJetCloseTable)( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR (JET_API *pJetGetTableColumnInfo)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR (JET_API *pJetGetIndexInfo)(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const char              *szIndexName,
        void                    *pvResult,
        unsigned long   cbResult,
        unsigned long   InfoLevel );

#define DB_FUNC(F,I,S) \
{#F, TEXT(#F), #F "@" #S, I, (FARPROC *)& p ## F }

typedef struct _DB_FUNC_ENTRY {
    LPSTR FuncName;
    LPWSTR FuncNameW;
    LPSTR AltName;
    DWORD Index;
    FARPROC *FuncPtr;
} DB_FUNC_ENTRY;

DB_FUNC_ENTRY FuncTable[] = {
    DB_FUNC(JetSetCurrentIndex, 164, 12),
    DB_FUNC(JetRetrieveColumn, 157, 32),
    DB_FUNC(JetSetColumn, 162, 28),
    DB_FUNC(JetMove, 147, 16),
    DB_FUNC(JetSetSystemParameter, 165, 20),
    DB_FUNC(JetTerm, 167, 4),
    DB_FUNC(JetTerm2, 0, 8),
    DB_FUNC(JetEndSession, 124, 8),
    DB_FUNC(JetBeginSession, 104, 16),
    DB_FUNC(JetInit, 145, 4),
    DB_FUNC(JetDetachDatabase, 121, 8),
    DB_FUNC(JetAttachDatabase, 102, 12),
    DB_FUNC(JetOpenDatabase, 148, 20),
    DB_FUNC(JetOpenTable, 149, 28),
    DB_FUNC(JetGetTableColumnInfo, 137, 24),
    DB_FUNC(JetCloseTable,108, 8),
    DB_FUNC(JetCloseDatabase, 107, 12),
    DB_FUNC(JetGetIndexInfo, 131, 28),
    DB_FUNC(JetBeginTransaction, 105, 4),
    DB_FUNC(JetPrepareUpdate, 151, 12),
    DB_FUNC(JetUpdate, 168, 20),
    DB_FUNC(JetCommitTransaction, 109, 8),
    DB_FUNC(JetRollback, 160, 8),
};

#define JetSetCurrentIndex pJetSetCurrentIndex
#define JetRetrieveColumn pJetRetrieveColumn
#define JetSetColumn pJetSetColumn
#define JetMove pJetMove
#define JetSetSystemParameter pJetSetSystemParameter
#define JetTerm pJetTerm
#define JetTerm2 pJetTerm2
#define JetEndSession pJetEndSession
#define JetBeginSession pJetBeginSession
#define JetInit pJetInit
#define JetDetachDatabase pJetDetachDatabase
#define JetAttachDatabase pJetAttachDatabase
#define JetOpenDatabase pJetOpenDatabase
#define JetOpenTable pJetOpenTable
#define JetGetTableColumnInfo pJetGetTableColumnInfo
#define JetCloseTable pJetCloseTable
#define JetCloseDatabase pJetCloseDatabase
#define JetGetIndexInfo pJetGetIndexInfo
#define JetBeginTransaction pJetBeginTransaction
#define JetPrepareUpdate pJetPrepareUpdate
#define JetUpdate pJetUpdate
#define JetCommitTransaction pJetCommitTransaction
#define JetRollback pJetRollback

typedef struct _TABLE_INFO {
    CHAR *ColName;
    JET_COLUMNID ColHandle;
    BOOL fPresent;
    JET_COLTYP ColType;
} TABLE_INFO, *LPTABLE_INFO;

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"

static TABLE_INFO ClientTable[] = {
    { IPADDRESS_STRING        , 0, 1, JET_coltypLong },
    { HARDWARE_ADDRESS_STRING , 0, 1, JET_coltypBinary },
    { STATE_STRING            , 0, 1, JET_coltypUnsignedByte },
    { MACHINE_INFO_STRING     , 0, 1, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
    { MACHINE_NAME_STRING     , 0, 1, JET_coltypBinary },
    { LEASE_TERMINATE_STRING  , 0, 1, JET_coltypCurrency },
    { SUBNET_MASK_STRING      , 0, 1, JET_coltypLong },
    { SERVER_IP_ADDRESS_STRING, 0, 1, JET_coltypLong },
    { SERVER_NAME_STRING      , 0, 1, JET_coltypBinary },
    { CLIENT_TYPE             , 0, 1, JET_coltypUnsignedByte }
};

#define MAGIC_COOKIE_NT4 'NT4 '
#define MAGIC_COOKIE_NT5 'W2K '
#define MAGIC_COOKIE_NT5_PLUS 'W2K1'

DWORD
GetCurrentMagicCookie(
    VOID
    )
{
    OSVERSIONINFO Ver;

    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return MAGIC_COOKIE_NT5_PLUS;
    if( Ver.dwMajorVersion == 4 ) return MAGIC_COOKIE_NT4;
    else if( Ver.dwMajorVersion == 5 ) {
        if( Ver.dwBuildNumber >= 2200 ) return MAGIC_COOKIE_NT5_PLUS;
        else return MAGIC_COOKIE_NT5;
    }
    return MAGIC_COOKIE_NT4;
}

DWORD
OpenTextFile(
    IN LPWSTR FileName,
    IN BOOL fRead,
    OUT HANDLE *hFile,
    OUT LPBYTE *Mem,
    OUT ULONG *MemSize
    )
{
    DWORD Error, Flags, LoSize, HiSize;

    Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    hTextFile = CreateFileW(
        FileName, GENERIC_READ | GENERIC_WRITE | DELETE,
        FILE_SHARE_READ, NULL,
        fRead ? OPEN_EXISTING : CREATE_ALWAYS,
        Flags, NULL );

    if( hTextFile == INVALID_HANDLE_VALUE ) {
        hTextFile = NULL;
        Error = GetLastError();
        if( !fRead || ERROR_FILE_NOT_FOUND != Error ) {
            Tr("CreateFile<%ws>: %ld\n", FileName, Error );
        }
        return Error;
    }

    (*hFile) = hTextFile;
    if( !fRead ) {
        //
        // Write the magic cookie
        //
        Flags = GetCurrentMagicCookie();
        if( FALSE == WriteFile(
            hTextFile, (LPBYTE)&Flags, sizeof(Flags), &LoSize,
            NULL ) ) {
            Error = GetLastError();
            CloseHandle(hTextFile);
            return Error;
        }
            
        return NO_ERROR;
    }

    LoSize = GetFileSize( hTextFile, &HiSize );
    if( -1 == LoSize && NO_ERROR != GetLastError() ) {
        return GetLastError();
    }

    if( LoSize <= sizeof(DWORD) ) {
        CloseHandle(hTextFile);
        return ERROR_INVALID_DATA;
    }
       
    (*MemSize) = LoSize;
    (*Mem) = NULL;
    
    hMapping = CreateFileMapping(
        hTextFile, NULL, PAGE_READONLY | SEC_COMMIT, HiSize, LoSize,
        NULL );
    if( NULL == hMapping ) {
        Error = GetLastError();
        Tr("Can't map file: %ld\n", Error );
        return Error;
    }

    FileView = MapViewOfFile(
        hMapping, FILE_MAP_READ, 0, 0, 0 );

    if( NULL == FileView ) {
        Error = GetLastError();
        Tr("Can't create view: %ld\n", Error );
        CloseHandle( hMapping );
        CloseHandle( hTextFile );
        hTextFile = NULL;
        hMapping = NULL;
        return Error;
    }

    (*Mem) = FileView;

    //
    // Before okaying, check if the version of the file is
    // greater than current version
    //

    Error = NO_ERROR;
    CopyMemory(&Flags, *Mem, sizeof(Flags));
    switch(GetCurrentMagicCookie()) {
    case MAGIC_COOKIE_NT5_PLUS :
        if( Flags != MAGIC_COOKIE_NT5 &&
            Flags != MAGIC_COOKIE_NT5_PLUS &&
            Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    case MAGIC_COOKIE_NT5 :
        if( Flags != MAGIC_COOKIE_NT5 &&
            Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    case MAGIC_COOKIE_NT4 :
        if( Flags != MAGIC_COOKIE_NT4 ) {
            Error = ERROR_NOT_SUPPORTED;
        }
        break;
    }

    if( NO_ERROR != Error ) {
        UnmapViewOfFile(FileView);
        CloseHandle( hMapping );
        CloseHandle( hTextFile );
        hTextFile = NULL;
        hMapping = NULL;
        FileView = NULL;
        return Error;
    }
    
    *MemSize -= sizeof(DWORD);
    (*Mem) += sizeof(DWORD);
    return NO_ERROR;
}

VOID
CloseTextFile(
    IN OUT HANDLE hFile,
    IN OUT LPBYTE Mem
    )
{
    ASSERT( hFile == hTextFile );
    
    if( NULL != FileView ) UnmapViewOfFile( FileView );
    FileView = NULL;

    if( NULL != hMapping ) CloseHandle( hMapping );
    hMapping = NULL;

    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;
}

ULONG
ByteSwap(
    IN ULONG Source
    )
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}

LPSTR
IpAddressToString(
    IN ULONG Address
    )
{
    static CHAR Buffer[30];
    PUCHAR pAddress;

    pAddress = (PUCHAR)&Address;
    sprintf(Buffer, "%d.%d.%d.%d", pAddress[0], pAddress[1],
            pAddress[2], pAddress[3] );
    return Buffer;
}


VOID static
CleanupDatabase(
    VOID
    )
{
    if( JetTbl != 0 ) {
        JetCloseTable( JetSession, JetTbl );
        JetTbl = 0;
    }

    if( JetSession != 0 ) {
        JetEndSession( JetSession, 0 );
        JetSession = 0;
    }

    if( NULL != hJet ) {
        if( NULL != JetTerm2 ) {
            JetTerm2( JetInstance, JET_bitTermComplete );
        } else {
            JetTerm( JetInstance );
        }
    
        FreeLibrary( hJet ); hJet = NULL;
    }

    JetInstance = 0;
}

DWORD
LoadAndLinkRoutines(
    IN DWORD JetVersion
    )
{
    DWORD Error, i;
    LPTSTR Module;
    LPSTR FuncName;
    
    Module = NULL;
    switch( JetVersion ) {
    case LoadJet2001 : Module = TEXT("esent.dll"); break;
    case LoadJet97 : Module = TEXT("esent.dll"); break;
    case LoadJet500 : Module = TEXT("jet500.dll"); break;
    case LoadJet200 : Module = TEXT("jet.dll"); break;
    default: Module = TEXT("esent.dll"); break;
    }

    hJet = LoadLibrary( Module );
    if( NULL == hJet ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    Tr( "Loading %ws: %ld\n", Module, Error );
    if( NO_ERROR != Error ) return Error;

    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        (*FuncTable[i].FuncPtr) = NULL;
    }
    
    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        if( LoadJet200 != JetVersion ) {
            FuncName = FuncTable[i].FuncName;
        } else {
            if( 0 == FuncTable[i].Index ) {
                (*FuncTable[i].FuncPtr) = NULL;
                continue;
            }

            FuncName = (LPSTR)ULongToPtr(FuncTable[i].Index);
        }

        Error = NO_ERROR;
        
        (*FuncTable[i].FuncPtr) = GetProcAddress(hJet, FuncName);
        
        if( NULL == FuncTable[i].FuncPtr ) {
            Error = GetLastError();

            if( LoadJet97 == JetVersion || LoadJet2001 == JetVersion ) {
                (*FuncTable[i].FuncPtr) = GetProcAddress(
                    hJet, FuncTable[i].AltName );
                if( NULL != FuncTable[i].FuncPtr ) continue;

                Error = GetLastError();
            }
        }

        Tr("GetProcAddr[%ws]: %ld\n", FuncTable[i].FuncNameW, Error );
        if( NO_ERROR != Error ) break;
    }

    //
    // if erred out, cleanup
    //

    if( NO_ERROR != Error ) {
        FreeLibrary( hJet );
        hJet = NULL;
    }

    return Error;
}


DWORD
SetJetParams(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error, JetParam, LogFileSize;
    CHAR Temp[2048];
    LPSTR DbSysFile = "\\system.mdb";
    LPSTR DbBaseName = "j50";

    JetInstance = 0;
    LogFileSize = 1000;

    if( JetVersion == LoadJet2001 ) LogFileSize = 1024;
    
    strcpy(Temp, DbPath);
    if( LoadJet200 == JetVersion ) {
        strcat(Temp, DbSysFile);
        JetParam = JET_paramSysDbPath_OLD;
    } else {
        strcat(Temp, "\\");
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramSystemPath_OLD;
        } else {
            JetParam = JET_paramSystemPath;
        }
    }

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );

    Tr("SetDbParam %ld: %ld\n", JetParam, Error );
    if( NO_ERROR != Error ) return Error;

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramBaseName_OLD;
        } else {
            JetParam = JET_paramBaseName;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, DbBaseName  );

        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 <= JetVersion ) {
            JetParam = JET_paramLogFileSize;
        } else {
            JetParam = JET_paramLogFileSize_OLD;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, LogFileSize, NULL );
        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }
    
    if( LoadJet200 != JetVersion ) {
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0,
            JET_paramCheckFormatWhenOpenFail, 1, NULL );

        JetParam = JET_paramCheckFormatWhenOpenFail;
        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 > JetVersion ) {
            JetParam = JET_paramRecovery_OLD;
        } else {
            JetParam = JET_paramRecovery;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, "on");
        
        Tr("SetDbParam %ld: %ld\n", JetParam, Error );
        if( NO_ERROR != Error ) return Error;
    }
    
    //
    // Note: Ideally, the log files should never exist.  Even
    // if the database is opened in readonly mode, they seem to
    // exist.  Not sure what else can be done
    //
        
    if( LoadJet97 <= JetVersion ) {
        JetParam = JET_paramLogFilePath;
    } else {
        JetParam = JET_paramLogFilePath_OLD;
    }        
    
    strcpy(Temp, DbPath); strcat( Temp, "\\");
    
    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );
    Tr("SetDbParam %ld: %ld\n", JetParam, Error );

    return Error;
}

DWORD
OpenDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    LONG Error;
    DWORD i;
    CHAR FilePath[2048];
    JET_INDEXLIST TmpIdxList;
    
    JetSession = 0;
    JetDb = 0;
    JetTbl = 0;
    
    Error = JetInit( &JetInstance );

    Tr("JetInit: %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    Error = JetBeginSession(
        JetInstance, &JetSession, "admin", "" );

    Tr("JetBeginSession: %ld\n", Error);
    if( Error < 0 ) return Error;

    strcpy(FilePath, DbPath );
    strcat(FilePath, "\\" );

    //
    // fix prefast bug 292432
    //

    if ( strlen( DbName ) < ( 2048 - strlen( FilePath ) ) )
        strcat(FilePath, DbName );

    Error = JetDetachDatabase( JetSession, NULL );

    Tr("JetDetachDatabase:%ld\n", Error );
    if( Error < 0 ) return Error;

    Error = JetAttachDatabase( JetSession, FilePath, JET_bitDbRecoveryOff );

    Tr("JetAttachDatabase:%ld\n", Error );
    if( Error < 0 ) return Error;

    Error = JetOpenDatabase(
        JetSession, FilePath, NULL, &JetDb,
        JET_bitDbSingleExclusive );

    Tr("JetOpenDatabase: %ld\n", Error);
    if( Error < 0 ) return Error;

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"ClientTable",
        NULL, 0, 0,&JetTbl );  

    Tr("JetOpenTable: %ld\n", Error );
    if( Error < 0 ) return Error;

    for( i = 0; i < sizeof(ClientTable)/sizeof(ClientTable[0]); i ++ ) {
        JET_COLUMNDEF ColDef;
        
        Error = JetGetTableColumnInfo(
            JetSession, JetTbl, ClientTable[i].ColName, &ColDef,
            sizeof(ColDef), 0 );

        if(Error && JET_errColumnNotFound != Error ) {
            Tr("JetGetCol: %ld\n", Error );
        }
        
        if( Error < 0 ) {
            if( JET_errColumnNotFound == Error ) {
                ClientTable[i].fPresent = FALSE;
                continue;
            } else {
                return Error;
            }
        }

        if( ColDef.coltyp != ClientTable[i].ColType ) {
            ASSERT( FALSE );
            Error = ERROR_BAD_FORMAT;
            return Error;
        }

        ClientTable[i].ColHandle = ColDef.columnid;
    }

    return NO_ERROR;
}

DWORD
LoadAndInitializeDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error;

    //
    // Attempt to load DLL and retrieve function pointers
    //

    Tr("Loading %ld jet version\n", JetVersion );
    
    Error = LoadAndLinkRoutines( JetVersion );
    if( NO_ERROR != Error ) return Error;

    //
    // set standard jet params
    //
    
    Error = SetJetParams( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        FreeLibrary( hJet ); hJet = NULL;
        return Error;
    }

    //
    // Attempt to open database
    //

    Error = OpenDatabase( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        CleanupDatabase();
        return Error;
    }
    
    return NO_ERROR;
}

DWORD
LoadAndLinkSecurityRoutines(
    OUT FARPROC *pGetInfo,
    OUT FARPROC *pSetInfo
    )
{
    HMODULE hAdvapi32;

    hAdvapi32 = GetModuleHandle(TEXT("ADVAPI32.DLL"));
    if( NULL == hAdvapi32 ) return GetLastError();

    (*pGetInfo) = GetProcAddress(hAdvapi32, "GetNamedSecurityInfoA");
    if( NULL == *pGetInfo ) return GetLastError();

    (*pSetInfo) = GetProcAddress(hAdvapi32, "SetNamedSecurityInfoA");
    if( NULL == *pSetInfo ) return GetLastError();

    return NO_ERROR;
}

DWORD
ConvertPermissionsOnDbFiles(
    VOID
    )
{
    DWORD Error, dwVersion = GetVersion();
    PSECURITY_DESCRIPTOR pSec;
    PACL pAcl;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;
    CHAR FileName[1024];
    FARPROC pGetInfo, pSetInfo;
    CHAR DriversDirPath[MAX_PATH *2 +1];
    DWORD PathLen = sizeof(DriversDirPath)-1;
    
    //
    // Check if version is atleast NT5.
    //
    
    dwVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    if( dwVersion < 5 ) return NO_ERROR;
    
    //
    // First get the requried function pointers..
    //

    Error = LoadAndLinkSecurityRoutines(
        &pGetInfo, &pSetInfo );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory(DriversDirPath, PathLen+1);
    PathLen = ExpandEnvironmentStringsA(
        "%SystemRoot%\\system32\\drivers", DriversDirPath, PathLen );
    if( PathLen == 0 ) {
        Error = GetLastError();
        return Error;
    }
    
    
    pSec = NULL;
    pAcl = NULL;
    Error = (DWORD)pGetInfo(
        DriversDirPath, //"MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DHCPServer",
        SE_FILE_OBJECT, // SE_REGISTRY_KEY
        DACL_SECURITY_INFORMATION, NULL, NULL,
        &pAcl, NULL, &pSec );

    if( NO_ERROR != Error ) return Error;

    Error = (DWORD)pSetInfo(
        DatabasePath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) return Error;

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, DatabaseName);

    Error = (DWORD)pSetInfo(
        FileName, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) goto Cleanup;

    //
    // Now for all files matching "*.log", repeat above operation
    //

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, "*.*");
    
    hSearch = FindFirstFileA( FileName, &FileData );
    if( INVALID_HANDLE_VALUE == hSearch ) {
        Error = GetLastError();
        goto Cleanup;
    }

    do {

        if( 0 != strcmp(FileData.cFileName, ".") &&
            0 != strcmp(FileData.cFileName, "..") ) {
            strcpy(FileName, DatabasePath);
            if( FileName[strlen(FileName)-1] != '\\' ) {
                strcat(FileName, "\\");
            }
            strcat(FileName, FileData.cFileName);
            
            Error = (DWORD)pSetInfo(
                FileName, SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION, NULL, NULL, pAcl, NULL );
            if( NO_ERROR != Error ) break;
        }

        Error = FindNextFileA( hSearch, &FileData );
        if( FALSE != Error ) Error = NO_ERROR;
        else Error = GetLastError();

    } while( NO_ERROR == Error );

    FindClose( hSearch );
    
 Cleanup:

    LocalFree( pSec );

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    if( ERROR_NO_MORE_FILES == Error ) return NO_ERROR;
    return Error;
}

DWORD
ReadString(
    IN HKEY hKey,
    IN LPSTR KeyName,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Error, Size, Type;
    CHAR Str[1024];

    Size = sizeof(Str);
    Error = RegQueryValueExA(
        hKey, KeyName, NULL, &Type, (LPSTR)Str, &Size );
    if( NO_ERROR == Error ) {
        if( 0 == Size || 1 == Size ) Error = ERROR_NOT_FOUND;
        if( Type != REG_SZ && Type != REG_EXPAND_SZ && Type !=
            REG_MULTI_SZ ) Error = ERROR_BAD_FORMAT;
    }

    if( NO_ERROR != Error ) return Error;

    Size = ExpandEnvironmentStringsA( (LPSTR)Str, Buffer, BufSize );
    if( Size == 0 || Size > BufSize ) {
        Error = ERROR_META_EXPANSION_TOO_LONG;
    }

    Tr("Expansion failed for %s\n", KeyName );
    return Error;
}

DWORD
ReadRegistry(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Size, Use351Db, DbType;
    CHAR Str[1024];

    //
    // Open dhcp server parameters key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    Tr("Open Params key failed %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    //
    // Read database details
    //

    do {
        Error = ReadString(
            hKey, "DatabasePath", (LPSTR)DatabasePath,
            sizeof(DatabasePath) );

        if( NO_ERROR != Error ) {
            Tr(" Read DatabasePath failed: %ld\n", Error );
            break;
        }

        Error = ReadString(
            hKey, "DatabaseName", (LPSTR)DatabaseName,
            sizeof(DatabaseName) );

        if( NO_ERROR != Error ) {
            Tr("Read DatabaseName failed %ld\n", Error );
            break;
        }

        strcpy(DhcpEximOemDatabaseName, DatabaseName);
        strcpy(DhcpEximOemDatabasePath, DatabasePath);
        CharToOemA(DhcpEximOemDatabaseName, DhcpEximOemDatabaseName);
        CharToOemA(DhcpEximOemDatabasePath, DhcpEximOemDatabasePath);
        
        if( !IsNT5() && !IsNT4() ) JetVersion  = LoadJet2001;
        else {
            if( IsNT5() ) JetVersion = LoadJet97;
            else JetVersion = LoadJet500;
            
            Size = sizeof(DWORD);
            Error = RegQueryValueExA(
                hKey, "Use351Db", NULL, NULL, (LPBYTE)&Use351Db, &Size );
            if( NO_ERROR == Error ) {
                JetVersion = LoadJet200;
            } else {
                Size = sizeof(DWORD);
                Error = RegQueryValueExA(
                    hKey, "DbType", NULL, NULL, (LPBYTE)&DbType, &Size );
                if( NO_ERROR == Error ) {
                    switch(DbType) {
                    case 3: JetVersion = LoadJet200; break;
                    case 4: JetVersion = LoadJet500; break;
                    }
                }
            }
        }
        
        Error = NO_ERROR;

    } while( 0 );

#if DBG
    DbgPrint("JetVersion: %ld\n", JetVersion);
#endif
    
    RegCloseKey( hKey );
    return Error;
}


DWORD
InitializeDatabase(
    VOID
    )
{
    DWORD Error;

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }
        
        return Error;
    }

    Error = LoadAndInitializeDatabase(
        JetVersion, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if( NO_ERROR != Error ) {
        Tr("LoadAndInitializeDatabase(%ld):%ld\n", JetVersion, Error );
    }
    
    return Error;
}

JET_ERR
GetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }
    
    Error = JetRetrieveColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }

    Tr("JetRetrieveColumn(%ld): %ld\n", Index, Error );
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

JET_ERR
SetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    JET_ERR Error = NO_ERROR;

    if( ClientTable[Index].fPresent == FALSE ) {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    Error = JetSetColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        BufSize, 0, NULL );

    Tr("JetSetColumn(%ld): %ld\n", Index, Error );
    if( Error < 0 ) return Error;

    return NO_ERROR;
}
    

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )

#define ADDRESS_STATE_OFFERED 0
#define ADDRESS_STATE_ACTIVE 1
#define ADDRESS_STATE_DECLINED 2
#define ADDRESS_STATE_DOOM 3
#define ADDRESS_BIT_DELETED  0x80
#define ADDRESS_BIT_UNREGISTERED 0x40
#define ADDRESS_BIT_BOTH_REC 0x20
#define ADDRESS_BIT_CLEANUP 0x10
#define ADDRESS_BITS_MASK 0xF0

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
AddScannedClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD SubnetMaskNetOrder,
    IN LPBYTE HwAddr,
    IN ULONG HwLen,
    IN LPWSTR MachineName,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN BYTE State,
    IN BYTE ClientType
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeDbEntry;
    
    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);
    
    CopyMemory(
        &Buffer[Length], (PVOID)&SubnetMaskNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], HwAddr, HwLen );
    Length += HwLen;
    
    if( NULL == MachineName || 0 == *MachineName ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineName));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    CopyMemory(&Buffer[Length], (PVOID)MachineName, Size );
    Length += Size;
    
    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
    Length += Size;

    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);
    Buffer[Length++] = State;
    Buffer[Length++] = ClientType;

    return AddRecord( Buffer, Length );
}


BOOL
SubnetNotSelected(
    IN ULONG Subnet,
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    if( nSubnets == 0 ) return FALSE;
    while( nSubnets -- ) {
        if( Subnet == *Subnets++ ) return FALSE;
    }
    return TRUE;
}

DWORD static
ScanDatabase(
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    LONG Error;
    DWORD Count;
    
    Error = JetSetCurrentIndex(
        JetSession, JetTbl, NULL );

    Tr("JetSetCurrentIndex: %ld\n", Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, JetTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, JetTbl, JET_MoveNext, 0) ) {
        
        DWORD IpAddress, SubnetMask, Size, HwLen;
        FILETIME Expiration;
        CHAR HwAddress[256];
        WCHAR MachineName[300], MachineInfo[300];
        BYTE Type, State;
        
        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetColumnValue(
            IPADDRESS_INDEX, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            Tr("Invalid Ip size\n");
            continue;
        }
        
        Size = sizeof(SubnetMask);
        Error = GetColumnValue(
            SUBNET_MASK_INDEX, (PVOID)&SubnetMask, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(SubnetMask) ) {
            Tr("Invalid mask size\n");
            continue;
        }

        //
        // Check if the subnet specified matches the specific
        // subnet 
        //

        if( SubnetNotSelected(
            IpAddress&SubnetMask, Subnets, nSubnets ) ) {
            continue;
        }
        
        HwLen = sizeof(HwAddress);
        Error = GetColumnValue(
            HARDWARE_ADDRESS_INDEX, (PVOID)HwAddress, &HwLen );
        if( NO_ERROR != Error ) break;

        Size = sizeof(MachineName);
        Error = GetColumnValue(
            MACHINE_NAME_INDEX, (PVOID)MachineName, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            Tr("Invalid name size\n");
            continue;
        }

        MachineName[Size/2] = L'\0';

        Size = sizeof(MachineInfo);
        Error = GetColumnValue(
            MACHINE_INFO_INDEX, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            Tr("Invalid Info size\n");
            continue;
        }

        MachineInfo[Size/2] = L'\0';

        Size = sizeof(Expiration);
        Error = GetColumnValue(
            LEASE_TERMINATE_INDEX, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            Tr("Invalid expiration\n");
            Error = ERROR_INVALID_DATA;
            break;
        }

        Size = sizeof(Type);
        Error = GetColumnValue(
            CLIENT_TYPE_INDEX, (PVOID)&Type, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            Type = CLIENT_TYPE_DHCP;
        }

        Size = sizeof(State);
        Error = GetColumnValue(
            STATE_INDEX, (PVOID)&State, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            State = ADDRESS_STATE_ACTIVE;
        }

        if( ADDRESS_STATE_OFFERED == State ) {
            continue;
        }
        
        //
        // Try to add the client
        //

        Error = AddScannedClient(
            ByteSwap(IpAddress), ByteSwap(SubnetMask), HwAddress, HwLen,
            MachineName, MachineInfo, *(PULONGLONG)&Expiration,
            State, Type ); 
        
        if( NO_ERROR != Error ) break;
    }

    Tr("Scanned %ld clients\n", Count );
    
    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
}


DWORD
DumpData(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return NO_ERROR;
}

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written, Error = NO_ERROR;

    if( NULL != Buffer ) {
        CopyMemory(&SaveBuf[SaveBufSize], (PVOID)&BufSize, sizeof(DWORD));
        CopyMemory(&SaveBuf[SaveBufSize+sizeof(DWORD)], Buffer, BufSize );
    } else {
        if( 0 == SaveBufSize ) return NO_ERROR;
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize, &Written, NULL ) ) {
            return GetLastError();
        }

        if( Written != SaveBufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    }
    
    if( SaveBufSize <= SAVE_THRESHOLD ) {
        SaveBufSize += BufSize + sizeof(DWORD);
    } else {
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize + BufSize + sizeof(DWORD),
            &Written, NULL )) {
            return GetLastError();
        }

        if( Written != SaveBufSize + BufSize + sizeof(DWORD) ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        SaveBufSize = 0;
    }

    return Error;
}


DWORD
AddRecordNoSize(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written, Error = NO_ERROR;

    if( NULL != Buffer ) {
        CopyMemory(&SaveBuf[SaveBufSize], Buffer, BufSize );
    } else {
        if( 0 == SaveBufSize ) return NO_ERROR;
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize, &Written, NULL ) ) {
            return GetLastError();
        }

        if( Written != SaveBufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    }
    
    if( SaveBufSize <= SAVE_THRESHOLD ) {
        SaveBufSize += BufSize;
    } else {
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize + BufSize,
            &Written, NULL )) {
            return GetLastError();
        }

        if( Written != SaveBufSize + BufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        SaveBufSize = 0;
    }

    return Error;
}


DWORD
StopDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;
    
    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            Tr("OpenSCManager: %ld\n", Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_STOP| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            Tr("OpenService: %ld\n", Error );
            break;
        }

        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                Tr( "QueryServiceStatus: %ld\n", Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_STOPPED ) break;
            if( Status.dwCurrentState != SERVICE_RUNNING &&
                Status.dwCurrentState != SERVICE_PAUSED ) {
                Tr( "Waiting, state = %ld\n", Status.dwCurrentState );

                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }
                if( Status.dwWaitHint > 5000 ) {
                    Status.dwWaitHint = 1000;
                }
                
                Sleep(Status.dwWaitHint);
            } else {
                Error = ControlService(
                    hSvc, SERVICE_CONTROL_STOP, &Status );
                if( FALSE != Error ) Error = NO_ERROR;
                else {
                    Error = GetLastError();
                    Tr("ControlService: %ld\n", Error );
                    break;
                }
            }
        }
    } while( 0 );

    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );
    
    return Error;
}


DWORD
StartDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;
    
    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            Tr("OpenSCManager: %ld\n", Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_START| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            Tr("OpenService: %ld\n", Error );
            break;
        }

        Error = StartService( hSvc, 0, NULL );
        if( FALSE == Error ) Error = GetLastError(); else Error = NO_ERROR;
        if( NO_ERROR != Error ) break;
        
        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                Tr("QueryServiceStatus: %ld\n", Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_RUNNING ) break;
            if( Status.dwCurrentState == SERVICE_START_PENDING ) {
                Tr("Sleeping %ld\n", Status.dwWaitHint );
                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }
                if( Status.dwWaitHint > 5000 ) {
                    Status.dwWaitHint = 5000;
                }
                
                Sleep(Status.dwWaitHint);
            } else {
                Error = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
    } while( 0 );

    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );
    
    return Error;
}


DWORD __stdcall PrintRecord(
    IN PDHCP_RECORD Recx
    )
{
    DWORD i;
    DHCP_RECORD Rec = *Recx;
    
    if( Rec.fMcast ) {
        printf("Mcast Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Mcast.Address ));
        printf("ScopeId: %s\n", IpAddressToString(
            Rec.Info.Mcast.ScopeId ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Mcast.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Mcast.ClientId[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Mcast.State);
        
    } else {
        printf("DHCP Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Address ));
        printf("Mask: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Mask ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Dhcp.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Dhcp.HwAddr[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Dhcp.State);
        printf("\nType = %02X\n", Rec.Info.Dhcp.Type);
        if( Rec.Info.Dhcp.Name ) {
            printf("Name = %ws\n", Rec.Info.Dhcp.Name );
        }

        if( Rec.Info.Dhcp.Info ) {
            printf("Comment = %ws\n", Rec.Info.Dhcp.Info );
        }
    }

    return NO_ERROR;
}

DWORD
StringLen(
    IN WCHAR UNALIGNED *Str
    )
{
    DWORD Size = sizeof(WCHAR);

    if( NULL == Str ) return 0;
    while( *Str ++ != L'\0' ) Size += sizeof(WCHAR);

    return Size;
}

DWORD __stdcall
AddRecordToDatabase(
    IN PDHCP_RECORD Recx
    )
{
    DWORD Index;
    JET_ERR Error;
    DHCP_RECORD Rec = *Recx;
    WCHAR Address[30], HwAddress[300];

    IpAddressToStringW(Rec.Info.Dhcp.Address, Address);
    DhcpHexToString(
        HwAddress, Rec.Info.Dhcp.HwAddr,
        Rec.Info.Dhcp.HwLen );
    
    Error = JetBeginTransaction( JetSession );
    Tr( "JetBeginTransaction: %ld\n", Error );
    if( Error < 0 ) return Error;

    do { 
        Error = JetPrepareUpdate( JetSession, JetTbl, JET_prepInsert );
        if( Error ) Tr( "JetPrepareUpdate: %ld\n", Error );
        if( Error < 0 ) break;

        Index = IPADDRESS_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Address, sizeof(DWORD) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;
        
        Index = SUBNET_MASK_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Mask, sizeof(DWORD) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = HARDWARE_ADDRESS_INDEX;
        Error = SetColumnValue(
            Index, Rec.Info.Dhcp.HwAddr, Rec.Info.Dhcp.HwLen );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = STATE_INDEX;
        Error = SetColumnValue(
            Index, &Rec.Info.Dhcp.State, sizeof(BYTE) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = CLIENT_TYPE_INDEX;
        Error = SetColumnValue(
            Index, &Rec.Info.Dhcp.Type, sizeof(BYTE) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = MACHINE_INFO_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Info, StringLen(Rec.Info.Dhcp.Info) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = MACHINE_NAME_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Name, StringLen(Rec.Info.Dhcp.Name) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = LEASE_TERMINATE_INDEX;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.ExpTime, sizeof(FILETIME) );
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = SERVER_IP_ADDRESS_INDEX;
        Rec.Info.Dhcp.Address = INADDR_LOOPBACK;
        Error = SetColumnValue(
            Index, (LPBYTE)&Rec.Info.Dhcp.Address, sizeof(DWORD));
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Index = SERVER_NAME_INDEX;
        Rec.Info.Dhcp.Name = L"";
        Error = SetColumnValue(
            Index, (LPBYTE)Rec.Info.Dhcp.Name, StringLen(Rec.Info.Dhcp.Name));
        if( Error ) Tr( "SetColumnValue(%ld): %ld\n", Index, Error );
        if( Error < 0 ) break;

        Error = JetUpdate( JetSession, JetTbl, NULL, 0, NULL );
        if( Error ) Tr( "JetUpdate: %ld\n", Error );
        if( Error < 0 ) break;

    } while ( 0 );

    if( Error < 0 ) {
        BOOL fAbort;

        JetRollback( JetSession, 0 );

        fAbort = TRUE;
        DhcpEximErrorDatabaseEntryFailed(
            Address, HwAddress, Error, &fAbort );

        if( fAbort ) return ERROR_CAN_NOT_COMPLETE;
    } else {
        JetCommitTransaction( JetSession, 0 );
    }

    return NO_ERROR;
}

DWORD
ProcessDbEntries(
    IN LPSTR Buffer,
    IN ULONG BufSize,
    IN PULONG Subnets,
    IN ULONG nSubnets,
    IN DHCP_ADD_RECORD_ROUTINE AddRec    
    )
{
    DWORD Size, ThisSize, DbEntry;
    LPSTR Buf;
    DWORD Address, i, Error;
    FILETIME Time;
    DHCP_RECORD Rec;

    Error = NO_ERROR;
    
    while( BufSize > sizeof(DWORD) ) {
        CopyMemory(&ThisSize, Buffer, sizeof(DWORD));
        Buffer += sizeof(DWORD);
        BufSize -= sizeof(DWORD);

        if( ThisSize > BufSize ) return ERROR_INVALID_DATA;
        if( ThisSize == 0 ) continue;
        DbEntry = *Buffer;
        Buf = Buffer+1;
        Buffer += ThisSize;
        BufSize -= ThisSize;

        ZeroMemory( &Rec, sizeof(Rec));

        switch(DbEntry) {
        default :
            return ERROR_INVALID_DATA;
            
        case RecordTypeDbEntry :
            Rec.fMcast = FALSE;
            CopyMemory( &Rec.Info.Dhcp.Address, Buf, sizeof(DWORD));
            Rec.Info.Dhcp.Address = ByteSwap(Rec.Info.Dhcp.Address);
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Dhcp.Mask, Buf, sizeof(DWORD));
            Rec.Info.Dhcp.Mask = ByteSwap(Rec.Info.Dhcp.Mask);
            Buf += sizeof(DWORD);

            Size = Rec.Info.Dhcp.HwLen = *Buf++;
            Rec.Info.Dhcp.HwAddr = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Name = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Dhcp.ExpTime, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Dhcp.State = Buf[0];
            Rec.Info.Dhcp.Type = Buf[1];

            //
            // Add the subnet only if it is selected
            //
            
            if( !SubnetNotSelected(
                Rec.Info.Dhcp.Address & Rec.Info.Dhcp.Mask,
                Subnets, nSubnets ) ) {
                Error = AddRec( &Rec );
            }
            
            break;
        case RecordTypeMcastDbEntry :
            Rec.fMcast = TRUE;
            
            CopyMemory( &Rec.Info.Mcast.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Mcast.ScopeId, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            Size = Rec.Info.Mcast.HwLen = *Buf++;
            Rec.Info.Mcast.ClientId = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Mcast.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Mcast.End, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            CopyMemory(&Rec.Info.Mcast.Start, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Mcast.State = Buf[0];

            Error = AddRec( &Rec );
            break;
        }

        if( NO_ERROR != Error ) return Error;
    }

    return NO_ERROR;
}


DWORD
SaveDatabaseEntriesToFile(
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;
    
    Error = InitializeDatabase();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabase: %ld\n", Error );
        return Error;
    }

    Error = ScanDatabase(Subnets, nSubnets);
    if( NO_ERROR != Error ) {
        Tr("ScanDatabase: %ld\n", Error);
    } else {
        AddRecord( NULL, 0 );
    }

    CleanupDatabase();

    return Error;
}
    
DWORD
SaveFileEntriesToDatabase(
    IN LPBYTE Mem,
    IN ULONG MemSize,
    IN PULONG Subnets,
    IN ULONG nSubnets
    )
{
    DWORD Error;

    Error = InitializeDatabase();
    if( NO_ERROR != Error ) {
        Tr("InitializeDatabase: %ld\n", Error );
        return Error;
    }

    Error = ProcessDbEntries(
        Mem, MemSize, Subnets, nSubnets, AddRecordToDatabase );
    if( NO_ERROR != Error ) {
        Tr("ProcessDbEntries: %ld\n", Error );
    }

    CleanupDatabase();

    return Error;
}

DWORD
InitializeDatabaseParameters(
    VOID
    )
{
    DWORD Error;
    
    //
    // Stop the service
    //
    
    Error = StopDhcpService();
    if( NO_ERROR != Error ) {
        Tr("StopDhcpService: %ld\n", Error );
        return Error;
    }

    //
    // Read the registry and otherwise initialize the database
    // parameters, without actually opening the database.
    //

    Error = ReadRegistry();
    Tr("ReadRegistry: %ld\n", Error );
    if( NO_ERROR != Error ) return Error;

    Error = ConvertPermissionsOnDbFiles();
    Tr("ConvertPermissionsOnDbFiles: %ld\n", Error );
    // ignore error and try best effort

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }

        return Error;
    }

    return NO_ERROR;
}

DWORD
CleanupDatabaseParameters(
    VOID
    )
{
    DWORD Error;
    
    Error = StartDhcpService();
    if( NO_ERROR != Error ) {
        Tr("StartDhcpService: %ld\n", Error );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\readdb.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   readdb.c

Abstract:

   This module reads the configuration from the db into MM data
   structures for whistler+

--*/

#include <precomp.h>

DWORD
DhcpeximReadDatabaseConfiguration(
    IN OUT PM_SERVER *Server
    )
{
    DWORD Error;
    HMODULE hDll;
    FARPROC pDhcpOpenAndReadDatabaseConfig;
    
    hDll = LoadLibrary(TEXT("DHCPSSVC.DLL"));
    if( NULL == hDll ) return GetLastError();


    pDhcpOpenAndReadDatabaseConfig = GetProcAddress(
        hDll, "DhcpOpenAndReadDatabaseConfig" );

    if( NULL == pDhcpOpenAndReadDatabaseConfig ) {
        Error = GetLastError();
    } else {
        Error = (DWORD)pDhcpOpenAndReadDatabaseConfig(
            DhcpEximOemDatabaseName, DhcpEximOemDatabasePath,
            Server );
    }

    FreeLibrary(hDll);

    return Error;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\readreg.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   readreg.c

Abstract:

   This module reads the configuration from the registry into the
   MM data structures for NT4 and W2K.

--*/

#include <precomp.h>


DWORD
DhcpeximReadRegistryConfiguration(
    IN OUT PM_SERVER *Server
    )
{
    REG_HANDLE Hdl;
    DWORD Error;
    LPTSTR Loc;
    //
    // The location in the registry where things are read from is
    // different between whether it is NT4 or W2K.
    //

    if( IsNT4() ) Loc = DHCPEXIM_REG_CFG_LOC4;
    else Loc = DHCPEXIM_REG_CFG_LOC5;

    //
    // Now open the regkey
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, Loc, 0, KEY_ALL_ACCESS, &Hdl.Key );
    if( NO_ERROR != Error ) return Error;

    //
    // Set this as the current server
    //

    DhcpRegSetCurrentServer(&Hdl);

    //
    // Read the configuration
    //

    Error = DhcpRegReadThisServer(Server);

    RegCloseKey(Hdl.Key);
    DhcpRegSetCurrentServer(NULL);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\mmfile.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    mmfile.c

Abstract;

    This file contains code to read/write MM data structures
    from/to internal file format.. code is nearly ripped off of
    server\dbconfig.c

--*/

#include <precomp.h>


typedef struct _DB_CREATE_CONTEXT {
    IN ULONG Index;
    IN PM_SERVER Server;
    
    IN PM_CLASSDEF UserClass, VendorClass;
    IN PM_SUBNET Subnet;
    IN PM_RESERVATION Reservation;

} DB_CREATE_CONTEXT, *PDB_CREATE_CONTEXT;


//
// types of records
//

enum {
    DBCFG_CLASS,
    DBCFG_OPT,
    DBCFG_OPTDEF,
    DBCFG_SCOPE,
    DBCFG_MSCOPE,
    DBCFG_RANGE,
    DBCFG_EXCL,
    DBCFG_RESERVATION,
    DBCFG_END
};

//
// attributes/fields
//

enum {
    DBCFG_INDEX,
    DBCFG_TYPE,
    DBCFG_SUBTYPE,
    DBCFG_FLAGS,
    DBCFG_NAME,
    DBCFG_COMMENT,
    DBCFG_INFO,
    DBCFG_OPTION_ID,
    DBCFG_OPTION_USER,
    DBCFG_OPTION_VENDOR,
    DBCFG_IPADDRESS,
    DBCFG_MASK,
    DBCFG_SUPERSCOPE,
    DBCFG_MSCOPEID,
    DBCFG_MSCOPELANG,
    DBCFG_MSCOPETTL,
    DBCFG_MSCOPE_EXPIRY,
    DBCFG_RANGE_START,
    DBCFG_RANGE_END,
    DBCFG_RANGE_MASK,
    DBCFG_BOOTP_ALLOCATED,
    DBCFG_BOOTP_MAX,
    DBCFG_LAST_COLUMN
};

typedef struct _DBCFG_ENTRY {
    ULONG Bitmasks; // indicates which of the fields below is present
    ULONG Index;
    ULONG Type, SubType, Flags;
    LPWSTR Name, Comment;
    PUCHAR Info;
    ULONG OptionId;
    LPWSTR UserClass, VendorClass;
    ULONG IpAddress, Mask;
    LPWSTR SuperScope;
    ULONG MscopeId;
    LPWSTR MscopeLang;
    ULONG Ttl;
    FILETIME ExpiryTime;
    ULONG RangeStart, RangeEnd, RangeMask;
    ULONG BootpAllocated, BootpMax;

    ULONG InfoSize;
    PVOID Buf;
} DBCFG_ENTRY, *PDBCFG_ENTRY;

typedef struct _DBCFG_MAP {
    DWORD Offset, Size;
} DBCFG_MAP;

DBCFG_MAP EntryMap[] = {
    FIELD_OFFSET(DBCFG_ENTRY,Index), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Type), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SubType), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Flags), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Name), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Comment), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Info), 0,
    FIELD_OFFSET(DBCFG_ENTRY,OptionId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,UserClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,VendorClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,IpAddress), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Mask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SuperScope), 0,
    FIELD_OFFSET(DBCFG_ENTRY,MscopeId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,MscopeLang), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Ttl), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,ExpiryTime), sizeof(FILETIME),
    FIELD_OFFSET(DBCFG_ENTRY,RangeStart), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeEnd), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeMask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpAllocated), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpMax), sizeof(DWORD)
};

DWORD Bitmasks[] = {
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
    0x010000, 0x020000, 0x040000, 0x080000, 0x100000, 0x200000,
    0x400000, 0x80000,
};

DWORD
CreateDbEntry(
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error, Size, i, Offset;
    PVOID Data;
    WORD Buffer[4096];
    
    Offset = 0;
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {
        if( (Entry->Bitmasks & Bitmasks[i]) == 0 ) {
            continue;
        }

        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;

        if( i == DBCFG_INFO ) {
            //
            // Skip info -- it is added at end
            //
            continue;
        } else if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = *(LPWSTR *)Data;

            if( NULL != Data ) Size = sizeof(WCHAR)*(
                1 + wcslen(Data));
        }

        if( 0 == Size ) continue;

        Buffer[Offset++] = (WORD)i;
        Buffer[Offset++] = (WORD)Size;
        memcpy(&Buffer[Offset], Data, Size);
        Offset += (Size + sizeof(WORD) - 1 )/sizeof(WORD);

    }

    //
    // add info at the end.
    //

    i = DBCFG_INFO;
    if( Entry->Bitmasks & Bitmasks[i]) {
        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;
        Data = *(PUCHAR *)Data;
        
        if( NULL != Data ) Size = Entry->InfoSize;
        if( 0 != Size ) {

            Buffer[Offset++] = (WORD)i;
            Buffer[Offset++] = (WORD)Size;
            memcpy(&Buffer[Offset], Data, Size);
            Offset += (Size + sizeof(WORD) - 1 )/sizeof(WORD);
        }
    }

        
    Buffer[Offset++] = DBCFG_LAST_COLUMN+1;
    Buffer[Offset++] = 0;
    
    //
    // Write the record onto file
    //

    return AddRecordNoSize( (LPBYTE)Buffer, Offset*sizeof(WORD));
}

DWORD
CreateClassEntry(
    IN ULONG Index,
    IN PM_CLASSDEF Class
    )
{
    DBCFG_ENTRY Entry;

    //
    // IsVendor, Type, Name, Comment, nBytes, ActualBytes
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_FLAGS] | Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] ); 

    Entry.Index = Index;
    Entry.Type = DBCFG_CLASS;

    Entry.Flags = Class->IsVendor;
    Entry.SubType = Class->Type;
    Entry.Name = Class->Name;
    Entry.Comment = Class->Comment;
    Entry.Info = Class->ActualBytes;
    Entry.InfoSize = Class->nBytes;

    return CreateDbEntry( &Entry );
}

DWORD
CreateOptDefEntry(
    IN ULONG Index,
    IN PM_OPTDEF OptDef,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass
    )
{
    DBCFG_ENTRY Entry;

    //
    // OptId, Type, OptName, OptComment, OptVal, OptValLen,
    // User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_OPTION_ID] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] | Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] );  

    Entry.Index = Index;
    Entry.Type = DBCFG_OPTDEF;

    Entry.OptionId = OptDef->OptId;
    Entry.SubType = OptDef->Type;
    Entry.Name = OptDef->OptName;
    Entry.Comment = OptDef->OptComment;
    Entry.Info = OptDef->OptVal;
    Entry.InfoSize = OptDef->OptValLen;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;
    
    return CreateDbEntry( &Entry );
}

DWORD
CreateOptionEntry(
    IN ULONG Index,
    IN PM_OPTION Option,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass,
    IN PM_SUBNET Subnet,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;
    
    //
    // OptId, Len, Val, User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_OPTION_ID] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] ); 

    if( Reservation ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Reservation->Address;
    } else if( Subnet && Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else if( Subnet && !Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_OPT;

    Entry.OptionId = Option->OptId;
    Entry.Info = Option->Val;
    Entry.InfoSize = Option->Len;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;

    return CreateDbEntry( &Entry );
}
    
DWORD
CreateScopeEntry(
    IN ULONG Index,
    IN PM_SUBNET Subnet,
    IN PM_SSCOPE SScope
    )
{
    DBCFG_ENTRY Entry;

    //
    // State, Policy, ExpiryTime, Name, Description
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_FLAGS] | 
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_MASK] |
            Bitmasks[DBCFG_SUPERSCOPE] );
        Entry.IpAddress = Subnet->Address;
        Entry.Mask = Subnet->Mask;
        if( SScope ) Entry.SuperScope = SScope->Name;
    } else {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_MSCOPEID] | Bitmasks[DBCFG_MSCOPETTL] |
            Bitmasks[DBCFG_MSCOPELANG] |
            Bitmasks[DBCFG_MSCOPE_EXPIRY] );

        Entry.MscopeId = Subnet->MScopeId;
        Entry.Ttl = Subnet->TTL;
        Entry.MscopeLang = Subnet->LangTag;
        Entry.ExpiryTime = *(FILETIME *)&Subnet->ExpiryTime;
    }
    
    Entry.Index = Index;
    Entry.Type = Subnet->fSubnet ? DBCFG_SCOPE : DBCFG_MSCOPE ;

    Entry.SubType = Subnet->State;
    Entry.Flags = Subnet->Policy;
    Entry.Name = Subnet->Name;
    Entry.Comment = Subnet->Description;
    
    return CreateDbEntry( &Entry );    
}
    
DWORD
CreateRangeEntry(
    IN ULONG Index,
    IN PM_RANGE Range,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End, Mask, State, BootpAllocated, MaxBootpAllowed
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] |
        Bitmasks[DBCFG_RANGE_MASK] | Bitmasks[DBCFG_FLAGS] |
        Bitmasks[DBCFG_BOOTP_ALLOCATED] | Bitmasks[DBCFG_BOOTP_MAX] ); 

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_RANGE;

    Entry.RangeStart = Range->Start;
    Entry.RangeEnd = Range->End;
    Entry.RangeMask = Range->Mask;
    Entry.Flags = Range->State;
    Entry.BootpAllocated = Range->BootpAllocated;
    Entry.BootpMax = Range->MaxBootpAllowed;
    
    return CreateDbEntry( &Entry );
}

DWORD
CreateExclEntry(
    IN ULONG Index,
    IN PM_EXCL Excl,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_EXCL;

    Entry.RangeStart = Excl->Start;
    Entry.RangeEnd = Excl->End;
    
    return CreateDbEntry(  &Entry );
}

DWORD
CreateReservationEntry(
    IN ULONG Index,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;

    //
    // Address, Flags, nBytes, ClientUID
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_FLAGS] );

    Entry.Index = Index;
    Entry.Type = DBCFG_RESERVATION;

    Entry.IpAddress = Reservation->Address;
    Entry.Flags = Reservation->Flags;
    Entry.Info = Reservation->ClientUID;
    Entry.InfoSize = Reservation->nBytes;
    
    return CreateDbEntry( &Entry );
}

DWORD
IterateArrayWithDbCreateRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PARRAY Array,
    IN DWORD (*Routine)(
        IN PDB_CREATE_CONTEXT Ctxt,
        IN PVOID ArrayElement
        )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    PVOID Element;
    
    Error = MemArrayInitLoc( Array, &Loc );
    while( NO_ERROR == Error ) {

        Error = MemArrayGetElement(
            Array, &Loc, &Element );
        ASSERT( NO_ERROR == Error && NULL != Element );

        Ctxt->Index ++;

        Error = Routine( Ctxt, Element );
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( Array, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    return Error;
}
    
DWORD
DbCreateClassRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_CLASSDEF Class
    )
{
    return CreateClassEntry( Ctxt->Index, Class );
}

DWORD
DbCreateOptDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTDEF OptDef
    )
{
    return CreateOptDefEntry(
        Ctxt->Index, OptDef, Ctxt->UserClass,
        Ctxt->VendorClass );
}

DWORD
DbCreateOptClassDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTCLASSDEFL_ONE OptClassDef
    )
{
    DWORD Error;

    if( 0 == MemArraySize(&OptClassDef->OptDefList.OptDefArray) ) {
        return NO_ERROR;
    }
    
    if( 0 == OptClassDef->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptClassDef->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptClassDef->OptDefList.OptDefArray,
        DbCreateOptDefRoutine );

    return Error;
}

DWORD
DbCreateOptionRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTION Option
    )
{
    return CreateOptionEntry(
        Ctxt->Index, Option, Ctxt->UserClass,
        Ctxt->VendorClass, Ctxt->Subnet, Ctxt->Reservation );
}

DWORD
DbCreateOptListRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_ONECLASS_OPTLIST OptList
    )
{
    DWORD Error;

    if( 0 == MemArraySize(&OptList->OptList) ) {
        return NO_ERROR;
    }
    
    if( 0 == OptList->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptList->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptList->OptList, DbCreateOptionRoutine );

    return Error;
}

DWORD
DbCreateRangeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RANGE Range
    )
{
    return CreateRangeEntry(
        Ctxt->Index, Range, Ctxt->Subnet );
}

DWORD
DbCreateExclRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_EXCL Excl
    )
{
    return CreateExclEntry(
        Ctxt->Index, Excl, Ctxt->Subnet );
}

DWORD
DbCreateReservationRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RESERVATION Reservation
    )
{
    DWORD Error;
    
    Error = CreateReservationEntry(
        Ctxt->Index, Reservation );
    if( NO_ERROR != Error ) return Error;

    Ctxt->Reservation = Reservation;
    
    //
    // Now add the options for this reservation
    //
    
    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Reservation->Options.Array,
        DbCreateOptListRoutine );
}

DWORD
DbCreateScopeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SUBNET Subnet
    )
{
    PM_SSCOPE SScope = NULL;
    DWORD Error;
    
    if( Subnet->fSubnet && Subnet->SuperScopeId ) {
        DWORD Error;

        Error = MemServerFindSScope(
            Ctxt->Server, Subnet->SuperScopeId, NULL, &SScope );
        if( NO_ERROR != Error ) {
            SScope = NULL;
        }
    }

    Error = CreateScopeEntry(
        Ctxt->Index, Subnet, SScope );
    if( NO_ERROR != Error ) return Error;

    //
    // Initialize the two fields that will get used later 
    //
    
    Ctxt->Subnet = Subnet;
    Ctxt->Reservation = NULL;

    //
    // Now add the options for this scope
    //

    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Now add the ranges and exclusions
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Ranges, DbCreateRangeRoutine );
    if( NO_ERROR != Error ) return Error;

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Exclusions, DbCreateExclRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Finally, add the reservations
    //

    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Reservations,
        DbCreateReservationRoutine );
}


DWORD
DbCreateServerRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error;
    
    Ctxt->Server = Server;

    //
    // First look through the classes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->ClassDefs.ClassDefArray,
        DbCreateClassRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the option defs
    //
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->OptDefs.Array,
        DbCreateOptClassDefRoutine );
    if( NO_ERROR != Error ) return Error;

    // 
    // Next save the options
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the scopes and mcast scopes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Subnets, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;

    return NO_ERROR;
}

DWORD
SaveConfigurationToFile(
    IN PM_SERVER Server
    )
{
    DB_CREATE_CONTEXT Ctxt;
    DWORD Error;
    
    ZeroMemory( &Ctxt, sizeof(Ctxt) );
    
    Error = DbCreateServerRoutine(
        &Ctxt, Server );
    
    if( NO_ERROR != Error ) {
        Tr("DbCreateServerRoutine: %ld\n", Error);
    } else {
        //
        // Sentinel
        //
        DBCFG_ENTRY Entry;
        ZeroMemory( &Entry, sizeof(Entry) );
        Entry.Bitmasks = (
            Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] );            
        Entry.Type = DBCFG_END;

        Error = CreateDbEntry( &Entry );
        if( NO_ERROR != Error ) {
            Tr("Create last entry: %ld\n", Error );
        }
    }

    Tr("SaveConfigurationToFile: %ld\n", Error);
    return Error;
}
    
DWORD
GetColumnFromMemory(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN ULONG Col,
    IN OUT PVOID Buffer,
    IN ULONG BufSize,
    IN OUT ULONG *CopiedSize
    )
{
    WORD *WordMem = (WORD *)*Mem;
    DWORD Size;
    
    if( *MemSize < sizeof(WORD)*2 ) return ERROR_INVALID_DATA;
    if( Col != WordMem[0] ) return JET_wrnColumnNull;

    Size = sizeof(WORD)*(
        2 + (WordMem[1]+sizeof(WORD)-1)/sizeof(WORD)  );
    if( Size > *MemSize ) return ERROR_INVALID_DATA;

    if( WordMem[1] >= BufSize ) *CopiedSize = BufSize;
    else *CopiedSize = WordMem[1];

    memcpy(Buffer, &WordMem[2], *CopiedSize );
    
    (*Mem) += Size;
    (*MemSize) -= Size;

    if( WordMem[1] > BufSize ) return JET_wrnBufferTruncated;
    return NO_ERROR;
}
    
DWORD
ReadDbEntry(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN PDBCFG_ENTRY Entry,
    IN PVOID Buffer,
    IN ULONG BufSize
    )
{
    DWORD Size, CopiedSize, i, OldMemSize, DummySize;
    JET_ERR JetError;
    LPVOID Data, Ptr;
    LPBYTE OldMem;

    OldMemSize = *MemSize;
    OldMem = *Mem;
    
    ZeroMemory( Entry, sizeof(*Entry) );
    ZeroMemory( Buffer, BufSize );
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {

        //
        // Info should be read at the very end to avoid screwing
        // up alignment as info is binary while the rest of the
        // variable size columns are all WCHAR strings
        //
        
        if( i == DBCFG_INFO ) continue;
        
        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;
        Ptr = Data;
        
        if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = Buffer;
            Size = BufSize;
        }

        JetError = GetColumnFromMemory(
            Mem, MemSize, i, Data, Size, &CopiedSize );

        //
        // If the column doesn't exist, continue
        //
       
        if( JET_wrnColumnNull == JetError ) continue;
            
        if( JET_wrnBufferTruncated == JetError &&
            Data == Buffer ) {

            (*Mem) = OldMem;
            (*MemSize) = OldMemSize;
            
            return ERROR_INSUFFICIENT_BUFFER;
        }

        if( NO_ERROR != JetError ) {
            Tr( "GetColumnFromMemory: %ld\n", JetError );
            return JetError;
        }
        
        //
        // If it is any of the variable sized params, then
        // set the ptr to point to the buffer where the data is
        // copied, and also update the buffer.
        //
        
        if( Data == Buffer ) {
            (*(LPVOID *)Ptr) = Buffer;
            BufSize -= CopiedSize;
            Buffer = (PVOID)(((PUCHAR)Buffer) + CopiedSize);
        } else {
            ASSERT( CopiedSize == Size );
        }

        //
        // Indicate that the column was retrieved successfully
        //

        Entry->Bitmasks |= Bitmasks[i];
    }

    //
    // Read the info field
    //

    Size = BufSize;
    JetError = GetColumnFromMemory(
        Mem, MemSize, DBCFG_INFO, Buffer, Size, &CopiedSize );

    GetColumnFromMemory(
        Mem, MemSize, DBCFG_LAST_COLUMN+1,NULL, 0, &DummySize);
    
    if( JET_wrnColumnNull == JetError ) return NO_ERROR;
        
    if( JET_wrnBufferTruncated == JetError ) {
        (*Mem) = OldMem;
        (*MemSize) = OldMemSize;
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if( NO_ERROR != JetError ) {
        Tr("GetColumnFromMemory: %ld\n", JetError );
        return JetError;
    }
    
    Entry->Info = Buffer;
    Entry->InfoSize = CopiedSize;
    Entry->Bitmasks  |= Bitmasks[DBCFG_INFO];

    return NO_ERROR;
}

DWORD
ReadDbEntryEx(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN PDBCFG_ENTRY Entry
    )
{
    PVOID Buffer;
    ULONG BufSize;
    DWORD Error;

    Buffer = NULL;
    BufSize = 512;
    
    do {
        if( NULL != Buffer ) LocalFree(Buffer);

        BufSize *= 2;
        Buffer = LocalAlloc( LPTR, BufSize );
        if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;
        
        Error = ReadDbEntry(Mem, MemSize, Entry, Buffer, BufSize);

    } while( ERROR_INSUFFICIENT_BUFFER == Error );

    if( !(Entry->Bitmasks & Bitmasks[DBCFG_INDEX]) ||
        !(Entry->Bitmasks & Bitmasks[DBCFG_TYPE]) ) {
        if( NO_ERROR == Error ) {
            ASSERT( FALSE );
            Error = ERROR_INTERNAL_ERROR;
        }
    }
    
    if( NO_ERROR != Error ) {
        LocalFree( Buffer );
        return Error;
    }

    Entry->Buf = Buffer;
    return NO_ERROR;
}

DWORD
AddDbEntry(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD UserId, VendorId, SScopeId, Error;
    PM_SUBNET Subnet;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DelOpt;
    PM_RANGE DelRange;
    PM_EXCL DelExcl;
    PM_RESERVATION Reservation;
    PM_CLASSDEF ClassDef;
    PM_SSCOPE SScope;
    
    Subnet = NULL;
    OptClass = NULL;
    Option = DelOpt = NULL;
    Reservation = NULL;
    DelRange = NULL;
    DelExcl = NULL;
    UserId = 0;
    VendorId = 0;
    SScopeId = 0;
    
    if( Entry->UserClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->UserClass, 0, NULL, &ClassDef );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == FALSE );
        UserId = ClassDef->ClassId;
    }

    if( Entry->VendorClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->VendorClass, 0, NULL, &ClassDef );
        ASSERT( NO_ERROR == Error );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == TRUE);
        VendorId = ClassDef->ClassId;
    }

    if( Entry->SuperScope ) {
        Error = MemServerFindSScope(
            Server, INVALID_SSCOPE_ID, Entry->SuperScope, &SScope );
        if( NO_ERROR == Error ) {
            SScopeId = SScope->SScopeId;
        } else if( ERROR_FILE_NOT_FOUND != Error ) {
            return Error;
        } else {
            Error = MemSScopeInit( &SScope, 0, Entry->SuperScope );
            if( NO_ERROR != Error ) return Error;

            Error = MemServerAddSScope( Server, SScope );
            if( NO_ERROR != Error ) {
                MemSScopeCleanup( SScope );
                return Error;
            }
            SScopeId = SScope->SScopeId;
        }
    }
    
    switch( Entry->Type ) {
    case DBCFG_CLASS :
        //
        // Flags = IsVendor, SubType =Type, Info = ActualBytes
        //
        
        return MemServerAddClassDef(
            Server, MemNewClassId(), Entry->Flags, Entry->Name,
            Entry->Comment, Entry->InfoSize, Entry->Info );

    case DBCFG_OPTDEF :
        //
        // OptionId = OptId, SubType = Type, Info = OptVal
        //
        
        return MemServerAddOptDef(
            Server, UserId, VendorId, Entry->OptionId,
            Entry->Name, Entry->Comment, Entry->SubType,
            Entry->Info, Entry->InfoSize );

    case DBCFG_OPT:
        //
        // OptionId = OptId, Info = Val
        // If this is a reservation option, address is set to
        // reserved client address. If this is a subnet option,
        // address is set to subnet address. If this is a mscope
        // option, scopeid is set to mscope scopeid.  If it is a
        // global option, neither address not scopeid is set.
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_MSCOPEID] ) {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
            if( NO_ERROR != Error ) return Error;

            OptClass = &Subnet->Options;
        } else if( 0 == (Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] )) {
            OptClass = &Server->Options;
        } else {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                &Reservation );
            ASSERT( NO_ERROR == Error );
            if( NO_ERROR != Error ) return Error;

            if( NULL != Reservation ) {
                OptClass = &Reservation->Options;
            } else OptClass = &Subnet->Options;
        }
        
        Error = MemOptInit(
            &Option, Entry->OptionId, Entry->InfoSize,
            Entry->Info );
        if( NO_ERROR != Error ) return Error;
            
        Error = MemOptClassAddOption(
            OptClass,  Option, UserId, VendorId, &DelOpt );

        ASSERT( NULL == DelOpt );
        if( NO_ERROR != Error ) MemFree( Option );

        return Error;

    case DBCFG_SCOPE:
        //
        // IpAddress = Address, Mask = Mask, SubType = State,
        // Flags = Policy
        //

        Error = MemSubnetInit(
            &Subnet, Entry->IpAddress, Entry->Mask,
            Entry->SubType, SScopeId, Entry->Name, Entry->Comment );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddSubnet( Server, Subnet );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;
            
    case DBCFG_MSCOPE :
        //
        // MscopeId = MScopeId, Ttl = TTL, MscopeLang = LangTag,
        // ExpiryTime = ExpiryTime, SubType = State, Flags =
        // Policy..
        //

        Error = MemMScopeInit(
            &Subnet, Entry->MscopeId, Entry->SubType,
            Entry->Flags, (BYTE)Entry->Ttl, Entry->Name,
            Entry->Comment, Entry->MscopeLang,
            *(DATE_TIME *)&Entry->ExpiryTime );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddMScope( Server, Subnet );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        Subnet->ServerPtr = Server;
        return Error;

    case DBCFG_RANGE :

        //
        // RangeStart = Start, RangeEnd = End, RangeMask = Mask,
        // Flags = State, BootpAllocated, BootpMax =
        // MaxBootpAllowed... Also, IpAddress or MscopeId
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddRange(
            Subnet, Entry->RangeStart, Entry->RangeEnd,
            Entry->Flags, Entry->BootpAllocated, Entry->BootpMax,
            &DelRange );
        
    case DBCFG_EXCL:
        //
        // RangeStart = Start, RangeEnd = End
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddExcl(
            Subnet, Entry->RangeStart, Entry->RangeEnd, &DelExcl
            );

    case DBCFG_RESERVATION :
        //
        // IpAddress = Address, Flags = Flags, Info = ClientUID
        //

        Error = MemServerGetAddressInfo(
            Server, Entry->IpAddress, &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) return Error;

        return MemReserveAdd(
            &Subnet->Reservations, Entry->IpAddress,
            Entry->Flags, Entry->Info, Entry->InfoSize );
    default:

        return ERROR_INTERNAL_ERROR;
    }        
}

DWORD
AddDbEntryEx(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error;
    LPSTR EntryTypes[] = {
        "Class", "Opt", "OptDef", "Scope", "Mscope", "Range",
        "Excl", "Reservation", "Unknown1", "Unknown2", "Unknown3"
    };
    
    Error = AddDbEntry( Server, Entry );
    if( NO_ERROR != Error ) {
        Tr("Error adding entry[%ld] %s: 0x%lx\n",
                   Entry->Index, EntryTypes[Entry->Type], Error );
    }

    return Error;
}

DWORD
ReadDbEntries(
    IN OUT LPBYTE *Mem,
    IN OUT ULONG *MemSize,
    IN OUT PM_SERVER *Server
    )
{
    DBCFG_ENTRY Entry;
    DWORD Error = NO_ERROR;

    Error = MemServerInit(
        Server, -1, 0, 0, NULL, NULL );
    if( NO_ERROR != Error ) return Error;
    
    while( Error == NO_ERROR ) {

        Error = ReadDbEntryEx( Mem, MemSize, &Entry );
        if( NO_ERROR != Error ) {
            Tr( "ReadDbEntryEx: %ld\n", Error );
            break;
        }

        if( Entry.Type == DBCFG_END ) {
            Error = NO_ERROR;
            break;
        }

        Error = AddDbEntryEx( *Server, &Entry );
        if( NULL != Entry.Buf ) LocalFree( Entry.Buf );
        if( NO_ERROR != Error ) {
            Tr( "AddDbEntryEx: %ld\n", Error );
            return Error;
        }
    }

    Tr("ReadDbEntries: %ld\n", Error);

    if( NO_ERROR != Error ) {
        MemServerFree( *Server );
        (*Server) = NULL;
    }
    
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\writedb.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   writedb.c

Abstract:

   This module writes the configuration onto the db for whistler+

--*/

#include <precomp.h>

DWORD
DhcpeximWriteDatabaseConfiguration(
    IN PM_SERVER Server
    )
{
    DWORD Error;
    HMODULE hDll;
    FARPROC pDhcpOpenAndWriteDatabaseConfig;
    
    hDll = LoadLibrary(TEXT("DHCPSSVC.DLL"));
    if( NULL == hDll ) return GetLastError();


    pDhcpOpenAndWriteDatabaseConfig = GetProcAddress(
        hDll, "DhcpOpenAndWriteDatabaseConfig" );

    if( NULL == pDhcpOpenAndWriteDatabaseConfig ) {
        Error = GetLastError();
    } else {
        Error = (DWORD)pDhcpOpenAndWriteDatabaseConfig(
            DhcpEximOemDatabaseName, DhcpEximOemDatabasePath,
            Server );
    }

    FreeLibrary(hDll);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\test.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

   test.c

Abstract:

    helps test the import and export functionality.
    usage: test import filename  { ALL or <scope_address> <scope_address> .. }
           test export filename  { ditto }

--*/

#include <precomp.h>

void _cdecl main(void) {
    LPWSTR CmdLine, *Args;
    ULONG nArgs, Error;
    
    CmdLine = GetCommandLineW();
    Args = CommandLineToArgvW(CmdLine, &nArgs );
    if( NULL == Args ) {
        printf("Error : %ld\n", GetLastError());
        return;
    }

    if( nArgs < 3 ) {
        Error = ERROR_BAD_ARGUMENTS;
    } else if( _wcsicmp(Args[1], L"export" ) == 0 ) {
        Error = CmdLineDoExport( &Args[2], nArgs - 2 );
    } else if( _wcsicmp(Args[1], L"Import" ) == 0 ) {
        Error = CmdLineDoImport( &Args[2], nArgs - 2 );
    } else {
        Error = ERROR_BAD_ARGUMENTS;
    }

    if( ERROR_BAD_ARGUMENTS == Error ) {
        printf("Usage: \n\t%s import filename <scope-list>"
               "\n\t%s export filename <scope-list>\n"
               "\t\t where <scope-list> is \"all\" or "
               "a list of subnet-addresses\n", Args[0], Args[0] );
    } else if( NO_ERROR != Error ) {
        printf("Failed error: %ld\n", Error );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\select.c ===
/*++

Copyright (c) 2000 Microsoft corporation

Module Name:

    select.c

Abstract:

    Implements the partial selection of configuration from the
    full MM configuration data structures.

--*/

#include <precomp.h>

typedef struct _SELECT_CTXT {
    ULONG *Subnets;
    ULONG nSubnets;
    
} SELECT_CTXT, *PSELECT_CTXT;

DWORD
DeleteScopesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PSELECT_CTXT SelectCtxt = Ctxt->ExtraCtxt;
    ULONG *Subnets, nSubnets, i;
    
    Subnets = SelectCtxt->Subnets;
    nSubnets = SelectCtxt->nSubnets;

    for( i = 0; i < nSubnets; i ++ ) {
        if( Subnets[i] == Ctxt->Scope->Address ) break;
    }

    if( i == nSubnets ) {
        //
        // Returning KEY_DELETED will cause the IterateScopes
        // routine to delete this scope out.
        //
        return ERROR_KEY_DELETED;
    }
    
    return NO_ERROR;
}

DWORD
OptionCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PM_CLASSDEF ClassDef = Ctxt->ExtraCtxt;

    //
    // If the class specified in ExtraCtxt matches the current
    // option's user or vendor class, then bummer -- fail
    // immediately with error code ERROR_DEVICE_IN_USE to
    // indicate that this class is needed and can't be deleted
    //
    
    if( Ctxt->UserClass == ClassDef ||
        Ctxt->VendorClass ==  ClassDef ) {
        return ERROR_DEVICE_IN_USE;
    }

    return NO_ERROR;
}

DWORD
OptionCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    PMM_ITERATE_CTXT OtherCtxt = Ctxt->ExtraCtxt;

    //
    // If the current option matches the optdef parameters, then
    // we need to save the optdef ..
    //
    
    if( Ctxt->VendorClass == OtherCtxt->VendorClass &&
        Ctxt->Option->OptId == OtherCtxt->OptDef->OptId ) {
        return ERROR_DEVICE_IN_USE;
    }

    return NO_ERROR;
}

DWORD
ScopeReservationsCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Ctxt->ExtraCtxt,
        OptionCheckForClass );
}

DWORD
ScopeReservationsCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    return IterateReservationOptions(
        Ctxt->Server, Ctxt->Res, Ctxt->ExtraCtxt,
        OptionCheckForOptDef );
}

DWORD
ScopeCheckForClass(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Iterate over each option in the current scope to see if
    // any of them use the same class
    //

    Error = IterateScopeOptions(
        Ctxt->Scope, Ctxt->ExtraCtxt, OptionCheckForClass );
    if( NO_ERROR != Error ) return Error;

    //
    // Otherwise iterate for each reservation to see if this is a
    // problem. 
    //

    return IterateScopeReservations(
        Ctxt->Scope, Ctxt->ExtraCtxt,
        ScopeReservationsCheckForClass );
}

DWORD
ScopeCheckForOptDef(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Iterate over each option in the current scope to see if
    // any of them use the same class
    //

    Error = IterateScopeOptions(
        Ctxt->Scope, Ctxt->ExtraCtxt, OptionCheckForOptDef );
    if( NO_ERROR != Error ) return Error;

    //
    // Otherwise iterate for each reservation to see if this is a
    // problem. 
    //

    return IterateScopeReservations(
        Ctxt->Scope, Ctxt->ExtraCtxt,
        ScopeReservationsCheckForOptDef );
}

DWORD
DeleteClassesCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Go through each subnet to see if there is any option
    // configured to use this class
    //

    Error = IterateScopes(
        Ctxt->Server, Ctxt->ClassDef, ScopeCheckForClass );

    //
    // If the specified class is in use, then don't
    // delete. Otherwise delete.
    //
    
    if( ERROR_DEVICE_IN_USE == Error ) return NO_ERROR;
    if (NO_ERROR == Error ) return ERROR_KEY_DELETED;
    return Error;
}

DWORD
DeleteOptDefsCallback(
    IN OUT PMM_ITERATE_CTXT Ctxt
    )
{
    DWORD Error;
    
    //
    // Go through each subnet to see if there is any option
    // configured to use this optdef
    //

    Error = IterateScopes(
        Ctxt->Server, Ctxt, ScopeCheckForOptDef );

    //
    // If the specified class is in use, then don't
    // delete. Otherwise delete.
    //
    
    if( ERROR_DEVICE_IN_USE == Error ) return NO_ERROR;
    if (NO_ERROR == Error ) return ERROR_KEY_DELETED;
    return Error;
    
}

DWORD
SelectConfiguration(
    IN OUT PM_SERVER Server,
    IN ULONG *Subnets,
    IN ULONG nSubnets
    )
{
    SELECT_CTXT Ctxt = { Subnets, nSubnets };
    DWORD Error;
    ULONG i;
    WCHAR SubnetAddress[30];
    
    //
    // No selection needed if nSubnets == 0, as this indicates
    // that the whole configuration is to be used
    //

    Tr("SelectConfiguration entered\n");
    
    if( nSubnets == 0 ) return NO_ERROR;

    //
    // First go through all scopes and check if all the required
    // scopes are present
    //

    for( i = 0; i < nSubnets ; i ++ ) {
        PM_SUBNET Subnet;
        
        Error = MemServerGetUAddressInfo(
            Server, Subnets[i], &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) {
            Tr("Cant find subnet 0x%lx: %ld\n", Subnets[i], Error );
            if( ERROR_FILE_NOT_FOUND == Error ) {
                IpAddressToStringW(Subnets[i], (LPWSTR)SubnetAddress);
                DhcpEximErrorSubnetNotFound( (LPWSTR)SubnetAddress );
                    
                Error = ERROR_CAN_NOT_COMPLETE;
            }
            
            return Error;
        }
    }
    
    //
    // Global options are never needed.. so we can delete them.
    //

    MemOptClassFree( &Server->Options );
    
    //
    // Go through all the subnets and delete ones that are
    // not selected
    //

    Error = IterateScopes(
        Server, &Ctxt, DeleteScopesCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateScopes: %ld\n", Error );
        return Error;
    }


    //
    // Now check if all the option-defs are needed
    //

    Error = IterateOptDefs(
        Server, NULL, DeleteOptDefsCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateOptDefs: %ld\n", Error );
        return Error;
    }

    //
    // Now check if all the user classes are needed
    //

    Error = IterateClasses(
        Server, NULL, DeleteClassesCallback );

    if( NO_ERROR != Error ) {
        Tr("IterateClasses: %ld\n", Error );
        return Error;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\exim\writereg.c ===
/*++

Copyright (C) 1999 Microsoft Coporation

Module Name:

   writereg.c

Abstract:

   This module write the configuration to the registry from the
   MM data structures for NT4 and W2K.

--*/

#include <precomp.h>


DWORD
SaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This routine backs up or restores the dhcp configuration between
    the registry and the file.

Arguments:
    hKey -- key to backup or restore onto
    ConfigFileName -- file name to use to backup onto or restore from.
        This must be full path name.
    fRestore -- TRUE ==> do a restore from file; FALSE => do backup to
        file.

Return Values:
    Win32 errors...

--*/
{
    DWORD Error;
    BOOL fError;
    BOOLEAN WasEnable;
    NTSTATUS NtStatus;
    HANDLE ImpersonationToken;

    if( FALSE == fRestore ) {
        //
        // If backing up, delete the old file.
        //
        fError = DeleteFile( ConfigFileName );
        if(FALSE == fError ) {
            Error = GetLastError();
            if( ERROR_FILE_NOT_FOUND != Error &&
                ERROR_PATH_NOT_FOUND != Error ) {

                ASSERT(FALSE);
                return Error;
            }
        }
    }

    //
    // Impersonate to self.
    //
    NtStatus = RtlImpersonateSelf( SecurityImpersonation );
    if( !NT_SUCCESS(NtStatus) ) {

        DbgPrint("Impersonation failed: 0x%lx\n", NtStatus);
        Error = RtlNtStatusToDosError( NtStatus );
        return Error;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {
        
        DbgPrint("RtlAdjustPrivilege: 0x%lx\n", NtStatus );
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_RESTORE_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {

        DbgPrint( "RtlAdjustPrivilege: 0x%lx\n", NtStatus );
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    //
    // Backup or restore appropriately.
    //
    
    if( FALSE == fRestore ) {
        Error = RegSaveKey( hKey, ConfigFileName, NULL );
    } else {
        Error = RegRestoreKey( hKey, ConfigFileName, 0 );
    }

    if( ERROR_SUCCESS != Error ) {
        DbgPrint("Backup/Restore: 0x%lx\n", Error);
    }
    
    //
    // revert impersonation.
    //

Cleanup:
    
    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken)
        );
    if( !NT_SUCCESS(NtStatus ) ) {
        DbgPrint("NtSetInfo: 0x%lx\n", NtStatus);
        if( ERROR_SUCCESS == Error ) {
            Error = RtlNtStatusToDosError(NtStatus);
        }
    }
    
    return Error;
}

DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    This function deletes the specified key and all its subkeys.

Arguments:

    ParentKeyHandle : handle of the parent key.

    KeyName : name of the key to be deleted.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error, NumSubKeys;
    HKEY KeyHandle = NULL;


    //
    // open key.
    //

    Error = RegOpenKeyEx(
        ParentKeyHandle,
        KeyName,
        0,
        KEY_ALL_ACCESS,
        &KeyHandle );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // query key info.
    //

    Error = RegQueryInfoKey(
        KeyHandle, NULL, NULL, NULL, &NumSubKeys, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // delete all its subkeys if they exist.
    //

    if( NumSubKeys != 0 ) {
        DWORD Index;
        DWORD KeyLength;
        WCHAR KeyBuffer[100];
        FILETIME KeyLastWrite;

        for(Index = 0;  Index < NumSubKeys ; Index++ ) {

            //
            // read next subkey name.
            //
            // Note : specify '0' as index each time, since  deleting
            // first element causes the next element as first
            // element after delete.
            //

            KeyLength = sizeof(KeyBuffer)/sizeof(WCHAR);
            Error = RegEnumKeyEx(
                KeyHandle,
                0,                  // index.
                KeyBuffer,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // delete this key recursively.
            //

            Error = DhcpRegDeleteKey(
                KeyHandle,
                KeyBuffer );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }
        }
    }

    //
    // close the key before delete.
    //

    RegCloseKey( KeyHandle );
    KeyHandle = NULL;

    //
    // at last delete this key.
    //

    Error = RegDeleteKey( ParentKeyHandle, KeyName );

Cleanup:

    if( KeyHandle == NULL ) {
        RegCloseKey( KeyHandle );
    }

    return( Error );
}

DWORD
DhcpRegDeleteKeyByName(
    IN LPWSTR Parent,
    IN LPWSTR SubKey
    )
{
    HKEY hKey;
    ULONG Error;
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        Parent,
        0,
        KEY_ALL_ACCESS,
        &hKey
        );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegDeleteKey(hKey, SubKey);
    RegCloseKey(hKey);

    return Error;
}

DWORD
DhcpeximWriteRegistryConfiguration(
    IN PM_SERVER Server
    )
{
    REG_HANDLE Hdl;
    DWORD Error, Disp;
    LPTSTR Loc, TempLoc;
    HKEY hKey;
    
    //
    // The location in the registry where things are read from is
    // different between whether it is NT4 or W2K.
    //

    if( IsNT4() ) Loc = DHCPEXIM_REG_CFG_LOC4;
    else Loc = DHCPEXIM_REG_CFG_LOC5;

    TempLoc = TEXT("Software\\Microsoft\\DhcpExim");
    
    //
    // Now open the regkey
    //

    Error = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE, TempLoc, 0, TEXT("DHCPCLASS"),
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &Hdl.Key, &Disp );
    if( NO_ERROR != Error ) return Error;

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, Loc, 0, KEY_ALL_ACCESS, &hKey );
    if( NO_ERROR != Error ) {
        RegCloseKey( Hdl.Key );
        return Error;
    }
    
    //
    // Set this as the current server
    //

    DhcpRegSetCurrentServer(&Hdl);

    //
    // Save the configuration temporarily 
    //

    Error = DhcpRegServerSave(Server);

    //
    // Now attempt to save the temporary key to disk and restore
    // it back where it should really be and delete temp key
    //

    if( NO_ERROR == Error ) {
    
        Error = SaveOrRestoreConfigToFile(
            Hdl.Key, L"Dhcpexim.reg", FALSE );

        if( NO_ERROR == Error ) {

            Error = SaveOrRestoreConfigToFile(
                hKey, L"Dhcpexim.reg", TRUE );

            if( NO_ERROR == Error ) {
                RegCloseKey(Hdl.Key);
                Hdl.Key = NULL;
                DhcpRegDeleteKeyByName(
                    L"Software\\Microsoft", L"DhcpExim" );
            }
        }
    }

    if( NULL != Hdl.Key ) RegCloseKey(Hdl.Key);
    RegCloseKey(hKey);
    DhcpRegSetCurrentServer(NULL);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\array.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements a growable array
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for conventions on reading/writing code that i use
//================================================================================
#include    <mm.h>
#define     FILE                   "mm\\array.h"

#ifdef      IMPORTS
MemAlloc
MemFree
AssertRet
Require
#endif      IMPORTS


//BeginExport(typedef)
typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;
//EndExport(typedef)

//BeginExport(typedef)
typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;
//EndExport(typedef)

//BeginExport(inline)
DWORD _inline
MemArrayInit(                                     // initialize the STRUCTURE
    OUT     PARRAY                 Array          // input structure pre-allocated
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayCleanup(                                  // freeup the memory if any, allocated in this module
    IN OUT  PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    if( Array->Ptrs) MemFree(Array->Ptrs);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArraySize(
    IN      PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    return Array->nElements;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayInitLoc(                                  // Initialize an array location
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    (*Location) = 0;
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
BOOL _inline
MemArrayValidLoc(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location
)
{
    AssertRet(Array && Location, FALSE);

    return ( *Location < Array->nElements );
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayNextLoc(                                  // move one step forward
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( (*Location) + 1  >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) ++;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayPrevLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    if( ((LONG)(*Location)) - 1 < 0 ) return ERROR_FILE_NOT_FOUND;
    (*Location) --;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayLastLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) = Array->nElements -1;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArrayGetElement(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    OUT     LPVOID                *Element
) {
    AssertRet(Array && Location && Element, ERROR_INVALID_PARAMETER);
    (*Element) = Array->Ptrs[*Location];
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD _inline
MemArraySetElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER );
    Array->Ptrs[*Location] = Element;
    return ERROR_SUCCESS;
}
//EndExport(inline)
const
DWORD       MinAllocUnit =         4;
const
DWORD       MinFreeUnit =          4;             // Must be a power of two

LPVOID _inline
MemAllocLpvoid(
    DWORD                          nLpvoids
) {
    return MemAlloc(sizeof(LPVOID)*nLpvoids);
}

//BeginExport(function)
DWORD
MemArrayAddElement(
    IN OUT  PARRAY                 Array,
    IN      LPVOID                 Element
) //EndExport(function)
{
    LPVOID                         Ptrs;

    AssertRet(Array, ERROR_INVALID_PARAMETER );
    if( Array->nElements < Array->nAllocated ) {
        Array->Ptrs[Array->nElements ++ ] = Element;
        return ERROR_SUCCESS;
    }

    if( 0 == Array->nAllocated ) {
        Array->Ptrs = MemAllocLpvoid(MinAllocUnit);
        if( NULL == Array->Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;
        Array->nAllocated = MinAllocUnit;
        Array->nElements = 1;
        Array->Ptrs[0] = Element;
        return ERROR_SUCCESS;
    }

    Ptrs = MemAllocLpvoid(MinAllocUnit+Array->nAllocated);
    if( NULL == Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*Array->nAllocated);
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->Ptrs[Array->nElements++] = Element;
    Array->nAllocated += MinAllocUnit;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemArrayInsElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) //EndExport(function)
{
    LPVOID                        *Ptrs;

    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);

    if( (*Location) == Array->nElements )
        return MemArrayAddElement(Array,Element);

    if( Array->nElements < Array->nAllocated ) {
        memmove(&Array->Ptrs[1+*Location], &Array->Ptrs[*Location], sizeof(LPVOID)*(Array->nElements - *Location));
        Array->Ptrs[*Location] = Element;
        Array->nElements++;
        return ERROR_SUCCESS;
    }

    Require(Array->nElements);

    Ptrs = MemAllocLpvoid(MinAllocUnit + Array->nAllocated);
    if( NULL == Ptrs ) return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*(*Location) );
    Ptrs[*Location] = Element;
    memcpy(&Ptrs[1+*Location], &Array->Ptrs[*Location], sizeof(LPVOID)*(Array->nElements - *Location));
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->nElements ++;
    Array->nAllocated += MinAllocUnit;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemArrayDelElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                *Element
) //EndExport(function)
{
    LPVOID                        *Ptrs;

    AssertRet(Array && Location && Array->nElements && Element, ERROR_INVALID_PARAMETER);

    (*Element) = Array->Ptrs[*Location];

    Array->nElements--;

    if( 0 == Array->nElements ) {
        Require(0 == *Location);
        return MemArrayCleanup(Array);
    }

    if( Array->nElements % MinFreeUnit || NULL == (Ptrs = MemAllocLpvoid(Array->nElements))) {
        memcpy(&Array->Ptrs[*Location], &Array->Ptrs[1+*Location], sizeof(LPVOID)*(Array->nElements - (*Location)));
        return ERROR_SUCCESS;
    }

    Require(Ptrs);
    memcpy(Ptrs, Array->Ptrs, sizeof(LPVOID)*(*Location));
    memcpy(&Ptrs[*Location], &Array->Ptrs[1+*Location], sizeof(LPVOID)*(Array->nElements - (*Location)));
    MemFree(Array->Ptrs);
    Array->Ptrs = Ptrs;
    Array->nAllocated = Array->nElements;

    return ERROR_SUCCESS;
}

//BeginExport(inline)
DWORD        _inline
MemArrayAdjustLocation(                           // reset location to "next" after a delete
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Location && Array, ERROR_INVALID_PARAMETER);

    if( *Location >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemArrayRotateCyclical(                           // rotate forward/right cyclical
    IN      PARRAY                 Array
) {
    LPVOID                         FirstPtr;

    AssertRet(Array, ERROR_INVALID_PARAMETER);

    if( Array->nElements < 2 ) return ERROR_SUCCESS;
    FirstPtr = Array->Ptrs[0];
    memcpy(Array->Ptrs, &Array->Ptrs[1], sizeof(Array->Ptrs[0])* (Array->nElements -1));
    Array->Ptrs[Array->nElements -1] = FirstPtr;

    return ERROR_SUCCESS;
}
//EndExport(inline)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\idl\imports.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Madan Appiah (madana)     10-Sep-1993
    Manny Weiser (mannyw)     11-Aug-1992

Revision History:


--*/


#include <windef.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <mdhcsapi.h>

#ifdef MIDL_PASS
#define RPC_BOOL DWORD
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\address.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#define     IS_SWITCHED(X)         (((X) & 0x00000002)?TRUE:FALSE)
#define     IS_DISABLED(X)         (((X) & 0x00000001)?TRUE:FALSE)
#define     SWITCHED(X)            ((X) |= 0x00000002 )
#define     DISABLED(X)            ((X) |= 0x00000001 )


BOOL
MemSubnetRequestAddress(
    IN OUT  PM_SUBNET              Subnet,        // the subnet to start the search in
    IN      DWORD                  Address,       // init. addr: 0 => search in SuperScope, SubnetAddr = try subnet first
    IN      BOOL                   fAcquire,      // also acquire the address? or just test for availability?
    IN      BOOL                   fBootp,        // acquire BOOTP address?
    OUT     DWORD                 *RetAddress,    // OPTIONAL if Address is not 0 or SubnetAddr -- address obtained
    OUT     PM_SUBNET             *RetSubnet      // OPTIONAL if Address is not 0 - which subnet is the address from
) ;


DWORD
MemServerReleaseAddress(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
) ;


DWORD       _inline
MemSubnetReleaseAddress(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
    ) 
{
    DWORD                          Error;
    DWORD                          OldState;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Reservation;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet && Subnet->Address != (Address & Subnet->Mask ) )
        return MemServerReleaseAddress(
            Subnet->ServerPtr,
            Address,
            fBootp
        );

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Require(Range);

    if( NULL != Reservation ) {
        Require(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP: MM_FLAG_ALLOW_DHCP))) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = MemBitSetOrClear(
        Range->BitMask,
        Address - Range->Start,
        FALSE /* Release */,
        &OldState
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( OldState == FALSE ) return ERROR_FILE_NOT_FOUND;

    InterlockedIncrement(&Range->DirtyOps);
    if( fBootp && 0 != Range->BootpAllocated ) {
        InterlockedDecrement( &Range->BootpAllocated );
    }

    return ERROR_SUCCESS;
}


BOOL // TRUE ==> allowed, FALSE ==> not allowed
MemSubnetCheckBootpDhcp(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp,
    IN      BOOL                   fCheckSuperScope
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\address.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for managing (multicast) scopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>

//BeginExport(constants)
#define     IS_SWITCHED(X)         (((X) & 0x00000002)?TRUE:FALSE)
#define     IS_DISABLED(X)         (((X) & 0x00000001)?TRUE:FALSE)
#define     SWITCHED(X)            ((X) |= 0x00000002 )
#define     DISABLED(X)            ((X) |= 0x00000001 )
//EndExport(constants)

//================================================================================
// subnet only address api's
//================================================================================
BOOL
MemSubnetGetThisAddress(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fAcquire,      // if available, also acquire?
    IN      BOOL                   fBootp
) 
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          OldState;
    PM_RANGE                       Range;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        NULL,
        NULL
    );

    if( ERROR_SUCCESS != Error ) return FALSE;
    Require(Range);
    if( fBootp ) {
        if( 0 == (Range->State & MM_FLAG_ALLOW_BOOTP))
            return FALSE;

        if( fAcquire &&
            Range->BootpAllocated >= Range->MaxBootpAllowed ) {
            return FALSE;
        }
    } else {
        if( 0 == (Range->State & MM_FLAG_ALLOW_DHCP) ) 
            return FALSE;
    }

    Offset = Address - Range->Start;

    if( !fAcquire ) return MemBitIsSet(Range->BitMask, Offset);

    Error = MemBitSetOrClear(
        Range->BitMask,
        Offset,
        TRUE /* Acquire */,
        &OldState
    );
    if( ERROR_SUCCESS != Error ) { Require(FALSE); return FALSE; }

    if( FALSE == OldState ) {
        InterlockedIncrement(&Range->DirtyOps);
        if( fBootp ) InterlockedIncrement( &Range->BootpAllocated );
    }
    return !OldState;
}

BOOL
MemSubnetGetAnAddress(
    IN      PM_SUBNET              Subnet,
    OUT     LPDWORD                AltAddress,
    IN      DWORD                  fAcquire,
    IN      BOOL                   fBootp
) {
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          Policy;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       Range;

    if( IS_DISABLED(Subnet->State)) return FALSE;

    Policy = Subnet->Policy;
    if( AddressPolicyNone == Policy )
        Policy = ((PM_SERVER)(Subnet->ServerPtr))->Policy;

    if( AddressPolicyRoundRobin == Policy ) {
        Error = MemArrayRotateCyclical(&Subnet->Ranges);
        Require(ERROR_SUCCESS == Error);
    }

    for ( Error = MemArrayInitLoc(&Subnet->Ranges, &Loc);
          ERROR_FILE_NOT_FOUND != Error ;
          Error = MemArrayNextLoc(&Subnet->Ranges, &Loc) ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Ranges, &Loc, (LPVOID *)&Range);
        Require(ERROR_SUCCESS == Error && Range);
        
        if( fBootp ) {
            if( 0 == (Range->State & MM_FLAG_ALLOW_BOOTP) ) {
                continue;
            }
            if( fAcquire && 
                Range->BootpAllocated >= Range->MaxBootpAllowed ) {
                continue;
            }
        } else {
            if( 0 == (Range->State & MM_FLAG_ALLOW_DHCP ) ) {
                continue;
            }
        }

        Error = MemBitGetSomeClearedBit(
            Range->BitMask,
            &Offset,
            fAcquire,
            Range->Start,
            &Subnet->Exclusions
        );
        if( ERROR_SUCCESS == Error ) {
            *AltAddress = Range->Start + Offset;
            InterlockedIncrement(&Range->DirtyOps);
            if( fBootp && fAcquire ) {
                InterlockedIncrement(&Range->BootpAllocated);
            }
            return TRUE;
        }
    }

    return FALSE;
}

//================================================================================
// per-server scans
//================================================================================

BOOL
MemServerGetAddress(                              // acquire address or check for availability
    IN OUT  PM_SERVER              Server,
    IN      PM_SUBNET              Subnet,        // search all subnets in superscope with this, except for this subnet alone
    IN      BOOL                   fAcquire,      // is this just a lookup or a full blown request?
    IN      BOOL                   fBootp,        // is this a DHCP address or BOOTP address?
    OUT     DWORD                 *AltAddress,    // the address that looks available
    OUT     PM_SUBNET             *AltSubnet      // got it from this subnet
) {
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          Size;
    DWORD                          Policy;
    BOOL                           Obtained;
    PM_SUBNET                      NextSubnet;
    PM_SSCOPE                      SScope;

    AssertRet(Server && Subnet && AltAddress && AltSubnet, ERROR_INVALID_PARAMETER );
    AssertRet(NULL == AltAddress || NULL != AltSubnet, ERROR_INVALID_PARAMETER);
    AssertRet(Subnet->fSubnet, FALSE );

    SScopeId = Subnet->SuperScopeId;
    if( 0 == SScopeId ) {
        if( AltSubnet ) *AltSubnet = Subnet;
        return MemSubnetGetAnAddress(Subnet,AltAddress, fAcquire, fBootp);
    }

    Error = MemServerFindSScope(Server, SScopeId, NULL, &SScope);
    if( ERROR_FILE_NOT_FOUND == Error ) {         // the superscope quietly died ?
        Subnet->SuperScopeId = 0;                 // no superscope at all
        if( AltSubnet ) *AltSubnet = Subnet;
        return MemSubnetGetAnAddress(Subnet, AltAddress, fAcquire, fBootp);
    }
    Require(ERROR_SUCCESS == Error);

    Policy = SScope->Policy;
    if( AddressPolicyNone == Policy )
        Policy = Server->Policy;

    if( AddressPolicyRoundRobin != Policy )
        Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
    else Error = MemArrayNextLoc(&Server->Subnets, &Server->Loc);

    Size = MemArraySize(&Server->Subnets);

    while( Size -- ) {
        if(ERROR_FILE_NOT_FOUND == Error) {       // wraparound
            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
        }
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Server->Loc, &NextSubnet);
        Require(ERROR_SUCCESS == Error && NextSubnet);

        if( NextSubnet->SuperScopeId == SScopeId ) {
            Obtained = MemSubnetGetAnAddress(NextSubnet,AltAddress,fAcquire, fBootp);
            if( Obtained ) {
                *AltSubnet = NextSubnet;
                return TRUE;
            }
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Server->Loc);
    }

    return FALSE;
}

//BeginExport(function)
BOOL
MemSubnetRequestAddress(
    IN OUT  PM_SUBNET              Subnet,        // the subnet to start the search in
    IN      DWORD                  Address,       // init. addr: 0 => search in SuperScope, SubnetAddr = try subnet first
    IN      BOOL                   fAcquire,      // also acquire the address? or just test for availability?
    IN      BOOL                   fBootp,        // acquire BOOTP address?
    OUT     DWORD                 *RetAddress,    // OPTIONAL if Address is not 0 or SubnetAddr -- address obtained
    OUT     PM_SUBNET             *RetSubnet      // OPTIONAL if Address is not 0 - which subnet is the address from
) //EndExport(function)
{
    BOOL                           Obtained;

    AssertRet( Subnet , ERROR_INVALID_PARAMETER);
    if( 0 == Address ) AssertRet(RetAddress && RetSubnet, ERROR_INVALID_PARAMETER);
    if( Subnet->fSubnet && Subnet->Address == Address ) AssertRet(RetAddress, ERROR_INVALID_PARAMETER);

    if( (!Subnet->fSubnet || Subnet->Address != Address ) && 0 != Address ) {
        Obtained = MemSubnetGetThisAddress(   // for the specific address requested
            Subnet,
            Address,
            fAcquire,
            fBootp
        );
        if( Obtained ) {
            if( RetAddress ) *RetAddress = Address;
            if( RetSubnet ) *RetSubnet = Subnet;
            return TRUE;
        }
    }
    if( !RetAddress ) return FALSE;

    if (0) {
        if( 0 == Address && Subnet->fSubnet ) Obtained = FALSE;      // this case, dont try subnet first.. go thru sscope list instead
        else
            Obtained = MemSubnetGetAnAddress(     // try for some address in this subnet?
                Subnet,
                RetAddress,
                fAcquire,
                fBootp
            );
    }

    Obtained = MemSubnetGetAnAddress(         // try for some address in this subnet?
        Subnet,
        RetAddress,
        fAcquire,
        fBootp
    );

    if( Obtained && RetSubnet ) *RetSubnet = Subnet;
    if( Obtained ) return TRUE;

    // if the address was requested from a particular subnet OR
    // multicast address requested then return FALSE now.
    if( !Subnet->fSubnet || Subnet->Address == Address ) return FALSE;

    return MemServerGetAddress(
        Subnet->ServerPtr,
        Subnet,
        fAcquire,
        fBootp,
        RetAddress,
        RetSubnet
    );
}

DWORD       _inline
MemSubnetReleaseAddress(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
);

//BeginExport(function)
DWORD
MemServerReleaseAddress(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    AssertRet(Server, ERROR_INVALID_PARAMETER);

    Error = MemServerGetAddressInfo(
        Server,
        Address,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Require(Subnet);
    if( Subnet->fSubnet ) {
        Require((Subnet->Mask & Address) == Subnet->Address);
    }

    return MemSubnetReleaseAddress(Subnet, Address, fBootp);
}


//BeginExport(_inline)
DWORD       _inline
MemSubnetReleaseAddress(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      BOOL                   fBootp
    ) 
{
    DWORD                          Error;
    DWORD                          OldState;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Reservation;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet && Subnet->Address != (Address & Subnet->Mask ) )
        return MemServerReleaseAddress(
            Subnet->ServerPtr,
            Address,
            fBootp
        );

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error ) return Error;
    Require(Range);

    if( NULL != Reservation ) {
        Require(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP: MM_FLAG_ALLOW_DHCP))) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = MemBitSetOrClear(
        Range->BitMask,
        Address - Range->Start,
        FALSE /* Release */,
        &OldState
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( OldState == FALSE ) return ERROR_FILE_NOT_FOUND;

    InterlockedIncrement(&Range->DirtyOps);
    if( fBootp && 0 != Range->BootpAllocated ) {
        InterlockedDecrement( &Range->BootpAllocated );
    }

    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(function)
BOOL // TRUE ==> allowed, FALSE ==> not allowed
MemSubnetCheckBootpDhcp(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp,
    IN      BOOL                   fCheckSuperScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    ULONG                          Error;
    PM_RANGE                       Range;
    PM_SUBNET                      ThisSubnet;
    PARRAY                         Array;

    if( Subnet->fSubnet && !IS_DISABLED( Subnet->State ) ) {
        for( Error = MemArrayInitLoc( &Subnet->Ranges, &Loc );
             ERROR_SUCCESS == Error ;
             Error = MemArrayNextLoc( &Subnet->Ranges, &Loc ) ) {
            Error = MemArrayGetElement( &Subnet->Ranges, &Loc , &Range );
            Require( ERROR_SUCCESS == Error );
            
            if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
                continue;
            }
            
            return TRUE;
        }
    }

    if( FALSE == fCheckSuperScope || 0 == Subnet->SuperScopeId ) {
        return FALSE;
    }

    Array = &((PM_SERVER) (Subnet->ServerPtr))->Subnets;
    for( Error = MemArrayInitLoc( Array, &Loc );
         ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( Array, &Loc ) ) {
        Error = MemArrayGetElement( Array, &Loc, &ThisSubnet );
        Require( ERROR_SUCCESS == Error );

        if( ThisSubnet == Subnet ) continue;
        if( ThisSubnet->SuperScopeId != Subnet->SuperScopeId ) continue;
        if( FALSE == MemSubnetCheckBootpDhcp( ThisSubnet, fBootp, FALSE ) )
            continue;

        return TRUE;
    }
    
    return FALSE;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\bitmask.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_EXCL {
    DWORD                          Start;
    DWORD                          End;
} M_EXCL, *PM_EXCL, *LPM_EXCL;


#define MM_FLAG_ALLOW_DHCP         0x1
#define MM_FLAG_ALLOW_BOOTP        0x2


typedef struct _M_BITMASK1 {
    DWORD                          Size;          // Size in # of bits
    DWORD                          AllocSize;     // Size in BYTES allocated
    DWORD                          nSet;          // nBits set
    LPBYTE                         Mask;          // BUBBUG making this DWORD would make things faster..
    DWORD                          Offset;        // used by Bit2 type..
    ULONG                          nDirtyOps;     // # of unsaved operations done on this bitmask?
} M_BITMASK1, *PM_BITMASK1, *LPM_BITMASK1;


typedef struct _M_BITMASK2 {
    DWORD                          Size;
    ARRAY_LOCATION                 Loc;           // where to start off to look for a bit
    ARRAY                          Array;         // Array of bitmask 1 types
} M_BITMASK2, *PM_BITMASK2, *LPM_BITMASK2;

typedef     M_BITMASK2             M_BITMASK;
typedef     PM_BITMASK2            PM_BITMASK;
typedef     LPM_BITMASK2           LPM_BITMASK;


#define     MAX_BIT1SIZE           (512*4)


DWORD
MemBitInit(
    OUT     PM_BITMASK            *Bits,
    IN      DWORD                  nBits
) ;


DWORD
MemBitCleanup(
    IN OUT  PM_BITMASK             Bits
) ;


DWORD
MemBitSetOrClearAll(
    IN OUT  PM_BITMASK             Bits,
    IN      BOOL                   fSet
) ;


DWORD
MemBitSetOrClear(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    IN      LPBOOL                 fOldState
) ;


BOOL
MemBitIsSet(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location
) ;


DWORD
MemBitGetSize(
    IN      PM_BITMASK             Bits
) ;


DWORD
MemBitGetSetBitsInRange(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  dwFrom,
    IN      DWORD                  dwTo
) ;


DWORD
MemBitGetSetBitsSize(
    IN      PM_BITMASK             Bits
) ;


DWORD
MemBitAddOrDelBits(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  nBitsToAddOrDelete,
    IN      BOOL                   fAdd,
    IN      BOOL                   fEnd
) ;


DWORD
MemBitGetSomeClearedBit(
    IN OUT  PM_BITMASK             Bits,
    OUT     DWORD                 *Offset,
    IN      BOOL                   fAcquire,     // Acquire or just lookup?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
) ;


DWORD
MemBitConvertToCluster(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  StartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\bitmask.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for bitmasks
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>

//BeginExport(typedef)
typedef struct _M_EXCL {
    DWORD                          Start;
    DWORD                          End;
} M_EXCL, *PM_EXCL, *LPM_EXCL;
//EndExport(typedef)

//BeginExport(defines)
#define MM_FLAG_ALLOW_DHCP         0x1
#define MM_FLAG_ALLOW_BOOTP        0x2
//EndExport(defines)

//BeginExport(typedef)
typedef struct _M_BITMASK1 {
    DWORD                          Size;          // Size in # of bits
    DWORD                          AllocSize;     // Size in BYTES allocated
    DWORD                          nSet;          // nBits set
    LPBYTE                         Mask;          //  making this DWORD would make things faster..
    DWORD                          Offset;        // used by Bit2 type..
    ULONG                          nDirtyOps;     // # of unsaved operations done on this bitmask?
} M_BITMASK1, *PM_BITMASK1, *LPM_BITMASK1;
//EndExport(typedef)

DWORD       _inline
MemBit1Init(
    OUT     PM_BITMASK1           *Bits,
    IN      DWORD                  nBits
)
{
    PM_BITMASK1                    Bits1;

    Bits1 = MemAlloc(sizeof(*Bits1));
    if( NULL == Bits1 ) return ERROR_NOT_ENOUGH_MEMORY;

    (*Bits) = Bits1;
    Bits1->Size = nBits;
    Bits1->AllocSize = (nBits + 8)/8;
    Bits1->nSet = 0;
    Bits1->Mask = NULL;
    Bits1->nDirtyOps = 0;
    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1Cleanup(
    IN      PM_BITMASK1            Bits
)
{
    if( Bits->Mask ) MemFree(Bits->Mask);
    MemFree(Bits);

    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1SetAll(
    IN OUT  PM_BITMASK1            Bits
)
{
    Bits->nDirtyOps ++;
    Bits->nSet = Bits->Size;
    if( Bits->Mask ) {
        MemFree(Bits->Mask);
        Bits->Mask = NULL;
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit1ClearAll(
    IN OUT  PM_BITMASK1            Bits
)
{
    Bits->nDirtyOps ++;
    Bits->nSet = 0;
    if( Bits->Mask ) {
        MemFree(Bits->Mask);
        Bits->Mask = NULL;
    }
    return ERROR_SUCCESS;
}


// Be careful - the same set of masks are used in regread.c -- don't change this!!!!

static      DWORD                  Masks[] = {
    0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80
};

DWORD
MemBit1SetOrClear(
    IN OUT  PM_BITMASK1            Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    OUT     LPBOOL                 fOldState      // OPTIONAL
)
{
    BOOL                           OldState;

    Bits->nDirtyOps ++;

    if( 0 == Bits->nSet ) {
        // No existing bit, so it must all be clear..

        if( fOldState ) *fOldState = FALSE;
        if( !fSet ) return ERROR_SUCCESS;

        // need to set the bit.. if we are setting only bit, don't bother..
        Require(Bits->Size != 0);

        if( 1 == Bits->Size ) {
            Bits->nSet = 1;
            return ERROR_SUCCESS;
        }

        // we have to allocate stuff to set the bit..
        Bits->Mask = MemAlloc(Bits->AllocSize);
        if( NULL == Bits->Mask ) return ERROR_NOT_ENOUGH_MEMORY;
        memset(Bits->Mask, 0, Bits->AllocSize);
    }

    if( Bits->Size == Bits->nSet ) {
        // All existing bits set, so prior state is "Set"

        if( fOldState ) *fOldState = TRUE;
        if( fSet ) return ERROR_SUCCESS;

        // check to see if we got only one bit to clear, then we don't have to do nothing
        if( 1 == Bits->Size ) {
            Bits->nSet = 0;
            return ERROR_SUCCESS;
        }

        // we have to allocate memory for teh bitmap..
        Bits->Mask = MemAlloc(Bits->AllocSize);
        if( NULL == Bits->Mask ) return ERROR_NOT_ENOUGH_MEMORY;
        memset(Bits->Mask, 0xFF, Bits->AllocSize);
    }

    OldState = (Bits->Mask[Location/8] & Masks[Location%8])?TRUE:FALSE;
    if( fOldState ) *fOldState = OldState;

    if( fSet == OldState ) return ERROR_SUCCESS;
    if( fSet ) {
        if( Bits->Size == ++Bits->nSet ) {
            if(Bits->Mask ) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[Location/8] |= Masks[Location%8];
        }
    } else {
        if( 0 == --Bits->nSet ) {
            if(Bits->Mask) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[Location/8] &=  ~Masks[Location%8];
        }
    }

    return ERROR_SUCCESS;
}

BOOL        _inline
MemBit1IsSet(
    IN      PM_BITMASK1            Bits,
    IN      DWORD                  Location
)
{
    if( 0 == Bits->nSet ) return FALSE;
    if( Bits->Size == Bits->nSet ) return TRUE;

    if( Bits->Mask[Location/8] & Masks[Location%8] )
        return TRUE;
    return FALSE;
}

DWORD       _inline
IsExcluded(
    IN OUT  DWORD                *Try,            // this is updated to 1 less than end of excl
    IN      DWORD                 StartAddress,
    IN      PARRAY                Exclusions
)
{
    DWORD                         Error;
    ARRAY_LOCATION                Loc;
    PM_EXCL                       Excl;

    if( NULL == Exclusions ) return FALSE;

    Error = MemArrayInitLoc(Exclusions, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Error = MemArrayGetElement(Exclusions, &Loc, &Excl);
        Error = MemArrayNextLoc(Exclusions, &Loc);
        if( Excl->Start > StartAddress + *Try ) continue;
        if( Excl->End < StartAddress + *Try ) continue;

        *Try = Excl->End-StartAddress;
        return TRUE;
    }

    return FALSE;
}

DWORD       _inline
MemBit1GetSomeClearedBit(
    IN OUT  PM_BITMASK1           Bits,
    OUT     LPDWORD               Offset,
    IN      BOOL                  fAcquire,       // is this address to be taken or just looked up?
    IN      DWORD                 StartAddress,
    IN      PARRAY                Exclusions
)
{
    DWORD                         i;
    DWORD                         j;
    DWORD                         Error;
    DWORD                         OldState;

    if( Bits->Size == Bits->nSet ) return ERROR_FILE_NOT_FOUND;
    if( 0 == Bits->nSet ) {                       // got some memory..
        for( i = 0; i < Bits->Size ; i ++ ) {
            if( !IsExcluded(&i, StartAddress, Exclusions) )
                break;
        }

        if( i >= Bits->Size ) {                   // we got no space at all? how odd?
            return ERROR_FILE_NOT_FOUND;
        }

        // bit "i" is free for us!!

        Error = MemBit1SetOrClear(Bits, i, TRUE, &OldState);
        Require( ERROR_SUCCESS == Error );

        if( ERROR_SUCCESS == Error ) *Offset = i;
        return Error;
    }

    for( i = 0 ; i < Bits->AllocSize ; i ++ ) {
        if( 0xFF != Bits->Mask[i] ) {             // if "i" is part of an exclusion, skip to end of exclusion
            for( j = 0; j < 8; j ++ ) {
                if( !(Bits->Mask[i] & Masks[j] )){// available in the bitmask, but need to check if excluded..
                    DWORD  x;
                    x = 8*i + j;                  // this is the actual bit position in the bitmask
                    if( !IsExcluded(&x, StartAddress, Exclusions) )
                        break;                    // this address is not excluded either..
                    j = x % 8;                    // choose the right offset after exclusion
                    if( x > 8*i + 7 ) { j = 8; i = -1 + x/8; break; }
                }
            }
            if( j < 8 ) break;                    // found a good location..
        }
    }

    if( i >= Bits->AllocSize ) return ERROR_FILE_NOT_FOUND;
    Require( (j <= 7) );

    *Offset = j + 8*i;
    if( *Offset >= Bits->Size ) return ERROR_FILE_NOT_FOUND;

    if( fAcquire ) {
        if( Bits->Size == ++ Bits->nSet ) {
            if( Bits->Mask ) MemFree(Bits->Mask);
            Bits->Mask = NULL;
        } else {
            Bits->Mask[i] |= Masks[j];
        }
        Bits->nDirtyOps ++;
    }
    return ERROR_SUCCESS;
}


DWORD       _inline
MemBit1GetSize(
    IN      PM_BITMASK1           Bits
)
{
    return Bits->Size;
}

DWORD		_inline
MemBit1GetSetBitsInRange(
    IN  PM_BITMASK1 Bits,
    IN  DWORD       dwFrom,
    IN  DWORD       dwTo
)
{
    DWORD i;
    DWORD nOnes;

    // simple case: no bits set to 1
    if (Bits->nSet == 0)
        return 0;

    // simple case: all bits set to 1
    if (Bits->nSet == Bits->Size)
        return dwTo - dwFrom + 1;
	
    // we have both types of bits; scan all the bytes concerned
    for (nOnes = 0, i = dwFrom>>3; i <= dwTo>>3; i++)
    {
        BYTE    Byte, Dup;

        // dwFrom and dwTo should both be in the interval [0 .. Bits->Size-1]
        Byte = Bits->Mask[i];

        if (i == (dwFrom>>3))
        {
            //                                  dwFrom
            //                                     v
            // if first byte in the range: ...|...[.....|...
            // mask Byte with                  000 11111
            Byte &= ~((1 << (dwFrom & 0x00000007)) - 1);
        }
        if (i == (dwTo>>3))
        {
            // if last byte in the range:  ...|......]..|...
            // mask Byte with                  111111 00
            //                                      ^
            //                                     dwTo
            Byte &= (1 << ((dwTo & 0x00000007) + 1)) - 1;
        }
        // now compute the nb. of '1' bits from the Byte.
        // log(8) algorithm

        Byte = (Byte & 0x55) + ((Byte & 0xAA) >> 1);
        Byte = (Byte & 0x33) + ((Byte & 0xCC) >> 2);
        Byte = (Byte & 0x0f) + ((Byte & 0xF0) >> 4);

        nOnes += Byte;
    }

    return nOnes;
}

DWORD       _inline
MemBit1GetSetBitsSize(                            // n Set bits in this bitmask ?
    IN      PM_BITMASK1           Bits
)
{
    return Bits->nSet;
}

DWORD        _inline
MemBit1DelBits(
    IN OUT  PM_BITMASK1           Bits,
    IN      DWORD                 nBits,          // new size after contraction
    IN      BOOL                  fEnd            // delete from end or start ?
)
{
    LPBYTE                        Mask;
    DWORD                         Diff;
    DWORD                         i;
    LONG                          j;

    Bits->nDirtyOps ++;

    Diff = Bits->Size - nBits;
    if( Bits->Size == Bits->nSet ) {
        Bits->Size = Bits->nSet = nBits;
        Bits->AllocSize = (nBits + 8)/8;
        Require(Bits->Mask == NULL);
        return ERROR_SUCCESS;
    }

    if( 0 == Bits->nSet ) {
        Bits->AllocSize = (nBits+8)/8;
        Bits->Size = nBits;
        Require(Bits->Mask == NULL);
        return ERROR_SUCCESS;
    }

    Bits->Size = nBits;
    if( fEnd && Bits->AllocSize == (nBits+8)/8) {
        return ERROR_SUCCESS;
    }

    Mask = MemAlloc((nBits+8)/8);
    if( NULL == Mask ) {
        Require(FALSE);                           // what to do? lets live with it
        Mask = Bits->Mask;                        // just use existing mask
    } else {
        memset(Mask, 0, (nBits+8)/8);
    }

    Bits->AllocSize = (nBits +8)/8;

    if( fEnd ) {
        memmove(Mask, Bits->Mask, Bits->AllocSize);
        if(Mask != Bits->Mask ) MemFree(Bits->Mask);
        Bits->Mask = Mask;
        Bits->nSet = 0;
        for( i = 0; i < Bits->Size ; i ++ )       // re-calculate # of set bits
            if( Mask[i/8] & Masks[i%8] ) Bits->nSet ++;
        return ERROR_SUCCESS;
    }

    Bits->nSet = 0;
    for( j = Bits->Size-1; j >=0 ; j -- ) {
        if( Bits->Mask[(j+Diff)/8] & Masks[(j+Diff)%8] ) {
            Mask[j/8] |= Masks[j%8];
            Bits->nSet ++;
        } else Mask[j/8] &= ~Masks[j%8];
    }

    return ERROR_SUCCESS;
}

//BeginExport(typedef)
typedef struct _M_BITMASK2 {
    DWORD                          Size;
    ARRAY_LOCATION                 Loc;           // where to start off to look for a bit
    ARRAY                          Array;         // Array of bitmask 1 types
} M_BITMASK2, *PM_BITMASK2, *LPM_BITMASK2;

typedef     M_BITMASK2             M_BITMASK;
typedef     PM_BITMASK2            PM_BITMASK;
typedef     LPM_BITMASK2           LPM_BITMASK;
//EndExport(typedef)

//BeginExport(defines)
#define     MAX_BIT1SIZE           (512*4)
//EndExport(defines)

const       DWORD                  MaxBit1Size = MAX_BIT1SIZE;

DWORD       _inline
MemBit2Init(
    OUT     PM_BITMASK2           *Bits,
    IN      DWORD                  nBits
)
{
    PM_BITMASK2                    Bits2;
    DWORD                          nBit1;
    DWORD                          i;
    DWORD                          Error;
    DWORD                          RetError;
    DWORD                          Offset;

    Bits2 = MemAlloc(sizeof(*Bits2));
    if( NULL == Bits2 ) return ERROR_NOT_ENOUGH_MEMORY;
    Error = MemArrayInit(&Bits2->Array);
    Require(ERROR_SUCCESS == Error);

    *Bits = Bits2;
    Bits2->Size = nBits;

    nBit1 = nBits/MaxBit1Size;
    for( i = 0; i < nBit1; i ++ ) {
        PM_BITMASK1                Bit1;
        Error = MemBit1Init(&Bit1, MaxBit1Size);
        if( ERROR_SUCCESS != Error) break;

        Error = MemArrayAddElement(&Bits2->Array,Bit1);
        if( ERROR_SUCCESS != Error) break;

        Bit1->Offset = i * MaxBit1Size;
    }

    if( ERROR_SUCCESS == Error ) {
        PM_BITMASK1                Bit1;

        MemArrayInitLoc(&Bits2->Array, &((*Bits)->Loc));

        if( 0 == (nBits % MaxBit1Size) ) return ERROR_SUCCESS;

        Error = MemBit1Init(&Bit1, nBits % MaxBit1Size);
        if( ERROR_SUCCESS == Error) {
            Error = MemArrayAddElement(&Bits2->Array, Bit1);
            Bit1->Offset = i * MaxBit1Size;
        }

        if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    }

    // error, cleanup
    *Bits = NULL;

    RetError = Error;
    {
        ARRAY_LOCATION             Loc;
        PM_BITMASK1                Bit1;

        Error = MemArrayInitLoc(&Bits2->Array, &Loc);
        while(ERROR_FILE_NOT_FOUND != Error) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(
                &Bits2->Array,
                &Loc,
                (LPVOID*)&Bit1
            );
            Require(ERROR_SUCCESS == Error);

            Error = MemBit1Cleanup(Bit1);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayNextLoc(&Bits2->Array, &Loc);
        }

        Error = MemArrayCleanup(&Bits2->Array);
        Require(ERROR_SUCCESS == Error);

        MemFree(Bits2);
    }

    return RetError;
}

DWORD      _inline
MemBit2Cleanup(
    IN     PM_BITMASK2             Bits
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_BITMASK1                    Bit1;

    Require(Bits->Size);
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error && Bit1);

        Error = MemBit1Cleanup(Bit1);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    Error = MemArrayCleanup(&Bits->Array);
    Require(ERROR_SUCCESS == Error);

    MemFree(Bits);
    return ERROR_SUCCESS;
}

DWORD       _inline
MemBit2SetOrClearAll(
    IN OUT  PM_BITMASK2            Bits,
    IN      BOOL                   fSet
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error && NULL != Bit1);

        if( fSet ) {
            Error = MemBit1SetAll(Bit1);
        } else {
            Error = MemBit1ClearAll(Bit1);
        }
        Require(ERROR_SUCCESS == Error);
    }

    return ERROR_SUCCESS;
}

DWORD
MemBit2SetOrClear(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    OUT     LPBOOL                 fOldState
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SkippedSize;
    DWORD                          Size;
    DWORD                          Start, Mid, End;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Bits->Size > Location, ERROR_INVALID_PARAMETER);

#if 0
    SkippedSize = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error);

        Size = MemBit1GetSize(Bit1);

        if( SkippedSize + Size > Location ) {     // got the bitmask1 struct we need
            return MemBit1SetOrClear(
                Bit1,
                Location - SkippedSize,
                fSet,
                fOldState
            );
        }

        SkippedSize += Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    Require(FALSE);                               // should have found the right Bit1  before?
    return Error;
#else

    //: need to expose a binary search in the array.h module....
    Start = 0;
    End = MemArraySize(&Bits->Array);
    while( Start + 1 < End) {
        Mid = (Start + End)/2;

        Bit1 = Bits->Array.Ptrs[Mid];
        if( Bit1->Offset <= Location ) {
            Start = Mid;
        } else {
            End = Mid;
        }
    }
    Require( Start <= MemArraySize(&Bits->Array));
    Bit1 = Bits->Array.Ptrs[Start];
    Require(Bit1->Offset <= Location && Location <= Bit1->Offset + Bit1->Size);

    return( MemBit1SetOrClear(
            Bit1,
            Location - Bit1 -> Offset,
            fSet,
            fOldState ) );
#endif
}

BOOL        _inline
MemBit2IsSet(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  Location
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SkippedSize;
    DWORD                          Size;
    DWORD                          Start, Mid, End;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Bits->Size > Location, ERROR_INVALID_PARAMETER);

#if 0
    SkippedSize = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error);

        Size = MemBit1GetSize(Bit1);

        if( SkippedSize + Size > Location ) {     // got the bitmask1 struct we need
            return MemBit1IsSet(
                Bit1,
                Location - SkippedSize
            );
        }

        SkippedSize += Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }
    Require(FALSE);                               // should have found the right Bit1  before?
    return FALSE;
#else

    //: need to expose binary search in the array.h module

    Start = 0;
    End = MemArraySize(&Bits->Array);
    while( Start + 1 < End ) {
        Mid = (Start + End)/2;

        Bit1 = Bits->Array.Ptrs[Mid];
        if( Bit1->Offset <= Location ) {
            Start = Mid;
        } else {
            End = Mid;
        }
    }

    Require( Start <= MemArraySize(&Bits->Array) );
    Bit1 = Bits->Array.Ptrs[Start];

    Require(Bit1->Offset <= Location && Location <= Bit1->Offset + Bit1->Size);

    return MemBit1IsSet(
        Bit1,
        Location - Bit1->Offset
    );

#endif
}

DWORD       _inline
MemBit2GetSize(
    IN      PM_BITMASK2            Bits
)
{
    AssertRet(Bits, ERROR_INVALID_PARAMETER );

    return Bits->Size;
}

DWORD		_inline
MemBit2GetSetBitsInRange(
    IN  PM_BITMASK2     Bits,
    IN  DWORD           dwFrom,
    IN  DWORD           dwTo
)
{
    ARRAY_LOCATION  Loc;
    PM_BITMASK1     Bit1;
    DWORD           nOnes;
    DWORD           Error;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    nOnes = 0;
    while(ERROR_FILE_NOT_FOUND != Error)
    {
        Error = MemArrayGetElement(
                    &Bits->Array,
                    &Loc,
                    &Bit1
                );
        Require(ERROR_SUCCESS == Error);

        if (dwTo < Bit1->Offset)
            break;

        if (dwFrom < Bit1->Offset + Bit1->Size)
        {
            if (dwFrom < Bit1->Offset)
                dwFrom = Bit1->Offset;

            nOnes += MemBit1GetSetBitsInRange(Bit1, 
                        dwFrom - Bit1->Offset,
                        dwTo < Bit1->Offset + Bit1->Size ? dwTo - Bit1->Offset: Bit1->Size - 1);
        }

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }
    return nOnes;
}

DWORD       _inline
MemBit2GetSetBitsSize(
    IN      PM_BITMASK2            Bits
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          nSet;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    nSet = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &Bits->Array,
            &Loc,
            &Bit1
        );
        Require(ERROR_SUCCESS == Error);

        nSet += MemBit1GetSetBitsSize(Bit1);

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }
    return nSet;
}

DWORD       _inline
MemBit2DelBits(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  nBitsToDelete,
    IN      BOOL                   fEnd
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          i;
    DWORD                          Size;
    DWORD                          Error;
    PM_BITMASK1                    Bit1, Bit1x;

    AssertRet(Bits && nBitsToDelete && Bits->Size > nBitsToDelete, ERROR_INVALID_PARAMETER);

    if( fEnd ) {
        Error = MemArrayLastLoc(&Bits->Array, &Loc);
    } else {
        Error = MemArrayInitLoc(&Bits->Array, &Loc);
    }

    Require(ERROR_SUCCESS == Error);
    while( nBitsToDelete ) {
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error);

        Size = MemBit1GetSize(Bit1);

        if( nBitsToDelete >= Size ) {
            nBitsToDelete -= Size;
            Bits->Size -= Size;

            Error = MemBit1Cleanup(Bit1);
            Require(ERROR_SUCCESS == Error);
            Error = MemArrayDelElement(&Bits->Array, &Loc, &Bit1x);
            Require(ERROR_SUCCESS == Error && Bit1x == Bit1);

            // Reset the ptr to the FIRST/LAST location to read the next element
            if( fEnd ) {
                Error = MemArrayLastLoc(&Bits->Array, &Loc);
            } else {
                Error = MemArrayInitLoc(&Bits->Array, &Loc);
            }
        } else {
            Size -= nBitsToDelete;
            Bits->Size -= nBitsToDelete;

            nBitsToDelete = 0;

            Error = MemBit1DelBits(Bit1, Size, fEnd);
        }
        Require(ERROR_SUCCESS == Error);
    }

    Size = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);

        Bit1->Offset = Size;
        Size += Bit1->Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    MemArrayInitLoc( &Bits->Array, &Bits->Loc);
    
    return NO_ERROR;
}

DWORD       _inline
MemBit2AddBits(
    IN OUT  PM_BITMASK2            Bits,
    IN      DWORD                  nBitsToAdd,
    IN      BOOL                   fEnd
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          i;
    DWORD                          Size;
    DWORD                          Error;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && nBitsToAdd, ERROR_INVALID_PARAMETER);

    while( nBitsToAdd ) {
        Size = (nBitsToAdd > MaxBit1Size) ? MaxBit1Size : nBitsToAdd;
        nBitsToAdd -= Size;

        Error = MemBit1Init(&Bit1, Size);
        if( ERROR_SUCCESS != Error ) break;

        if( fEnd ) {
            Error = MemArrayAddElement(
                &Bits->Array,
                Bit1
            );
        } else {
            Error = MemArrayInitLoc(&Bits->Array, &Loc);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayInsElement(
                &Bits->Array,
                &Loc,
                Bit1
            );
        }
        if( ERROR_SUCCESS != Error ) break;
        Bits->Size += Size;
    }

    Size = 0;
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);

        Bit1->Offset = Size;
        Size += Bit1->Size;

        Error = MemArrayNextLoc(&Bits->Array, &Loc);
    }

    MemArrayInitLoc( &Bits->Array, &Bits->Loc);
        
    return NO_ERROR;
}

DWORD       _inline
MemBit2GetSomeClearedBit(
    IN OUT  PM_BITMASK2            Bits,
    OUT     LPDWORD                Offset,
    IN      BOOL                   fAcquire,      // if we find one, do we Set it?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Size;
    DWORD                          Error;
    DWORD                          nBit1s;
    PM_BITMASK1                    Bit1;

    AssertRet(Bits && Offset, ERROR_INVALID_PARAMETER);

    nBit1s = MemArraySize(&Bits->Array);

    while( nBit1s-- != 0 ) {

        Error = MemArrayGetElement(&Bits->Array, &Bits->Loc, (LPVOID *)&Bit1);
        Require(ERROR_SUCCESS == Error);

        Error = MemBit1GetSomeClearedBit(Bit1, &Size, fAcquire, StartAddress+Bit1->Offset, Exclusions);
        if( ERROR_SUCCESS == Error ) {
            *Offset = Bit1->Offset + Size;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Bits->Array, &Bits->Loc);
        if( ERROR_SUCCESS != Error ) {
            Error = MemArrayInitLoc(&Bits->Array, &Bits->Loc);
            Require( ERROR_SUCCESS == Error );
        }
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemBitInit(
    OUT     PM_BITMASK            *Bits,
    IN      DWORD                  nBits
) //EndExport(function)
{
    AssertRet(Bits && nBits, ERROR_INVALID_PARAMETER);

    return MemBit2Init(Bits,nBits);
}

//BeginExport(function)
DWORD
MemBitCleanup(
    IN OUT  PM_BITMASK             Bits
) //EndExport(function)
{
    AssertRet(Bits, ERROR_INVALID_PARAMETER);

    return MemBit2Cleanup(Bits);
}

//BeginExport(function)
DWORD
MemBitSetOrClearAll(
    IN OUT  PM_BITMASK             Bits,
    IN      BOOL                   fSet
) //EndExport(function)
{
    return MemBit2SetOrClearAll(Bits,fSet);
}

//BeginExport(function)
DWORD
MemBitSetOrClear(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location,
    IN      BOOL                   fSet,
    IN      LPBOOL                 fOldState
) //EndExport(function)
{
    return  MemBit2SetOrClear(Bits,Location,fSet, fOldState);
}


//BeginExport(function)
BOOL
MemBitIsSet(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  Location
) //EndExport(function)
{
    BOOL                           Test;
    Test = MemBit2IsSet(Bits, Location);
    return Test;
}

//BeginExport(function)
DWORD
MemBitGetSize(
    IN      PM_BITMASK             Bits
) //EndExport(function)
{
    return MemBit2GetSize(Bits);
}

//BeginExport(function)
DWORD
MemBitGetSetBitsInRange(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  dwFrom,
    IN      DWORD                  dwTo
) //EndExport(function)
{
    return MemBit2GetSetBitsInRange(Bits, dwFrom, dwTo);
}

//BeginExport(function)
DWORD
MemBitGetSetBitsSize(
    IN      PM_BITMASK             Bits
) //EndExport(function)
{
    return MemBit2GetSetBitsSize(Bits);
}

//BeginExport(function)
DWORD
MemBitAddOrDelBits(
    IN OUT  PM_BITMASK             Bits,
    IN      DWORD                  nBitsToAddOrDelete,
    IN      BOOL                   fAdd,
    IN      BOOL                   fEnd
) //EndExport(function)
{
    if( fAdd ) return MemBit2AddBits(Bits, nBitsToAddOrDelete, fEnd);
    return MemBit2DelBits(Bits,nBitsToAddOrDelete, fEnd);
}

//BeginExport(function)
DWORD
MemBitGetSomeClearedBit(
    IN OUT  PM_BITMASK             Bits,
    OUT     DWORD                 *Offset,
    IN      BOOL                   fAcquire,     // Acquire or just lookup?
    IN      DWORD                  StartAddress,
    IN      PARRAY                 Exclusions
) //EndExport(function)
{
    return MemBit2GetSomeClearedBit(Bits,Offset,fAcquire, StartAddress, Exclusions);
}

//BeginExport(function)
DWORD
MemBitConvertToCluster(
    IN      PM_BITMASK             Bits,
    IN      DWORD                  StartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                           Error;
    DWORD                           Cluster;
    DWORD                           i, j;
    DWORD                           nBits;
    DWORD                           nBit1s;
    DWORD                           Size;
    DWORD                           UsedSize;
    DWORD                           InUseSize;
    LPDWORD                         Used;
    LPDWORD                         InUse;
    PM_BITMASK1                     Bit1;
    ARRAY_LOCATION                  Loc;

    nBits = MemBitGetSize(Bits);
    if( 0 == nBits || 0 == MemBitGetSetBitsSize(Bits) ) {
        InUse = MemAlloc(sizeof(DWORD));
        Used = MemAlloc(sizeof(DWORD));
        if( NULL == InUse || NULL == Used ) {
            if( InUse ) MemFree(InUse);
            if( Used ) MemFree(Used);
            Require(FALSE);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *Used = *InUse = 0;
        *InUseClusters = (LPBYTE)InUse;
        *UsedClusters = (LPBYTE)Used;
        *InUseClustersSize = *UsedClustersSize = sizeof(DWORD);
        return ERROR_SUCCESS;
    }

    nBit1s = MemArraySize(&Bits->Array);
    Require(nBit1s);
    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    UsedSize = InUseSize = 1;                     // no matter what, we always use a DWORD for total size
    for(i = 0; i < nBit1s ; i ++ ) {
        Require(ERROR_SUCCESS == Error);
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);
        Error = MemArrayNextLoc(&Bits->Array, &Loc);

        // : Dont touch Bit1 directly like below? not really clean
        if( 0 == Bit1->nSet ) continue;           // no bit is set, nothing to do..
        if( Bit1->Size == Bit1->nSet ) {          // all bits set, nothing to do except for few odd bits
            UsedSize += Bit1->Size/32;
            if( Bit1->Size % 32 ) InUseSize+=2;   // fill the odd bits in InUse so that we dont mark extra bits as used
            continue;
        }

        for( j = 0; j < Bit1->Size/32; j ++ ) {
            if( 0xFFFFFFFF == ((LPDWORD)(Bit1->Mask))[j] ) {
                UsedSize ++;                      // this 32-bit is completely filled
            } else if ( 0 != ((LPDWORD)(Bit1->Mask))[j]) {
                InUseSize += 2;                   // this 32 bit is partially filled, not quite empty
            }
        }
        if( j * 32 < Bit1->Size ) InUseSize +=2;  // for the last few bits..
    }

    InUse = MemAlloc(InUseSize * sizeof(DWORD));
    Used  = MemAlloc(UsedSize * sizeof(DWORD));
    if( NULL == Used || NULL == InUse ) {
        if( InUse ) MemFree(InUse);
        if( Used ) MemFree(Used);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *InUseClustersSize = sizeof(DWORD)*InUseSize; // fill in the sizes and ptrs to be returned..
    *InUseClusters = (LPBYTE)InUse;
    *UsedClusters = (LPBYTE)Used;
    *UsedClustersSize = sizeof(DWORD)*UsedSize;

    Error = MemArrayInitLoc(&Bits->Array, &Loc);
    UsedSize = InUseSize = 1;
    for(i = 0; i < nBit1s ; i ++ ) {
        Require(ERROR_SUCCESS == Error);
        Error = MemArrayGetElement(&Bits->Array, &Loc, &Bit1);
        Require(ERROR_SUCCESS == Error && Bit1);
        Error = MemArrayNextLoc(&Bits->Array, &Loc);

        //  Dont touch Bit1 directly like below? not really clean
        if( 0 == Bit1->nSet ) {                   // all bits clear ==> just ignore
            StartAddress += Bit1->Size;
            continue;
        }
        if( Bit1->nSet == Bit1->Size ) {          // handle all bits set here (loose bits need to be handled later)
            for( j = 0; j < Bit1->Size/32; j ++ ) {
                Used[UsedSize++] = StartAddress + sizeof(DWORD)*j*8;
            }
        } else {
            for( j = 0; j < Bit1->Size/32; j ++ ) {
                if( 0xFFFFFFFF == ((LPDWORD)(Bit1->Mask))[j] ) {
                    Used[UsedSize++] = StartAddress + sizeof(DWORD)*j*8;
                } else if ( 0 != ((LPDWORD)(Bit1->Mask))[j]) {
#ifdef _X86_                                      // on X86, the first byte is the lowest order byte..
                    Cluster = ((LPDWORD)(Bit1->Mask))[j];
#else                                             // it maynot be so on other machines, so combine the bytes manually..
                    Cluster = Bit1->Mask[j*sizeof(DWORD)];
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+1]) << 8;
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+2]) << 16;
                    Cluster |= (Bit1->Mask[j*sizeof(DWORD)+3]) << 24;
#endif
                    InUse[InUseSize++] = StartAddress + sizeof(DWORD)*j*8;
                    InUse[InUseSize++] = Cluster;
                }
            }
        }

        if( j * 32 < Bit1->Size ) {               // copy the last few bits off..
            InUse[InUseSize++] = StartAddress + sizeof(DWORD)*j*8;
            Cluster = 0;
            j *= 32;
            while( j < Bit1->Size ) {
                if( MemBit1IsSet(Bit1, j) ) Cluster |= (1 << (j%32));
                j ++;
            }
            InUse[InUseSize++] = Cluster;
        }

        StartAddress += Bit1->Size;               // move the start address fwd for the next set..
    }

    InUse[0] = (InUseSize -1)/2;                  // size in header does not include itself
    Used[0] = UsedSize -1;                        // it is just the # of CLUSTERS..

    Require(InUseSize*sizeof(DWORD) == *InUseClustersSize);
    Require(UsedSize*sizeof(DWORD) == *UsedClustersSize);
    return ERROR_SUCCESS;
}

//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\classdefl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of class defintitions
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <wchar.h>

//BeginExport(typedef)
typedef struct _M_CLASSDEF {
    DWORD                          RefCount;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    DWORD                          Type;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    DWORD                          nBytes;
    LPBYTE                         ActualBytes;
} M_CLASSDEF, *PM_CLASSDEF, *LPM_CLASSDEF;

typedef struct _M_CLASSDEFLIST {
    ARRAY                          ClassDefArray;
} M_CLASSDEFLIST, *PM_CLASSDEFLIST, *LPM_CLASSDEFLIST;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemClassDefListInit(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayInit(&ClassDefList->ClassDefArray);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemClassDefListCleanup(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayCleanup(&ClassDefList->ClassDefArray);
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemClassDefListFindClassDefInternal(              // dont use this fn outside of classdefl.c
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      LPBOOL                 pIsVendor,
    OUT     PARRAY_LOCATION        Location
) //EndExport(function)
{
    DWORD                          Error;
    PM_CLASSDEF                    ThisClassDef;

    for( Error = MemArrayInitLoc(&ClassDefList->ClassDefArray, Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&ClassDefList->ClassDefArray, Location)
    ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &ClassDefList->ClassDefArray,
            Location,
            (LPVOID *)&ThisClassDef
        );
        Require(ERROR_SUCCESS == Error && ThisClassDef);

        if( pIsVendor != NULL && ThisClassDef->IsVendor != *pIsVendor)
            continue;

        if( ThisClassDef->ClassId == ClassId ) {
            return ERROR_SUCCESS;
        }

        if( nBytes == ThisClassDef->nBytes ) {
            if( 0 == memcmp(ActualBytes, ThisClassDef->ActualBytes, nBytes)) {
                return ERROR_SUCCESS;
            }
        }

        if( Name && 0 == wcscmp(ThisClassDef->Name, Name) ) {
            return ERROR_SUCCESS;
        }
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(inline)
DWORD       _inline
MemClassDefListFindOptDef(                        // search either by ClassId or by Actual bytes and fill matched stuff
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    OUT     PM_CLASSDEF           *ClassDef       // NULL or valid matching class def
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    AssertRet(ClassDef, ERROR_INVALID_PARAMETER);

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error) return Error;

    Error = MemArrayGetElement(
        &ClassDefList->ClassDefArray,
        &Location,
        (LPVOID*)ClassDef
    );
    Require(ERROR_SUCCESS == Error);

    return Error;
}

//BeginExport(function)
DWORD
MemClassDefListAddClassDef(                       // Add or replace option
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          Size;
    PM_CLASSDEF                    ThisClassDef;
    PM_CLASSDEF                    OldClassDef;

    AssertRet(ClassDefList && ClassId && Name && ActualBytes && nBytes, ERROR_INVALID_PARAMETER );

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        &IsVendor,
        &Location
    );

    Size = sizeof(M_CLASSDEF)+nBytes;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    Size += (1+wcslen(Name))*sizeof(WCHAR);
    if( Comment ) Size += (1+wcslen(Comment))*sizeof(WCHAR);

    ThisClassDef = MemAlloc(Size);
    if( NULL == ThisClassDef ) return ERROR_NOT_ENOUGH_MEMORY;

    ThisClassDef->RefCount = 1;
    ThisClassDef->ClassId = ClassId;
    ThisClassDef->IsVendor = IsVendor;
    ThisClassDef->Type = Type;
    ThisClassDef->nBytes = nBytes;
    ThisClassDef->ActualBytes = sizeof(M_CLASSDEF) + (LPBYTE)ThisClassDef;
    memcpy(ThisClassDef->ActualBytes, ActualBytes, nBytes);
    ThisClassDef->Name = (LPWSTR)(ROUND_UP_COUNT(sizeof(M_CLASSDEF)+nBytes, ALIGN_WORST) + (LPBYTE)ThisClassDef);
    wcscpy(ThisClassDef->Name, Name);
    if( Comment ) {
        ThisClassDef->Comment = 1 + wcslen(Name) + ThisClassDef->Name;
        wcscpy(ThisClassDef->Comment, Comment);
    } else {
        ThisClassDef->Comment = NULL;
    }

    if( ERROR_SUCCESS == Error ) {
        DebugPrint2("Overwriting class definition for class-id 0x%lx\n", ClassId);
        Error = MemArrayGetElement(
            &ClassDefList->ClassDefArray,
            &Location,
            (LPVOID *)&OldClassDef
        );
        Require(ERROR_SUCCESS == Error);
        MemFree(OldClassDef);

        Error = MemArraySetElement(
            &ClassDefList->ClassDefArray,
            &Location,
            ThisClassDef
        );
        Require(ERROR_SUCCESS == Error);
        return Error;
    }

    Error = MemArrayAddElement(
        &ClassDefList->ClassDefArray,
        ThisClassDef
    );
    if( ERROR_SUCCESS != Error ) MemFree(ThisClassDef);

    return Error;
}


//BeginExport(inline)
DWORD       _inline
MemClassDefListDelClassDef(
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_CLASSDEF                    ThisClassDef;

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayDelElement(
        &ClassDefList->ClassDefArray,
        &Location,
        &ThisClassDef
    );
    Require(ERROR_SUCCESS == Error && ThisClassDef);

    MemFree(ThisClassDef);
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemClassDefListGetRefCount(
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ThisClassDef->RefCount;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemClassDefListIncRefCount(                       // return increased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ++ThisClassDef->RefCount;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemClassDefListDecRefCount(                       // return decreased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return --ThisClassDef->RefCount;
}
//EndExport(inline)

ULONG                  ClassIdRunningCount = 100;

//BeginExport(function)
DWORD
MemNewClassId(
    VOID
) //EndExport(function)
{
    return InterlockedIncrement(&ClassIdRunningCount);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\array.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;


typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;


DWORD _inline
MemArrayInit(                                     // initialize the STRUCTURE
    OUT     PARRAY                 Array          // input structure pre-allocated
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayCleanup(                                  // freeup the memory if any, allocated in this module
    IN OUT  PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    if( Array->Ptrs) MemFree(Array->Ptrs);
    Array->nElements = Array->nAllocated = 0;
    Array->Ptrs = NULL;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArraySize(
    IN      PARRAY                 Array
) {
    AssertRet(Array, ERROR_INVALID_PARAMETER);
    return Array->nElements;
}


DWORD _inline
MemArrayInitLoc(                                  // Initialize an array location
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    (*Location) = 0;
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}


BOOL _inline
MemArrayValidLoc(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location
)
{
    AssertRet(Array && Location, FALSE);

    return ( *Location < Array->nElements );
}


DWORD _inline
MemArrayNextLoc(                                  // move one step forward
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( (*Location) + 1  >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) ++;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayPrevLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    if( ((LONG)(*Location)) - 1 < 0 ) return ERROR_FILE_NOT_FOUND;
    (*Location) --;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayLastLoc(
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER);
    if( 0 == Array->nElements ) return ERROR_FILE_NOT_FOUND;
    (*Location) = Array->nElements -1;
    return ERROR_SUCCESS;
}


DWORD _inline
MemArrayGetElement(
    IN      PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    OUT     LPVOID                *Element
) {
    AssertRet(Array && Location && Element, ERROR_INVALID_PARAMETER);
    (*Element) = Array->Ptrs[*Location];
    return ERROR_SUCCESS;
}


DWORD _inline
MemArraySetElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) {
    AssertRet(Array && Location, ERROR_INVALID_PARAMETER );
    Array->Ptrs[*Location] = Element;
    return ERROR_SUCCESS;
}


DWORD
MemArrayAddElement(
    IN OUT  PARRAY                 Array,
    IN      LPVOID                 Element
) ;


DWORD
MemArrayInsElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                 Element
) ;


DWORD
MemArrayDelElement(
    IN OUT  PARRAY                 Array,
    IN      PARRAY_LOCATION        Location,
    IN      LPVOID                *Element
) ;


DWORD        _inline
MemArrayAdjustLocation(                           // reset location to "next" after a delete
    IN      PARRAY                 Array,
    IN OUT  PARRAY_LOCATION        Location
) {
    AssertRet(Location && Array, ERROR_INVALID_PARAMETER);

    if( *Location >= Array->nElements ) return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}


DWORD       _inline
MemArrayRotateCyclical(                           // rotate forward/right cyclical
    IN      PARRAY                 Array
) {
    LPVOID                         FirstPtr;

    AssertRet(Array, ERROR_INVALID_PARAMETER);

    if( Array->nElements < 2 ) return ERROR_SUCCESS;
    FirstPtr = Array->Ptrs[0];
    memcpy(Array->Ptrs, &Array->Ptrs[1], sizeof(Array->Ptrs[0])* (Array->nElements -1));
    Array->Ptrs[Array->nElements -1] = FirstPtr;

    return ERROR_SUCCESS;
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\memfree.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: Routines to recursively free objects
//================================================================================

#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <address.h>

//BeginExport(typedef)
typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);
//EndExport(typedef)

//BeginExport(function)
VOID
MemArrayFree(
    IN OUT  PARRAY                 Array,
    IN      ARRAY_FREE_FN          Function
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    LPVOID                         Element;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &Element);
        Require(ERROR_SUCCESS == Error && Element);

        Function(Element);

        Error = MemArrayNextLoc(Array, &Loc);
    }

    Require(ERROR_FILE_NOT_FOUND == Error);

    Error = MemArrayCleanup(Array);
    Require(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
MemOptFree(
    IN OUT  PM_OPTION              Opt
) //EndExport(function)
{
    MemFree(Opt);
}

//BeginExport(function)
VOID
MemOptListFree(
    IN OUT  PM_OPTLIST             OptList
) //EndExport(function)
{
    MemArrayFree(OptList, MemOptFree);
}

//BeginExport(function)
VOID
MemOptClassOneFree(
    IN OUT  PM_ONECLASS_OPTLIST    OptClassOne
) //EndExport(function)
{
    MemOptListFree(&OptClassOne->OptList);
    MemFree(OptClassOne);
}

//BeginExport(function)
VOID
MemOptClassFree(
    IN OUT  PM_OPTCLASS            Options
) //EndExport(function)
{
    MemArrayFree(&Options->Array, MemOptClassOneFree);
}

VOID
MemBitMaskFree(
    IN OUT  PM_BITMASK             BitMask
) //EndExport(Function)
{
    MemBitCleanup(BitMask);
}

//BeginExport(function)
VOID
MemRangeFree(
    IN OUT  PM_RANGE               Range
) //EndExport(function)
{
    MemOptClassFree(&Range->Options);
    MemBitMaskFree(Range->BitMask);
    MemFree(Range);
}

//BeginExport(function)
VOID
MemExclusionFree(
    IN OUT  PM_EXCL                Excl
) //EndExport(function)
{
    MemFree(Excl);
}

//BeginExport(function)
VOID
MemReservationFree(
    IN OUT  PM_RESERVATION         Reservation
) //EndExport(function)
{
    MemOptClassFree(&Reservation->Options);
    MemFree(Reservation);
}

//BeginExport(function)
VOID
MemReservationsFree(
    IN OUT  PM_RESERVATIONS        Reservations
) //EndExport(function)
{
    MemArrayFree(Reservations, MemReservationFree);
}

//BeginExport(function)
VOID
MemSubnetFree(
    IN OUT  PM_SUBNET              Subnet
)//EndExport(function)
{
    MemOptClassFree(&Subnet->Options);
    MemArrayFree(&Subnet->Ranges, MemRangeFree);
    MemArrayFree(&Subnet->Exclusions, MemExclusionFree);
    MemReservationsFree(&Subnet->Reservations);

    MemFree(Subnet);
}

//BeginExport(function)
VOID
MemMScopeFree(
    IN OUT  PM_MSCOPE              MScope
)//EndExport(function)
{
    MemSubnetFree(MScope);
}

//BeginExport(function)
VOID
MemOptDefFree(
    IN OUT  PM_OPTDEF              OptDef
) //EndExport(function)
{
    MemFree(OptDef);
}

//BeginExport(function)
VOID
MemOptDefListFree(
    IN OUT  PM_OPTCLASSDEFL_ONE    OptClassDefListOne
) //EndExport(function)
{
    MemArrayFree(&OptClassDefListOne->OptDefList.OptDefArray, MemOptDefFree);
    MemFree(OptClassDefListOne);
}

//BeginExport(function)
VOID
MemOptClassDefListFree(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) //EndExport(function)
{
    MemArrayFree(&OptClassDefList->Array, MemOptDefListFree);
}

//BeginExport(function)
VOID
MemClassDefFree(
    IN OUT  PM_CLASSDEF            ClassDef
) //EndExport(function)
{
    MemFree(ClassDef);
}

//BeginExport(function)
VOID
MemClassDefListFree(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
)//EndExport(function)
{
    MemArrayFree(&ClassDefList->ClassDefArray, MemClassDefFree);
}



//BeginExport(function)
VOID
MemServerFree(
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    MemArrayFree(&Server->Subnets, MemSubnetFree);
    MemArrayFree(&Server->MScopes, MemMScopeFree);
    MemOptClassFree(&Server->Options);
    MemOptClassDefListFree(&Server->OptDefs);
    MemClassDefListFree(&Server->ClassDefs);

    MemFree(Server);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mm.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: some useful defines and other information
//================================================================================

#ifndef     UNICODE
#define     UNICODE 1
#endif      UNICODE
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windef.h>
#include    <winbase.h>
#include    <winuser.h>
#include    <align.h>
#include    <dhcp.h>    // need this for DATE_TIME

#if         DBG

VOID        _inline
RequireF(
    IN      LPSTR                  Condition,
    IN      LPSTR                  FileName,
    IN      DWORD                  LineNumber
) {
    RtlAssert(Condition, FileName, LineNumber, "RequireF" );
}

#define     Require(X)             do{ if( !(X) ) RequireF(#X, __FILE__, __LINE__ ); } while(0)
#define     AssertRet(X,Y)         do { if( !(X) ) { RequireF(#X, __FILE__, __LINE__); return Y; } } while(0)

#else       DBG

#define     Require(X)
#define     AssertRet(X,Y)         do { if( !(X) ) { return Y; } } while (0)

#endif      DBG

#include    <..\mm\mminit.h>

#define     DebugPrint2(X,Y)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\classdefl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_CLASSDEF {
    DWORD                          RefCount;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    DWORD                          Type;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    DWORD                          nBytes;
    LPBYTE                         ActualBytes;
} M_CLASSDEF, *PM_CLASSDEF, *LPM_CLASSDEF;

typedef struct _M_CLASSDEFLIST {
    ARRAY                          ClassDefArray;
} M_CLASSDEFLIST, *PM_CLASSDEFLIST, *LPM_CLASSDEFLIST;


DWORD       _inline
MemClassDefListInit(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayInit(&ClassDefList->ClassDefArray);
}


DWORD       _inline
MemClassDefListCleanup(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) {
    return MemArrayCleanup(&ClassDefList->ClassDefArray);
}


DWORD
MemClassDefListFindClassDefInternal(              // dont use this fn outside of classdefl.c
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    IN      LPBOOL                 pIsVendor,
    OUT     PARRAY_LOCATION        Location
) ;


DWORD       _inline
MemClassDefListFindOptDef(                        // search either by ClassId or by Actual bytes and fill matched stuff
    IN      PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes,
    OUT     PM_CLASSDEF           *ClassDef       // NULL or valid matching class def
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    AssertRet(ClassDef, ERROR_INVALID_PARAMETER);

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error) return Error;

    Error = MemArrayGetElement(
        &ClassDefList->ClassDefArray,
        &Location,
        (LPVOID*)ClassDef
    );
    Require(ERROR_SUCCESS == Error);

    return Error;
}

//BeginExport(function)

DWORD
MemClassDefListAddClassDef(                       // Add or replace option
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
) ;


DWORD       _inline
MemClassDefListDelClassDef(
    IN OUT  PM_CLASSDEFLIST        ClassDefList,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      LPBYTE                 ActualBytes,
    IN      DWORD                  nBytes
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_CLASSDEF                    ThisClassDef;

    Error = MemClassDefListFindClassDefInternal(
        ClassDefList,
        ClassId,
        Name,
        ActualBytes,
        nBytes,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayDelElement(
        &ClassDefList->ClassDefArray,
        &Location,
        &ThisClassDef
    );
    Require(ERROR_SUCCESS == Error && ThisClassDef);

    MemFree(ThisClassDef);
    return ERROR_SUCCESS;
}


DWORD       _inline
MemClassDefListGetRefCount(
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ThisClassDef->RefCount;
}


DWORD       _inline
MemClassDefListIncRefCount(                       // return increased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return ++ThisClassDef->RefCount;
}


DWORD       _inline
MemClassDefListDecRefCount(                       // return decreased by one value
    IN      PM_CLASSDEF            ThisClassDef
) {
    return --ThisClassDef->RefCount;
}


DWORD
MemNewClassId(
    VOID
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\memfree.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);


VOID
MemArrayFree(
    IN OUT  PARRAY                 Array,
    IN      ARRAY_FREE_FN          Function
) ;


VOID
MemOptFree(
    IN OUT  PM_OPTION              Opt
) ;


VOID
MemOptListFree(
    IN OUT  PM_OPTLIST             OptList
) ;


VOID
MemOptClassOneFree(
    IN OUT  PM_ONECLASS_OPTLIST    OptClassOne
) ;


VOID
MemOptClassFree(
    IN OUT  PM_OPTCLASS            Options
) ;



VOID
MemRangeFree(
    IN OUT  PM_RANGE               Range
) ;


VOID
MemExclusionFree(
    IN OUT  PM_EXCL                Excl
) ;


VOID
MemReservationFree(
    IN OUT  PM_RESERVATION         Reservation
) ;


VOID
MemReservationsFree(
    IN OUT  PM_RESERVATIONS        Reservations
) ;


VOID
MemSubnetFree(
    IN OUT  PM_SUBNET              Subnet
) ;


VOID
MemMScopeFree(
    IN OUT  PM_MSCOPE              MScope
) ;


VOID
MemOptDefFree(
    IN OUT  PM_OPTDEF              OptDef
) ;


VOID
MemOptDefListFree(
    IN OUT  PM_OPTCLASSDEFL_ONE    OptClassDefListOne
) ;


VOID
MemOptClassDefListFree(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) ;


VOID
MemClassDefFree(
    IN OUT  PM_CLASSDEF            ClassDef
) ;


VOID
MemClassDefListFree(
    IN OUT  PM_CLASSDEFLIST        ClassDefList
) ;


VOID
MemServerFree(
    IN OUT  PM_SERVER              Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mminit.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: some memory handling stuff
//================================================================================

#include <mm.h>
#include <align.h>

#if  DBG
#define     STATIC          static
#else
#define     STATIC
#endif

STATIC      HANDLE                 MemHeapHandle = NULL;
static      DWORD                  Initialized = FALSE;
static      DWORD                  UseHeap = 0;
ULONG                              MemNBytesAllocated = 0;

//BeginExport(function)
DWORD
MemInit(
    VOID
) //EndExport(function)
{
    Require(Initialized == FALSE);
    MemHeapHandle = HeapCreate(
        /* flOptions     */ 0,
        /* dwInitialSize */ 64000,
        /* dwMaximumSize */ 0
    );
    if( MemHeapHandle == NULL ) return GetLastError();
    Initialized = TRUE;
    UseHeap = 1;
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
MemCleanup(
    VOID
) //EndExport(function)
{
    BOOL                           Status;

    if( 0 == Initialized ) return;
    Initialized --;
    Require(MemHeapHandle);
    Status = HeapDestroy(MemHeapHandle);
    MemHeapHandle = NULL;
    Require(FALSE != Status);
    Require(0 == Initialized);
    UseHeap = 0;
}

LPVOID  _inline
MemAllocInternal(
    IN      DWORD                  nBytes
)
{
    LPVOID                         Ptr;
    if( 0 == UseHeap ) {
        Ptr = LocalAlloc(LMEM_FIXED, nBytes);
        // DbgPrint("MEM %08lx ALLOC\n", Ptr);
        return Ptr;
    }

    if( NULL == MemHeapHandle ) return NULL;

    return HeapAlloc(
        /* hHeap    */ MemHeapHandle,
        /* dwFlags  */ HEAP_ZERO_MEMORY,
        /* dwBytes  */ nBytes
    );
}

DWORD  _inline
MemFreeInternal(
    IN      LPVOID                 Mem
)
{
    BOOL                           Status;

    // DbgPrint("MEM %08lx FREE\n", Mem);

    if( 0 == UseHeap ) {
        if(NULL == LocalFree(Mem) )
            return ERROR_SUCCESS;
        return ERROR_INVALID_DATA;
    }

    if( NULL == MemHeapHandle ) {
        Require(FALSE);
        return ERROR_INVALID_DATA;
    }

    Status = HeapFree(
        /* hHeap   */ MemHeapHandle,
        /* dwFlags */ 0,
        /* lpMem   */ Mem
    );

    if( FALSE != Status ) return ERROR_SUCCESS;
    return GetLastError();
}

//BeginExport(function)
LPVOID
MemAlloc(
    IN      DWORD                  nBytes
) //EndExport(function)
{
    LPVOID                         Ptr;

#if DBG
    Ptr = MemAllocInternal(ROUND_UP_COUNT(nBytes + sizeof(ULONG_PTR), ALIGN_WORST));
    if( NULL == Ptr ) return Ptr;
    *((ULONG_PTR *)Ptr) ++ = nBytes;
    InterlockedExchangeAdd(&MemNBytesAllocated, nBytes);
    return Ptr;
#endif

    return MemAllocInternal(nBytes);
}


//BeginExport(function)
DWORD 
MemFree(
    IN      LPVOID                 Mem
) //EndExport(function)
{
    LPVOID                         Ptr;

#if DBG
    Ptr = -1 + (ULONG_PTR *)Mem;
    InterlockedExchangeAdd(&MemNBytesAllocated, - (LONG)(*(ULONG *)Ptr) );
    return MemFreeInternal(Ptr);
#endif

    return MemFreeInternal(Mem);

}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mmdump.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

VOID
MmDumpOption(
    IN      ULONG                  InitTab,
    IN      PM_OPTION              Option
) ;


VOID
MmDumpOptList(
    IN      ULONG                  InitTab,
    IN      PM_OPTLIST             OptList
) ;


VOID
MmDumpOneClassOptList(
    IN      ULONG                  InitTab,
    IN      PM_ONECLASS_OPTLIST    OptList1
) ;


VOID
MmDumpOptions(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASS            OptClass
) ;


VOID
MmDumpReservation(
    IN      ULONG                  InitTab,
    IN      PM_RESERVATION         Res
) ;


VOID
MmDumpRange(
    IN      ULONG                  InitTab,
    IN      PM_RANGE               Range
) ;


VOID
MmDumpExclusion(
    IN      ULONG                  InitTab,
    IN      PM_EXCL                Range
) ;


VOID
MmDumpSubnets(
    IN      ULONG                  InitTab,
    IN      PM_SUBNET              Subnet
) ;


VOID
MmDumpSscope(
    IN      ULONG                  InitTab,
    IN      PM_SSCOPE              Sscope
) ;


VOID
MmDumpOptDef(
    IN      ULONG                  InitTab,
    IN      PM_OPTDEF              OptDef
) ;


VOID
MmDumpOptClassDefListOne(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFL_ONE    OptDefList1
) ;


VOID
MmDumpOptClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFLIST     OptDefList
) ;


VOID
MmDumpClassDef(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEF            ClassDef
) ;


VOID
MmDumpClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEFLIST        ClassDefList
) ;


VOID
MmDumpServer(
    IN      ULONG                  InitTab,        // how much to tab initially..
    IN      PM_SERVER              Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mmdump.c ===
//================================================================================
//  Copyright (C) 1998 Microsoft Corporation
//  Author: RameshV
//  Decription: This module just dumps several types of objects to the debugger.
//   This can be easily modified to be a ntsd extension etc..
//   No separate description is given as this is not supposed to be used for
//   regular use.  This is just there for diagnostic purposes.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <winsock2.h>
#include    <stdio.h>

#define TAB                        do{int i = InitTab ; while(i--) printf("\t"); }while(0)

typedef
VOID
DUMPFUNC(                                          // any phonetic resemblance to "dum fuk" is purely incidental..
    IN      ULONG                  InitTab,
    IN      LPVOID                 Struct
);

static
VOID
DumpArray(
    IN      PARRAY                 Array,
    IN      ULONG                  InitTab,
    IN      DUMPFUNC               Func
)
{
    ARRAY_LOCATION                 Loc;
    LPVOID                         ThisElt;
    DWORD                          Err;

    for( Err = MemArrayInitLoc(Array, &Loc)
         ; ERROR_SUCCESS == Err ;
         Err = MemArrayNextLoc(Array, &Loc)
    ) {
        ThisElt = NULL;
        Err = MemArrayGetElement(Array, &Loc, &ThisElt);
        Func(InitTab, ThisElt);
    }

    if( ERROR_FILE_NOT_FOUND != Err ) {
        TAB; printf("Enumeration failure: %ld (0x%08lx)\n", Err, Err);
    }
}

#define     HEX_CHAR(c)            (((c) < 10)?((c)+'0'):((c) - 10 + 'A'))

static
VOID
DumpHex(
    IN      LPSTR                  Name,
    IN      LPBYTE                 Bytes,
    IN      ULONG                  nBytes
)
{
    printf("%s ", Name);
    while(nBytes--) {
        printf("%c%c ", HEX_CHAR(((*Bytes)&0xF0)>>4), HEX_CHAR((*Bytes)&0x0F));
        Bytes ++;
    }
    printf("\n");
}

//BeginExport(function)
VOID
MmDumpOption(
    IN      ULONG                  InitTab,
    IN      PM_OPTION              Option
)   //EndExport(function)
{
    TAB; printf("Option %ld\n", Option->OptId);
    InitTab++;
    TAB; DumpHex("Option value:", Option->Val, Option->Len);
}

//BeginExport(function)
VOID
MmDumpOptList(
    IN      ULONG                  InitTab,
    IN      PM_OPTLIST             OptList
)   //EndExport(function)
{
    DumpArray(OptList, InitTab, MmDumpOption);
}

//BeginExport(function)
VOID
MmDumpOneClassOptList(
    IN      ULONG                  InitTab,
    IN      PM_ONECLASS_OPTLIST    OptList1
)   //EndExport(function)
{
    TAB; printf("OptList for UserClass %ld Vendor Class %ld\n", OptList1->ClassId, OptList1->VendorId);
    InitTab ++;

    MmDumpOptList(InitTab, &OptList1->OptList);
}


//BeginExport(function)
VOID
MmDumpOptions(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASS            OptClass
)   //EndExport(function)
{
    DumpArray(&OptClass->Array, InitTab, MmDumpOneClassOptList);
}

//BeginExport(function)
VOID
MmDumpReservation(
    IN      ULONG                  InitTab,
    IN      PM_RESERVATION         Res
)   //EndExport(function)
{
    TAB; printf("Reservation %s (Type %ld)\n", inet_ntoa(*(struct in_addr *)&Res->Address),Res->Flags);
    InitTab++;
    TAB; DumpHex("Reservation for", Res->ClientUID, Res->nBytes);
    MmDumpOptions(InitTab, &Res->Options);
}

//BeginExport(function)
VOID
MmDumpRange(
    IN      ULONG                  InitTab,
    IN      PM_RANGE               Range
)   //EndExport(function)
{
    TAB; printf("Range: %s to ", inet_ntoa(*(struct in_addr *)&Range->Start));
    printf("%s mask (", inet_ntoa(*(struct in_addr *)&Range->End));
    printf("%s)\n", inet_ntoa(*(struct in_addr *)&Range->Mask));
}

//BeginExport(function)
VOID
MmDumpExclusion(
    IN      ULONG                  InitTab,
    IN      PM_EXCL                Range
)   //EndExport(function)
{
    TAB; printf("Range: %s to ", inet_ntoa(*(struct in_addr *)&Range->Start));
    printf("%s\n", inet_ntoa(*(struct in_addr *)&Range->End));
}

//BeginExport(function)
VOID
MmDumpSubnets(
    IN      ULONG                  InitTab,
    IN      PM_SUBNET              Subnet
)   //EndExport(function)
{
    TAB; printf("Scope %ws : ", Subnet->Name);
    if( Subnet->fSubnet ) {
        printf("ADDRESS %s ", inet_ntoa(*(struct in_addr*)&Subnet->Address));
        printf("MASK %s\n", inet_ntoa(*(struct in_addr*)&Subnet->Mask));
    } else {
        printf("SCOPEID %ld\n", Subnet->MScopeId);
    }
    InitTab++;
    TAB; printf("Subnet Description: %ws\n", Subnet->Description);
    TAB; printf("State/SuperScope/Policy: %ld/%ld/%ld\n", Subnet->State, Subnet->SuperScopeId, Subnet->Policy);
    DumpArray(&Subnet->Ranges, InitTab, MmDumpRange);
    DumpArray(&Subnet->Exclusions, InitTab, MmDumpExclusion);
    MmDumpOptions(InitTab, &Subnet->Options);
    DumpArray(&Subnet->Reservations, InitTab, MmDumpReservation);
}

//BeginExport(function)
VOID
MmDumpSscope(
    IN      ULONG                  InitTab,
    IN      PM_SSCOPE              Sscope
)   //EndExport(function)
{
    TAB; printf("SuperScope %ws (%ld) Policy 0x%08lx\n",
                  Sscope->Name, Sscope->SScopeId, Sscope->Policy
    );
}

//BeginExport(function)
VOID
MmDumpOptDef(
    IN      ULONG                  InitTab,
    IN      PM_OPTDEF              OptDef
)   //EndExport(function)
{
    TAB; printf("Option <%ws> %ld\n", OptDef->OptName, OptDef->OptId);
    InitTab++;
    TAB; printf("Option Comment: %ws\n", OptDef->OptComment);
    TAB; DumpHex("Option Default Value:", OptDef->OptVal, OptDef->OptValLen);
}

//BeginExport(function)
VOID
MmDumpOptClassDefListOne(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFL_ONE    OptDefList1
)   //EndExport(function)
{
    TAB; printf("Options for UserClass %ld Vendor Class %ld \n",
                  OptDefList1->ClassId, OptDefList1->VendorId
    );
    InitTab++;
    DumpArray(&OptDefList1->OptDefList.OptDefArray, InitTab, MmDumpOptDef);
}

//BeginExport(function)
VOID
MmDumpOptClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_OPTCLASSDEFLIST     OptDefList
)   //EndExport(function)
{
    DumpArray(&OptDefList->Array, InitTab, MmDumpOptClassDefListOne);
}

//BeginExport(function)
VOID
MmDumpClassDef(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEF            ClassDef
)   //EndExport(function)
{
    TAB; printf("Class <%ws> Id: %ld, %s\n", ClassDef->Name, ClassDef->ClassId,
                  ClassDef->IsVendor? "VENDOR CLASS" : "USER CLASS"
    );

    InitTab ++;
    TAB; printf("ClassComment: %ws\n", ClassDef->Comment);
    TAB; printf("ClassType/RefCount: %ld/%ld\n", ClassDef->Type, ClassDef->RefCount);
    TAB; DumpHex("ClassData:", ClassDef->ActualBytes, ClassDef->nBytes);
}


//BeginExport(function)
VOID
MmDumpClassDefList(
    IN      ULONG                  InitTab,
    IN      PM_CLASSDEFLIST        ClassDefList
)   //EndExport(function)
{
    DumpArray(&ClassDefList->ClassDefArray, InitTab, MmDumpClassDef);
}

//BeginExport(function)
VOID
MmDumpServer(
    IN      ULONG                  InitTab,        // how much to tab initially..
    IN      PM_SERVER              Server
)   //EndExport(function)
{
    DWORD                          Err;

    PM_SUBNET                      ThisSubnet;
    PM_MSCOPE                      ThisMScope;
    PM_SSCOPE                      ThisSScope;

    TAB;
    printf("Server: %s <%ws>\n", inet_ntoa(*(struct in_addr*)&Server->Address), Server->Name);
    InitTab++;

    TAB; printf("State: %ld (0x%08lx)\n", Server->State, Server->State);
    TAB; printf("Policy: %ld (0x%08lx)\n", Server->Policy, Server->Policy);

    MmDumpClassDefList(InitTab, &Server->ClassDefs);
    MmDumpOptClassDefList(InitTab, &Server->OptDefs);
    MmDumpOptions(InitTab, &Server->Options);     // dump classes, option defs, options

    DumpArray(&Server->SuperScopes, InitTab, MmDumpSscope);
    DumpArray(&Server->Subnets, InitTab, MmDumpSubnets);
    DumpArray(&Server->MScopes, InitTab, MmDumpSubnets);
}


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\oclassdl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for storing complete option configuration info
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include <mm.h>
#include <array.h>
#include <optdefl.h>

//BeginExport(typedef)
typedef struct _M_OPTCLASSDEFL_ONE {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTDEFLIST                   OptDefList;
} M_OPTCLASSDEFL_ONE, *PM_OPTCLASSDEFL_ONE;

typedef struct _M_OPTCLASSDEFLIST {
    ARRAY                          Array;
} M_OPTCLASSDEFLIST, *PM_OPTCLASSDEFLIST, *LPM_OPTCLASSDEFLIST;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemOptClassDefListInit(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    return MemArrayInit(&OptClassDefList->Array);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptClassDefListCleanup(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    // Bump down class Id refcount?
    return MemArrayCleanup(&OptClassDefList->Array);
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemOptClassDefListFindOptDefList(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTDEFLIST         *OptDefList
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_OPTCLASSDEFL_ONE            OneClassDefList;

    AssertRet(OptClassDefList && OptDefList, ERROR_INVALID_PARAMETER);

    *OptDefList = NULL;
    for( Error = MemArrayInitLoc(&OptClassDefList->Array, &Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClassDefList->Array, &Location)
    ) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(
            &OptClassDefList->Array,
            &Location,
            (LPVOID*)&OneClassDefList
        );
        Require(ERROR_SUCCESS == Error && OneClassDefList);

        if( OneClassDefList->ClassId == ClassId &&
            OneClassDefList->VendorId == VendorId ) {
            *OptDefList = &OneClassDefList->OptDefList;
            return ERROR_SUCCESS;
        }
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemOptClassDefListAddOptDef(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTCLASSDEFL_ONE            OneClassDefList;
    PM_OPTDEFLIST                  OptDefList;

    AssertRet(OptClassDefList, ERROR_INVALID_PARAMETER);

    OneClassDefList = NULL;

    Error = MemOptClassDefListFindOptDefList(
        OptClassDefList,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) {
        Require(ERROR_FILE_NOT_FOUND == Error);
        OneClassDefList = MemAlloc(sizeof(*OneClassDefList));
        if( NULL == OneClassDefList) return ERROR_NOT_ENOUGH_MEMORY;

        // RefCount on ClassId needs to be bumped up?
        OneClassDefList->ClassId = ClassId;
        OneClassDefList->VendorId = VendorId;
        Error = MemOptDefListInit(&OneClassDefList->OptDefList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(OneClassDefList);
            return Error;
        }

        Error = MemArrayAddElement(&OptClassDefList->Array, OneClassDefList);
        if( ERROR_SUCCESS != Error) {
            MemFree(OneClassDefList);
            return Error;
        }

        OptDefList = &OneClassDefList->OptDefList;
    }

    Error = MemOptDefListAddOptDef(
        OptDefList,
        OptId,
        Type,
        Name,
        Comment,
        OptVal,
        OptLen
    );

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mminit.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
MemInit(
    VOID
) ;


VOID
MemCleanup(
    VOID
) ;


LPVOID
MemAlloc(
    IN      DWORD                  nBytes
) ;


DWORD 
MemFree(
    IN      LPVOID                 Mem
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\mmtypes.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

typedef struct _ARRAY {
    DWORD                          nElements;
    DWORD                          nAllocated;
    LPVOID                        *Ptrs;
} ARRAY, *PARRAY, *LPARRAY;


typedef DWORD                      ARRAY_LOCATION;
typedef ARRAY_LOCATION*            PARRAY_LOCATION;
typedef PARRAY_LOCATION            LPARRAY_LOCATION;


typedef struct _M_OPTION {
    DWORD                          OptId;
    DWORD                          Len;
    BYTE                           Val[0];
} M_OPTION, *PM_OPTION, *LP_MOPTION;


typedef     ARRAY                  M_OPTLIST;
typedef     PARRAY                 PM_OPTLIST;
typedef     LPARRAY                LPM_OPTLIST;


typedef struct _M_OPTDEF {
    DWORD                          OptId;
    DWORD                          Type;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    LPBYTE                         OptVal;
    DWORD                          OptValLen;
} M_OPTDEF, *PM_OPTDEF, *LPM_OPTDEF;

typedef struct _M_OPTDEFLIST {
    ARRAY                          OptDefArray;
} M_OPTDEFLIST, *PM_OPTDEFLIST, *LPM_OPTDEFLIST;


typedef struct _M_CLASSDEF {
    DWORD                          RefCount;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    DWORD                          Type;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    DWORD                          nBytes;
    LPBYTE                         ActualBytes;
} M_CLASSDEF, *PM_CLASSDEF, *LPM_CLASSDEF;

typedef struct _M_CLASSDEFLIST {
    ARRAY                          ClassDefArray;
} M_CLASSDEFLIST, *PM_CLASSDEFLIST, *LPM_CLASSDEFLIST;


typedef struct _M_ONECLASS_OPTLIST {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTLIST                      OptList;
} M_ONECLASS_OPTLIST, *PM_ONECLASS_OPTLIST, *LPM_ONECLASS_OPTLIST;

typedef struct _M_OPTCLASS {
    ARRAY                          Array;
} M_OPTCLASS, *PM_OPTCLASS, *LPM_OPTCLASS;


typedef struct _M_EXCL {
    DWORD                          Start;
    DWORD                          End;
} M_EXCL, *PM_EXCL, *LPM_EXCL;


typedef struct _M_BITMASK1 {
    DWORD                          Size;          // Size in # of bits
    DWORD                          AllocSize;     // Size in BYTES allocated
    DWORD                          nSet;          // nBits set
    LPBYTE                         Mask;          //  making this DWORD would make things faster..
    DWORD                          Offset;        // used by Bit2 type..
    ULONG                          nDirtyOps;     // # of unsaved operations done on this bitmask?
} M_BITMASK1, *PM_BITMASK1, *LPM_BITMASK1;


typedef struct _M_BITMASK2 {
    DWORD                          Size;
    ARRAY_LOCATION                 Loc;           // where to start off to look for a bit
    ARRAY                          Array;         // Array of bitmask 1 types
} M_BITMASK2, *PM_BITMASK2, *LPM_BITMASK2;

typedef     M_BITMASK2             M_BITMASK;
typedef     PM_BITMASK2            PM_BITMASK;
typedef     LPM_BITMASK2           LPM_BITMASK;


typedef struct _M_RESERVATION  {
    LPVOID                         SubnetPtr;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    M_OPTCLASS                     Options;
} M_RESERVATION , *PM_RESERVATION , *LPM_RESERVATION ;


typedef ARRAY                      M_RESERVATIONS;
typedef PARRAY                     PM_RESERVATIONS;
typedef LPARRAY                    LPM_RESERVATIONS;


typedef struct _M_RANGE {
    DWORD                          Start;
    DWORD                          End;
    DWORD                          Mask;
    DWORD                          State;
    ULONG                          BootpAllocated;
    ULONG                          MaxBootpAllowed;
    DWORD                          DirtyOps;      // how many unsaved ops done?
    M_OPTCLASS                     Options;
    PM_BITMASK                     BitMask;
    // Reservations?
} M_RANGE, *PM_RANGE, *LPM_RANGE;


typedef struct _M_SUBNET {
    LPVOID                         ServerPtr;     // Ptr to Server object
    union {
        struct {                                  // for normal subnet.
            DWORD                      Address;
            DWORD                      Mask;
            DWORD                      SuperScopeId;  // unused for MCAST scopes
        };
        struct {                                  // for multicast scope
            DWORD                      MScopeId;
            LPWSTR                     LangTag;       // the language tag for multicast scope
            BYTE                       TTL;
        };
    };
    DWORD                          fSubnet;       // TRUE => Subnet, FALSE => MSCOPE
    DWORD                          State;
    DWORD                          Policy;
    DATE_TIME                      ExpiryTime;     // Scope Lifetime. Currently used for MCast only.
    M_OPTCLASS                     Options;
    ARRAY                          Ranges;
    ARRAY                          Exclusions;
    M_RESERVATIONS                 Reservations;
    ARRAY                          Servers;       // future use, Server-Server protocol
    LPWSTR                         Name;
    LPWSTR                         Description;
} M_SUBNET, *PM_SUBNET, *LPM_SUBNET;


typedef     M_SUBNET               M_MSCOPE;      // same structure for Multicast Scopes and Subnets
typedef     PM_SUBNET              PM_MSCOPE;     // still, use the correct functions for MScope
typedef     LPM_SUBNET             LPM_MSCOPE;


typedef struct _M_SSCOPE {
    DWORD                          SScopeId;
    DWORD                          Policy;
    LPWSTR                         Name;
    M_OPTCLASS                     Options;
} M_SSCOPE, *PM_SSCOPE, *LPM_SSCOPE;


typedef struct _M_OPTCLASSDEFL_ONE {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTDEFLIST                   OptDefList;
} M_OPTCLASSDEFL_ONE, *PM_OPTCLASSDEFL_ONE;

typedef struct _M_OPTCLASSDEFLIST {
    ARRAY                          Array;
} M_OPTCLASSDEFLIST, *PM_OPTCLASSDEFLIST, *LPM_OPTCLASSDEFLIST;


typedef struct _M_SERVER {
    DWORD                          Address;
    //  must be ARRAY type to hold multliple addresses
    DWORD                          State;
    DWORD                          Policy;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY_LOCATION                 Loc;           // if RoundRobin on, then we need this to keep track
    ARRAY                          SuperScopes;
    M_OPTCLASS                     Options;
    M_OPTCLASSDEFLIST              OptDefs;
    M_CLASSDEFLIST                 ClassDefs;
    LPWSTR                         Name;
    LPWSTR                         Comment;
} M_SERVER, *PM_SERVER, *LPM_SERVER;


typedef     VOID                  (*ARRAY_FREE_FN)(LPVOID  MemObject);

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\oclassdl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_OPTCLASSDEFL_ONE {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTDEFLIST                   OptDefList;
} M_OPTCLASSDEFL_ONE, *PM_OPTCLASSDEFL_ONE;

typedef struct _M_OPTCLASSDEFLIST {
    ARRAY                          Array;
} M_OPTCLASSDEFLIST, *PM_OPTCLASSDEFLIST, *LPM_OPTCLASSDEFLIST;


DWORD       _inline
MemOptClassDefListInit(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    return MemArrayInit(&OptClassDefList->Array);
}


DWORD       _inline
MemOptClassDefListCleanup(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList
) {
    // BUG BUG Bump down class Id refcount?
    return MemArrayCleanup(&OptClassDefList->Array);
}


DWORD
MemOptClassDefListFindOptDefList(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTDEFLIST         *OptDefList
) ;


DWORD
MemOptClassDefListAddOptDef(
    IN OUT  PM_OPTCLASSDEFLIST     OptClassDefList,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\opt.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for an option
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include    <mm.h>

//BeginExport(typedef)
typedef struct _M_OPTION {
    DWORD                          OptId;
    DWORD                          Len;
    BYTE                           Val[0];
} M_OPTION, *PM_OPTION, *LP_MOPTION;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemOptInit(
    OUT     PM_OPTION             *Opt,
    IN      DWORD                  OptId,
    IN      DWORD                  Len,
    IN      LPBYTE                 Val
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);
    AssertRet(Len || NULL==Val, ERROR_INVALID_PARAMETER);
    AssertRet(0 == Len|| Val, ERROR_INVALID_PARAMETER);

    (*Opt) = MemAlloc(sizeof(M_OPTION)+Len);
    if( NULL == (*Opt) ) return ERROR_NOT_ENOUGH_MEMORY;

    (*Opt)->OptId = OptId;
    (*Opt)->Len = Len;
    memcpy((*Opt)->Val, Val, Len);

    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptCleanup(
    IN OUT  PM_OPTION              Opt
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);

    MemFree(Opt);
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
LPBYTE      _inline
MemOptVal(
    IN      PM_OPTION              Opt
) {
    return Opt->Val;
}
//EndExport(inline)

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optclass.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for options, including class id
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <opt.h>
#include <optl.h>

//BeginExport(typedef)
typedef struct _M_ONECLASS_OPTLIST {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTLIST                      OptList;
} M_ONECLASS_OPTLIST, *PM_ONECLASS_OPTLIST, *LPM_ONECLASS_OPTLIST;

typedef struct _M_OPTCLASS {
    ARRAY                          Array;
} M_OPTCLASS, *PM_OPTCLASS, *LPM_OPTCLASS;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemOptClassInit(
    IN OUT  PM_OPTCLASS            OptClass
) {
    return MemArrayInit(&OptClass->Array);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptClassCleanup(
    IN OUT  PM_OPTCLASS            OptClass
) {
    // Bump down refcounts?
    return MemArrayCleanup(&OptClass->Array);
}
//EndExport(inline)

//BeginExport(function)
MemOptClassFindClassOptions(                      // find options for one particular class
    IN OUT  PM_OPTCLASS            OptClass,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTLIST            *OptList
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    PM_ONECLASS_OPTLIST            ThisOptList;
    DWORD                          Error;

    AssertRet(OptClass && OptList, ERROR_INVALID_PARAMETER);

    for( Error = MemArrayInitLoc(&OptClass->Array, &Location)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClass->Array, &Location)
    ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(
            &OptClass->Array,
            &Location,
            (LPVOID*)&ThisOptList
        );
        Require(ERROR_SUCCESS == Error && ThisOptList);

        if( ThisOptList->ClassId == ClassId &&
            ThisOptList->VendorId == VendorId ) {
            *OptList = &ThisOptList->OptList;
            return ERROR_SUCCESS;
        }
    }
    *OptList = NULL;
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemOptClassAddOption(
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PM_OPTION              Opt,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTION             *DeletedOpt
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTLIST                     ThisOptList;
    PM_ONECLASS_OPTLIST            ThisOneOptList;

    AssertRet(OptClass && Opt && DeletedOpt, ERROR_INVALID_PARAMETER);

    ThisOneOptList = NULL;
    (*DeletedOpt) = NULL;

    Error = MemOptClassFindClassOptions(OptClass,ClassId,VendorId,&ThisOptList);
    if( ERROR_SUCCESS != Error ) {
        ThisOneOptList = MemAlloc(sizeof(*ThisOneOptList));
        if( NULL == ThisOneOptList ) return ERROR_NOT_ENOUGH_MEMORY;

        // RefCount on ClassId has to go up?
        ThisOneOptList->ClassId = ClassId;
        ThisOneOptList->VendorId = VendorId;
        Error = MemOptListInit(&ThisOneOptList->OptList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisOneOptList);
            return Error;
        }

        Error = MemArrayAddElement(&OptClass->Array, ThisOneOptList);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisOneOptList);
            return Error;
        }

        ThisOptList = &ThisOneOptList->OptList;
    }

    Error = MemOptListAddOption(ThisOptList, Opt, DeletedOpt);

    return Error;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optdefl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of option definitions
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include <mm.h>
#include <array.h>
#include <wchar.h>

//BeginExport(typedef)
typedef struct _M_OPTDEF {
    DWORD                          OptId;
    DWORD                          Type;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    LPBYTE                         OptVal;
    DWORD                          OptValLen;
} M_OPTDEF, *PM_OPTDEF, *LPM_OPTDEF;

typedef struct _M_OPTDEFLIST {
    ARRAY                          OptDefArray;
} M_OPTDEFLIST, *PM_OPTDEFLIST, *LPM_OPTDEFLIST;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemOptDefListInit(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    AssertRet(OptDefList, ERROR_INVALID_PARAMETER);
    return MemArrayInit(&OptDefList->OptDefArray);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptDefListCleanup(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    return MemArrayCleanup(&OptDefList->OptDefArray);
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemOptDefListFindOptDefInternal(                  // Dont use this function out of optdefl.c
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // either OptId or OptName need only be specified..
    OUT     PARRAY_LOCATION        Location
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEF                      RetOptDef;

    Error = MemArrayInitLoc(&OptDefList->OptDefArray, Location);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptDefList->OptDefArray, Location, (LPVOID*)&RetOptDef);
        Require(ERROR_SUCCESS == Error);

        if( RetOptDef->OptId == OptId ) return ERROR_SUCCESS;
        if(OptName)
            if( 0 == wcscmp(RetOptDef->OptName, OptName) ) return ERROR_SUCCESS;
        Error = MemArrayNextLoc(&OptDefList->OptDefArray, Location);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(inline)
DWORD       _inline
MemOptDefListFindOptDef(
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // only either the name or the option id need be given..
    OUT     PM_OPTDEF             *OptDef
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        OptName,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    return MemArrayGetElement(
        &OptDefList->OptDefArray,
        &Location,
        (LPVOID *)OptDef
    );
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemOptDefListAddOptDef(                           // Add or replace an option defintion for given Option Id
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    PM_OPTDEF                      OptDef;
    PM_OPTDEF                      ThisOptDef;
    DWORD                          Size;
    DWORD                          Error;
    AssertRet(OptDefList, ERROR_INVALID_PARAMETER);

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        OptName,
        &Location
    );
    Require(ERROR_FILE_NOT_FOUND == Error || ERROR_SUCCESS == Error);

    Size = sizeof(M_OPTDEF) + OptValLen ;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    if( OptName ) Size += (1+wcslen(OptName))*sizeof(WCHAR);
    if( OptComment ) Size += (1+wcslen(OptComment))*sizeof(WCHAR);

    OptDef = MemAlloc(Size);
    if( NULL == OptDef ) return ERROR_NOT_ENOUGH_MEMORY;
    memcpy(sizeof(M_OPTDEF) +(LPBYTE)OptDef, OptVal, OptValLen);
    Size = sizeof(M_OPTDEF) + OptValLen ;
    Size = ROUND_UP_COUNT(Size, ALIGN_WORST);
    OptDef->OptVal = sizeof(M_OPTDEF) + (LPBYTE)OptDef;
    OptDef->OptValLen = OptValLen;
    OptDef->OptId = OptId;
    OptDef->Type  = Type;
    if( OptName ) {
        OptDef->OptName  = (LPWSTR)(Size + (LPBYTE)OptDef);
        wcscpy(OptDef->OptName, OptName);
        Size += sizeof(WCHAR)*(1 + wcslen(OptName));
    } else {
        OptDef->OptName = NULL;
    }

    if( OptComment) {
        OptDef->OptComment = (LPWSTR)(Size + (LPBYTE)OptDef);
        wcscpy(OptDef->OptComment, OptComment);
    } else {
        OptDef->OptComment = NULL;
    }

    if( ERROR_SUCCESS == Error ) {
        DebugPrint2("Overwriting option definition for 0x%lx\n", OptId);
        Error = MemArrayGetElement(
            &OptDefList->OptDefArray,
            &Location,
            (LPVOID*)&ThisOptDef
        );
        Require(ERROR_SUCCESS == Error && ThisOptDef);
        MemFree(ThisOptDef);

        Error = MemArraySetElement(
            &OptDefList->OptDefArray,
            &Location,
            (LPVOID)OptDef
        );
        Require(ERROR_SUCCESS==Error);
        return Error;
    }

    Error = MemArrayAddElement(
        &OptDefList->OptDefArray,
        (LPVOID)OptDef
    );

    if( ERROR_SUCCESS != Error ) MemFree(OptDef);

    return Error;
}

//BeginExport(inline)
DWORD       _inline
MemOptDefListDelOptDef(
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_OPTDEF                      OptDef;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayDelElement(
        &OptDefList->OptDefArray,
        &Location,
        &OptDef
    );
    Require(ERROR_SUCCESS == Error && OptDef);

    MemFree(OptDef);
    return ERROR_SUCCESS;
}
//EndExport(inline)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\opt.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_OPTION {
    DWORD                          OptId;
    DWORD                          Len;
    BYTE                           Val[0];
} M_OPTION, *PM_OPTION, *LP_MOPTION;


DWORD       _inline
MemOptInit(
    OUT     PM_OPTION             *Opt,
    IN      DWORD                  OptId,
    IN      DWORD                  Len,
    IN      LPBYTE                 Val
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);
    AssertRet(Len || NULL==Val, ERROR_INVALID_PARAMETER);
    AssertRet(0 == Len|| Val, ERROR_INVALID_PARAMETER);

    (*Opt) = MemAlloc(sizeof(M_OPTION)+Len);
    if( NULL == (*Opt) ) return ERROR_NOT_ENOUGH_MEMORY;

    (*Opt)->OptId = OptId;
    (*Opt)->Len = Len;
    memcpy((*Opt)->Val, Val, Len);

    return ERROR_SUCCESS;
}


DWORD       _inline
MemOptCleanup(
    IN OUT  PM_OPTION              Opt
) {
    AssertRet(Opt, ERROR_INVALID_PARAMETER);

    MemFree(Opt);
    return ERROR_SUCCESS;
}


LPBYTE      _inline
MemOptVal(
    IN      PM_OPTION              Opt
) {
    return Opt->Val;
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optclass.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_ONECLASS_OPTLIST {
    DWORD                          ClassId;
    DWORD                          VendorId;
    M_OPTLIST                      OptList;
} M_ONECLASS_OPTLIST, *PM_ONECLASS_OPTLIST, *LPM_ONECLASS_OPTLIST;

typedef struct _M_OPTCLASS {
    ARRAY                          Array;
} M_OPTCLASS, *PM_OPTCLASS, *LPM_OPTCLASS;


DWORD       _inline
MemOptClassInit(
    IN OUT  PM_OPTCLASS            OptClass
) {
    return MemArrayInit(&OptClass->Array);
}


DWORD       _inline
MemOptClassCleanup(
    IN OUT  PM_OPTCLASS            OptClass
) {
    // Bump down refcounts?
    return MemArrayCleanup(&OptClass->Array);
}


MemOptClassFindClassOptions(                      // find options for one particular class
    IN OUT  PM_OPTCLASS            OptClass,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTLIST            *OptList
) ;


DWORD
MemOptClassAddOption(
    IN OUT  PM_OPTCLASS            OptClass,
    IN      PM_OPTION              Opt,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    OUT     PM_OPTION             *DeletedOpt
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef     ARRAY                  M_OPTLIST;
typedef     PARRAY                 PM_OPTLIST;
typedef     LPARRAY                LPM_OPTLIST;


DWORD       _inline
MemOptListInit(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayInit(OptList);
}


DWORD       _inline
MemOptListCleanup(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayCleanup(OptList);
}


DWORD       _inline
MemOptListAddOption(                              // Add or replace an option
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt,
    OUT     PM_OPTION             *DeletedOpt     // OPTIONAL: old option or NULL
) // EndExport(function)
{ // if DeletedOpt is NULL, then the option would just be freed.
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_OPTION                      ThisOpt;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER);

    if( DeletedOpt ) *DeletedOpt  = NULL;
    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)&ThisOpt);
        Require(ERROR_SUCCESS == Error );
        Require(ThisOpt);

        if( ThisOpt->OptId == Opt->OptId ) {
            Error = MemArraySetElement(OptList, &Loc, (LPVOID)Opt);
            Require(ERROR_SUCCESS == Error);

            if( DeletedOpt ) (*DeletedOpt) = ThisOpt;
            else MemOptCleanup(ThisOpt);

            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    Error = MemArrayAddElement(OptList, (LPVOID)Opt);
    return Error;
}


//BeginExport(inline)

DWORD       _inline
MemOptListAddAnotherOption(                       // add without checking for duplicates
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt
) {
    return MemArrayAddElement(OptList, (LPVOID)Opt);
}


DWORD       _inline
MemOptListFindOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId,
    OUT     PM_OPTION             *Opt
) {
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)Opt);
        Require(ERROR_SUCCESS == Error);
        Require(*Opt);

        if( (*Opt)->OptId == OptId )
            return ERROR_SUCCESS;

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    *Opt = NULL;
    return ERROR_FILE_NOT_FOUND;
}


DWORD
MemOptListDelOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId
) ;


DWORD       _inline
MemOptListSize(
    IN      PM_OPTLIST             OptList
) {
    return MemArraySize(OptList);
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optl.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a list of options
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================

#include    <mm.h>
#include    <opt.h>
#include    <array.h>

//BeginExport(typedef)
typedef     ARRAY                  M_OPTLIST;
typedef     PARRAY                 PM_OPTLIST;
typedef     LPARRAY                LPM_OPTLIST;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemOptListInit(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayInit(OptList);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptListCleanup(
    IN OUT  PM_OPTLIST             OptList
) {
    return MemArrayCleanup(OptList);
}
//EndExport(inline)

//BeginExport(function)
DWORD       _inline
MemOptListAddOption(                              // Add or replace an option
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt,
    OUT     PM_OPTION             *DeletedOpt     // OPTIONAL: old option or NULL
) // EndExport(function)
{ // if DeletedOpt is NULL, then the option would just be freed.
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_OPTION                      ThisOpt;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER);

    if( DeletedOpt ) *DeletedOpt  = NULL;
    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)&ThisOpt);
        Require(ERROR_SUCCESS == Error );
        Require(ThisOpt);

        if( ThisOpt->OptId == Opt->OptId ) {
            Error = MemArraySetElement(OptList, &Loc, (LPVOID)Opt);
            Require(ERROR_SUCCESS == Error);

            if( DeletedOpt ) (*DeletedOpt) = ThisOpt;
            else MemOptCleanup(ThisOpt);

            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    Error = MemArrayAddElement(OptList, (LPVOID)Opt);
    return Error;
}


//BeginExport(inline)
DWORD       _inline
MemOptListAddAnotherOption(                       // add without checking for duplicates
    IN OUT  PM_OPTLIST             OptList,
    IN      PM_OPTION              Opt
) {
    return MemArrayAddElement(OptList, (LPVOID)Opt);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemOptListFindOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId,
    OUT     PM_OPTION             *Opt
) {
    ARRAY_LOCATION