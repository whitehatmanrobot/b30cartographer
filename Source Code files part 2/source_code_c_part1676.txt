
        if (wY > MAX_REL_Y_MOVEMENT)
            w = MAX_REL_Y_MOVEMENT;
        else
            w = wY;

        SetRelYSub(lpXPDV, w, FALSE);
        wY -= w;
    }
#endif
}

/*
 *  Relative up movement
 */
VOID SetRelUp(LPEXTPDEV lpXPDV, WORD wY)
{
    WORD w;

#ifdef  USE_MASTERUNIT
    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
    while (wY > 0)
    {
        if (wY > MAX_REL_Y_MOVEMENT)
            w = MAX_REL_Y_MOVEMENT;
        else
            w = wY;

        SetRelYSub(lpXPDV, w, TRUE);
        wY -= w;
    }
}

/*
 *  Set absolute X and Y coordinate
 */
VOID SetAbsXY(LPEXTPDEV lpXPDV, WORD wX, WORD wY)
{
    BYTE tmp[4];

    myCmd(lpXPDV, "\x1B\x5C\x39", 3);

#ifdef  USE_MASTERUNIT
    wX = wX / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
	tmp[0] = HIBYTE(wX) | 0x80;
	tmp[1] = LOBYTE(wX);
	tmp[2] = HIBYTE(wY);
	tmp[3] = LOBYTE(wY);
    myCmd(lpXPDV, tmp, 4);
}

/*
 *  Set relative X and Y coordinate
 */
VOID SetRelXY(LPEXTPDEV lpXPDV, WORD wX, WORD wY)
{
    BYTE tmp[4];

    myCmd(lpXPDV, "\x1B\x5C\x30", 3);

#ifdef  USE_MASTERUNIT
    wX = wX / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
	tmp[0] = HIBYTE(wX) | 0x80;
	tmp[1] = LOBYTE(wX);
	tmp[2] = HIBYTE(wY);
	tmp[3] = LOBYTE(wY);
    myCmd(lpXPDV, tmp, 4);
}

/*
 *  Set absolute X movement
 */
VOID SetAbsX(LPEXTPDEV lpXPDV, WORD wX)
{
    BYTE tmp[4];
    WORD w, t;
    int i;

#ifdef  USE_MASTERUNIT
    wX = wX / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT

    while (wX > 0)
    {
        if (wX > 9999)
            w = 9999;
        else
            w = wX;

        wX -= w;

        myCmd(lpXPDV, "\x1B\x46", 2);
    	for (t = 1000, i = 0; i < 4; i++)
    	{
            tmp[i] = (BYTE)(w / t) + 0x30;
            w = w % t;
            t = t / 10;
        }
        myCmd(lpXPDV, tmp, 4);
    }
}

/*
 *  Send a block(rectangle image)
 */
VOID SetSendBlock(LPEXTPDEV lpXPDV, WORD wHeight, WORD wWidthBytes)
{
    BYTE tmp[4];

    myCmd(lpXPDV, "\x1B\x77", 2);
	tmp[0] = HIBYTE(wWidthBytes);
	tmp[1] = LOBYTE(wWidthBytes);
	tmp[2] = HIBYTE(wHeight);
	tmp[3] = LOBYTE(wHeight);
    myCmd(lpXPDV, tmp, 4);
}

/*
 *  Composes printer commands at run-time based on some dynamic information.
 */
VOID FAR PASCAL OEMOutputCmd(lpdv, wCmdCbld, lpdwParams)
LPDV    lpdv;
WORD    wCmdCbld;
LPDWORD lpdwParams;
{
    LPEXTPDEV lpXPDV;

    if (!(lpXPDV = ((LPEXTPDEV)lpdv->lpMd)))
        return;

    lpXPDV->wCmdLen = 0;

    if ((wCmdCbld >= CMD_ID_TRAY_1) &&
        (wCmdCbld <= CMD_ID_TRAY_AUTO))
    {
        lpXPDV->wTray = wCmdCbld;
    }
    else
    if ((wCmdCbld >= CMD_ID_PAPER_A3) &&
        (wCmdCbld <= CMD_ID_PAPER_LEGAL))
    {
        lpXPDV->wPaper = wCmdCbld;

        SetTrayPaper(lpXPDV);
    }
    else
    if (wCmdCbld == CMD_ID_COPYCOUNT)
    {
        WORD copies;

        copies = LOWORD(*lpdwParams);
        if (copies < 1)
            copies = 1;
        if (copies > 99)
            copies = 99;

        lpXPDV->wCopyCount = copies;

        SetCopyCount(lpXPDV);
    }
    else
    if ((wCmdCbld == CMD_ID_RES240) ||
        (wCmdCbld == CMD_ID_RES400))
    {
        lpXPDV->wRes = wCmdCbld;

        SetResolution(lpXPDV);
    }
    else
    if (wCmdCbld == CMD_ID_BEGIN_PAGE)
    {
        lpXPDV->wFont = 0;

        SetVert(lpXPDV, FALSE, TRUE);
        SetAbsXY(lpXPDV, 0, 0);
    }
    else
    if (wCmdCbld == CMD_ID_XM_REL)
    {
        SetRelX(lpXPDV, LOWORD(*lpdwParams));
    }
    else
    if (wCmdCbld == CMD_ID_XM_RELLEFT)
    {
        SetRelLeft(lpXPDV, LOWORD(*lpdwParams));
    }
    else
    if (wCmdCbld == CMD_ID_YM_REL)
    {
        SetRelY(lpXPDV, LOWORD(*lpdwParams));
    }
    else
    if (wCmdCbld == CMD_ID_YM_RELUP)
    {
        SetRelUp(lpXPDV, LOWORD(*lpdwParams));
    }
    else
    if (wCmdCbld == CMD_ID_XY_ABS)
    {
        SetAbsXY(lpXPDV, LOWORD(*lpdwParams), LOWORD(*(lpdwParams+1)));
    }
    else
    if (wCmdCbld == CMD_ID_XY_REL)
    {
        SetRelXY(lpXPDV, LOWORD(*lpdwParams), LOWORD(*(lpdwParams+1)));
    }
    else
    if (wCmdCbld == CMD_ID_XM_ABS)
    {
        SetAbsX(lpXPDV, LOWORD(*lpdwParams));
    }
    else
    if ((wCmdCbld == CMD_ID_SEND_BLOCK240) ||
        (wCmdCbld == CMD_ID_SEND_BLOCK400))
    {
        lpXPDV->wBlockHeight = LOWORD(*(lpdwParams+1));
        lpXPDV->wBlockWidth  = LOWORD(*(lpdwParams+2)) * 8;

        SetSendBlock(lpXPDV, LOWORD(*(lpdwParams+1)), LOWORD(*(lpdwParams+2)));
    }
    else
    if (wCmdCbld == CMD_ID_END_BLOCK)
    {
#if 0   //RES_CUR_Y_POS_AUTO
        WORD wY = 1;

#ifdef  USE_MASTERUNIT
        wY = wY * (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
        SetRelY(lpXPDV, wY);
#else
        WORD wHeight;

        wHeight = lpXPDV->wBlockHeight - 1;
        if (wHeight)
        {
#ifdef  USE_MASTERUNIT
            wHeight = wHeight * (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
            SetRelUp(lpXPDV, wHeight);
        }
#endif
    }
//    else
//    if (wCmdCbld == CMD_ID_VERT_ON)
//    {
//        SetVert(lpXPDV, TRUE, FALSE);
//    }
//    else
//    if (wCmdCbld == CMD_ID_VERT_OFF)
//    {
//        SetVert(lpXPDV, FALSE, FALSE);
//    }
    else
    if (wCmdCbld == CMD_ID_BEGIN_GRAPH)
    {
        SetVert(lpXPDV, FALSE, FALSE);
    }

    if (lpXPDV->wCmdLen)
    {
        WriteSpoolBuf(lpdv, (LPSTR)lpXPDV->rgCmd, lpXPDV->wCmdLen);
        lpXPDV->wCmdLen = 0;
    }
}

#ifndef NOOEMGETFONTCMD
/*
 *  Composes font selection commands at run-time based on some dynamic 
 *  information.
 */
BOOL FAR PASCAL OEMGetFontCmd(lpdv, wCmdCbld, lpFont, fSelect, lpBuf, lpwSize)
LPDV        lpdv;
WORD        wCmdCbld;
LPFONTINFO  lpFont;
BOOL        fSelect;
LPBYTE      lpBuf;
LPWORD      lpwSize;
{
    return FALSE;
}
#endif

#ifndef NODOWNLOADFONTHEADER
/*
 *  Provides a font header command for downloading TrueType fonts.
 */
VOID FAR PASCAL DownloadFontHeader(lpdv, lpFont, lpwWidths, id)
LPDV        lpdv;
LPFONTINFO  lpFont;
LPWORD      lpwWidths;
WORD        id;
{
}
#endif

#ifndef NOOEMDOWNLOADCHAR
/*
 *  Downloads a character bitmap for a TrueType font.
 */
VOID FAR PASCAL OEMDownloadChar(lpdv, lpFont, id, cp, wCharWidth,
                                lpbmm, lpBitmap, dwBmpSize)
LPDV            lpdv;
LPFONTINFO      lpFont;
WORD            id;
WORD            cp;
WORD            wCharWidth;
//LPBITMAPMETRICS lpbmm;
VOID FAR *      lpbmm;
//LPDIBITS        lpBitmap;
VOID FAR *      lpBitmap;
DWORD           dwBmpSize;
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)



//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FXME'
#define DLLTEXT(s)      "FXME: " s
#define OEM_VERSION      0x00010000L

// private definitions
#define MAXBUFLEN               256
#define MAX_REL_Y_MOVEMENT      256
#define FONT_ID_MIN             1
#define FONT_ID_MIN_V           2
#define FONT_ID_GOT             3
#define FONT_ID_GOT_V           4
#define FONT_ID_MAX             4
#define FONT_MINCHO             1
#define FONT_GOTHIC             2

// Identify for output command
#define CMD_ID_TRAY_1           1
#define CMD_ID_TRAY_2           2
#define CMD_ID_TRAY_MANUAL      3
#define CMD_ID_TRAY_AUTO        4

#define CMD_ID_PAPER_A3         5
#define CMD_ID_PAPER_B4         6
#define CMD_ID_PAPER_A4         7
#define CMD_ID_PAPER_B5         8
#define CMD_ID_PAPER_A5         9
#define CMD_ID_PAPER_HAGAKI     10
#define CMD_ID_PAPER_LETTER     11
#define CMD_ID_PAPER_LEGAL      12

#define CMD_ID_COPYCOUNT        13
#define CMD_ID_RES240           14
#define CMD_ID_RES400           15

#define CMD_ID_BEGIN_PAGE       19
#define CMD_ID_END_PAGE         20
#define CMD_ID_SEND_BLOCK240    21
#define CMD_ID_SEND_BLOCK400    22
#define CMD_ID_VERT_ON          25
#define CMD_ID_VERT_OFF         26
#define CMD_ID_BEGIN_GRAPH      27
#define CMD_ID_END_GRAPH        28
#define CMD_ID_END_BLOCK        29

#define CMD_ID_XM_ABS           30
#define CMD_ID_YM_ABS           31
#define CMD_ID_X_REL_RIGHT      32
#define CMD_ID_X_REL_LEFT       33
#define CMD_ID_Y_REL_DOWN       34
#define CMD_ID_Y_REL_UP         35

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;

    // Private extention
    WORD        wCopyCount;
    WORD        wTray;
    WORD        wPaper;
    WORD        wRes;
    BOOL        fVert;
    WORD        wFont;
    WORD        wBlockHeight;
    WORD        wBlockWidth;
} OEM_EXTRADATA, *POEM_EXTRADATA;

VOID SetTrayPaper(PDEVOBJ);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\etc\libinit.asm ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

	page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBENTRY.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286p
	.xlist
	include cmacros.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externFP    LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
%out link me first!!
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd
sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\etc\fx4103me.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

// FX4103ME.H

#define LPDV_DEFINED

// documented part of UNIDRV.DLL's PDEVICE
typedef struct
{
    short       iType;
    short       oBruteHdr;
    HANDLE      hMd;
    LPSTR       lpMd;
} PDEVICE, FAR * LPDV;

// private definitions
#define BUFLEN                  256
#define MAX_REL_Y_MOVEMENT      256
#define FONT_ID_MIN             1
#define FONT_ID_MIN_V           2
#define FONT_ID_GOT             3
#define FONT_ID_GOT_V           4
#define FONT_ID_MAX             4
#define FONT_MINCHO             1
#define FONT_GOTHIC             2

// private data
typedef struct
{
    WORD        wCopyCount;
    WORD        wTray;
    WORD        wPaper;
    WORD        wRes;

    BOOL        fVert;
    WORD        wFont;

    WORD        wBlockHeight;
    WORD        wBlockWidth;

    WORD        wCmdLen;
    BYTE        rgCmd[BUFLEN*2];

    BYTE        DeviceName[CCHDEVICENAME];
} EXTPDEV, FAR * LPEXTPDEV;

// function prottypes
WORD FAR PASCAL CBFilterGraphics(LPBYTE, LPSTR, WORD);
VOID FAR PASCAL OEMOutputChar(LPDV, LPSTR, WORD , SHORT);

// for scalable font (moved from DDK sample for ESCPAGE)
#define SHIFTJIS_CHARSET 128
#define CCHMAXCMDLEN 128
typedef struct
{
  BYTE  fGeneral;       // General purpose bitfield
  BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
  WORD  wCount;         // # of EXTCD structures following
  WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

// Identify for output command
#define CMD_ID_TRAY_1           1
#define CMD_ID_TRAY_2           2
#define CMD_ID_TRAY_MANUAL      3
#define CMD_ID_TRAY_AUTO        4
#define CMD_ID_PAPER_A3         5
#define CMD_ID_PAPER_B4         6
#define CMD_ID_PAPER_A4         7
#define CMD_ID_PAPER_B5         8
#define CMD_ID_PAPER_A5         9
#define CMD_ID_PAPER_HAGAKI     10
#define CMD_ID_PAPER_LETTER     11
#define CMD_ID_PAPER_LEGAL      12
#define CMD_ID_COPYCOUNT        13
#define CMD_ID_RES240           14
#define CMD_ID_RES400           15
#define CMD_ID_XM_REL           16
#define CMD_ID_YM_REL           17
#define CMD_ID_XY_ABS           18
#define CMD_ID_BEGIN_PAGE       19
#define CMD_ID_END_PAGE         20
#define CMD_ID_SEND_BLOCK240    21
#define CMD_ID_SEND_BLOCK400    22
#define CMD_ID_XM_RELLEFT       23
#define CMD_ID_YM_RELUP         24
#define CMD_ID_VERT_ON          25
#define CMD_ID_VERT_OFF         26
#define CMD_ID_BEGIN_GRAPH      27
#define CMD_ID_END_GRAPH        28
#define CMD_ID_END_BLOCK        29
#define CMD_ID_XY_REL           30
#define CMD_ID_XM_ABS           31

// callback definitions
#define NOCBFILTERGRAPHICS
#define NOOEMOUTPUTCHAR
#define NODOWNLOADFONTHEADER
#define NOOEMDOWNLOADCHAR

// other definitions
#define USE_MASTERUNIT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\etc\minidriv.c ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

#define PRINTDRIVER
#define BUILDDLL
#include "print.h"
#include "gdidefs.inc"
#include "fx4103me.h"
#include "mdevice.h"
#include "unidrv.h"
extern char *rgchModuleName;    // global module name

#ifndef NOCONTROL
short WINAPI Control(lpdv, function, lpInData, lpOutData)
LPDV    lpdv;
WORD    function;
LPSTR   lpInData;
LPSTR   lpOutData;
{
    return UniControl(lpdv, function, lpInData, lpOutData);
}
#endif

#ifndef NODEVBITBLT
BOOL WINAPI DevBitBlt(lpdv, DstxOrg, DstyOrg, lpSrcDev, SrcxOrg, SrcyOrg,
                    xExt, yExt, lRop, lpPBrush, lpDrawmode)
LPDV        lpdv;           // --> to destination bitmap descriptor
short       DstxOrg;        // Destination origin - x coordinate
short       DstyOrg;        // Destination origin - y coordinate
LPBITMAP    lpSrcDev;       // --> to source bitmap descriptor
short       SrcxOrg;        // Source origin - x coordinate
short       SrcyOrg;        // Source origin - y coordinate
WORD        xExt;           // x extent of the BLT
WORD        yExt;           // y extent of the BLT
long        lRop;           // Raster operation descriptor
LPPBRUSH    lpPBrush;       // --> to a physical brush (pattern)
LPDRAWMODE  lpDrawmode;
{
    return UniBitBlt(lpdv, DstxOrg, DstyOrg, lpSrcDev, SrcxOrg, SrcyOrg,
                    xExt, yExt, lRop, lpPBrush, lpDrawmode);
}
#endif

#ifndef NODEVSTRETCHBLT
WORD WINAPI DevStretchBlt(lpdv, DstxOrg, DstyOrg, DstXExt, DstYExt, 
                          lpSrcDev, SrcxOrg, SrcyOrg, xExt, yExt, 
                          lRop, lpPBrush, lpDrawmode, lpClip)
LPDV        lpdv;           // --> to destination bitmap descriptor
short       DstxOrg;        // Destination origin - x coordinate
short       DstyOrg;        // Destination origin - y coordinate
WORD        DstXExt;
WORD        DstYExt;
LPBITMAP    lpSrcDev;       // --> to source bitmap descriptor
short       SrcxOrg;        // Source origin - x coordinate
short       SrcyOrg;        // Source origin - y coordinate
WORD        xExt;           // x extent of the BLT
WORD        yExt;           // y extent of the BLT
long        lRop;           // Raster operation descriptor
LPPBRUSH    lpPBrush;       // --> to a physical brush (pattern)
LPDRAWMODE  lpDrawmode;
LPRECT      lpClip;
{
    return UniStretchBlt(lpdv, DstxOrg, DstyOrg, DstXExt, DstYExt, 
                         lpSrcDev, SrcxOrg, SrcyOrg, xExt, yExt, 
                         lRop, lpPBrush, lpDrawmode, lpClip);
}
#endif

#ifndef NOPIXEL
DWORD WINAPI Pixel(lpdv, x, y, Color, lpDrawMode)
LPDV        lpdv;
short       x;
short       y;
DWORD       Color;
LPDRAWMODE  lpDrawMode;
{
    return UniPixel(lpdv, x, y, Color, lpDrawMode);
}
#endif

#ifndef NOOUTPUT
short WINAPI Output(lpdv, style, count, lpPoints, lpPPen, lpPBrush, lpDrawMode, lpCR)
LPDV        lpdv;       // --> to the destination
WORD        style;      // Output operation
WORD        count;      // # of points
LPPOINT     lpPoints;   // --> to a set of points
LPVOID      lpPPen;     // --> to physical pen
LPPBRUSH    lpPBrush;   // --> to physical brush
LPDRAWMODE  lpDrawMode; // --> to a Drawing mode
LPRECT      lpCR;       // --> to a clipping rectange if <> 0
{
    return UniOutput(lpdv, style, count, lpPoints, lpPPen, lpPBrush, lpDrawMode, lpCR);
}
#endif

#ifndef NOSTRBLT
DWORD WINAPI StrBlt(lpdv, x, y, lpCR, lpStr, count, lpFont, lpDrawMode, lpXform)
LPDV        lpdv;
short       x;
short       y;
LPRECT      lpCR;
LPSTR       lpStr;
int         count;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;           // includes background mode and bkColor
LPTEXTXFORM lpXform;
{
    // StrBlt is never called by GDI.
    // Keep a stub function here so nobody complains.
    //
    return 0;
}
#endif

#ifndef NOSCANLR
short WINAPI ScanLR(lpdv, x, y, Color, DirStyle)
LPDV    lpdv;
short   x;
short   y;
DWORD   Color;
WORD    DirStyle;
{
    // ScanLR is only called for RASDISPLAY devices.
    // Keep a stub function here so nobody complains.
    //
    return 0;
}
#endif

#ifndef NOENUMOBJ
short WINAPI EnumObj(lpdv, style, lpCallbackFunc, lpClientData)
LPDV    lpdv;
WORD    style;
FARPROC lpCallbackFunc;
LPVOID  lpClientData;
{
    return UniEnumObj(lpdv, style, lpCallbackFunc, lpClientData);
}
#endif

#ifndef NOCOLORINFO
DWORD WINAPI ColorInfo(lpdv, ColorIn, lpPhysBits)
LPDV    lpdv;
DWORD   ColorIn;
LPDWORD lpPhysBits;
{

    return UniColorInfo(lpdv, ColorIn, lpPhysBits);
}
#endif

#ifndef NODEVICEMODE
void WINAPI DeviceMode(hWnd, hInst, lpDevName, lpPort)
HWND    hWnd;
HANDLE  hInst;
LPSTR   lpDevName;
LPSTR   lpPort;
{
    UniDeviceMode(hWnd, hInst, lpDevName, lpPort);
}
#endif

#ifndef NOREALIZEOBJECT
DWORD WINAPI RealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm)
LPDV        lpdv;
short       sStyle;
LPSTR       lpInObj;
LPSTR       lpOutObj;
LPTEXTXFORM lpTextXForm;
{
    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}
#endif

#ifndef NOENUMDFONTS
short WINAPI EnumDFonts(lpdv, lpFaceName, lpCallbackFunc, lpClientData)
LPDV    lpdv;
LPSTR   lpFaceName;
FARPROC lpCallbackFunc;
LPVOID  lpClientData;
{
    return UniEnumDFonts(lpdv, lpFaceName, lpCallbackFunc, lpClientData);
}
#endif

#ifndef NOENABLE
short WINAPI Enable(lpdv, style, lpModel, lpPort, lpStuff)
LPDV    lpdv;
WORD    style;
LPSTR   lpModel;
LPSTR   lpPort;
LPDM    lpStuff;
{
    CUSTOMDATA  cd;
    short sRet;
    LPEXTPDEV lpXPDV;

    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
    cd.fnOEMDump = NULL;
#ifndef NOOEMOUTPUTCHAR
    cd.fnOEMOutputChar = (LPFNOEMOUTPUTCHAR)OEMOutputChar;
#else
    cd.fnOEMOutputChar = NULL;
#endif

    if (!(sRet = UniEnable(lpdv, style, lpModel, lpPort, lpStuff, &cd)))
        return (sRet);

    // Allocate private PDEVICE
    if (style == 0)
    {
        // allocate space for our private data
        if (!(lpdv->hMd = GlobalAlloc(GHND, sizeof(EXTPDEV))))
            return 0;

        lpdv->lpMd = GlobalLock(lpdv->hMd);

        if ((lpXPDV = ((LPEXTPDEV)lpdv->lpMd)) != NULL)
        {
            DWORD dwType, dwData;

            // Get a printer model name
            DrvGetPrinterData(lpModel, (LPSTR)INT_PD_PRINTER_MODEL,
                                &dwType, (LPSTR)lpXPDV->DeviceName,
                                sizeof(lpXPDV->DeviceName), (LPDWORD)&dwData);
        }
    }

    return sRet;
}
#endif

#ifndef NODISABLE
void WINAPI Disable(lpdv)
LPDV lpdv;
{
    // if allocated private PDEVICE data
    if (lpdv->hMd)
    {
        // free private PDEVICE buffer
        GlobalUnlock(lpdv->hMd);
        GlobalFree(lpdv->hMd);
    }
    UniDisable(lpdv);
}
#endif

#ifndef NODEVEXTTEXTOUT
DWORD WINAPI DevExtTextOut(lpdv, x, y, lpCR, lpStr, count, lpFont,
                        lpDrawMode, lpXform, lpWidths, lpOpaqRect, options)
LPDV        lpdv;
short       x;
short       y;
LPRECT      lpCR;
LPSTR       lpStr;
int         count;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;
LPTEXTXFORM lpXform;
LPSHORT     lpWidths;
LPRECT      lpOpaqRect;
WORD        options;
{
    return(UniExtTextOut(lpdv, x, y, lpCR, lpStr, count, lpFont,
                        lpDrawMode, lpXform, lpWidths, lpOpaqRect, options));
}
#endif

#ifndef NODEVGETCHARWIDTH
short WINAPI DevGetCharWidth(lpdv, lpBuf, chFirst, chLast, lpFont, lpDrawMode,
                        lpXForm)
LPDV        lpdv;
LPSHORT     lpBuf;
WORD        chFirst;
WORD        chLast;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;
LPTEXTXFORM lpXForm;
{
    return(UniGetCharWidth(lpdv, lpBuf, chFirst, chLast, lpFont,lpDrawMode,
                          lpXForm));
}
#endif

#ifndef NODEVICEBITMAP
short WINAPI DeviceBitmap(lpdv, command, lpBitMap, lpBits)
LPDV     lpdv;
WORD     command;
LPBITMAP lpBitMap;
LPSTR    lpBits;
{
    return 0;
}
#endif

#ifndef NOFASTBORDER
short WINAPI FastBorder(lpRect, width, depth, lRop, lpdv, lpPBrush,
                                          lpDrawmode, lpCR)
LPRECT  lpRect;
short   width;
short   depth;
long    lRop;
LPDV    lpdv;
long    lpPBrush;
long    lpDrawmode;
LPRECT  lpCR;
{
    return 0;
}
#endif

#ifndef NOSETATTRIBUTE
short WINAPI SetAttribute(lpdv, statenum, index, attribute)
LPDV    lpdv;
WORD    statenum;
WORD    index;
WORD    attribute;
{
    return 0;
}
#endif

#ifndef NODEVMODE
int WINAPI ExtDeviceMode(hWnd, hInst, lpdmOut, lpDevName, lpPort,
                              lpdmIn, lpProfile, wMode)
HWND    hWnd;           // parent for DM_PROMPT dialog box
HANDLE  hInst;          // handle from LoadLibrary()
LPDM    lpdmOut;        // output DEVMODE for DM_COPY
LPSTR   lpDevName;      // device name
LPSTR   lpPort;         // port name
LPDM    lpdmIn;         // input DEVMODE for DM_MODIFY
LPSTR   lpProfile;      // alternate .INI file
WORD    wMode;          // operation(s) to carry out
{
    return UniExtDeviceMode(hWnd, hInst, lpdmOut, lpDevName, lpPort, lpdmIn,
                           lpProfile, wMode);
}
#endif

#ifndef WANT_WIN30
#ifndef NODMPS
int WINAPI ExtDeviceModePropSheet(hWnd, hInst, lpDevName, lpPort,
                              dwReserved, lpfnAdd, lParam)
HWND                 hWnd;        // Parent window for dialog
HANDLE               hInst;       // handle from LoadLibrary()
LPSTR                lpDevName;   // friendly name
LPSTR                lpPort;      // port name
DWORD                dwReserved;  // for future use
LPFNADDPROPSHEETPAGE lpfnAdd;     // Callback to add dialog page
LPARAM               lParam;      // Pass to callback
{
    return UniExtDeviceModePropSheet(hWnd, hInst, lpDevName, lpPort,
                                     dwReserved, lpfnAdd, lParam);
}
#endif
#endif

#ifndef NODEVICECAPABILITIES
DWORD WINAPI DeviceCapabilities(lpDevName, lpPort, wIndex, lpOutput, lpdm)
LPSTR   lpDevName;
LPSTR   lpPort;
WORD    wIndex;
LPSTR   lpOutput;
LPDM    lpdm;
{
    return(UniDeviceCapabilities(lpDevName, lpPort, wIndex, lpOutput, lpdm,
                    GetModuleHandle((LPSTR)rgchModuleName)));
}
#endif

#ifndef NOADVANCEDSETUPDIALOG
LONG WINAPI AdvancedSetUpDialog(hWnd, hInstMiniDrv, lpdmIn, lpdmOut)
HWND    hWnd;
HANDLE  hInstMiniDrv;   // handle of the driver module
LPDM    lpdmIn;         // initial device settings
LPDM    lpdmOut;        // final device settings
{
    return(UniAdvancedSetUpDialog(hWnd, hInstMiniDrv, lpdmIn, lpdmOut));
}
#endif

#ifndef NODIBBLT
short WINAPI DIBBLT(lpBmp, style, iStart, sScans, lpDIBits,
                        lpBMI, lpDrawMode, lpConvInfo)
LPBITMAP      lpBmp;
WORD          style;
WORD          iStart;
WORD          sScans;
LPSTR         lpDIBits;
LPBITMAPINFO  lpBMI;
LPDRAWMODE    lpDrawMode;
LPSTR         lpConvInfo;
{
    return(UniDIBBlt(lpBmp, style, iStart, sScans, lpDIBits,
                     lpBMI, lpDrawMode, lpConvInfo));
}
#endif

#ifndef NOCREATEDIBITMAP
short WINAPI CreateDIBitmap()
{
    // CreateDIBitmap is never called by GDI.
    // Keep a stub function here so nobody complains.
    //
    return(0);
}
#endif

#ifndef NOSETDIBITSTODEVICE
short WINAPI SetDIBitsToDevice(lpdv, DstXOrg, DstYOrg, StartScan, NumScans,
                         lpCR, lpDrawMode, lpDIBits, lpDIBHdr, lpConvInfo)
LPDV                lpdv;
WORD                DstXOrg;
WORD                DstYOrg;
WORD                StartScan;
WORD                NumScans;
LPRECT              lpCR;
LPDRAWMODE          lpDrawMode;
LPSTR               lpDIBits;
LPBITMAPINFOHEADER  lpDIBHdr;
LPSTR               lpConvInfo;
{
    return(UniSetDIBitsToDevice(lpdv, DstXOrg, DstYOrg, StartScan, NumScans,
                         lpCR, lpDrawMode, lpDIBits, lpDIBHdr, lpConvInfo));
}
#endif

#ifndef NOSTRETCHDIB
int WINAPI StretchDIB(lpdv, wMode, DstX, DstY, DstXE, DstYE,
                SrcX, SrcY, SrcXE, SrcYE, lpBits, lpDIBHdr,
                lpConvInfo, dwRop, lpbr, lpdm, lpClip)
LPDV                lpdv;
WORD                wMode;
short               DstX, DstY, DstXE, DstYE;
short               SrcX, SrcY, SrcXE, SrcYE;
LPSTR               lpBits;             /* pointer to DIBitmap Bits */
LPBITMAPINFOHEADER  lpDIBHdr;           /* pointer to DIBitmap info Block */
LPSTR               lpConvInfo;         /* not used */
DWORD               dwRop;
LPPBRUSH            lpbr;
LPDRAWMODE          lpdm;
LPRECT              lpClip;
{
    return(UniStretchDIB(lpdv, wMode, DstX, DstY, DstXE, DstYE,
                SrcX, SrcY, SrcXE, SrcYE, lpBits, lpDIBHdr,
                lpConvInfo, dwRop, lpbr, lpdm, lpClip));
}
#endif

#if 0   // nobody is calling this DDI. Deleted.

#ifndef NOQUERYDEVICENAMES
long WINAPI QueryDeviceNames(lprgDeviceNames)
LPSTR   lprgDeviceNames;
{
    return UniQueryDeviceNames(GetModuleHandle(rgchModuleName),
                              lprgDeviceNames);
}
#endif
#endif

#ifndef NODEVINSTALL
int WINAPI DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND    hWnd;
LPSTR   lpDevName;
LPSTR   lpOldPort, lpNewPort;
{
    return UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);
}
#endif

#ifndef NOBITMAPBITS
BOOL WINAPI BitmapBits(lpdv, fFlags, dwCount, lpBits)
LPDV  lpdv;
DWORD fFlags;
DWORD dwCount;
LPSTR lpBits;
{
    return UniBitmapBits(lpdv, fFlags, dwCount, lpBits);
}
#endif

#ifndef NOSELECTBITMAP
BOOL WINAPI DeviceSelectBitmap(lpdv, lpPrevBmp, lpBmp, fFlags)
LPDV     lpdv;
LPBITMAP lpPrevBmp;
LPBITMAP lpBmp;
DWORD    fFlags;
{
    return UniDeviceSelectBitmap(lpdv, lpPrevBmp, lpBmp, fFlags);
}
#endif

VOID WINAPI WEP(fExitWindows)
short fExitWindows;
{
}

#ifndef NOLIBMAIN
int WINAPI LibMain(HANDLE hInstance, WORD wDataSeg, WORD cbHeapSize,
               LPSTR lpszCmdLine)
{
    return 1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "pdev.h"
#include "name.h"

#include <initguid.h>
#include <prcomoem.h>

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver will be
    // called for cleanup.
    return S_OK;
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
//  return E_NOTIMPL;
  
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE(((DLLTEXT("        Function:%s:"),pMethodName)));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
   // if (OEMDevMode(dwMode, pOemDMParam))
   //     return S_OK;
    //else
    //    return S_FALSE;
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

// #94193: shold create temp. file on spooler directory.
    if (*piResult < 0)
        return E_FAIL;

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
       return S_OK;
    else
        return S_FALSE;

}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

BOOL APIENTRY 
OEMGetInfo(
    DWORD dwInfo,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\r\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING, 
                    (ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING, 
                (ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\ib87wres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ib587res.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

--*/

#include "pdev.h"

#include <windows.h>
#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

/*--------------------------------------------------------------------------*/
/*                             G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/

//Command strings

//
const BYTE CMD_BEGIN_DOC_1[] = {0x1B,0x7E,0xB0,0x00,0x12,0x01} ;
const BYTE CMD_BEGIN_DOC_2[] = {0x01,0x01,0x00} ;
const BYTE CMD_BEGIN_DOC_3[] = {0x02,0x02,0xFF,0xFF} ;
const BYTE CMD_BEGIN_DOC_4[] = {0x03,0x02,0xFF,0xFF} ;
const BYTE CMD_BEGIN_DOC_5[] = {0x04,0x04,0xFF,0xFF,0xFF,0xFF} ;
const BYTE CMD_BEGIN_PAGE[]    = {0xD4, 0x00} ;
const BYTE CMD_END_JOB[] = {0x1B,0x7E,0xB0,0x00,0x04,0x01,0x01,0x01,0x01} ;
const BYTE CMD_END_PAGE[] = {0x20};

//SetPac
#define CMD_SETPAC pOEM->SetPac
const BYTE CMD_SETPAC_TMPL[]    ={ 0xD7,
                       0x01,
                       0xD0,
                       0x1D, //CommandLength
                       0x00, //Front tray paper size
                       0x00, //Input-bin
                       0x01,
                       0x04, //Bit-assign1
                       0xD9, //Bit-assign2
                       0x04, //EET
                       0x02, //PrintDensity
                       0x01, 
                       0x00, //Resolution
                       0x01,
                       0x00, //1st cassette paper size
                       0x00, //2nd cassette paper size
                       0x0F, //Time to Power Save
                       0x00, 
                       0x01, //Compression Mode
                       0x00,0x00,0x00,0x00, //PageLength
                       0x07, 
                       0x00, //Number of Copies
                       0x00, //Toner save mode
                       0x00,0x00, //Dot per line for custom size
                       0x00,0x00, //Data lines per page for custom size
                       0x00} ;

#if 0
const BYTE CMD_DATA[] = {0xDA, 
                       0x00, //mh:DataLen from yh
                       0x00, //ml:
                       0x00, //yh:number of line / send data
                       0x00, //yl:
                       0x00, //xh:number of byte / line
                       0x00} ;
#endif

const BYTE Mask[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01} ;

const POINTL phySize300[] = {
//    Width,Height Physical paper size for 300dpi
    {3416,4872},    //A3
    {2392,3416},    //A4
    {1672,2392},    //A5
    {2944,4208},    //B4
    {2056,2944},    //B5
    {1088,1656},    //PostCard
    {2456,3208},    //Letter
    {2456,4112},    //Legal
    {0000,0000},    //user define
};
const POINTL phySize600[] = {
//    Width,Height   Physical paper size for 600dpi
    {6832,9736},    //A3
    {4776,6832},    //A4
    {3336,4776},    //A5
    {5888,8416},    //B4
    {4112,5888},    //B5
    {2176,3312},    //PostCard
    {4912,6416},    //Letter
    {4912,8216},    //Legal
    {0000,0000},    //user define
};


/******************* FUNCTIONS *************************/
BOOL MyDeleteFile(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL InitSpoolBuffer(LPSB lpsb) ;
BOOL MyCreateFile(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL MySpool(PDEVOBJ pdevobj, LPSB lpsb, PBYTE pBuf, DWORD dwLen) ;
BOOL SpoolOut(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL MyEndDoc(PDEVOBJ pdevobj) ;
BOOL WriteFileForP_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;
BOOL WriteFileForL_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;
BOOL FillPageRestData(PDEVOBJ pdevobj) ;
BOOL SpoolWhiteData(PDEVOBJ pdevobj, DWORD dwWhiteLen, BOOL fComp) ;
BOOL SendPageData(PDEVOBJ pdevobj, PBYTE pSrcImage, DWORD dwLen) ;
BOOL SpoolOutChangedData(PDEVOBJ pdevobj, LPSB lpsb) ;
WORD GetPrintableArea(WORD physSize, INT iRes) ;
BOOL AllocTempBuffer(PIBMPDEV pOEM, DWORD dwNewBufLen) ;
BOOL MyEndPage(PDEVOBJ pdevobj) ;
BOOL MyStartDoc(PDEVOBJ pdevobj) ;

BOOL SpoolOutCompStart(PSOCOMP pSoc);
BOOL SpoolOutCompEnd(PSOCOMP pSoc, PDEVOBJ pdevobj, LPSB psb);
BOOL SpoolOutComp(PSOCOMP pSoc, PDEVOBJ pdevobj, LPSB psb,
    PBYTE pjBuf, DWORD dwLen);

/*****************************************************************************/
/*                                                                             */
/*    Module:         IB587RES.DLL                                              *
/*                                                                             */
/*    Function:        OEMEnablePDEV                                             */
/*                                                                             */
/*    Syntax:         PDEVOEM APIENTRY OEMEnablePDEV(                          */
/*                                        PDEVOBJ         pdevobj,             */
/*                                        PWSTR            pPrinterName,         */
/*                                        ULONG            cPatterns,             */
/*                                        HSURF           *phsurfPatterns,      */
/*                                        ULONG            cjGdiInfo,             */
/*                                        GDIINFO        *pGdiInfo,             */
/*                                        ULONG            cjDevInfo,             */
/*                                        DEVINFO        *pDevInfo,             */
/*                                        DRVENABLEDATA  *pded)                 */
/*                                                                             */
/*    Description:    Allocate buffer of private data to pdevobj                 */
/*                                                                             */
/*****************************************************************************/
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR            pPrinterName,
    ULONG            cPatterns,
    HSURF           *phsurfPatterns,
    ULONG            cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG            cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PIBMPDEV    pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAlloc(sizeof(IBMPDEV))))
        {
            //DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMEnablePDEV:Memory alloc failed.\n")));
            return NULL;
        }
    }

    pOEM = (PIBMPDEV)(pdevobj->pdevOEM);

    // Setup pdev specific conrol block fields
    ZeroMemory(pOEM, sizeof(IBMPDEV));
    CopyMemory(pOEM->SetPac, CMD_SETPAC_TMPL, sizeof(CMD_SETPAC_TMPL));

    return pdevobj->pdevOEM;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:         IB587RES.DLL                                              */
/*                                                                             */
/*    Function:        OEMDisablePDEV                                             */
/*                                                                             */
/*    Description:    Free buffer of private data                              */
/*                                                                             */
/*****************************************************************************/
VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{

    if(pdevobj->pdevOEM)
    {
        if (((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage) {
            MemFree(((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage);
            ((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage = 0;
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PIBMPDEV pOEMOld, pOEMNew;
    PBYTE pTemp;

    pOEMOld = (PIBMPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PIBMPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
        pTemp = pOEMNew->pTempImage;
        *pOEMNew = *pOEMOld;
        pOEMNew->pTempImage = pTemp;
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:    OEMFilterGraphics                                             */
/*                                                                             */
/*    Function:                                                                 */
/*                                                                             */
/*    Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)         */
/*                                                                             */
/*    Input:       pdevobj       address of PDEVICE structure                      */
/*               pBuf        points to buffer of graphics data                 */
/*               dwLen       length of buffer in bytes                         */
/*                                                                             */
/*    Output:    BOOL                                                          */
/*                                                                             */
/*    Notice:    nFunction and Escape numbers are the same                     */
/*                                                                             */
/*****************************************************************************/
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PIBMPDEV    pOEM;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if(pOEM->fChangeDirection) {
        return(WriteFileForL_Paper(pdevobj, pBuf, dwLen)) ;

    }else{
        return(WriteFileForP_Paper(pdevobj, pBuf, dwLen)) ;
    }
    return TRUE;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:    OEMCommandCallback                                             */
/*                                                                             */
/*    Function:                                                                 */
/*                                                                             */
/*    Syntax:    INT APIENTRY OEMCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)     */
/*                                                                             */
/*    Input:       pdevobj                                                         */
/*               dwCmdCbID                                                     */
/*               dwCount                                                         */
/*               pdwParams                                                     */
/*                                                                             */
/*    Output:    INT                                                             */
/*                                                                             */
/*    Notice:                                                                  */
/*                                                                             */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD    dwCmdCbID,    // Callback ID
    DWORD    dwCount,    // Counts of command parameter
    PDWORD    pdwParams ) // points to values of command params
{
    PIBMPDEV       pOEM;
    WORD            wPhysWidth;
    WORD            wPhysHeight;
    WORD            wDataLen ;
    WORD            wLines ;
    WORD            wNumOfByte ;
    POINTL            ptlUserDefSize;

    BYTE            byOutput[64];
    DWORD            dwNeeded;
    DWORD            dwOptionsReturned;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    switch(dwCmdCbID)
    {

        case PAGECONTROL_BEGIN_DOC:
            if (!InitSpoolBuffer(&(pOEM->sb)))
                goto fail;

            if (!MyCreateFile(pdevobj, &(pOEM->sb)))
                goto fail;
            if (!MyCreateFile(pdevobj, &(pOEM->sbcomp)))
                goto fail;

            pOEM->fSendYMove = FALSE ;
            pOEM->fChangeDirection = FALSE ;
            pOEM->sPageNum = 0 ;

            if (!MyStartDoc(pdevobj))
                goto fail;

            break;

        case PAGECONTROL_BEGIN_PAGE:
            pOEM->dwCurCursorY = 0 ;
            pOEM->dwOffset = 0 ;
            pOEM->sPageNum ++ ;

            if(pOEM->fChangeDirection == FALSE) {
                if (!MySpool(pdevobj, &(pOEM->sb), (PBYTE)CMD_BEGIN_PAGE, 1))
                    goto fail;
                if (!SpoolOutCompStart(&pOEM->Soc))
                    goto fail;
            }

            break;

        case PAGECONTROL_END_PAGE:
            if(pOEM->fChangeDirection == FALSE){
                if (!FillPageRestData(pdevobj))
                    goto fail;
                if (!SpoolOutCompEnd(&pOEM->Soc, pdevobj, &pOEM->sb))
                    goto fail;
                if (!MySpool(pdevobj,&(pOEM->sb),
                    (PBYTE)CMD_END_PAGE, sizeof(CMD_END_PAGE)))
                    goto fail;
            }else{
               if (!SpoolOutChangedData(pdevobj, &(pOEM->sbcomp)))
                   goto fail;
            }

            if (!MyEndPage(pdevobj))
                goto fail;
            
            break;

        case PAGECONTROL_ABORT_DOC:
        case PAGECONTROL_END_DOC:
                       
            if (!MyEndDoc(pdevobj))
                goto fail;
            break;

        case RESOLUTION_300:
            pOEM->ulHorzRes = 300;
            pOEM->ulVertRes = 300;

            CMD_SETPAC[12] = 0x02 ;
            
            if( pOEM->sPaperSize == PHYS_PAPER_UNFIXED){
                pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
                pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

                ptlUserDefSize.x = GetPrintableArea((WORD)pOEM->szlPhysSize.cx, RESOLUTION_300);
                ptlUserDefSize.y = GetPrintableArea((WORD)pOEM->szlPhysSize.cy, RESOLUTION_300);
                pOEM->ptlLogSize = ptlUserDefSize;

                CMD_SETPAC[26] = LOBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[27] = HIBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[28] = LOBYTE((WORD)(ptlUserDefSize.y));
                CMD_SETPAC[29] = HIBYTE((WORD)(ptlUserDefSize.y));
            }
            else {
                pOEM->ptlLogSize = phySize300[pOEM->sPaperSize-50];
            }

            break;

        case RESOLUTION_600:
            pOEM->ulHorzRes = 600;
            pOEM->ulVertRes = 600;
            pOEM->ptlLogSize = phySize600[pOEM->sPaperSize-50];
            CMD_SETPAC[12] = 0x20 ;

            if( pOEM->sPaperSize == PHYS_PAPER_UNFIXED){
                pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
                pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

                ptlUserDefSize.x = GetPrintableArea((WORD)pOEM->szlPhysSize.cx, RESOLUTION_600);
                ptlUserDefSize.y = GetPrintableArea((WORD)pOEM->szlPhysSize.cy, RESOLUTION_600);
                pOEM->ptlLogSize = ptlUserDefSize;

                CMD_SETPAC[26] = LOBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[27] = HIBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[28] = LOBYTE((WORD)(ptlUserDefSize.y));
                CMD_SETPAC[29] = HIBYTE((WORD)(ptlUserDefSize.y));
            }
            else {
                pOEM->ptlLogSize = phySize600[pOEM->sPaperSize-50];
            }
            break;

        case SEND_BLOCK_DATA:
            wNumOfByte = (WORD)PARAM(pdwParams, 0);

            pOEM->wImgHeight = (WORD)PARAM(pdwParams, 1);
            pOEM->wImgWidth = (WORD)PARAM(pdwParams, 2);
            break;

        case ORIENTATION_PORTRAIT:                   // 28
        case ORIENTATION_LANDSCAPE:                 // 29
             switch(pOEM->sPaperSize){
                case PHYS_PAPER_A3 :
                case PHYS_PAPER_B4 :
                case PHYS_PAPER_LEGAL :
                case PHYS_PAPER_POSTCARD :
                    pOEM->fChangeDirection = FALSE ;
                    pOEM->fComp = TRUE ;
                    break;

                case PHYS_PAPER_A4 :
                case PHYS_PAPER_A5 :
                case PHYS_PAPER_B5 :
                case PHYS_PAPER_LETTER :
                    pOEM->fChangeDirection = TRUE ;
                    pOEM->fComp = FALSE ;
                    break;

                case PHYS_PAPER_UNFIXED :           /* Paper is not rotated in UNFIXED case */
                    pOEM->fChangeDirection = FALSE ;
                    pOEM->fComp = TRUE ;
                    break;
            }
            break;

        case PHYS_PAPER_A3:                 // 50
             pOEM->sPaperSize = PHYS_PAPER_A3 ;
             CMD_SETPAC[4] = 0x04 ;
             CMD_SETPAC[14] = 0x04 ;
             CMD_SETPAC[15] = 0x04 ;
             break ;
        case PHYS_PAPER_A4:                 // 51
             pOEM->sPaperSize = PHYS_PAPER_A4 ;
             CMD_SETPAC[4] = 0x83 ;
             CMD_SETPAC[14] = 0x83 ;
             CMD_SETPAC[15] = 0x83 ;
             break ;
        case PHYS_PAPER_B4:                 // 54
             pOEM->sPaperSize = PHYS_PAPER_B4 ;
             CMD_SETPAC[4] = 0x07 ;
             CMD_SETPAC[14] = 0x07 ;
             CMD_SETPAC[15] = 0x07 ;
             break ;
        case PHYS_PAPER_LETTER:             // 57
             pOEM->sPaperSize = PHYS_PAPER_LETTER ;
             CMD_SETPAC[4 ] = 0x90 ;
             CMD_SETPAC[14] = 0x90 ;
             CMD_SETPAC[15] = 0x90 ;
             break ;
        case PHYS_PAPER_LEGAL:                // 58
             pOEM->sPaperSize = PHYS_PAPER_LEGAL ;
             CMD_SETPAC[4] = 0x11 ;
             CMD_SETPAC[14] = 0x11 ;
             CMD_SETPAC[15] = 0x11 ;
             break ;

        case PHYS_PAPER_B5:                 // 55
             pOEM->sPaperSize = PHYS_PAPER_B5 ;
             CMD_SETPAC[4] = 0x86 ;
             CMD_SETPAC[14] = 0x86 ;
             CMD_SETPAC[15] = 0x86 ;
             break ;
        case PHYS_PAPER_A5:                 // 52
             pOEM->sPaperSize = PHYS_PAPER_A5 ;
             CMD_SETPAC[4] = 0x82 ;
             CMD_SETPAC[14] = 0x82 ;
             CMD_SETPAC[15] = 0x82 ;
             break ;

        case PHYS_PAPER_POSTCARD:            // 59
             pOEM->sPaperSize = PHYS_PAPER_POSTCARD ;
             CMD_SETPAC[4] = 0x17 ;
             CMD_SETPAC[14] = 0x17 ;
             CMD_SETPAC[15] = 0x17 ;
             break ;

        case PHYS_PAPER_UNFIXED:            // 60
             pOEM->sPaperSize = PHYS_PAPER_UNFIXED ;
             CMD_SETPAC[4] = 0x3F ;
             CMD_SETPAC[14] = 0x3F ;
             CMD_SETPAC[15] = 0x3F ;

             break ;

        case PAPER_SRC_FTRAY:
             CMD_SETPAC[5] = 0x01 ;
             break ;

        case PAPER_SRC_CAS1:
            CMD_SETPAC[5] = 0x02 ;
            break;

        case PAPER_SRC_CAS2:
            CMD_SETPAC[5] = 0x04 ;
            break;

        case PAPER_SRC_AUTO:
            CMD_SETPAC[5] = 0x04 ;
            break;


        case TONER_SAVE_MEDIUM:                // 100
            CMD_SETPAC[25] = 0x02 ;
            break;

        case TONER_SAVE_DARK:                // 101
            CMD_SETPAC[25] = 0x04 ;
            break;

        case TONER_SAVE_LIGHT:                // 102
            CMD_SETPAC[25] = 0x01 ;
            break;


        case PAGECONTROL_MULTI_COPIES:
            CMD_SETPAC[24] = (BYTE)*pdwParams;
            pOEM->sCopyNum = (BYTE)*pdwParams ;
            break;
        
        case Y_REL_MOVE :
            pOEM->fSendYMove = TRUE ;

            pOEM->dwYmove=(WORD)*pdwParams/(MASTERUNIT/(WORD)pOEM->ulHorzRes);
            if(pOEM->dwCurCursorY < pOEM->dwYmove){
                pOEM->dwYmove -= pOEM->dwCurCursorY ;
            }else{
                pOEM->dwYmove = 0 ;
            }
            break;
            

        default:
            break;
    }
    return 0;

fail:
    return -1;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:    GetPrintableArea                                              */
/*                                                                             */
/*    Function:  Calculate PrintableArea for user defined paper                 */
/*                                                                             */
/*    Syntax:    WORD GetPrintableArea(WORD physSize, INT iRes)                 */
/*                                                                             */
/*    Input:       physSize                                                      */
/*               iRes                                                          */
/*                                                                             */
/*    Output:    WORD                                                          */
/*                                                                             */
/*    Notice:                                                                  */
/*                                                                             */
/*****************************************************************************/
WORD GetPrintableArea(WORD physSize, INT iRes)
{
    DWORD dwArea ;
    DWORD dwPhysSizeMMx10 = physSize * 254 / MASTERUNIT;

    /* Unit of phySize is MASTERUNIT(=1200) */

    if(iRes == RESOLUTION_300){
        dwArea = (((WORD)(( ( (DWORD)(dwPhysSizeMMx10*300/25.4) -
                            2*( (DWORD)(4*300*10/25.4) ) ) / 10 +7)/8))) * 8;
    }else{
        dwArea = (((WORD)(( ( (DWORD)(dwPhysSizeMMx10*600/25.4) -
                            2*( (DWORD)(4*600*10/25.4) ) ) / 10 +7)/8))) * 8;
    }

    return (WORD)dwArea ;
}

// #94193: shold create temp. file on spooler directory.

/*++

Routine Description:

  This function comes up with a name for a spool file that we should be
  able to write to.

  Note: The file name returned has already been created.

Arguments:

  hPrinter - handle to the printer that we want a spool file for.

  ppwchSpoolFileName: pointer that will receive an allocated buffer
                      containing the file name to spool to.  CALLER
                      MUST FREE.  Use LocalFree().


Return Value:

  TRUE if everything goes as expected.
  FALSE if anything goes wrong.

--*/

BOOL
GetSpoolFileName(
  IN HANDLE hPrinter,
  IN OUT PWCHAR pwchSpoolPath
)
{
  PBYTE         pBuffer = NULL;
  DWORD         dwAllocSize;
  DWORD         dwNeeded;
  DWORD         dwRetval;
  HANDLE        hToken=NULL;

  //
  //  In order to find out where the spooler's directory is, we add
  //  call GetPrinterData with DefaultSpoolDirectory.
  //

  dwAllocSize = ( MAX_PATH + 1 ) * sizeof (WCHAR);

  for (;;)
  {
    pBuffer = LocalAlloc( LMEM_FIXED, dwAllocSize );

    if ( pBuffer == NULL )
    {
      ERR((DLLTEXT("LocalAlloc faild, %d\n"), GetLastError()));
      goto Failure;
    }

    if ( GetPrinterData( hPrinter,
                         SPLREG_DEFAULT_SPOOL_DIRECTORY,
                         NULL,
                         pBuffer,
                         dwAllocSize,
                         &dwNeeded ) == ERROR_SUCCESS )
    {
      break;
    }

    if ( ( dwNeeded < dwAllocSize ) ||( GetLastError() != ERROR_MORE_DATA ))
    {
      ERR((DLLTEXT("GetPrinterData failed in a non-understood way.\n")));
      goto Failure;
    }

    //
    // Free the current buffer and increase the size that we try to allocate
    // next time around.
    //

    LocalFree( pBuffer );

    dwAllocSize = dwNeeded;
  }

  hToken = RevertToPrinterSelf();

  if( !GetTempFileName( (LPWSTR)pBuffer, TEMP_NAME_PREFIX, 0, pwchSpoolPath ))
  {
      goto Failure;
  }

  //
  //  At this point, the spool file name should be done.  Free the structure
  //  we used to get the spooler temp dir and return.
  //

  LocalFree( pBuffer );

  if (NULL != hToken) {
    (void)ImpersonatePrinterClient(hToken);
  }

  return( TRUE );

Failure:

  //
  //  Clean up and fail.
  //
  if ( pBuffer != NULL )
  {
    LocalFree( pBuffer );
  }

  if (hToken != NULL)
  {
      (void)ImpersonatePrinterClient(hToken);
  }
  return( FALSE );
}

//SPLBUF is used for control temp files.
//This printer need the number of bytes of whole page data.
BOOL InitSpoolBuffer(LPSB lpsb)
{
    lpsb->dwWrite = 0 ;
    lpsb->TempName[0] = __TEXT('\0') ;
    lpsb->hFile = INVALID_HANDLE_VALUE ;

    return TRUE;
}

BOOL MyCreateFile(PDEVOBJ pdevobj, LPSB lpsb)
{
#if 0
    INT iLen, iUniq ;
    TCHAR PathName[MAX_PATH+1] ;

    if(0 == (iLen = (GetTempPath(MAX_PATH, (LPTSTR)PathName))) ){
        ERR((DLLTEXT("GetTempPath failed (%d).\n"),
                GetLastError()))
        return FALSE ;
    }
    PathName[iLen] = __TEXT('\0') ;

    if(0 == (iUniq = GetTempFileName((LPTSTR)PathName,
                         TEMP_NAME_PREFIX,
                         0,
                         (LPTSTR)lpsb->TempName))){
        ERR((DLLTEXT("GetTempFileName failed (%d).\n"),
                GetLastError()))
        return FALSE ;
    }
#endif // 0

    HANDLE hToken = NULL;

    if (!GetSpoolFileName(pdevobj->hPrinter, lpsb->TempName)) {
        //DBGPRINT(DBG_WARNING, ("GetSpoolFileName failed.\n"));
        return FALSE;
    }

    hToken = RevertToPrinterSelf();

    lpsb->hFile = CreateFile((LPCTSTR)lpsb->TempName,
                     (GENERIC_READ | GENERIC_WRITE), 
                     0,                             
                     NULL,                            
                     CREATE_ALWAYS,                 
                     FILE_ATTRIBUTE_NORMAL,         
                     NULL) ;

    if (hToken) (void)ImpersonatePrinterClient(hToken);

    if(lpsb->hFile == INVALID_HANDLE_VALUE)
    {
        //DBGPRINT(DBG_WARNING, ("Tmp file cannot create.\n"));
        DeleteFile(lpsb->TempName);
        lpsb->TempName[0] = __TEXT('\0') ;
        return FALSE ;
    }

    return TRUE ;

}

BOOL MyDeleteFile(PDEVOBJ pdevobj, LPSB lpsb)
{    
    HANDLE hToken = NULL;
    BOOL bRet = FALSE;

    if(lpsb->hFile != INVALID_HANDLE_VALUE){

        if (0 == CloseHandle(lpsb->hFile)) {
            //DBGPRINT(DBG_WARNING, ("CloseHandle error %d\n"));
            goto fail;
        }
        lpsb->hFile = INVALID_HANDLE_VALUE ;
        hToken = RevertToPrinterSelf();
        if (0 == DeleteFile(lpsb->TempName)) {
            //DBGPRINT(DBG_WARNING, ("DeleteName error %d\n",GetLastError()));
            goto fail;
        }
        lpsb->TempName[0] = __TEXT('\0');

    }
    bRet = TRUE;

fail:
    if (hToken) (void)ImpersonatePrinterClient(hToken);
    return bRet;
}

//Spool page data to temp file
BOOL MySpool
    (PDEVOBJ pdevobj,
     LPSB  lpsb,
     PBYTE pBuf,
     DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;

    if (lpsb->hFile != INVALID_HANDLE_VALUE) {

        pTemp = pBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(lpsb->hFile,
                               pTemp,
                               dwTemp,
                               &dwTemp2,
                               NULL)) {

                ERR((DLLTEXT("WriteFile error in CacheData %d.\n"),
                    GetLastError()));
                return FALSE;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
            lpsb->dwWrite += dwTemp2 ;
        }
        return TRUE;
    }
    else {
        return WRITESPOOLBUF(pdevobj, pBuf, dwLen);
    }
}

//Dump out temp file to printer
BOOL
SpoolOut(PDEVOBJ pdevobj, LPSB lpsb)
{
 
   DWORD dwSize, dwTemp, dwTemp2;
   HANDLE hFile;

    BYTE  Buf[SPOOL_OUT_BUF_SIZE];

    hFile = lpsb->hFile ;
    dwSize = lpsb->dwWrite ;

    VERBOSE(("dwSize=%ld\n", dwSize));

    if (0L != SetFilePointer(hFile, 0L, NULL, FILE_BEGIN)) {

        ERR((DLLTEXT("SetFilePointer failed %d\n"),
            GetLastError()));
        return FALSE;
    }

    for ( ; dwSize > 0; dwSize -= dwTemp2) {

        dwTemp = ((SPOOL_OUT_BUF_SIZE < dwSize)
            ? SPOOL_OUT_BUF_SIZE : dwSize);

        if (0 == ReadFile(hFile, Buf, dwTemp, &dwTemp2, NULL)) {
            ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
            return FALSE;
        }

        if (dwTemp2 > 0) {
            if (!WRITESPOOLBUF(pdevobj, Buf, dwTemp2))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL MyStartDoc(PDEVOBJ pdevobj)
{
    return
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_1, sizeof(CMD_BEGIN_DOC_1)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_2, sizeof(CMD_BEGIN_DOC_2)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_3, sizeof(CMD_BEGIN_DOC_3)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_4, sizeof(CMD_BEGIN_DOC_4)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_5, sizeof(CMD_BEGIN_DOC_5));
}

BOOL MyEndPage(PDEVOBJ pdevobj)
{
    PIBMPDEV    pOEM;
    LPSB        lpsb, lpsbco ;
    DWORD        dwPageLen ;
    WORD        wTmph, wTmpl ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    lpsb = &(pOEM->sb) ;
    lpsbco = &(pOEM->sbcomp) ;

    if(pOEM->fChangeDirection == FALSE) {
        dwPageLen = lpsb->dwWrite;
    }
    else {
        dwPageLen = lpsbco->dwWrite ;
    }

    dwPageLen -= 3 ; //End page Command Len

    VERBOSE(("MyEndPage - dwPageLen=%ld\n",
        dwPageLen));

    wTmpl = LOWORD(dwPageLen) ;
    wTmph = HIWORD(dwPageLen) ;
    
    CMD_SETPAC[19] = LOBYTE(wTmpl);
    CMD_SETPAC[20] = HIBYTE(wTmpl);
    CMD_SETPAC[21] = LOBYTE(wTmph);
    CMD_SETPAC[22] = HIBYTE(wTmph);

    if (!WRITESPOOLBUF(pdevobj, CMD_SETPAC, sizeof(CMD_SETPAC)))
        return FALSE;

    if(pOEM->fChangeDirection == FALSE){
        if (!SpoolOut(pdevobj, lpsb))
            return FALSE;
    }else{
        if (!SpoolOut(pdevobj, lpsbco))
            return FALSE;
    }

    //InitFiles
    lpsbco->dwWrite = 0 ;
    lpsb->dwWrite = 0 ;

    if(0xFFFFFFFF==SetFilePointer(lpsb->hFile,0,NULL,FILE_BEGIN)){
        ERR((DLLTEXT("SetFilePointer failed %d\n"),
             GetLastError()));
        return FALSE;
    }

    if(0xFFFFFFFF==SetFilePointer(lpsbco->hFile,0,NULL,FILE_BEGIN)){
        ERR((DLLTEXT("SetFilePointer failed %d\n"),
             GetLastError()));
        return FALSE;
    }

    return TRUE;
}

BOOL MyEndDoc(PDEVOBJ pdevobj)
{
    PIBMPDEV    pOEM;
    LPSB        lpsb, lpsbco ;
    WORD        wTmph, wTmpl ;
    DWORD        dwPageLen ;
    SHORT        i ;
    LPPD        lppdTemp ;
    BOOL        bRet = FALSE;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    lpsb = &(pOEM->sb) ;
    lpsbco = &(pOEM->sbcomp) ;


    if (!WRITESPOOLBUF(pdevobj, (PBYTE)CMD_END_JOB, sizeof(CMD_END_JOB)))
        goto fail;

    if (!MyDeleteFile(pdevobj, lpsb))
        goto fail;
    if (!MyDeleteFile(pdevobj, lpsbco))
        goto fail;
    bRet = TRUE;

fail:
    return bRet;
}

BOOL WriteFileForP_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    PIBMPDEV           pOEM;
    ULONG                ulHorzPixel;
    WORD                wCompLen;
    DWORD                dwWhiteLen ;
    DWORD                dwTmp ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if(pOEM->fSendYMove == TRUE && pOEM->dwYmove > 1){
        dwWhiteLen = pOEM->wImgWidth * (pOEM->dwYmove-1);

        if(dwWhiteLen > 0){
            if (!SpoolWhiteData(pdevobj, dwWhiteLen, TRUE))
                return FALSE;
            pOEM->dwCurCursorY += pOEM->dwYmove-1 ;
        }
    }

    pOEM->dwCurCursorY += dwLen/pOEM->wImgWidth - 1 ;

    return SendPageData(pdevobj, pBuf, dwLen) ;
}

BOOL WriteFileForL_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    PIBMPDEV           pOEM;
    ULONG                ulHorzPixel;
    WORD                wCompLen;
    DWORD                dwWhiteLen ;

    DWORD i, j;
    DWORD dwHeight, dwWidth;
    PBYTE pTemp;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if(pOEM->fSendYMove == TRUE && pOEM->dwYmove > 1){
        dwWhiteLen = pOEM->wImgWidth * (pOEM->dwYmove-1) ;

        if(dwWhiteLen > 0){
            if (!SpoolWhiteData(pdevobj, dwWhiteLen, FALSE))
                return FALSE;
            pOEM->dwCurCursorY += pOEM->dwYmove - 1 ;
        }

    }

    pOEM->dwCurCursorY += dwLen/pOEM->wImgWidth - 1 ;
    pOEM->dwOffset ++ ;

    return MySpool(pdevobj, &(pOEM->sb), pBuf,dwLen);
}

//fill page blanks.
BOOL FillPageRestData(PDEVOBJ pdevobj)
{

    PIBMPDEV    pOEM ;
    DWORD        dwRestHigh ;
    DWORD        dwWhiteLen ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    
    dwRestHigh = pOEM->ptlLogSize.y - pOEM->dwCurCursorY ;

    if(dwRestHigh <= 0)
        return TRUE;

    dwWhiteLen = pOEM->ptlLogSize.x * dwRestHigh;
    
    return SpoolWhiteData(pdevobj, dwWhiteLen, pOEM->fComp);
}

//not white data
BOOL SendPageData(PDEVOBJ pdevobj, PBYTE pSrcImage, DWORD dwLen)
{
    PIBMPDEV           pOEM;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    return SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sb, pSrcImage, dwLen);
}

BOOL SpoolWhiteData(PDEVOBJ pdevobj, DWORD dwWhiteLen, BOOL fComp)
{

    PIBMPDEV    pOEM;
    PBYTE        pWhite ;
    WORD        wCompLen ;
    DWORD        dwTempLen ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if(dwWhiteLen == 0)
        return TRUE;

    if(dwWhiteLen > MAXIMGSIZE){
        dwTempLen = MAXIMGSIZE ;
    }else{
        dwTempLen = dwWhiteLen ;
    }

    if (!AllocTempBuffer(pOEM, dwTempLen))
        return FALSE;
    pWhite = pOEM->pTempImage;

    ZeroMemory(pWhite, dwTempLen);

    if(fComp == TRUE)
    {
        DWORD dwTemp;

        while (0 < dwWhiteLen) {

            if (MAXIMGSIZE <= dwWhiteLen)
                dwTemp = MAXIMGSIZE;
            else
                dwTemp = dwWhiteLen;

            if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sb, pWhite, dwTemp))
                return FALSE;
            dwWhiteLen -= dwTemp;
        }

    }
    else{
        if(dwWhiteLen > MAXIMGSIZE){
            while(dwWhiteLen > MAXIMGSIZE){
                if (!MySpool(pdevobj, &pOEM->sb, pWhite, MAXIMGSIZE))
                    return FALSE;

                dwWhiteLen -= MAXIMGSIZE ;
            }
        }

        if(dwWhiteLen > 0){
            if (!MySpool(pdevobj, &pOEM->sb, pWhite, dwWhiteLen))
                return FALSE;

        }
    }

    return TRUE;
}

BOOL SpoolOutChangedData(PDEVOBJ pdevobj, LPSB lpsb)
{
    PIBMPDEV    pOEM;
    POINTL        ptlDataPos ;
    DWORD        dwFilePos, dwTemp;
    HANDLE        hFile ;
    PBYTE        pSaveFileData ;
    PBYTE        pTemp;
    PBYTE        pTransBuf ;
    DWORD        X, Y;
    DWORD        dwFirstPos ;
    INT h, i, j, k;

    POINTL ptlBand;
    PBYTE pSrc, pDst, pSrcSave;
    DWORD dwBandY, dwImageY, dwImageX;
    BOOL bBlank, bZero;
    BOOL bRet = FALSE;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    hFile = pOEM->sb.hFile ;

    // band size in pixels
    ptlBand.x = pOEM->ptlLogSize.y;
    ptlBand.y = TRANS_BAND_Y_SIZE;

    //t@CJnuvZ
    ptlDataPos.x = 0 ;
    ptlDataPos.y = pOEM->dwCurCursorY + pOEM->dwOffset ;

    //cAPs]
    dwImageX = ((ptlDataPos.y + 7) / 8) * 8;

    // Buffer for loading file data (scan lines for a band)
    pSaveFileData = (PBYTE)MemAlloc((ptlBand.y / 8) * dwImageX);
    if (NULL == pSaveFileData) {
        ERR(("Failed to allocate memory.\n"));
        return FALSE;
    }

    // Buffer for transpositions (one scan line)
    pTransBuf = (PBYTE)MemAlloc((ptlBand.x / 8));
    if (NULL == pTransBuf) {
        ERR(("Failed to allocate memory.\n"));
// #441444: PREFIX: reference NULL pointer.
        goto out;
    }

    //t@CuwB
    dwFirstPos = pOEM->wImgWidth - 1;

    if (!MySpool(pdevobj,&(pOEM->sbcomp), (PBYTE)CMD_BEGIN_PAGE, 1))
        goto out;
    if (!SpoolOutCompStart(&pOEM->Soc))
        goto out;

    dwImageY = pOEM->wImgWidth;

    bBlank = FALSE;
    bZero = FALSE;
    for (X = 0; X < (DWORD)pOEM->ptlLogSize.x / 8; X += dwBandY) {

        //]ZbgBB
        dwBandY = ptlBand.y / 8;
        if (dwBandY > (DWORD)pOEM->ptlLogSize.x / 8 - X)
            dwBandY = (DWORD)pOEM->ptlLogSize.x / 8 - X;

        // White scanlines.  Currently the trailing ones only,
        // desired to be udpated to include others.

        if (X >= dwImageY) {
            bBlank = TRUE;
        }

        // Output white scanline.
        if (bBlank) {

            if (!bZero) {
                ZeroMemory(pTransBuf, (ptlBand.x / 8));
                bZero = TRUE;
            }

            for (i = 0; i < (INT)dwBandY * 8; i++) {
                if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sbcomp,
                    (PBYTE)pTransBuf, (ptlBand.x / 8)))
                    goto out;
            }
            continue;
        }

        // Non-white scanlines.

        pTemp = pSaveFileData ;
        dwFilePos = pOEM->wImgWidth - X - dwBandY;

        //cPst@CB
        for (Y = 0; Y < dwImageX; pTemp += dwBandY, Y++) {

            if (Y >= (DWORD)ptlDataPos.y) {
                ZeroMemory(pTemp, dwBandY);
                continue;
            }

            if(0xFFFFFFFF==SetFilePointer(hFile,dwFilePos,NULL,FILE_BEGIN)){
                 ERR((DLLTEXT("SetFilePointer failed %d\n"),
                     GetLastError()));
// #441442: PREFIX: leaking memory.
                    // return;
                    goto out;
            }

            if (0 == ReadFile(hFile, pTemp, dwBandY, &dwTemp, NULL)) {
                 ERR(("Faild reading data from file. (%d)\n",
                     GetLastError()));
// #441442: PREFIX: leaking memory.
                // return;
                goto out;
            }

            dwFilePos += pOEM->wImgWidth;

        }//End of Y loop

        // Transposition and output dwBandY * 8 scan lines
        for (h = 0; h < (INT)dwBandY; h++) {

            //VERBOSE(("> %d/%d\n", h, dwBandY));

            pSrcSave = pSaveFileData + dwBandY - 1 - h;

            // Transposition and output eight scan lines
            for (j = 0; j < 8; j++) {

                pSrc = pSrcSave;
                pDst = pTransBuf;
                ZeroMemory(pDst, (ptlBand.x / 8));

                // Transposition one scan line

                for (i = 0; i < (INT)(dwImageX / 8); i++){

                    for (k = 0; k < 8; k++) {

                        if (0 != (*pSrc & Mask[7 - j])) {
                            *pDst |= Mask[k];
                        }
                        pSrc += dwBandY;
                    }
                    pDst++;
                }

                // Output one scan line
                if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sbcomp,
                    (PBYTE)pTransBuf, (ptlBand.x / 8)))
                    goto out;
            }
        }

    }

    // Mark end of image
    if (!SpoolOutCompEnd(&pOEM->Soc, pdevobj, &pOEM->sbcomp))
        goto out;
    if (!MySpool(pdevobj, &(pOEM->sbcomp),
        (PBYTE)CMD_END_PAGE, sizeof(CMD_END_PAGE)))
        goto out;

    bRet = TRUE;

// #441442: PREFIX: leaking memory.
out:
    if (NULL != pSaveFileData){
        MemFree(pSaveFileData);
    }
    if(NULL != pTransBuf){
        MemFree(pTransBuf);
    }

    return bRet;
}

BOOL
AllocTempBuffer(
    PIBMPDEV pOEM,
    DWORD dwNewBufLen)
{
   if (NULL == pOEM->pTempImage ||
        dwNewBufLen > pOEM->dwTempBufLen) {

        if (NULL != pOEM->pTempImage) {
            MemFree(pOEM->pTempImage);
        }
        pOEM->pTempImage = (PBYTE)MemAlloc(dwNewBufLen);
        if (NULL == pOEM->pTempImage) {
            WARNING(("Failed to allocate memory. (%d)\n",
                GetLastError()));
            return FALSE;
        }
        pOEM->dwTempBufLen = dwNewBufLen;
    }
    return TRUE;
}

BOOL
SpoolOutCompStart(
    PSOCOMP pSoc)
{
    pSoc->iNRCnt = 0;
    pSoc->iRCnt = 0;
    pSoc->iPrv = -1;

    return TRUE;
}

BOOL
SpoolOutCompEnd(
    PSOCOMP pSoc,
    PDEVOBJ pdevobj,
    LPSB psb)
{
    BYTE jTemp;

    if (0 < pSoc->iNRCnt) {
        jTemp = ((BYTE)pSoc->iNRCnt) - 1;
        if (!MySpool(pdevobj, psb, &jTemp, 1))
            return FALSE;
        if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt))
            return FALSE;
        pSoc->iNRCnt = 0;
    }

    if (0 < pSoc->iRCnt) {
        jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
        if (!MySpool(pdevobj, psb, &jTemp, 1))
            return FALSE;
        if (!MySpool(pdevobj, psb, &pSoc->iPrv, 1))
            return FALSE;
        pSoc->iRCnt = 0;
    }

    return TRUE;
}

BOOL
SpoolOutComp(
    PSOCOMP pSoc,
    PDEVOBJ pdevobj,
    LPSB psb,
    PBYTE pjBuf,
    DWORD dwLen)
{
    BYTE jCur, jTemp;

    while (0 < dwLen--) {

        jCur = *pjBuf++;

        if (pSoc->iPrv == jCur) {

            if (0 < pSoc->iNRCnt) {
                if (1 < pSoc->iNRCnt) {
                    jTemp = ((BYTE)pSoc->iNRCnt - 1) - 1;
                    if (!MySpool(pdevobj, psb, &jTemp, 1))
                        return FALSE;
                    if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt - 1))
                        return FALSE;
                }
                pSoc->iNRCnt = 0;
                pSoc->iRCnt = 1;
            }

            pSoc->iRCnt++;

            if (RPEAK == pSoc->iRCnt) {
                jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, &jCur, 1))
                    return FALSE;
                pSoc->iRCnt = 0;
            }
        }
        else {

            if (0 < pSoc->iRCnt) {
                jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, &pSoc->iPrv, 1))
                    return FALSE;
                pSoc->iRCnt = 0;
            }

            pSoc->pjNRBuf[pSoc->iNRCnt++] = jCur;

            if (NRPEAK == pSoc->iNRCnt) {
                jTemp = ((BYTE)pSoc->iNRCnt) - 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt))
                    return FALSE;
                pSoc->iNRCnt = 0;
            }
        }
        pSoc->iPrv = jCur;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#ifdef USERMODE_DRIVER
#ifdef DbgBreakPoint
#undef DbgBreakPoint
extern VOID DbgBreakPoint(VOID);
#endif // DbgBreakPoint
#endif // USERMODE_DRIVER

#include <printoem.h>
#include <prntfont.h>
#include <winsplp.h> // #94193: shold create temp. file on spooler directory.

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

// OEM Signature and version.
#define OEM_SIGNATURE   'IBMW'
#define DLLTEXT(s)      "IB87WRES: " s
#define OEM_VERSION      0x00010000L

/*************  Value   **************/

#define PAPER_SRC_FTRAY                 20
#define PAPER_SRC_CAS1                  21
#define PAPER_SRC_CAS2                  22
#define PAPER_SRC_CAS3                  23
#define PAPER_SRC_AUTO                  24

#define ORIENTATION_PORTRAIT			28
#define ORIENTATION_LANDSCAPE			29

#define PAGECONTROL_BEGIN_DOC           30
#define PAGECONTROL_BEGIN_PAGE          31
#define PAGECONTROL_END_DOC             32
#define PAGECONTROL_END_PAGE            33
#define PAGECONTROL_DUPLEX_OFF          34
#define PAGECONTROL_ABORT_DOC           35
#define PAGECONTROL_POTRAIT             36
#define PAGECONTROL_LANDSCAPE           37
#define PAGECONTROL_MULTI_COPIES        38

#define PHYS_PAPER_A3                   50
#define PHYS_PAPER_A4                   51
#define PHYS_PAPER_A5                   52
#define PHYS_PAPER_B4                   53
#define PHYS_PAPER_B5                   54
#define PHYS_PAPER_POSTCARD             55
#define PHYS_PAPER_LETTER               56
#define PHYS_PAPER_LEGAL                57
#define PHYS_PAPER_UNFIXED              58

#define Y_REL_MOVE                      71

#define RESOLUTION_300                  76
#define RESOLUTION_600                  77
#define SEND_BLOCK_DATA                 82

#define TONER_SAVE_MEDIUM               100
#define TONER_SAVE_DARK                 101
#define TONER_SAVE_LIGHT                102

#define MAXIMGSIZE                      0xF000
#define NRPEAK                          0x7F
#define RPEAK                           0x80
#define MASTERUNIT						1200
#define MAXLINESIZE 				   11817

#define TEMP_NAME_PREFIX __TEXT("~IB")

#define TRANS_BAND_Y_SIZE 1024
#define SPOOL_OUT_BUF_SIZE 1024

/*************  Structure   **************/
typedef struct tag_PAGEDATA{
	SHORT	sPageNum ;
	HANDLE	hPageFile ;
	TCHAR   TempName[MAX_PATH];
	DWORD	dwPageLen ;	//Page length of one page in byte.
	DWORD	dwFilePos ;	//Start Position for reading file.
	LPVOID	pPrePage ;
	LPVOID	pNextPage ;
}PAGEDATA, *LPPD ;

typedef struct SPLBUF {
	DWORD	dwWrite ;
	DWORD	dwPageLen ;
	HANDLE	hFile ;
	TCHAR   TempName[MAX_PATH];
}SPLBUF, *LPSB ;

// Status paramters for SpoolOutComp routine.
typedef struct {
    INT iNRCnt;
    INT iRCnt;
    BYTE iPrv;
    BYTE pjNRBuf[NRPEAK];
} SOCOMP, *PSOCOMP;

typedef struct tag_IBMPDEV {
    ULONG   ulHorzRes;
    ULONG   ulVertRes;

    SIZEL   szlPhysSize;
	POINTL  ptlLogSize;
    POINTL  ptlPhysOffset;

    WORD    wImgWidth;
    WORD    wImgHeight;

    BYTE    byPaperSize ;

	SHORT   sPageNum;
	SHORT   sCopyNum;
	
	BOOL	fSendYMove ;
	DWORD   dwYmove ;
	DWORD	dwCurCursorY ;
	DWORD	dwOffset ;
	
	DWORD	wCompLen ;
	SHORT   sPaperSize ;

	BOOL	fComp ;
	BOOL	fChangeDirection ;

	SPLBUF  sb ;		//to count bytes
	SPLBUF  sbcomp ;	//to change direstions

	PBYTE   pTempImage ;
	DWORD   dwTempBufLen ;

	LPPD	lpFstData ;
	LPPD	lpCurData ;
	
	BOOL	fDocCmd ;

    BYTE SetPac[31]; // DefineSession + SETPAC

    SOCOMP Soc;

} IBMPDEV, *PIBMPDEV;

/*************  Macro   **************/
// #94193: shold create temp. file on spooler directory.
#define WRITESPOOLBUF(p, s, n) \
    (((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n)) == (n))

#define PARAM(p,n) \
    (*((p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#endif  //_PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ib87wres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\ibm\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=ib87wres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),ib87wres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ib87wres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\ib87wres.c

MISCFILES=\
    $(SRCDIR)\ib87wres.ini \
    $(GPDDIR)\ib5587wj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        WARNING(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        WARNING(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        WARNING(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            WARNING(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        INT iTemp = giDebugLevel;

        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));

        giDebugLevel = iTemp;
    }
#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\kpdlres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#include "pdev.h"

#define SHIFTJIS_CHARSET  128
#define CCHMAXCMDLEN      128

#include <stdio.h>
#undef wsprintf
#define wsprintf sprintf

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))

#define FLAG_SBCS  1
#define FLAG_DBCS  2

WORD SJis2JisNPDL(
WORD usCode)
{

    union {
        USHORT bBuffer;
        struct tags{
            UCHAR al;
            UCHAR ah;
        } s;
    } u;

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (usCode >= 0xf040) {
        usCode = 0x8145;
    }

    u.bBuffer = usCode;

    u.s.al -= u.s.al >= 0x80 ;
    u.s.al -= 0x1F ;
    u.s.ah &= 0xBF ;
    u.s.ah <<= 1 ;
    u.s.ah += 0x21-0x02 ;

    if (u.s.al > 0x7E )
    {
        u.s.al -= (0x7F-0x21) ;
        u.s.ah++;
    }
     return (u.bBuffer);
}

// In case it is a single byte font, we will some of the characters
// (e.g. Yen-mark) to the actual printer font codepoint.  Note since
// the GPC data sets 0 to default CTT ID value, single byte codes
// are in codepage 1252 (Latin1) values.

WORD
Ltn1ToAnk(
   WORD wCode )
{
    // Not a good mapping table now.

    switch ( wCode ) {
    case 0xa5: // YEN MARK
        wCode = 0x5c;
        break;
    default:
        if ( wCode >= 0x7f)
            wCode = 0xa5;
    }

    return wCode;
}

//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(PBYTE buf, long n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}


VOID
InitMyData(PMYDATA pnp)
{
    pnp->wRes = 300;
    pnp->wCopies = 1;
    pnp->sSBCSX = pnp->sDBCSX = pnp->sSBCSXMove =
    pnp->sSBCSYMove = pnp->sDBCSXMove = pnp->sDBCSYMove = 0;
    pnp->sEscapement = 0;
    pnp->fVertFont = FALSE;
    pnp->jAddrMode = ADDR_MODE_NONE;
    pnp->wOldFontID = 0;
    pnp->fPlus = FALSE;
    pnp->wScale = 1;
    pnp->lPointsx =
    pnp->lPointsy = 0;
    pnp->CursorX =
    pnp->CursorY = 0;
    pnp->jColorMode = MONOCHROME;
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    PMYDATA pTemp;

    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));

    // Allocate minidriver private PDEV block.

    pTemp = (PMYDATA)MemAllocZ(sizeof(MYDATA));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        return NULL;
    }
    InitMyData(pTemp);

    MINIDEV_DATA(pdevobj) = (PVOID)pTemp;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

    if ( NULL != pdevobj->pdevOEM ) {

        PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

        if (NULL != pnp) {
            if (NULL != pnp->pTempBuf) {
                MemFree(pnp->pTempBuf);
            }
            MemFree( pnp );
            MINIDEV_DATA(pdevobj) = NULL;
        }
    }

    if ( NULL != pdevobj->pdevOEM ) {
        MemFree( pdevobj->pdevOEM );
        pdevobj->pdevOEM = NULL;
    }
}


BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew )
{
    PMYDATA pTempOld, pTempNew;

    VERBOSE((DLLTEXT("OEMResetPDEV entry.\n")));

    // Do some verificatin on PDEV data passed in.

    pTempOld = (PMYDATA)MINIDEV_DATA(pdevobjOld);
    pTempNew = (PMYDATA)MINIDEV_DATA(pdevobjNew);

    // Copy mindiriver specific part of PDEV

    if (NULL != pTempNew && NULL != pTempOld) {
        if (NULL != pTempNew->pTempBuf) {
            MemFree(pTempNew->pTempBuf);
        }
        *pTempNew = *pTempOld;
        pTempOld->pTempBuf = NULL;
        pTempOld->dwTempBufLen = 0;
    }

    return TRUE;
}


/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMFilterGraphics                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)        */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pBuf        points to buffer of graphics data                 */
/*             dwLen       length of buffer in bytes                         */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);
    DWORD i;
    PBYTE pTop, pBot, pTmp;
    DWORD dwBlockX;

    if (IsColorPlanar(pnp)) {
        WRITESPOOLBUF(pdevobj, pBuf, dwLen);
        // #308001: Garbage appear on device font
        WRITESPOOLBUF(pdevobj, "\x1C!o.", 4);   // end ROP mode
        return TRUE;
    }

#if 0

// #294780: pattern density changes
// TODO: It can't to be available because some raster image doesn't printed
//       as correct position. We need to add smoothing for graphics.

    if (IsColorTrue8dens(pnp)) {

	DWORD j;
	DWORD dwX, dwY, dwAdjX;
	BYTE bTmp;
	PBYTE pSrc;

	// 24bpp color 8 density mode:
	// Most codes are similar to other True color mode
	// but raster data will be stretching by printer hardware.
	// (It's hardware restriction for this color mode.)

        // Change byte order from RGB to BGR, which
        // this printer can accept.

	pTmp = pnp->pTempBuf + pnp->dwTempDataLen;
	pTop = pBuf;
	for (i = 0; i < dwLen; pTmp += 3, pTop += 3, i += 3) {
	    // RGB -> BGR
	    pTmp[0] = pTop[2];
	    pTmp[1] = pTop[1];
	    pTmp[2] = pTop[0];
	}
        if (pnp->dwTempBufLen < pnp->dwTempDataLen + dwLen) {
            ERR(("Internal buffer overflow.\n"));
            return FALSE;
        }
        pnp->dwTempDataLen += dwLen;
        if (pnp->dwTempDataLen < pnp->dwBlockLen) {
            // Not all the data has been saved.
            return TRUE;
        }

        // Need to send the last row first.
        // We have Y + 1 rows of the bufferes and the
        // last row is used as working buffer.

        dwBlockX = pnp->dwBlockX;
        pTop = pnp->pTempBuf;
        pBot = pTop + pnp->dwBlockLen - dwBlockX;
        for (i = 0; i < pnp->dwBlockY / 2; i++) {
	    for (j = 0; j < dwBlockX; j++) {
		bTmp = *pTop;
		*pTop++ = *pBot;
		*pBot++ = bTmp;
	    }
	    pBot -= (dwBlockX * 2);
        }

	if (!pnp->fStretch) {
            WRITESPOOLBUF(pdevobj, pnp->pTempBuf, pnp->dwTempDataLen);
            pnp->dwTempDataLen = 0;
            return TRUE;
	}

	// Shrink the 4 pixel data to one pixel.

	dwX = pnp->dwSrcX;
	dwY = pnp->dwSrcY;
	dwAdjX = dwBlockX - (dwX * 2 * 3);
	pSrc = pnp->pTempBuf + pnp->dwBlockLen;
	pBot = pnp->pTempBuf + dwBlockX * (dwY * 2);
	pTop = pBot - dwBlockX;
	for (i = 0; i < dwY; i++) {
	    pTop -= dwAdjX;
	    pBot -= dwAdjX;
	    for (j = 0; j < dwX; j++) {
		pTop -= 3 * 2;
		pBot -= 3 * 2;
		pSrc -= 3;
		// Compute averages for each RGB colors.
		pSrc[0] = (BYTE)(((DWORD)pTop[0] + (DWORD)pTop[3] +
		    (DWORD)pBot[0] + (DWORD)pBot[3]) / 4); // B
		pSrc[1] = (BYTE)(((DWORD)pTop[1] + (DWORD)pTop[4] +
		    (DWORD)pBot[1] + (DWORD)pBot[4]) / 4); // G
		pSrc[2] = (BYTE)(((DWORD)pTop[2] + (DWORD)pTop[5] +
		    (DWORD)pBot[2] + (DWORD)pBot[5]) / 4); // R
	    }
	    pTop -= dwBlockX;
	    pBot -= dwBlockX;
	}

        WRITESPOOLBUF(pdevobj, pSrc, pnp->dwSrcSize);
        pnp->dwTempDataLen = 0;
        return TRUE;

    } else

#endif // 0

    if (IsColorTrueColor(pnp)) {

        // 24bpp color mode:
        // Change byt order from RGB to BGR, which
        // this printer can accept.

        pTop = pBuf;
        for (i = 0; i < dwLen; pTop += 3, i += 3)
        {
            BYTE jTmp;

            jTmp = *pTop;
            *pTop = *(pTop + 2);
            *(pTop + 2) = jTmp;
        }

        if (pnp->dwTempBufLen < pnp->dwTempDataLen + dwLen) {
            ERR(("Internal buffer overflow.\n"));
            return FALSE;
        }
        memcpy(pnp->pTempBuf + pnp->dwTempDataLen, pBuf, dwLen);
        pnp->dwTempDataLen += dwLen;

        if (pnp->dwTempDataLen < pnp->dwBlockLen) {
            // Not all the data has been saved.
            return TRUE;
        }

        // Now send out the block.
        // Need to send the last row first.
        // We have Y + 1 rows of the bufferes and the
        // last row is used as working buffer.

        dwBlockX = pnp->dwBlockX;
        pTop = pnp->pTempBuf;
        pBot = pTop + pnp->dwBlockLen - dwBlockX;
        pTmp = pTop + pnp->dwBlockLen;
        for (i = 0; i < pnp->dwBlockY / 2; i++) {
            memcpy(pTmp, pTop, dwBlockX);
            memcpy(pTop, pBot, dwBlockX);
            memcpy(pBot, pTmp, dwBlockX);
            pTop += dwBlockX;
            pBot -= dwBlockX;
        }
        WRITESPOOLBUF(pdevobj, pnp->pTempBuf,
            pnp->dwTempDataLen);
        pnp->dwTempDataLen = 0;
        return TRUE;
    }

    // Others, should not happen.
    WARNING(("Unknown color mode, cannot handle\n"));
    return FALSE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendFontCmd                                                */
/*                                                                           */
/*  Function:  send font selection command.                                  */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMSendFontCmd(                                 */
/*                                    PDEVOBJ, PUNIFONTOBJ, PFINVOCATION)    */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             pFInv       address of FINVOCATION                            */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv )
{
    short               ocmd;
    BYTE                i;
    long                tmpPointsx, tmpPointsy;
    PBYTE               pcmd;
    BYTE                rgcmd[CCHMAXCMDLEN];    // build command here
    BOOL                fDBCS;
    DWORD               dwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR pSV;

    PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

    if(!pUFObj || !pFInv)
        return;

    if(!pFInv->pubCommand || !pFInv->dwCount)
    {
        ERR(("Command string is NULL.\n"));
        return;
    }

    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * (3-1) * sizeof(DWORD);
    pSV->dwNumOfVariable = 3;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                                                            pSV->dwSize, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }

    tmpPointsy = (long)pSV->StdVar[0].lStdVariable * 720 / (long)pnp->wRes;
    ocmd = i = 0;
    pcmd = pFInv->pubCommand;

    while(pcmd[i] !='#')
    {
        rgcmd[ocmd] = pcmd[i];
        ocmd++;
        i++;
    }

    i++;
    pnp->fVertFont = pnp->fPlus = FALSE;

    switch(pcmd[i])
    {
        case 'R':
            pnp->fPlus = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1200 /
                                                            (long)pnp->wRes;
            break;

        case 'P':
            fDBCS = FALSE;
            tmpPointsx = ((long)pSV->StdVar[1].lStdVariable * 1200 + 600) /
                         (long)pnp->wRes;
            break;

        case 'W':
            pnp->fVertFont = TRUE;
        case 'Q':
            fDBCS = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1440 /
                                                            (long)pnp->wRes;
            break;

        case 'Y':
            pnp->fVertFont = TRUE;

        case 'S':
            pnp->fPlus = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1440 /
                                                            (long)pnp->wRes;
            break;
    }

    if(pnp->fPlus)
    {
        if(tmpPointsy > 9999)
            tmpPointsy = 9999;
        else if(tmpPointsy < 10)
            tmpPointsy = 10;
        if(tmpPointsx > 9999)
            tmpPointsx = 9999;
        else if(tmpPointsx < 10)
            tmpPointsx = 10;

        pnp->wScale = tmpPointsx == tmpPointsy;
        pnp->lPointsx = tmpPointsx;
        pnp->lPointsy = tmpPointsy;

        if(pnp->fVertFont)
        {
            if(pnp->wScale)
            {
                rgcmd[ocmd] = '\034';
                ocmd += (SHORT)wsprintf(&rgcmd[ocmd], "12S2-");
                ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], tmpPointsx, 4);
                rgcmd[ocmd++] = '-';
                ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], tmpPointsy, 4);
            }
        } else {
            ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], tmpPointsx, 4);
            rgcmd[ocmd++] = '-';
            ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], tmpPointsy, 4);
        }
        goto SEND_COM;
    }
    pnp->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }
    pnp->wScale = (int)(tmpPointsx / tmpPointsy);

    if(pnp->wScale > 8)
        pnp->wScale = 8;

MAKE_COM:
    ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], tmpPointsy, 4);

SEND_COM:
    // write spool builded command
    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);

    i++;
    ocmd = 0;

    while(pcmd[i] !='#')
    {
        rgcmd[ocmd] = pcmd[i];
        ocmd++;
        i++;
    }

    ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], (fDBCS ?
           pSV->StdVar[1].lStdVariable * 2 : pSV->StdVar[1].lStdVariable), 4);
    rgcmd[ocmd++] = ',';
    ocmd += (SHORT)iDwtoA_FillZero(&rgcmd[ocmd], pSV->StdVar[0].lStdVariable, 4);
    rgcmd[ocmd++] = '.';

    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);

    // save for FS_SINGLE_BYTE and FS_DOUBLE_BYTE
    pnp->sSBCSX = pnp->sSBCSXMove = (short)pSV->StdVar[1].lStdVariable;
    pnp->sDBCSX = pnp->sDBCSXMove = (short)(pSV->StdVar[1].lStdVariable << 1);

    // Reset address mode values.
    pnp->sSBCSYMove = pnp->sDBCSYMove = 0;
    pnp->jAddrMode = ADDR_MODE_NONE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMCommandCallback                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    INT APIENTRY OEMCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)   */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             ddwCmdCbID                                                    */
/*             dwCount                                                       */
/*             pdwParams                                                     */
/*                                                                           */
/*  Output:    INT                                                           */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams ) // points to values of command params
{
    WORD                wlen = 0;
    BYTE                ch[CCHMAXCMDLEN];

    PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

    switch(dwCmdCbID)
    {
    case MONOCHROME:
        pnp->jColorMode = (BYTE)dwCmdCbID;
        // OR mode
        WRITESPOOLBUF(pdevobj, "\x1C\"O.", 4);
        break;

    case COLOR_3PLANE:
    case COLOR_24BPP_2:
    case COLOR_24BPP_4:
    case COLOR_24BPP_8:

        pnp->jColorMode = (BYTE)dwCmdCbID;
        // Replace mode
        WRITESPOOLBUF(pdevobj, "\x1C\"R.", 4);
        break;

    case RES_300:
        pnp->wRes = 300;
        WRITESPOOLBUF(pdevobj, "\x1CYSU1,300,0;\x1CZ", 14);
        WRITESPOOLBUF(pdevobj, "\x1C<1/300,i.", 10);
        break;

    case RES_SENDBLOCK:
        {
            DWORD dwCursorX, dwCursorY;

            if(!pdwParams)
                return 0;

            pnp->dwBlockLen = PARAM(pdwParams, 0);
            pnp->dwBlockX = PARAM(pdwParams, 1);
            pnp->dwBlockY = PARAM(pdwParams, 2);
            dwCursorX = PARAM(pdwParams, 3);
            dwCursorY = PARAM(pdwParams, 4);

            if (IsColorPlanar(pnp))
            {
                //#355334: no need send cursor command. 
                // Send cursor move command using saved parameters
                //wlen = (WORD)wsprintf(ch, FS_E, dwCursorX, dwCursorY);
                //WRITESPOOLBUF(pdevobj, ch, wlen);

                // #308001: Garbage appear on device font
                // Send color command for each sendblocks.
                switch (pnp->jCurrentPlane) {
                case PLANE_CYAN:
                    wlen += (WORD)wsprintf(&ch[wlen],
                        "\x1C!s0,,,,,,.\x1C!o4,204,3.");
                    break;
                case PLANE_MAGENTA:
                    wlen += (WORD)wsprintf(&ch[wlen],
                        "\x1C!s0,,,,,,.\x1C!o4,204,2.");
                    break;
                case PLANE_YELLOW:
                    wlen += (WORD)wsprintf(&ch[wlen],
                        "\x1C!s0,,,,,,.\x1C!o4,204,1.");
                    break;
                }
                wlen += (WORD)wsprintf(&ch[wlen],
                    "\034R\034i%d,%d,0,1/1,1/1,%d,300.",
                    (pnp->dwBlockX * 8), pnp->dwBlockY,
                    pnp->dwBlockLen );

                WRITESPOOLBUF(pdevobj, ch, wlen);
                pnp->jAddrMode = ADDR_MODE_NONE;
            }
            else if (IsColorTrueColor(pnp)) {

                DWORD dwNewBufLen;
                INT iDepth;

#if 0
// #294780: pattern density changes
		DWORD dwSize;
#endif // 0

                // Allocate working buffer. We allocate Y + 1 rows
                // to save the block data passed from the Unidrv.
                // See the OEMFilterGraphics() code for the details.

                VERBOSE(("sb - l,x,y=%d,%d,%d, t=%d\n",
                    pnp->dwBlockLen, pnp->dwBlockX, pnp->dwBlockY,
                    pnp->dwTempBufLen));

                dwNewBufLen = pnp->dwBlockLen + pnp->dwBlockX;

                if (pnp->dwTempBufLen < dwNewBufLen) {
                    if (NULL != pnp->pTempBuf) {

                        VERBOSE(("sb - realloc\n"));

                        MemFree(pnp->pTempBuf);
                        pnp->pTempBuf = NULL;
                    }
                }
                if (NULL == pnp->pTempBuf) {
                    pnp->pTempBuf = MemAlloc(dwNewBufLen);
                    if (NULL == pnp->pTempBuf) {
                        ERR(("Faild to allocate temp. buffer\n"));
                        return 0;
                    }
                    pnp->dwTempBufLen = dwNewBufLen;
                    pnp->dwTempDataLen = 0;
                }

                // Construct printer command
                // This printer wants left-bottom corner's coordinate
                // for the parameter.

                iDepth = ColorOutDepth(pnp);

#if 0

// #294780: pattern density changes
		pnp->dwSrcX = pnp->dwBlockX / 3;
		pnp->dwSrcY = pnp->dwBlockY;
		pnp->dwSrcSize = pnp->dwBlockLen;
		// TODO: What should we do if each sizes are not even ?
		if (IsColorTrue8dens(pnp) &&
		    pnp->dwSrcX >= 2 && pnp->dwSrcY >= 2) {
		    pnp->dwSrcX /= 2;
		    pnp->dwSrcY /= 2;
		    pnp->dwSrcSize = (pnp->dwSrcX * 3) * pnp->dwSrcY;
		    pnp->fStretch = TRUE;
		} else
		    pnp->fStretch = FALSE;

                wlen = (WORD)wsprintf(ch, "\034!E%d,%d,%d,%d,%d,%d,%d,%d.",
                    iDepth, dwCursorX, (dwCursorY + pnp->dwBlockY - 1),
                    (pnp->dwBlockX / 3), pnp->dwBlockY,
                    pnp->dwSrcX, pnp->dwSrcY,
                    pnp->dwSrcSize);

#else // 0

                wlen = (WORD)wsprintf(ch, "\034!E%d,%d,%d,%d,%d,%d,%d,%d.",
                    iDepth, dwCursorX, (dwCursorY + pnp->dwBlockY - 1),
                    (pnp->dwBlockX / 3), pnp->dwBlockY,
                    (pnp->dwBlockX / 3), pnp->dwBlockY,
                    pnp->dwBlockLen);

#endif // 0

                WRITESPOOLBUF(pdevobj, ch, wlen);
            }
            else {
                ERR(("Unknown color mode, cannot handle.\n"));
            }
        }
        break;

        case PC_TYPE_F:
            wlen = (WORD)wsprintf(ch, ESC_RESET);
            WRITESPOOLBUF(pdevobj, ch, wlen);
            break;

        case PC_END_F:
            wlen = (WORD)wsprintf(ch, FS_RESO0_RESET);
            WRITESPOOLBUF(pdevobj, ch, wlen);
            break;

        case PC_ENDPAGE :
            wlen = (WORD)wsprintf(ch, FS_ENDPAGE, pnp->wCopies);
            WRITESPOOLBUF(pdevobj, ch, wlen);
            break;

        case PC_MULT_COPIES_N:
        case PC_MULT_COPIES_C:
            // FS_COPIES is neccesary for each page
            if(!pdwParams)
                return 0;

            if(dwCmdCbID == PC_MULT_COPIES_C)
            {
                ch[wlen] = '\034';
                wlen += (WORD)wsprintf(&ch[wlen], "05F2-02");
            }
            pnp->wCopies = (WORD)*pdwParams;

            wlen += (WORD)wsprintf(&ch[wlen], INIT_DOC, pnp->wRes, pnp->wRes);
            WRITESPOOLBUF(pdevobj, ch, wlen);
            break;

        case PC_PRN_DIRECTION:
            {
            short  sEsc, sEsc90;
            short  ESin[] = {0, 1, 0, -1};
            short  ECos[] = {1, 0, -1, 0};

            if(!pdwParams)
                return 0;

            pnp->sEscapement = (short)*pdwParams % 360;
            sEsc = pnp->sEscapement;
            sEsc90 = pnp->sEscapement/90;

            pnp->sSBCSXMove = pnp->sSBCSX * ECos[sEsc90];
            pnp->sSBCSYMove = -pnp->sSBCSX * ESin[sEsc90];
            pnp->sDBCSXMove = pnp->sDBCSX * ECos[sEsc90];
            pnp->sDBCSYMove = -pnp->sDBCSX * ESin[sEsc90];
            }
            break;

    // *** Cursor Movement CM *** //

    case CM_X_ABS:
    case CM_Y_ABS:

    {
        INT iRet = (INT)PARAM(pdwParams, 0);

        if (CM_X_ABS == dwCmdCbID) {
            pnp->CursorX = iRet;
        }
        else if (CM_Y_ABS == dwCmdCbID){
            pnp->CursorY = iRet;
        }
        wlen = (WORD)wsprintf(ch, FS_E, pnp->CursorX, pnp->CursorY);
        WRITESPOOLBUF(pdevobj, ch, wlen);

        return iRet;
    }

        case CM_CR:
            pnp->CursorX = 0;
            //#355334: ensure CursorX=0 after CR
            wlen = (WORD)wsprintf(ch, "\x0D\034e0,%d.", pnp->CursorY);
            WRITESPOOLBUF(pdevobj, ch, wlen);
            break;

        case CM_FF:
            pnp->CursorX = pnp->CursorY = 0;
            WRITESPOOLBUF(pdevobj, "\x0C", 1);
            break;

        case CM_LF:
            pnp->CursorX = 0;
            pnp->CursorY++;
            WRITESPOOLBUF(pdevobj, "\x0A", 1);
            break;

    // *** Font Simulation FS *** //
        case FS_DOUBLE_BYTE:

            wlen = (WORD)wsprintf(ch, FS_ADDRMODE_ON, pnp->sDBCSXMove,
                            pnp->sDBCSYMove);
            WRITESPOOLBUF(pdevobj, ch, wlen);

            if(pnp->fVertFont)
            {
                WRITESPOOLBUF(pdevobj, ESC_KANJITATE, 2);

                if(pnp->wScale == 1)
                    break;

                if(!pnp->fPlus)
                {
                    char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                     "4/1", "4/1", "6/1", "6/1", "8/1"};

                    wlen = (WORD)wsprintf(ch, FS_M_T, (PBYTE)bcom[pnp->wScale]);
                    WRITESPOOLBUF(pdevobj, ch, wlen);
                    break;
                } else {
                    ch[wlen] = '\034';
                    wlen += (WORD)wsprintf(&ch[wlen], "12S2-");
                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsx, 4);
                    ch[wlen++] = '-';
                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsy, 4);
                }
                WRITESPOOLBUF(pdevobj, ch, wlen);
            }
            break;

        case FS_SINGLE_BYTE:

            wlen = (WORD)wsprintf(ch, FS_ADDRMODE_ON, pnp->sSBCSXMove,
                            pnp->sSBCSYMove);
            WRITESPOOLBUF(pdevobj, ch, wlen);

            if(pnp->fVertFont)
            {
                WRITESPOOLBUF(pdevobj, ESC_KANJIYOKO, 2);

                if(pnp->wScale == 1)
                    break;

                if(!pnp->fPlus)
                {
                    char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                     "4/1", "4/1", "6/1", "6/1", "8/1"};

                    wlen = (WORD)wsprintf(ch, FS_M_Y, (LPSTR)bcom[pnp->wScale]);
                    WRITESPOOLBUF(pdevobj, ch, wlen);
                    break;
                } else {
                    ch[wlen] = '\034';
                    wlen += (WORD)wsprintf(&ch[wlen], "12S2-");
                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsx, 4);
                    ch[wlen++] = '-';
                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsy, 4);
                }
                WRITESPOOLBUF(pdevobj, ch, wlen);
            }
            break;

    case CMD_RECT_WIDTH :
        pnp->dwRectX = PARAM(pdwParams, 0);
        break;

    case CMD_RECT_HEIGHT :
        pnp->dwRectY = PARAM(pdwParams, 0);
        break;

    case CMD_BLACK_FILL:
    case CMD_GRAY_FILL:
    case CMD_WHITE_FILL:

    {
        INT iGrayLevel;
        wlen = 0;

        // Disable absolute addres mode, enter graphics.
        // Set fill mode.
        wlen += (WORD)wsprintf(&ch[wlen], "\034R\034YXX1;");

        if (CMD_BLACK_FILL == dwCmdCbID) {
            iGrayLevel = 0;
        }
        else if (CMD_WHITE_FILL == dwCmdCbID) {
            iGrayLevel = 100;
        }
        else {
            // Gray fill.
            // 0 = Black, 100 = White
            iGrayLevel = (INT)(100 - (WORD)PARAM(pdwParams, 2));
        }

        // Select ray level.
        wlen += (WORD)wsprintf(&ch[wlen], "SG%d;", iGrayLevel);

        // Move pen, fill rect.
        wlen += (WORD)wsprintf(&ch[wlen], "MA%d,%d;RR%d,%d;",
            (WORD)PARAM(pdwParams, 0),
            (WORD)PARAM(pdwParams, 1),
            (pnp->dwRectX - 1), (pnp->dwRectY - 1));

        // Disable fill mode.
        // Exit graphics.
        wlen += (WORD)wsprintf(&ch[wlen], "XX0;\034Z");

        // Now send command linet to the printer.
        WRITESPOOLBUF(pdevobj, ch, wlen);

        // Reset some flags to indicate graphics mode
        // side effects.
        pnp->jAddrMode = ADDR_MODE_NONE;
        break;
    }

// #308001: Garbage appear on device font
    case CMD_SENDCYAN:
        pnp->jCurrentPlane = PLANE_CYAN;
        break;

    case CMD_SENDMAGENTA:
        pnp->jCurrentPlane = PLANE_MAGENTA;
        break;

    case CMD_SENDYELLOW:
        pnp->jCurrentPlane = PLANE_YELLOW;
        break;

    default:
        WARNING(("Unknown command cllabck ID %d not handled.\n",
            dwCmdCbID))
        break;
    }
    return 0;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputCharStr                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMOutputCharStr(PDEVOBJ, PUNIFONTOBJ, DWORD,   */
/*                                                   DWORD, PVOID)           */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj                                                        */
/*             dwType                                                        */
/*             dwCount                                                       */
/*             pGlyph                                                        */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )

{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA          pTrans;
    //BYTE                aubBuff[256];
    WORD                wlen;
    WORD                i;
    WORD                wTmpChar;
    BYTE                ch[512];
    BOOL                fDBCSFont;
    WORD                wComLen;
    BYTE                command[CCHMAXCMDLEN];
	PBYTE				pTempBuf;

    PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

    wlen = 0;

    switch(dwType)
    {
        case TYPE_GLYPHHANDLE:      // Device Font
        {
            if( pUFObj->ulFontID != pnp->wOldFontID )
            {
                pnp->jAddrMode = ADDR_MODE_NONE;
                pnp->wOldFontID = (WORD)pUFObj->ulFontID;
            }

            switch(pUFObj->ulFontID)
            {
                case 5: // Courier
                case 6: // Helv
                case 7: // TmsRmn
                case 8: // TmsRmn Italic
                    fDBCSFont = FALSE;
                    break;

                default:
                    fDBCSFont = TRUE;
                    break;
            }

// #333653: Change I/F for GETINFO_GLYPHSTRING begin
            GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
            GStr.dwCount   = dwCount;
            GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
            GStr.pGlyphIn  = pGlyph;
            GStr.dwTypeOut = TYPE_TRANSDATA;
            GStr.pGlyphOut = NULL;
		    GStr.dwGlyphOutSize = 0;		/* new member of GETINFO_GLYPHSTRING */

			/* Get TRANSDATA buffer size */
            if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
				 || !GStr.dwGlyphOutSize )
            {
                ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                return;
            }

			/* Alloc TRANSDATA buffer */
			if(!(pTempBuf = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
			{
				ERR(("Memory alloc failed.\n"));
				return ;
			}
            pTrans = (PTRANSDATA)pTempBuf;

			/* Get actual TRANSDATA */
			GStr.pGlyphOut = pTrans;
			if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,	0, NULL))
			{
				ERR(("GetInfo failed.\n"));
		    	return;
			}
// #333653: Change I/F for GETINFO_GLYPHSTRING end

// #346241: SBCS pitch is widely.
            if(fDBCSFont &&
                (pTrans[0].ubType & MTYPE_FORMAT_MASK) == MTYPE_PAIRED &&
                pTrans[0].uCode.ubPairs[0])
            {
                if (ADDR_MODE_DBCS != pnp->jAddrMode)
                {
                    WORD        wLen;
                    BYTE        cH[CCHMAXCMDLEN];

                    wLen = (WORD)wsprintf(cH, FS_ADDRMODE_ON, pnp->sDBCSXMove,
                                                            pnp->sDBCSYMove);
                    WRITESPOOLBUF(pdevobj, cH, wLen);

                    if(pnp->fVertFont)
                    {
                        WRITESPOOLBUF(pdevobj, ESC_KANJITATE, 2);

                        if(pnp->wScale != 1)
                        {
                            if(!pnp->fPlus)
                            {
                                char  *bcom[] = {"1/2","1/1","2/1","3/1",
                                             "4/1","4/1","6/1","6/1","8/1"};

                                wLen = (WORD)wsprintf(cH, FS_M_T,
                                                    (PBYTE)bcom[pnp->wScale]);
                            } else {
                                cH[wLen] = '\034';
                                wLen += (WORD)wsprintf(&cH[wLen], "12S2-");
                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
                                                            pnp->lPointsx, 4);
                                cH[wLen++] = '-';
                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
                                                            pnp->lPointsy, 4);
                            }
                            WRITESPOOLBUF(pdevobj, cH, wLen);
                        }
                    }
                    pnp->jAddrMode = ADDR_MODE_DBCS;
                }
            } else {
                if(ADDR_MODE_SBCS != pnp->jAddrMode)
                {
                    WORD        wLen;
                    BYTE        cH[CCHMAXCMDLEN];

                    wLen = (WORD)wsprintf(cH, FS_ADDRMODE_ON, pnp->sSBCSXMove,
                                                            pnp->sSBCSYMove);
                    WRITESPOOLBUF(pdevobj, cH, wLen);

                    if(pnp->fVertFont)
                    {
                        WRITESPOOLBUF(pdevobj, ESC_KANJIYOKO, 2);

                        if(pnp->wScale != 1)
                        {
                            if(!pnp->fPlus)
                            {
                                char  *bcom[] = {"1/2","1/1","2/1","3/1",
                                             "4/1","4/1","6/1","6/1","8/1"};

                                wLen = (WORD)wsprintf(cH, FS_M_Y,
                                                    (PBYTE)bcom[pnp->wScale]);
                            } else {
                                cH[wLen] = '\034';
                                wLen += (WORD)wsprintf(&cH[wLen], "12S2-");
                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
                                                            pnp->lPointsx, 4);
                                cH[wLen++] = '-';
                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
                                                            pnp->lPointsy, 4);
                            }
                            WRITESPOOLBUF(pdevobj, cH, wLen);
                        }
                    }
                    pnp->jAddrMode = ADDR_MODE_SBCS;
                }
            }

            for(i = 0; i < dwCount; i++, pTrans++)
            {
                switch(pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                    case MTYPE_PAIRED:
                        memcpy(((PBYTE)(ch + wlen)), pTrans->uCode.ubPairs, 2);
                        wlen += 2;
                        break;

                    case MTYPE_DIRECT:
                        wTmpChar = (WORD)pTrans->uCode.ubCode;

                        if (!fDBCSFont)
                             wTmpChar = Ltn1ToAnk( wTmpChar );

                        *(PWORD)(ch + wlen) = SWAPW(wTmpChar);
                        wlen += 2;
                        break;
                }
            }

            if(wlen)
                WRITESPOOLBUF(pdevobj, ch, wlen);

            break;
        }   // case TYPE_GLYPHHANDLE

        default:
            break;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//----------------------------------------------------------------------------
// Filename:    pdev.h
// This file contains definitions for KPDL mini-driver
//-----------------------------------------------------------------------------
#ifndef _PDEV_H
#define _PDEV_H


#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'KPDL'
#define DLLTEXT(s)      "KPDL: " s
#define OEM_VERSION      0x00010000L

// kpdlres mini driver device data structure
typedef struct
{
    WORD            wRes;            // resolution 600 or 400 or 240
    WORD            wCopies;         // number of multi copies
    short           sSBCSX;
    short           sDBCSX;
    short           sSBCSXMove;      // use to set address mode
    short           sSBCSYMove;      // use to set address mode
    short           sDBCSXMove;      // use to set address mode
    short           sDBCSYMove;      // use to set address mode
    short           sEscapement;     // use to set address mode
    BOOL            fVertFont;       // for TATEGAKI font
    WORD            wOldFontID;
    BOOL            fPlus;
    WORD            wScale;
    LONG            lPointsx;
    LONG            lPointsy;
    int             CursorX;
    int             CursorY;

    // Used for rect-fill operations.

    DWORD dwRectX;
    DWORD dwRectY;

    // Temp. buffer parameters.

    DWORD dwBlockX, dwBlockY, dwBlockLen;
    PBYTE pTempBuf;
    DWORD dwTempBufLen;
    DWORD dwTempDataLen;

    // Absolute address mode setting.

#define ADDR_MODE_NONE 0
#define ADDR_MODE_SBCS 1
#define ADDR_MODE_DBCS 2

    BYTE jAddrMode;

    // Color mode values.  Sam values also used
    // for the command callback IDs.

#define COLOR_24BPP_2                120
#define COLOR_24BPP_4                121
#define COLOR_24BPP_8                122
#define COLOR_3PLANE                 123
#define MONOCHROME                   124

    BYTE jColorMode;

// #308001: Garbage appear on device font
#define PLANE_CYAN              1
#define PLANE_MAGENTA           2
#define PLANE_YELLOW            3
    BYTE jCurrentPlane;

#if 0
// #294780: pattern density changes
    BOOL fStretch;
    DWORD dwSrcX, dwSrcY, dwSrcSize;
#endif // 0

} MYDATA, *PMYDATA;

#define MINIDEV_DATA(p) \
    ((p)->pdevOEM)

#define IsColorPlanar(p) \
    ((MONOCHROME == (p)->jColorMode) \
    || (COLOR_3PLANE == (p)->jColorMode))

#define IsColorTrueColor(p) \
    (!IsColorPlanar(p))

#if 0
// #294780: pattern density changes
#define IsColorTrue8dens(p) \
    ((p)->jColorMode == COLOR_24BPP_8)
#endif // 0

#define ColorOutDepth(p) \
    (((p)->jColorMode == COLOR_24BPP_2)?1:\
    (((p)->jColorMode == COLOR_24BPP_4)?2:\
    (((p)->jColorMode == COLOR_24BPP_8)?3:1)))

typedef struct
{
    OEM_DMEXTRAHEADER   dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// NPDL2 command
#define ESC_RESET         "\033c1"                // software reset
#define ESC_KANJIYOKO     "\033K"                 // kanji yoko mode
#define ESC_KANJITATE     "\033t"                 // kanji yoko mode
#define FS_PAGEMODE       "\034d240.",        6   // page mode
#define FS_DRAWMODE       "\034\"R.",         4   // draw mode
#define FS_ADDRMODE_ON    "\034a%d,%d,0,B."       // set address mode
#define FS_GRPMODE_ON     "\034Y",            2   // set graphic mode
#define FS_GRPMODE_OFF    "\034Z",            2   // reset graphic mode
#define FS_SETMENUNIT     "\034<1/%d,i."          // select men-mode resolution
#define FS_JIS78          "\03405F2-00",      8   // select JIS78
#define FS_JIS90          "\03405F2-02"           // select JIS90
#define FS_ENDPAGE        "\034R\034x%d.\015\014" // end page
#define FS_E              "\034e%d,%d."
#define FS_RESO           "\034&%d."
#define FS_RESO0_RESET    "\034&0.\033c1"
#define INIT_DOC          "\034<1/%d,i.\034YSU1,%d,0;\034Z"
#define RESO_PAGE_KANJI   "\034&%d.\034d240.\033K"
#define FS_I              "\034R\034i%d,%d,0,1/1,1/1,%d,%d."
#define FS_I_2            "\034R\034i%d,%d,5,1/1,1/1,%d,%d."
#define FS_I_D            "%d,%d."
#define FS_M_Y            "\034m1/1,%s."
#define FS_M_T            "\034m%s,1/1."
#define FS_12S2           "\03412S2-%04ld-%04ld"

// Command CallBack ID
#define CALLBACK_ID_MAX              255 //

// PAGECONTROL
#define PC_MULT_COPIES_N               1
#define PC_MULT_COPIES_C               2
#define PC_TYPE_F                      4
#define PC_END_F                       6
#define PC_ENDPAGE                     7
#define PC_PRN_DIRECTION               9

// FONTSIMULATION
#define FS_SINGLE_BYTE                20
#define FS_DOUBLE_BYTE                21

// RESOLUTION
#define RES_240                       30
#define RES_400                       31
#define RES_300                       35
#define RES_SENDBLOCK                 36

//CURSORMOVE
#define CM_X_ABS                     101
#define CM_Y_ABS                     102
#define CM_CR                        103
#define CM_FF                        104
#define CM_LF                        105

#define CMD_RECT_WIDTH              130
#define CMD_RECT_HEIGHT             131
#define CMD_WHITE_FILL              132
#define CMD_GRAY_FILL               133
#define CMD_BLACK_FILL              134

// #308001: Garbage appear on device font
#define CMD_SENDCYAN                141
#define CMD_SENDMAGENTA             142
#define CMD_SENDYELLOW              143

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

WORD Ltn1ToAnk( WORD );
static int iDwtoA_FillZero(PBYTE, long, int );

#endif  //PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

#if 0
    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

#if 0
    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

#if 0
    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\konic\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=kpdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),kpdlres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\common.c \
    $(SRCDIR)\kpdlres.c \
    $(SRCDIR)\kpdlres.rc

MISCFILES=\
    $(SRCDIR)\kpdlres.ini \
    $(GPDDIR)\kokl21j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\reg_def.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// REG_DEF.H

#define MULTI_SCALE  "Multi Scale"
#define FAX_ON       "Fax On"
#define FAX_MYNAME   "Fax MyName"
#define FAX_ID       "Fax Id"
#define FAX_RES      "Fax Res"
#define FAX_USEBOOK  "Fax UseBook"
#define FAX_DSTTEL   "Fax DstTel"
#define FAX_IDDSTTEL "Fax DstTelID"
#define FAX_TEL      "Fax Tel  %d"
#define FAX_BOOK     "Fax Book %d"
#define FAX_BOOK1    "Fax Book 1"
#define FAX_BOOK2    "Fax Book 2"
#define FAX_LISTTYPE "Fax ListType"
#define FAX_DRIVE    "Fax Drive"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\kpdlms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "KPDLMS";

#define  PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#include "kpdlms.h"
#include "reg_def.h"
//#include "mydebug.h"

#define BM_DEVICE  0x8080

#define SHIFTJIS_CHARSET  128
#define CCHMAXCMDLEN      128

#define COMP_TH           3

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR *LPCD;

typedef struct
{
    SIZEL    sizlExtent;
    POINTFX  pfxOrigin;
    POINTFX  pfxCharInc;
} BITMAPMETRICS, FAR *LPBITMAPMETRICS;

#ifndef WINNT
typedef BYTE huge *LPDIBITS;
#else
typedef BYTE *LPDIBITS;
#endif //WINNT

// add for FAX BEGINDOC & ENDDOC
#define NAME_LENGTH  33
#define ID_LENGTH    17

#define MULTI_SCALE "Multi Scale"

#ifdef WINNT
#include <stdio.h>
#undef wsprintf
#define wsprintf sprintf

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

#undef  GlobalFreePtr
#define GlobalFreePtr  UniDrvFreeMem

#define DrvGetPrinterData(a,b,c,d,e,f)  TRUE
#define DrvSetPrinterData(a,b,c,d,e)    TRUE

#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))

#define FLAG_SBCS  1
#define FLAG_DBCS  2

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

BYTE IsDBCSLeadByteNPDL(
BYTE Ch)
{
    return ShiftJis[Ch];
}
WORD SJis2JisNPDL(
WORD usCode)
{

    union {
        USHORT bBuffer;
        struct tags{
            UCHAR al;
            UCHAR ah;
        } s;
    } u;

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (usCode >= 0xf040) {
        usCode = 0x8145;
    }

    u.bBuffer = usCode;

    u.s.al -= u.s.al >= 0x80 ;
    u.s.al -= 0x1F ;
    u.s.ah &= 0xBF ;
    u.s.ah <<= 1 ;
    u.s.ah += 0x21-0x02 ;

    if (u.s.al > 0x7E )
    {
        u.s.al -= (0x7F-0x21) ;
        u.s.ah++;
    }
     return (u.bBuffer);
}

// In case it is a single byte font, we will some of the characters
// (e.g. Yen-mark) to the actual printer font codepoint.  Note since
// the GPC data sets 0 to default CTT ID value, single byte codes
// are in codepage 1252 (Latin1) values.

WORD
Ltn1ToAnk(
   WORD wCode )
{
    // Not a good mapping table now.

    switch ( wCode ) {
    case 0xa5: // YEN MARK
        wCode = 0x5c;
        break;
    default:
        if ( wCode >= 0x7f)
            wCode = 0xa5;
    }

    return wCode;
}

#endif // WINNT

#if 0
int Table[]={
    0, 175, 349, 523, 698, 872, 1045, 1219, 1392, 1564,
    1736, 1908, 2079, 2250, 2419, 2588, 2756, 2924, 3090, 3256,
    3420, 3584, 3746, 3907, 4067, 4226, 4384, 4540, 4695, 4848,
    5000, 5150, 5299, 5446, 5592, 5736, 5878, 6018, 6157, 6293,
    6428, 6561, 6691, 6820, 6947, 7071, 7193, 7314, 7431, 7547,
    7660, 7771, 7880, 7986, 8090, 8192, 8290, 8387, 8480, 8572,
    8660, 8746, 8829, 8910, 8988, 9063, 9135, 9205, 9272, 9336,
    9397, 9455, 9511, 9563, 9613, 9659, 9703, 9744, 9781, 9816,
    9848, 9877, 9903, 9925, 9945, 9962, 9976, 9986, 9994, 9998,
10000};

int NEAR PASCAL Tbl(int x)
{
    int a, b;

    a = Table[x / 10];
    b = Table[x / 10 + 1] - a;

    return a + (x % 10) * b / 10;
}

int NEAR PASCAL Tsin(int x)
{
    if(x <= 900) return Tbl(x);

    if(x <= 1800) return Tbl(1800 - x);

    if(x <=2700) return -Tbl(x - 1800);

    return -Tbl(3600 - x);
}

int NEAR PASCAL Tcos(int x)
{
    if(x <= 900) return Tbl(900 - x);

    if(x <= 1800) return -Tbl(x - 900);

    if(x < 2700) return -Tbl(2700 - x);

    return Tbl(x - 2700);
}
#endif

//-------------------------------------------------------------------
// m2d
// Action:convert master unit to device unit
//-------------------------------------------------------------------
int NEAR PASCAL m2d(int x, WORD res)
{
// 300 only : sueyas

    return x;
#if 0
    if(res == 400) return x / 3;

    if(res == 600) return x >> 1;

    return x / 5;
#endif
}

#ifndef WINNT
VOID NEAR PASCAL memcpy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    while(wLen--) *lpDst++ = *lpSrc++;
}
#endif //WINNT

//------------------------------------------------------------------
// REL1
// Action : compress image data
//------------------------------------------------------------------
WORD NEAR PASCAL RLE1(
LPBYTE lpDst,
LPBYTE lpSrc,
WORD   wLen)
{
    LPBYTE lpTemp, lpEnd, lpDsto;
    WORD   len, deflen;

    lpDsto = lpDst;
    lpEnd = lpSrc + wLen;

    while(lpSrc < lpEnd)
    {
        lpTemp = lpSrc++;

        if(lpSrc == lpEnd)
        {
            *lpDst++ = 0x41;
            *lpDst++ = *lpTemp;
            break;
        }

        if(*lpTemp == *lpSrc)
        {
            lpSrc++;

            while(lpSrc < lpEnd && *lpTemp == *lpSrc) lpSrc++;

            len = lpSrc - lpTemp;

            if(len < 63)
            {
                *lpDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *lpDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *lpDst++ = 0xff;
                len -= 255;
            }

            *lpDst++ = (BYTE)len;
T1:
            *lpDst++ = *lpTemp;
            continue;
        }

        lpSrc++;

        while(lpSrc < lpEnd)
        {
            if(*lpSrc == *(lpSrc - 1))
            {
                lpSrc--;
                break;
            }

            lpSrc++;
        }

        deflen = len = lpSrc - lpTemp;

        if(len < 63)
        {
            *lpDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *lpDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *lpDst++ = 0xff;
            len -= 255;
        }

        *lpDst++ = (BYTE)len;
T2:
        memcpy(lpDst, lpTemp, deflen);
        lpDst += deflen;
    }

    return (WORD)(lpDst - lpDsto);
}

//-------------------------------------------------------------------
// CBFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
WORD FAR PASCAL CBFilterGraphics(
LPDV  lpdv,
LPBYTE lpBuf,
WORD  wLen)
{
    WORD       wlen, wDatalen, wCounter;
    BYTE       ch[CCHMAXCMDLEN];
    LPNPDL2MDV lpnp;
    LPBYTE     lpLBuff;
    LPBYTE     lpBuff, lpTemp, lpBuffo, lpEnd;
    LPBYTE     lpBuff2, lpBuff2o;

    if(!lpdv->fMdv) return wLen;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    if(lpnp->fComp == FALSE)
    {
        if( lpnp->fMono || (lpnp->Color == COLOR_8) ){
            WriteSpoolBuf(lpdv, lpBuf, wLen);
        }
        else{

            WORD   i;
            LPSTR  lpTmp, lpBuf2;
            BYTE   bR, bG, bB;
            BOOL   fAlternate= FALSE;

            lpTmp = lpBuf;
            lpBuf2 = lpBuf;

            // Change order to RGB -> BGR

            for( i = 0; i < wLen; lpBuf+=3, i+=3 ){

   //             if (fAlternate){
   //                 fAlternate = FALSE;
   //                 continue;
   //             }else
   //                 fAlternate = TRUE;

                bR = (BYTE)*lpBuf;
                bG = (BYTE)*(lpBuf+1);
                bB = (BYTE)*(lpBuf+2);

                *lpBuf2 = (BYTE)bB;
                *(lpBuf2+1) = (BYTE)bG;
                *(lpBuf2+2) = (BYTE)bR;

                lpBuf2+=3;
            }
            WriteSpoolBuf(lpdv, lpTmp, wLen);
    //        WriteSpoolBuf(lpdv, lpTmp, wLen/2);
            
        }
        return wLen;
    }

#ifdef WINNT

    memcpy(lpnp->lpBuff, lpBuf, wLen);
    lpnp->lpBuff += wLen;
    if (lpnp->lpBuff
            < lpnp->lpLBuff + lpnp->wBitmapX + lpnp->wBitmapLen)
        return wLen;

#else // WINNT

    if(!lpnp->wBitmapYC) return wLen;

    lpnp->lpBuff += wLen;
    memcpy(lpnp->lpBuff, lpBuf, wLen);

    if(--lpnp->wBitmapYC) return wLen;
#endif // WINNT

    wCounter = lpnp->wBitmapY;
    lpLBuff = lpnp->lpLBuff;

#ifdef WINNT
    lpBuffo = lpBuff = lpTemp = lpLBuff + lpnp->wBitmapX;
#else // WINNT
    lpBuffo = lpBuff = lpTemp = lpLBuff + wLen;
#endif // WINNT
    lpBuff2o = lpBuff2 = lpBuff + lpnp->wBitmapLen;

    do
    {
#ifdef WINNT
        lpEnd = lpBuff + lpnp->wBitmapX;
#else // WINNT
        lpEnd = lpBuff + wLen;
#endif // WINNT

        while(lpBuff < lpEnd)
        {
            while(lpBuff < lpEnd && *lpLBuff != *lpBuff)
            {
                lpLBuff++;
                lpBuff++;
            }

            wlen = lpBuff - lpTemp;

            if(wlen)
            {
                lpBuff2 += RLE1(lpBuff2, lpTemp, wlen);
                lpTemp = lpBuff;
            }

            if(lpBuff == lpEnd) break;

            while(lpBuff < lpEnd && *lpLBuff == *lpBuff)
            {
                lpLBuff++;
                lpBuff++;
            }

            wlen = lpBuff - lpTemp;

            if(wlen < 63)
            {
                *lpBuff2++ = (BYTE)wlen;
                goto T;
            }

            *lpBuff2++ = 0x3f;
            wlen -= 63;

            while(wlen >= 255)
            {
                *lpBuff2++ = (BYTE)0xff;
                wlen -= 255;
            }

            *lpBuff2++ = (BYTE)wlen;
T:
            lpTemp = lpBuff;
        }

        *lpBuff2++ = (BYTE)0x80;
        wDatalen = (WORD)(lpBuff2 - lpBuff2o);

        if(wDatalen > lpnp->wBitmapLen)
        {
#ifdef WINNT
            wlen = wsprintf(ch, FS_I, (lpnp->wBitmapX << 3),
                    lpnp->wBitmapY, lpnp->wBitmapLen, lpnp->wRes);
            lpnp->wCurrentAddMode = 0;
#else // WINNT
            wlen = wsprintf(ch, FS_I, (wLen << 3), lpnp->wBitmapY,
                            lpnp->wBitmapLen, lpnp->wRes);
#endif // WINNT
            WriteSpoolBuf(lpdv, ch, wlen);
            WriteSpoolBuf(lpdv, lpBuffo, lpnp->wBitmapLen);
            GlobalFreePtr(lpnp->lpLBuff);
            return wLen;
        }
    }
    while(--wCounter);

#ifdef WINNT
    wlen = wsprintf(ch, FS_I_2, (lpnp->wBitmapX << 3), lpnp->wBitmapY,
            wDatalen, lpnp->wRes);
    lpnp->wCurrentAddMode = 0;
#else // WINNT
    wlen = wsprintf(ch, FS_I_2, (wLen << 3), lpnp->wBitmapY, wDatalen,
                    lpnp->wRes);
#endif // WINNT
    WriteSpoolBuf(lpdv, ch, wlen);
    WriteSpoolBuf(lpdv, lpBuff2o, wDatalen);
    GlobalFreePtr(lpnp->lpLBuff);
    return wLen;
}

//-------------------------------------------------------------------
// fnOEMTTBitmap
// Action: Dummy
//-------------------------------------------------------------------
BOOL FAR PASCAL fnOEMTTBitmap(
LPDV       lpdv,
LPFONTINFO lpFont,
LPDRAWMODE lpDrawMode)
{
    return TRUE;
}

//-------------------------------------------------------------------
// fnOEMGetFontCmd
// Action: Dummy
//-------------------------------------------------------------------
BOOL FAR PASCAL fnOEMGetFontCmd(
LPDV    lpdv,
WORD    wCmdCbId,
LPSTR   lpfont,
BOOL    fSelect,
LPBYTE  lpBuf,
LPWORD  lpwSize)
{
    return TRUE;
}

//-------------------------------------------------------------------
// OEMSendScalableFontCmd
// Action:  send NPDL2-style font selection command.
//-------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(
LPDV        lpdv,
LPCD        lpcd,     // offset to the command heap
LPFONTINFO  lpFont)
{
    short  ocmd;
    BYTE   i;
    long   tmpPointsx, tmpPointsy;
    LPSTR  lpcmd;
    BYTE   rgcmd[CCHMAXCMDLEN];    // build command here
    BOOL   fDBCS;


    LPNPDL2MDV  lpnp;

    if(!lpcd || !lpFont) return;

    if(!lpdv->fMdv) return;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd + 1);

    tmpPointsy = (long)lpFont->dfPixHeight * 720 / (long)lpnp->wRes;
    ocmd = i = 0;

    while(lpcmd[i] !='#')
    {
        rgcmd[ocmd] = lpcmd[i];
        ocmd++;
        i++;
    }

    i++;
    lpnp->fVertFont = lpnp->fPlus = FALSE;

    switch(lpcmd[i])
    {
    case 'R':
        lpnp->fPlus = TRUE;
        tmpPointsx = (long)lpFont->dfAvgWidth * 1200 / (long)lpnp->wRes;
        break;

    case 'P':
        fDBCS = FALSE; 
        tmpPointsx = ((long)lpFont->dfAvgWidth * 1200 + 600) /
                     (long)lpnp->wRes;
        break;

    case 'W':
        lpnp->fVertFont = TRUE;

    case 'Q':
        fDBCS = TRUE; 
        tmpPointsx = (long)lpFont->dfAvgWidth * 1440 / (long)lpnp->wRes;
        break;

    case 'Y':
        lpnp->fVertFont = TRUE;

    case 'S':
        lpnp->fPlus = TRUE;
        tmpPointsx = (long)lpFont->dfAvgWidth * 1440 / (long)lpnp->wRes;
        break;
    }

    if(lpnp->fPlus)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        lpnp->wScale = tmpPointsx == tmpPointsy;
        lpnp->lPointsx = tmpPointsx;
        lpnp->lPointsy = tmpPointsy;

        if(lpnp->fVertFont)
        {
            if(lpnp->wScale)
                ocmd += wsprintf(&rgcmd[ocmd], FS_12S2, tmpPointsy,
                                 tmpPointsx);
        }
        else
            ocmd += wsprintf(&rgcmd[ocmd], "%04ld-%04ld", tmpPointsx,
                             tmpPointsy);
        goto SEND_COM;
    }

    lpnp->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

    lpnp->wScale = (int)(tmpPointsx / tmpPointsy);

    if(lpnp->wScale > 8) lpnp->wScale = 8;

MAKE_COM:
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld", tmpPointsy);

SEND_COM:
    // write spool builded command
    WriteSpoolBuf(lpdv, rgcmd, ocmd);

    i++;
    ocmd = 0;
    while(lpcmd[i] !='#')
    {
        rgcmd[ocmd] = lpcmd[i];
        ocmd++;
        i++;
    }
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld,", (fDBCS ? lpFont->dfAvgWidth * 2 : lpFont->dfAvgWidth));
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld.", lpFont->dfPixHeight);
    WriteSpoolBuf(lpdv, rgcmd, ocmd);
#if 0 
    if(!lpnp->fPlus)
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(lpnp->fVertFont)
        {
            if(lpnp->wScale == 1)
            {
                ocmd = wsprintf(rgcmd, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, rgcmd, ocmd);
            }
        }
        else
        {
            ocmd = wsprintf(rgcmd, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
            WriteSpoolBuf(lpdv, rgcmd, ocmd);
        }
    }
#endif

    // save for FS_SINGLE_BYTE and FS_DOUBLE_BYTE
    lpnp->sSBCSX = lpnp->sSBCSXMove = lpFont->dfAvgWidth;
    lpnp->sDBCSX = lpnp->sDBCSXMove = lpFont->dfAvgWidth << 1;
    lpnp->sSBCSYMove = lpnp->sDBCSYMove = 0;
#ifdef WINNT
    lpnp->wCurrentAddMode = 0;
#endif
}

//-------------------------------------------------------------------
// fnOEMOutputCmd
// Action :
//-------------------------------------------------------------------
VOID FAR PASCAL fnOEMOutputCmd(
LPDV     lpdv,
WORD     wCmdCbId,
LPDWORD  lpdwParams)
{
    WORD        wlen;
   BYTE        ch[CCHMAXCMDLEN];
    LPNPDL2MDV  lpnp;


    if(!lpdv->fMdv) return;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    switch(wCmdCbId)
    {
    case COLOR_8:
        lpnp->Color = COLOR_8;
        break;
    case COLOR_TRUE:
        lpnp->Color = COLOR_TRUE;
        break;
    case KAICHO4:
        lpnp->Kaicho = 2;
        break;
    case KAICHO8:
        lpnp->Kaicho = 3;
        break;
// *** Resolutions   RES *** //
    case RES_600:
    case RES_400:
    case RES_240:
        lpnp->wRes = wCmdCbId == RES_600 ? 600 :
                    (wCmdCbId == RES_400 ? 400 : 240);

        wlen = wsprintf(ch, RESO_PAGE_KANJI, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;
    case RES_300:
        lpnp->wRes = 300;
        WriteSpoolBuf(lpdv, "\x1CYSU1,300,0;\x1CZ", 14);
        WriteSpoolBuf(lpdv, "\x1C<1/300,i.", 10);

        if (lpnp->fMono == FALSE){

            WriteSpoolBuf(lpdv, "\x1B\x43\x30", 3);
            WriteSpoolBuf(lpdv, "\x1CYOP2,13;", 9);
            WriteSpoolBuf(lpdv, "QB0,255,255,255,0,0,0;", 22);
            WriteSpoolBuf(lpdv, "XX1;\x1CZ", 6);
        }

        break;

    case RES_SENDBLOCK:
        {
            WORD size, x, y;

            if(!lpdwParams) return;

            size = (WORD)*lpdwParams;
            y = (WORD)*(lpdwParams + 1);
            x = (WORD)*(lpdwParams + 2);

            if( lpnp->fMono || (lpnp->Color == COLOR_8) ){
              
                wlen = wsprintf(ch, "\034R\034i%d,%d,0,1/1,1/1,%d,300.", x * 8, y, size );
                WriteSpoolBuf(lpdv, ch, wlen);
#ifdef WINNT
                lpnp->wCurrentAddMode = 0;
#endif

            }
            else{

                wlen = wsprintf(ch, "\034!E%d,%d,%d,%d,%d,%d,%d,%d.", 
                                lpnp->Kaicho, lpnp->CursorX, lpnp->CursorY,
                                x/3, y, x/3, y, size );
                                //x/3, y, (x/3)/2, y/2, size/2 );
      
                WriteSpoolBuf(lpdv, ch, wlen);

            }
        }
        break;

    case RES_BLOCKOUT2:
        {
        WORD size, x, y;

        if(!lpdwParams) return;

        size = (WORD)*lpdwParams;
        y = (WORD)*(lpdwParams + 1);
        x = (WORD)*(lpdwParams + 2);

#ifdef WINNT
        lpnp->wBitmapX = x;
        lpnp->wBitmapY = y;
#else // WINNT
        lpnp->wBitmapY = lpnp->wBitmapYC = y
#endif // WINNT

        lpnp->wBitmapLen = size;

        if(x < COMP_TH) goto NOCOMP;

#ifndef WINNT
        lpnp->hBuff = GlobalAlloc(GHND, x * 3 + (size << 1) + y);

        if(!lpnp->hBuff) goto NOCOMP;

        lpnp->lpLBuff = lpnp->lpBuff = (LPSTR)GlobalLock(lpnp->hBuff);

        if(!lpnp->lpBuff)
        {
            GlobalFree(lpnp->hBuff);
            goto NOCOMP;
        }
#else // WINNT

        lpnp->lpLBuff = (LPSTR)UniDrvAllocMem(x * 3 + (size << 1) + y);

        if (lpnp->lpBuff == NULL)
        {
            goto NOCOMP;
        }

        memset(lpnp->lpLBuff, 0, (x * 3 + (size << 1) + y));
        lpnp->lpBuff = lpnp->lpLBuff + lpnp->wBitmapX;

#endif // WINNT

        lpnp->fComp = TRUE;
        break;

NOCOMP:
        lpnp->fComp = FALSE;
        wlen = wsprintf(ch, FS_I, (x << 3), y, size, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
#ifdef WINNT
        lpnp->wCurrentAddMode = 0;
#endif
        }
        break;

// *** Page Control PC *** //
    case PC_TYPE_F:
        {
        DWORD dwTmp, dwType, dwData;
        char  szBuff[80];
        short nDouhou;

        WriteSpoolBuf(lpdv, ESC_RESET);

        if(DrvGetPrinterData(lpnp->szDevName, FAX_ON, &dwType, (LPBYTE)&dwTmp,
                             sizeof(DWORD), &dwData))
            dwTmp = 0;

        if(dwTmp)
        {
            lpnp->fFax = TRUE;
            dwTmp = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_ON, REG_DWORD,
                              (LPBYTE)&dwTmp, sizeof(DWORD));
            WriteSpoolBuf(lpdv, FX_INIT);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_USEBOOK, &dwType,
                                 (LPBYTE)&dwTmp, sizeof(DWORD), &dwData))
                nDouhou = 0;
            else
                nDouhou = (int)dwTmp;

            dwTmp = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_USEBOOK, REG_DWORD,
                              (LPBYTE)&dwTmp, sizeof(DWORD));

            if(nDouhou)
            {
                int i = 0;
                char telBuf[40];

                while(1)
                {
                    i++;
                    wsprintf(telBuf, FAX_TEL, i);

                    if(DrvGetPrinterData(lpnp->szDevName, telBuf, &dwType,
                                         szBuff, sizeof(szBuff),
                                         &dwData))
                        break;

                    wlen = wsprintf(ch, FX_TEL, (LPSTR)szBuff);
                    WriteSpoolBuf(lpdv, ch, wlen);
                }
            }
            else
            {
                if(DrvGetPrinterData(lpnp->szDevName, FAX_IDDSTTEL, &dwType,
                                     szBuff, sizeof(szBuff), &dwData))
                    szBuff[0] = 0;

                if(szBuff[0])
                {
                    wlen = wsprintf(ch, FX_TEL, (LPSTR)szBuff);
                    WriteSpoolBuf(lpdv, ch, wlen);
                }
            }

            szBuff[0] = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_DSTTEL, REG_SZ, szBuff, 1);
            DrvSetPrinterData(lpnp->szDevName, FAX_IDDSTTEL, REG_SZ, szBuff,
                              1);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_RES, &dwType,
                                 (LPBYTE)&dwTmp, sizeof(DWORD), &dwData))
                dwTmp = 0;

            wlen = wsprintf(ch, FX_QUA, (int)dwTmp);
            WriteSpoolBuf(lpdv, ch, wlen);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_MYNAME, &dwType, szBuff,
                                 sizeof(szBuff), &dwData))
                szBuff[0] = 0;

            if(szBuff[0])
            {
                wlen = wsprintf(ch, FX_MY, (LPSTR)szBuff);
                WriteSpoolBuf(lpdv, ch, wlen);
            }

            if(DrvGetPrinterData(lpnp->szDevName, FAX_ID, &dwType, szBuff,
                                 sizeof(szBuff), &dwData))
                szBuff[0] = 0;

            if(szBuff[0])
            {
                wlen = wsprintf(ch, FX_ID, (LPSTR)szBuff);
                WriteSpoolBuf(lpdv, ch, wlen);
            }

            WriteSpoolBuf(lpdv, FX_SETEND);
        }
        }
        break;

    case PC_END_F:

        if(lpnp->fFax == TRUE)
        {
            WriteSpoolBuf(lpdv, FX_DATAEND);
            lpnp->fFax = FALSE;
        }

        WriteSpoolBuf(lpdv, FS_RESO0_RESET);
        break;

    case PC_ENDPAGE :
        wlen = wsprintf(ch, FS_ENDPAGE, lpnp->wCopies);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case PC_MULT_COPIES_N:
    case PC_MULT_COPIES_C:
        // FS_COPIES is neccesary for each page
        if(!lpdwParams) return;

        if(wCmdCbId == PC_MULT_COPIES_C)
        {
            int iCharSet;

#ifndef WINNT
            iCharSet = GetProfileInt("system.font", "CharSet", 1);

            if(iCharSet == 8) WriteSpoolBuf(lpdv, FS_JIS78);
            else              WriteSpoolBuf(lpdv, FS_JIS90);
#else
            WriteSpoolBuf(lpdv, FS_JIS90);
#endif //WINNT
        }

        lpnp->wCopies = (WORD)*lpdwParams;
        wlen = wsprintf(ch, INIT_DOC, lpnp->wRes, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case PC_PRN_DIRECTION:
        {
        short  sEsc, sEsc90;
        short  ESin[] = {0, 1, 0, -1};
        short  ECos[] = {1, 0, -1, 0};

        if(!lpdwParams) return;

        lpnp->sEscapement = (short)*lpdwParams % 360;
        sEsc = lpnp->sEscapement;
        sEsc90 = lpnp->sEscapement/90;

#if 0
//if gpc supported any degree character rotation, available here.
        if(!(sEsc % 900))
        {
#endif
        lpnp->sSBCSXMove = lpnp->sSBCSX * ECos[sEsc90];
        lpnp->sSBCSYMove = -lpnp->sSBCSX * ESin[sEsc90];
        lpnp->sDBCSXMove = lpnp->sDBCSX * ECos[sEsc90];
        lpnp->sDBCSYMove = -lpnp->sDBCSX * ESin[sEsc90];
#if 0
//if gpc supported any degree character rotation, available here.
        }
        else
        {
            lpnp->sSBCSXMove = Scale(lpnp->sSBCSX, RCos(1000, sEsc), 1000);
            lpnp->sSBCSYMove = Scale(-lpnp->sSBCSX, RSin(1000, sEsc), 1000);
            lpnp->sDBCSXMove = Scale(lpnp->sDBCSX, RCos(1000, sEsc), 1000);
            lpnp->sDBCSYMove = Scale(-lpnp->sDBCSX, RSin(1000, sEsc), 1000);
        }
#endif
        }
        break;

// *** Cursor Movement CM *** //
    case CM_XY_ABS:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
 
        lpnp->CursorX = x;
        lpnp->CursorY = y;

        wlen = wsprintf(ch, FS_E, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

// *** Font Simulation FS *** //
    case FS_DOUBLE_BYTE:
#ifndef WINNT
        wlen = wsprintf(ch, FS_ADDRMODE_ON, lpnp->sDBCSXMove,
                        lpnp->sDBCSYMove);
        WriteSpoolBuf(lpdv, ch, wlen);

        if(lpnp->fVertFont)
        {
            WriteSpoolBuf(lpdv, ESC_KANJITATE);

            if(lpnp->wScale == 1) break;

            if(!lpnp->fPlus)
            {
                char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                 "4/1", "4/1", "6/1", "6/1", "8/1"};

                wlen = wsprintf(ch, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }
            else  wlen = wsprintf(ch, FS_12S2, lpnp->lPointsy, lpnp->lPointsx);

            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif

        break;

    case FS_SINGLE_BYTE:
#ifndef WINNT
        wlen = wsprintf(ch, FS_ADDRMODE_ON, lpnp->sSBCSXMove,
                        lpnp->sSBCSYMove);
        WriteSpoolBuf(lpdv, ch, wlen);

        if(lpnp->fVertFont)
        {
            WriteSpoolBuf(lpdv, ESC_KANJIYOKO);

            if(lpnp->wScale == 1) break;

            if(!lpnp->fPlus)
            {
                char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                 "4/1", "4/1", "6/1", "6/1", "8/1"};

                wlen = wsprintf(ch, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }
            else wlen = wsprintf(ch, FS_12S2, lpnp->lPointsx, lpnp->lPointsy);

            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        break;

// *** Vector Page VP *** //
    case VP_INIT_VECT:
        if(lpnp->wRes == 400)
        {
            WriteSpoolBuf(lpdv, VEC_INIT_400);
            return;
        }

        if(lpnp->wRes == 600)
        {
            WriteSpoolBuf(lpdv, VEC_INIT_600);
            return;
        }

        WriteSpoolBuf(lpdv, VEC_INIT_240);
        return;

    case VP_CLIP:
        {
        int left, top, right, bottom;

        if(!lpdwParams) return;

        left = m2d((int)*lpdwParams, lpnp->wRes);
        top  = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        right = m2d((int)*(lpdwParams + 2), lpnp->wRes);
        bottom  = m2d((int)*(lpdwParams + 3), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CLIP, left, top, right, bottom);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;
#if 0
    case VP_TRANSPARENT:
        lpnp->fTrans = TRUE;

        if(lpnp->fFill == FALSE) WriteSpoolBuf(lpdv, VEC_TRANS);
        else                     WriteSpoolBuf(lpdv, VEC_OPAQUE);

        break;
#endif

    case VP_OPAQUE:
//        lpnp->fTrans = FALSE;

        if(lpnp->fCurve == TRUE && lpnp->fFill == TRUE)
            WriteSpoolBuf(lpdv, VEC_OPLINE);
        else
            WriteSpoolBuf(lpdv, VEC_OPAQUE);

        break;

// *** Carousel CAR *** //
    case CAR_SELECT_PEN_COLOR:
        lpnp->wPenColor = *lpdwParams ? SG_BLACK : SG_WHITE;

        if(lpnp->wBrStyle == PP_SOLID)
            wlen = wsprintf(ch, VEC_SG, lpnp->wPenColor, lpnp->wPenColor);
        else
            wlen = wsprintf(ch, VEC_SG_PEN, lpnp->wPenColor);

        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case CAR_SET_PEN_WIDTH:
        {
        int width;

        if(!lpdwParams) return;

        width = m2d((int)*lpdwParams, lpnp->wRes);
        wlen = wsprintf(ch, VEC_PEN_WIDTH, width);

#if 0
// for Opaque Style Pen and Line Width
        lpnp->wPenWidth = m2d((int)*lpdwParams, lpnp->wRes);;
        if(lpnp->wPenWidth < 2)
        {
            WriteSpoolBuf(lpdv, VEC_PEN_WIDTH_1);
            break;
        }

        wlen = wsprintf(ch, VEC_PEN_WIDTH, lpnp->wPenWidth);
#endif

        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

// *** Line Info LI *** //
#if 0
// for Opaque Style Pen and Line Width
    case LI_SELECT_SOLID:
    case LI_SELECT_DASH:
    case LI_SELECT_DOT:
    case LI_SELECT_DASHDOT:
    case LI_SELECT_DASHDOTDOT:
        {
        short n[] = {0, 2, 100, 5, 6};

        lpnp->wPenStyle = n[wCmdCbId - LI_SELECT_SOLID];

        if(!lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            break;
        }

        wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
        WriteSpoolBuf(lpdv, ch, wlen);

        }
        break;
#endif

// *** Brush Info BI *** //
// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI
    case BI_SELECT_SOLID:
        lpnp->wBrStyle = PP_SOLID;
        wlen = wsprintf(ch, VEC_SG_BR, lpnp->wPenColor);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI
    case BI_SELECT_HS_HORIZONTAL:
    case BI_SELECT_HS_VERTICAL:
    case BI_SELECT_HS_FDIAGONAL:
    case BI_SELECT_HS_BDIAGONAL:
    case BI_SELECT_HS_CROSS:
    case BI_SELECT_HS_DIAGCROSS:
        {
        short  i;

        struct
        {
            WORD   pp;
            WORD   rp;
            LPSTR  vec;
            int   size;
        } BrTbl[]={{PP_HORIZONTAL, RP_HORIZONTAL, VEC_RP_HORIZONTAL},
                   {PP_VERTICAL,   RP_VERTICAL,   VEC_RP_VERTICAL  },
                   {PP_FDIAGONAL,  RP_FDIAGONAL,  VEC_RP_FDIAGONAL },
                   {PP_BDIAGONAL,  RP_BDIAGONAL,  VEC_RP_BDIAGONAL },
                   {PP_CROSS,      RP_CROSS,      VEC_RP_CROSS     },
                   {PP_DIAGCROSS,  RP_DIAGCROSS,  VEC_RP_DIAGCROSS }};

        i = wCmdCbId - BI_SELECT_HS_HORIZONTAL;
        lpnp->wBrStyle = BrTbl[i].pp;

        if(!(lpnp->fBrCreated & BrTbl[i].rp))
        {
            WriteSpoolBuf(lpdv, BrTbl[i].vec, BrTbl[i].size);
            lpnp->fBrCreated |= BrTbl[i].rp;
        }

        switch(lpnp->dwMulti)
        {
        case 0:
            wlen = wsprintf(ch, VEC_PP, lpnp->wBrStyle);
            break;

        case 1:
            wlen = wsprintf(ch, VEC_PP2, lpnp->wBrStyle);
            break;

        case 2:
            wlen = wsprintf(ch, VEC_PP3, lpnp->wBrStyle);
        }

        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case BI_CREATE_BYTE_2:
        if(!lpdwParams) return;

        wlen = wsprintf(ch, VEC_RP_BYTE, (BYTE)~*lpdwParams);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case BI_SELECT_BRUSHSTYLE:
        if(!lpdwParams) return;

        lpnp->wBrStyle = (WORD)*lpdwParams + PP_USERPATERN;

        switch(lpnp->dwMulti)
        {
        case 0:
            wlen = wsprintf(ch, VEC_PP, lpnp->wBrStyle);
            break;

        case 1:
            wlen = wsprintf(ch, VEC_PP2, lpnp->wBrStyle);
            break;

        case 2:
            wlen = wsprintf(ch, VEC_PP3, lpnp->wBrStyle);
        }

        WriteSpoolBuf(lpdv, ch, wlen);
        break;

// *** Vector Output VO *** //
// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI

    case VO_RECT:
        {
        short x1, y1, dx, dy;

        x1 = m2d((short)*lpdwParams, lpnp->wRes);
        y1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        dx = m2d((short)*(lpdwParams + 4), lpnp->wRes);
        dy = m2d((short)*(lpdwParams + 5), lpnp->wRes);

        if(!dx && !dy) dx = dy = 1;

        wlen = wsprintf(ch, VEC_RECT, x1, y1, dx, dy, dx,dy);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case VO_RECT_P:
        {
        short x1, y1, x2, y2, n;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        x1 = m2d((short)*lpdwParams, lpnp->wRes);
        y1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        x2 = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        y2 = m2d((short)*(lpdwParams + 3), lpnp->wRes);

        if(x1 == x2 && y1 == y2 )
        {
            x2++;
            y2++;
        }

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        wlen = wsprintf(ch, VEC_RECT_P, x1, y1, x2, y2, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_RECT_P, x1, y1, x2, y2, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

// for NPDL2+ vector graphics mode(add Naka 95/5/11)
    case VO_CIRCLE:
        {
        short n;
        short sX;
        short sXr;
        short sY;
        short sR;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        sX = m2d((short)*lpdwParams, lpnp->wRes);
        sY = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sR = m2d((short)*(lpdwParams + 2), lpnp->wRes);

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        sXr = sX + sR;     // starting point of the circle (X coordinate)
        wlen = wsprintf(ch, VEC_ELLIP, sX, sY, sR, sR, sXr, sY, sXr, sY, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_ELLIP, sR, sR, sX, sY, sX, sY, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

// for NPDL2+ vector graphics mode(add Naka 95/5/8)
    case VO_ELLIPSE:
        {
        short n;
        short sEllX1;
        short sEllY1;
        short sEllX2;
        short sEllY2;
        short sEllX;
        short sEllY;
        short sCENTERX;
        short sCENTERY;
        short sR;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        sEllX1 = m2d((short)*lpdwParams, lpnp->wRes);
        sEllY1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sEllX2 = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        sEllY2 = m2d((short)*(lpdwParams + 3), lpnp->wRes);
        sCENTERX = (sEllX1 + sEllX2) >> 1;
        sCENTERY = (sEllY1 + sEllY2) >> 1;
        sEllX = (sEllX2 - sEllX1) >> 1;
        sEllY = (sEllY2 - sEllY1) >> 1;
        sR = sCENTERX + sEllX;

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        wlen = wsprintf(ch, VEC_ELLIP, sCENTERX, sCENTERY, sEllX, sEllY,
                        sEllX2, sCENTERY, sEllX2, sCENTERY, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_ELLIP, sEllX, sEllY, sEllX2, sCENTERY,
                            sEllX2, sCENTERY, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

#if 0
// for NPDL2+ vector graphics mode(add Naka 95/5/9)
    case VO_E_PIE:
    case VO_E_ARC:
    case VO_E_CHORD:
        {
        short n;
        short i;
        short sPIEX1;
        short sPIEY1;
        short sPIEX2;
        short sPIEY2;
        long X1;
        long Y1;
        long X2;
        long Y2;
        int iDegree;
        short sCENTERX;
        short sCENTERY;
        short rx;
        short ry;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        i = wCmdCbId - VO_ELLIPSE;

        if(i == 2 && lpnp->fStroke == FALSE) return;

        sPIEX1  = m2d((short)*lpdwParams, lpnp->wRes);
        sPIEY1  = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sPIEX2  = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        sPIEY2  = m2d((short)*(lpdwParams + 3), lpnp->wRes);
        X1      = (short)*(lpdwParams + 4);  // transformed(r=5000) scale
        Y1      = (short)*(lpdwParams + 5);  // transformed(r=5000) scale
        iDegree = (short)*(lpdwParams + 6);  // transformed(r=5000) degree

        if(!iDegree) return;

        if(iDegree < 0) iDegree += 3600;

        sCENTERX = (sPIEX1 + sPIEX2) >> 1;
        sCENTERY = (sPIEY1 + sPIEY2) >> 1;
        rx = (sPIEX2 - sPIEX1) >> 1;
        ry = (sPIEY2 - sPIEY1) >> 1;
        wlen = wsprintf(ch, VEC_CENTER, sCENTERX, sCENTERY);
        WriteSpoolBuf(lpdv, ch, wlen);
        X2 = (X1 * Tcos(iDegree) - Y1 * Tsin(iDegree)) / 10000;
        Y2 = (X1 * Tsin(iDegree) + Y1 * Tcos(iDegree)) / 10000;
        X1 = (long)rx * X1 / 5000 + (long)sCENTERX;
        Y1 = (long)ry * Y1 / 5000 + (long)sCENTERY;
        X2 = (long)rx * X2 / 5000 + (long)sCENTERX;
        Y2 = (long)ry * Y2 / 5000 + (long)sCENTERY;

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        switch(i)
        {
        case 1:
            wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2, n);
#if 0
// for opaque style line
            if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
               !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                                    (short)X2, (short)Y2, 0);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                                (short)X2, (short)Y2, n);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
#endif
            break;

        case 2:
            wlen = wsprintf(ch, VEC_E_ARC, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2);
#if 0
// for opaque style line
            {
            BYTE chtmp[CCHMAXCMDLEN];

            wlen = wsprintf(chtmp, VEC_E_ARC, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2);

            if(lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 || !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, chtmp, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, chtmp, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                WriteSpoolBuf(lpdv, chtmp, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                WriteSpoolBuf(lpdv, chtmp, wlen);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            }
#endif
            break;

        case 3:
            wlen = wsprintf(ch, VEC_ELLIP, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2, n);
#if 0
// for opaque style line
            if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
               !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_ELLIP, rx, ry, (short)X1, (short)Y1,
                                (short)X2, (short)Y2, 0);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
#endif
            break;
        }

        WriteSpoolBuf(lpdv, ch, wlen);
    }
    break;
#endif

// *** Poly Vector Output PV *** //
    case PV_BEGIN:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        wlen = wsprintf(ch, VEC_BEGIN, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case PV_CONTINUE:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*(lpdwParams + 4), lpnp->wRes);
        y = m2d((int)*(lpdwParams + 5), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CONTINUE, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

#if 0
// for Poly Bezier
    case PV_BEGIN_BEZ:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        wlen = wsprintf(ch, VEC_BEGIN_BEZ, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case PV_CONTINUE_BEZ:
        {
        int x1, y1, x2, y2, x3, y3;

        if(!lpdwParams) return;

        x1 = m2d((int)*(lpdwParams + 2), lpnp->wRes);
        y1 = m2d((int)*(lpdwParams + 3), lpnp->wRes);
        x2 = m2d((int)*(lpdwParams + 4), lpnp->wRes);
        y2 = m2d((int)*(lpdwParams + 5), lpnp->wRes);
        x3 = m2d((int)*(lpdwParams + 6), lpnp->wRes);
        y3 = m2d((int)*(lpdwParams + 7), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CONTINUE_BEZ, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;
#endif

// *** Vector SupportVS *** //
    case VS_STROKE:
        lpnp->fStroke = TRUE;

        if(lpnp->fCurve == TRUE) return;

        WriteSpoolBuf(lpdv, VEC_STROKE);
#if 0
// for opaque style line
        if(lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 || !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, VEC_STROKE);
            return;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_SG_PEN_W);
            wlen = wsprintf(ch, VEC_STROKE_OPA_W, (short)lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            WriteSpoolBuf(lpdv, VEC_SG_PEN_B);
            WriteSpoolBuf(lpdv, VEC_STROKE);
        }
        else
        {
            wlen = wsprintf(ch, VEC_STROKE_OPA_W, (short)lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        break;

#if 0
    case VS_WINDFILL:
        lpnp->fFill = TRUE;
        WriteSpoolBuf(lpdv, VEC_WINDFILL);
        break;
#endif

    case VS_ALTFILL:
        lpnp->fFill = TRUE;

        if(lpnp->fCurve == TRUE) return;

        WriteSpoolBuf(lpdv, VEC_ALTFILL);
        break;
    }
}


#ifndef WINNT
//-------------------------------------------------------------------
// Function: Enable()
// Action  : call UniEnable and setup Mdv
//-------------------------------------------------------------------
short CALLBACK Enable(
LPDV   lpdv,
WORD   style,
LPSTR  lpModel,
LPSTR  lpPort,
LPDM   lpStuff)
{
    CUSTOMDATA  cd;

    short         sRet;
    GLOBALHANDLE  hTmp;
    LPSTR         lpTmp;
    LPNPDL2MDV    lpnp;
    DWORD         dwMulti, dwType, dwData;

    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
    cd.fnOEMDump = NULL;
    cd.fnOEMOutputChar = NULL;

    sRet = UniEnable(lpdv, style, lpModel, lpPort, lpStuff, &cd);

    if(lpdv && lpdv->iType == BM_DEVICE && !lpdv->fMdv && sRet && !style)
    {
        hTmp = GlobalAlloc(GPTR, sizeof(NPDL2MDV));

        if(!hTmp) return sRet;

        lpTmp = GlobalLock(hTmp);

        if(!lpTmp)
        {
            GlobalFree(hTmp);
            return sRet;
        }

        lpdv->fMdv = TRUE;
        lpdv->lpMdv = lpTmp;
        lpnp = (LPNPDL2MDV)lpdv->lpMdv;
        lpnp->hKeep = hTmp;
        lpnp->wPenColor = SG_BLACK;
        lpnp->wBrStyle = PP_SOLID;
        lpnp->fStroke = FALSE;
        lpnp->fFill = FALSE;
        lpnp->fCurve = FALSE;
        lstrcpy(lpnp->szDevName, lpModel);

        if(DrvGetPrinterData(lpModel, MULTI_SCALE, &dwType, (LPBYTE)&dwMulti,
                             sizeof(DWORD), (LPDWORD)&dwData))
            dwMulti = 0;

        lpnp->dwMulti = dwMulti;
    }

    return sRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void WINAPI Disable(
LPDV lpdv)
{
    if(lpdv && lpdv->iType == BM_DEVICE && lpdv->fMdv)
    {
        LPNPDL2MDV  lpnp;

        lpnp = (LPNPDL2MDV)lpdv->lpMdv;
        GlobalUnlock(lpnp->hKeep);
        GlobalFree(lpnp->hKeep);
    }

    UniDisable(lpdv);
}
#endif // WINNT

#ifdef WINNT

short OEMOutputChar( lpdv, lpstr, len, rcID )
LPDV    lpdv;
LPSTR   lpstr;
WORD    len;
WORD    rcID;
{
    WORD        wlen;
    WORD        i;
    WORD        wTmpChar;
    LPSTR       lpTmpStr;
    BYTE        ch[512];
    LPNPDL2MDV  lpnp;
    BOOL        fDBCSFont;

    wlen = 0;
    lpTmpStr = lpstr;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    if( rcID != lpnp->wOldFontID )
    {
        lpnp->wCurrentAddMode = 0;
        lpnp->wOldFontID = rcID;
    }

    switch(rcID)
    {
    case 5: // Courier
    case 6: // Helv
    case 7: // TmsRmn
    case 8: // TmsRmn Italic
        fDBCSFont = FALSE;
        break;

    default:
        fDBCSFont = TRUE;
    }

    for(i = 0; i < len;i ++)
    {
        if((fDBCSFont == TRUE) && IsDBCSLeadByteNPDL(*lpTmpStr))
        {
            if(lpnp->wCurrentAddMode != FLAG_DBCS)
            {
                WORD        wLen;
                BYTE        cH[CCHMAXCMDLEN];

                wLen = wsprintf(cH, FS_ADDRMODE_ON, lpnp->sDBCSXMove,
                                lpnp->sDBCSYMove);
                WriteSpoolBuf(lpdv, cH, wLen);

                if(lpnp->fVertFont)
                {
                    WriteSpoolBuf(lpdv, ESC_KANJITATE);

                    if(lpnp->wScale != 1)
                    {


                        if(!lpnp->fPlus)
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};

                            wLen = wsprintf(cH, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                        }
                        else  wLen = wsprintf(cH, FS_12S2, lpnp->lPointsy, lpnp->lPointsx);

                        WriteSpoolBuf(lpdv, cH, wLen);
                    }
                }
                lpnp->wCurrentAddMode = FLAG_DBCS;
            }
            wTmpChar  = SJis2JisNPDL(SWAPW((WORD)*(LPWORD)lpTmpStr));
            *(LPWORD)(ch+wlen) = SWAPW(wTmpChar);
            wlen+=2;
            lpTmpStr+=2;
            i++;
        }
        else
        {
            if(lpnp->wCurrentAddMode != FLAG_SBCS)
            {
                WORD        wLen;
                BYTE        cH[CCHMAXCMDLEN];

                wLen = wsprintf(cH, FS_ADDRMODE_ON, lpnp->sSBCSXMove,
                                lpnp->sSBCSYMove);
                WriteSpoolBuf(lpdv, cH, wLen);

                if(lpnp->fVertFont)
                {
                    WriteSpoolBuf(lpdv, ESC_KANJIYOKO);

                    if(lpnp->wScale != 1)
                    {

                        if(!lpnp->fPlus)
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};

                            wLen = wsprintf(cH, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
                        }
                        else wLen = wsprintf(cH, FS_12S2, lpnp->lPointsx, lpnp->lPointsy);

                        WriteSpoolBuf(lpdv, cH, wLen);
                    }
                }
                lpnp->wCurrentAddMode = FLAG_SBCS;

            }
            wTmpChar = (WORD)((0x00ff)&(*lpTmpStr));
            if (!fDBCSFont) {
                 wTmpChar = Ltn1ToAnk( wTmpChar );
            }
            *(LPWORD)(ch+wlen) = SWAPW(wTmpChar);
            wlen+=2;
            lpTmpStr++;
        }
    }

    WriteSpoolBuf(lpdv, ch, wlen);
    return wlen;
}
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    int                    i;
    LPSTR                  lpTmp;
    LPNPDL2MDV    lpnp;

    lpTmp = UniDrvAllocMem(sizeof(NPDL2MDV));

    if(!lpTmp)
    {
        return FALSE;
    }

    lpdv->fMdv = TRUE;
    lpdv->lpMdv = lpTmp;
    lpnp = (LPNPDL2MDV)lpdv->lpMdv;
    lpnp->wPenColor = SG_BLACK;
    lpnp->wBrStyle = PP_SOLID;
    lpnp->fStroke = FALSE;
    lpnp->fFill = FALSE;
    lpnp->fCurve = FALSE;
    lpnp->dwMulti = 0;
    lpnp->fComp = FALSE;
    lpnp->Color = 0;
    lpnp->wCurrentAddMode = 0;
    lpnp->wOldFontID = 0;

    // Check if user selects MONO
    if( (((PGDIINFO)pdevcaps)->cBitsPixel == 1) &&
        (((PGDIINFO)pdevcaps)->cPlanes == 1))
        lpnp->fMono = TRUE;
    else{
        lpnp->fMono = FALSE;
    }

    return TRUE;


}

/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{
    LPNPDL2MDV    lpnp;


    if ( lpdv && lpdv->fMdv )
    {
        UniDrvFreeMem( lpdv->lpMdv );
    }


}

DRVFN
MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMGetFontCmd,           (PFN)fnOEMGetFontCmd  },
    {  INDEX_OEMOutputCmd,            (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  },
    {  INDEX_OEMTTBitmap,             (PFN)fnOEMTTBitmap  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\reg_def.h ===
// REG_DEF.H

#define MULTI_SCALE  "Multi Scale"
#define FAX_ON       "Fax On"
#define FAX_MYNAME   "Fax MyName"
#define FAX_ID       "Fax Id"
#define FAX_RES      "Fax Res"
#define FAX_USEBOOK  "Fax UseBook"
#define FAX_DSTTEL   "Fax DstTel"
#define FAX_IDDSTTEL "Fax DstTelID"
#define FAX_TEL      "Fax Tel  %d"
#define FAX_BOOK     "Fax Book %d"
#define FAX_BOOK1    "Fax Book 1"
#define FAX_BOOK2    "Fax Book 2"
#define FAX_LISTTYPE "Fax ListType"
#define FAX_DRIVE    "Fax Drive"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\kpdlms.h ===
//----------------------------------------------------------------------------
// Filename:    kpdlms.h
// This file contains definitions for KPDL mini-driver
//-----------------------------------------------------------------------------

// kpdlms mini driver device data structure
typedef struct
{
    GLOBALHANDLE  hKeep;
    char   szDevName[CCHDEVICENAME];
    WORD   wRes;            // resolution 600 or 400 or 240
    WORD   wCopies;         // number of multi copies
    short  sSBCSX;
    short  sDBCSX;
    short  sSBCSXMove;      // use to set address mode
    short  sSBCSYMove;      // use to set address mode
    short  sDBCSXMove;      // use to set address mode
    short  sDBCSYMove;      // use to set address mode
    short  sEscapement;     // use to set address mode
//    WORD   wPenStyle;       //
//    WORD   wPenWidth;       //
    WORD   wPenColor;       //
    WORD   fBrCreated;      //
    WORD   wBrStyle;        //
    BOOL   fVertFont;       // for TATEGAKI font
    BOOL   fFax;            // for 1000FX
    DWORD  dwMulti;         // for Pattern
    BOOL   fFill;           // flag of fill command
    BOOL   fStroke;         // flag of stroke command
//    BOOL   fTrans;          //
    BOOL   fCurve;          // flag for Curves
    HANDLE hBuff;
    LPSTR  lpBuff;
    LPSTR  lpLBuff;
#ifdef WINNT
    WORD   wBitmapX;
    WORD   wBitmapY;
    WORD   wCurrentAddMode;
    WORD   wOldFontID;
#else // WINNT
    WORD   wBitmapY;
    WORD   wBitmapYC;
#endif // WINNT
    WORD   wBitmapLen;
    BOOL   fComp;
    BOOL   fPlus;
    WORD   wScale;
    LONG   lPointsx;
    LONG   lPointsy;
    BOOL   fMono;
    int    CursorX;
    int    CursorY;
    int    Kaicho;
    int    Color;
} NPDL2MDV, FAR *LPNPDL2MDV;

// NPDL2 command
#define ESC_RESET         "\033c1",           3   // software reset
#define ESC_KANJIYOKO     "\033K",            2   // kanji yoko mode
#define ESC_KANJITATE     "\033t",            2   // kanji yoko mode
#define FS_PAGEMODE       "\034d240.",        6   // page mode
#define FS_DRAWMODE       "\034\"R.",         4   // draw mode
#define FS_ADDRMODE_ON    "\034a%d,%d,0,B."       // set address mode
#define FS_GRPMODE_ON     "\034Y",            2   // set graphic mode
#define FS_GRPMODE_OFF    "\034Z",            2   // reset graphic mode
#define FS_SETMENUNIT     "\034<1/%d,i."          // select men-mode resolution
#define FS_JIS78          "\03405F2-00",      8   // select JIS78
#define FS_JIS90          "\03405F2-02",      8   // select JIS90
#define FS_ENDPAGE        "\034R\034x%d.\015\014" // end page
#define FS_E              "\034e%d,%d."
#define FS_RESO           "\034&%d."
#define FS_RESO0_RESET    "\034&0.\033c1",    7
#define VEC_INIT_600      "PD;IP0,0,608,608;", 17
#define VEC_INIT_400      "PD;IP0,0,405,405;", 17
#define VEC_INIT_240      "PD;IP0,0,243,243;", 17
#define VEC_TRANS         "PM0,0;",           6
#define VEC_OPAQUE        "PM1,1;",           6
#define VEC_OPLINE        "PM,1;",            5
#define INIT_DOC          "\034<1/%d,i.\034YSU1,%d,0;\034Z"
#define RESO_PAGE_KANJI   "\034&%d.\034d240.\033K"
#define FS_I              "\034R\034i%d,%d,0,1/1,1/1,%d,%d."
#define FS_I_2            "\034R\034i%d,%d,5,1/1,1/1,%d,%d."
#define FS_I_D            "%d,%d."
#define FS_M_Y            "\034m1/1,%s."
#define FS_M_T            "\034m%s,1/1."
#define FS_12S2           "\03412S2-%04ld-%04ld"

#define FX_MODESET        "\03402ZS",         5
#define FX_DATAEND        "\03402ZE",         5
#define FX_SETSTART       "\03402ZM",         5
#define FX_SETEND         "\03402ZN",         5
#define FX_TEL            "TN%s\015"
#define FX_QUA            "GQ%d\015"
#define FX_MY             "SN%s\015"
#define FX_ID             "ID%s\015"

#define FX_INIT           "\03402ZS\03402ZM",  10

// add 11/28 for PC-PR2000/6W (Naka)
#define FS_PCMODE         "\03406MNPDL1",     9 // return to PC mode
// add 95/5/8 for NPDL2+ Vector command (Nakamura)
#define VEC_ELLIP         "MA%d,%d;CV%d,%d,%d,%d,%d,%d,%d,0;" // draw ellipse
#define VEC_E_PIE         "MA%d,%d;FV%d,%d,%d,%d,%d,%d,%d,0;" // draw pie
#define VEC_E_ARC         "MA%d,%d;AV%d,%d,%d,%d,%d,%d,0;"    // draw arc
#define VEC_RECT          "NP;MA%d,%d;PR%d,0,0,%d,-%d,0,0,-%d;EP;"
#define VEC_RECT_P        "MA%d,%d;RB%d,%d,0,0,%d;"
#define VEC_CENTER        "MA%d,%d;"                 // move pen center
#define PATH_BIGIN        "NP;",              3   // begin path mode
#define VEC_STROKE        "ST1;",             4   // stroke
#define VEC_STROKE_OPA_W  "LT;ST1;LT%d,10;"
#define VEC_WINDFILL      "FL1;",             4   //
#define VEC_ALTFILL       "EF1;",             4   //

#define VEC_LC            "LC%d;"                 // endcap
#define VEC_LJ            "LJ%d;"                 // join

#define VEC_SU            "SU1,%d,0;"           // select graphic resolution
#define VEC_SG            "SG%d,%d;"            // set gray
#define VEC_SG_PEN        "SG,%d;"              // set Pen gray
#define VEC_SG_PEN_B      "SG,0;",            5 // set Pen gray
#define VEC_SG_PEN_W      "SG,100;",          7 // set Pen gray
#define VEC_SG_BR         "SG%d;"               // set Brush gray
#define VEC_PP            "PP%d;"               // select Brush

#define VEC_PEN_WIDTH     "LW%d;"
#define VEC_PEN_WIDTH_1   "LW1;",             4

#define VEC_LT_SOLID      "LT;",              3
#define VEC_LT_STYLE      "LT%d,10;"
#define VEC_LT_STYLE_B    "LT%d,10;SG,0;"
#define VEC_LT_WHITE      "LT;SG,100;",      10

// add 11/28 for PC-PR2000/6W (Naka)
#define VEC_PP6           "PP%d,2,2;"           // selest Brush for 600dpi
#define VEC_PP2           "PP%d,2,2;"           // selest Brush for 2x2
#define VEC_PP3           "PP%d,3,3;"           // selest Brush for 3x3
#define VEC_RP_BYTE       "%02X"                // Brush Pattern Set
#define VEC_RP_HORIZONTAL "RP100,8,8,00,00,00,00,FF,00,00,00;", 34// create PP_HORIZONTAL
#define VEC_RP_VERTICAL   "RP101,8,8,08,08,08,08,08,08,08,08;", 34// create PP_VERTICAL
#define VEC_RP_FDIAGONAL  "RP102,8,8,80,40,20,10,08,04,02,01;", 34// create PP_FDIAGONAL
#define VEC_RP_BDIAGONAL  "RP103,8,8,01,02,04,08,10,20,40,80;", 34// create PP_BDIAGONAL
#define VEC_RP_CROSS      "RP104,8,8,08,08,08,08,FF,08,08,08;", 34// create PP_CROSS
#define VEC_RP_DIAGCROSS  "RP105,8,8,81,42,24,18,18,24,42,81;", 34// creata PP_DIAGCROSS
#define VEC_BEGIN         "MA%d,%d;PR"
#define VEC_CONTINUE      "%d,%d"
#define VEC_BEGIN_BEZ     "MA%d,%d;BA"
#define VEC_CONTINUE_BEZ  "%d,%d,%d,%d,%d,%d"
#define VEC_CLIP          "IW%d,%d,%d,%d;"
//#define VEC_ENDPOLY       ";CP;", 4
#define VEC_ENDPOLY       ";", 1
#define VEC_ENDPOLY_D     "0,0,1,1;", 8


// Pen and Brush Color
#define SG_WHITE            100
#define SG_BLACK              0

// Created Hatch Style Brush

#define RP_HORIZONTAL    0x0001
#define RP_VERTICAL      0x0002
#define RP_FDIAGONAL     0x0004
#define RP_BDIAGONAL     0x0008
#define RP_CROSS         0x0010
#define RP_DIAGCROSS     0x0020

// Select Brush Style
#define PP_NULL               0
#define PP_SOLID              1
#define PP_HATCH            100
#define PP_HORIZONTAL       100
#define PP_VERTICAL         101
#define PP_FDIAGONAL        102
#define PP_BDIAGONAL        103
#define PP_CROSS            104
#define PP_DIAGCROSS        105
#define PP_USERPATERN       105

// Command CallBack ID
#define CALLBACK_ID_MAX              255 //

// PAGECONTROL
#define PC_MULT_COPIES_N               1
#define PC_MULT_COPIES_C               2
#define PC_TYPE_F                      4
#define PC_END_F                       6
#define PC_ENDPAGE                     7
#define PC_PRN_DIRECTION               9
#define PC_TYPE_6                     10  // add 11/25 for PC-PR2000/6W (Naka)

// FONTSIMULATION
#define FS_SINGLE_BYTE                20
#define FS_DOUBLE_BYTE                21

// RESOLUTION
#define RES_240                       30
#define RES_400                       31
#define RES_600                       32  // add 11/25 for PC-PR2000/6W (Naka)
#define RES_BLOCKOUT1                 33
#define RES_BLOCKOUT2                 34
#define RES_300                       35
#define RES_SENDBLOCK                 36

// CAROUSEL
#define CAR_SELECT_PEN_COLOR          40
#define CAR_SET_PEN_WIDTH             41

// BRUSHINFO
#define BI_SELECT_NULL                51
#define BI_SELECT_SOLID               52
#define BI_SELECT_HS_HORIZONTAL       53
#define BI_SELECT_HS_VERTICAL         54
#define BI_SELECT_HS_FDIAGONAL        55
#define BI_SELECT_HS_BDIAGONAL        56
#define BI_SELECT_HS_CROSS            57
#define BI_SELECT_HS_DIAGCROSS        58
#define BI_CREATE_BYTE_2              59
#define BI_SELECT_BRUSHSTYLE          60

// LINEINFO
#define LI_SELECT_SOLID               61
#define LI_SELECT_DASH                62
#define LI_SELECT_DOT                 63
#define LI_SELECT_DASHDOT             64
#define LI_SELECT_DASHDOTDOT          65

// VECTOROUTPUT
// add 95/5/9 for npdl2p (Nakamura)
#define VO_ELLIPSE                    70
#define VO_E_PIE                      71
#define VO_E_ARC                      72
#define VO_E_CHORD                    73
#define VO_CIRCLE                     74
#define VO_RECT                       75
#define VO_RECT_P                     76

// VECTORSUPPORT
#define VS_BIGIN_POLYDEF              81
#define VS_WINDFILL                   83
#define VS_ALTFILL                    84
#define VS_STROKE                     85

// VECTORPAGE
#define VP_E_FLAT_J_BEVEL             91
#define VP_E_ROUND_J_MITER            92
#define VP_E_SQUARE_J_ROUND           93
#define VP_TRANSPARENT                94
#define VP_OPAQUE                     95
#define VP_J_BEVEL                    96
#define VP_J_MITER                    97
#define VP_J_ROUND                    98
#define VP_INIT_VECT                  99
#define VP_CLIP                      100

//CURSORMOVE
#define CM_XY_ABS                    101

//POLYVECT
#define PV_BEGIN                     111
#define PV_CONTINUE                  112
#define PV_BEGIN_BEZ                 113
#define PV_CONTINUE_BEZ              114
#define PV_END                       115

//IMAGE CONTROL
#define KAICHO4                      120
#define KAICHO8                      121

//COLOR MODE
#define COLOR_8                      200
#define COLOR_TRUE                   201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            WARNING(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'KYP5'      // KYOCERA
#define DLLTEXT(s)      "KYP5: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
    // Private extention
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);


#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\kyp5jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
    }

    return TRUE;
}

#define MINJOBLEN       48
#define MAX_NAMELEN     31

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#ifdef wsprintf
#undef wsprintf
#endif
#define wsprintf sprintf

//
// Command callback ID's
//

// Do not reorder the following CMD_BARCODEPOS_X group.
#define CMD_BARCODEPOS_0        100
#define CMD_BARCODEPOS_1        101
#define CMD_BARCODEPOS_2        102
#define CMD_BARCODEPOS_3        103
#define CMD_BARCODEPOS_4        104
#define CMD_BARCODEPOS_5        105
#define CMD_BARCODEPOS_6        106
#define CMD_BARCODEPOS_7        107
#define CMD_BARCODEPOS_8        108


/*
 *  OEMCommandCallback
 */
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         iRet = 0;
    INT         iBCID;
    INT         iLen;
    INT         iDocument;
    INT         iDocuTemp;
    INT         iUserName;
    INT         iUserTemp;
    DWORD       cbNeeded = 0;
    DWORD       cReturned = 0;
    DWORD       CmdSize;
    PBYTE       pCmd = NULL;
    PBYTE       pDocument = NULL;
    PBYTE       pDocuTemp = NULL;
    PBYTE       pUserName = NULL;
    PBYTE       pUserTemp = NULL;
    PBYTE       pTemp, pNext, pEnd;
    PJOB_INFO_1 pJobInfo = NULL;
    FILETIME    ft, lft;
    SYSTEMTIME  st;
    BYTE        ch[MINJOBLEN];

    VERBOSE(("OEMCommandCallback entry - %d, %d\r\n", dwCmdCbID, dwCount));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    switch (dwCmdCbID) {

    case CMD_BARCODEPOS_0:
    case CMD_BARCODEPOS_1:
    case CMD_BARCODEPOS_2:
    case CMD_BARCODEPOS_3:
    case CMD_BARCODEPOS_4:
    case CMD_BARCODEPOS_5:
    case CMD_BARCODEPOS_6:
    case CMD_BARCODEPOS_7:
    case CMD_BARCODEPOS_8:

        iBCID = (dwCmdCbID - CMD_BARCODEPOS_0);
        CmdSize = MINJOBLEN;

        //
        // Get the first JOB info
        //
        (void)EnumJobs(pdevobj->hPrinter, 0, 1, 1, NULL, 0,
            &cbNeeded, &cReturned);
        if (!cbNeeded)
            goto out;
        if ((pJobInfo = (PJOB_INFO_1)MemAlloc(cbNeeded)) == NULL)
            goto out;
        if (!EnumJobs(pdevobj->hPrinter, 0, 1, 1, (LPBYTE)pJobInfo, cbNeeded,
            &cbNeeded, &cReturned))
            goto out;

        // Convert to multi-byte

        iDocuTemp = WideCharToMultiByte(CP_ACP, 0, pJobInfo->pDocument, -1,
            NULL, 0, NULL, NULL);
        if (!iDocuTemp)
            goto out;
        if ((pDocuTemp = (PBYTE)MemAlloc(iDocuTemp)) == NULL)
            goto out;
        if (!WideCharToMultiByte(CP_ACP, 0, pJobInfo->pDocument, -1,
            pDocuTemp, iDocuTemp, NULL, NULL))
            goto out;

        if ((pDocument = (PBYTE)MemAlloc(iDocuTemp)) == NULL)
            goto out;
        pTemp = pDocuTemp;
        pEnd = &pDocuTemp[min(iDocuTemp - 1, MAX_NAMELEN)];
        while (*pTemp) {
            pNext = CharNextA(pTemp);
            if (pNext > pEnd)
                break;
            pTemp = pNext;
        }
        iDocument = (INT)(pTemp - pDocuTemp);
        CopyMemory(pDocument, pDocuTemp, iDocument);
        pDocument[iDocument] = '\0';

        // Convert to multi-byte

        iUserTemp = WideCharToMultiByte(CP_ACP, 0, pJobInfo->pUserName, -1,
            NULL, 0, NULL, NULL);
        if (!iUserTemp)
            goto out;
        if ((pUserTemp = (PBYTE)MemAlloc(iUserTemp)) == NULL)
            goto out;
        if (!WideCharToMultiByte(CP_ACP, 0, pJobInfo->pUserName, -1,
            pUserTemp, iUserTemp, NULL, NULL))
            goto out;

        if ((pUserName = (PBYTE)MemAlloc(iUserTemp)) == NULL)
            goto out;
        pTemp = pUserTemp;
        pEnd = &pUserTemp[min(iUserTemp - 1, MAX_NAMELEN)];
        while (*pTemp) {
            pNext = CharNextA(pTemp);
            if (pNext > pEnd)
                break;
            pTemp = pNext;
        }
        iUserName = (INT)(pTemp - pUserTemp);
        CopyMemory(pUserName, pUserTemp, iUserName);
        pUserName[iUserName] = '\0';

        // Convert to local time
        (void)SystemTimeToFileTime(&pJobInfo->Submitted, &ft);
        (void)FileTimeToLocalFileTime(&ft, &lft);
        (void)FileTimeToSystemTime(&lft, &st);

        // Output commands
        CmdSize = 8 +   // barcode position and share
            iDocument + // document name
            iUserName + // user name
            16 +        // Date & Time
            16;         // Other characters
        if ((pCmd = (PBYTE)MemAlloc(CmdSize)) == NULL)
            goto out;
        iLen = wsprintf(pCmd,
            "%d,0,\"%s\",\"%s\",\"%4d/%02d/%02d %02d:%02d\";EXIT;",
            iBCID, pDocument, pUserName,
            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute);
        WRITESPOOLBUF(pdevobj, pCmd, iLen);
        goto done;

out:
        iLen = wsprintf(ch, "%d,0,\"Windows2000\",\"Kyocera\",\"\";EXIT;",
            iBCID);
        WRITESPOOLBUF(pdevobj, ch, iLen);

done:
        if (pCmd) MemFree(pCmd);
        if (pUserName) MemFree(pUserName);
        if (pUserTemp) MemFree(pUserTemp);
        if (pDocument) MemFree(pDocument);
        if (pDocuTemp) MemFree(pDocuTemp);
        if (pJobInfo) MemFree(pJobInfo);

        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//  "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=md_kyp5jres

!ifndef PRNROOT
PRNROOT=$(MAKEDIR:\gpdres\kyp5jres=)
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR_KY=$(PRNROOT)\gpd\kyo\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=kyp5jres
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),kyp5jres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;

C_DEFINES=$(C_DEFINES) -DUNICODE

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\kyp5jres.rc \
    $(SRCDIR)\kyp5jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(GPDDIR_KY)\kylm180j.gpd \
    $(GPDDIR_KY)\kylm380j.gpd \
    $(GPDDIR_KY)\kylm630j.gpd \
    $(GPDDIR_KY)\kylm670j.gpd \
    $(GPDDIR_KY)\kylm67sj.gpd \
    $(GPDDIR_KY)\kylm680j.gpd \
    $(GPDDIR_KY)\kylm700j.gpd \
    $(GPDDIR_KY)\kylm770j.gpd \
    $(GPDDIR_KY)\kylm900j.gpd \
    $(GPDDIR_KY)\kyls170j.gpd \
    $(GPDDIR_KY)\kyls180j.gpd \
    $(GPDDIR_KY)\kyls370j.gpd \
    $(GPDDIR_KY)\kyls380j.gpd \
    $(GPDDIR_KY)\kyls630j.gpd \
    $(GPDDIR_KY)\kyls670j.gpd \
    $(GPDDIR_KY)\kyls67sj.gpd \
    $(GPDDIR_KY)\kyls680j.gpd \
    $(GPDDIR_KY)\kyls700j.gpd \
    $(GPDDIR_KY)\kyls770j.gpd \
    $(GPDDIR_KY)\kyls800j.gpd \
    $(GPDDIR_KY)\kyls900j.gpd \
    ..\kyp5jres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));

        *piResult = OEMCompression(
                pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);
        if (*piResult > 0) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\lgcomp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#ifndef _LGCOMP_H
#define _LGCOMP_H

#include <minidrv.h>

#define COMP_NONE 0
#define COMP_RLE  1
#define COMP_MHE   2

extern INT LGCompMHE(PBYTE, PBYTE, DWORD, INT);
extern INT LGCompRLE(PBYTE, PBYTE, DWORD, INT);

#endif // _LGCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            WARNING(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\lgcomp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include "lgcomp.h"

//
// File: LGCOMP.C
//
// Implementations of LG compression algprithms on the
// LG "Raster 1" printers.
//
// printer command:
//     <9B>I{type}#{compressed data length}{compressed data}
//
// type can be:
//   <01> RLE
//   <02> MHE
//

// For MHE debugging.
#define MHEDEBUG 0
//#define MHEDEBUG 1
//#define MHEDEBUGPATTERN 0x81
#define MHEDEBUGPATTERN 0xff

//
// LG RLE compression.  See comments for the details.
//

INT
LGCompRLE(
    PBYTE pOutBuf,
    PBYTE pSrcBuf, DWORD iSrcBuf,
    INT iMode)
{
    PBYTE pMaxSrcBuf = pSrcBuf + iSrcBuf;
    INT iOutLen = 0, iRun;
    BYTE jTemp;
    PBYTE pSize;

    // Embedd print command if requested.
    if (iMode == 1) {

        // LG Raster 1 
        if (pOutBuf) {
            *pOutBuf++ = (BYTE)'\x9B';
            *pOutBuf++ = (BYTE)'I';
            *pOutBuf++ = COMP_RLE;
            pSize = pOutBuf++;
            pOutBuf++;
       }
       iOutLen += 5;
    }

    while (pSrcBuf < pMaxSrcBuf) {

        // Get Run length.

        jTemp = *pSrcBuf;
        for (iRun = 1; pSrcBuf + iRun < pMaxSrcBuf; iRun++) {
            if (*(pSrcBuf + iRun) != jTemp)
                break;
        }

        // iRun == N means N consective bytes
        // of the same value exists.

        if (iRun > 1) {

            // Run > 1.

            while (iRun >= 0x82) {

                iRun -= 0x82;
                iOutLen += 2;
                if (pOutBuf) {

                    // Mark <- 0x80,
                    // length = 0x82.
                    *pOutBuf++ = 0x80;
                    *pOutBuf++ = jTemp;
                }
                pSrcBuf += 0x82;
            }

            // iRun less than 3 will be output as "copy" block.

            if (iRun >= 3) {

                iOutLen += 2;
                if (pOutBuf) {

                    // Mark <- 0x81 to 0xff,
                    // length = 0x81 to 3.
                    *pOutBuf++ = (0x102 - iRun);
                    *pOutBuf++ = jTemp;
                }
            }
            else if (iRun > 0) {

                iOutLen += (1 + iRun);
                if (pOutBuf) {
                    *pOutBuf++ = (iRun - 1);
                    memcpy(pOutBuf, pSrcBuf, iRun);
                    pOutBuf += iRun;
                }
            }
            pSrcBuf += iRun;

            // Go to the next around.
            continue;
        }

        // Get "different" Run length.  We already know
        // pSrcBuf[0] != pSrcBuf[1].

        for (iRun = 1; pSrcBuf + iRun < pMaxSrcBuf; iRun++) {
            if ((pSrcBuf + iRun + 1 < pMaxSrcBuf) &&
                    (*(pSrcBuf + iRun) == *(pSrcBuf + iRun + 1))) {
                break;
            }
        }

        for (; iRun >= 0x80; iRun -= 0x80) {
            iOutLen += (1 + 0x80);
            if (pOutBuf) {

                // Mark <- 0x7f,
                // copy = 0x80.
                *pOutBuf++ = 0x7f;
                memcpy(pOutBuf, pSrcBuf, 0x80);
                pOutBuf += 0x80;
            }
            pSrcBuf += 0x80;
        }

        if (iRun > 0) {
            iOutLen += (1 + iRun);
            if (pOutBuf) {

                // Mark <- 0x7e to 0,
                // copy = 0x7f to 1.
                *pOutBuf++ = (iRun - 1);
                memcpy(pOutBuf, pSrcBuf, iRun);
                pOutBuf += iRun;
            }
            pSrcBuf += iRun;
        }
    }

    // Embed size information if requested.
    if (iMode == 1) {
        if (pOutBuf) {
            *pSize++ = (BYTE)((iOutLen - 5) >> 8);
            *pSize++ = (BYTE)(iOutLen - 5);
        }
    }

    return iOutLen;
}

//
// MHE compression.  See comments for the details.
//

typedef struct {
    DWORD cswd;    /* compressing signed word */
    INT vbln;    /* cswd's valid bits length, count from MSB */
} ENCfm;                    /* ENC. form */

ENCfm pWhiteTermTbl[64] = {    /* Terminating Code Table (White)*/
    {0x35000000,  8},{0x1c000000,  6},{0x70000000,  4},{0x80000000,  4},
    {0xb0000000,  4},{0xc0000000,  4},{0xe0000000,  4},{0xf0000000,  4},
    {0x98000000,  5},{0xa0000000,  5},{0x38000000,  5},{0x40000000,  5},
    {0x20000000,  6},{0x0c000000,  6},{0xd0000000,  6},{0xd4000000,  6},
    {0xa8000000,  6},{0xac000000,  6},{0x4e000000,  7},{0x18000000,  7},
    {0x10000000,  7},{0x2e000000,  7},{0x06000000,  7},{0x08000000,  7},
    {0x50000000,  7},{0x56000000,  7},{0x26000000,  7},{0x48000000,  7},
    {0x30000000,  7},{0x02000000,  8},{0x03000000,  8},{0x1a000000,  8},
    {0x1b000000,  8},{0x12000000,  8},{0x13000000,  8},{0x14000000,  8},
    {0x15000000,  8},{0x16000000,  8},{0x17000000,  8},{0x28000000,  8},
    {0x29000000,  8},{0x2a000000,  8},{0x2b000000,  8},{0x2c000000,  8},
    {0x2d000000,  8},{0x04000000,  8},{0x05000000,  8},{0x0a000000,  8},
    {0x0b000000,  8},{0x52000000,  8},{0x53000000,  8},{0x54000000,  8},
    {0x55000000,  8},{0x24000000,  8},{0x25000000,  8},{0x58000000,  8},
    {0x59000000,  8},{0x5a000000,  8},{0x5b000000,  8},{0x4a000000,  8},
    {0x4b000000,  8},{0x32000000,  8},{0x33000000,  8},{0x34000000,  8}
};

ENCfm pBlackTermTbl[64] = {    /* Terminating Code Table (Black) */
    {0x0dc00000, 10},{0x40000000,  3},{0xc0000000,  2},{0x80000000,  2},
    {0x60000000,  3},{0x30000000,  4},{0x20000000,  4},{0x18000000,  5},
    {0x14000000,  6},{0x10000000,  6},{0x08000000,  7},{0x0a000000,  7},
    {0x0e000000,  7},{0x04000000,  8},{0x07000000,  8},{0x0c000000,  9},
    {0x05c00000, 10},{0x06000000, 10},{0x02000000, 10},{0x0ce00000, 11},
    {0x0d000000, 11},{0x0d800000, 11},{0x06e00000, 11},{0x05000000, 11},
    {0x02e00000, 11},{0x03000000, 11},{0x0ca00000, 12},{0x0cb00000, 12},
    {0x0cc00000, 12},{0x0cd00000, 12},{0x06800000, 12},{0x06900000, 12},
    {0x06a00000, 12},{0x06b00000, 12},{0x0d200000, 12},{0x0d300000, 12},
    {0x0d400000, 12},{0x0d500000, 12},{0x0d600000, 12},{0x0d700000, 12},
    {0x06c00000, 12},{0x06d00000, 12},{0x0da00000, 12},{0x0db00000, 12},
    {0x05400000, 12},{0x05500000, 12},{0x05600000, 12},{0x05700000, 12},
    {0x06400000, 12},{0x06500000, 12},{0x05200000, 12},{0x05300000, 12},
    {0x02400000, 12},{0x03700000, 12},{0x03800000, 12},{0x02700000, 12},
    {0x02800000, 12},{0x05800000, 12},{0x05900000, 12},{0x02b00000, 12},
    {0x02c00000, 12},{0x05a00000, 12},{0x06600000, 12},{0x06700000, 12}
};
ENCfm pWhiteMkupTbl[41] = {    /* Make-up Code Table (White) */
    {0x00100000, 12},{0xd8000000,  5},{0x90000000,  5},{0x5c000000,  6},
    {0x6e000000,  7},{0x36000000,  8},{0x37000000,  8},{0x64000000,  8},
    {0x65000000,  8},{0x68000000,  8},{0x67000000,  8},{0x66000000,  9},
    {0x66800000,  9},{0x69000000,  9},{0x69800000,  9},{0x6a000000,  9},
    {0x6a800000,  9},{0x6b000000,  9},{0x6b800000,  9},{0x6c000000,  9},
    {0x6c800000,  9},{0x6d000000,  9},{0x6d800000,  9},{0x4c000000,  9},
    {0x4c800000,  9},{0x4d000000,  9},{0x60000000,  6},{0x4d800000,  9},
    {0x01000000, 11},{0x01800000, 11},{0x01a00000, 11},{0x01200000, 12},
    {0x01300000, 12},{0x01400000, 12},{0x01500000, 12},{0x01600000, 12},
    {0x01700000, 12},{0x01c00000, 12},{0x01d00000, 12},{0x01e00000, 12},
    {0x01f00000, 12}
};
ENCfm pBlackMkupTbl[41] = {    /* Make-up Code Table (Black) */
    {0x00100000, 12},{0x03c00000, 10},{0x0c800000, 12},{0x0c900000, 12},
    {0x05b00000, 12},{0x03300000, 12},{0x03400000, 12},{0x03500000, 12},
    {0x03600000, 13},{0x03680000, 13},{0x02500000, 13},{0x02580000, 13},
    {0x02600000, 13},{0x02680000, 13},{0x03900000, 13},{0x03980000, 13},
    {0x03a00000, 13},{0x03a80000, 13},{0x03b00000, 13},{0x03b80000, 13},
    {0x02900000, 13},{0x02980000, 13},{0x02a00000, 13},{0x02a80000, 13},
    {0x02d00000, 13},{0x02d80000, 13},{0x03200000, 13},{0x03280000, 13},
    {0x01000000, 11},{0x01800000, 11},{0x01a00000, 11},{0x01200000, 12},
    {0x01300000, 12},{0x01400000, 12},{0x01500000, 12},{0x01600000, 12},
    {0x01700000, 12},{0x01c00000, 12},{0x01d00000, 12},{0x01e00000, 12},
    {0x01f00000, 12}
};


#define DIV8(k) ((k) >> 3)
#define MOD8(k) ((k) & 7)
#define MUL8(k) ((k) << 3)
#define DIV64(k) ((k) >> 6)
#define MOD64(k) ((k) & 63)

BOOL
ScanBits(
    PBYTE pSrc,
    INT iOffset,
    DWORD dwMaxSrc,
    PDWORD pdwRunLength
)
{
    BOOL bBlack;
    BYTE jTemp, jMask;
    PBYTE pMaxSrc = pSrc + dwMaxSrc;
    INT k;
    DWORD dwRunLength = 0;

    // The 1st byte.
    jTemp = *pSrc++;
#if MHEDEBUG
    jTemp = MHEDEBUGPATTERN;
#endif // MHEDEBUG
    bBlack = ((jTemp & (0x80 >> iOffset)) != 0);
    if (!bBlack) {
        jTemp = ~jTemp;
    }

    // fill previous bits.
    jTemp |= ~(0xff >> iOffset);

    // ...interlim bytes.
    jMask = 0xff;
    for (; pSrc < pMaxSrc; pSrc++) {
        if (jTemp != jMask)
            break;
        dwRunLength += 8;
        jTemp = *pSrc;
#if MHEDEBUG
    jTemp = MHEDEBUGPATTERN;
#endif // MHEDEBUG
        if (!bBlack) {
            jTemp = ~jTemp;
        }
    }

    // The last byte.
    jMask = ~0x80;
    for (k = 0; k < 8; k++) {
    
        if ((jTemp | jMask) != 0xff)
            break;
        jMask >>= 1;
    }
    dwRunLength += k;

    // Return results to the caller.
    *pdwRunLength = (dwRunLength - iOffset);
    return bBlack;
}

VOID
CopyBits(
    PBYTE pBuffer,
    INT iOffset,
    DWORD dwPattern,
    INT iPatternLength
)
{
    INT iNumberOfBytes, k;
    DWORD dwTemp;

    // Decide how many bytes we are to modify.
    iNumberOfBytes = DIV8(iOffset + iPatternLength + 7);

    // Make the pattern mask.
    dwPattern >>= iOffset;

    // Read in a byte if necessary.
    if (iOffset > 0) {
        dwTemp = (*pBuffer << 24);
        dwTemp &= ~((DWORD)~0 >> iOffset);
    }
    else {
        dwTemp = 0;
    }
    dwTemp |= dwPattern;

    // Write back.
    for (k = 3; k >= iNumberOfBytes; k--) {
        dwTemp >>= 8;
    }
    for (; k >= 0; k--) {
        *(pBuffer + k) = (BYTE)(dwTemp & 0xff);
        dwTemp >>= 8;
    }
}

INT
LGCompMHE(
    PBYTE pBuf,
    PBYTE pSrcBuf,
    DWORD dwMaxSrcBuf,
    INT iMode)
{
    DWORD dwSrcOffset = 0;
    DWORD dwOffset = 0;
    ENCfm *pMkupTbl, *pTermTbl;
    DWORD dwRunLength;
    INT k;
    BOOL bBlack;
    DWORD dwMaxSrcOffset = MUL8(dwMaxSrcBuf);
    PBYTE pSize;
    DWORD dwLength;

    // Embed print command if requested.
    if (iMode == 1) {

        // LG Raster 1 
        if (pBuf) {
            *(pBuf) = (BYTE)'\x9B';
            *(pBuf + 1) = (BYTE)'I';
            *(pBuf + 2) = COMP_MHE;
            pSize = (pBuf + 3);
            // 1 byte more.
        }
        dwOffset += 40;
    }

    while (dwSrcOffset < dwMaxSrcOffset) {

        bBlack = ScanBits(
            (pSrcBuf + DIV8(dwSrcOffset)),
            MOD8(dwSrcOffset),
            DIV8(dwMaxSrcOffset - dwSrcOffset + 7),
            &dwRunLength);

        VERBOSE(("LGCompMHE: %d, %d, %d (%d / %d)\n",
            dwOffset, dwRunLength, bBlack,
            dwSrcOffset, dwMaxSrcOffset));

        if (dwSrcOffset == 0 && bBlack) {

            // The 1st code in the data must be white encoding data.
            // So, we will insert "0 byte white run" record when the
            // data does not begin with white.

            dwLength = pWhiteTermTbl[0].vbln;
            if (pBuf) {
                CopyBits(
                    (pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    pWhiteTermTbl[0].cswd,
                    dwLength);
            }
            dwOffset += dwLength;
        }

        if (dwRunLength >= 2624) {

            if (pBuf) {
                CopyBits(
                    (pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    0x01f00000, 12);
            }
            dwOffset += 12;

            if (bBlack) {

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x06700000, 12);
                }
                dwOffset += 12;

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x35000000, 8);
                }
                dwOffset += 8;
            }
            else {

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x34000000, 8);
                }
                dwOffset += 8;

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x0dc00000, 10);
                }
                dwOffset += 10;
            }
            dwRunLength -= 2623;
        }

        if (bBlack) {
            pMkupTbl = pBlackMkupTbl;
            pTermTbl = pBlackTermTbl;
        }
        else {
            pMkupTbl = pWhiteMkupTbl;
            pTermTbl = pWhiteTermTbl;
        }

        if (dwRunLength >= 64) {

            dwLength = pMkupTbl[DIV64(dwRunLength)].vbln;
            if (pBuf) {
                CopyBits((pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    pMkupTbl[DIV64(dwRunLength)].cswd,
                    dwLength);
            }
            dwOffset += dwLength;
        }

        dwLength = pTermTbl[MOD64(dwRunLength)].vbln;
        if (pBuf) {
            CopyBits(
                (pBuf + DIV8(dwOffset)),
                MOD8(dwOffset),
                pTermTbl[MOD64(dwRunLength)].cswd,
                dwLength);
        }
        dwOffset += dwLength;

        // Next
        dwSrcOffset += dwRunLength;
    }

    // Convert unit into # of bytes.
    dwOffset = DIV8(dwOffset + 7);

    // Embed size information if requested.
    if (iMode == 1) {
        if (pBuf) {
            *pSize++ = (BYTE)((dwOffset - 5) >> 8);
            *pSize++ = (BYTE)(dwOffset - 5);
        }
    }

    return (INT)dwOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\lggdires.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->bComp = FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->bComp = pdmIn->bComp;
    }

    return TRUE;
}

#define MASTER_UNIT 600

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// Command callback ID's
//

#define CMD_XMOVE_ABS           10 // X-move Absolute
#define CMD_YMOVE_ABS           11 // Y-move Absolute
#define CMD_CR                  12
#define CMD_LF                  13
#define CMD_SEND_BLOCK_DATA     14
#define CMD_ENABLE_OEM_COMP     15
#define CMD_DISALBE_COMP        16

INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT        i;
    BYTE        Cmd[16];
    DWORD dwDestX, dwDestY;
    DWORD dwDataWidth;
    DWORD dwDataSize;
    INT iRet = 0;

    POEMUD_EXTRADATA lpOemData;

    VERBOSE(("OEMCommandCallback entry - %d, %d\r\n",
        dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //

    ASSERT(VALID_PDEVOBJ(pdevobj));

    lpOemData = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // fill in printer commands
    //

    i = 0;

    switch (dwCmdCbID) {

    case CMD_XMOVE_ABS:
    case CMD_YMOVE_ABS:

        VERBOSE(("MOVE_ABS - %d, %d, %d, %d\r\n",
            PARAM(pdwParams, 0),PARAM(pdwParams, 1),
            PARAM(pdwParams, 2),PARAM(pdwParams, 3)));

        //
        // The commands require 4 parameters
        //

        if (dwCount < 4 || !pdwParams)
            return 0;

        dwDestX = (PARAM(pdwParams, 0) * PARAM(pdwParams, 2)) / MASTER_UNIT;
        dwDestY = (PARAM(pdwParams, 1) * PARAM(pdwParams, 3)) / MASTER_UNIT;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'P';
        Cmd[i++] = (BYTE)(dwDestX >> 8);
        Cmd[i++] = (BYTE)(dwDestX);
        Cmd[i++] = (BYTE)(dwDestY >> 8);
        Cmd[i++] = (BYTE)(dwDestY);

        WRITESPOOLBUF(pdevobj, Cmd, i);

        switch (dwCmdCbID) {
        case CMD_XMOVE_ABS:
            iRet = dwDestX;
            break;
        case CMD_YMOVE_ABS:
            iRet = dwDestY;
            break;
        }
        break;

    case CMD_CR:

        dwDestY = (PARAM(pdwParams, 0) * PARAM(pdwParams, 1)) / MASTER_UNIT;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'P';
        Cmd[i++] = 0;
        Cmd[i++] = 0;
        Cmd[i++] = (BYTE)(dwDestY >> 8);
        Cmd[i++] = (BYTE)dwDestY;

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_LF:
        // DUMMY entry.
        break;

    case CMD_SEND_BLOCK_DATA:

        dwDataWidth = PARAM(pdwParams, 0) * 8;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'S';
        Cmd[i++] = (BYTE)(dwDataWidth >> 8);
        Cmd[i++] = (BYTE)(dwDataWidth);

        // In case it is OEMCompression data, we already
        // embedded printing command and data length.

        if (!lpOemData->bComp) {
            dwDataSize = PARAM(pdwParams, 1);
            Cmd[i++] = (BYTE)'\x9B';
            Cmd[i++] = 'I';
            Cmd[i++] = COMP_NONE;
            Cmd[i++] = (BYTE)(dwDataSize >> 8);
            Cmd[i++] = (BYTE)(dwDataSize);
        }

        WRITESPOOLBUF(pdevobj, Cmd, i);
        break;

    case CMD_ENABLE_OEM_COMP:
        lpOemData->bComp = TRUE;
        break;

    case CMD_DISALBE_COMP:
        lpOemData->bComp = FALSE;
        break;
    }

    return iRet;
}

INT
APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE pInBuf,
    PBYTE pOutBuf,
    DWORD dwInLen,
    DWORD dwOutLen)
{
    INT iRet = -1;
    INT iRetRLE, iRetMHE;
    DWORD dwMHECeil = 0xc00000; // Can be any.

    // Compression algorithm (per each scanline)

#if defined(RLETEST)

    if (LGCompRLE(NULL, pInBuf, dwInLen, 1) <= (INT)(dwOutLen * 2 / 3)) {
        iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
    }

#elif defined(MHETEST)

    if (LGCompMHE(NULL, pInBuf, dwInLen, 1) <= (INT)(dwOutLen * 2 / 3)) {
        iRet = LGCompMHE(pOutBuf, pInBuf, dwInLen, 1);
    }

#else // Normal case.

    iRetRLE = LGCompRLE(NULL, pInBuf, dwInLen, 1);
    if (iRetRLE >= 0 && iRetRLE < (INT)dwInLen / 2) {

        // Ok with RLE.
        iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
    }
    else if (iRetRLE <= (INT)dwInLen) {

        // Try MHE.
        iRetMHE = LGCompMHE(NULL, pInBuf, dwInLen, 1);
        if (iRetMHE > 0 && iRetMHE < iRetRLE && iRetMHE < (INT)dwMHECeil) {

            // Go with MHE.
            iRet = LGCompMHE(pOutBuf, pInBuf, dwInLen, 1);
        }
        else {
            // Go with RLE.
            iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
        }
    }
#endif // NORMAL

    VERBOSE(("OEMCompression - dwInLen=%d,dwOutLen=%d,iRet = %d\n",
        dwInLen, dwOutLen, iRet));

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF


ALT_PROJECT=KOR
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\lg\$(ALT_PROJECT)
SRCDIR=..

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

TARGETNAME=lggdires
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),lggdires
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\lggdires.rc \
    $(SRCDIR)\lggdires.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\lgcomp.c

MISCFILES=\
    $(SRCDIR)\lggdires.ini \
    $(GPDDIR)\lglp63jk.gpd \
    $(GPDDIR)\lglp63pk.gpd \
    $(GPDDIR)\lglp66jk.gpd \
    $(GPDDIR)\lglp860k.gpd \
    $(GPDDIR)\lglp86nk.gpd \
    $(GPDDIR)\lgmf700k.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggdires\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#include "lgcomp.h"

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) \
    ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'LGGD'      // LG GDI x00 series dll
#define DLLTEXT(s)      "LGGD: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
    // Private extention
    INT bComp;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF


ALT_PROJECT=KOR
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\lg\$(ALT_PROJECT)
SRCDIR=..

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

TARGETNAME=lggs6res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),lggs6res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(SRCDIR)\..\lggdires

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\lggs6res.rc \
    $(SRCDIR)\lggs6res.c \
    $(SRCDIR)\common.c \

MISCFILES=\
    $(SRCDIR)\lggs6res.ini \
    $(GPDDIR)\lglp660k.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#include "lgcomp.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'LGS6'      // LG GSS6 prnters
#define DLLTEXT(s)      "LGS6: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
    // Private extention
    INT bComp;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define COMP_NONE 0
#define COMP_RLE  1

// See lgcomp.c
extern INT LGCompRLE(PBYTE, PBYTE, DWORD, INT);

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);


#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\lggs6res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->bComp = FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->bComp = pdmIn->bComp;
    }

    return TRUE;
}

#define MASTER_UNIT 600

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// Command callback ID's
//

#define CMD_XMOVE_ABS           10 // X-move Absolute
#define CMD_YMOVE_ABS           11 // Y-move Absolute
#define CMD_CR                  12
#define CMD_LF                  13
#define CMD_SEND_BLOCK_DATA     14
#define CMD_ENABLE_OEM_COMP     15
#define CMD_DISALBE_COMP        16


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT        i;
    BYTE        Cmd[50];
    DWORD dwDestX, dwDestY;
    DWORD dwDataWidth;
    DWORD dwDataHeight;
    DWORD dwDataSize;
    INT iRet = 0;

    POEMUD_EXTRADATA lpOemData;

    VERBOSE(("OEMCommandCallback entry - %d, %d\r\n",
        dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //

    ASSERT(VALID_PDEVOBJ(pdevobj));

    lpOemData = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // fill in printer commands
    //

    i = 0;

    switch (dwCmdCbID) {

    case CMD_XMOVE_ABS:
    case CMD_YMOVE_ABS:

        VERBOSE(("MOVE_ABS - %d, %d, %d, %d\r\n",
            PARAM(pdwParams, 0),PARAM(pdwParams, 1),
            PARAM(pdwParams, 2),PARAM(pdwParams, 3)));

        //
        // The commands require 4 parameters
        //

        if (dwCount < 4 || !pdwParams)
            return 0;

        dwDestX = (PARAM(pdwParams, 0) * PARAM(pdwParams, 2)) / MASTER_UNIT;
        dwDestY = (PARAM(pdwParams, 1) * PARAM(pdwParams, 3)) / MASTER_UNIT;


        // Since we are to emit cursor move commands at send block,
        // here we just return values to fake Unidrv.

        switch (dwCmdCbID) {
        case CMD_XMOVE_ABS:
            iRet = dwDestX;
            break;
        case CMD_YMOVE_ABS:
            iRet = dwDestY;
            break;
        }
        break;

    case CMD_CR:

        // DUMMY entry.
        break;

    case CMD_LF:

        // DUMMY entry.
        break;

    case CMD_SEND_BLOCK_DATA:

        dwDestX = (PARAM(pdwParams, 0) * PARAM(pdwParams, 2)) / MASTER_UNIT;
        dwDestY = (PARAM(pdwParams, 1) * PARAM(pdwParams, 3)) / MASTER_UNIT;
        dwDataWidth = PARAM(pdwParams, 4) * 8;
        dwDataHeight = PARAM(pdwParams, 5);
        dwDataSize = PARAM(pdwParams, 6);

	
        VERBOSE(("SEND_BLOCK: (%d,%d),(%d,%d),(%d,%d,%d)\n",
            PARAM(pdwParams, 0),PARAM(pdwParams, 1),
            PARAM(pdwParams, 2),PARAM(pdwParams, 3),
            PARAM(pdwParams, 4),PARAM(pdwParams, 5),
            PARAM(pdwParams, 6)));

        // Emit curspor position.
        // On LG Raser 2 printers, cursor positioning commands
        // are allowed only before image output.

        if ((iRet = sprintf(&Cmd[i],
            "\x1bGMA(%ld,%ld)",
            dwDestX,
            dwDestY)) >= 0) {
            i += iRet;
        }

        // Set image size.

        if ((iRet = sprintf(&Cmd[i],
            "\x1bGRI(%ld,%ld)",
            dwDataWidth,
            dwDataHeight)) >= 0) {
            i += iRet;
        }

        // Semd block data
        // Comprssion mode switch:
        // 0 - None, 1 - RLE, 3 - MH.

        if ((iRet = sprintf(&Cmd[i],
            "\x1bGRT(%ld,%d)",
            dwDataSize,
            (lpOemData->bComp ? 3 : 0))) >= 0) {
            i += iRet;
        }

        WRITESPOOLBUF(pdevobj, Cmd, i);
        break;

    case CMD_ENABLE_OEM_COMP:
        lpOemData->bComp = TRUE;
        break;

    case CMD_DISALBE_COMP:
        lpOemData->bComp = FALSE;
        break;
    }

    return iRet;
}


INT
APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE pInBuf,
    PBYTE pOutBuf,
    DWORD dwInLen,
    DWORD dwOutLen)
{
    INT iRet = -1;
    
    // Compression algorithm (per each scanline)

#if 0
    if (LGCompRLE(NULL, pInBuf, dwInLen, 2) <= (INT)dwOutLen) {
	    iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 2);
    }
#else
    // Use MH compression as of now.
    if (LGCompMHE(NULL, pInBuf, dwInLen, 2) <= (INT)(dwOutLen * 2 / 3)) {
        iRet = LGCompMHE(pOutBuf, pInBuf, dwInLen, 2);
    }
#endif

    VERBOSE(("OEMCompression - dwInLen=%d,dwOutLen=%d,iRet = %d\n",
        dwInLen, dwOutLen, iRet));

    return iRet;
}

// Borrow this from LG Raster 1.

#include "lgcomp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\lggs6res\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));

        *piResult = OEMCompression(
                pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);
        if (*piResult > 0) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc11jres\hlp\nc11jres.h ===
/* PAPER SETTING */
#define POP_11_PAPSET                1150
#define POP_11_PAPSET2               1151


/* PRINT QUALITIES */
#define POP_11_PQUALITIESOLD         1166
#define POP_11_PQUALITIESNEW         1167


/* TextHalftonThreshold */
#define POP_11_TEXTHALFTONE          1180
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc21jres\hlp\nc21jres.h ===
/* PAPER SETTING */
#define POP_21_PAPSET                2150
/* #define POP_21_PAPSET40              2151 */


/* PRINT QUALITIES */
#define POP_21_PQUALITIESOLD         2166
#define POP_21_PQUALITIESNEW         2167

/* KANJI CODE */
#define POP_21_KANJICODE             2170

/* TextHalftoneThreshold */
#define POP_21_TEXTHALFTONE          2180
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc24tres\etc\nec24c.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "NEC24C";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\nc62jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#include "pdev.h"

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// command callback ID's
//
#define CMD_MOVE_X           23
#define CMD_MOVE_Y           24
#define CMD_BEGIN_RASTER     26
#define CMD_RES_240          29     //for PR601,602,602R
#define CMD_SEND_BLOCK_DATA  30     //for PR1000,1000/2,2000
#define CMD_RES_240NEW       31     //for PR1000,1000/2,2000
#define CMD_SEND_BLOCK_DATA2 32     //for PR601,602,602R
#define CMD_INIT_COORDINATE  33
#define CMD_PC_PRN_DIRECTION 50
#define CMD_CR               51

// #278517: RectFill
#define CMD_RECTWIDTH        60
#define CMD_RECTHEIGHT       61
// #define CMD_RECTWHITE        62
#define CMD_RECTBLACK        63
// #define CMD_RECTGRAY         64


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }
    return TRUE;
}

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;

    return rLen;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;

    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

    switch (dwCmdCbID) {
    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

        if (dwCount < 4)
            return 0;      // cannot do anything

        pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
                (MASTER_UNIT / PARAM(pdwParams, 2));
        pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
                (MASTER_UNIT / PARAM(pdwParams, 3));

        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

    case CMD_RES_240:

        pOEM->wRes = MASTER_UNIT / 240;

        break;

    case CMD_RES_240NEW:

        i = 0;
        i += memcopy(&Cmd[i], "\034<1/240,i.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;

        break;

    case CMD_SEND_BLOCK_DATA:

        /* Send a draw coordinate command to the printer. */
        i = 0;
        i += memcopy(&Cmd[i], "\034e", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        /* Save the present coordinate. */
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

        /* Send an image data draw command. */
        i = 0;
        i += memcopy(&Cmd[i], "\034R", 2);
        i += memcopy(&Cmd[i], "\034i", 2);
        i += iDwtoA(&Cmd[i], (PARAM(pdwParams, 0) * 8 ));
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 1));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "0,1/1,1/1,", 10);
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 2));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "240", 3);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_SEND_BLOCK_DATA2:

        /* Send a draw coordinate command to the printer. */
        i = 0;
        i += memcopy(&Cmd[i], "\034e", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        /* Save the present coordinate. */
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

        /* Send an image data draw command. */
        i = 0;
        i += memcopy(&Cmd[i], "\034R", 2);
        i += memcopy(&Cmd[i], "\034i", 2);
        i += iDwtoA(&Cmd[i], (PARAM(pdwParams, 0) * 8 ));
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 1));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "0,1/1,1/1,", 10);
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 2));
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_BEGIN_RASTER:
        if (pOEM->wCurrentAddMode){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = 0;
        }
        break;

    case CMD_PC_PRN_DIRECTION:
        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_INIT_COORDINATE:
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = 0;
// #278517: RectFill
        if (!(pOEM->fGeneral & FG_GMINIT)) {
            i = 0;
            i += memcopy(&Cmd[i], "\x1CYIN;SU1,", 9);
            i += iDwtoA(&Cmd[i], MASTER_UNIT / pOEM->wRes);
            i += memcopy(&Cmd[i], ",0;XX1;PM1;XX0;\x1CZ", 17);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->fGeneral |= FG_GMINIT;
        }
        break;

// #278517: RectFill
    case CMD_RECTWIDTH:
        pOEM->dwRectWidth = PARAM(pdwParams, 0) / pOEM->wRes;
        break;
    case CMD_RECTHEIGHT:
        pOEM->dwRectHeight = PARAM(pdwParams, 0) / pOEM->wRes;
        break;
    case CMD_RECTBLACK:
        {
        i = 0;
        // #285792: Excel file is not print out correctly.
        // Need '\x1CR' during the text mode.
        i += memcopy(&Cmd[i], "\x1CR\x1CYXX1;MA", 10);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        // #285789: Some text box print as black.
        // "SG" command doesn't recognized on PC-PR602 series.
        // i += memcopy(&Cmd[i], ";SG", 3);
        // i += iDwtoA(&Cmd[i], iGray);
        i += memcopy(&Cmd[i], ";RA", 3);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX + pOEM->dwRectWidth - 1);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + pOEM->dwRectHeight - 1);
        i += memcopy(&Cmd[i], ";XX0;\x1CZ", 7);
        WRITESPOOLBUF(pdevobj, Cmd, i);
        }
        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut, dwTemp;    // = i,ocmd = counter
    PBYTE       pubCmd;                 // = lpcmd
    BYTE        aubCmd[128];            // = rgcmd[]
    POEMUD_EXTRADATA    pOEM;           // = LPPR602DATASTRUCTURE like
    DWORD       tmpPoints;
    PIFIMETRICS pIFI;                   // = LPFONTINFO
    DWORD       dwNeeded;

    DWORD       dwCount;
    BOOL        bFound = FALSE;

    char  pcom1[] = {'Q', 'E', 'H'};
    char  *pcom2[] = {"070","105","120"};
    char  *bcom[] = {"1/2,1/2,L.", "1/1,1/1,L.", "2/1,2/1,L.", "3/1,3/1,L.",
                     "4/1,4/1,L.", "6/1,6/1,L.", "8/1,8/1,L."};

    short  PTable1[] = {      0,1,2,0,0,1,1,1,2,2,0,0,0,0,1,1,1,
                        0,0,2,2,2,2,0,0,0,1,1,1,1,2,2,2,2,2,1,1,
                        1,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,1,1,
                        1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
                        1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2};

    short  BTable1[] = {      0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
                        3,3,2,2,2,2,4,4,4,3,3,3,3,3,3,3,3,3,4,4,
                        4,5,5,5,5,4,4,4,4,4,4,4,6,6,6,6,6,6,5,5,
                        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
                        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6};

    short  PTable2[] = {      0,1,2,0,0,0,1,1,2,2,0,0,0,0,0,1,1,
                        1,1,2,2,2,2,0,0,0,0,1,1,1,1,2,2,2,2,2,1,
                        1,1,1,1,1,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,
                        0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,
                        1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2};

    short  BTable2[] = {      0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
                        2,2,2,2,2,2,4,4,4,4,3,3,3,3,3,3,3,3,3,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,6,6,
                        6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
                        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6};

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return;
    }

    pubCmd = pFInv->pubCommand;    //Copy Font Selection Command
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);    //Copy ExtraData
    pIFI = pUFObj->pIFIMetrics;


    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }

    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    tmpPoints = ((pSV->StdVar[0].lStdVariable / pOEM->wRes)  * 72)
                                            / pSV->StdVar[2].lStdVariable;

    if(tmpPoints > 96)     tmpPoints = 96;
    else if(tmpPoints < 4) tmpPoints = 4;

    tmpPoints -= 4;

    dwIn = dwOut = dwTemp = 0;

    pOEM->fGeneral &= ~(FG_VERT | FG_DBCS);

    while(dwIn < pFInv->dwCount && dwOut < 128)
    {
        while(dwCount--)
        {
            if(pubCmd[dwIn] !='#'){
                aubCmd[dwOut] = pubCmd[dwIn];
                dwOut++;
                dwIn++;
            }
            else{
                bFound = TRUE;
                break;
            }
        }

        if(bFound == TRUE)
            dwIn++;
        else
            return;   // mismatch font command


        switch(pubCmd[dwIn])
        {
        case 'T':  // 602,602R 2Byte TATE Size
            pOEM->fGeneral |= FG_VERT;

        case 'Q':  // 602,602R 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            if(tmpPoints < 3) tmpPoints = 3;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)pcom2[PTable2[tmpPoints]], 3);
            break;

        case 'S':  // NPDL 2Byte TATE Size
           pOEM->fGeneral |= FG_VERT;

        case 'P':  // NPDL 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)pcom2[PTable2[tmpPoints]], 3);
            break;

        case 'U':  // 601 TATE SIZE
            pOEM->fGeneral |= FG_VERT;

        case 'R':  // 601 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            if(tmpPoints < 3) tmpPoints = 3;
            dwTemp = BTable2[tmpPoints] > 2 ? 2 : PTable2[tmpPoints];
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)pcom2[dwTemp], 3);
            break;

        case 'X':  // 602,602R,NPDL 2Byte Scale
            pOEM->fGeneral |= FG_DBCS;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)bcom[BTable2[tmpPoints]], 10);
            break;

        case 'Y':  // 601 2Byte Scale
            pOEM->fGeneral |= FG_DBCS;
            dwTemp = BTable2[tmpPoints] > 1 ? 2 : 1;
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[dwTemp], 10);
            break;

        case 'L':  // 1Byte Size
            aubCmd[dwOut] = pcom1[PTable1[tmpPoints]];
            dwOut++;

            break;

        case 'M':  // 1Byte Scale
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)bcom[BTable2[tmpPoints]], 10);
        }

        dwIn++;
    }

        WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
    if(pOEM->fGeneral & FG_DBCS)
    {

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }
    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = 0;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));
}

//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE  aubBuff[256];
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;


    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;


    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

// #333653: Change I/F for GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        MemFree(aubBuff);
        return;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;
    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {

        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
         if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)

        {
            int i = 0;
            BYTE  Cmd[256];

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = ',';
            Cmd[i++] = '0';
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
             if(pOEM->wCurrentAddMode != FLAG_DBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                int i = 0;
                BYTE  Cmd[256];

                i += memcopy(&Cmd[i], "\034e", 2);
                i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
                Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = ',';
                Cmd[i++] = '0';
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                int i = 0;
                BYTE  Cmd[256];

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = ',';
                Cmd[i++] = '0';
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }
// #333653: Change I/F for GETINFO_GLYPHSTRING
    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NC62'      // NEC 602 series dll
#define DLLTEXT(s)     "NC62: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD  wRes;             // resolution / MasterUnit
    DWORD dwSBCSX;          // temp
    DWORD dwDBCSX;          // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD fGeneral;         // general flag
    WORD  wCurrentAddMode;  // draw mode
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
// #278517: RectFill
#define FG_GMINIT   0x00000040

#define FLAG_SBCS  1
#define FLAG_DBCS  2

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc62jres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=nc62jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fjxlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\nc62jres.rc \
    $(SRCDIR)\nc62jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\nc62jres.ini \
    $(GPDDIR)\nc62102j.gpd \
    $(GPDDIR)\nc6210j.gpd \
    $(GPDDIR)\nc6220j.gpd \
    $(GPDDIR)\nc6261j.gpd \
    $(GPDDIR)\nc62j.gpd \
    $(GPDDIR)\nc62rj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc75jres\hlp\nc75jres.h ===
/* PRINT QUALITIES */
#define POP_75_PQUALITIESNEW         7560


/* KANJI CODE */
#define POP_75_KANJICODE             7570

/*  */
#define POP_75_TEXTHALFTONE          7580
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc70jres\hlp\nc70jres.h ===
/* PAPER SETTING */
#define POP_70_YOUSIHOUKOU           7050
#define POP_70_YOUSIHOUKOU2          7051
#define POP_70_YOUSIHOUKOU3          7052
#define POP_70_YOUSIHOUKOU4          7053


/* PRINT QUALITIES */
#define POP_70_PQUALITIESNEW         7060
#define POP_70_PQUALITIESNEW2        7061
#define POP_70_PQUALITIESNEW3        7062

/* KANJI CODE */
#define POP_70_KANJICODE             7070

/* TextHalftoneThreshold */
#define POP_70_TEXTHALFTONE          7080
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    //DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        //DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        //DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    //DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        //DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        //DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            //DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        //DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        //DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        //DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        //DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        //DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        //DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        //DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        //DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        //DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


//
// Functions for outputting debug messages
//
#if 0
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// ######################

// Function Name: GetInfo
// Plug-in: Any
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::GetInfo(
    DWORD dwMode,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

// ######################

//
// Function Name: PublishDriverInterface
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

int __cdecl
iCompNames(
    void *p1,
    void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
}

LONG __stdcall
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            (int (__cdecl *)(const void *, const void *))iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

// #######################

//
// Function Name: EnableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: EnablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: DisablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisablePDEV(
    PDEVOBJ pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
//  return E_FAIL;
}

//
// Function Name: DevMode
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

// ################


//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    if (*piResult < 0) {
        return E_FAIL;
    }
    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if (OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

HRESULT __stdcall
IOemCF::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\nc82jres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#include "pdev.h"

#include "nc82jres.h"

#undef wsprintf
#define wsprintf sprintf

HRESULT SendABSMove(
PDEVOBJ pdevobj,
LPDWORD   lpdwParams);

HRESULT SpoolOut(PDEVOBJ pdevobj, FILE* pFile);

HRESULT
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    LPPCPRDATASTRUCTURE pdevOEM,
    INT iPlane);

HRESULT
DataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen);

VOID
BPBCalc(
    PDEVOBJ pdevobj,
    PBYTE pDataBuf,
    DWORD dwLen,
    BYTE BPBCommand);

/*************************** Function Header *******************************
 *  OEMEnablePDEV
 *  (MiniDrvEnablePDEV)
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *  15 Apr 1998    -by-    Yoshitaka Oku     [yoshitao]
 *      Conversion to NT5.0 spec driver
 *
 ***************************************************************************/
PDEVOEM APIENTRY OEMEnablePDEV(
PDEVOBJ pdevobj,
PWSTR pPrinterName,
ULONG cPatterns,
HSURF* phsurfPatterns,
ULONG cjGdiInfo,
GDIINFO* pGdiInfo,
ULONG cjDevInfo,
DEVINFO* pDevInfo,
DRVENABLEDATA * pded)
{
    LPPCPRDATASTRUCTURE    lpnp;

    //DbgPrint(DLLTEXT("OEMEnablePDEV(--) entry.\r\n"));

    if ((lpnp = (PCPRDATASTRUCTURE *) MemAllocZ(
            sizeof(PCPRDATASTRUCTURE ))) == NULL)
    {
        return 0;
    }

    memset(lpnp, 0, sizeof (PCPRDATASTRUCTURE));
    memcpy(lpnp->pszSheetSetting, SHEET_CMD_DEFAULT,
        SHEET_CMDLEN );

    pdevobj->pdevOEM = lpnp;

    return lpnp;
}

/*************************** Function Header *******************************
 *  OEMDisablePDEV
 *  (MiniDrvDisablePDEV)
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *  15 Apr 1998    -by-    Yoshitaka Oku     [yoshitao]
 *      Conversion to NT5.0 spec driver
 *
 ***************************************************************************/
VOID APIENTRY OEMDisablePDEV(
PDEVOBJ pdevobj)
{

    //DbgPrint(DLLTEXT("OEMDisablePDEV(--) entry.\r\n"));

    if ( pdevobj && pdevobj->pdevOEM )
    {
        MemFree( pdevobj->pdevOEM );
    }

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    LPPCPRDATASTRUCTURE pOEMOld, pOEMNew;

    pOEMOld = (LPPCPRDATASTRUCTURE)pdevobjOld->pdevOEM;
    pOEMNew = (LPPCPRDATASTRUCTURE)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

BOOL APIENTRY OEMFilterGraphics (
PDEVOBJ pdevobj,
PBYTE pBuf,
DWORD dwLen)
{

    LPPCPRDATASTRUCTURE lpnp;

    //DbgPrint(DLLTEXT("OEMFilterGraphics(%d bytes) entry.\r\n"),dwLen);

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    if (dwLen == 0)
	return TRUE;

    //if (dwLen != lpnp->wNumScans * lpnp->wScanWidth * 3)
	//DbgPrint(DLLTEXT("OEMFilterGraphics(%d bytes - %d) entry.\r\n"),dwLen,lpnp->wNumScans * lpnp->wScanWidth * 3);

    // YMC(K)
    // lpnp->iColor : data's color
    switch( lpnp->iColor )
    {
    case YELLOW:

        // Send YELLOW data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_COPY);
        }
        break;

    case MAGENTA:
        // Send MAGENTA data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_AND);
        }
        break;

    case CYAN:
        // Send CYAN data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_AND);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[3], lpnp->BPBuf, dwLen);
            BPBCalc(pdevobj, pBuf, dwLen, BPB_CLR);
        }
        break;

    case BLACK:
        // Send BLACK data.
        if(lpnp->bComBlackMode) {
            DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, dwLen);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, dwLen);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, dwLen);
	} else
            DATASPOOL4FG(pdevobj, lpnp->TempFile[3], pBuf, dwLen);
        break;

    case RGB_COLOR:

        //if( lpnp->iPlaneNumber == 4 )
            //break;

        if(((lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO) ||
            (lpnp->iRibbon == CMDID_RIBBON_3COLOR_SHOKA)) &&
            (lpnp->iColorMode == CMDID_MODE_COLOR))
        {
            int	i, j, iDiv;
            LPSTR	lpByte;
	    char	pad[] = "\x00\x00\x00\x00\x00\x00\x00\x00";

            i = dwLen;
            lpByte = pBuf;

            // Convert RGB to CMY
            while( --i > 0 )
                *lpByte++ ^= ~((BYTE)0);

            if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO)
                //iDiv = 29;   // KAICHO DATA : 9 step  29=(255+8)/9
                iDiv = 32;  // adjustment
            else
                iDiv = 4;    // SHOKA DATA : 64 step  4=(255+63)/64

            for( j = 0; j < lpnp->wNumScans; j++) {

		if (lpnp->wTopPad) {
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pad, lpnp->wTopPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pad, lpnp->wTopPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pad, lpnp->wTopPad);
		}

                for( i = 0; i < lpnp->wScanWidth; i++) {
                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, 1);
		    pBuf++;

                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, 1);
		    pBuf++;

                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, 1);
		    pBuf++;
                }

		if (lpnp->wEndPad) {
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pad, lpnp->wEndPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pad, lpnp->wEndPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pad, lpnp->wEndPad);
		}
            }
        }
        else
        {
            int     h, i, j, iBlack;
	    char    SpoolBin[8];

            if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO)
                iBlack = 8;  // KAICHO DATA : 9 step
            else
                iBlack = 63; // SHOKA DATA : 64 step

            for( j = 0; j < lpnp->wNumScans; j++) {
                for( i = 0; i < lpnp->wScanWidth; i++) {
                    for( h = 0; h < 8; h++)
                        SpoolBin[h] = ((*pBuf << h) & 0x80) ? iBlack : 0;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], SpoolBin, 8);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], SpoolBin, 8);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], SpoolBin, 8);
		    pBuf++;
                }
            }
        }
        break;

    default:
	//DbgPrint(DLLTEXT("OEMFilterGraphics: Invalid color(%d).\r\n"), lpnp->iColor);
        break;

    }

    return TRUE;
}


INT APIENTRY OEMCommandCallback(
PDEVOBJ pdevobj,
DWORD dwCmdCbID,
DWORD dwCount,
PDWORD pdwParams)
{

    LPPCPRDATASTRUCTURE lpnp;
    WORD   len;
    BYTE   ch[100];
    WORD   wOutByte;
    WORD   wOld;
    INT    i;
    INT    iRet = 0;
    HANDLE hToken = NULL;

    //DbgPrint(DLLTEXT("OEMCommandCallback(%d) entry.\r\n"),dwCmdCbID );
    //if ((dwCmdCbID != 25) && (dwCmdCbID != 30)&& (dwCmdCbID != 31)&& (dwCmdCbID != 60))
	//DbgPrint(DLLTEXT("OEMCommandCallback(%d) entry.\r\n"),dwCmdCbID );

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    switch ( dwCmdCbID ){

    case CMDID_COLOR_YELLOW:
    case CMDID_COLOR_MAGENTA:
    case CMDID_COLOR_CYAN:
    case CMDID_COLOR_BLACK:

//        if(!(lpnp->iPlaneNumber = UniDrvGetPlaneId(pdevobj)))
        if(!(lpnp->iPlaneNumber = 1))
        {
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid iPlaneNumber = 0 \n");
        }

        switch( dwCmdCbID )
        {
        case CMDID_COLOR_YELLOW:

            // Color Y
            // Send \x1B%lD\x83
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = YELLOW;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams ) ) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);
            break;


        case CMDID_COLOR_MAGENTA:

            // Color M
            // Send \x1B%lDC
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = MAGENTA;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);
            break;


        case CMDID_COLOR_CYAN:

            // Color C
            // Send \x1B%lD# with param
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = CYAN;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);

            if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
                 (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
                len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
                        LOBYTE(wOutByte), HIBYTE(wOutByte));
                DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
            }

            break;


        case CMDID_COLOR_BLACK:

            // Color K
            // Send \x1B%lD\x13
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = BLACK;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
                    LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
            break;
        }
        break;

    case CMDID_COLOR_BLACKONLY:

        if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_A4)
	    lpnp->bComBlackMode = TRUE;

        lpnp->iColor = BLACK;
        lpnp->iPlaneNumber = BLACK;

        if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
            return -1;
        }
        wOutByte = (WORD)pdwParams[0] + 2;

        if(lpnp->bComBlackMode)
        {
            // If an user selects glay scale with 3colors ribbon,
            // we print it with CYAN ribbon because there is not black ribbon

	    // Spec change on NT5.
	    // Make black color by 3 colors composite on this situation.

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);

            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);
        }
        else
        {
            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
        }

        break;

    case CMDID_COLOR_RGB:

	if (pdwParams[0] == 0)
	    break;

//    DbgPrint(DLLTEXT("BlockData(%d,%d,%d)\r\n"),pdwParams[0],pdwParams[1],pdwParams[2] );
        lpnp->iColor = RGB_COLOR;

//        if(!(lpnp->iPlaneNumber = UniDrvGetPlaneId(pdevobj)))
        if(!(lpnp->iPlaneNumber = 1))
        {
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid iPlaneNumber = 0 \n");
        }

        // This is 3 plane model.
        if( lpnp->iPlaneNumber == 4 )
            break;

        if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
            return -1;
        }
        wOutByte = (WORD)(lpnp->wScanBytes * lpnp->wNumScans * 8) + 2;

	len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);

        len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);

        len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
                            LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);

        break;


        // \x1B\x09\x00C%l%l  param1 /8  param2 none
        // store x and y positions
    case CMDID_X_ABS_MOVE:
        wOld = lpnp->wXpos;
        lpnp->wXpos = (WORD)pdwParams[0];
        return (lpnp->wXpos > wOld ? lpnp->wXpos - wOld : wOld - lpnp->wXpos);

    case CMDID_Y_ABS_MOVE:
        wOld = lpnp->wYpos;
        lpnp->wYpos = (WORD)pdwParams[0];
        return (lpnp->wYpos > wOld ? lpnp->wYpos - wOld : wOld - lpnp->wYpos);

    case 60: // CmdYMoveRelDown
	//DbgPrint(DLLTEXT("CmdYMoveRelDown(%d) \r\n"),pdwParams[0] );
        lpnp->wYpos += (WORD)pdwParams[0];
	return pdwParams[0];

    case CMDID_BEGINPAGE:

        BPBCalc(pdevobj, 0, BPB_SIZE, BPB_CLR);

        if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x01\x00\x47", 4)) {
            return -1;
        }
        switch (lpnp->iRibbon)
        {

        case CMDID_RIBBON_MONO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\x10", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_A4:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe0", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_4COLOR_A4:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xf0", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_4COLOR_A4LONG:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xf1", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_KAICHO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe2", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_SHOKA:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe3", 5)) {
                return -1;
            }
            break;

        default:
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid Ribbon ID = %d \n", lpnp->iRibbon );
            return FALSE;
        }

        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 0)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 1)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 2)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 3)) {
            return -1;
        }
	lpnp->wXpos = 0;
	lpnp->wYpos = 0;
	lpnp->iFirstColor = 0;
	lpnp->wOldNumScans = 0;
	lpnp->bComBlackMode = FALSE;
        break;

    case CMDID_ENDPAGE:

	SpoolOut(pdevobj, lpnp->TempFile[0]);
	SpoolOut(pdevobj, lpnp->TempFile[1]);
	SpoolOut(pdevobj, lpnp->TempFile[2]);
	SpoolOut(pdevobj, lpnp->TempFile[3]);

        // Close cache files.
        for (i = 0; i < 4; i++) {
            if (INVALID_HANDLE_VALUE != lpnp->TempFile[i]) {
                if (0 == CloseHandle(lpnp->TempFile[i])) {
                    ERR((DLLTEXT("CloseHandle error %d\n"),
                            GetLastError()));
                }
                lpnp->TempFile[i] = INVALID_HANDLE_VALUE;

                hToken = RevertToPrinterSelf();
                if (0 == DeleteFile(lpnp->TempName[i])) {
                    ERR((DLLTEXT("DeleteName error %d\n"),
                            GetLastError()));
                }
                if (hToken != NULL) {
                    (VOID)ImpersonatePrinterClient(hToken);
                }
                lpnp->TempName[i][0] = __TEXT('\0');
            }
        }

        if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x01\x00\x48", 4)) {
            return -1;
        }
        break;


    case CMDID_SELECT_RESOLUTION:

        switch (lpnp->iRibbon)
        {

        case CMDID_RIBBON_3COLOR_KAICHO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x03\x00\x41\x2c\x01\x1b\x03\x00\x42\x10\x00", 12)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_SHOKA:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x03\x00\x41\x2c\x01\x1b\x03\x00\x42\x20\x00", 12)) {
                return -1;
            }
            break;
        }

        break;

    case CMDID_RIBBON_MONO:
        lpnp->iRibbon = CMDID_RIBBON_MONO;
        break;

    case CMDID_RIBBON_3COLOR_A4:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_A4;
        break;

    case CMDID_RIBBON_4COLOR_A4:
        lpnp->iRibbon = CMDID_RIBBON_4COLOR_A4;
        break;

    case CMDID_RIBBON_4COLOR_A4LONG:
        lpnp->iRibbon = CMDID_RIBBON_4COLOR_A4LONG;
        break;

    case CMDID_RIBBON_3COLOR_KAICHO:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_KAICHO;
        break;

    case CMDID_RIBBON_3COLOR_SHOKA:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_SHOKA;
        break;

    case CMDID_PSIZE_LETTER:
        lpnp->pszSheetSetting[4] = P1_LETTER;
        break;

    case CMDID_PSIZE_LEGAL:
        lpnp->pszSheetSetting[4] = P1_LEGAL;
        break;

    case CMDID_PSIZE_A4:
        lpnp->pszSheetSetting[4] = P1_A4;
        break;

    case CMDID_PSIZE_A4LONG:
        lpnp->pszSheetSetting[4] = P1_A4LONG;
        break;

    case CMDID_PSIZE_B5:
        lpnp->pszSheetSetting[4] = P1_B5;
        break;

    case CMDID_PSIZE_POSTCARD:
        lpnp->pszSheetSetting[4] = P1_POSTCARD;
        break;

    case CMDID_PSOURCE_HOPPER:
        lpnp->pszSheetSetting[5] = P2_HOPPER;
        if ( E_FAIL == WRITESPOOLBUF(pdevobj, lpnp->pszSheetSetting, SHEET_CMDLEN)) {
            return -1;
        }
        break;

    case CMDID_PSOURCE_MANUAL:
        lpnp->pszSheetSetting[5] = P2_MANUAL;
        if ( E_FAIL == WRITESPOOLBUF(pdevobj, lpnp->pszSheetSetting, SHEET_CMDLEN)) {
            return -1;
        }
        break;

    case CMDID_MODE_COLOR:
        lpnp->iColorMode = CMDID_MODE_COLOR;
        break;

    case CMDID_MODE_MONO:
        lpnp->iColorMode = CMDID_MODE_MONO;
        break;
   }
   return iRet;
}

/*
  HRESULT SendABSMove

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/
HRESULT SendABSMove(
PDEVOBJ pdevobj,
LPDWORD   lpdwParams)
{
    LPPCPRDATASTRUCTURE lpnp;
    WORD   len;
    BYTE   ch[100];

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    lpnp->wNumScans = (WORD)lpdwParams[1];
    lpnp->wScanWidth = (WORD)lpdwParams[2]; // already converted to byte unit in rasdd

    if((lpnp->iColor == RGB_COLOR) &&
       (lpnp->iColorMode == CMDID_MODE_COLOR))
    {
        lpnp->wScanWidth /= 3; // one of RGB byte
        lpnp->wScanBytes = (lpnp->wXpos + lpnp->wScanWidth)/8 - lpnp->wXpos/8 + 1;
        lpnp->wTopPad = lpnp->wXpos % 8;
        lpnp->wEndPad = (lpnp->wScanBytes * 8) - lpnp->wScanWidth - lpnp->wTopPad;
    } else {
        lpnp->wScanBytes = lpnp->wScanWidth;
        lpnp->wTopPad = 0;
        lpnp->wEndPad = 0;
    }


    if (lpnp->iFirstColor == 0)
	lpnp->iFirstColor = lpnp->iColor;

    if (lpnp->iFirstColor == lpnp->iColor) {
	lpnp->wYpos += lpnp->wOldNumScans;
	lpnp->wOldNumScans = lpnp->wNumScans;
    }


    ch[0] = 0x1B; ch[1] = 0x09; ch[2] = 0;

    len = (WORD)wsprintf( &ch[3], "C%c%c%c%c%c%c%c%c",
                    LOBYTE(lpnp->wXpos/8), HIBYTE(lpnp->wXpos/8),
                    LOBYTE(lpnp->wYpos), HIBYTE(lpnp->wYpos),
                    LOBYTE(lpnp->wScanBytes), HIBYTE(lpnp->wScanBytes),
                    LOBYTE(lpnp->wNumScans), HIBYTE(lpnp->wNumScans));

    switch (lpnp->iColor)
    {
    case YELLOW:
        return( DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) );

    case MAGENTA:
        return( DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) );
        break;

    case CYAN:
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3) ){
            return E_FAIL;
        }

        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[3], ch, len+3) ) {
                return E_FAIL;
            }
        }
        break;

    case BLACK:
        if(lpnp->bComBlackMode) {
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) ) {
                return E_FAIL;
            }
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) ) {
                return E_FAIL;
            }
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3)) {
                return E_FAIL;
            }
	} else
            return( DataSpool(pdevobj, lpnp->TempFile[3], ch, len+3) );
        break;

    case RGB_COLOR:
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) ) {
            return E_FAIL;
        }
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) ) {
            return E_FAIL;
        }
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3) ) {
            return E_FAIL;
        }
        break;
    }

//    DbgPrint(DLLTEXT("SendABS(%d,%d,%d,%d)\r\n"), lpnp->wXpos, lpnp->wYpos, lpnp->wScanWidth, lpnp->wNumScans );

    return S_OK;

}

/*
  HRESULT SpoolOut

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT SpoolOut(PDEVOBJ pdevobj, FILE* pFile)
{
    int   Size, Move, Move2;
#define	BUF_SIZE 1024
    BYTE  Tmp[BUF_SIZE];

	// spooled data output

	Size = SetFilePointer(pFile, 0L, NULL, FILE_CURRENT);
        if (0xffffffff == Size) {
            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return E_FAIL;
        }

        if (0L != SetFilePointer(pFile, 0L, NULL, FILE_BEGIN)) {

            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return E_FAIL;
        }

	while(Size){
	    Move = Size > BUF_SIZE ? BUF_SIZE : Size;
            if (0 == ReadFile(pFile, Tmp, Move, &Move2, NULL)) {
                ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
                return E_FAIL;
            }
	    if ( E_FAIL == WRITESPOOLBUF(pdevobj, Tmp, Move2)) {
                return E_FAIL;
            }
	    Size -= Move2;
	}
    return S_OK;
}

/*++

Routine Description:

  This function comes up with a name for a spool file that we should be
  able to write to.

  Note: The file name returned has already been created.

Arguments:

  hPrinter - handle to the printer that we want a spool file for.

  ppwchSpoolFileName: pointer that will receive an allocated buffer
                      containing the file name to spool to.  CALLER
                      MUST FREE.  Use LocalFree().


Return Value:

  TRUE if everything goes as expected.
  FALSE if anything goes wrong.

--*/

BOOL
GetSpoolFileName(
  IN HANDLE hPrinter,
  IN OUT PWCHAR pwchSpoolPath
)
{
  PBYTE         pBuffer = NULL;
  DWORD         dwAllocSize;
  DWORD         dwNeeded;
  DWORD         dwRetval;
  HANDLE        hToken=NULL;

  //
  //  In order to find out where the spooler's directory is, we add
  //  call GetPrinterData with DefaultSpoolDirectory.
  //

  dwAllocSize = ( MAX_PATH + 1 ) * sizeof (WCHAR);

  for (;;)
  {
    pBuffer = LocalAlloc( LMEM_FIXED, dwAllocSize );

    if ( pBuffer == NULL )
    {
      ERR((DLLTEXT("LocalAlloc faild, %d\n"), GetLastError()));
      goto Failure;
    }

    if ( GetPrinterData( hPrinter,
                         SPLREG_DEFAULT_SPOOL_DIRECTORY,
                         NULL,
                         pBuffer,
                         dwAllocSize,
                         &dwNeeded ) == ERROR_SUCCESS )
    {
      break;
    }

    if ( ( dwNeeded < dwAllocSize ) ||( GetLastError() != ERROR_MORE_DATA ))
    {
      ERR((DLLTEXT("GetPrinterData failed in a non-understood way.\n")));
      goto Failure;
    }

    //
    // Free the current buffer and increase the size that we try to allocate
    // next time around.
    //

    LocalFree( pBuffer );

    dwAllocSize = dwNeeded;
  }

  hToken = RevertToPrinterSelf();

  if( !GetTempFileName( (LPWSTR)pBuffer, TEMP_NAME_PREFIX, 0, pwchSpoolPath ))
  {
      goto Failure;
  }

  //
  //  At this point, the spool file name should be done.  Free the structure
  //  we used to get the spooler temp dir and return.
  //

  LocalFree( pBuffer );

  if (NULL != hToken) {
    (VOID)ImpersonatePrinterClient(hToken);
  }

  return( TRUE );

Failure:

  //
  //  Clean up and fail.
  //
  if ( pBuffer != NULL )
  {
    LocalFree( pBuffer );
  }

  if (hToken != NULL)
  {
      (VOID)ImpersonatePrinterClient(hToken);
  }
  return( FALSE );
}

/*
  HRESULT MDP_CreateTempFile

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    LPPCPRDATASTRUCTURE pdevOEM,
    INT iPlane)
{
#if 0
    TCHAR TempDir[MAX_PATH + 1];
    INT iLength, iUniq;
    HANDLE hFile;

    if (0 == (iLength = GetTempPath(MAX_PATH, TempDir))) {
        ERR((DLLTEXT("GetTempPath failed (%d).\n"),
                GetLastError()))
        goto Error_Return;
    }
    TempDir[iLength] = __TEXT('\0');

    if (0 == (iUniq = GetTempFileName(TempDir,
            TEMP_NAME_PREFIX, 0, pdevOEM->TempName[iPlane]))) {
        ERR((DLLTEXT("GetTempFileName failed (%d).\n"),
                GetLastError()))
        goto Error_Return;
    }

#if DBG
    VERBOSE((DLLTEXT("Temp. file = %d\nPath: "), iUniq));
    if (giDebugLevel <= DBG_VERBOSE) {
        OutputDebugString(pdevOEM->TempName[iPlane]);
    }
    VERBOSE(("\n"));
#endif // DBG
#endif // #if 0

    HANDLE hToken = NULL;
    HANDLE hFile;

    if (!GetSpoolFileName(pdevobj->hPrinter, pdevOEM->TempName[iPlane])) {
        DBGPRINT(DBG_WARNING, ("GetSpoolFileName failed.\n"));
        return E_FAIL;
    }

    hToken = RevertToPrinterSelf();

    hFile = CreateFile(pdevOEM->TempName[iPlane],
            (GENERIC_READ | GENERIC_WRITE), 0, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hToken != NULL) {
        (VOID)ImpersonatePrinterClient(hToken);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        ERR((DLLTEXT("CreateFile failed.\n")))
        DeleteFile(pdevOEM->TempName[iPlane]);
        goto Error_Return;
    }

    pdevOEM->TempFile[iPlane] = hFile;

    // Normal return
    return S_OK;

Error_Return:
    pdevOEM->TempName[iPlane][0] = __TEXT('\0');
    pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;

    return E_FAIL;
}


/*
  HRESULT DataSpool

  Sending data to a specified file or spooler.
  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT
DataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;

    if (hFile != INVALID_HANDLE_VALUE) {

        pTemp = lpBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(hFile, pTemp, dwTemp, &dwTemp2, NULL)) {

                ERR((DLLTEXT("WriteFile error in CacheData %d.\n"),
                    GetLastError()));
                return E_FAIL;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
        }
        return S_OK;
    }
    else {
        if ( S_OK == WRITESPOOLBUF(pdevobj, lpBuf, dwLen) ) {
            return S_OK;
        }
    }

    return E_FAIL;
}



VOID
BPBCalc(
    PDEVOBJ pdevobj,
    PBYTE pDataBuf,
    DWORD dwLen,
    BYTE BPBCommand)
{
    DWORD i;
    LPPCPRDATASTRUCTURE lpnp;

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    switch(BPBCommand)
    {
    case BPB_CLR:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] = 0;
        break;

    case BPB_COPY:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] = pDataBuf[i];
        break;

    case BPB_AND:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] &= pDataBuf[i];
        break;

    case BPB_OR:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] |= pDataBuf[i];
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <winsplp.h> // RevertToPrinterSelf
#include <prcomoem.h>

//

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'NC82'      // NEC PR820 printer driver
#define DLLTEXT(s)      "NC82:  " s
#define OEM_VERSION      0x00010000L

#endif  // _PDEV_H

/*************  Macro   **************/
// should create temp. file on spooler directory.
#define WRITESPOOLBUF(p, b, n) \
    ((((p)->pDrvProcs->DrvWriteSpoolBuf((p), (b), (n))) == (DWORD)(n)) ? S_OK : E_FAIL)

// DATASPOOL4FG extends DataSpool function for OEMFilterGraphics
// It returns with 0 if failed.
#define DATASPOOL4FG(p, h, b, l)  \
    if ( E_FAIL == (DataSpool((p), (h), (b), (l)) )) { \
        return 0; \
    }

// DATASPOOL4CCB extends DataSpool function for OEMCommandCallBack
// It returns with -1 if failed.
#define DATASPOOL4CCB(p, h, b, l) \
    if ( E_FAIL == (DataSpool((p), (h), (b), (l)) )){ \
        return -1; \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\nc82jres.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#define BPB_SIZE 304
#define BPB_CLR  1
#define BPB_COPY 2
#define BPB_AND  3
#define BPB_OR   4

typedef struct {
    int  iColor;
    int  iFirstColor;
    int  iPlaneNumber;
    WORD wXpos;
    WORD wYpos;
    WORD wNumScans;
    WORD wOldNumScans;
    WORD wScanWidth;
    WORD wScanBytes;
    WORD wTopPad;
    WORD wEndPad;
    int  iRibbon;
    int  iColorMode;
    BOOL bComBlackMode;
    BYTE pszSheetSetting[8];
    HANDLE TempFile[4]; // Temp. file handles
    TCHAR TempName[4][MAX_PATH]; // Temp. file names
    BYTE BPBuf[BPB_SIZE]; // Black Pixel Buffer
} PCPRDATASTRUCTURE;
typedef PCPRDATASTRUCTURE FAR *LPPCPRDATASTRUCTURE;

#define SHEET_CMD_DEFAULT "\x1B\x04\x00\x45\x14\x01\x01"
#define SHEET_CMDLEN 7

#define CMDID_PSIZE_LETTER     1
#define CMDID_PSIZE_LEGAL      2
#define CMDID_PSIZE_A4         3
#define CMDID_PSIZE_A4LONG     4
#define CMDID_PSIZE_B5         5
#define CMDID_PSIZE_POSTCARD   6

#define CMDID_PSOURCE_HOPPER   10
#define CMDID_PSOURCE_MANUAL   11

#define CMDID_COLOR_YELLOW     20
#define CMDID_COLOR_MAGENTA    21
#define CMDID_COLOR_CYAN       22
#define CMDID_COLOR_BLACK      23
#define CMDID_COLOR_BLACKONLY  24
#define CMDID_COLOR_RGB        25
#define CMDID_SELECT_RESOLUTION  26
#define CMDID_MODE_COLOR       27
#define CMDID_MODE_MONO        28

#define CMDID_X_ABS_MOVE      30
#define CMDID_Y_ABS_MOVE      31

#define CMDID_RIBBON_MONO           40
#define CMDID_RIBBON_3COLOR_A4      41
#define CMDID_RIBBON_4COLOR_A4      42
#define CMDID_RIBBON_4COLOR_A4LONG  43
#define CMDID_RIBBON_3COLOR_KAICHO  44
#define CMDID_RIBBON_3COLOR_SHOKA   45

#define CMDID_BEGINPAGE        50
#define CMDID_ENDPAGE          51

#define P1_LETTER              0x02
#define P1_LEGAL               0x03
#define P1_A4                  0x14
#define P1_A4LONG              0x18
#define P1_B5                  0x25
#define P1_POSTCARD            0x01

#define P2_HOPPER              0x01
#define P2_MANUAL              0xff

#define P3_PORTRAIT            0x01

#define YELLOW                 1
#define MAGENTA                2
#define CYAN                   3
#define BLACK                  4
#define RGB_COLOR              5

#define TEMP_NAME_PREFIX __TEXT("~82")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}

#if 0
BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nc82jres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=nc82jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),nc82jres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    $(SRCDIR)\nc82jres.rc \
    $(SRCDIR)\common.c    \
    $(SRCDIR)\nc82jres.c

MISCFILES=\
    $(SRCDIR)\nc82jres.ini \
    $(GPDDIR)\nc82mj.gpd \
    $(GPDDIR)\nc823j.gpd \
    $(GPDDIR)\nc824j.gpd \
    $(GPDDIR)\nc82fj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (OEMFilterGraphics(pdevobj, pBuf, dwLen) <= 0) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
//     "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#ifdef __cplusplus
extern "C" {
#endif // cplusplus

#include <minidrv.h>
#include <stdio.h>

#ifdef __cplusplus
}
#endif // cplusplus

#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L

#if 0
////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD   wRes;            // resolution / MasterUnit
    WORD   wScale;          // The magnification of the font
    LONG   lPointsx;        // font width
    LONG   lPointsy;        // font height
    DWORD  dwSBCSX;         // temp
    DWORD  dwDBCSX;         // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD   fGeneral;       // general flag
    WORD   wCurrentAddMode; // draw mode
    PBYTE pCompBuf;         // buffer for compression
    DWORD dwCompBufLen;     // line buffer
    DWORD dwScanLen;        // bitmap width
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
    UINT  iGray;            // rect fill gray scale
    UINT  cSubPath;         // sub path counter max is 500
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define MAX_SUBPATH 500

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
#define FG_PLUS     0x00000010

#ifdef BYPASS
#define FG_NO_COMP  0x00000020
#endif // BYPASS

// #278517: RectFill
#define FG_GMINIT   0x00000040

// Flags for Draw Mode
#define FLAG_RASTER 0   //
#define FLAG_SBCS   1   // FSa SBCS - FSR
#define FLAG_DBCS   2   // FSa DBCS - FSR
#define FLAG_VECTOR 3   // FSY - FSZ

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
#endif

#endif  // _PDEV_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\ncb2jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/


#include "pdev.h"

#define WriteSpoolBuf(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

//
// For debugging.
//

//#define DBG_OUTPUTCHARSTR 1

//
// Files necessary for OEM plug-in.
//


//------------------------------------------------------------------
// define 
//------------------------------------------------------------------
#define N   4096
#define F     18
#define NIL    N

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
PDEVOBJ lpdv,
PBYTE lpBuf,
DWORD wLen)
{
    DWORD v;//sorce buffer read pointer
    DWORD len2;//compress buffer length
    DWORD y,ku,ct;
    HANDLE hTemp;//get mem hundle
    LPSTR lpTemp;//write pointer
    LPSTR lpStart;//start pointer
    int  i, r, s, lastmatchlen, j,len;
     unsigned char code[17], mask,escJ[4],c;
    unsigned long int work;
    int  qq;
    unsigned char text[4113];             // text buffer
    int dad[4097], lson[4097], rson[4353];      // tree
    int matchpos, matchlen;

    int x, p, cmp,dummy;
    unsigned char *key;

    WORD length,outcount,codeptr;
    length = 0;
    outcount = 0;

    {
    char j;
    BYTE d;
    for(v=0 ; v<wLen ; v++)
    {
        for(d=j=0 ; j<8 ; j++)
        {
            d = ((*(lpBuf+v) << j) & 0x80) | (d >> 1);
        }
        *(lpBuf+v) = d;
    }
    }

    lpStart = EngAllocMem(0,wLen+11,'cenD');
    lpTemp = lpStart;

    ct = 0;
    ku = 1000;
    len2 = wLen / 3;
    for( j=0;j<4;j++){
        for( y=1;y<11;y++){
            if( len2 < y*ku ){
                escJ[ct] =(unsigned char) (0x30 + (y-1));
                len2 -= (y-1)*ku;
                ct ++;
                ku = ku /10;
                break;
            }
        }
    }
    if(wLen < 200 ){                                    // no compress
no_comp:
        if( lpStart != NULL ){
            *lpStart = 0x4a;                                    // J
            for(i=0;i<4;i++){
                *(lpStart+(i+1)) = escJ[i];                    // Parameter
            }
            outcount = 5;
            WriteSpoolBuf(lpdv, lpStart, outcount);

            WriteSpoolBuf(lpdv, lpBuf, wLen);

            EngFreeMem(lpStart);
        }
//      EngFreeMem(lpStart);
        return(wLen);
    }

    lpTemp += 11;                        // address update


    for (i = 4097; i <= 4352; i++) rson[i] = NIL;    // tree inital
    for (i = 0; i < 4096; i++) dad[i] = NIL;


    code[0] = 0;  codeptr = mask = 1;
    s = 0;  r = 4078;
    for (i = s; i < r; i++) text[i] = 0;      // buffer inital
    for (len = 0; len < 18 ; len++) {

        c = *(lpBuf + length);
        length ++;

        if (length > wLen ) break;
        text[r + len] = c;
    }

    for (i = 1; i <= 18; i++){
//--- insert_node(r - i);
        cmp = 1;  key = &text[r-i];  p = 4097 + key[0];
        rson[r-i] = lson[r-i] = NIL;  matchlen = 0;
        for ( ; ; ) {
            if (cmp >= 0) {
                if (rson[p] != NIL) p = rson[p];
                else {  rson[p] = (r-i);  dad[r-i] = p;  goto down1;  }
            } else {
                if (lson[p] != NIL) p = lson[p];
                else {  lson[p] = (r-i);  dad[r-i] = p;  goto down1;  }
            }
            for (x = 1; x < 18; x++)
                if ((cmp = key[x] - text[p + x]) != 0)  break;
            if (x > matchlen) {
                matchpos = p;
                if ((matchlen = x) >= 18)  break;
            }
        }
        dad[r-i] = dad[p];  lson[r-i] = lson[p];  rson[r-i] = rson[p];
        dad[lson[p]] = (r-i);  dad[rson[p]] = (r-i);
        if (rson[dad[p]] == p) rson[dad[p]] = (r-i);
        else                   lson[dad[p]] = (r-i);
        dad[p] = NIL;                  // p
down1:
        ; // dummy = dummy; // MSKK:10/10/2000
//--- insert_node end
    }
//--- insert_node(r);

    cmp = 1;  key = &text[r];  p = 4097 + key[0];
    rson[r] = lson[r] = NIL;  matchlen = 0;
    for ( ; ; ) {
        if (cmp >= 0) {
            if (rson[p] != NIL) p = rson[p];
            else {  rson[p] = r;  dad[r] = p;  goto down2;  }
        } else {
            if (lson[p] != NIL) p = lson[p];
            else {  lson[p] = r;  dad[r] = p;  goto down2;  }
        }
        for (x = 1; x < 18; x++)
            if ((cmp = key[x] - text[p + x]) != 0)  break;
        if (x > matchlen) {
            matchpos = p;
            if ((matchlen = x) >= 18)  break;
        }
    }
    dad[r] = dad[p];  lson[r] = lson[p];  rson[r] = rson[p];
    dad[lson[p]] = r;  dad[rson[p]] = r;
    if (rson[dad[p]] == p) rson[dad[p]] = r;
    else                   lson[dad[p]] = r;
    dad[p] = NIL;                  // p
down2:
//---insrt_node end

    do {
        if (matchlen > len) matchlen = len;
        if (matchlen < 3) {
            matchlen = 1;  code[0] |= mask;  code[codeptr++] = text[r];
        } else {
            code[codeptr++] = (unsigned char) matchpos;
            code[codeptr++] = (unsigned char)
                (((matchpos >> 4) & 0xf0) | (matchlen - 3));
        }
        if ((mask <<= 1) == 0) {
            outcount += codeptr;
            //compress data > original data
            if(outcount >= wLen)
                goto no_comp;
            for (i = 0; i < codeptr; i++){
                 *lpTemp = code[i];
                lpTemp++;
            }
            code[0] = 0;  codeptr = mask = 1;
        }
        lastmatchlen = matchlen;
        for (i = 0; i < lastmatchlen; i++) {
            c = *(lpBuf + length);
            length ++;
            if (length > wLen ) break;
//            delete_node(s);
//---------------
            if (dad[s] != NIL){
                if (rson[s] == NIL) qq = lson[s];
                else if (lson[s] == NIL) qq = rson[s];
                else {
                    qq = lson[s];
                    if (rson[qq] != NIL) {
                        do {  qq = rson[qq];  } while (rson[qq] != NIL);
                        rson[dad[qq]] = lson[qq];  dad[lson[qq]] = dad[qq];
                        lson[qq] = lson[s];  dad[lson[s]] = qq;
                    }
                    rson[qq] = rson[s];  dad[rson[s]] = qq;
                }
                dad[qq] = dad[s];
                if (rson[dad[s]] == s) rson[dad[s]] = qq;
                else                   lson[dad[s]] = qq;
                dad[s] = NIL;
            }
//-------------
            text[s] = c;
            if (s < 17) text[s + 4096] = c;
            s = (s + 1) & 4095;  r = (r + 1) & 4095;
//---        insert_node(r);
            cmp = 1;  key = &text[r];  p = 4097 + key[0];
            rson[r] = lson[r] = NIL;  matchlen = 0;
            for ( ; ; ) {
                if (cmp >= 0) {
                    if (rson[p] != NIL) p = rson[p];
                    else {  rson[p] = r;  dad[r] = p;  goto down3;  }
                } else {
                    if (lson[p] != NIL) p = lson[p];
                    else {  lson[p] = r;  dad[r] = p;  goto down3;  }
                }
                for (x = 1; x < 18; x++)
                    if ((cmp = key[x] - text[p + x]) != 0)  break;
                if (x > matchlen) {
                    matchpos = p;
                    if ((matchlen = x) >= 18)  break;
                }
            }
            dad[r] = dad[p];  lson[r] = lson[p];  rson[r] = rson[p];
            dad[lson[p]] = r;  dad[rson[p]] = r;
            if (rson[dad[p]] == p) rson[dad[p]] = r;
            else                   lson[dad[p]] = r;
            dad[p] = NIL;                  // p
down3:
//--- insert_node end
        dummy = dummy;
        }
        while (i++ < lastmatchlen) {
//            delete_node(s);
//---------------
            if (dad[s] != NIL){
                if (rson[s] == NIL) qq = lson[s];
                else if (lson[s] == NIL) qq = rson[s];
                else {
                    qq = lson[s];
                    if (rson[qq] != NIL) {
                        do {  qq = rson[qq];  } while (rson[qq] != NIL);
                        rson[dad[qq]] = lson[qq];  dad[lson[qq]] = dad[qq];
                        lson[qq] = lson[s];  dad[lson[s]] = qq;
                    }
                    rson[qq] = rson[s];  dad[rson[s]] = qq;
                }
                dad[qq] = dad[s];
                if (rson[dad[s]] == s) rson[dad[s]] = qq;
                else                   lson[dad[s]] = qq;
                dad[s] = NIL;
            }
//-------------

            s = (s + 1) & (4095);  r = (r + 1) & (4095);
            if (--len){
//--- insert_node(r);

                cmp = 1;  key = &text[r];  p = 4097 + key[0];
                rson[r] = lson[r] = NIL;  matchlen = 0;
                for ( ; ; ) {
                    if (cmp >= 0) {
                        if (rson[p] != NIL) p = rson[p];
                        else {  rson[p] = r;  dad[r] = p;  goto down4;  }
                    } else {
                        if (lson[p] != NIL) p = lson[p];
                        else {  lson[p] = r;  dad[r] = p;  goto down4;  }
                    }
                    for (x = 1; x < 18; x++)
                        if ((cmp = key[x] - text[p + x]) != 0)  break;
                    if (x > matchlen) {
                        matchpos = p;
                        if ((matchlen = x) >= 18)  break;
                    }
                }
                dad[r] = dad[p];  lson[r] = lson[p];  rson[r] = rson[p];
                dad[lson[p]] = r;  dad[rson[p]] = r;
                if (rson[dad[p]] == p) rson[dad[p]] = r;
                else                   lson[dad[p]] = r;
                dad[p] = NIL;                  // p
down4:
                dummy = dummy;
//--- insert_node end
            }
        }
    } while (len > 0);

    if (codeptr > 1) {
        outcount += codeptr;
        //compress data > orignal data 
        if(outcount >= wLen)
            goto no_comp;
        for (i = 0; i < codeptr; i++){
             *lpTemp = code[i];
            lpTemp++;
        }
    }
    //compress data sousin
        lpTemp = lpStart;
// 1999 04.22
    ct = 1;
    ku = 1000;
    work = outcount;
    for( j=0;j<4;j++){
        for( y=1;y<11;y++){                                    // 1000
            if( work < (unsigned long int)y*ku ){
                *(lpTemp + ct ) =(unsigned char) (0x30+(y-1));
                work -= (y-1)*ku;
                ct ++;
                ku = ku /10;
                break;
            }
        }
    }
    *lpTemp = 0x7a;
    *(lpTemp+5) =0x2c;
    for(i=6;i<10;i++){
        *(lpTemp+i) = escJ[i-6];
    }
    *(lpTemp+10) = 0x2e;

    outcount += 11;

// 1999.04.22

       WriteSpoolBuf(lpdv, lpTemp, outcount);
    //mem free
    EngFreeMem(lpTemp);
    return(wLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\sources.inc ===
ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=ncb2jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLBASE=0x8000000

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncb2jres.rc \
    $(SRCDIR)\ncb2jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncb2jres.ini \
    $(GPDDIR)\ncb168j.gpd \
    $(GPDDIR)\ncb160j.gpd \
    $(SRCDIR)\hlp\ncb2jres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\hlp\ncb2jres.h ===
/* KANJI CODE */
/*#define POP_75_PQUALITIESNEW         7560
#define POP_75_KANJICODE             7570
#define POP_75_PDENSITY              7571
*/
#define POP_70_YOUSIHOUKOU           7560
#define POP_70_YOUSIHOUKOU2          7590
#define POP_70_KANJICODE             7570


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (!OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD   wRes;            // resolution / MasterUnit
    WORD   wScale;          // The magnification of the font
    LONG   lPointsx;        // font width
    LONG   lPointsy;        // font height
    DWORD  dwSBCSX;         // temp
    DWORD  dwDBCSX;         // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD   fGeneral;       // general flag
    WORD   wCurrentAddMode; // draw mode
    PBYTE pCompBuf;         // buffer for compression
    DWORD dwCompBufLen;     // line buffer
    DWORD dwScanLen;        // bitmap width
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
    UINT  iGray;            // rect fill gray scale
    UINT  cSubPath;         // sub path counter max is 500
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define MAX_SUBPATH 500

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
#define FG_PLUS     0x00000010

#ifdef BYPASS
#define FG_NO_COMP  0x00000020
#endif // BYPASS

// #278517: RectFill
#define FG_GMINIT   0x00000040

// Flags for Draw Mode
#define FLAG_RASTER 0   //
#define FLAG_SBCS   1   // FSa SBCS - FSR
#define FLAG_DBCS   2   // FSa DBCS - FSR
#define FLAG_VECTOR 3   // FSY - FSZ

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\ncdljres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// Misc definitions and declarations.
//

#define ALLOCMEM EngAllocMem
#define FREEMEM EngFreeMem

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// For debugging.
//

//#define DBG_OUTPUTCHARSTR 1

// INT giDebugLevel = DBG_VERBOSE; // MSKK:10/5/2000
//
// command callback ID's
//

#define CMD_MOVE_X                  23
#define CMD_MOVE_Y                  24
#define CMD_BEGIN_RASTER            26
#define CMD_RES_600                 27
#define CMD_RES_400                 28
#define CMD_RES_240                 29
#define CMD_SEND_BLOCK_DATA         30
#define CMD_BEGIN_RASTER_NO_COMP    31
#define CMD_INIT_COORDINATE         32
#define CMD_PC_PRN_DIRECTION        50
#define CMD_CR                      51
#define CMD_FF                      52

// #278517: RectFill
#define CMD_RECTWIDTH               60
#define CMD_RECTHEIGHT              61
#define CMD_RECTWHITE               62
#define CMD_RECTBLACK               63
#define CMD_RECTGRAY                64

// MW2250H, MW2300
#define CMD_RES_1200                70

// Text color
#define CMD_WHITE_ON                80
#define CMD_WHITE_OFF               81

// Font Attrib
#define CMD_BOLD_ON                 82
#define CMD_ITALIC_ON               83
#define CMD_CLEAR_ATTRIB            84
#define CMD_CLEAR_ATTRIB_P          85

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->pCompBuf = NULL;
    pOEMExtra->dwCompBufLen = 0;
    pOEMExtra->dwScanLen = 0;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;
    pOEMExtra->iGray = 0;
    pOEMExtra->cSubPath = 0;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->wScale = pdmIn->wScale;
        pdmOut->lPointsx = pdmIn->lPointsx;
        pdmOut->lPointsy = pdmIn->lPointsy;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }

    return TRUE;
}

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

//-----------------------------------------------------------------------------
//
//  Function:   IsDBCSLeadByteNPDL
//
//  Description:  if the caracter is DBCS we return 1
//-----------------------------------------------------------------------------
BYTE IsDBCSLeadByteNPDL(
BYTE Ch)
{
    return ShiftJis[Ch];
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;
    return rLen;
}

//------------------------------------------------------------------
// RLE1
// Action : compress image data with RLE1
//------------------------------------------------------------------
DWORD RLE1(
PBYTE pDst,
PBYTE pSrc,
DWORD   dwLen)
{
    PBYTE pTemp, pEnd, pDsto;
    DWORD   len, deflen;

    pDsto = pDst;
    pEnd = pSrc + dwLen;

    while(pSrc < pEnd)
    {
        pTemp = pSrc++;

        if(pSrc == pEnd)
        {
            *pDst++ = 0x41;
            *pDst++ = *pTemp;
            break;
        }

        if(*pTemp == *pSrc)
        {
            pSrc++;

            while(pSrc < pEnd && *pTemp == *pSrc) pSrc++;

            len = (DWORD)(pSrc - pTemp);

            if(len < 63)
            {
                *pDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *pDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *pDst++ = 0xff;
                len -= 255;
            }

            *pDst++ = (BYTE)len;
T1:
            *pDst++ = *pTemp;
            continue;
        }

        pSrc++;

        while(pSrc < pEnd)
        {
            if(*pSrc == *(pSrc - 1))
            {
                pSrc--;
                break;
            }

            pSrc++;
        }

        deflen = len = (DWORD)(pSrc - pTemp);

        if(len < 63)
        {
            *pDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *pDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *pDst++ = 0xff;
            len -= 255;
        }

        *pDst++ = (BYTE)len;
T2:
        memcpy(pDst, pTemp, deflen);
        pDst += deflen;
    }

    return (DWORD)(pDst - pDsto);
}


//------------------------------------------------------------------
// RLC2Comp
// Action : compress image data with RLE2
//------------------------------------------------------------------
DWORD
RLC2Comp(
    PBYTE pOutBuf,
    PBYTE pInBuf,
    DWORD dwInLen,
    DWORD dwScanLen
    )
{
    DWORD     dwlen, dwDatalen, dwCounter;
    PBYTE     pLBuff;
    PBYTE     pBuff, pTemp, pBuffo, pEnd;
    PBYTE     pBuff2, pBuff2o;

VERBOSE(("RLC2Comp() In +++\r\n"));

    dwCounter = dwInLen / dwScanLen;
    pLBuff = pBuffo = pBuff = pTemp = pInBuf;    // Copy Src first pointer
    pBuff2o = pBuff2 = pOutBuf;                  // Copy Dst first pointer

    /*
     * We compare contents of First line with 0x00
     */
    pEnd = pBuff + dwScanLen;

    while(pBuff < pEnd)
    {
        while(pBuff < pEnd && 0x00 != *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen)
        {
            pBuff2 += RLE1(pBuff2, pTemp, dwlen);
            pTemp = pBuff;
        }

        if(pBuff == pEnd) break;

        while(pBuff < pEnd && 0x00 == *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen < 63)
        {
            *pBuff2++ = (BYTE)dwlen;
            goto T1;
        }

        *pBuff2++ = 0x3f;
        dwlen -= 63;

        while(dwlen >= 255)
        {
            *pBuff2++ = (BYTE)0xff;
            dwlen -= 255;
        }

        *pBuff2++ = (BYTE)dwlen;
T1:
        pTemp = pBuff;
    }

    dwCounter--;

    *pBuff2++ = (BYTE)0x80;
    dwDatalen = (DWORD)(pBuff2 - pBuff2o);

    // If the compressed bitmap size is larger than nomal bitmap size,
    // we don't compress
    if(dwDatalen > dwInLen)
    {
VERBOSE(("goto NO_COMP\r\n"));
        goto NO_COMP;
    }

    if(!dwCounter)
        return dwDatalen;

    /*
     * We compare the 1 previous line with the present line
     */
    do
    {
        pEnd = pBuff + dwScanLen;

        while(pBuff < pEnd)
        {
            while(pBuff < pEnd && *pLBuff != *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen)
            {
                pBuff2 += RLE1(pBuff2, pTemp, dwlen);
                pTemp = pBuff;
            }

            if(pBuff == pEnd) break;

            while(pBuff < pEnd && *pLBuff == *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen < 63)
            {
                *pBuff2++ = (BYTE)dwlen;
                goto T2;
            }

            *pBuff2++ = 0x3f;
            dwlen -= 63;

            while(dwlen >= 255)
            {
                *pBuff2++ = (BYTE)0xff;
                dwlen -= 255;
            }

            *pBuff2++ = (BYTE)dwlen;
T2:
            pTemp = pBuff;
        }

        *pBuff2++ = (BYTE)0x80;
        dwDatalen = (DWORD)(pBuff2 - pBuff2o);

        // If the compressed bitmap size is larger than nomal bitmap size,
        // we don't compress
        if(dwDatalen > dwInLen)  // full buffer
        {
VERBOSE(("goto NO_COMP\r\n"));
            goto NO_COMP;
        }
    }
    while(--dwCounter);

VERBOSE(("RLC2Comp() COMP Out---\r\n\r\n"));
    return dwDatalen;

NO_COMP:

VERBOSE(("RLC2Comp() NO_COMP Out---\r\n\r\n"));
    return 0;
}

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    )
{
    POEMUD_EXTRADATA    pOEM;
    INT         i;
    BYTE            Cmd[128];
    PBYTE pOutBuf;
    DWORD dwOutLen;
    BYTE jCompMethod;

VERBOSE(("OEMFilterGraphics() In +++++++++++++++++++++++++++++\r\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    // Sanity check.

    if (!pBuf || pOEM->dwScanLen == 0) {
        ERR(("Invalid parameter.\r\n"));
        return FALSE;
    }

    // Prepare temp. buffer for compression.

#ifdef BYPASS
    if ((!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) &&
        !(pOEM->fGeneral & FG_NO_COMP)){
#else
    if (!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) {
#endif // BYPASS

        if (pOEM->pCompBuf) {
            FREEMEM(pOEM->pCompBuf);
        }

        pOEM->pCompBuf = ALLOCMEM(0,
                          (dwLen << 1) + (dwLen / pOEM->dwScanLen),
                          (ULONG)'NCDL');
        pOEM->dwCompBufLen = dwLen;
    }

    // Try compression methods.

    dwOutLen = 0;
    if (pOEM->pCompBuf != NULL) {

        pOutBuf = pOEM->pCompBuf;

        // Try RLC2 method;
        if (dwOutLen == 0) {
            if ((dwOutLen = RLC2Comp(pOutBuf, pBuf,
                                      dwLen, pOEM->dwScanLen)) > 0)
                jCompMethod = '5';
        }
    }

    if (dwOutLen == 0) {

        // Any of the Compression menthod faild.
        // We will send data to the printer withtout
        // compression.

        pOutBuf = pBuf;
        dwOutLen = dwLen;
        jCompMethod = '0';  // Without compression.
    }

    /* Send a draw coordinate command to the printer. */
    i = 0;
    i += memcopy(&Cmd[i], "\034e", 2);
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
    Cmd[i++] = '.';

    /* Save the present coordinate. */
    pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
    pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

    /* Send an image data draw command. */
    i += memcopy(&Cmd[i], "\034i", 2);
    i += iDwtoA(&Cmd[i], (pOEM->dwScanLen << 3));
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (dwLen / pOEM->dwScanLen));
    Cmd[i++] = ',';
    Cmd[i++] = jCompMethod;
    i += memcopy(&Cmd[i], ",1/1,1/1,", 9);
    i += iDwtoA(&Cmd[i], dwOutLen);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (MASTER_UNIT / pOEM->wRes));
    Cmd[i++] = '.';
    WRITESPOOLBUF(pdevobj, Cmd, i);

    /* Send an image data */
    WRITESPOOLBUF(pdevobj, pOutBuf, dwOutLen);
VERBOSE(("OEMFilterGraphics() Out-------------------------------\r\n\r\n"));

    return TRUE;

}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;
    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;
    UINT gray;

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

    /*
     * There are four kinds of draw modes of this driver.When entering a
     * new draw mode, it send the commands which ends the previous draw mode
     * at the same time.
     * 1.FLAG_RASTER - raster image mode.The condition not to enter
     *                 a vector mode and a text mode.
     *                 Default condition is RASTER in this driver
     * 2.FLAG_SBCS   - single byte text mode. IN: FSa, OUT:FSR
     * 3.FLAG_DBCS   - double byte text mode. IN: FSa, OUT:FSR
     * 4.FLAG_VECTOR - vector mode.  IN: FSY, OUT:FSZ
     */
     switch (dwCmdCbID) {

    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

        if (dwCount < 4)
            return 0;      // cannot do anything

        pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
                (MASTER_UNIT / PARAM(pdwParams, 2));
        pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
                (MASTER_UNIT / PARAM(pdwParams, 3));

        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

// MW2250H, MW2300
    case CMD_RES_1200:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/1200,i.\x1CYSC;SU1,1200,0;PM1,1;SG0;\x1CZ", 39);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 1200;
        break;

    case CMD_RES_600:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/600,i.\x1CYSC;SU1,600,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 600;
        break;

    case CMD_RES_400:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/400,i.\x1CYSC;SU1,400,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 400;
        break;

    case CMD_RES_240:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/240,i.\x1CYSC;SU1,240,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;
        break;

    case CMD_BEGIN_RASTER:

        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_SEND_BLOCK_DATA:

        // Rememter length of the scan line.

        pOEM->dwScanLen = PARAM(pdwParams, 0);
        break;

#ifdef BYPASS
    case CMD_BEGIN_RASTER_NO_COMP:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        pOEM->fGeneral |= FG_NO_COMP;
        break;

#endif // BYPASS

    case CMD_PC_PRN_DIRECTION:
        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_FF:

        i = 0;
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i += memcopy(&Cmd[i], "EP;FL;\x1CZ\x0D\x0C", 10);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x0D\x0C", 4);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else{
            i += memcopy(&Cmd[i], "\x0D\x0C", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_INIT_COORDINATE:
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = FLAG_RASTER;
        pOEM->cSubPath = 0;

        break;

    case CMD_WHITE_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"R.\034$100.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_WHITE_OFF:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"O.\034$0.", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_BOLD_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,1.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_ITALIC_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,2.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB_P:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0,80.", 9);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_RECTWIDTH:
        pOEM->dwRectWidth = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTHEIGHT:
        pOEM->dwRectHeight = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTWHITE:
        gray = 100;
        goto fill;
    case CMD_RECTBLACK:
        gray = 0;
        goto fill;
    case CMD_RECTGRAY:
        gray = 100 - PARAM(pdwParams, 0);
        goto fill;

    fill:
        {
        // if rectangle size is zeor,we do not draw.
        if(pOEM->dwRectWidth - 1 < 1 && pOEM->dwRectHeight - 1 < 1)
            break;

        i = 0;
        /* Raster mode -> Vector mode in */
        if (pOEM->wCurrentAddMode == FLAG_RASTER){
            i += memcopy(&Cmd[i], "\x1CY", 2);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
    }
        /* Text mode -> Vector mode in */
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x1CY", 4);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        /* Already Vector mode and gray scale changed  or
           sub path count is over 500 */
        if(pOEM->iGray != gray){
            i += memcopy(&Cmd[i], "EP;FL;SG", 8);
            i += iDwtoA(&Cmd[i], gray);
            i += memcopy(&Cmd[i], ";NP;", 4);
            pOEM->iGray = gray;
            pOEM->cSubPath = 0;
        }
        else if(pOEM->cSubPath >= MAX_SUBPATH){
            i += memcopy(&Cmd[i], "EP;FL;", 6);
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        i += memcopy(&Cmd[i], "MA", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        i += memcopy(&Cmd[i], ";PR", 3);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0,0,", 5);
        i += iDwtoA(&Cmd[i], pOEM->dwRectHeight - 1);
        i += memcopy(&Cmd[i], ",-", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0;CP;", 6);
        pOEM->cSubPath+=4;   // rect is built by 4 line

        // some model have to close pass when rect width or height under 1
//        if(pOEM->dwRectWidth - 1 < 1 || pOEM->dwRectHeight - 1 < 1)
        pOEM->cSubPath = MAX_SUBPATH;

        /* send RectFill command */
        WRITESPOOLBUF(pdevobj, Cmd, i);
        }

        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4]; // it means dwSize + dwNumOfVariable +
                                       // (dwStdVarID + lStdVariable) * n
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    POEMUD_EXTRADATA    pOEM;
    DWORD   tmpPointsx, tmpPointsy;
    PIFIMETRICS pIFI;
    DWORD       dwNeeded;
    DWORD       dwCount;
    BOOL        bFound = FALSE;

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return;
    }
    pubCmd = pFInv->pubCommand;
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    tmpPointsy = pSV->StdVar[0].lStdVariable * 720 / pSV->StdVar[2].lStdVariable;
    dwIn = dwOut = 0;

    /* vector mode ends.*/
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        dwOut += memcopy(&aubCmd[dwOut], "EP;FL;\034Z", 8);
    }

    /* make font select command */
    while(dwCount--)
    {
        if(pubCmd[dwIn] !='#'){
            aubCmd[dwOut] = pubCmd[dwIn];
            dwOut++;
            dwIn++;
        }
        else{
            bFound = TRUE;
            break;
        }
    }

    if(bFound == TRUE)
        dwIn++;
    else
        return;   // mismatch font command

    pOEM->fGeneral &= ~(FG_VERT | FG_PLUS | FG_DBCS);

    switch(pubCmd[dwIn])
    {
    case 'O':                 // for OCR-B Font support
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsy = tmpPointsx = 120 * pOEM->wRes;  // Only 12pt
        break;

    case 'R':                 // NPDL2P SBCS
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'P':                // NPDL2 SBCS
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'W':                // NPDL2 DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'Q':
        pOEM->fGeneral |= FG_DBCS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'Y':                // NPDL2P DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'S':
        pOEM->fGeneral |= (FG_PLUS | FG_DBCS);
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;
    }

    if(pOEM->fGeneral & FG_PLUS)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        pOEM->wScale = tmpPointsx == tmpPointsy;
        pOEM->lPointsx = tmpPointsx;
        pOEM->lPointsy = tmpPointsy;

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale){
                aubCmd[dwOut++] = '\034';
                dwOut += memcopy(&aubCmd[dwOut], "12S2-", 5);
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsy / pOEM->wRes, 4);
                aubCmd[dwOut++] = '-';
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsx / pOEM->wRes, 4);
            }
        }
        else{
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsx / pOEM->wRes, 4);
            aubCmd[dwOut++] = '-';
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsy / pOEM->wRes, 4);
        }
        goto SEND_COM;
    }

    pOEM->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

    pOEM->wScale = (int)(((tmpPointsx * 10) / tmpPointsy + 5) / 10);

    if(pOEM->wScale > 8) pOEM->wScale = 8;

MAKE_COM:
    dwOut += iDwtoA_FillZero(&aubCmd[dwOut], tmpPointsy / pOEM->wRes, 4);

SEND_COM:

    if(!(pOEM->fGeneral & FG_PLUS))
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale == 1)
            {
                dwOut += memcopy(&aubCmd[dwOut], "\034m1/1,1/1.", 10);
            }
        }
        else
        {
            aubCmd[dwOut++] = '\034';
            dwOut += memcopy(&aubCmd[dwOut], "m1/1,", 5);
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[pOEM->wScale], 3);
            aubCmd[dwOut++] = '.';
        }
    }
    // write spool builded command
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
    if(pOEM->fGeneral & FG_DBCS){

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }

    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = FLAG_RASTER;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE  aubBuff[256];
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;
    // Adjust baseline if font substituted from TrueType font.
    DWORD       dwYAdj;
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVar[2+2*2];
    BYTE  Cmd[256];
    int i;

    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;


    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

// #333653: Change I/F for GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        MemFree(aubBuff);
        return;
    }

    // Adjust baseline if font substituted from TrueType font.
    if (pUFObj->dwFlags & UFOFLAG_TTSUBSTITUTED) {
        pSV = (PGETINFO_STDVAR)adwStdVar;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_TEXTYRES;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                pSV->dwSize, &dwNeeded)) {
            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
            MemFree(aubBuff);
            return;
        }
        dwYAdj = (pSV->StdVar[0].lStdVariable * pIFI->fwdWinDescender /
            pIFI->fwdUnitsPerEm) / pOEM->wRes;
    } else
        dwYAdj = 0;

    /* Vector mode off */
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        i = 0;
        i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
        pOEM->wCurrentAddMode = FLAG_RASTER;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;
    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {
        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
        if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
        {
            i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
            if(pOEM->wCurrentAddMode != FLAG_DBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1",
                                             "8/1"};
                            Cmd[i++] = '\034';
                            Cmd[i++] = 'm';
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            i += memcopy(&Cmd[i], ",1/1.", 5);
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsy / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "m1/1,", 5);
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            Cmd[i++] = '.';
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                              pOEM->lPointsy / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }
// #333653: Change I/F for GETINFO_GLYPHSTRING
    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

}


VOID
APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

Return Value:

    NONE

--*/

{
    POEMUD_EXTRADATA    pOEM;

    VERBOSE(("Entering OEMDisablePDEV...\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // Free up memory allocated for the temp. buffer
    //

    if (pOEM->pCompBuf) {
        FREEMEM(pOEM->pCompBuf);
        pOEM->pCompBuf = NULL;
        pOEM->dwCompBufLen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\hlp\helpid.h ===
// HELP  Index

#define POP_DL_MARGIN                602
#define POP_DL_JOBSEPARATE           603
#define POP_DL_SET                   604
#define POP_DL_TONAR                 605
#define POP_DL_DENSITY               606
#define POP_DL_SORTER                607
#define POP_DL_OUTBIN                608
#define POP_DL_FACE                  609
#define POP_DL_KANJICODE             610

/* TextHalftoneThreshold */
#define POP_DL_TEXTHALFTONE          611
#define POP_DL_TEXTHALFTONE_S        612
#define POP_DL_TEXTHALFTONE_S2       613
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..
HLPDIR=$(SRCDIR)\hlp

TARGETNAME=ncdljres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
COFFBASE=ncdljres
!ELSE
COFFBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncdljres.rc \
    $(SRCDIR)\ncdljres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncdljres.ini \
    $(GPDDIR)\ncdl104j.gpd \
    $(GPDDIR)\ncdl125j.gpd \
    $(GPDDIR)\ncdl14rj.gpd \
    $(GPDDIR)\ncdl14wj.gpd \
    $(GPDDIR)\ncdl14xj.gpd \
    $(GPDDIR)\ncdl1e4j.gpd \
    $(GPDDIR)\ncdl1ewj.gpd \
    $(GPDDIR)\ncdl1f4j.gpd \
    $(GPDDIR)\ncdl202j.gpd \
    $(GPDDIR)\ncdl204j.gpd \
    $(GPDDIR)\ncdl210j.gpd \
    $(GPDDIR)\ncdl21sj.gpd \
    $(GPDDIR)\ncdl222j.gpd \
    $(GPDDIR)\ncdl225j.gpd \
    $(GPDDIR)\ncdl22xj.gpd \
    $(GPDDIR)\ncdl230j.gpd \
    $(GPDDIR)\ncdl24j.gpd \
    $(GPDDIR)\ncdl24rj.gpd \
    $(GPDDIR)\ncdl24wj.gpd \
    $(GPDDIR)\ncdl24xj.gpd \
    $(GPDDIR)\ncdl25j.gpd \
    $(GPDDIR)\ncdl25hj.gpd \
    $(GPDDIR)\ncdl265j.gpd \
    $(GPDDIR)\ncdl26ej.gpd \
    $(GPDDIR)\ncdl26mj.gpd \
    $(GPDDIR)\ncdl26wj.gpd \
    $(GPDDIR)\ncdl2ej.gpd \
    $(GPDDIR)\ncdl2fj.gpd \
    $(GPDDIR)\ncdl2n2j.gpd \
    $(GPDDIR)\ncdl2nj.gpd \
    $(GPDDIR)\ncdl2x2j.gpd \
    $(GPDDIR)\ncdl2xej.gpd \
    $(GPDDIR)\ncdl2xj.gpd \
    $(GPDDIR)\ncdl404j.gpd \
    $(GPDDIR)\ncdl4e4j.gpd \
    $(HLPDIR)\ncdljres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (!OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncdljres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (!OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\ncmwjres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// Misc definitions and declarations.
//

#define ALLOCMEM EngAllocMem
#define FREEMEM EngFreeMem

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// For debugging.
//

//#define DBG_OUTPUTCHARSTR 1

//
// command callback ID's
//

#define CMD_MOVE_X                  23
#define CMD_MOVE_Y                  24
#define CMD_BEGIN_RASTER            26
#define CMD_RES_600                 27
#define CMD_RES_400                 28
#define CMD_RES_240                 29
#define CMD_SEND_BLOCK_DATA         30
#define CMD_BEGIN_RASTER_NO_COMP    31
#define CMD_INIT_COORDINATE         32
#define CMD_PC_PRN_DIRECTION        50
#define CMD_CR                      51
#define CMD_FF                      52
#define CMD_RES_300		    65
#define CMD_RES_200		    66
// #278517: RectFill
#define CMD_RECTWIDTH               60
#define CMD_RECTHEIGHT              61
#define CMD_RECTWHITE               62
#define CMD_RECTBLACK               63
#define CMD_RECTGRAY                64

#define CMD_DUPLEX_NONE				67
#define CMD_DUPLEX_VERTICAL			68
#define CMD_DUPLEX_HORIZONTAL		69
#define CMD_MAIN_BACK1				70
#define CMD_MAIN_BACK2				71
#define CMD_MAIN_BACK3				72
#define CMD_MAIN_BACK4				73
#define CMD_0						74
#define CMD_1						75
#define CMD_2						76
#define CMD_3						77
#define CMD_4						78
#define CMD_5						79
#define CMD_6						80
#define CMD_7						81
#define CMD_8						82
#define CMD_9						83
#define CMD_10						84
#define CMD_11						85
#define CMD_12						86
#define CMD_13						87
#define CMD_14						88
#define CMD_15						89
#define CMD_16						90
#define CMD_17						91
#define CMD_18						92
#define CMD_19						93
#define CMD_20						94
#define CMD_MAIN_BACK0				95
#define CMD_MAIN_BACK11				96
#define CMD_MAIN_BACK12				97
#define CMD_MAIN_BACK13				98
#define CMD_MAIN_BACK14				99
#define CMD_DUPLEX_A1_600			100
#define CMD_DUPLEX_A1_400			101
#define CMD_DUPLEX_A1_300			102
#define CMD_DUPLEX_A1_240			103
#define CMD_DUPLEX_A1_200			104
#define CMD_DUPLEX_A2_600			105
#define CMD_DUPLEX_A2_400			106
#define CMD_DUPLEX_A2_300			107
#define CMD_DUPLEX_A2_240			108
#define CMD_DUPLEX_A2_200			109
#define CMD_DUPLEX_A3_600			110
#define CMD_DUPLEX_A3_400			111
#define CMD_DUPLEX_A3_300			112
#define CMD_DUPLEX_A3_240			113
#define CMD_DUPLEX_A3_200			114
#define CMD_SORT_NONE				115
#define CMD_SORT_COPY				116
#define CMD_SORT_SORT				117
#define CMD_SORT_BIN				118
#define CMD_SORT_STACK				119
#define CMD_JIS_90					120
#define CMD_JIS_78					121
// Text color add. 2000.12.28
#define	CMD_WHITE_ON				130
#define CMD_WHITE_OFF				131
// Under Line add 2001.2.2
#define CMD_BOLD_ON					132
#define CMD_ITALIC_ON				133
#define CMD_CLEAR_ATTRIB_P			134
#define	CMD_ESORT_OFF				135
#define	CMD_ESORT_ON				136

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->pCompBuf = NULL;
    pOEMExtra->dwCompBufLen = 0;
    pOEMExtra->dwScanLen = 0;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;
    pOEMExtra->iGray = 0;
    pOEMExtra->cSubPath = 0;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->wScale = pdmIn->wScale;
        pdmOut->lPointsx = pdmIn->lPointsx;
        pdmOut->lPointsy = pdmIn->lPointsy;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }

    return TRUE;
}

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

//-----------------------------------------------------------------------------
//
//  Function:   IsDBCSLeadByteNPDL
//
//  Description:  if the caracter is DBCS we return 1
//-----------------------------------------------------------------------------
BYTE IsDBCSLeadByteNPDL(
BYTE Ch)
{
    return ShiftJis[Ch];
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;
    return rLen;
}
//-----------------------------------------------------------------------------
//
//  Function:   copynumber
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
void
copynumber(LPSTR lpDst, LONG wLen)
{

	LONG rLen;
	BYTE i,j;

	j = 0;
	rLen = wLen;

	if( rLen > 9 ){
		for(i=0;i<rLen;i+=10)
		{
			j++;
		}
		*lpDst = (j-1) + 0x30;
		i -= 10;
		rLen -=i;
		lpDst++;
	}
	j = (BYTE)rLen;
	*lpDst = 0x30 + j;
	return;

}
//------------------------------------------------------------------
// RLE1
// Action : compress image data with RLE1
//------------------------------------------------------------------
DWORD RLE1(
PBYTE pDst,
PBYTE pSrc,
DWORD   dwLen)
{
    PBYTE pTemp, pEnd, pDsto;
    DWORD   len, deflen;

    pDsto = pDst;
    pEnd = pSrc + dwLen;

    while(pSrc < pEnd)
    {
        pTemp = pSrc++;

        if(pSrc == pEnd)
        {
            *pDst++ = 0x41;
            *pDst++ = *pTemp;
            break;
        }

        if(*pTemp == *pSrc)
        {
            pSrc++;

            while(pSrc < pEnd && *pTemp == *pSrc) pSrc++;

            len = (DWORD)(pSrc - pTemp);

            if(len < 63)
            {
                *pDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *pDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *pDst++ = 0xff;
                len -= 255;
            }

            *pDst++ = (BYTE)len;
T1:
            *pDst++ = *pTemp;
            continue;
        }

        pSrc++;

        while(pSrc < pEnd)
        {
            if(*pSrc == *(pSrc - 1))
            {
                pSrc--;
                break;
            }

            pSrc++;
        }

        deflen = len = (DWORD)(pSrc - pTemp);

        if(len < 63)
        {
            *pDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *pDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *pDst++ = 0xff;
            len -= 255;
        }

        *pDst++ = (BYTE)len;
T2:
        memcpy(pDst, pTemp, deflen);
        pDst += deflen;
    }

    return (DWORD)(pDst - pDsto);
}


//------------------------------------------------------------------
// RLC2Comp
// Action : compress image data with RLE2
//------------------------------------------------------------------
DWORD
RLC2Comp(
    PBYTE pOutBuf,
    PBYTE pInBuf,
    DWORD dwInLen,
    DWORD dwScanLen
    )
{
    DWORD     dwlen, dwDatalen, dwCounter;
    PBYTE     pLBuff;
    PBYTE     pBuff, pTemp, pBuffo, pEnd;
    PBYTE     pBuff2, pBuff2o;

VERBOSE(("RLC2Comp() In +++\r\n"));

    dwCounter = dwInLen / dwScanLen;
    pLBuff = pBuffo = pBuff = pTemp = pInBuf;    // Copy Src first pointer
    pBuff2o = pBuff2 = pOutBuf;                  // Copy Dst first pointer

    /*
     * We compare contents of First line with 0x00
     */
    pEnd = pBuff + dwScanLen;

    while(pBuff < pEnd)
    {
        while(pBuff < pEnd && 0x00 != *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen)
        {
            pBuff2 += RLE1(pBuff2, pTemp, dwlen);
            pTemp = pBuff;
        }

        if(pBuff == pEnd) break;

        while(pBuff < pEnd && 0x00 == *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen < 63)
        {
            *pBuff2++ = (BYTE)dwlen;
            goto T1;
        }

        *pBuff2++ = 0x3f;
        dwlen -= 63;

        while(dwlen >= 255)
        {
            *pBuff2++ = (BYTE)0xff;
            dwlen -= 255;
        }

        *pBuff2++ = (BYTE)dwlen;
T1:
        pTemp = pBuff;
    }

    dwCounter--;

    *pBuff2++ = (BYTE)0x80;
    dwDatalen = (DWORD)(pBuff2 - pBuff2o);

    // If the compressed bitmap size is larger than nomal bitmap size,
    // we don't compress
    if(dwDatalen > dwInLen)
    {
VERBOSE(("goto NO_COMP\r\n"));
        goto NO_COMP;
    }

    if(!dwCounter)
        return dwDatalen;

    /*
     * We compare the 1 previous line with the present line
     */
    do
    {
        pEnd = pBuff + dwScanLen;

        while(pBuff < pEnd)
        {
            while(pBuff < pEnd && *pLBuff != *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen)
            {
                pBuff2 += RLE1(pBuff2, pTemp, dwlen);
                pTemp = pBuff;
            }

            if(pBuff == pEnd) break;

            while(pBuff < pEnd && *pLBuff == *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen < 63)
            {
                *pBuff2++ = (BYTE)dwlen;
                goto T2;
            }

            *pBuff2++ = 0x3f;
            dwlen -= 63;

            while(dwlen >= 255)
            {
                *pBuff2++ = (BYTE)0xff;
                dwlen -= 255;
            }

            *pBuff2++ = (BYTE)dwlen;
T2:
            pTemp = pBuff;
        }

        *pBuff2++ = (BYTE)0x80;
        dwDatalen = (DWORD)(pBuff2 - pBuff2o);

        // If the compressed bitmap size is larger than nomal bitmap size,
        // we don't compress
        if(dwDatalen > dwInLen)  // full buffer
        {
VERBOSE(("goto NO_COMP\r\n"));
            goto NO_COMP;
        }
    }
    while(--dwCounter);

VERBOSE(("RLC2Comp() COMP Out---\r\n\r\n"));
    return dwDatalen;

NO_COMP:

VERBOSE(("RLC2Comp() NO_COMP Out---\r\n\r\n"));
    return 0;
}

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    )
{
    POEMUD_EXTRADATA    pOEM;
    INT         i;
    BYTE            Cmd[128];
    PBYTE pOutBuf;
    DWORD dwOutLen;
    BYTE jCompMethod;

VERBOSE(("OEMFilterGraphics() In +++++++++++++++++++++++++++++\r\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    // Sanity check.

    if (!pBuf || pOEM->dwScanLen == 0) {
        ERR(("Invalid parameter.\r\n"));
        return FALSE;
    }

    // Prepare temp. buffer for compression.

#ifdef BYPASS
    if ((!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) &&
        !(pOEM->fGeneral & FG_NO_COMP)){
#else
    if (!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) {
#endif // BYPASS

        if (pOEM->pCompBuf) {
            FREEMEM(pOEM->pCompBuf);
        }

        pOEM->pCompBuf = ALLOCMEM(0,
                          (dwLen << 1) + (dwLen / pOEM->dwScanLen),
                          (ULONG)'NCDL');
        pOEM->dwCompBufLen = dwLen;
    }

    // Try compression methods.

    dwOutLen = 0;
    if (pOEM->pCompBuf != NULL) {

        pOutBuf = pOEM->pCompBuf;

        // Try RLC2 method;
        if (dwOutLen == 0) {
            if ((dwOutLen = RLC2Comp(pOutBuf, pBuf,
                                      dwLen, pOEM->dwScanLen)) > 0)
                jCompMethod = '5';
        }
    }

    if (dwOutLen == 0) {

        // Any of the Compression menthod faild.
        // We will send data to the printer withtout
        // compression.

        pOutBuf = pBuf;
        dwOutLen = dwLen;
        jCompMethod = '0';  // Without compression.
    }

    /* Send a draw coordinate command to the printer. */
    i = 0;
    i += memcopy(&Cmd[i], "\034e", 2);
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
    Cmd[i++] = '.';

    /* Save the present coordinate. */
    pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
    pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

    /* Send an image data draw command. */
    i += memcopy(&Cmd[i], "\034i", 2);
    i += iDwtoA(&Cmd[i], (pOEM->dwScanLen << 3));
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (dwLen / pOEM->dwScanLen));
    Cmd[i++] = ',';
    Cmd[i++] = jCompMethod;
    i += memcopy(&Cmd[i], ",1/1,1/1,", 9);
    i += iDwtoA(&Cmd[i], dwOutLen);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (MASTER_UNIT / pOEM->wRes));
    Cmd[i++] = '.';
    WRITESPOOLBUF(pdevobj, Cmd, i);

    /* Send an image data */
    WRITESPOOLBUF(pdevobj, pOutBuf, dwOutLen);
VERBOSE(("OEMFilterGraphics() Out-------------------------------\r\n\r\n"));

    return TRUE;

}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;
    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;
    UINT gray;
	LONG	copynum;
	BYTE	CopyCmd[2];

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

    /*
     * There are four kinds of draw modes of this driver.When entering a
     * new draw mode, it send the commands which ends the previous draw mode
     * at the same time.
     * 1.FLAG_RASTER - raster image mode.The condition not to enter
     *                 a vector mode and a text mode.
     *                 Default condition is RASTER in this driver
     * 2.FLAG_SBCS   - single byte text mode. IN: FSa, OUT:FSR
     * 3.FLAG_DBCS   - double byte text mode. IN: FSa, OUT:FSR
     * 4.FLAG_VECTOR - vector mode.  IN: FSY, OUT:FSZ
     */
     switch (dwCmdCbID) {

	case CMD_ESORT_OFF:
		i = 0;
        i += memcopy(&Cmd[i],"@PJL SET COLLATE=OFF\x0D\x0A",22);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->ESort_mode = 0;
		break;

	case CMD_ESORT_ON:
		i = 0;
        i += memcopy(&Cmd[i],"@PJL SET COLLATE=ON\x0D\x0A",21);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->ESort_mode = 1;
		break;

	case CMD_DUPLEX_NONE:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'S,,",5);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 0;
		break;

	case CMD_DUPLEX_VERTICAL:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'B",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 1;
		break;

	case CMD_DUPLEX_HORIZONTAL:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'B",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 2;
		break;

	case CMD_MAIN_BACK0:
		i = 0;
		pOEM->Duplex_OU = 0;
		break;

	case CMD_MAIN_BACK1:
		i = 0;
        i += memcopy(&Cmd[i], ",F,1",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 1;
		break;

	case CMD_MAIN_BACK2:
		i = 0;
        i += memcopy(&Cmd[i], ",F,2",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 2;
		break;

	case CMD_MAIN_BACK3:
		i = 0;
        i += memcopy(&Cmd[i], ",F,3",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 3;
		break;

	case CMD_MAIN_BACK4:
		i = 0;
        i += memcopy(&Cmd[i], ",F,4",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 4;
		break;

	case CMD_MAIN_BACK11:
		i = 0;
        i += memcopy(&Cmd[i], ",B,1",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 5;
		break;

	case CMD_MAIN_BACK12:
		i = 0;
        i += memcopy(&Cmd[i], ",B,2",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 6;
		break;

	case CMD_MAIN_BACK13:
		i = 0;
        i += memcopy(&Cmd[i], ",B,3",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 7;
		break;

	case CMD_MAIN_BACK14:
		i = 0;
        i += memcopy(&Cmd[i], ",B,4",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 8;
		break;

	case CMD_0:
		i = 0;
        i += memcopy(&Cmd[i], ",0.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 0;
		break;

	case CMD_1:
		i = 0;
        i += memcopy(&Cmd[i], ",1.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 1;
		break;

	case CMD_2:
		i = 0;
        i += memcopy(&Cmd[i], ",2.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 2;
		break;

	case CMD_3:
		i = 0;
        i += memcopy(&Cmd[i], ",3.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 3;
		break;

	case CMD_4:
		i = 0;
        i += memcopy(&Cmd[i], ",4.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 4;
		break;

	case CMD_5:
		i = 0;
        i += memcopy(&Cmd[i], ",5.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 4;
		break;

	case CMD_6:
		i = 0;
        i += memcopy(&Cmd[i], ",6.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 6;
		break;

	case CMD_7:
		i = 0;
        i += memcopy(&Cmd[i], ",7.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 7;
		break;

	case CMD_8:
		i = 0;
        i += memcopy(&Cmd[i], ",8.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 8;
		break;

	case CMD_9:
		i = 0;
        i += memcopy(&Cmd[i], ",9.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 9;
		break;

	case CMD_10:
		i = 0;
        i += memcopy(&Cmd[i], ",10.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 10;
		break;

	case CMD_11:
		i = 0;
        i += memcopy(&Cmd[i], ",11.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 11;
		break;

	case CMD_12:
		i = 0;
        i += memcopy(&Cmd[i], ",12.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 12;
		break;

	case CMD_13:
		i = 0;
        i += memcopy(&Cmd[i], ",13.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 13;
		break;

	case CMD_14:
		i = 0;
        i += memcopy(&Cmd[i], ",14.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 14;
		break;

	case CMD_15:
		i = 0;
        i += memcopy(&Cmd[i], ",15.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 15;
		break;

	case CMD_16:
		i = 0;
        i += memcopy(&Cmd[i], ",16.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 16;
		break;

	case CMD_17:
		i = 0;
        i += memcopy(&Cmd[i], ",17.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 17;
		break;

	case CMD_18:
		i = 0;
        i += memcopy(&Cmd[i], ",18.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 18;
		break;

	case CMD_19:
		i = 0;
        i += memcopy(&Cmd[i], ",19.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 19;
		break;

	case CMD_20:
		i = 0;
        i += memcopy(&Cmd[i], ",20.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 20;
		break;
	case CMD_SORT_NONE:
	case CMD_SORT_COPY:
	case CMD_SORT_SORT:
	case CMD_SORT_BIN:
	case CMD_SORT_STACK:
		i = 0;
		goto dup;

	case CMD_DUPLEX_A1_600:
	case CMD_DUPLEX_A2_600:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&600.\x1C\x64\x32\x34\x30.",15);
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&600.",7);
		goto dup;
	case CMD_DUPLEX_A1_400:
	case CMD_DUPLEX_A2_400:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&400.\x1C\x64\x32\x34\x30.",15);
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1 ){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&400.",7);
		goto dup;

	case CMD_DUPLEX_A1_300:
	case CMD_DUPLEX_A2_300:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&300.\x1C\x64\x32\x34\x30.",15);
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&300.",7);
		goto dup;

	case CMD_DUPLEX_A1_240:
	case CMD_DUPLEX_A2_240:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&240.\x1C\x64\x32\x34\x30.",15);
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			CopyCmd[0] = 0x31;
			copynum = 1;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&240.",7);
		goto dup;

	case CMD_DUPLEX_A1_200:
	case CMD_DUPLEX_A2_200:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&200.\x1C\x64\x32\x34\x30.",15);
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&200.",7);

		goto dup;

	case CMD_DUPLEX_A3_600:
	case CMD_DUPLEX_A3_400:
	case CMD_DUPLEX_A3_300:
	case CMD_DUPLEX_A3_240:
	case CMD_DUPLEX_A3_200:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C&0.\x1B\x63\x31",7);
		goto dup;
	case CMD_JIS_90:
	case CMD_JIS_78:
		goto dup;

	dup:
	{
		if( pOEM->Duplex_mode == 0 ){
			i += memcopy(&Cmd[i], "\x1C'S,,",5);
		}else{
	        i += memcopy(&Cmd[i], "\x1C'B",3);
		}
		if( pOEM->Duplex_OU == 1 ){
	        i += memcopy(&Cmd[i], ",F,1",4);
		}
		if( pOEM->Duplex_OU == 2 ){
	        i += memcopy(&Cmd[i], ",F,2",4);
		}
		if( pOEM->Duplex_OU == 3 ){
	        i += memcopy(&Cmd[i], ",F,3",4);
		}
		if( pOEM->Duplex_OU == 4 ){
	        i += memcopy(&Cmd[i], ",F,4",4);
		}
		if( pOEM->Duplex_OU == 5 ){
	        i += memcopy(&Cmd[i], ",B,1",4);
		}
		if( pOEM->Duplex_OU == 6 ){
	        i += memcopy(&Cmd[i], ",B,2",4);
		}
		if( pOEM->Duplex_OU == 7 ){
	        i += memcopy(&Cmd[i], ",B,3",4);
		}
		if( pOEM->Duplex_OU == 8 ){
	        i += memcopy(&Cmd[i], ",B,4",4);
		}
		if( pOEM->Margin == 0 ){
	        i += memcopy(&Cmd[i], ",0.",3);
		}
		if( pOEM->Margin == 1 ){
	        i += memcopy(&Cmd[i], ",1.",3);
		}
		if( pOEM->Margin == 2 ){
	        i += memcopy(&Cmd[i], ",2.",3);
		}
		if( pOEM->Margin == 3 ){
	        i += memcopy(&Cmd[i], ",3.",3);
		}
		if( pOEM->Margin == 4 ){
	        i += memcopy(&Cmd[i], ",4.",3);
		}
		if( pOEM->Margin == 5 ){
	        i += memcopy(&Cmd[i], ",5.",3);
		}
		if( pOEM->Margin == 6 ){
	        i += memcopy(&Cmd[i], ",6.",3);
		}
		if( pOEM->Margin == 7 ){
	        i += memcopy(&Cmd[i], ",7.",3);
		}
		if( pOEM->Margin == 8 ){
	        i += memcopy(&Cmd[i], ",8.",3);
		}
		if( pOEM->Margin == 9 ){
	        i += memcopy(&Cmd[i], ",9.",3);
		}
		if( pOEM->Margin == 10 ){
	        i += memcopy(&Cmd[i], ",10.",4);
		}
		if( pOEM->Margin == 11 ){
	        i += memcopy(&Cmd[i], ",11.",4);
		}
		if( pOEM->Margin == 12 ){
	        i += memcopy(&Cmd[i], ",12.",4);
		}
		if( pOEM->Margin == 13 ){
	        i += memcopy(&Cmd[i], ",13.",4);
		}
		if( pOEM->Margin == 14 ){
	        i += memcopy(&Cmd[i], ",14.",4);
		}
		if( pOEM->Margin == 15 ){
	        i += memcopy(&Cmd[i], ",15.",4);
		}
		if( pOEM->Margin == 16 ){
	        i += memcopy(&Cmd[i], ",16.",4);
		}
		if( pOEM->Margin == 17 ){
	        i += memcopy(&Cmd[i], ",17.",4);
		}
		if( pOEM->Margin == 18 ){
	        i += memcopy(&Cmd[i], ",18.",4);
		}
		if( pOEM->Margin == 19 ){
	        i += memcopy(&Cmd[i], ",19.",4);
		}
		if( pOEM->Margin == 20 ){
	        i += memcopy(&Cmd[i], ",20.",4);
		}
	    switch (dwCmdCbID) {
			case CMD_DUPLEX_A2_600:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&600.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_400:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&400.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_300:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&300.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_240:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&240.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_200:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&200.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A3_600:
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&600.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_400:
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&400.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_300:
		        i += memcopy(&Cmd[i], "\x1C\x78\x31.\x1C&300.\x1C\x66PAI.\x0D\x0A",18);
				break;
			case CMD_DUPLEX_A3_240:
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&240.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_200:
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&200.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_SORT_NONE:
		        i += memcopy(&Cmd[i], "\x1C\x25\x45,1",5);
				break;
			case CMD_SORT_COPY:
		        i += memcopy(&Cmd[i], "\x1C\x25\x43,1",5);
				break;
			case CMD_SORT_SORT:
		        i += memcopy(&Cmd[i], "\x1C\x25\x53,1",5);
				break;
			case CMD_SORT_BIN:
		        i += memcopy(&Cmd[i], "\x1C\x25\x42,1",5);
				break;
			case CMD_SORT_STACK:
		        i += memcopy(&Cmd[i], "\x1C\x25\x54,1",5);
				break;
			case CMD_JIS_90:
		        i += memcopy(&Cmd[i], "\x1C\x30\x35\x46\x32-\x30\x32",8);
				break;
			case CMD_JIS_78:
		        i += memcopy(&Cmd[i], "\x1C\x30\x35\x46\x32-\x30\x30",8);
				break;
		}
	    switch (dwCmdCbID) {
			case CMD_DUPLEX_A3_600:
			case CMD_DUPLEX_A3_400:
			case CMD_DUPLEX_A3_300:
			case CMD_DUPLEX_A3_240:
			case CMD_DUPLEX_A3_200:
				i += memcopy(&Cmd[i], "\x0C\x1B\x63\x31\x1B\x25-12345X@PJL EOJ\x0D\x0A@PJL ENTER LANGUAGE=DEFAULT\x0D\x0A",52);
				break;
		}
		WRITESPOOLBUF(pdevobj, Cmd, i);
		break;
	}

    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

        if (dwCount < 4)
            return 0;      // cannot do anything

        pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
                (MASTER_UNIT / PARAM(pdwParams, 2));
        pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
                (MASTER_UNIT / PARAM(pdwParams, 3));

        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

    case CMD_RES_600:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/600,i.\x1CYSC;SU1,600,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 600;
        break;

    case CMD_RES_400:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/400,i.\x1CYSC;SU1,400,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 400;
        break;

    case CMD_RES_240:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/240,i.\x1CYSC;SU1,240,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;
        break;
    case CMD_RES_300:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/300,i.\x1CYSC;SU1,300,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 300;
        break;
    case CMD_RES_200:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/200,i.\x1CYSC;SU1,200,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 200;
        break;
    case CMD_BEGIN_RASTER:

        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_SEND_BLOCK_DATA:

        // Rememter length of the scan line.

        pOEM->dwScanLen = PARAM(pdwParams, 0);
        break;

#ifdef BYPASS
    case CMD_BEGIN_RASTER_NO_COMP:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        pOEM->fGeneral |= FG_NO_COMP;
        break;

#endif // BYPASS

    case CMD_PC_PRN_DIRECTION:
        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_FF:

        i = 0;
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i += memcopy(&Cmd[i], "EP;FL;\x1CZ\x0D\x0C", 10);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x0D\x0C", 4);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else{
            i += memcopy(&Cmd[i], "\x0D\x0C", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_INIT_COORDINATE:
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = FLAG_RASTER;
        pOEM->cSubPath = 0;

        break;

    case CMD_WHITE_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"R.\034$100.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_WHITE_OFF:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"O.\034$0.", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		break;

    case CMD_BOLD_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,1.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_ITALIC_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,2.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB_P:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0,80.", 9);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_RECTWIDTH:
        pOEM->dwRectWidth = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTHEIGHT:
        pOEM->dwRectHeight = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTWHITE:
        gray = 100;
        goto fill;
    case CMD_RECTBLACK:
        gray = 0;
        goto fill;
    case CMD_RECTGRAY:
        gray = 100 - PARAM(pdwParams, 0);
        goto fill;

    fill:
        {
// add 2000.12.28
        // if rectangle size is zeor,we do not draw.
        if(pOEM->dwRectWidth - 1 < 1 && pOEM->dwRectHeight - 1 < 1)
            break;

        i = 0;
        /* Raster mode -> Vector mode in */
        if (pOEM->wCurrentAddMode == FLAG_RASTER){
            i += memcopy(&Cmd[i], "\x1CY", 2);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
    }
        /* Text mode -> Vector mode in */
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x1CY", 4);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }
/* add 2000.12.28 */
        /* Already Vector mode and gray scale changed  or
           sub path count is over 500 */
        if(pOEM->iGray != gray){
            i += memcopy(&Cmd[i], "EP;FL;SG", 8);
            i += iDwtoA(&Cmd[i], gray);
            i += memcopy(&Cmd[i], ";NP;", 4);
            pOEM->iGray = gray;
            pOEM->cSubPath = 0;
        }
        else if(pOEM->cSubPath >= MAX_SUBPATH){
            i += memcopy(&Cmd[i], "EP;FL;", 6);
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        i += memcopy(&Cmd[i], "MA", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        i += memcopy(&Cmd[i], ";PR", 3);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0,0,", 5);
        i += iDwtoA(&Cmd[i], pOEM->dwRectHeight - 1);
        i += memcopy(&Cmd[i], ",-", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0;CP;", 6);
        pOEM->cSubPath+=4;   // rect is built by 4 line

// del. 2000.12.28
        // some model have to close pass when rect width or height under 1
//      if(pOEM->dwRectWidth - 1 < 1 || pOEM->dwRectHeight - 1 < 1)
        pOEM->cSubPath = MAX_SUBPATH;

        /* send RectFill command */
        WRITESPOOLBUF(pdevobj, Cmd, i);
        }

        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4]; // it means dwSize + dwNumOfVariable +
                                       // (dwStdVarID + lStdVariable) * n
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    POEMUD_EXTRADATA    pOEM;
    DWORD   tmpPointsx, tmpPointsy;
    PIFIMETRICS pIFI;
    DWORD       dwNeeded;
    DWORD       dwCount;
    BOOL        bFound = FALSE;

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return;
    }
    pubCmd = pFInv->pubCommand;
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    tmpPointsy = pSV->StdVar[0].lStdVariable * 720 / pSV->StdVar[2].lStdVariable;
    dwIn = dwOut = 0;

    /* vector mode ends.*/
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        dwOut += memcopy(&aubCmd[dwOut], "EP;FL;\034Z", 8);
    }

    /* make font select command */
    while(dwCount--)
    {
        if(pubCmd[dwIn] !='#'){
            aubCmd[dwOut] = pubCmd[dwIn];
            dwOut++;
            dwIn++;
        }
        else{
            bFound = TRUE;
            break;
        }
    }

    if(bFound == TRUE)
        dwIn++;
    else
        return;   // mismatch font command

    pOEM->fGeneral &= ~(FG_VERT | FG_PLUS | FG_DBCS);

    switch(pubCmd[dwIn])
    {
    case 'O':                 // for OCR-B Font support
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsy = tmpPointsx = 120 * pOEM->wRes;  // Only 12pt
        break;

    case 'R':                 // NPDL2P SBCS
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'P':                // NPDL2 SBCS
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'W':                // NPDL2 DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'Q':
        pOEM->fGeneral |= FG_DBCS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'Y':                // NPDL2P DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'S':
        pOEM->fGeneral |= (FG_PLUS | FG_DBCS);
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;
    }

    if(pOEM->fGeneral & FG_PLUS)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        pOEM->wScale = tmpPointsx == tmpPointsy;
        pOEM->lPointsx = tmpPointsx;
        pOEM->lPointsy = tmpPointsy;

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale){
                aubCmd[dwOut++] = '\034';
                dwOut += memcopy(&aubCmd[dwOut], "12S2-", 5);
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsy / pOEM->wRes, 4);
                aubCmd[dwOut++] = '-';
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsx / pOEM->wRes, 4);
            }
        }
        else{
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsx / pOEM->wRes, 4);
            aubCmd[dwOut++] = '-';
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsy / pOEM->wRes, 4);
        }
        goto SEND_COM;
    }

    pOEM->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

    pOEM->wScale = (int)(((tmpPointsx * 10) / tmpPointsy + 5) / 10);

    if(pOEM->wScale > 8) pOEM->wScale = 8;

MAKE_COM:
    dwOut += iDwtoA_FillZero(&aubCmd[dwOut], tmpPointsy / pOEM->wRes, 4);

SEND_COM:

    if(!(pOEM->fGeneral & FG_PLUS))
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale == 1)
            {
                dwOut += memcopy(&aubCmd[dwOut], "\034m1/1,1/1.", 10);
            }
        }
        else
        {
            aubCmd[dwOut++] = '\034';
            dwOut += memcopy(&aubCmd[dwOut], "m1/1,", 5);
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[pOEM->wScale], 3);
            aubCmd[dwOut++] = '.';
        }
    }
    // write spool builded command
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
    if(pOEM->fGeneral & FG_DBCS){

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }

    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = FLAG_RASTER;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE  aubBuff[256];
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;

// Adjust baseline if font substituted form TureType font.
	DWORD		dwYAdj;
	PGETINFO_STDVAR	pSV;
	DWORD 		adwStdVar[2+2*2];
    BYTE  Cmd[256];
    int i;

    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;


    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

// #333653: Change I/F for GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        MemFree(aubBuff);
        return;
    }

    // Adjust baseline if font substituted from TrueType font.
    if (pUFObj->dwFlags & UFOFLAG_TTSUBSTITUTED) {
        pSV = (PGETINFO_STDVAR)adwStdVar;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_TEXTYRES;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                pSV->dwSize, &dwNeeded)) {
            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
            MemFree(aubBuff);
            return;
        }
        dwYAdj = (pSV->StdVar[0].lStdVariable * pIFI->fwdWinDescender /
            pIFI->fwdUnitsPerEm) / pOEM->wRes;
    } else
        dwYAdj = 0;

    /* Vector mode off */
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        i = 0;
        i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
        pOEM->wCurrentAddMode = FLAG_RASTER;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;
    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {
        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
        if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)
        {
            i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted form TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
            if(pOEM->wCurrentAddMode != FLAG_DBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)

            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted form TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1",
                                             "8/1"};
                            Cmd[i++] = '\034';
                            Cmd[i++] = 'm';
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            i += memcopy(&Cmd[i], ",1/1.", 5);
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsy / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted from TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "m1/1,", 5);
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            Cmd[i++] = '.';
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                              pOEM->lPointsy / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }
// #333653: Change I/F for GETINFO_GLYPHSTRING
    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

}


VOID
APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

Return Value:

    NONE

--*/

{
    POEMUD_EXTRADATA    pOEM;

    VERBOSE(("Entering OEMDisablePDEV...\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // Free up memory allocated for the temp. buffer
    //

    if (pOEM->pCompBuf) {
        FREEMEM(pOEM->pCompBuf);
        pOEM->pCompBuf = NULL;
        pOEM->dwCompBufLen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\sources.inc ===
MAJORCOMP=windows
MINORCOMP=md_ncmwjres

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..
HLPDIR=$(SRCDIR)\hlp

TARGETNAME=ncmwjres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
COFFBASE=ncmwjres
!ELSE
COFFBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncmwjres.rc \
    $(SRCDIR)\ncmwjres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncmwjres.ini \
    $(GPDDIR)\nc45m2j.gpd \
    $(GPDDIR)\ncm45mj.gpd \
    $(GPDDIR)\ncm65aj.gpd \
    $(HLPDIR)\ncmwjres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\hlp\helpid.h ===
// HELP  Index

#define POP_DL_MARGIN                602	//
#define POP_DL_JOBSEPARATE           603	//WuZp[g
#define POP_DL_SET                   604	//Zbg@\
#define POP_DL_TONAR                 605	//gi[Z[u
#define POP_DL_DENSITY               606	//Zx
#define POP_DL_SORTER                607	//\[^[
#define POP_DL_OUTBIN                608	//r
#define POP_DL_FACE                  609	//tF[XAbvgC
#define POP_DL_KANJICODE             610	//ihr

#define POP_DL_PAPERTYPE1			 611	//
#define POP_DL_ENVFEEDER			 612	//
#define POP_DL_SIWAKE1				 613	//
#define POP_DL_SIWAKE2				 614	//
#define POP_DL_PRINTAREA			 615	//
#define POP_DL_ERCSORT				 616	//
#define POP_DL_FINISHER1			 617	//
#define POP_DL_F_HOUKOU				 619	//
#define POP_DL_F_ITI				 620	//
#define POP_DL_DUPLX				 621	//
#define POP_DL_PAPERTYPE2			 622	//
#define POP_DL_FACE2                 623	//tF[XAbvgC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD   wRes;            // resolution / MasterUnit
    WORD   wScale;          // The magnification of the font
    LONG   lPointsx;        // font width
    LONG   lPointsy;        // font height
    DWORD  dwSBCSX;         // temp
    DWORD  dwDBCSX;         // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD   fGeneral;       // general flag
    WORD   wCurrentAddMode; // draw mode
    PBYTE pCompBuf;         // buffer for compression
    DWORD dwCompBufLen;     // line buffer
    DWORD dwScanLen;        // bitmap width
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
    UINT  iGray;            // rect fill gray scale
    UINT  cSubPath;         // sub path counter max is 500
// 2001.3.16 add
	WORD Duplex_mode;
	WORD Duplex_OU;
	WORD Margin;
	WORD ESort_mode;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define MAX_SUBPATH 500

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
#define FG_PLUS     0x00000010

#ifdef BYPASS
#define FG_NO_COMP  0x00000020
#endif // BYPASS

// #278517: RectFill
#define FG_GMINIT   0x00000040

// Flags for Draw Mode
#define FLAG_RASTER 0   //
#define FLAG_SBCS   1   // FSa SBCS - FSR
#define FLAG_DBCS   2   // FSa DBCS - FSR
#define FLAG_VECTOR 3   // FSY - FSZ

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncnmjres\hlp\helpid.h ===
// HELP  Index


#define POP_NM_FEEDPOS_A3           701
#define POP_NM_FEEDPOS_B4           702
#define POP_NM_FEEDPOS_A4           703
#define POP_NM_QUARITY              704

/* TextHalftoneThreshold */
#define POP_NM_TEXTHALFTONE         705
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\command.cpp ===
/*=============================================================================
 * FILENAME: command.cpp
 * Copyright (C) 1996-1999 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
 *
 * DESCRIPTION: Support for OEMCommand function to interject additional
 *              postscript commands into the postscript stream.
 * NOTES:  
 *=============================================================================
*/

#include "precomp.h"

#include <windows.h>
#include <WINDDI.H>
#include <PRINTOEM.H>
#include <winspool.h>

#include <stdio.h>
#include <stdlib.h>

#include "nc46nt.h"
#include "debug.h" /* MMM */
#include "oemps.h"



/******************************************************************************
 * DESCRIPTION: Get *JUST* filename from Full path format data 
 *****************************************************************************/

extern "C"
void GetFileName(char *FULL)
{
	char	work[NEC_DOCNAME_BUF_LEN+2], *pwork, *plast;
	int		i, j;
	// char	tmp; // for SoftICE trace

	strncpy(work, FULL, NEC_DOCNAME_BUF_LEN+2);

	j = strlen(work);

	// tmp = '\\'; // for SoftICE trace

	for(plast = pwork = work; pwork < work + j; ++pwork)
	{
		// tmp = *pwork; // for SoftICE trace

		if(*pwork == '\\')	plast = pwork+1;
	}

	strncpy(FULL, plast, NEC_DOCNAME_BUF_LEN+2);
}

/******************************************************************************
 * DESCRIPTION: Exported function for OEM plug-in. Required name and parameters
 *              from the OEM plug-in spectification.
 *              file must be exported in .def file
 *****************************************************************************/
extern "C"
DWORD APIENTRY OEMCommand( PDEVOBJ pDevObj, DWORD dwIndex,
                           PVOID pData, DWORD cbSize )
{
	char *pMem;
	char szUserName[NEC_USERNAME_BUF_LEN+2];
	// char szDocName[NEC_DOCNAME_BUF_LEN+2];

	PDRVPROCS pProcs;
	DWORD dwRv = ERROR_NOT_SUPPORTED;
	DWORD dwNeeded = 0;
	DWORD dwCOptions = 0;
	DWORD dwCbRet;
	BOOL bRv = 0;
	
	int	NumCopies = 1;

	POEMPDEV    poempdev = (POEMPDEV) pDevObj->pdevOEM;

   if( pDevObj == NULL )
      return( dwRv );
   if( (pProcs = (PDRVPROCS)pDevObj->pDrvProcs) == NULL )
      return( dwRv );

   // test function (should be deleted later)

   //strcpy(szDocName, poempdev->szDocName);
   //strcpy(szDocName, "BUG FIX");

   switch( dwIndex )
   {
      case PSINJECT_BEGINSTREAM:
         pMem = (char*)EngAllocMem(FL_ZERO_MEMORY, NEC_DOCNAME_BUF_LEN, OEM_SIGNATURE ); 
         if( pMem != NULL )
         {
            POEMDEV pOEMDM = (POEMDEV)pDevObj->pOEMDM;
            // convert username from unicode string to ascii char string
#ifdef USERMODE_DRIVER
			WideCharToMultiByte(CP_THREAD_ACP,
								WC_NO_BEST_FIT_CHARS,
								pOEMDM->szUserName,
								wcslen(pOEMDM->szUserName) * 2 + 2,
								szUserName,
								NEC_USERNAME_BUF_LEN,
								NULL,
								NULL);
#else // !USERMODE_DRIVER
            EngUnicodeToMultiByteN( szUserName, NEC_USERNAME_BUF_LEN, &dwCbRet,
                                    pOEMDM->szUserName,
//                                    NEC_USERNAME_BUF_LEN * sizeof( WCHAR ) );
                                    wcslen(pOEMDM->szUserName) * 2 + 2);
#endif // USERMODE_DRIVER
			cbSize = 50;
            if( pProcs->DrvGetDriverSetting != NULL )
            {
               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCSpooler", pMem, cbSize, &dwNeeded, &dwCOptions ); 
               if( strcmp( pMem, "True" ) == 0 )
			   {
					// output PS-like header
					strcpy(pMem,
						"%!PS-Adobe-3.0\r\n% Spooled PostScript job\r\n{\r\n {\r\n  1183615869 internaldict begin\r\n  (Job ID is) print \r\n  <<\r\n"
					);
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

					// output JobName
					strcpy(pMem, "    /JobName (");
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strncpy(pMem, poempdev->szDocName, NEC_DOCNAME_BUF_LEN);

					// strcpy(pMem, "c:\\test\\test\\test\\simulate.dat"); // for Full Path Simulation

					GetFileName(pMem);
					// check document name
					//if(strcmp(pMem, "") == 0)	strcpy(pMem, "No information");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
			           pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strcpy(pMem, ")\r\n");
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
		
					// output Owner
					//sprintf(pMem,"    /Owner (%s)\r\n",szUserName);
					strcpy(pMem, "    /Owner (");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strncpy(pMem, szUserName, NEC_DOCNAME_BUF_LEN);
					// check szUserName
					// if(strcmp(pMem, "") == 0)	strcpy(pMem, "No information");
			        if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strcpy(pMem, ")\r\n");
					if( pProcs->DrvWriteSpoolBuf != NULL )
					   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

					// output Creator (Deleted from Spec)
					//sprintf(pMem,"    /Owner (%s)\r\n",szUserName);
					//strcpy(pMem, "    /Creator (NEC SuperScript 4400 NT PS Driver)\r\n");
				    //if( pProcs->DrvWriteSpoolBuf != NULL )
					//   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

					/*
					// output username
					if( pProcs->DrvWriteSpoolBuf != NULL )
					   pProcs->DrvWriteSpoolBuf( pDevObj, szUserName, strlen(szUserName) ); 

					// output document name
			        if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, szDocName, strlen(szDocName) ); 
					*/
			
					// Get and Modify NumCopies
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCCollate", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   NumCopies = pDevObj->pPublicDM->dmCopies;
						   pDevObj->pPublicDM->dmCopies = 1;
					   }
		            }

					// output NumCopies
					//sprintf(pMem,"    /NumCopies %d\r\n",NumCopies);
					strcpy(pMem, "    /NumCopies ");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					_itoa(NumCopies, pMem, 10);
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strcpy(pMem, "\r\n");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 


					// Put /Collate
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCCollate", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   strcpy(pMem, "    /Collate true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   strcpy(pMem, "    /Collate false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /Banner
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCBanner", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   strcpy(pMem, "    /Banner true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   strcpy(pMem, "    /Banner false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /DeleteJob
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCJobpreview", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   strcpy(pMem, "    /DeleteJob false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   strcpy(pMem, "    /DeleteJob true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /HoldJob
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCHoldjob", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   strcpy(pMem, "    /HoldJob true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   strcpy(pMem, "    /HoldJob false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /Priority
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCPriority", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "P1" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 1\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
		               if( strcmp( pMem, "P2" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 2\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P3" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 3\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P4" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 4\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P5" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 5\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P6" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 6\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P7" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 7\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P8" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 8\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P9" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 9\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P10" ) == 0 )
					   {
						   strcpy(pMem, "    /Priority 10\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					strcpy(pMem, 
						"  >>\r\n  spoolgetjobid dup == flush\r\n  spooljobsubmit\r\n } stopped {end clear} if\r\n} exec\r\n");
					if( pProcs->DrvWriteSpoolBuf != NULL )
						pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

			   }
            }

            dwRv = ERROR_SUCCESS;
            EngFreeMem( pMem );
         }
		 break;
		 /*

      case PSINJECT_COMMENTS:
         pMem = (char*)EngAllocMem(FL_ZERO_MEMORY, 52, OEM_SIGNATURE ); 
         if( pMem != NULL )
         {
            strcpy( pMem, "%%Comment added by OEM DLL!!!\n" );
            cbSize = strlen( pMem );
            if( pProcs->DrvWriteSpoolBuf != NULL )
               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, cbSize ); 
            EngFreeMem( pMem );
            dwRv = ERROR_SUCCESS;
         }
      break;
	  */
   }
   return( dwRv );
}


//
// OEMStartDoc
//

extern "C"
BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    HANDLE      hPrinter;

	// char *tmp; // for SoftICE


	DWORD dwCbRet;
	JOB_INFO_1 *pJob;
	DWORD cbNeeded;
    // DebugMsg(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


	//
	// Add DocName copy command here ( copy from pwszDocName to poempdev->szDocName )
	// 

	if((NULL != pwszDocName) && (NULL != poempdev->szDocName))
	{
#ifdef USERMODE_DRIVER
		WideCharToMultiByte(CP_THREAD_ACP,
							WC_NO_BEST_FIT_CHARS,
							pwszDocName,
							wcslen(pwszDocName) * 2 + 2,
							poempdev->szDocName,
							NEC_DOCNAME_BUF_LEN,
							NULL,
							NULL);
		//
		// W2K/Whistler's user mode driver does not pass the correct job name in pwszDocName
		// in case that the printer is connected to network port.
		// So, I need to get the job name from JOB_INFO_1 structure.
		//
		if (OpenPrinter(poempdev->pPrinterName, &hPrinter, NULL) != 0) {
			GetJob(hPrinter, dwJobId, 1, NULL, 0, &cbNeeded);
			pJob = (JOB_INFO_1 *)EngAllocMem(FL_ZERO_MEMORY, cbNeeded, OEM_SIGNATURE);
			if (NULL != pJob) {
			 	if (GetJob(hPrinter, dwJobId, 1, (LPBYTE)pJob, cbNeeded, &cbNeeded) != 0) {
					VERBOSE(__TEXT("Job Name: %s\r\n"), pJob->pDocument);
					WideCharToMultiByte(CP_THREAD_ACP,
										WC_NO_BEST_FIT_CHARS,
										pJob->pDocument,
										wcslen(pJob->pDocument) * 2 + 2,
										poempdev->szDocName,
										NEC_DOCNAME_BUF_LEN,
										NULL,
										NULL);
				}
				EngFreeMem(pJob);
			}
			ClosePrinter(hPrinter);
		}

#else // !USERMODE_DRIVER

		EngUnicodeToMultiByteN( poempdev->szDocName, NEC_DOCNAME_BUF_LEN, &dwCbRet,
                                   pwszDocName,
//                                 NEC_DOCNAME_BUF_LEN * sizeof( WCHAR ) );
                                   wcslen(pwszDocName) * 2 + 2);
#endif // USERMODE_DRIVER
	}
	
	//tmp = poempdev->szDocName; // for SoftICE
	//
    // turn around to call PS
    //


    return (((PFN_DrvStartDoc)(poempdev->pfnPS[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
}

//
// OEMEndDoc
//

extern "C"
BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    // DebugMsg(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    
	return (((PFN_DrvEndDoc)(poempdev->pfnPS[UD_DrvEndDoc])) (
            pso,
            fl));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\exports.cpp ===
/*=============================================================================
 * FILENAME: exports.cpp
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
 *
 * DESCRIPTION: Contains exported functions required to get an OEM plug-in 
 *              to work.
 * NOTES:  
 *=============================================================================
 */

#include "precomp.h"

#include <windows.h>
#include <WINDDI.H>
#include <PRINTOEM.H>
#include <tchar.h> //_tcsxxx MMM

#include "nc46nt.h"
#include "debug.h" /* MMM */
#include "oemps.h"


/*
	For OEMEnableDriver
*/

static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvStartDoc,                    (PFN) OEMStartDoc                   },
    { INDEX_DrvEndDoc,                      (PFN) OEMEndDoc                     },
};



/******************************************************************************
 * DESCRIPTION: Called by the postscript driver after the dll is loaded 
 *              to get plug-in information
 *  
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMGetInfo( DWORD  dwMode,
            PVOID  pBuffer,
            DWORD  cbSize,
            PDWORD pcbNeeded )
{
   // Validate parameters.
   if( NULL == pcbNeeded )
   {
      EngSetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   // Set expected buffer size and number of bytes written.
   *pcbNeeded = sizeof(DWORD);

   // Check buffer size is sufficient.
   if((cbSize < *pcbNeeded) || (NULL == pBuffer))
   {
      EngSetLastError(ERROR_INSUFFICIENT_BUFFER);
      return FALSE;
   }

   switch(dwMode)
   {
      case OEMGI_GETSIGNATURE:     // OEM DLL Signature
         *(PDWORD)pBuffer = OEM_SIGNATURE;
         break;
      case OEMGI_GETVERSION:       // OEM DLL version
         *(PDWORD)pBuffer = OEM_VERSION;
         break;
      case OEMGI_GETINTERFACEVERSION: // version the Printer driver supports
         *(PDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
         break;
      case OEMGI_GETPUBLISHERINFO: // fill PUBLISHERINFO structure
      // fall through to not supported
      default: // dwMode not supported.
         // Set written bytes to zero since nothing was written.
         *pcbNeeded = 0;
         EngSetLastError(ERROR_NOT_SUPPORTED);
         return FALSE;
    }
    return TRUE;
}

/******************************************************************************
 * DESCRIPTION:  Exported function that allows setting of private and public
 *               devmode fields.
 * NOTE: This function must be in entered under EXPORTS in rntapsui.def to be called
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMDevMode( DWORD dwMode, POEMDMPARAM pOemDMParam )
{
POEMDEV pOEMDevIn;
POEMDEV pOEMDevOut;

   switch(dwMode) // kernel mode rendering dll
   {
      case OEMDM_SIZE: // size of oem devmode
         if( pOemDMParam )
            pOemDMParam->cbBufSize = sizeof( OEMDEV );
         break;

      case OEMDM_DEFAULT: // fill oem devmode with default data
         if( pOemDMParam && pOemDMParam->pOEMDMOut )
         {
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
         }
         break;
         
      case OEMDM_MERGE:  // set the public devmode fields
      case OEMDM_CONVERT:  // convert any old oem devmode to new version
         if( pOemDMParam && pOemDMParam->pOEMDMOut && pOemDMParam->pOEMDMIn )
         {
            pOEMDevIn  = (POEMDEV)pOemDMParam->pOEMDMIn;
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            if( pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature )
            {
               wcscpy( pOEMDevOut->szUserName, pOEMDevIn->szUserName );
            }
         }
         break;
   }
   return( TRUE );
}

/******************************************************************************
 * DESCRIPTION: Windows dll required entry point function.
 *  
 *****************************************************************************/
extern "C"
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_DETACH:
			break;
	}

	return( TRUE );
}

extern "C"
VOID APIENTRY OEMDisableDriver()
{
    // DebugMsg(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}

extern "C"
BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // DebugMsg(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}


extern "C"
PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    // DebugMsg(DLLTEXT("OEMEnablePDEV() entry.\r\n"));
    /* MMM */
	VERBOSE(__TEXT("\r\n[MHR:OEMEnablePDEV()] pPrinterName: %s, %d\r\n\n"), pPrinterName, _tcslen(pPrinterName));
	/* MMM */

    //
    // Allocate the OEMDev
    //
    // poempdev = new OEMPDEV;
	poempdev = (POEMPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(OEMPDEV), OEM_SIGNATURE);
    if (NULL == poempdev)
    {
        return NULL;
    }

	//
	// Allocate memory for poempdev->szDocName
	//
	poempdev->szDocName = (char *) EngAllocMem(FL_ZERO_MEMORY, NEC_DOCNAME_BUF_LEN+2, OEM_SIGNATURE);
	if (NULL == poempdev->szDocName)
	{
	    return NULL;
	}
	/* MMM */
	//
	// Allocate memory for poempdev->pPrinterName
	poempdev->pPrinterName = (PWSTR) EngAllocMem(FL_ZERO_MEMORY, (wcslen(pPrinterName)+1)*sizeof(WCHAR), OEM_SIGNATURE);
	if (NULL == poempdev->pPrinterName)
	{
	    return NULL;
	}
	/* MMM */

    //
    // Fill in OEMDEV as you need
    //

	_tcscpy(poempdev->pPrinterName, pPrinterName);	/* MMM */

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnPS[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnPS[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


extern "C"
VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    // DebugMsg(DLLTEXT("OEMDisablePDEV() entry.\r\n"));
	POEMPDEV    poempdev = (POEMPDEV) pdevobj->pdevOEM;

    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //

	// assert(NULL != poempdev->szDocName);
	
	if(NULL != poempdev->szDocName)
	{
		EngFreeMem(poempdev->szDocName);
		poempdev->szDocName = (char *)NULL;
	}
	/* MMM */
	if(NULL != poempdev->pPrinterName)
	{
		EngFreeMem(poempdev->pPrinterName);
		poempdev->pPrinterName = (PWSTR)NULL;
	}
	/* MMM */
    assert(NULL != pdevobj->pdevOEM);
    // delete pdevobj->pdevOEM;
	EngFreeMem(pdevobj->pdevOEM);
}


extern "C"
BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
	//char *tmp; // for SoftICE tracing

	POEMPDEV    poempdevOld = (POEMPDEV)pdevobjOld->pdevOEM;
	POEMPDEV    poempdevNew = (POEMPDEV)pdevobjNew->pdevOEM;

	// DebugMsg(DLLTEXT("OEMResetPDEV() entry.\r\n"));

	//tmp=poempdevOld->szDocName; // for SoftICE trace
	//tmp=poempdevNew->szDocName; // for SoftICE trace

	if((NULL != poempdevNew->szDocName) && (NULL != poempdevOld->szDocName))
	{
		strncpy(poempdevNew->szDocName, poempdevOld->szDocName, NEC_DOCNAME_BUF_LEN);
	}

	//tmp=poempdevNew->szDocName; // for SoftICE trace

    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif

#define DLLTEXT(s)      __TEXT("OEMPS:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
// #include "oem.h"
#include "nc46nt.h"
#include "debug.h"
#include "kmode.h"


#ifdef DBG


////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\nc46nt.h ===
/*=============================================================================
 * FILENAME: nc46ntui.h
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc.  All Rights Reserved.
 *
 * DESCRIPTION: main header file for OEM User interface Dll.
 *  
 * NOTES:  
 *=============================================================================
*/


#ifndef NC46NT_H
#define NC46NT_H

// #define WINVER          0x0500
// #define _WIN32_WINNT    0x0500


// the signature and version of Adobe PostScript OEM dll
#define OEM_SIGNATURE   'NEC '
#define OEM_VERSION     0x00000001L

#define NEC_USERNAME_BUF_LEN 256
#define NEC_DOCNAME_BUF_LEN 256

// OEM devmode structure
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    TCHAR               szUserName[NEC_USERNAME_BUF_LEN];
    // char                szDocName[NEC_DOCNAME_BUF_LEN];

}OEMDEV, *POEMDEV;

#endif // NC46NT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMPS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.inc

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

SRCDIR=..

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(SRCDIR)\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -D_DEBUG to C_DEFINES line below
#C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM -D_DEBUG -DDEBUG
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM



TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=$(SDK_INC_PATH)\mfc42;$(SRCDIR)

SOURCES= $(SRCDIR)\exports.cpp \
         $(SRCDIR)\command.cpp \
         $(SRCDIR)\debug.cpp   \
         $(SRCDIR)\ncpsres.rc

MISCFILES=\
          $(SRCDIR)\icm\NC465006.icm \
          $(SRCDIR)\icm\NC465012.icm \
          $(SRCDIR)\icm\NC46NX06.icm \
          $(SRCDIR)\icm\NC46NX12.icm \
          $(SRCDIR)\icm\NC46N_06.icm \
          $(SRCDIR)\icm\NC46N_12.icm \
          $(SRCDIR)\icm\Ncss4206.icm \
          $(SRCDIR)\icm\Ncss4212.icm \
          $(SRCDIR)\icm\Ncss4406.icm \
          $(SRCDIR)\icm\Ncss4412.icm \
          $(SRCDIR)\icm\ncss4606.icm \
          $(SRCDIR)\icm\ncss4612.icm \
          $(SRCDIR)\ncpsres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.

#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsui\exports.cpp ===
/*=============================================================================
 * FILENAME: exports.cpp
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 *
 * DESCRIPTION: Contains exported functions required to get an OEM plug-in 
 *              to work.
 * NOTES:  
 *=============================================================================
*/

#include <windows.h>
#include <tchar.h> //_tcsxxx
#include <stdlib.h>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#include "nc46nt.h"

HINSTANCE ghInstance;

/******************************************************************************
 * DESCRIPTION: Called by the postscript driver after the dll is loaded 
 *              to get plug-in information
 *  
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMGetInfo( DWORD  dwMode,
            PVOID  pBuffer,
            DWORD  cbSize,
            PDWORD pcbNeeded )
{
   // Validate parameters.
   if( NULL == pcbNeeded )
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   // Set expected buffer size and number of bytes written.
   *pcbNeeded = sizeof(DWORD);

   // Check buffer size is sufficient.
   if((cbSize < *pcbNeeded) || (NULL == pBuffer))
   {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);
      return FALSE;
   }

   switch(dwMode)
   {
      case OEMGI_GETSIGNATURE:     // OEM DLL Signature
         *(PDWORD)pBuffer = OEM_SIGNATURE;
         break;
      case OEMGI_GETVERSION:       // OEM DLL version
         *(PDWORD)pBuffer = OEM_VERSION;
         break;
      case OEMGI_GETINTERFACEVERSION: // version the Printer driver supports
         *(PDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
         break;
      case OEMGI_GETPUBLISHERINFO: // fill PUBLISHERINFO structure
      // fall through to not supported
      default: // dwMode not supported.
         // Set written bytes to zero since nothing was written.
         *pcbNeeded = 0;
         SetLastError(ERROR_NOT_SUPPORTED);
         return FALSE;
    }
    return TRUE;
}

/******************************************************************************
 * DESCRIPTION:  Exported function that allows setting of private and public
 *               devmode fields.
 * NOTE: This function must be in entered under EXPORTS in rntapsui.def to be called
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMDevMode( DWORD dwMode, POEMDMPARAM pOemDMParam )
{
POEMDEV pOEMDevIn;
POEMDEV pOEMDevOut;

   switch(dwMode) // user mode dll
   {
      case OEMDM_SIZE: // size of oem devmode
         if( pOemDMParam )
            pOemDMParam->cbBufSize = sizeof( OEMDEV );
         break;

      case OEMDM_DEFAULT: // fill oem devmode with default data
         if( pOemDMParam && pOemDMParam->pOEMDMOut )
         {
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            _tcscpy( pOEMDevOut->szUserName, TEXT("NO USER NAME") );
         }
         break;
      case OEMDM_MERGE:  // set the public devmode fields
      case OEMDM_CONVERT:  // convert any old oem devmode to new version
         if( pOemDMParam && pOemDMParam->pOEMDMOut && pOemDMParam->pOEMDMIn )
         {
            pOEMDevIn  = (POEMDEV)pOemDMParam->pOEMDMIn;
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            if( pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature )
            {
            TCHAR szUserName[NEC_USERNAME_BUF_LEN+2];
            DWORD dwCb = NEC_USERNAME_BUF_LEN;
               if( GetUserName( szUserName, &dwCb ) )
                  _tcscpy( pOEMDevOut->szUserName, szUserName );
            }
         }
         break;

   }
   return( TRUE );
}

/******************************************************************************
 * DESCRIPTION: Windows dll required entry point function.
 *  
 *****************************************************************************/
extern "C" 
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
   switch(wReason)
   {
      case DLL_PROCESS_ATTACH:
         ghInstance = hInst;
         break;

      case DLL_THREAD_ATTACH:
         break;

      case DLL_PROCESS_DETACH:
         break;

      case DLL_THREAD_DETACH:
         ghInstance = NULL;
         break;
   }
   return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ncpsres\oemps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//  Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
//
//  FILE:	OEMPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEMPS_H
#define _OEMPS_H

//#include "OEM.H"
//#include "DEVMODE.H"

#define NEC_DOCNAME_BUF_LEN 256

////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

//#define DLLTEXT(s)      __TEXT("OEMPS:  ") __TEXT(s)
//#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvStartDoc,
    UD_DrvEndDoc,


    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // PS's hook function pointer so it call back.
    //
    PFN     pfnPS[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    
	char	*szDocName;
	PWSTR	pPrinterName;	/* MMM */
	
	DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nt4lib\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

C_DEFINES=$(C_DEFINES) -DUNICODE -DKERNEL_MODE -DOEMCOM

INCLUDES=..;$(INCLUDES)

SOURCES=..\stubs.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nt4lib\minidrv.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#ifndef WINNT_40

#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#else // WINNT_40

extern DWORD gdwDrvMemPoolTag;

#define MemAlloc(n)      EngAllocMem(0, (n), gdwDrvMemPoolTag)
#define MemAllocZ(n)     EngAllocMem(FL_ZERO_MEMORY, (n), gdwDrvMemPoolTag)
#define MemFree(p)          { if (p) EngFreeMem(p); }

extern LONG DrvInterlockedIncrement(PLONG);
extern LONG DrvInterlockedDecrement(PLONG);

#undef InterlockedIncrement
#undef InterlockedDecrement
#define InterlockedIncrement(p) DrvInterlockedIncrement(p)
#define InterlockedDecrement(p) DrvInterlockedDecrement(p)

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghUniSemaphore
#define INIT_CRITICAL_SECTION()     ghUniSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghUniSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghUniSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghUniSemaphore)

extern DECLARE_CRITICAL_SECTION;
extern VOID DrvCreateInterlock();
extern VOID DrvDeleteInterlock();
#define SetLastError EngSetLastError

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
extern DWORD DrvGetTickCount(VOID);
#define GetTickCount DrvGetTickCount

extern HANDLE DrvMapFileForRead(LPWSTR, PVOID *, PDWORD);
extern HANDLE DrvMapFileForWrite(LPWSTR, DWORD, PVOID *, PDWORD);
extern VOID DrvUnMapFile(HANDLE);
extern DWORD DrvGetWindowsDirectory(LPWSTR, DWORD);
#undef GetWindowsDirectory
#define GetWindowsDirectory DrvGetWindowsDirectory

#endif

#endif // WINNT_40

//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (Taiwan, Hong Kong SAR)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\nt4lib\stubs.cxx ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

--*/

extern "C" {

#include <minidrv.h>

}

#ifdef WINNT_40

#ifdef KM_DRIVER

inline void* __cdecl operator new(size_t nSize)
{
      // return pointer to allocated memory
      return  MemAllocZ(nSize);
}

inline void __cdecl operator delete(void *p)
{
    if (p)
        MemFree(p);
}

int __cdecl _purecall (void)
{
    return FALSE;
}

#endif

extern "C" {

DECLARE_CRITICAL_SECTION;

//DWORD gdwDrvMemPoolTag = 'meoD';

#if DBG

//
// Variable to control the amount
//

INT giDebugLevel = DBG_WARNING;
#endif

VOID
DrvCreateInterlock()
{
    INIT_CRITICAL_SECTION();
}

VOID
DrvDeleteInterlock()
{
    DELETE_CRITICAL_SECTION();
}

LONG
DrvInterlockedIncrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{


    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);

}


LONG
DrvInterlockedDecrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();

    return (*pRef);

}


#ifdef KM_DRIVER

DWORD
DrvGetTickCount()
{
    DWORD dwRet;

    ENG_TIME_FIELDS currentTime;

    EngQueryLocalTime(&currentTime); 

    dwRet = currentTime.usMilliseconds
        + currentTime.usSecond * 1000
        + currentTime.usMinute * 1000 * 60
        + currentTime.usHour * 1000 * 60 * 60
        + currentTime.usDay * 1000 * 60 * 60 * 24;

    return dwRet;
}

HANDLE
DrvMapFileForRead(
    LPWSTR pwsz,
    PVOID *ppvData,
    PDWORD pdwSize)
{
    HANDLE  hModule = NULL;
    DWORD   dwSize;

    if (NULL != (hModule = EngLoadModule((PWSTR)pwsz)))
    {
        if (*ppvData = EngMapModule(hModule, &dwSize))
        {
            if (pdwSize)
                *pdwSize = dwSize;
        }
        else
        {
            ERR(("EngMapModule failed: %d\n", EngGetLastError()));
            EngFreeModule(hModule);
            hModule = NULL;
        }
    }
    else
        ERR(("EngLoadModuleForWrite failed: %d\n", EngGetLastError()));

    return hModule;
}

HANDLE
DrvMapFileForWrite(
    LPWSTR pwsz,
    DWORD dwReqSize,
    PVOID *ppvData,
    PDWORD pdwSize)
{
    HANDLE  hModule = NULL;
    DWORD   dwSize;

    if (NULL != (hModule = EngLoadModuleForWrite((PWSTR)pwsz, dwReqSize)))
    {
        if (*ppvData = EngMapModule(hModule, &dwSize))
        {
            if (pdwSize)
                *pdwSize = dwSize;
        }
        else
        {
            ERR(("EngMapModule failed: %d\n", EngGetLastError()));
            EngFreeModule(hModule);
            hModule = NULL;
        }
    }
    else
        ERR(("EngLoadModuleForWrite failed: %d\n", EngGetLastError()));

    return hModule;
}

VOID
DrvUnMapFile(
    HANDLE hModule
)
{
    EngFreeModule(hModule);
}

DWORD
DrvGetWindowsDirectory(
    LPWSTR szFileName,
    DWORD uSize)
{
    return 0;
}

#endif // KM_DRIVER


#if DBG
#define STANDARD_DEBUG_PREFIX ""

VOID
DbgPrint(
    PCSTR DebugMessage, ...)
{
    va_list ap;

    va_start(ap, DebugMessage);
    EngDebugPrint((PCHAR)STANDARD_DEBUG_PREFIX, (PCHAR)DebugMessage, ap);
    va_end(ap);
}
#endif // DBG

} // "C"

#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\okepjres\etc\okiescms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------


char *rgchModuleName = "okiescms";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\code.c ===
/********************** Module Header **************************************
 * code.c
 *	Code required for OKI 9 pin printers.  The bit order needs
 *	swapping,  and any ETX char needs to be sent twice.
 *
 * HISTORY:
 *  15:26 on Fri 10 Jan 1992	-by-	Lindsay Harris   [lindsayh]
 *	Created it.
 * 
 *  Ported to NT5 on  Weds 29 Oct 1997 -by- Philip Lee [philipl]
 *
 *  Copyright (C) 1999  Microsoft Corporation.
 *
 **************************************************************************/

char *rgchModuleName = "OKI9RES";


/*
 *   This printer requires sending the ETX character (0x03) twice to send
 * just one - so we define the following to select that byte.
 */

#define	RPT_CHAR	0x03

#define	SZ_LBUF	128	/* Size of local copying buffer */

/*
 *   The bit flipping table is common to several drivers,  so it is
 *  included here.  It's definition is as a static.
 */

static const BYTE  FlipTable[ 256 ] =
{

#include	"fliptab.h"

};

#define _GET_FUNC_ADDR         1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\fliptab.h ===
0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };


    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "comoem.h"


///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////

#include "code.c"

//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

// Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return S_FALSE;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return S_FALSE;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

/********************** Module Header **************************************
 * code.c
 *	Code required for OKI 9 pin printers.  The bit order needs
 *	swapping,  and any ETX char needs to be sent twice.
 *
 * HISTORY:
 *  15:26 on Fri 10 Jan 1992	-by-	Lindsay Harris   [lindsayh]
 *	Created it.
 *
 *  Ported to NT5 on  Weds 29 Oct 1997 -by- Philip Lee [philipl]
 *
 *  Copyright (C) 1999  Microsoft Corporation.
 *
 **************************************************************************/

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    citohres.c

Abstract:

    Implementation of OEMFilterGraphics callback


Environment:

    Windows NT Unidrv driver

Revision History:

    10/09/97 -patryan-
        Port code to NT5.0

--*/

{
	
    /*
     *    Easy to do - translate the input using FlipTable,  then call the
     *  RasDD function WriteSpoolBuf.  Also must follow any \003 with
     *  another one.
     */

    DWORD dwResult, dwBufLen;

    register int    iLoop;		/* Inner loop counter */
    register BYTE  *pbOut;		/* Destination address */
    int    iLeft;			/* Outer loop counter */
    BYTE   bLocal[ SZ_LBUF ];		/* For local manipulations */
    HRESULT hr;

    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    iLeft = dwLen;

    while( iLeft > 0 )
    {

	    iLoop = iLeft > (SZ_LBUF / 2) ? SZ_LBUF / 2 : iLeft;
	    iLeft -= iLoop;
	    pbOut = bLocal;

	    while( --iLoop >= 0 )
	    {

	        if( (*pbOut++ = FlipTable[ *pBuf++ ]) == RPT_CHAR )
		    *pbOut++ = RPT_CHAR;
	    }
        dwBufLen = (DWORD)(pbOut - bLocal);

        hr = pOEMHelp->DrvWriteSpoolBuf( pdevobj, bLocal, dwBufLen,  &dwResult );

        if ( !SUCCEEDED(hr) || (dwResult != dwBufLen) )
            return E_FAIL;

    }
    return S_OK;
}


STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\oki9res\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for Declasers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'OKI9'      // LG GDI x00 series dll
#define DLLTEXT(s)      __TEXT("OKI9RES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pa24tres\etc\pansn24c.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "PANSN24C";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

#if 0
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#else // 0
extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#endif // 0
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING, ("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}
#endif // 0


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING, ("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING, ("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING, ("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING, ("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\compress.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//typedef unsigned char BYTE;

// const BYTE terminator[5] = {0x1B, 0x7E, 0x01, 0x00, 0x00};


#define RL4_MAXISIZE  0xFFFE
#define RL4_MAXHEIGHT 0xFFFE
#define RL4_MAXWIDTH  4096
#define VALID     0x00
#define INVALID   0x01

typedef struct tag_COMP_DATA {
	PBYTE	RL_ImagePtr;
	PBYTE	RL_CodePtr;
	PBYTE	RL_BufEnd;
	DWORD	RL_ImageSize;
	DWORD	RL_CodeSize;
	BYTE	BUF_OVERFLOW;
} COMP_DATA, *PCOMP_DATA;

// #291170: Image data is not printed partly
DWORD RL_ECmd(PBYTE, PBYTE, DWORD, DWORD);
BYTE RL_Init(PBYTE, PBYTE, DWORD, DWORD, PCOMP_DATA);
char RL_Enc( PCOMP_DATA );

#define RL4_BLACK     0x00
#define RL4_WHITE     0x01
#define RL4_BYTE      0x00
#define RL4_NONBYTE   0x01
#define RL4_CLEAN     0x00
#define RL4_DIRTY     0x01
#define RL4_FIRST     0x00
#define RL4_SECOND    0x01

#define COMP_FAIL     0x00
#define COMP_SUCC     0x01

#define CODBUFSZ      0x7FED     /* NOTE : THIS SHOULD MATCH THE SPACE GIVEN */
                                 /*        TO COMPRESSED DATA BY THE DEVICE  */
                                 /*        DRIVER. CHANGE THIS BASED ON YOUR */
                                 /*        OWN DISCRETION.   C.Chi           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'PAGS'
#define DLLTEXT(s)      "PAGS: " s
#define OEM_VERSION      0x00010000L

#define CCHMAXCMDLEN    128
// Though the data GDI sends to CBFilerGraphics
// is only one line, we allocate maximum image data
// length ESX86 command can handle.
// 0x7fff - 18 = 0x7fed bytes

#define MAXIMGSIZE (0x7fff - 18)

// Use for whether it calls OEMFilterGraphics
#define GRXFILTER_ON        1

#define CURSOR_Y_ABS_MOVE   2
#define CURSOR_Y_REL_DOWN   3
#define CURSOR_X_ABS_MOVE   4
#define CURSOR_X_REL_RIGHT  5

// It's only NetworkPrinter12/17/24 using these definitions
#define CMD_SELECT_RES_300  10
#define CMD_SELECT_RES_600  11
// #278517: Support RectFill
#define CMD_SELECT_RES_240  12
#define CMD_SELECT_RES_360  13
#define CMD_SEND_BLOCKDATA  20

// #278517: RectFill
#define CMD_RECT_WIDTH      30
#define CMD_RECT_HEIGHT     31
#define CMD_RECT_BLACK      32
#define CMD_RECT_WHITE      33
#define CMD_RECT_GRAY       34  // Not used
#define CMD_RECT_BLACK_2    35
#define CMD_RECT_WHITE_2    36
#define CMD_RECT_GRAY_2     37

#define BVERTFONT(p) \
    ((p)->ulFontID == 6 || (p)->ulFontID == 8)

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    // Private extention
    BOOL                fCallback;

    // Using build ESX86 command
    WORD                wCurrentRes;
    LONG                lWidthBytes;
    LONG                lHeightPixels;

#ifdef FONTPOS
// UNIDRV send incorrect Y position when set UPPERLEFT
// We should adjust manually.
    WORD                wFontHeight;    // DevFont height
    WORD                wYPos;          // DevFont Y position
#endif  //FONTPOS
// #278517: RectFill
    WORD                wRectWidth;     // Width of Rectangle
    WORD                wRectHeight;    // Height of Rectangle
    WORD                wUnit;          // Resolution in MasterUnit
} OEM_EXTRADATA, *POEM_EXTRADATA;

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\pagesres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include <windows.h>
#include "pdev.h"
#include "compress.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fCallback = FALSE;
    pOEMExtra->wCurrentRes = 0;
    pOEMExtra->lWidthBytes = 0;
    pOEMExtra->lHeightPixels = 0;

#ifdef FONTPOS
    pOEMExtra->wFontHeight = 0;
    pOEMExtra->wYPos = 0;
#endif
// #278517: RectFill
    pOEMExtra->wRectWidth = 0;
    pOEMExtra->wRectHeight = 0;
    pOEMExtra->wUnit = 1;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->fCallback = pdmIn->fCallback;

        pdmOut->wCurrentRes = pdmIn->wCurrentRes;
        pdmOut->lWidthBytes = pdmIn->lWidthBytes;
        pdmOut->lHeightPixels = pdmIn->lHeightPixels;

#ifdef FONTPOS
        pdmOut->wFontHeight = pdmIn->wFontHeight;
        pdmOut->wYPos = pdmIn->wYPos;
#endif
// #278517: RectFill
        pdmOut->wRectWidth = pdmIn->wRectWidth;
        pdmOut->wRectHeight = pdmIn->wRectHeight;
        pdmOut->wUnit = pdmIn->wUnit;

    }
    return TRUE;
}

// #######

#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

BYTE IsDBCSLeadBytePAGES(BYTE Ch)
{
    static BYTE ShiftJisPAGES[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

return ShiftJisPAGES[Ch];
}


/*********************************************************/
/*  RL_ECmd  : main function                             */
/*  ARGS     : LPBYTE - pointer to image                 */
/*             LPBYTE - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : WORD   - size of BRL Code                 */
/*             0      - COMPRESSION FAILED               */
/*********************************************************/
DWORD RL_ECmd(PBYTE iptr, PBYTE cptr, DWORD isize, DWORD osize)
{
    COMP_DATA   CompData;
    
    if (VALID == RL_Init(iptr, cptr, isize, osize, &CompData))
        RL_Enc( &CompData );

    if (CompData.BUF_OVERFLOW)
        return 0;
    else
        return CompData.RL_CodeSize;
}

/*********************************************************/
/*  RL_Init  : Initializer                               */
/*  ARGS     : BYTE * - pointer to image                 */
/*             BYTE * - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : BYTE   - VALID or INVALID                 */
/*********************************************************/

BYTE RL_Init(PBYTE iptr, PBYTE cptr, DWORD isize, DWORD osize,
    PCOMP_DATA pCompData)
{
    pCompData->RL_ImagePtr  = iptr;
    pCompData->RL_CodePtr   = cptr;
    pCompData->RL_ImageSize = isize;
    pCompData->BUF_OVERFLOW = 0;
    pCompData->RL_BufEnd    = cptr + osize;

    return VALID;
}

/*********************************************************/
/*  RL_Enc   : Encoder                                   */
/*  ARGS     : void                                      */
/*  RET      : char   COMP_SUCC or COMP_FAIL             */
/*********************************************************/
char RL_Enc(PCOMP_DATA pCompData)
{
// #313252: RLE compressed data doesn't match with length.
// Rewrite RLE compression algorithm.

    int     count;
    BYTE    rdata;
    PBYTE   pdata, pcomp, pend;
    DWORD   i;

    pdata = pCompData->RL_ImagePtr;
    pcomp = pCompData->RL_CodePtr;
    pend = pCompData->RL_BufEnd;
    count = 0;

    for (i = 0; i < pCompData->RL_ImageSize; i++, pdata++) {
        if (count == 0) {
            rdata = *pdata;
            count = 1;
        } else if (*pdata != rdata) {
            if (pcomp + 2 >= pend)
                goto overflow;
            *pcomp++ = count - 1;
            *pcomp++ = rdata;
            rdata = *pdata;
            count = 1;
        } else if (++count >= 256) {
            if (pcomp + 2 >= pend)
                goto overflow;
            *pcomp++ = count - 1;
            *pcomp++ = rdata;
            count = 0;
        }
    }
    if (count) {
        if (pcomp + 2 >= pend)
            goto overflow;
        *pcomp++ = count - 1;
        *pcomp++ = rdata;
    }

    pCompData->RL_CodeSize = (DWORD)(pcomp - pCompData->RL_CodePtr);
    pCompData->RL_CodePtr = pcomp;

    return COMP_SUCC;

overflow:
    pCompData->BUF_OVERFLOW = 1; 
    return COMP_FAIL;
}


//---------------------------*OEMSendFontCmd*----------------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
VOID APIENTRY OEMSendFontCmd(pdevobj, pUFObj, pFInv)
PDEVOBJ      pdevobj;
PUNIFONTOBJ  pUFObj;
PFINVOCATION pFInv;
{
    DWORD               i, ocmd;
    BYTE                rgcmd[CCHMAXCMDLEN];
    PGETINFO_STDVAR     pSV;

//#287800 ->
    DWORD               dwStdVariable[2 + 2 * 3];
    DWORD   dwTxtRes ;
//#287800 <-

//#319705 
    WORD wAscend, wDescend ;

    POEM_EXTRADATA      pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

    VERBOSE(("OEMSendFontCmd entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pUFObj || !pFInv)
    {
        ERR(("OEMSendFontCmd: pUFObj or pFInv is NULL."));
        return ;
    }

//#287800 ->
    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (3 - 1);
    pSV->dwNumOfVariable = 3;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
//#287800 <-

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, NULL)) 
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

#ifdef FONTPOS
    pOEM->wFontHeight = (WORD)pSV->StdVar[0].lStdVariable;

//#287800 ->
    dwTxtRes = pSV->StdVar[2].lStdVariable ;
    pOEM->wFontHeight = (WORD)((pOEM->wFontHeight * pOEM->wCurrentRes
                                 + dwTxtRes / 2) / dwTxtRes) ;
//#287800 <-

//#319705 For TTFS positioning ->
    wAscend = pUFObj->pIFIMetrics->fwdWinAscender ;
    wDescend = pUFObj->pIFIMetrics->fwdWinDescender ;

    wDescend = pOEM->wFontHeight * wDescend / (wAscend + wDescend) ;
    pOEM->wFontHeight -= wDescend ;

#endif

#define SV_HEIGHT   (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH    (pSV->StdVar[1].lStdVariable)

    ocmd = 0;
    for (i = 0; i < pFInv->dwCount && ocmd < CCHMAXCMDLEN; )
    {
        WORD wTemp;

        if (pFInv->pubCommand[i] == '#')
        {
            if (pFInv->pubCommand[i+1] == 'V')
            {
                // character height setting
                wTemp = (WORD)SV_HEIGHT;
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'H')
            {
                // (DBCS) character width setting
                wTemp = (WORD)(SV_WIDTH * 2);
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'P')
            {
                // (DBCS) character pitch setting
                wTemp = (WORD)(SV_WIDTH * 2);
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'L')
            {
                // Line pitch (spacing) setting
                wTemp = (WORD)SV_HEIGHT;
    
                if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else {
                rgcmd[ocmd++] = pFInv->pubCommand[i++];
            }

            continue;
        }

        // just copy others
        rgcmd[ocmd++] = pFInv->pubCommand[i++];
    }

    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);
    return;
}

VOID APIENTRY OEMOutputCharStr( 
PDEVOBJ     pdevobj,
PUNIFONTOBJ pUFObj,
DWORD       dwType,
DWORD       dwCount,
PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               tempBuf;
    PTRANSDATA          pTrans;
    DWORD               i, j;
    DWORD               rSize = 0;
    BOOL                fLeadByteFlag;
    BYTE                fDBCS[256];
    BYTE                ESC_VERT_ON[]  = "\x1B\x7E\x0E\x00\x01\x0B";
    BYTE                ESC_VERT_OFF[] = "\x1B\x7E\x0E\x00\x01\x0C";

#ifdef FONTPOS
    POEM_EXTRADATA      pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
    BYTE                ESC_Y_ABS[] = "\x1b\x7e\x1d\x00\x03\x05\x00\x00";
#endif

    BOOL bVFont, bDBChar;
    BYTE *pTemp;
    WORD wLen;

    VERBOSE(("OEMOutputCharStr() entry.\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!(tempBuf = (PBYTE)MemAllocZ(dwCount * sizeof(TRANSDATA)) ))
    {
        ERR(("Mem alloc failed.\n"));
        return;
    }

    GStr.dwSize     = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount    = dwCount;
    GStr.dwTypeIn   = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn   = pGlyph;
    GStr.dwTypeOut  = TYPE_TRANSDATA;
    GStr.pGlyphOut  = NULL;
    GStr.dwGlyphOutSize = 0;

     /* Get TRANSDATA buffer size */
    if (FALSE != pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
        || 0 == GStr.dwGlyphOutSize )
    {
        ERR(("Get Glyph String error\n"));
        return ;
    }

    /* Alloc TRANSDATA buffer */
    if(!(tempBuf = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize) ))
    {
        ERR(("Mem alloc failed.\n"));
        return;
    }

    /* Get actual TRANSDATA */
    GStr.pGlyphOut = tempBuf;
    if (!pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("GetInfo failed.\n"));
        return;
    }

    pTrans = (PTRANSDATA)GStr.pGlyphOut;

#ifdef FONTPOS
    if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600 )
        ESC_Y_ABS[5] = 0x25;

    // ntbug9#406475: Font printed the different position.
    if((pOEM->wYPos - pOEM->wFontHeight) >= 0)
    {
        ESC_Y_ABS[6] = HIBYTE((pOEM->wYPos - pOEM->wFontHeight));
        ESC_Y_ABS[7] = LOBYTE((pOEM->wYPos - pOEM->wFontHeight));
        WRITESPOOLBUF(pdevobj, ESC_Y_ABS, 8);
    }
#endif  //FONTPOS

    bVFont = BVERTFONT(pUFObj);
    bDBChar = FALSE;

    for(i = 0; i < dwCount; i++, pTrans++)
    {
        switch((pTrans->ubType & MTYPE_FORMAT_MASK))
        {
        case MTYPE_DIRECT:      // SBCS character
            if (bVFont && bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                bDBChar = FALSE;
            }
            WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
            break;

        case MTYPE_PAIRED:      // DBCS character
            if (bVFont && !bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON));
                bDBChar = TRUE;
            }
            WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
            break;

        case MTYPE_COMPOSE:
            if (bVFont && bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                bDBChar = FALSE;
            }

            pTemp = (BYTE *)(GStr.pGlyphOut) + pTrans->uCode.sCode;

            // first two bytes are the length of the string
            wLen = *pTemp + (*(pTemp + 1) << 8);
            pTemp += 2;

            WRITESPOOLBUF(pdevobj, pTemp, wLen);
        }
    }

    if (bDBChar)
    {
        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
    }
 
    MemFree(tempBuf);
    return;
}

BOOL APIENTRY OEMFilterGraphics(
PDEVOBJ    pdevobj,  // Points to private data required by the Unidriver.dll
PBYTE      pBuf,     // points to buffer of graphics data
DWORD      dwLen)    // length of buffer in bytes
{  
    DWORD           dwCompLen;
    LONG            lHorzPixel;
    DWORD           dwLength;      // Let's use a temporary LEN
    PBYTE           pCompImage;
    POEM_EXTRADATA  pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
    BYTE            ESC_ESX86[] = "\x1B\x7E\x86\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01";
// #291170: Image data is not printed partly
    LONG            li, lHeightPixel, lPixels, lBytes, lRemain, lSize;
    PBYTE           pTemp;
    BYTE            ESC_Y_REL[] = "\x1b\x7e\x1d\x00\x03\x06\x00\x00";

    if(!pOEM->fCallback)
    {
        WRITESPOOLBUF(pdevobj, pBuf, dwLen);
        return TRUE;
    }

    if(!(pCompImage = (BYTE *)MemAllocZ(MAXIMGSIZE)))
    {
        ERR(("Memory alloc error\n"));
        return FALSE;
    }

// #291170: Image data is not printed partly
// Sent 'SendBlock' command separately if necessary.

#define RLE_THRESH (MAXIMGSIZE / 2 - 2)    // threshold for RLE should success

    /*_ Calculate i-axis direction size of the iage ISIZ */
    lBytes = pOEM->lWidthBytes;
    lHorzPixel = lBytes * 8;
    lHeightPixel = pOEM->lHeightPixels;

    if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
        ESC_ESX86[5] = (pOEM->wCurrentRes == 300 ? 0x10 : 0x40);

    pTemp = pBuf;
    lRemain = lBytes * lHeightPixel;
    li = 0;
    while (li < lHeightPixel) {

        /*_ Compress image data using Byte Run Length Algorithm  */
        lPixels = min(lRemain, RLE_THRESH) / lBytes;
        lSize = lBytes * lPixels;
        dwCompLen = RL_ECmd(pTemp, pCompImage, lSize, MAXIMGSIZE);
        pTemp += lSize;
        lRemain -= lSize;
        li += lPixels;

        /*_ Set ISIZ of ESX86 command */
        ESC_ESX86[17] = HIBYTE(lHorzPixel);
        ESC_ESX86[18] = LOBYTE(lHorzPixel);
        ESC_ESX86[21] = HIBYTE(lPixels);
        ESC_ESX86[22] = LOBYTE(lPixels);

        /*_ Add parameter length to the data length after compression */
        dwLength = dwCompLen + 18;

        /*_ Set LEN of ESX86 command */
        ESC_ESX86[3] = HIBYTE(dwLength);
        ESC_ESX86[4] = LOBYTE(dwLength);

        /*_ Output ESX86 command */
        WRITESPOOLBUF(pdevobj, (PBYTE)ESC_ESX86, 23);

        /*_ Output compressed data */
        WRITESPOOLBUF(pdevobj, pCompImage, dwCompLen);

        /* Move Y position to the next graphics portion */
        if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
            ESC_Y_REL[5] = 0x26;

        dwLength = lPixels * pOEM->wUnit;       // Convert to MasterUnit
        ESC_Y_REL[6] = HIBYTE(dwLength);
        ESC_Y_REL[7] = LOBYTE(dwLength);
        WRITESPOOLBUF(pdevobj, ESC_Y_REL, 8);
    }

    MemFree(pCompImage);

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    POEM_EXTRADATA      pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
    WORD                wTemp =0;
// #278517: Support RectFill
    WORD                wUnit;
    BYTE                ESC_X_ABS_NP[] = "\x1b\x7e\x1c\x00\x03\x25\x00\x00";
    BYTE                ESC_X_REL_NP[] = "\x1b\x7e\x1c\x00\x03\x26\x00\x00";
    BYTE                ESC_Y_ABS[] = "\x1b\x7e\x1d\x00\x03\x05\x00\x00";
    BYTE                ESC_Y_REL[] = "\x1b\x7e\x1d\x00\x03\x06\x00\x00";
// #278517: RectFill
    BYTE                ESC_RECT_FILL[] =
                        "\x1b\x7e\x32\x00\x08\x80\x40\x00\x02\x00\x00\x00\x00";
    BYTE                ESC_BEGIN_RECT[] =
                        "\x1b\x7e\x52\x00\x06\x00\x00\x17\x70\x17\x70";
    BYTE                ESC_END_RECT[] =
                        "\x1b\x7e\x52\x00\x06\x00\x00\x38\x40\x38\x40";

    switch(dwCmdCbId)
    {
        case GRXFILTER_ON:
            pOEM->fCallback = TRUE;
            break;

        case CMD_SELECT_RES_300:
            pOEM->wCurrentRes = 300;
            pOEM->wUnit = 2;
            break;

        case CMD_SELECT_RES_600:
            pOEM->wCurrentRes = 600;
            pOEM->wUnit = 1;
            break;

// #278517: Support RectFill
        case CMD_SELECT_RES_240:
            pOEM->wCurrentRes = 240;
            pOEM->wUnit = 6;
            break;

        case CMD_SELECT_RES_360:
            pOEM->wCurrentRes = 360;
            pOEM->wUnit = 4;
            break;

        case CMD_SEND_BLOCKDATA:
            if( !pdwParams || dwCount != 2)
                break;

            pOEM->fCallback = TRUE;
            pOEM->lHeightPixels = (LONG)PARAM(pdwParams, 0);
            pOEM->lWidthBytes = (LONG)PARAM(pdwParams, 1);
            break;

        case CURSOR_Y_ABS_MOVE:
            if(!pdwParams)
                break;

            wTemp = (WORD)*pdwParams;

#ifdef FONTPOS
            pOEM->wYPos = wTemp;
#endif

            if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                ESC_Y_ABS[5] = 0x25;

            ESC_Y_ABS[6] = HIBYTE(wTemp);
            ESC_Y_ABS[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_Y_ABS, 8);
            return (INT)wTemp;

        case CURSOR_Y_REL_DOWN:
            if(!pdwParams)
                break;

            wTemp = (WORD)*pdwParams;

#ifdef FONTPOS
            pOEM->wYPos += wTemp;
#endif

            if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                ESC_Y_REL[5] = 0x26;

            ESC_Y_REL[6] = HIBYTE(wTemp);
            ESC_Y_REL[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_Y_REL, 8);
            return (INT)wTemp;

        case CURSOR_X_ABS_MOVE:
            if(!pdwParams)
                break;

            wTemp = (WORD)*pdwParams;
            ESC_X_ABS_NP[6] = HIBYTE(wTemp);
            ESC_X_ABS_NP[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_X_ABS_NP, 8);
            return (INT)wTemp;

        case CURSOR_X_REL_RIGHT:
            if(!pdwParams)
                break;

            wTemp = (WORD)*pdwParams;
            ESC_X_REL_NP[6] = HIBYTE(wTemp);
            ESC_X_REL_NP[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_X_REL_NP, 8);
            return (INT)wTemp;
            
// #278517: RectFill
        case CMD_RECT_WIDTH:
            pOEM->wRectWidth = (WORD)*pdwParams;
            break;

        case CMD_RECT_HEIGHT:
            pOEM->wRectHeight = (WORD)*pdwParams;
            break;

        case CMD_RECT_BLACK:
        case CMD_RECT_BLACK_2:
//#292316
//            ESC_RECT_FILL[6] = 0x60;
            ESC_RECT_FILL[7] = 0x00;    // Black
            goto fill;

        case CMD_RECT_WHITE:
        case CMD_RECT_WHITE_2:
//#292316
//            ESC_RECT_FILL[6] = 0x40;
            ESC_RECT_FILL[7] = 0x0F;    // White
            goto fill;

        case CMD_RECT_GRAY:
        case CMD_RECT_GRAY_2:
//#292316
//            ESC_RECT_FILL[6] = 0x60;
            ESC_RECT_FILL[7] = (BYTE)((100 - *pdwParams) * 100 / 1111); // Gray
            goto fill;

        fill:
            if (dwCmdCbId >= CMD_RECT_BLACK_2)
                WRITESPOOLBUF(pdevobj, ESC_BEGIN_RECT, 11);
            wUnit = pOEM->wUnit ? pOEM->wUnit : 1;  // for our safety

//#292316
//            wTemp = pOEM->wRectWidth - 1;
            wTemp = pOEM->wRectWidth;

            wTemp = (WORD)(((LONG)wTemp + wUnit - 1) / wUnit * wUnit);
            ESC_RECT_FILL[9] = HIBYTE(wTemp);
            ESC_RECT_FILL[10] = LOBYTE(wTemp);

//#292316
//            wTemp = pOEM->wRectHeight - 1;
            wTemp = pOEM->wRectHeight;

            wTemp = (WORD)(((LONG)wTemp + wUnit - 1) / wUnit * wUnit);
            ESC_RECT_FILL[11] = HIBYTE(wTemp);
            ESC_RECT_FILL[12] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_RECT_FILL, 13);
            if (dwCmdCbId >= CMD_RECT_BLACK_2)
                WRITESPOOLBUF(pdevobj, ESC_END_RECT, 11);
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DisableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR_IBM=$(PRNROOT)\gpd\ibm\$(ALT_PROJECT)
GPDDIR_CAN=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)
GPDDIR_APT=$(PRNROOT)\gpd\apti\$(ALT_PROJECT)
GPDDIR_TEC=$(PRNROOT)\gpd\tec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=pagesres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),pagesres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\pagesres.rc \
    $(SRCDIR)\pagesres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\pagesres.ini \
    $(GPDDIR_APT)\ate740j.gpd \
    $(GPDDIR_APT)\ate74hj.gpd \
    $(GPDDIR_CAN)\cn5585ij.gpd \
    $(GPDDIR_IBM)\ib5584gj.gpd \
    $(GPDDIR_IBM)\ib5584kj.gpd \
    $(GPDDIR_IBM)\ib5585hj.gpd \
    $(GPDDIR_IBM)\ib5586hj.gpd \
    $(GPDDIR_IBM)\ib5587hj.gpd \
    $(GPDDIR_IBM)\ib5587kj.gpd \
    $(GPDDIR_IBM)\ib5588hj.gpd \
    $(GPDDIR_IBM)\ib5589hj.gpd \
    $(GPDDIR_IBM)\ib5589kj.gpd \
    $(GPDDIR_IBM)\ibipp20j.gpd \
    $(GPDDIR_IBM)\ibnpp12j.gpd \
    $(GPDDIR_IBM)\ibnpp17j.gpd \
    $(GPDDIR_IBM)\ibnpp24j.gpd \
    $(GPDDIR_TEC)\telbp35j.gpd \
    $(GPDDIR_TEC)\telb450j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

#if 0
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    // if (OEMResetPDEV(pdevobjOld, pdevobjNew))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

#if 0
    OEMDisablePDEV(pdevobj);
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

#if 0
    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

#if 0
    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

#if 0
    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\compress.h ===
//typedef unsigned char BYTE;

const BYTE terminator[5] = {0x1B, 0x7E, 0x01, 0x00, 0x00};


#define RL4_MAXISIZE  0xFFFE
#define RL4_MAXHEIGHT 0xFFFE
#define RL4_MAXWIDTH  4096
#define VALID     0x00
#define INVALID   0x01


LPBYTE  RL_ImagePtr;
LPBYTE  RL_CodePtr;
LPBYTE  RL_BufEnd;
WORD    RL_ImageSize;
WORD    RL_CodeSize;


WORD FAR PASCAL RL_ECmd(LPBYTE, LPBYTE, WORD);
BYTE FAR PASCAL RL_Init(LPBYTE, LPBYTE, WORD);
char FAR PASCAL RL_Enc( void );

#define RL4_BLACK     0x00
#define RL4_WHITE     0x01
#define RL4_BYTE      0x00
#define RL4_NONBYTE   0x01
#define RL4_CLEAN     0x00
#define RL4_DIRTY     0x01
#define RL4_FIRST     0x00
#define RL4_SECOND    0x01

#define COMP_FAIL     0x00
#define COMP_SUCC     0x01

#define CODBUFSZ      0x7FED     /* NOTE : THIS SHOULD MATCH THE SPACE GIVEN */
                                 /*        TO COMPRESSED DATA BY THE DEVICE  */
                                 /*        DRIVER. CHANGE THIS BASED ON YOUR */
                                 /*        OWN DISCRETION.   C.Chi           */


/* Variables */


LPBYTE  RL4_CodePtr;
LPBYTE  RL4_ImagePtr;
WORD    RL4_IWidth;
WORD    RL4_IHeight;
WORD    RL4_CurrRL;
WORD    RL4_NblCnt;
BYTE    RL4_RowAttrib;
BYTE    RL4_CurrColor;
BYTE    RL4_Status;
BYTE    RL4_Nibble;
WORD    RL4_ISize;
WORD    RL4_CodeSize;

LPBYTE  RL4_BufEnd;

BYTE    BUF_OVERFLOW;

/* macros */

#define PUTNBL(lval, nblcnt)  {                                      \
      short i;                                                       \
      for (i=nblcnt ; i>0; i--)                                      \
      {     if (RL4_Nibble==RL4_FIRST)                               \
        {   RL4_Nibble = RL4_SECOND;                                 \
                 *RL4_CodePtr = (BYTE) (lval >> ((i-1)*4)) << 4 ;    \
            } else                                                   \
        {   RL4_Nibble = RL4_FIRST;                                  \
                 *RL4_CodePtr |= (BYTE) (lval >> ((i-1)*4)) ;        \
                RL4_CodePtr++;                                       \
            if (RL4_CodePtr>RL4_BufEnd)                              \
               {  BUF_OVERFLOW = 1; return;                          \
               }                                                     \
            }                                                        \
      }                                                              \
}

/* Function Prototypes */

WORD FAR PASCAL RL4_ECmd (LPBYTE, LPBYTE, WORD, WORD, WORD);
BYTE FAR PASCAL RL4_ChkParms (LPBYTE, LPBYTE, WORD , WORD, WORD );
char FAR PASCAL RL4_Enc (void);
char FAR PASCAL RL4_ConvRow(LPBYTE);
char FAR PASCAL RL4_ConvLast(LPBYTE, WORD);
char FAR PASCAL RL4_ByteProc (BYTE);
char FAR PASCAL RL4_EncRow(LPBYTE, WORD);
WORD FAR PASCAL RL4_TransRun(WORD);
char RL4_PutNbl(long , short );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\pagesms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// 
// Copyright (C) 1994-1995 Microsoft Corporation
// Copyright (C) 1995      Advanced Peripherals Technologies, Inc.
//-----------------------------------------------------------------------------

char *rgchModuleName = "PAGESMS";

#define PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"
#include <memory.h>

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#define CCHMAXCMDLEN    128
#define MAXIMGSIZE      0x7FED   /* GDICBFilterGraphics    */
                                 /* 1AESX86M  */
                                 /* \IMAGEpB      */
                                 /* 0x7FFF - 18 =  7FED byte                 */

/*_  k */
extern WORD FAR PASCAL RL_ECmd(LPBYTE, LPBYTE, WORD);
/*_ 4 k */
extern WORD FAR PASCAL RL4_ECmd (LPBYTE, LPBYTE, WORD, WORD, WORD);

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

typedef struct tagPAGES {
    short sHorzRes;
    short sVertRes;
    LPSTR  lpCompBuf;     // k
} PAGES, FAR * LPPAGES;

static BYTE ShiftJisPAGES[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

static BYTE ESC_VERT_ON[]  = "\x1B\x7E\x0E\x00\x01\x0B";
static BYTE ESC_VERT_OFF[] = "\x1B\x7E\x0E\x00\x01\x0C";

short usHorzRes;
short usVertRes;

#ifndef WINNT
BYTE NEAR __loadds IsDBCSLeadBytePAGES(BYTE Ch)
#else
BYTE NEAR IsDBCSLeadBytePAGES(BYTE Ch)
#endif
{
return ShiftJisPAGES[Ch];
}

#ifdef WINNT
LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;
#endif // WINNT

//---------------------------*OEMSendScalableFontCmd*--------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(lpdv, lpcd, lpFont)
LPDV    lpdv;
LPCD    lpcd;     // offset to the command heap
LPFONTINFO lpFont;
{
    LPSTR   lpcmd;
    short   ocmd;
    WORD    i;
    BYTE    rgcmd[CCHMAXCMDLEN];    // build command here
    LPPAGES lpPages = lpdv->lpMdv;

    if (!lpcd || !lpFont)
        return;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd+1);
    ocmd = 0;

    for (i = 0; i < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
        if (lpcmd[i] == '#' && lpcmd[i+1] == 'V')      // height
        {
            WORD    height;

            height = (lpFont->dfPixHeight - lpFont->dfInternalLeading)
                    * (1440 / lpFont->dfVertRes);
            rgcmd[ocmd++] = HIBYTE(height);
            rgcmd[ocmd++] = LOBYTE(height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'L')     // pitch
        {
            WORD    height;

            height = lpFont->dfPixHeight * (1440 / lpFont->dfVertRes);
            rgcmd[ocmd++] = HIBYTE(height);
            rgcmd[ocmd++] = LOBYTE(height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'H')     // width
        {
            if (lpFont->dfPixWidth > 0)
            {
                short tmpWidth;

                tmpWidth = lpFont->dfMaxWidth * (1440 / lpFont->dfVertRes);

                rgcmd[ocmd++] = HIBYTE(tmpWidth);
                rgcmd[ocmd++] = LOBYTE(tmpWidth);
            }
            i += 2;
            
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'P')     // pitch
        {
            if (lpFont->dfPixWidth > 0)
            {
                short sWidth = (lpFont->dfMaxWidth * (1440/lpPages->sHorzRes));

                rgcmd[ocmd++] = HIBYTE(sWidth);
                rgcmd[ocmd++] = LOBYTE(sWidth);
            }
            i += 2;
        }
        else
            rgcmd[ocmd++] = lpcmd[i++];

    WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
}

//----------------------------*OEMScaleWidth*--------------------------------
// Action: return the scaled width which is calcualted based on the
//      assumption that ESC\Page assumes 72 points in one 1 inch.
//
// Formulas:
//  <extent> : <font units> = <base Width> : <hRes>
//  <base width> : <etmMasterHeight> = <newWidth> : <newHeight>
//  <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>
// therefore,
//   <newWidth> = (<extent> * <hRes> * <newHeight>) / 
//                  (<etmMasterUnits> * <vRes>)
//---------------------------------------------------------------------------
short FAR PASCAL OEMScaleWidth(width, masterUnits, newHeight, vRes, hRes)
short width;        // in units specified by 'masterUnits'.
short masterUnits;
short newHeight;    // in units specified by 'vRes'.
short vRes, hRes;   // height and width device units.
{
    DWORD newWidth10;
    short newWidth;

    // assert that hRes == vRes to avoid overflow problem.
    if (vRes != hRes)
        return 0;

    newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
    newWidth10 /= (DWORD)masterUnits;

    // we multiplied 10 first in order to maintain the precision of
    // the width calcution. Now convert it back and round to the
    // nearest integer.
    newWidth = (short)((newWidth10 + 5) / 10);

    return newWidth;
}

#ifndef WINNT
short FAR PASCAL __loadds OEMOutputChar( lpdv, lpstr, len, rcID)
#else
short FAR PASCAL OEMOutputChar( lpdv, lpstr, len, rcID)
#endif
LPDV	lpdv;
LPSTR	lpstr;
short	len;
short	rcID;
{

    short rSize = 0;

    if (rcID == 6 || rcID == 8)
    {
        LPSTR lpChar = lpstr, 
              lpStrTmp = lpstr;
        WORD  fLeadByteFlag = TRUE;
        int   i, j;

        for (i = 0,j = 0; i < len; j ++, i++, lpChar++)
        { 
            if (!IsDBCSLeadBytePAGES((BYTE)*lpChar)) // SBCS
            {
                if (fLeadByteFlag)
                    {
                    WriteSpoolBuf(lpdv, lpStrTmp, j);
                    WriteSpoolBuf(lpdv, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                    lpStrTmp += j;
                    j = 0;
                    fLeadByteFlag = FALSE;
                    rSize += sizeof(ESC_VERT_OFF);
                    }
            }
            else                                 // DBCS
            {
                if (!fLeadByteFlag)
                    {
                    WriteSpoolBuf(lpdv,  lpStrTmp, j);
                    WriteSpoolBuf(lpdv, ESC_VERT_ON, sizeof(ESC_VERT_ON));
                    lpStrTmp += j;
                    j = 0;
                    fLeadByteFlag = TRUE;
                    rSize += sizeof(ESC_VERT_ON);
                    }
                j ++; i++; lpChar++;
            }
        } 
        WriteSpoolBuf(lpdv, lpStrTmp, j);
    }
    else
        WriteSpoolBuf(lpdv, lpstr, len);

    return len+rSize;

}

#ifndef WINNT
short FAR PASCAL Enable( lpdv, style, lpModel, lpPort, lpStuff)
LPDV    lpdv;
WORD    style;
LPSTR   lpModel;
LPSTR   lpPort;
LPDM    lpStuff;
{
    CUSTOMDATA      cd;
    short           sRet;
    LPPAGES         lpPages;


    cd.cbSize               = sizeof( CUSTOMDATA );
    cd.hMd                  = GetModuleHandle( (LPSTR)rgchModuleName );
    cd.fnOEMDump            = NULL;
    cd.fnOEMOutputChar      = (LPFNOEMOUTPUTCHAR)OEMOutputChar;

    // In order to the Style vlalue, following process is performed.
    //      0x0000 Initialize device block.
    //      0x0001 Inquire Device GDIINFO.
    //      0x8000 Initialize device block without output. CreateIC()
    //      0x8001 Inquire Device GDIINFO without output.  CreateIC()

    sRet = UniEnable( lpdv, style, lpModel, lpPort, lpStuff, &cd );

    if (style == 0x0000)
    {
        lpdv->fMdv = FALSE;
        if (!(lpPages = lpdv->lpMdv = GlobalAllocPtr(GHND,sizeof(PAGES))))
        {
            UniDisable( lpdv );
            return FALSE;
        }
        lpdv->fMdv = TRUE;

        lpPages->sHorzRes = usHorzRes;
        lpPages->sVertRes = usVertRes;
        
    } else 
    if( style == 0x0001)
    {
        //INQUIREINFO
        usHorzRes = ((LPGDIINFO)lpdv)->dpAspectX;
        usVertRes = ((LPGDIINFO)lpdv)->dpAspectY;

    }

   return sRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void FAR PASCAL Disable(lpdv)
LPDV lpdv;
{
    if (lpdv->fMdv)
    {
        GlobalFreePtr (lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }

    UniDisable(lpdv);
}
#else //WINNT
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    LPPAGES   lpPages;


        usHorzRes = (short)((PGDIINFO)pdevcaps)->ulAspectX;
        usVertRes = (short)((PGDIINFO)pdevcaps)->ulAspectY;

        lpdv->fMdv = FALSE;
        if (!(lpPages = lpdv->lpMdv = UniDrvAllocMem(sizeof(PAGES))))
        {
            return FALSE;
        }
        if (!(lpPages->lpCompBuf = UniDrvAllocMem(MAXIMGSIZE)))
        {
            return FALSE;
        }
        lpdv->fMdv = TRUE;

        lpPages->sHorzRes = usHorzRes;
        lpPages->sVertRes = usVertRes;


    return TRUE;


}
/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{

    if (lpdv->fMdv)
    {
        UniDrvFreeMem(((LPPAGES)(lpdv->lpMdv))->lpCompBuf);
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }

}

#endif //WINNT


/*f***************************************************************************/
/*  PAGES PRINTER DRIVER for MS-Windows95                                    */
/*                                                                           */
/*  F  CBFilterGraphics                                                 */
/*                                                                           */
/*  @\F  ESX86gpoB                        */
/*                                                                           */
/*  F  WORD FAR PASCAL CBFilterGraphics(lpdv, lpBuf, wLen)              */
/*                                                                           */
/*  F  LPDV     lpdv      UNIDRV.DLLgpPDEVICE\             */
/*          LPSTR    lpBuf                     */
/*          WORD     wLen      lpBuf()                           */
/*                                                                           */
/*                                                                           */
/*  oF  return             o  @                            */
/*                                                                           */
/*  LF                                                                   */
/*                                                                           */
/*  F  1995.11.xx  Ver 1.00                                             */
/*****************************************************************************/
WORD FAR PASCAL CBFilterGraphics (lpdv, lpBuf, wLen)
LPDV      lpdv;     // Points to private data required by the Unidriver.dll
LPSTR     lpBuf;    // points to buffer of graphics data
WORD      wLen;     // length of buffer in bytes

{  
    LPSTR   lpCompImage;
    WORD    wCompLen;
    LONG    lHorzPixel;
    WORD    wLength;      // Let's use a temporary LEN
    LPPAGES lpPages = lpdv->lpMdv;

//#define MAXIMGSIZE  0x7FED          // 32K-18 bytes
static BYTE params[] = {(0x1B), (0x7E), (0x86), 00,00, 01, 00, 00,00,00,00, 00,00,00,00, 00,00,00,00, 00,00,00,01};


    /*_ LPDV */
    lpCompImage = lpPages->lpCompBuf;

    /*_ iISIZvZB */
    lHorzPixel = (LONG)(wLen * 8);

    /*_ C[Wf[^Btye Run Length AlgorithmkB */
    wCompLen = RL_ECmd((LPBYTE)lpBuf, (LPBYTE)lpCompImage, wLen);

    /*_ kESX86LENOB */
    wLength = wCompLen + 18;

    /*_ ESX86R}hLENZbgB */
    params[3] = (BYTE) (wLength >>8 & 0x00ff);    // get higher byte
    params[4] = (BYTE) (wLength & 0x00ff);        // get lower byte

    /*_ k@p[^Byte Run LengthZbgB */
    params[6] = 0x02;

    /*_ ESX86R}hISIZZbgB */
    params[17] = (BYTE) (lHorzPixel >> 8 & 0x000000ffL);   // get ISZ higher byte
    params[18] = (BYTE) (lHorzPixel & 0x000000ffL);        // get ISZ lower byte

    /*_ ESX86R}hXv[oB */
    WriteSpoolBuf((LPDV)lpdv, (LPSTR)params, 23);

    /*_ kf[^Xv[oB */
    WriteSpoolBuf((LPDV)lpdv, lpCompImage, wCompLen);

    return wLen;
}

// The following is implemented in MiniDrvEnablePDEV/DisablePDEV
// on NT-J.  We do not simulate Control DDI call, and it is not
// guranteed that STARTOC, etc. always corresponds to minidriver
// enable/disable.

#ifndef WINNT

/*f***************************************************************************/
/*  PAGES PRINTER DRIVER for MS-Windows95                                    */
/*                                                                           */
/*  F  Control                                                          */
/*                                                                           */
/*  @\F  Calls Escape function from applications		                     */
/*                                                                           */
/*  F  short FAR PASCAL Control(lpdv, nFunction,                        */
/*                                             lpInData, lpOutData)          */
/*                                                                           */
/*  F  LPDV        lpdv        PDEVICE structure                        */
/*          WORD        function    Subfunction ID                           */
/*          LPSTR       lpInData    Input data                               */
/*          LPSTR       lpOutData   Output data                              */
/*                                                                           */
/*  oF  short ret   Positive :    Normal exit                            */
/*                      Negative :    Error exit                             */
/*                      FALSE  :      No escape subfunction                  */
/*                                                                           */
/*  LF  nFunction and Escape numbers are the same                        */
/*                                                                           */
/*  F  1995.12.xx  Ver 1.00                                             */
/*                                                                           */
/*****************************************************************************/
short FAR PASCAL Control(LPDV  lpdv,
                         WORD  function,
                         LPSTR lpInData,
                         LPSTR lpOutData)
{
    LPPAGES lpPages = lpdv->lpMdv;

    switch (function)
    {
        /*_ STARTDOCAkpmB */
        case STARTDOC :
            lpPages->lpCompBuf = GlobalAllocPtr(GHND,MAXIMGSIZE);
            break;

        /*_ ABORTDOC,ENDDOCAkpB */
        case ABORTDOC :
        case ENDDOC :
            GlobalFreePtr (lpPages->lpCompBuf);
            break;
    }

    /*_ UNIDRVControl DDI */
    return UniControl(lpdv, function, lpInData, lpOutData);
}
#endif //!WINNT


#ifdef WINNT
DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMScaleWidth1,          (PFN)OEMScaleWidth  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\compress.c ===
#include <windows.h>
#include "compress.h"


/*********************************************************/
/*  RL_ECmd  : main function                             */
/*  ARGS     : LPBYTE - pointer to image                 */
/*             LPBYTE - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : WORD   - size of BRL Code                 */
/*             0      - COMPRESSION FAILED               */
/*********************************************************/
WORD FAR PASCAL RL_ECmd(LPBYTE iptr, LPBYTE cptr, WORD isize)
{
   if (RL_Init(iptr, cptr, isize)==VALID)
      RL_Enc();
   if (BUF_OVERFLOW)
      return 0;
   else
      return RL_CodeSize;
}

/*********************************************************/
/*  RL_Init  : Initializer                               */
/*  ARGS     : BYTE * - pointer to image                 */
/*             BYTE * - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : BYTE   - VALID or INVALID                 */
/*********************************************************/

BYTE FAR PASCAL RL_Init(LPBYTE iptr, LPBYTE cptr, WORD isize)
{
   RL_ImagePtr = iptr;
   RL_CodePtr = cptr;
   RL_ImageSize = isize;
   BUF_OVERFLOW = 0;
   RL_BufEnd = cptr + CODBUFSZ;
   return VALID;
}

/*********************************************************/
/*  RL_Enc   : Encoder                                   */
/*  ARGS     : void                                      */
/*  RET      : char   COMP_SUCC or COMP_FAIL             */
/*********************************************************/
char FAR PASCAL RL_Enc(void)
{
int     repcnt;
BYTE   refbyt;
WORD    i;

   i = 0;
   repcnt = 0;
   RL_CodeSize = 0;
   refbyt = RL_ImagePtr[0];
   //@CC 12.22.94 for (i=1;i<=RL_ImageSize; i++)
   //@TO 12/01/1995   for (i=1;i<RL_ImageSize;i++)
   for (i=1;i<=RL_ImageSize;i++)
   {
       if ((RL_ImagePtr[i] == refbyt)&&(repcnt<255)&&(i!=RL_ImageSize-1))
          repcnt++;
       else
       {
          //-> @CC 12.22.94
          if ((RL_ImagePtr[i] == refbyt)&&(repcnt<255))
             repcnt++;
          //<- @CC 12.22.94
          if (RL_CodePtr > RL_BufEnd)
             {BUF_OVERFLOW = 1; return COMP_FAIL;}
          RL_CodePtr[0] = repcnt;
          RL_CodePtr[1] = refbyt;
          RL_CodePtr += 2;
          RL_CodeSize += 2;
          refbyt = RL_ImagePtr[i];
          repcnt = 0;
       }
   }
   return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ECmd                                               */
/*      @\@: main entry point                                       */
/*      @: code size = RL4_ECmd(iptr, cptr, isz, iwd, iht)        */
/*      @: LPBYTE      -    pointer to image                      */
/*              LPBYTE      -    pointer to code                       */
/*              WORD        -    size of image IN BYTES !!!            */
/*              WORD        -    image width                           */
/*              WORD        -    height of image                       */
/*      o@: WORD        -    size of RL4 code                      */
/*              0           -    COMPRESSION FAILED                    */
/*      L@:                                                        */
/*      @:  1993. 1.27 initial                                    */
/***********************************************************************/
WORD FAR PASCAL RL4_ECmd(LPBYTE iptr, LPBYTE cptr, WORD sz, WORD wd, WORD ht)
{
char status;

if (RL4_ChkParms( iptr, cptr, sz, wd, ht ) == VALID)
if ((status=RL4_Enc())==COMP_FAIL)
   return 0;
else
   return RL4_CodeSize;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ChkParms                                           */
/*      @\@: checks input parameters if valid and sets internal     */
/*              variables if they are                                  */
/*      @: ret val = RL4_ChkParms(iptr, cptr, isz, iwd, iht)      */
/*      @: LPBYTE     -    pointer to image                       */
/*              LPBYTE     -    pointer to code                        */
/*              WORD    -    size of image                             */
/*              WORD    -    image width IN BYTES !!!                  */
/*              WORD    -    height of image                           */
/*      o@: BYTE       -    VALID or INVALID                       */
/*      L@:                                                        */
/*      @:  1994. 1.25 initial                                    */
/*               1994. 2.12 clean up                                   */
/***********************************************************************/
BYTE FAR PASCAL RL4_ChkParms(LPBYTE iptr, LPBYTE cptr, WORD isz, WORD iwd, WORD iht)
{
    if ((isz > RL4_MAXISIZE)||
       ((iht != isz/iwd+1)&&(iht != isz/iwd))||
       (iht <= 0)||
       (iht > RL4_MAXHEIGHT)||
       (iwd <= 0)||
       (iwd > RL4_MAXWIDTH))
    return INVALID;
    else
       {
          RL4_ImagePtr = iptr;
          RL4_CodePtr = cptr;
          RL4_IHeight = iht;
          RL4_IWidth = iwd;
          RL4_ISize = isz;

          RL4_BufEnd = cptr + CODBUFSZ;  /* please define CODBUFSZ in header */
                                         /* file COMPRESS.H                  */
          BUF_OVERFLOW = 0;
          return VALID;
       }
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_Enc                                                */
/*      @\@: encodes image to RL4 code                              */
/*      @: RL4_Enc()                                              */
/*      @: void                                                   */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/*               1994. 2.12 added RL4_ConvLast                         */
/***********************************************************************/
char FAR PASCAL RL4_Enc(void) {

LPBYTE rowptr, codeptr;
WORD rownum, lrlen;
long isize,  diff;

    RL4_Nibble = RL4_FIRST;
    rowptr = RL4_ImagePtr;
    RL4_CodeSize = 0;
    isize = 0;
    lrlen = RL4_ISize%RL4_IWidth;
    if (lrlen == 0)
       lrlen = RL4_IWidth;
    diff = RL4_ISize-RL4_IWidth;
    for ( rownum = 0; rownum < RL4_IHeight; rownum++ )
    {
       codeptr = RL4_CodePtr;
       if (isize < diff)
        {
          RL4_ConvRow(rowptr);
          if (BUF_OVERFLOW) return COMP_FAIL;
        }
       else
       {
       RL4_ConvLast(rowptr,lrlen);
       if (BUF_OVERFLOW) return COMP_FAIL;
       }
       if (RL4_RowAttrib == RL4_DIRTY) /* Encode only rows with '1' bits */
          RL4_EncRow(codeptr, rownum);
       else
       RL4_CodePtr -= 4;
       rowptr += RL4_IWidth;
       isize += RL4_IWidth;
     }
     return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ConvRow                                            */
/*      @\@: translates runs in a row to RL4 code                   */
/*      @: RL4_ConvRow(rowptr)                                    */
/*      @: LPBYTE       -   pointer to a row of image            */
/*      o@: void                                                   */
/*      L@: excluding last row                                     */
/*      @: 1993. 1.25 initial                                     */
/***********************************************************************/
char FAR PASCAL RL4_ConvRow(LPBYTE rowptr){

WORD bytenum;
        RL4_CurrRL = 0;
        RL4_CurrColor = RL4_WHITE;
        RL4_Status = RL4_BYTE;
        RL4_CodePtr += 4;
        RL4_NblCnt = 0;
        for( bytenum = 0; bytenum < RL4_IWidth; bytenum++ )
        {
           RL4_ByteProc(rowptr[bytenum]);
           if (BUF_OVERFLOW) return COMP_FAIL;
        }
        if ((RL4_CurrColor == RL4_WHITE)&&(RL4_CurrRL==RL4_IWidth*8)) /* all '0' bits */
           RL4_RowAttrib = RL4_CLEAN;
        else
           RL4_RowAttrib = RL4_DIRTY;
        return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ConvLast                                           */
/*      @\@: translates runs in a row to RL4 code                   */
/*      @: RL4_ConvLast(rowptr, lrlen)                            */
/*      @: LPBYTE       -   pointer to a row of image             */
/*              WORD      -   length of last row                       */
/*      o@: void                                                   */
/*      L@: for image data whose last row is not exactly           */
/*              RL4_Width bytes wide                                   */
/*      @: 1993. 2.12 added to eliminate extra bytes in code      */
/*              1994. 6.08 made attrib always dirty so that last row   */
/*                         is always encoded                           */
/***********************************************************************/
char FAR PASCAL RL4_ConvLast(LPBYTE rowptr, WORD lrlen){

WORD bytenum;

 RL4_CurrRL = 0;
 RL4_CurrColor = RL4_WHITE;
 RL4_Status = RL4_BYTE;
 RL4_CodePtr += 4;
 RL4_NblCnt = 0;
 RL4_RowAttrib = RL4_DIRTY;
 for( bytenum = 0; bytenum < lrlen; bytenum++ )
 {
   RL4_ByteProc(rowptr[bytenum]);
   if (BUF_OVERFLOW) return COMP_FAIL;
  }
 return COMP_SUCC;
}
/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ByteProc                                           */
/*      @\@: processes one byte of image data                       */
/*      @: RL4_ByteProc(ibyte)                                    */
/*      @: BYTE       -   one byte of image data                  */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
char FAR PASCAL RL4_ByteProc (BYTE ibyte)
{
BYTE mask;     /* mask bits from '1000 0000' to '0000 0001' */
int i;

      mask = 0x80;
      for ( i = 0; i < 8; i++ )
      { if (ibyte & mask)    /* Next bit is black */
           { if (RL4_CurrColor==RL4_WHITE)
                { RL4_CurrColor = RL4_BLACK;
                  RL4_NblCnt += RL4_TransRun(RL4_CurrRL);
                  if (BUF_OVERFLOW) return COMP_FAIL;
                  if (RL4_NblCnt & 1)           /* Check if even or odd # of nibbles */
                     RL4_Status = RL4_NONBYTE;
                  else
                     RL4_Status = RL4_BYTE;
                  RL4_CurrRL = 1;
                }
             else if (RL4_CurrColor==RL4_BLACK)
                     RL4_CurrRL++;
           }
      else  /* Next bit is white */
         { if (RL4_CurrColor==RL4_BLACK)
             { RL4_CurrColor = RL4_WHITE;
               RL4_NblCnt += RL4_TransRun (RL4_CurrRL);
               if (BUF_OVERFLOW) return COMP_FAIL;
               if (RL4_NblCnt & 1)           /* Check if even or odd # of nibbles */
                  RL4_Status = RL4_NONBYTE;
               else
                  RL4_Status = RL4_BYTE;
               RL4_CurrRL = 1;
             }
           else if (RL4_CurrColor==RL4_WHITE)
                   RL4_CurrRL++;
         }
        mask >>= 1;
       }
       return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_EncRow                                             */
/*      @\@: encodes row number, code length, and End-of-Row code   */
/*      @: RL4_EncRow(codeptr, rownum)                            */
/*      @: LPBYTE        - pointer to RL4 code                   */
/*              WORD  - no. of row being encoded              */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
char FAR PASCAL RL4_EncRow(LPBYTE codeptr, WORD rownum){
short codelen;

        codelen = 0;
        *codeptr = (BYTE) (rownum >>8);
        codeptr[1] = (BYTE) rownum;
        if(RL4_Status==RL4_BYTE){
           RL4_NblCnt += 2;
           RL4_PutNbl(0xFFl,2);        /* Append 0xFF to code */
           if (BUF_OVERFLOW) return COMP_FAIL;
        } else {
        RL4_NblCnt += 3;
        RL4_PutNbl(0xFFFl,3); /* Append 0xFFF to code */
        if (BUF_OVERFLOW) return COMP_FAIL;
        }
        codelen = RL4_NblCnt/2;
        codeptr[2] = (BYTE) (codelen >>8);
        codeptr[3] = (BYTE) codelen;
        RL4_CodeSize += codelen + 4;
        return COMP_SUCC;
}


/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_TransRun                                           */
/*      @\@: translates run length value to RL4 code                */
/*      @: nibble count = RL4_TransRun(rlval)                     */
/*      @: short         -   run length value to be encoded       */
/*      o@: short         -   no. of nibbles appended              */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
WORD FAR PASCAL RL4_TransRun(WORD rlval){
WORD nblcnt;
long lval;
     if (rlval == 0) { lval = 0xFEl;
                       nblcnt = 2; }

     else if (rlval<=8) { lval = (long) (rlval)-1l;
                                        nblcnt = 1; }
     else if (rlval<=72) {lval = (long) (rlval)+119l;
                                        nblcnt = 2; }
     else if (rlval<=584) { lval = (long) (rlval)+2999l;
                                           nblcnt = 3; }
     else if (rlval<=4680) { lval = (long) (rlval)+56759l;
                                             nblcnt = 4; }
     else if (rlval<=32767) { lval = (long) (rlval)+978359l;
                                               nblcnt = 5; }
/*     PUTNBL(lval, nblcnt)*/
     RL4_PutNbl(lval, nblcnt);
     if (BUF_OVERFLOW) return COMP_FAIL;
     return nblcnt;
}

char RL4_PutNbl(long lval2, short nblcnt2)  {
{
      short i;
      for (i=nblcnt2 ; i>0; i--)
      {     if (RL4_Nibble==RL4_FIRST)
        {   RL4_Nibble = RL4_SECOND;
                 *RL4_CodePtr = (BYTE) (lval2 >> ((i-1)*4)) << 4 ;
            } else
        {   RL4_Nibble = RL4_FIRST;
                 *RL4_CodePtr |= (BYTE) (lval2 >> ((i-1)*4)) ;
                RL4_CodePtr++;
                if (RL4_CodePtr>RL4_BufEnd)
                   {BUF_OVERFLOW = 1; return COMP_FAIL;}
            }
      }
      return COMP_SUCC;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl4jres\etc\pcl4msj.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//
//-----------------------------------------------------------------------------

#include "strings.h"


// #define CONVERT_FROM_WIN30

char *rgchModuleName   = "PCL4MSJ";
char szSoftFonts[]     = "SoftFonts";

#ifdef CONVERT_FROM_WIN30
char szPrtIndex[]      = "prtindex";
char szWinVer[]        = "winver";
char sz310[]           = "310";
char sz150[]           = "150";
char sz75[]            = "75";
char szNull[]          = "";
char szOrient[]        = "orient";
char szOrientation[]   = "Orientation";
char szPaper[]         = "paper";
char szPaperSize[]     = "Paper Size";
char szPrtResFac[]     = "prtresfac";
char szPrintQuality[]  = "Print Quality";
char szTray[]          = "tray";
char szDefaultSource[] = "Default Source";
char szNumCart[]       = "numcart";
char szCartIndex[]     = "cartindex";
char szCartridge[]     = "Cartridge ";
char szNumberCart[]    = "Number of Cartridges";
char szFsVers[]        = "fsvers";
char szFontSummary[]   = "Font Summary";

// map old HPPCL's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL .rc file.
int rgNewCartMap[9] = {8, 7, 2, 3, 5, 6, 1, 4, 0};

#endif


#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "mdevice.h"



#define DELETE_OLD

#ifndef WINNT
HDC   FAR PASCAL CreateIC(LPCSTR, LPCSTR, LPCSTR, const VOID FAR*);
BOOL  FAR PASCAL DeleteDC(HDC);
#endif // !WINNT

#include "unidrv.h"


#ifndef WINNT
extern char *rgchModuleName;	// global module name

// typedef for soft font installer
typedef int (FAR PASCAL *SFPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

#define SOFT_FONT_THRES 25	    // build font summary, if over this limit
#define MAX_CART_INDEX	33
#define MAX_OLD_CART	24
#define TMPSIZE         256

HINSTANCE hInst;

#ifdef PRTCAPSTUFF

char szPrtCaps[]       = "prtcaps";

#define MAX_NUM_MODELS	24
#define MAX_MODEL_NAME	29
typedef struct
    {
    char szModel[MAX_MODEL_NAME];
    int  rgIndexLimit[2];
    char szPrtCaps[7];	    // keep as a string instead of integer to avoid
			    // conversion because itoa doesn't work here.
    } MODELMAP, FAR * LPMODELMAP;



//-------------------------------------------------------------------
// Function: DoPrtCapsStuff(lpDevName,lpPort)
//
// Action: Write out PRTCAPS under [<model>,<port>] section
//         in order to be backward-compatible with existing font
//         packages. Note that this code can fail
//         under extremely low memory conditions, so be sure and check
//         the return values from the resource calls.
//-------------------------------------------------------------------
void NEAR PASCAL DoPrtCapsStuff(LPSTR lpDevName,
                                LPSTR lpPort)
{
  char szOldSec[64];
  int  i;
  HANDLE  hMd;
  HANDLE  hResMap;
  LPMODELMAP	lpModelMap;


  lstrcpy(szOldSec,lpDevName);
  MakeAppName((LPSTR)szOldSec,lpPort,sizeof(szOldSec));

  hMd=GetModuleHandle((LPSTR)rgchModuleName);
  hResMap=LoadResource(hMd,FindResource(hMd,MAKEINTRESOURCE(1),RT_RCDATA));
  if(hResMap)
  {
    if(lpModelMap=(LPMODELMAP)LockResource(hResMap))
    {
      for (i=0;i<MAX_NUM_MODELS;i++)
      {
        if (!lstrcmp(lpDevName,(LPSTR)(lpModelMap[i].szModel)))
        {
          WriteProfileString((LPSTR)szOldSec,szPrtCaps,
                            (LPSTR)lpModelMap[i].szPrtCaps);
          break;
        }
      }
      UnlockResource(hResMap);
    }
    FreeResource(hResMap);
  }
}


#endif

//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
		    WORD   wDataSeg,
		    WORD   cbHeapSize,
		    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}




//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
  short   length, count;
  LPCSTR  lpTmp;
  LPCSTR  lpLastColon = NULL;

  length = lstrlen(lpAppName);

  if (!lpPortName)
    return length;

  if (length == 0 || length > max - lstrlen(lpPortName))
    return -1;

  // insert the comma
  lpAppName[length++] = ',';

  // append the port name but do not want the last ':', if any.
  for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
    if (*lpTmp == ':')
      lpLastColon = lpTmp;
    if (lpLastColon && lpLastColon == lpTmp - 1)
      count = lpLastColon - lpPortName;
    else
      count = lpTmp - lpPortName;

  lstrcpy((LPSTR)&lpAppName[length], lpPortName);

  length += count;
  lpAppName[length]='\0';

  return length;
}

#ifdef CONVERT_FROM_WIN30

//------------------------------------------------------------------------------
// Function: itoa
//
// Action:  This function converts the given integer into an ASCII string.
//
// return:  The length of the string.
//-----------------------------------------------------------------------------

short NEAR PASCAL itoa(buf, n)
LPSTR buf;
short n;
{
    short   fNeg;
    short   i, j;

    if (fNeg = (n < 0))
	n = -n;

    for (i = 0; n; i++)
	{
	buf[i] = (char)(n % 10 + '0');
	n /= 10;
	}

    // n was zero
    if (i == 0)
	buf[i++] = '0';

    if (fNeg)
	buf[i++] = '-';

    for (j = 0; j < i / 2; j++)
	{
	short tmp;

	tmp = buf[j];
	buf[j] = buf[i - j - 1];
	buf[i - j - 1] = (char)tmp;
	}

    buf[i] = 0;

    return i;
}

#endif


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------

int FAR PASCAL DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND	hWnd;
LPSTR	lpDevName;
LPSTR	lpOldPort, lpNewPort;
{
    char szOldSec[64];
    int  nReturn=1;

    if (!lpDevName)
	    return -1;

    if (!lpOldPort)
	{
#ifdef CONVERT_FROM_WIN30
        char szNewSec[64];
	    char szBuf[32];
	    int  tmp;
	    int  i, index;
	    HANDLE	hMd;
	    HANDLE	hResMap;
	    LPMODELMAP  lpModelMap;
#endif

	    if (!lpNewPort)
	        return 0;

#ifdef CONVERT_FROM_WIN30
	    // install a device for the first time. Convert old HPPCL settings,
	    // which are still under [<driver>,<port>], into equivalent new
	    // UNIDRV settings under [<device>,<port>], if applicable.
	    // All soft fonts are left under the section [<driver>,<port>].
	    lstrcpy(szOldSec,rgchModuleName);
	    MakeAppName((LPSTR)szOldSec, lpNewPort, sizeof(szOldSec));

	    // if old section exists at all
	    if (!GetProfileString(szOldSec, NULL, NULL, szBuf, sizeof(szBuf)))
	        goto DI_exit;

	    // make sure the old device settings are for this device.
	    // If not, there is nothing to do here. Simply return 1.
	    tmp = GetProfileInt(szOldSec, szPrtIndex, 0);
	    hMd = GetModuleHandle((LPSTR)rgchModuleName);
	    hResMap = LoadResource(hMd,
			    FindResource(hMd, MAKEINTRESOURCE(1), RT_RCDATA));
	    lpModelMap = (LPMODELMAP)LockResource(hResMap);
	    for (i = 0; i < MAX_NUM_MODELS; i++)
        {
	        if (!lstrcmp(lpDevName, (LPSTR)lpModelMap[i].szModel))
		    {
		        if ((tmp < lpModelMap[i].rgIndexLimit[0]) ||
		            (tmp > lpModelMap[i].rgIndexLimit[1]) )
		            i = MAX_NUM_MODELS;        // not this model. No conversion.
		        break;
		    }
        }

	    UnlockResource(hResMap);
	    FreeResource(hResMap);

	    if (i >= MAX_NUM_MODELS)
	        // this model is not even listed in the old HPPCL driver.
	        goto DI_exit;

	    if (GetProfileInt(szOldSec, szWinVer, 0) == 310)
	        goto DI_exit;

	    WriteProfileString(szOldSec, szWinVer, sz310);
#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtIndex, NULL);
#endif

	    lstrcpy(szNewSec, lpDevName);
	    MakeAppName((LPSTR)szNewSec, lpNewPort, sizeof(szNewSec));

	    // convertable device settings include: copies, duplex, orient,
	    // paper, prtresfac, tray, and cartidges.

	    if (GetProfileString(szOldSec, szOrient, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szOrientation, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szOrient, NULL);
#endif
        }
	    if (GetProfileString(szOldSec, szPaper, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szPaperSize, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szPaper, NULL);
#endif
        }

	    // default to 2 if cannot find it
	    tmp = GetProfileInt(szOldSec, szPrtResFac, 2);

	    if (tmp == 1)
	        WriteProfileString(szNewSec, szPrintQuality, sz150);
	    else if (tmp == 2)
	        WriteProfileString(szNewSec, szPrintQuality, sz75);

#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtResFac, NULL);
#endif

	    if (GetProfileString(szOldSec, szTray, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szDefaultSource, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szTray, NULL);
#endif
        }

	    // try to convert the cartridge information.

	    if ((tmp = GetProfileInt(szOldSec, szNumCart, 0)) == 0)
	        tmp = 1;

	    // this is executed at least once
	    {
	        char szOldCartKey[16];
	        char szNewCartKey[16];
	        char nCart = 0;

	        lstrcpy(szOldCartKey, szCartIndex);

	        for (i = 0; i < tmp; i++)
	        {
	            if (i > 0)
                    itoa((LPSTR)&szOldCartKey[9], i);
	            // compose cartridge keyname under UNIDRV.
	            lstrcpy(szNewCartKey, szCartridge);
	            itoa((LPSTR)&szNewCartKey[10], i + 1);

	            if ((index = GetProfileInt(szOldSec, szOldCartKey, 0)) > 0)
		        {
		            WriteProfileString(szOldSec, szOldCartKey, NULL);
		            nCart++;
		            if (index <= MAX_OLD_CART)
		            {
		                itoa((LPSTR)szBuf, index + 8);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else if (index <= MAX_CART_INDEX)
		            {
		                itoa((LPSTR)szBuf, rgNewCartMap[index - MAX_OLD_CART - 1]);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else
		            {
		                // external cartridges. Simply copy the id over.
		                itoa((LPSTR)szBuf, index);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		        }
	        }

	        // integer to ASCII string conversion.
	        itoa((LPSTR)szBuf, nCart);
	        WriteProfileString(szNewSec, szNumberCart, szBuf);
	    }

	    // delete the old font summary file
	    WriteProfileString(szOldSec, szFsVers, NULL);
	    if (GetProfileString(szOldSec, szFontSummary, szNull, szBuf, sizeof(szBuf)) > 0)
	    {
	        int hFS;

	        // truncate the old font summary file to zero size.
	        if ((hFS = _lcreat(szBuf, 0)) >= 0)
		        _lclose(hFS);
	        WriteProfileString(szOldSec, szFontSummary, NULL);
	    }

            // create UNIDRV's font summary file, if there are many soft fonts.
	    if (GetProfileInt(szOldSec, szSoftFonts, 0) > SOFT_FONT_THRES)
	    {
	        HDC hIC;

	        if (hIC = CreateIC("PCL4MSJ", lpDevName, lpNewPort, NULL))
		        DeleteDC(hIC);
	    }
#endif
	}
    else

    {

	// move device settings from the old port to the new port, or
	// de-install a device, i.e. remove its device setttings in order
	// to compress the profile.

	// First, check if there is any  soft font installed under the
	// old port. If so, warn the user to copy them over.

	lstrcpy(szOldSec, rgchModuleName);
	MakeAppName((LPSTR)szOldSec, lpOldPort, sizeof(szOldSec));
	if (GetProfileInt(szOldSec, szSoftFonts, 0) > 0 && lpNewPort)
	{
            LPBYTE lpTemp;

            if(lpTemp=GlobalAllocPtr(GMEM_MOVEABLE,TMPSIZE))
	    {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,lpTemp,TMPSIZE))
		{
		    // Use this API so that the M Box is set to the Foreground
		    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
		    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = lpTemp;
		    mbp.lpszCaption = lpOldPort;
		    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
		    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
		GlobalFreePtr (lpTemp);
	    }
	}
    nReturn=UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);
    }


#ifdef CONVERT_FROM_WIN30
DI_exit:
#endif

#ifdef PRTCAPSTUFF

    DoPrtCapsStuff(lpDevName,lpNewPort);

#endif

    return nReturn;
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND	hWnd;
LPSTR	lpDeviceName;
LPSTR	lpPortName;
BOOL	bSoftFonts;
{
    int     fsVers;
    HANDLE  hFIlib;
    SFPROC  lpFIns;

    if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
	{
	    if (hFIlib >= 32)
	        FreeLibrary(hFIlib);
#ifdef DEBUG
	    MessageBox(0,
	        "Can't load FINSTALL.DLL or can't get InstallSoftFont",
	        NULL, MB_OK);
#endif
	    return TRUE;
	}

    // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
    // We choose to ignore the returned fvers. No use of it.
    fsVers = (*lpFIns)(hWnd, rgchModuleName, lpPortName,
		(GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0),
		1,	  // dummy value for fvers.
		bSoftFonts ? CLASS_LASERJET : 256
		);
    FreeLibrary(hFIlib);
    return fsVers;
}


#endif // !WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_SOFTFONTWARNING   4890
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\jp3500p.c ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "JP3500P";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#define MB_SETFOREGROUND    0x00010000
#if (WINVER >= 0x0400)
typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMS
{
    DWORD           cbSize;
#ifdef tagWND
    HWND_16         hwndOwner;
#else
    HWND            hwndOwner;
#endif
    HINSTANCE       hInstance;
    LPCSTR          lpszText;
    LPCSTR          lpszCaption;
    DWORD           dwStyle;
    LPCSTR          lpszIcon;
    DWORD           dwContextHelpId;
    MSGBOXCALLBACK  lpfnMsgBoxCallback;
    DWORD           dwLanguageId;
}   MSGBOXPARAMS, FAR *LPMSGBOXPARAMS;

int     WINAPI MessageBoxIndirect(LPMSGBOXPARAMS);
#endif /* WINVER >=0x0400 */

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\pcl4ch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//
//-----------------------------------------------------------------------------

#include "strings.h"


// #define CONVERT_FROM_WIN30

char *rgchModuleName   = "PCL4CH";
char szSoftFonts[]     = "SoftFonts";

#ifdef CONVERT_FROM_WIN30
char szPrtIndex[]      = "prtindex";
char szWinVer[]        = "winver";
char sz310[]           = "310";
char sz150[]           = "150";
char sz75[]            = "75";
char szNull[]          = "";
char szOrient[]        = "orient";
char szOrientation[]   = "Orientation";
char szPaper[]         = "paper";
char szPaperSize[]     = "Paper Size";
char szPrtResFac[]     = "prtresfac";
char szPrintQuality[]  = "Print Quality";
char szTray[]          = "tray";
char szDefaultSource[] = "Default Source";
char szNumCart[]       = "numcart";
char szCartIndex[]     = "cartindex";
char szCartridge[]     = "Cartridge ";
char szNumberCart[]    = "Number of Cartridges";
char szFsVers[]        = "fsvers";
char szFontSummary[]   = "Font Summary";

// map old HPPCL's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL .rc file.
int rgNewCartMap[9] = {8, 7, 2, 3, 5, 6, 1, 4, 0};

#endif


#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "mdevice.h"



#define DELETE_OLD

#ifndef WINNT
HDC   FAR PASCAL CreateIC(LPCSTR, LPCSTR, LPCSTR, const VOID FAR*);
BOOL  FAR PASCAL DeleteDC(HDC);
#endif  // WINNT

#include "unidrv.h"


#ifndef WINNT
extern char *rgchModuleName;	// global module name

// typedef for soft font installer
typedef int (FAR PASCAL *SFPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

#define SOFT_FONT_THRES 25	    // build font summary, if over this limit
#define MAX_CART_INDEX	33
#define MAX_OLD_CART	24
#define TMPSIZE         256

HINSTANCE hInst;

#ifdef PRTCAPSTUFF

char szPrtCaps[]       = "prtcaps";

#define MAX_NUM_MODELS	24
#define MAX_MODEL_NAME	29
typedef struct
    {
    char szModel[MAX_MODEL_NAME];
    int  rgIndexLimit[2];
    char szPrtCaps[7];	    // keep as a string instead of integer to avoid
			    // conversion because itoa doesn't work here.
    } MODELMAP, FAR * LPMODELMAP;



//-------------------------------------------------------------------
// Function: DoPrtCapsStuff(lpDevName,lpPort)
//
// Action: Write out PRTCAPS under [<model>,<port>] section
//         in order to be backward-compatible with existing font
//         packages. Note that this code can fail
//         under extremely low memory conditions, so be sure and check
//         the return values from the resource calls.
//-------------------------------------------------------------------
void NEAR PASCAL DoPrtCapsStuff(LPSTR lpDevName,
                                LPSTR lpPort)
{
  char szOldSec[64];
  int  i;
  HANDLE  hMd;
  HANDLE  hResMap;
  LPMODELMAP	lpModelMap;


  lstrcpy(szOldSec,lpDevName);
  MakeAppName((LPSTR)szOldSec,lpPort,sizeof(szOldSec));

  hMd=GetModuleHandle((LPSTR)rgchModuleName);
  hResMap=LoadResource(hMd,FindResource(hMd,MAKEINTRESOURCE(1),RT_RCDATA));
  if(hResMap)
  {
    if(lpModelMap=(LPMODELMAP)LockResource(hResMap))
    {
      for (i=0;i<MAX_NUM_MODELS;i++)
      {
        if (!lstrcmp(lpDevName,(LPSTR)(lpModelMap[i].szModel)))
        {
          WriteProfileString((LPSTR)szOldSec,szPrtCaps,
                            (LPSTR)lpModelMap[i].szPrtCaps);
          break;
        }
      }
      UnlockResource(hResMap);
    }
    FreeResource(hResMap);
  }
}


#endif

//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
		    WORD   wDataSeg,
		    WORD   cbHeapSize,
		    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}




//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
  short   length, count;
  LPCSTR  lpTmp;
  LPCSTR  lpLastColon = NULL;

  length = lstrlen(lpAppName);

  if (!lpPortName)
    return length;

  if (length == 0 || length > max - lstrlen(lpPortName))
    return -1;

  // insert the comma
  lpAppName[length++] = ',';

  // append the port name but do not want the last ':', if any.
  for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
    if (*lpTmp == ':')
      lpLastColon = lpTmp;
    if (lpLastColon && lpLastColon == lpTmp - 1)
      count = lpLastColon - lpPortName;
    else
      count = lpTmp - lpPortName;

  lstrcpy((LPSTR)&lpAppName[length], lpPortName);

  length += count;
  lpAppName[length]='\0';

  return length;
}

#ifdef CONVERT_FROM_WIN30

//------------------------------------------------------------------------------
// Function: itoa
//
// Action:  This function converts the given integer into an ASCII string.
//
// return:  The length of the string.
//-----------------------------------------------------------------------------

short NEAR PASCAL itoa(buf, n)
LPSTR buf;
short n;
{
    short   fNeg;
    short   i, j;

    if (fNeg = (n < 0))
	n = -n;

    for (i = 0; n; i++)
	{
	buf[i] = (char)(n % 10 + '0');
	n /= 10;
	}

    // n was zero
    if (i == 0)
	buf[i++] = '0';

    if (fNeg)
	buf[i++] = '-';

    for (j = 0; j < i / 2; j++)
	{
	short tmp;

	tmp = buf[j];
	buf[j] = buf[i - j - 1];
	buf[i - j - 1] = (char)tmp;
	}

    buf[i] = 0;

    return i;
}

#endif


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------

int FAR PASCAL DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND	hWnd;
LPSTR	lpDevName;
LPSTR	lpOldPort, lpNewPort;
{
    char szOldSec[64];
    int  nReturn=1;

    if (!lpDevName)
	    return -1;

    if (!lpOldPort)
	{
#ifdef CONVERT_FROM_WIN30
        char szNewSec[64];
	    char szBuf[32];
	    int  tmp;
	    int  i, index;
	    HANDLE	hMd;
	    HANDLE	hResMap;
	    LPMODELMAP  lpModelMap;
#endif

	    if (!lpNewPort)
	        return 0;

#ifdef CONVERT_FROM_WIN30
	    // install a device for the first time. Convert old HPPCL settings,
	    // which are still under [<driver>,<port>], into equivalent new
	    // UNIDRV settings under [<device>,<port>], if applicable.
	    // All soft fonts are left under the section [<driver>,<port>].
	    lstrcpy(szOldSec,rgchModuleName);
	    MakeAppName((LPSTR)szOldSec, lpNewPort, sizeof(szOldSec));

	    // if old section exists at all
	    if (!GetProfileString(szOldSec, NULL, NULL, szBuf, sizeof(szBuf)))
	        goto DI_exit;

	    // make sure the old device settings are for this device.
	    // If not, there is nothing to do here. Simply return 1.
	    tmp = GetProfileInt(szOldSec, szPrtIndex, 0);
	    hMd = GetModuleHandle((LPSTR)rgchModuleName);
	    hResMap = LoadResource(hMd,
			    FindResource(hMd, MAKEINTRESOURCE(1), RT_RCDATA));
	    lpModelMap = (LPMODELMAP)LockResource(hResMap);
	    for (i = 0; i < MAX_NUM_MODELS; i++)
        {
	        if (!lstrcmp(lpDevName, (LPSTR)lpModelMap[i].szModel))
		    {
		        if ((tmp < lpModelMap[i].rgIndexLimit[0]) ||
		            (tmp > lpModelMap[i].rgIndexLimit[1]) )
		            i = MAX_NUM_MODELS;        // not this model. No conversion.
		        break;
		    }
        }

	    UnlockResource(hResMap);
	    FreeResource(hResMap);

	    if (i >= MAX_NUM_MODELS)
	        // this model is not even listed in the old HPPCL driver.
	        goto DI_exit;

	    if (GetProfileInt(szOldSec, szWinVer, 0) == 310)
	        goto DI_exit;

	    WriteProfileString(szOldSec, szWinVer, sz310);
#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtIndex, NULL);
#endif

	    lstrcpy(szNewSec, lpDevName);
	    MakeAppName((LPSTR)szNewSec, lpNewPort, sizeof(szNewSec));

	    // convertable device settings include: copies, duplex, orient,
	    // paper, prtresfac, tray, and cartidges.

	    if (GetProfileString(szOldSec, szOrient, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szOrientation, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szOrient, NULL);
#endif
        }
	    if (GetProfileString(szOldSec, szPaper, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szPaperSize, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szPaper, NULL);
#endif
        }

	    // default to 2 if cannot find it
	    tmp = GetProfileInt(szOldSec, szPrtResFac, 2);

	    if (tmp == 1)
	        WriteProfileString(szNewSec, szPrintQuality, sz150);
	    else if (tmp == 2)
	        WriteProfileString(szNewSec, szPrintQuality, sz75);

#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtResFac, NULL);
#endif

	    if (GetProfileString(szOldSec, szTray, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szDefaultSource, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szTray, NULL);
#endif
        }

	    // try to convert the cartridge information.

	    if ((tmp = GetProfileInt(szOldSec, szNumCart, 0)) == 0)
	        tmp = 1;

	    // this is executed at least once
	    {
	        char szOldCartKey[16];
	        char szNewCartKey[16];
	        char nCart = 0;

	        lstrcpy(szOldCartKey, szCartIndex);

	        for (i = 0; i < tmp; i++)
	        {
	            if (i > 0)
                    itoa((LPSTR)&szOldCartKey[9], i);
	            // compose cartridge keyname under UNIDRV.
	            lstrcpy(szNewCartKey, szCartridge);
	            itoa((LPSTR)&szNewCartKey[10], i + 1);

	            if ((index = GetProfileInt(szOldSec, szOldCartKey, 0)) > 0)
		        {
		            WriteProfileString(szOldSec, szOldCartKey, NULL);
		            nCart++;
		            if (index <= MAX_OLD_CART)
		            {
		                itoa((LPSTR)szBuf, index + 8);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else if (index <= MAX_CART_INDEX)
		            {
		                itoa((LPSTR)szBuf, rgNewCartMap[index - MAX_OLD_CART - 1]);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else
		            {
		                // external cartridges. Simply copy the id over.
		                itoa((LPSTR)szBuf, index);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		        }
	        }

	        // integer to ASCII string conversion.
	        itoa((LPSTR)szBuf, nCart);
	        WriteProfileString(szNewSec, szNumberCart, szBuf);
	    }

	    // delete the old font summary file
	    WriteProfileString(szOldSec, szFsVers, NULL);
	    if (GetProfileString(szOldSec, szFontSummary, szNull, szBuf, sizeof(szBuf)) > 0)
	    {
	        int hFS;

	        // truncate the old font summary file to zero size.
	        if ((hFS = _lcreat(szBuf, 0)) >= 0)
		        _lclose(hFS);
	        WriteProfileString(szOldSec, szFontSummary, NULL);
	    }

            // create UNIDRV's font summary file, if there are many soft fonts.
	    if (GetProfileInt(szOldSec, szSoftFonts, 0) > SOFT_FONT_THRES)
	    {
	        HDC hIC;

	        if (hIC = CreateIC("PCL4CH", lpDevName, lpNewPort, NULL))
		        DeleteDC(hIC);
	    }
#endif
	}
    else

    {

	// move device settings from the old port to the new port, or
	// de-install a device, i.e. remove its device setttings in order
	// to compress the profile.

	// First, check if there is any  soft font installed under the
	// old port. If so, warn the user to copy them over.

	lstrcpy(szOldSec, rgchModuleName);
	MakeAppName((LPSTR)szOldSec, lpOldPort, sizeof(szOldSec));
	if (GetProfileInt(szOldSec, szSoftFonts, 0) > 0 && lpNewPort)
	{
            LPBYTE lpTemp;

            if(lpTemp=GlobalAllocPtr(GMEM_MOVEABLE,TMPSIZE))
	    {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,lpTemp,TMPSIZE))
		{
		    // Use this API so that the M Box is set to the Foreground
		    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
		    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = lpTemp;
		    mbp.lpszCaption = lpOldPort;
		    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
		    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
		GlobalFreePtr (lpTemp);
	    }
	}
    nReturn=UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);
    }


#ifdef CONVERT_FROM_WIN30
DI_exit:
#endif

#ifdef PRTCAPSTUFF

    DoPrtCapsStuff(lpDevName,lpNewPort);

#endif

    return nReturn;
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND	hWnd;
LPSTR	lpDeviceName;
LPSTR	lpPortName;
BOOL	bSoftFonts;
{
    int     fsVers;
    HANDLE  hFIlib;
    SFPROC  lpFIns;

    if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
	{
	    if (hFIlib >= 32)
	        FreeLibrary(hFIlib);
#ifdef DEBUG
	    MessageBox(0,
	        "Can't load FINSTALL.DLL or can't get InstallSoftFont",
	        NULL, MB_OK);
#endif
	    return TRUE;
	}

    // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
    // We choose to ignore the returned fvers. No use of it.
    fsVers = (*lpFIns)(hWnd, rgchModuleName, lpPortName,
		(GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0),
		1,	  // dummy value for fvers.
		bSoftFonts ? CLASS_LASERJET : 256
		);
    FreeLibrary(hFIlib);
    return fsVers;
}

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5kres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLD_5E_HALFTONE   4811
#define IDS_OLDTRUETYPE       4812
#define IDS_OLDOUTPUT         4813
#define IDS_OLDSEPARATION     4814
#define IDS_NEWMEMORY         4815
#define IDS_NEWPAPERSIZE      4816
#define IDS_NEWPAPERSOURCE    4817
#define IDS_NEWRESOLUTION     4818
#define IDS_NEWYRESOLUTION    4819
#define IDS_NEWORIENTATION    4820
#define IDS_NEWPAGEPROTECT    4821
#define IDS_NEWBRUSH          4822
#define IDS_NEWINTENSITY      4823
#define IDS_NEWTRUETYPE       4824
#define IDS_NEWOUTPUT         4825
#define IDS_NEWSEPARATION     4826
#define IDS_CARTRIDGES        4827
#define IDS_OLDVECTORMODE     4828
#define IDS_NEWVECTORMODE     4829
#define IDS_CARTINDEX         4830
#define IDS_CARTRIDGE         4831
#define IDS_CARTRIDGECOUNT    4832
#define IDS_FONTSUMMARY       4833
#define IDS_SOFTFONTS         4834
#define IDS_SOFTFONTFORMAT    4835
#define IDS_SOFTFONTTEST      4836
#define IDS_SOFTFONTWARNING   4837
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5tres\etc\pcl5msc.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5MSC";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}
#endif //!WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5kres\etc\pcl5ch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5CH";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
//swpark
//#define DEBUG 1
#ifdef DEBUG
#include "stdarg.h"
void NEAR CDECL  DBMSG(LPSTR, ...);
#endif
#endif  //WINNT

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

#endif // WINNT


#ifndef  WINNT
//swpark
//--------------------------**fnOEMOutputChar*---------------------------------//
// Function:    fnOEMOutputChar()
// 
// Action:      Output n characters pointed to by lpStr. Translation happens
//              on any extended characters in lpStr before printing.
//
// Notes:       We go through lpStr printing each character until we need to
//              translate for an extended character. 
//              We call SubstituteExtendedChar() which will read the device
//              data for this model if it has not already been retrieved.
//              We  get an offset into the translation table and print
//              those characters which represent that extended character.
//
//              We then return from SubstituteExtendedChar() and continue
//              printing the contents of lpStr.
//              We currently do not call Unidrv to handle this if no change             
//              has been made to the default translation set via the TTY UI.

#define OFFSET_HCURRENTCTT 258
static LPWORD lpwTailFirst;
static LPWORD lpwTailFirstX;
static LPBYTE lpbLeadMap;
static LPBYTE lpbLeadMapX;
static LPBYTE lpbTailOff;
static LPBYTE lpbTailOffX;
static LPBYTE lpbTailTable;
void near pascal OutputMachine (LPDV lpdv, LPSTR lpStr, WORD n);
// VOID _loadds far pascal fnOEMOutputChar(LPDV lpdv, LPSTR lpStr, WORD n, short rcID)
VOID   FAR PASCAL fnOEMOutputChar(LPDV lpdv, LPSTR lpStr, WORD n, short rcID)
{
    #define OFFSET_1  4
    #define OFFSET_2  158
    #define OFFSET_3  312
    #define OFFSET_4  337
    #define OFFSET_5  407
    #define OFFSET_6  432
    #define OFFSET_7  502
    HANDLE hCTT;
    LPSTR lpCtt;

    hCTT = *(LPHANDLE)((LPSTR)lpdv+OFFSET_HCURRENTCTT);
#ifdef DEBUG
    DBMSG ("hCTT = %d\n", hCTT);
#endif
    if (hCTT &&
        (lpCtt = (LPSTR)LockResource(hCTT))) {
        lpwTailFirst = (LPWORD)((LPSTR)lpCtt + OFFSET_1);
        lpwTailFirstX= (LPWORD)((LPSTR)lpCtt + OFFSET_2);
        lpbLeadMap   = (LPBYTE)lpCtt + OFFSET_3;
        lpbLeadMapX  = (LPBYTE)lpCtt + OFFSET_4;
        lpbTailOff   = (LPBYTE)lpCtt + OFFSET_5;
        lpbTailOffX  = (LPBYTE)lpCtt + OFFSET_6;
        lpbTailTable = (LPBYTE)lpCtt + OFFSET_7;
        #ifdef DEBUG
        DBMSG("   lpwTailFirst[0] = %d\n", lpwTailFirst[0]);
        DBMSG("   lpwTailFirst[1] = %d\n", lpwTailFirst[1]);
        DBMSG("   lpwTailFirstX[0]= %d\n", lpwTailFirstX[0]);
        DBMSG("   lpwTailFirstX[1]= %d\n", lpwTailFirstX[1]);
        DBMSG("   lpbLeadMap[0]   = %d\n", lpbLeadMap[0]);
        DBMSG("   lpbLeadMap[1]   = %d\n", lpbLeadMap[1]);
        DBMSG("   lpbLeadMapX[0]  = %d\n", lpbLeadMapX[0]);
        DBMSG("   lpbLeadMapX[1]  = %d\n", lpbLeadMapX[1]);
        DBMSG("   lpbTailOff[0]   = %d\n", lpbTailOff[0]);
        DBMSG("   lpbTailOff[1]   = %d\n", lpbTailOff[1]);
        DBMSG("   lpbTailOffX[0]  = %d\n", lpbTailOffX[0]);
        DBMSG("   lpbTailOffX[1]  = %d\n", lpbTailOffX[1]);
        DBMSG("   lpbTailTable[0] = %d\n", lpbTailTable[0]);
        DBMSG("   lpbTailTable[1] = %d\n", lpbTailTable[1]);
        #endif
        #ifdef DEBUG
        DBMSG ("Sucess Lock CTT\n");
        #endif
	OutputMachine (lpdv, lpStr, n);
        UnlockResource(hCTT);
    }else{
#ifdef DEBUG
        DBMSG ("Fail Lock CTT\n");
#endif
      WriteSpoolBuf(lpdv, lpStr, n);
    }
}

int near  pascal IsHangeul( WORD wXW );
WORD near pascal ConvertToChoHap (WORD wCh);
void near pascal OutputMachine (LPDV lpdv, LPSTR lpStr, WORD n)
{
    #define S_HANGEUL 1
    #define S_REMAINS 2
    #define SET_CHOHAP  "\033(18H",5
    #define SET_WANSUNG "\033(19H",5
    int state;
    short i;
    WORD  wCh;
    LPSTR lpT = lpStr;

    state = S_HANGEUL;
    for (i=n; i > 0;) {
        if (IsDBCSLeadByte(*lpT) && i>1) {
#ifdef DEBUG
            DBMSG ("   IsHangeul() = %d\n", IsHangeul( *(LPWORD)lpT) );
#endif
            if ( IsHangeul(*(LPWORD)lpT)) {
                if (state==S_REMAINS) {
                    WriteSpoolBuf(lpdv, SET_CHOHAP); 
                    state = S_HANGEUL;
                }
                wCh = ConvertToChoHap (*(LPWORD)lpT);
                WriteSpoolBuf(lpdv, (LPSTR)&wCh, 2);
            }else{
                if (state==S_HANGEUL) {
                    WriteSpoolBuf(lpdv, SET_WANSUNG); 
                    state = S_REMAINS;
                }
                WriteSpoolBuf(lpdv, lpT, 2);
            }
            lpT+=2; i-=2;
        }else{
            if (state==S_HANGEUL) {
                WriteSpoolBuf(lpdv, SET_WANSUNG); 
               state = S_REMAINS;
            }
            WriteSpoolBuf(lpdv, lpT, 1);
            lpT++; i--;
        }
    }
    if (state==S_REMAINS) WriteSpoolBuf(lpdv, SET_CHOHAP); 
}


int near  pascal IsHangeul( WORD wXW )
{
    #define  XWT_INVALID    0xFF
    #define  XWT_EXTENDED   0x01
    #define  XWT_WANSUNG    0x02
    #define  XWT_JUNJA      0x03
    #define  XWT_HANJA      0x04
    #define  XWT_UDC        0x05
    static BYTE  iXWType[8][3] =
    {
      XWT_EXTENDED, XWT_EXTENDED, XWT_EXTENDED,    // Lead = 0x81-0xA0
      XWT_EXTENDED, XWT_EXTENDED, XWT_JUNJA,       // Lead = 0xA1-0xAC
      XWT_EXTENDED, XWT_EXTENDED, XWT_INVALID,     // Lead = 0xAD-0xAF
      XWT_EXTENDED, XWT_EXTENDED, XWT_WANSUNG,     // Lead = 0xB0-0xC5
      XWT_EXTENDED, XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC6
      XWT_INVALID,  XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC7-0xC8
      XWT_INVALID,  XWT_INVALID,  XWT_UDC,         // Lead = 0xC9, 0xFE
      XWT_INVALID,  XWT_INVALID,  XWT_HANJA        // Lead = 0xCA-0xFD
   };
   BYTE  bT = (BYTE) (( wXW >> 8 ) & 0xFF);
   BYTE  bL = (BYTE) (wXW & 0xFF);
   int   iLType = -1, iTType = -1;
   WORD wRet;

#ifdef DEBUG
DBMSG ("   In GetXWType, bL =%d\n", bL);
DBMSG ("   In GetXWType, bT =%d\n", bT);
#endif

   if ( ( bT >= 0x41 ) && ( bT <= 0xFE ) )
   {
      if ( bT <= 0x52 )
         iTType = 0;       // Tail Range 0x41-0x52
      else
      {
         if ( bT >= 0xA1 )
            iTType = 2;    // Tail Range 0xA1-0xFE
         else if ( ( bT <= 0x5A ) || ( bT >= 0x81 ) ||
                   ( ( bT >= 0x61 ) && ( bT <= 0x7A ) ) )
            iTType = 1;    // Tail Range 0x53-0x5A, 0x61-0x7A, 0x81-0xA0
      }
   }
   if ( iTType < 0 )  return( 0 );

   if ( ( bL >= 0x81 ) && ( bL <= 0xFE ) )
   {
      if ( bL < 0xB0 )
      {
         if ( bL <= 0xA0 )
            iLType = 0;       // Lead Range 0x81-0xA0
         else if ( bL <= 0xAC )
            iLType = 1;       // Lead Range 0xA1-0xAC
         else
            iLType = 2;       // Lead Range 0xAD-0xAF
      }
      else
      {
         if ( bL <= 0xC8 )
         {
            if ( bL < 0xC6 )
               iLType = 3;    // Lead Range 0xB0-0xC5
            else if ( bL == 0xC6 )
               iLType = 4;    // Lead Range 0xC6
            else
               iLType = 5;    // Lead Range 0xC7-0xC8
         }
         else
         {
            if ( ( bL == 0xC9 ) || ( bL == 0xFE ) )
               iLType = 6;    // Lead Range 0xC9, 0xFE
            else
               iLType = 7;    // Lead Range 0xCA-0xFD
         }
      }
   }

   wRet = ( iLType < 0 ) ? -1 : iXWType[iLType][iTType];
   if (wRet == XWT_WANSUNG || wRet == XWT_EXTENDED)
       return wRet;
   else return 0;
}

WORD near pascal ConvertToChoHap (WORD wCh)
{
   LPWORD  lpTF;
   int   iTO;
   BYTE  bL, bT, bJS;
   WORD wCh1;

   wCh1 = wCh<<8;
   wCh1 |= wCh>>8;

   switch ( IsHangeul(wCh) )
   {
      case  XWT_EXTENDED :
         bL = (BYTE) (( ( wCh1 >> 8 ) & 0xFF ) - 0x81);
         bT = (BYTE) (wCh1 & 0xFF);
         if ( ( bT -= 0x41 ) > 0x19 )
            if ( ( bT -= 6 ) > 0x33 )
               bT -= 6;
         iTO = bT + lpbTailOffX[bL];
         lpTF = lpwTailFirstX + ( bL = lpbLeadMapX[bL] );
         goto FindHangeul;
      case  XWT_WANSUNG :
#ifdef DEBUG
DBMSG("   case XWT_WANSUGN\n");
#endif
         bL = (BYTE) (( ( wCh1 >> 8 ) & 0xFF ) - 0xB0);
         iTO = ( wCh1 & 0xFF ) - 0xA1 + lpbTailOff[bL];
         lpTF = lpwTailFirst + ( bL = lpbLeadMap[bL] );
         goto FindHangeul;
      default :
         return (0x6188);
   }

FindHangeul:
   iTO += *lpTF++;
   while ( iTO >= *lpTF++ )  bL++;
   //return ( (WORD)(bL+0x88) * 256 + lpbTailTable[iTO] );
   return ( (WORD)lpbTailTable[iTO]  * 256 + (bL+0x88) );

FindSymbol:
   bL = (BYTE) (( wCh1 >> 8 ) & 0xFF);
   bT = (BYTE) (wCh1 & 0xFF);
   if ( ( bL & 1 ) == 0 )
      bT -= ( ( bT <= 0xEE ) ? 0x70 : 0x5E );
   bJS += ( bL / 2 );
   //return ((WORD) bJS * 256 + bT );
   return ( (WORD)bT * 256 + bJS );
}

//-----------------------------**Enable**-----------------------------------//
// Function: Enable()
// Action:   We setup the callback to fnOEMOutPutChar and call UniEnable.
// ------------------------------------------------------------------------

short CALLBACK Enable(
LPDV lpdv,
WORD style,
LPSTR lpModel,
LPSTR lpPort,
LPDM lpStuff)
{
  CUSTOMDATA cd;
  
  cd.cbSize = sizeof(CUSTOMDATA);
  cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
  cd.fnOEMDump = NULL;
  cd.fnOEMOutputChar = (LPFNOEMOUTPUTCHAR)fnOEMOutputChar;
  return  UniEnable(lpdv, style, lpModel, lpPort, lpStuff, &cd);
}


#ifdef DEBUG
static char logbuf[100];
void NEAR CDECL  DBMSG(LPSTR lpFmt, BYTE arg)
{

    if (lpFmt) {
        wvsprintf(logbuf, lpFmt, (LPSTR)&arg);
        OutputDebugString(logbuf);
     }
}
#endif  // DEBUG

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5zres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLD_5E_HALFTONE   4811
#define IDS_OLDTRUETYPE       4812
#define IDS_OLDOUTPUT         4813
#define IDS_OLDSEPARATION     4814
#define IDS_NEWMEMORY         4815
#define IDS_NEWPAPERSIZE      4816
#define IDS_NEWPAPERSOURCE    4817
#define IDS_NEWRESOLUTION     4818
#define IDS_NEWYRESOLUTION    4819
#define IDS_NEWORIENTATION    4820
#define IDS_NEWPAGEPROTECT    4821
#define IDS_NEWBRUSH          4822
#define IDS_NEWINTENSITY      4823
#define IDS_NEWTRUETYPE       4824
#define IDS_NEWOUTPUT         4825
#define IDS_NEWSEPARATION     4826
#define IDS_CARTRIDGES        4827
#define IDS_OLDVECTORMODE     4828
#define IDS_NEWVECTORMODE     4829
#define IDS_CARTINDEX         4830
#define IDS_CARTRIDGE         4831
#define IDS_CARTRIDGECOUNT    4832
#define IDS_FONTSUMMARY       4833
#define IDS_SOFTFONTS         4834
#define IDS_SOFTFONTFORMAT    4835
#define IDS_SOFTFONTTEST      4836
#define IDS_SOFTFONTWARNING   4837
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5tres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLDTRUETYPE       4811
#define IDS_OLDOUTPUT         4812
#define IDS_OLDSEPARATION     4813
#define IDS_NEWMEMORY         4814
#define IDS_NEWPAPERSIZE      4815
#define IDS_NEWPAPERSOURCE    4816
#define IDS_NEWRESOLUTION     4817
#define IDS_NEWYRESOLUTION    4818
#define IDS_NEWORIENTATION    4819
#define IDS_NEWPAGEPROTECT    4820
#define IDS_NEWBRUSH          4821
#define IDS_NEWINTENSITY      4822
#define IDS_NEWTRUETYPE       4823
#define IDS_NEWOUTPUT         4824
#define IDS_NEWSEPARATION     4825
#define IDS_CARTRIDGES        4826
#define IDS_OLDVECTORMODE     4827
#define IDS_NEWVECTORMODE     4828
#define IDS_CARTINDEX         4829
#define IDS_CARTRIDGE         4830
#define IDS_CARTRIDGECOUNT    4831
#define IDS_FONTSUMMARY       4832
#define IDS_SOFTFONTS         4833
#define IDS_SOFTFONTFORMAT    4834
#define IDS_SOFTFONTTEST      4835
#define IDS_SOFTFONTWARNING   4836
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\pcl5zres\etc\pcl5sc.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5SC";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qbjres\etc\qbj.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "QBJ";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\ppdskres\etc\ppdsch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "windows.h"
#include "string.h"

// the following 3 definitions MUST be compatible with the
// HPPCL font installer

//Is this needed for IBMPPDS ?????
#define CLASS_LASERJET      0
#define CLASS_DESKJET       1
#define CLASS_DESKJET_PLUS  2

#define MAXBLOCK                400

char *rgchModuleName = "PPDSCH";

#ifndef	WINNT
// typedef for font installer
typedef int (FAR PASCAL *SFPROC)(HANDLE,HWND,LPSTR,LPSTR,LPSTR,int,
                                 BOOL,short);

// Local routines
int FAR PASCAL lstrcopyn(LPSTR, LPSTR, int);

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//          and/or external cartridges.
//
// Parameters:
//      HWND    hWnd;           handle to the parent windows.
//      LPSTR   lpDeviceName;   long pointer to the printer name.
//      LPSTR   lpPortName;     long pointer to the associated port name.
//      BOOL    bSoftFonts;     flag if supporting soft fonts or not.
//
//  Return Value:
//      > 0   :  if the font information has changed;
//      == 0  :  if nothing has changed;
//      == -1 :  if intending to use the universal font installer
//               (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND    hWnd;
LPSTR   lpDeviceName;
LPSTR   lpPortName;
BOOL    bSoftFonts;
{
    int     fsVers, fonttypes;
    HANDLE  hFIlib, hModule;
    SFPROC  lpFIns;
    static char    LocalDeviceName[80];

    /*************************************************************/
    /* If device is 4019 then font type support is bitmap.       */
    /* For any other printer (4029, 4037, ...(?)) font type      */
    /* support is outline.  Because of current Unidrv limitation */
    /* both bitmap and outline support (value = 3) cannot be     */
    /* supported by the same printer model.                      */
    /* MFC - 9/8/94                                              */
    /*************************************************************/
    LocalDeviceName[0] = '\0';
    lstrcopyn((LPSTR)LocalDeviceName, lpDeviceName, 79);
    LocalDeviceName[79] = '\0';
    if (strstr(LocalDeviceName, "4019") != NULL)
       fonttypes = 1;            // Bitmap
    else
       fonttypes = 2;            // Outline

    if ((hFIlib = LoadLibrary((LPSTR)"SF4029.EXE")) < 32 ||
	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"SoftFontInstall")))
	{
	if (hFIlib >= 32)
	    FreeLibrary(hFIlib);

	MessageBox(0,
	           "Can't load SF4029.EXE or can't get SoftFontInstall",
		        NULL, MB_OK);

   return TRUE;
	}

   hModule = GetModuleHandle((LPSTR)"PPDSCH.DRV");

    // FINSTALL.DLL was loaded properly. Now call SoftFontInstall().
    // We choose to ignore the returned "fvers". No use of it.
    fsVers = (*lpFIns)(hModule, hWnd, lpDeviceName, lpPortName,
                       (LPSTR)rgchModuleName, fonttypes, (BOOL)0,
                       (short)0);
    FreeLibrary(hFIlib);
    return fsVers;
}


//---------------------------*lstrcopyn*---------------------------------
// Action: Copies n characters from one string to another.  If the end of
//         the source string has been reached before n characters have
//         been copied, the the destination string is padded with nulls.
//         Returns the number of characters used from the source string.
//
// Parameters:
//      LPSTR   string1;    Destination string;
//      LPSTR   string2;    Source string;
//      int     n;          Number of characters to copy.
//
//  Return Value:
//      int   :  Number of characters copied from source string
//-------------------------------------------------------------------------

int FAR PASCAL lstrcopyn(string1, string2, n)
LPSTR   string1;
LPSTR   string2;
int     n;
{
    int     i = 0;
    LPSTR   s1, s2;

    s1 = string1;
    s2 = string2;

    while ((*s2) && (n > 0))
    {
       *s1++ = *s2++;
       i++;
       n--;
    }

    while (n > 0)
    {
       *s1++ = '\0';
       n--;
    }

    return i;
}

#endif  // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

// #289908: pOEMDM -> pdevOEM
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR( ("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR( ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR( ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// ######################

// Function Name: GetInfo
// Plug-in: Any
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::GetInfo(
    DWORD dwMode,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

// ######################

//
// Function Name: PublishDriverInterface
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

int __cdecl
iCompNames(
    void *p1,
    void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
}

LONG __stdcall
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            (int (__cdecl *)(const void *, const void *))iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

// #######################

//
// Function Name: EnableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: EnablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
//  return E_NOTIMPL;
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

//
// Function Name: DisablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
//  return E_NOTIMPL;
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//  return E_NOTIMPL;
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

//
// Function Name: DevMode
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

// ################


//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if (OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

HRESULT __stdcall
IOemCF::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'QPLK'      // QPL resource DLL
#define DLLTEXT(s)      "QPLK: " s
#define OEM_VERSION      0x00010000L

#define SCANLINE_BUFFER_SIZE	1280    // A3 landscape scanline length + extra

// Worst case is like "ABB". It is compressed to 
// "[non-continuous count]A[continuous count]B".
// So, we need RLE buffer whose size is 4/3 times as large as scanline buffer. 
// But just to make sure, 2x size of buffer is prepared.
#define COMPRESS_BUFFER_SIZE	SCANLINE_BUFFER_SIZE*2

// Color support
#define CC_CYAN		5	//current plain is cyan
#define CC_MAGENTA	6	//current plain is magenta
#define CC_YELLOW	7	//current plain is yellow
#define CC_BLACK	4	//current plain is black

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

// #289908: pOEMDM -> pdevOEM
typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
} OEM_EXTRADATA, *POEM_EXTRADATA;

typedef struct tag_QPLKPDEV {
    // Private extention
	BOOL		bFirst;
//	DWORD		dwLastScanLineLen;
//	BYTE		lpLastScanLine[SCANLINE_BUFFER_SIZE];
	DWORD		dwCompType;
// Color support
	DWORD		dwCyanLastScanLineLen;
	DWORD		dwMagentaLastScanLineLen;
	DWORD		dwYellowLastScanLineLen;
	DWORD		dwBlackLastScanLineLen;
	BYTE		lpCyanLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpMagentaLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpYellowLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpBlackLastScanLine[SCANLINE_BUFFER_SIZE];
	BOOL		bColor;
	UINT		fColor;
} QPLKPDEV, *PQPLKPDEV;

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\qplkres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

// #289908: pOEMDM -> pdevOEM
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(QPLKPDEV))))
        {
        //  ERR(("Faild to allocate memory. (%d)\n",
        //      GetLastError()));
            return NULL;
        }
    }

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PQPLKPDEV pOEMOld, pOEMNew;

    pOEMOld = (PQPLKPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PQPLKPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

//  BInitOEMExtraData() and BMergeOEMExtraData() has moved to common.c

// #######

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

// Private Definition
// Command callback
#define CMD_BEGINPAGE_DELTAROW		1
#define CMD_SENDBLOCKDATA_DELTAROW	2
#define CMD_SENDBLOCKDATA_B2		3
#define CMD_BEGINPAGE_B2			4
// Color support
#define CMD_BEGINPAGE_C1            5
#define CMD_BEGINPAGE_DEFAULT       6
#define CMD_BEGINPAGE_B2_LAND       7

// Special fix for Qnix Picasso 300
#define CMD_BEGINPAGE_B2_PICA       8

#define CMD_CR						10
#define CMD_LF						11
#define CMD_FF						12

// Color support
#define CMD_SELECT_CYAN			100
#define CMD_SELECT_MAGENTA		101
#define CMD_SELECT_YELLOW		102
#define CMD_SELECT_BLACK		103

#define CMD_YMOVE_REL_COLOR		150

// #299937: Incorrect value for Y Move
#define COLOR_MASTERUNIT                600

// Compression Type
#define COMP_DELTARAW				1
#define COMP_B2						2
#define COMP_NOCOMP					3

// Compression routine
WORD DeltaRawCompress(PBYTE, PBYTE, PBYTE, DWORD, DWORD);
WORD B2Compress(PBYTE, PBYTE, PBYTE, DWORD);
PBYTE RLE_comp(PBYTE);
WORD RLEencoding(PBYTE, PBYTE, DWORD);

/*****************************************************************************/
/*                                                                           */
/*   BOOL APIENTRY OEMFilterGraphics(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                PBYTE   pBuf                                               */
/*                DWORD   dwLen )                                            */
/*                                                                           */
/*****************************************************************************/
BOOL APIENTRY 
OEMFilterGraphics(
	PDEVOBJ    pdevobj, // Points to private data required by the Unidriver.dll
	PBYTE      pBuf,    // points to buffer of graphics data
	DWORD      dwLen)   // length of buffer in bytes
{
	BYTE			CompressedScanLine[COMPRESS_BUFFER_SIZE];
	BYTE			HeaderScanLine[4];
	WORD			nCompBufLen;
	PQPLKPDEV               pOEM = (PQPLKPDEV)pdevobj->pdevOEM;
	// Color support
	PDWORD			pdwLastScanLineLen;
	LPSTR			lpLastScanLine;
	BYTE			HeaderColorPlane;

	if (pOEM->bFirst)
	{
		// Color support
		ZeroMemory(pOEM->lpCyanLastScanLine, SCANLINE_BUFFER_SIZE);
		ZeroMemory(pOEM->lpMagentaLastScanLine, SCANLINE_BUFFER_SIZE);
		ZeroMemory(pOEM->lpYellowLastScanLine, SCANLINE_BUFFER_SIZE);
		ZeroMemory(pOEM->lpBlackLastScanLine, SCANLINE_BUFFER_SIZE);
		pOEM->bFirst = FALSE;
	}
	// Color support
	switch (pOEM->fColor) {
	case CC_CYAN:
		HeaderColorPlane = 0x05;
		pdwLastScanLineLen = &(pOEM->dwCyanLastScanLineLen);
		lpLastScanLine = pOEM->lpCyanLastScanLine;
		break;
	case CC_MAGENTA:
		HeaderColorPlane = 0x06;
		pdwLastScanLineLen = &(pOEM->dwMagentaLastScanLineLen);
		lpLastScanLine = pOEM->lpMagentaLastScanLine;
		break;
	case CC_YELLOW:
		HeaderColorPlane = 0x07;
		pdwLastScanLineLen = &(pOEM->dwYellowLastScanLineLen);
		lpLastScanLine = pOEM->lpYellowLastScanLine;
		break;
	case CC_BLACK:
	default:	// Black&White
		HeaderColorPlane = 0x04;
		pdwLastScanLineLen = &(pOEM->dwBlackLastScanLineLen);
		lpLastScanLine = pOEM->lpBlackLastScanLine;
		break;
	}
	if(pOEM->dwCompType == COMP_DELTARAW)
	{
		nCompBufLen = (WORD)DeltaRawCompress(pBuf, lpLastScanLine,
			CompressedScanLine, (*pdwLastScanLineLen > dwLen) ?
			*pdwLastScanLineLen : dwLen, (DWORD)0);

		HeaderScanLine[0] = 0;
		HeaderScanLine[1] = 0;
		HeaderScanLine[2] = HIBYTE(nCompBufLen);
		HeaderScanLine[3] = LOBYTE(nCompBufLen);

		WRITESPOOLBUF(pdevobj, (PBYTE) HeaderScanLine, 4);
		WRITESPOOLBUF(pdevobj, (PBYTE) CompressedScanLine, nCompBufLen);

		CopyMemory(lpLastScanLine, pBuf, dwLen);
		if (*pdwLastScanLineLen > dwLen)
			ZeroMemory(lpLastScanLine + dwLen,
			*pdwLastScanLineLen - dwLen);

		*pdwLastScanLineLen = dwLen;
	} else if(pOEM->dwCompType == COMP_B2) {
		nCompBufLen = B2Compress(lpLastScanLine, pBuf,
			CompressedScanLine, (*pdwLastScanLineLen > dwLen) ?
			*pdwLastScanLineLen : dwLen);

		// send color plane command
		if (pOEM->bColor)
			WRITESPOOLBUF(pdevobj, &HeaderColorPlane, 1);

		HeaderScanLine[0] = 0x02;
		HeaderScanLine[1] = (BYTE) (nCompBufLen >> 8);
		HeaderScanLine[2] = (BYTE) nCompBufLen;
		WRITESPOOLBUF(pdevobj, (PBYTE) HeaderScanLine, 3);
                // #297256: Line is cut and increase
                // Do not send if no compressed data.
		if (nCompBufLen) {
		    WRITESPOOLBUF(pdevobj, (PBYTE) CompressedScanLine,
                        nCompBufLen);
		    *pdwLastScanLineLen = dwLen;
                }

	}

	return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    PQPLKPDEV      pOEM = (PQPLKPDEV)(pdevobj->pdevOEM);
	INT					iRet = 0;
// Color support
	DWORD	count, n, unit;
	BYTE	aCmd[32];

    switch(dwCmdCbId)
    {
        case CMD_BEGINPAGE_DEFAULT:
			WRITESPOOLBUF(pdevobj, "\033}0;0;5B", 8);
			pOEM->bFirst = TRUE;
            break;

        case CMD_BEGINPAGE_DELTAROW:
			WRITESPOOLBUF(pdevobj, "\033}0;0;3B", 8);
			pOEM->bFirst = TRUE;
            break;

        case CMD_BEGINPAGE_B2:
        case CMD_BEGINPAGE_B2_PICA:
			WRITESPOOLBUF(pdevobj, "\033}0;0;4B", 8);
			pOEM->bFirst = TRUE;
            if (dwCmdCbId == CMD_BEGINPAGE_B2_PICA )
            {
                if (pdwParams[0] == 300 )
                    WRITESPOOLBUF(pdevobj, "\x00\x1C", 2);
                else
                    WRITESPOOLBUF(pdevobj, "\x00\x38", 2);
            }
            break;

        case CMD_BEGINPAGE_B2_LAND:
			WRITESPOOLBUF(pdevobj, "\033}0;0;7B", 8);
			pOEM->bFirst = TRUE;
            break;

	// Color support
        case CMD_BEGINPAGE_C1:
			WRITESPOOLBUF(pdevobj, "\033}0;0;6B", 8);
// #315089: some lines isn't printed on printable area test.
// move cursor to printable origin.
                        WRITESPOOLBUF(pdevobj,
                            "\x05\x00\x03\x06\x00\x03\x07\x00\x03\x04\x00\x03",
                            12);
			pOEM->bFirst = TRUE;
			pOEM->dwCompType = COMP_B2;
			pOEM->bColor = TRUE;
            break;

		case CMD_SENDBLOCKDATA_DELTAROW:
			pOEM->dwCompType = COMP_DELTARAW;
			break;

		case CMD_SENDBLOCKDATA_B2:
			pOEM->dwCompType = COMP_B2;
			break;

		case CMD_CR:
		case CMD_LF:
		case CMD_FF:
			// Dummy support
			break;

// Color support
	case CMD_SELECT_CYAN:
		pOEM->fColor = CC_CYAN;
		break;

	case CMD_SELECT_MAGENTA:
		pOEM->fColor = CC_MAGENTA;
		break;

	case CMD_SELECT_YELLOW:
		pOEM->fColor = CC_YELLOW;
		break;

	case CMD_SELECT_BLACK:
		pOEM->fColor = CC_BLACK;
		break;

	case CMD_YMOVE_REL_COLOR:
// #299937: Incorrect value for Y Move
// YMove value is always in MasterUnit even YMoveUnit was specified.
		if (dwCount < 2 || !pdwParams)
			break;
		unit = COLOR_MASTERUNIT / pdwParams[1];
		if (unit == 0)
			unit = 1;	// for our safety
		count = pdwParams[0] / unit;
		while (count > 0) {
			n = min(count, 255);
			aCmd[0] = 0x04;
			aCmd[1] = 0x00;
			aCmd[2] = (BYTE)n;
			aCmd[3] = 0x05;
			aCmd[4] = 0x00;
			aCmd[5] = (BYTE)n;
			aCmd[6] = 0x06;
			aCmd[7] = 0x00;
			aCmd[8] = (BYTE)n;
			aCmd[9] = 0x07;
			aCmd[10] = 0x00;
			aCmd[11] = (BYTE)n;
			WRITESPOOLBUF(pdevobj, aCmd, 12);
			count -= n;
		}
		iRet = pdwParams[0];
		break;

        default:
            break;
    }

    return iRet;
}

/*************************************************
 *
 * Image Delta Compression Routine
 *
 *===================================================
 * Input:
 *	 nbyte		 : # of byte, raw data
 *	 Image_string: pointer of raw data
 *	 Prn_string  : pointer of compress data
 * Output:
 *	 Ret_count	 : # of byte, compress data
**************************************************/
WORD DeltaRawCompress(
	PBYTE	Image_string,	/* pointer to original string */
	PBYTE	ORG_image,		/* pointer to previous scanline's string */
	PBYTE	Prn_string,		/* pointer to return string */
	DWORD	nbyte,			/* original number of bytes */
	DWORD	nMagics)		//Magic number
{
	DWORD		c, Ret_count, Skip_flag, Skip_count;
	DWORD		i, j, k, outcount;
	PBYTE		Diff_ptr;
	PBYTE		ORG_ptr;
	PBYTE		Skip_ptr;
	BYTE		Diff_byte;
	BYTE		Diff_mask[8]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
	BOOL		bstart = TRUE;

	outcount = 0;
	Ret_count = 0;
	ORG_ptr = ORG_image;
	Skip_flag = TRUE;

	Skip_ptr = Prn_string++;
	Skip_count = (nMagics / 8) / 8;
	*Skip_ptr = (BYTE)Skip_count;

	k = (nbyte + 7) / 8;
	for(i = 0; i < k; i++)
	{
		Diff_byte = 0;
		Diff_ptr = Prn_string++;

		for(j = 0; j < 8; j++)
		{
			if ( (i * 8 + j) >= nbyte )
			{
				*Prn_string++= 0;
				Diff_byte |= Diff_mask[j];
				outcount++;
			} else {
				c = *Image_string++;
				if(c != *ORG_ptr)
				{
					*ORG_ptr++ = (BYTE)c;
					*Prn_string++= (BYTE)c;
					Diff_byte |= Diff_mask[j];
					outcount++;
				} else {
					ORG_ptr++;
				}
			}
		}

		if(Diff_byte == 0)
		{
			if(Skip_flag == TRUE)
			{
				Skip_count++;
				Prn_string--;
			}else{
				*Diff_ptr = Diff_byte;
				outcount++;
			}
		}else{
			if(Skip_flag == TRUE)
			{
				Skip_flag = FALSE;
				*Skip_ptr = (BYTE)Skip_count;
				outcount++;
				*Diff_ptr = Diff_byte;
				outcount++;
			}else{
				*Diff_ptr = Diff_byte;
				outcount++;
			}
			Ret_count = outcount;
		}
	}
	return (WORD)Ret_count;
}

/*****************************************************************************/
/*                                                                           */
/*         WORD B2Compress(                                                  */
/*                PBYTE   pLastScanLine                                      */
/*                PBYTE   pCurrentScanLine                                   */
/*                PBYTE   pPrnBuf                                            */
/*                DWORD   nImageWidth                                        */
/*                                                                           */
/*****************************************************************************/
WORD B2Compress(
	PBYTE	pLastScanLine, 
	PBYTE	pCurrentScanLine, 
	PBYTE	pPrnBuf, 
	DWORD	nImageWidth)
{
	PBYTE	pLast, pCurrent, pComp;
	PBYTE	pByteNum, pCountByte;
	WORD	i;
	BYTE	nSameCount, nDiffCount;
	BOOL	bSame = TRUE;

        // #297256: Line is cut and increase
        // Indicate to zero if this place doesn't have any data.
        if (nImageWidth == 0)
            return 0;

	pLast = pLastScanLine;
	pCurrent = pCurrentScanLine;
	pComp = pPrnBuf;

	pByteNum = pComp;
	nSameCount = 0;
	nDiffCount = 0;
	pCountByte = pComp++;

	for(i = 0; i < nImageWidth; i++)
	{
		if(*pCurrent != *pLast)
		{
			bSame = FALSE;
			nDiffCount++;
			if(nSameCount)      // if continuous data remain...
			{
				*pCountByte = nSameCount;
				pCountByte = pComp++;
				nSameCount = 0;
			}
			if(nDiffCount > 127)
			{
				*pCountByte = 127 + 128;
				pComp = RLE_comp(pCountByte);
				pCountByte = pComp++;
				nDiffCount -= 127;
			}
			*pLast = *pCurrent;
			*pComp++ = *pCurrent;
		} else {
			nSameCount++;
			if(nDiffCount)      // if non-continuous data remain...
			{
				*pCountByte = nDiffCount + 128;
				pComp = RLE_comp(pCountByte);
				pCountByte = pComp++;
				nDiffCount = 0;
			}
			if(nSameCount > 127)
			{
				*pCountByte = 127;
				pCountByte = pComp++;
				nSameCount -= 127;
			}
		}
		pCurrent++;
		pLast++;
	}  // end of for loop
	
	if(nSameCount)
		*pCountByte = nSameCount;

	if(nDiffCount)
	{
		*pCountByte = nDiffCount+128;
		pComp = RLE_comp(pCountByte);
	}
	
        // #297256: Line is cut and increase
        // Actually, printer doesn't have command for same as previous line.
#if 0
	if (bSame)
		return((WORD) 0);
	else
#endif
		return((WORD) (pComp - pByteNum));
}

/*****************************************************************************/
/*                                                                           */
/*         PBYTE RLE_comp(LPBYTE p)                                          */
/*                                                                           */
/*****************************************************************************/
PBYTE RLE_comp(PBYTE p)
{
	WORD	i, count, RLEEncodedCount;
	PBYTE	p1;
	BYTE	RLEBuffer[COMPRESS_BUFFER_SIZE];

	count = (WORD) (*p - 128);
	if(count > 4)
	{
		RLEEncodedCount = RLEencoding(p + 1, (PBYTE) RLEBuffer, count);

		if(RLEEncodedCount < count)
		{
			*p++ = 0;	// RLE encode indicator
			*p++ = (BYTE) RLEEncodedCount;
			p1 = RLEBuffer;

			for(i = 0; i < RLEEncodedCount; i++)
				*p++ = *p1++;

			return(p);
		}
	}
	return(p + 1 + count);
}

/*****************************************************************************/
/*                                                                           */
/*         WORD RLEencoding(                                                 */
/*                PBYTE   pCurrent                                           */
/*                PBYTE   pComp                                              */
/*                DWORD   count                                              */
/*                                                                           */
/*****************************************************************************/
WORD RLEencoding(
	PBYTE	pCurrent,
	PBYTE	pComp,
	DWORD	count)
{
	WORD	i, nByteNum;
    BYTE	curr, next, RLEcount;

	nByteNum = 0;
	RLEcount = 1;

	for(i = 0; i < count - 1; i++)
	{
		curr = *pCurrent++;
		next = *pCurrent;

		if(curr == next)
		{
			if(RLEcount == 255)
			{
				*pComp++ = RLEcount;
                *pComp++ = curr;
				nByteNum += 2;
				RLEcount = 1;
			} else {
				RLEcount++;
			} 
		} else {
			*pComp++ = RLEcount;
            *pComp++ = curr;
			nByteNum += 2;
			RLEcount = 1;
		}
	}
	*pComp++ = RLEcount;
    *pComp++ = next;
	nByteNum += 2;

	return(nByteNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=KOR
ALT_PROJECT_TARGET=$(ALT_PROJECT)

QNIX_DIR=$(PRNROOT)\gpd\qnix\$(ALT_PROJECT)
VRTK_DIR=$(PRNROOT)\gpd\vrtk\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=qplkres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),qplkres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=949

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\qplkres.rc \
    $(SRCDIR)\qplkres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\qplkres.ini \
    $(QNIX_DIR)\qxlpic2k.gpd \
    $(QNIX_DIR)\qxlsf1ek.gpd \
    $(QNIX_DIR)\qxlsf1sk.gpd \
    $(QNIX_DIR)\qxlsf3hk.gpd \
    $(QNIX_DIR)\qxlsf3sk.gpd \
    $(QNIX_DIR)\qxlpi20k.gpd \
    $(QNIX_DIR)\qxlpi30k.gpd \
    $(QNIX_DIR)\qxlpi40k.gpd \
    $(QNIX_DIR)\qxlsf1gk.gpd \
    $(QNIX_DIR)\qxlsf50k.gpd \
    $(QNIX_DIR)\qxlsf60k.gpd \
    $(QNIX_DIR)\qxlsf61k.gpd \
    $(QNIX_DIR)\qxlsf70k.gpd \
    $(QNIX_DIR)\qxlsf71k.gpd \
    $(QNIX_DIR)\qxlsf73k.gpd \
    $(QNIX_DIR)\qxlsf77k.gpd \
    $(QNIX_DIR)\qxlsf8nk.gpd \
    $(QNIX_DIR)\qxllsk.gpd \
    $(QNIX_DIR)\qxlsf1k.gpd \
    $(QNIX_DIR)\qxlsf1pk.gpd \
    $(QNIX_DIR)\qxlsf2k.gpd \
    $(QNIX_DIR)\qxlsf2pk.gpd \
    $(QNIX_DIR)\qxlsf3gk.gpd \
    $(QNIX_DIR)\qxlsf3k.gpd \
    $(VRTK_DIR)\vtlc2kk.gpd \
    $(VRTK_DIR)\vtlc4kk.gpd \
    $(VRTK_DIR)\vtlc6kk.gpd \
    $(VRTK_DIR)\vtls425k.gpd \
    $(VRTK_DIR)\vtls450k.gpd \
    $(VRTK_DIR)\vtls750k.gpd \
    $(VRTK_DIR)\vtls850k.gpd \
    $(VRTK_DIR)\vtls7ek.gpd \
    $(VRTK_DIR)\vtlsf35k.gpd \
    $(VRTK_DIR)\vtlsf41k.gpd \
    $(VRTK_DIR)\vtlsf42k.gpd \
    $(VRTK_DIR)\vtlsf43k.gpd \
    $(VRTK_DIR)\vtlsf44k.gpd \
    $(VRTK_DIR)\vtlsf45k.gpd \
    $(VRTK_DIR)\vtlsf50k.gpd \
    $(VRTK_DIR)\vtlsf55k.gpd \
    $(VRTK_DIR)\vtlsf65k.gpd \
    $(VRTK_DIR)\vtlsf70k.gpd \
    $(VRTK_DIR)\vtlsf75k.gpd \
    $(VRTK_DIR)\vtlsf78k.gpd \
    $(VRTK_DIR)\vtlsf80k.gpd \
    $(VRTK_DIR)\vtlsf85k.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\etc\qlaserb1.c ===
#include	<windef.h>
#include	<wingdi.h>
#include	<unidrv.h>

#include	"../modinit.c"

#define SCANLINE_BUFFER_SIZE	1280	// A3 landscape scanline length + extra

// Delta Raw Compression routine
int DeltaRawCompress(LPBYTE, LPBYTE, LPBYTE, WORD, WORD);

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

typedef struct tagQLASERDV 
{
  BOOL  bFirst;
  WORD  wLastScanLineLen;
  BYTE  lpLastScanLine[SCANLINE_BUFFER_SIZE];
} QLASERDV, FAR *LPQLASERDV;


BOOL MiniDrvEnablePDEV(LPDV lpdv, ULONG *pdevcaps)
{
    lpdv->fMdv = FALSE;
    if (!(lpdv->lpMdv = UniDrvAllocMem(sizeof(QLASERDV))))
         return FALSE;

    lpdv->fMdv = TRUE;
	((LPQLASERDV)lpdv->lpMdv)->bFirst = FALSE;
	((LPQLASERDV)lpdv->lpMdv)->wLastScanLineLen = 0;

    return TRUE;
}


VOID MiniDrvDisablePDEV(LPDV lpdv)
{
    if (lpdv->fMdv)
    {
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }
}


VOID FAR PASCAL fnOEMOutputCmd(LPDV lpdv, WORD wCmdCbId, PDWORD lpdwParams)
{
	if (wCmdCbId == 1) // StartPage
	{
        WriteSpoolBuf(lpdv, "\033}0;0;3B", 8);
		((LPQLASERDV)lpdv->lpMdv)->bFirst = TRUE;
	}
}


WORD FAR PASCAL CBFilterGraphics(LPDV lpdv, LPBYTE lpBuf, WORD wLen)
{
	BYTE  CompressedScanLine[SCANLINE_BUFFER_SIZE];
    BYTE  HeaderScanLine[4];
	WORD  nCompBufLen;
	LPQLASERDV  lpQDV = lpdv->lpMdv;

	if (lpQDV->bFirst)
	{
		ZeroMemory(lpQDV->lpLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		lpQDV->bFirst = FALSE;
	}
	nCompBufLen = (WORD) DeltaRawCompress(lpBuf, lpQDV->lpLastScanLine,
					CompressedScanLine, (lpQDV->wLastScanLineLen > wLen)
					? lpQDV->wLastScanLineLen : wLen, 0);

    HeaderScanLine[0] = 0;
    HeaderScanLine[1] = 0;
    HeaderScanLine[2] = (BYTE) (nCompBufLen >> 8);
    HeaderScanLine[3] = (BYTE) nCompBufLen;
    WriteSpoolBuf(lpdv, (LPBYTE) HeaderScanLine, 4);
    WriteSpoolBuf(lpdv, (LPBYTE) CompressedScanLine, nCompBufLen);

	CopyMemory(lpQDV->lpLastScanLine, lpBuf, wLen);
	if (lpQDV->wLastScanLineLen > wLen)
		ZeroMemory(lpQDV->lpLastScanLine + wLen, lpQDV->wLastScanLineLen - wLen);
    lpQDV->wLastScanLineLen = wLen;

    return nCompBufLen;
}


DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,    (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,   (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMOutputCmd,         (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,     (PFN)CBFilterGraphics  },
};


BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver
    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}


/*************************************************
 *
 * Image Delta Compression Routine
 *
 *===================================================
 * Input:
 *   nbyte       : # of byte, raw data
 *   Image_string: pointer of raw data
 *   Prn_string  : pointer of compress data
 * Output:
 *   Ret_count   : # of byte, compress data
**************************************************/
int DeltaRawCompress( Image_string, //pbData,
                 ORG_image,    //pbSeedRow,
                 Prn_string,   //pbReturn,
                 nbyte,        //usTotalBytes
                 nMagics)      //Magic number
LPBYTE Image_string;  /* pointer to original string */
LPBYTE ORG_image;     /* pointer to previous scanline's string */
LPBYTE Prn_string;    /* pointer to return string */
WORD  nbyte;         /* original number of bytes */
WORD  nMagics;       //Magic number
{
        int     c, Ret_count, Skip_flag, Skip_count;
        unsigned int     i, j, k, outcount;
        LPBYTE   Diff_ptr;
        LPBYTE   ORG_ptr;
        LPBYTE   Skip_ptr;
        BYTE    Diff_byte;
        BYTE    Diff_mask[8]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};

        BOOL bstart = TRUE;

        outcount = 0;
        Ret_count = 0;
        ORG_ptr = ORG_image;
        Skip_flag = TRUE;

        Skip_ptr = Prn_string++;
        *Skip_ptr = Skip_count = (nMagics/8)/8;

        k = (nbyte+7)/8;
        for(i=0;i<k;i++)
        {
           Diff_byte = 0;
           Diff_ptr = Prn_string++;

           for(j=0;j<8;j++)
           {
              if ( (i*8+j) >= nbyte ){
                  *Prn_string++= 0;
                  Diff_byte |= Diff_mask[j];
                  outcount++;
              } else {
                  c = *Image_string++;
                  if(c != *ORG_ptr){
                    *ORG_ptr++ = c;
                    *Prn_string++= c;
                    Diff_byte |= Diff_mask[j];
                    outcount++;
                  } else {
                    ORG_ptr++;
                  }
              }
           }
           if(Diff_byte == 0){
                if(Skip_flag == TRUE){
                        Skip_count++;
                        Prn_string--;
                }else{
                       *Diff_ptr = Diff_byte;
                       outcount++;
                }
           }else{
                if(Skip_flag == TRUE){
                        Skip_flag = FALSE;
                        *Skip_ptr = Skip_count;
                        outcount++;
                        *Diff_ptr = Diff_byte;
                        outcount++;
                }else{
                       *Diff_ptr = Diff_byte;
                       outcount++;
                }
                Ret_count = outcount;
           }
        }
        return(Ret_count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\etc\vlaserc1.c ===
#include	<windef.h>
#include	<wingdi.h>
#include	<unidrv.h>

#include	"../modinit.c"

#define SCANLINE_BUFFER_SIZE		1280	// A3 landscape scanline length + extra
#define ALL_COLOR_Y_MOVE_CMD_LEN	12		// length of Y move command for all colors
#define CC_CYAN		5	//current plain is cyan
#define CC_MAGENTA	6	//current plain is magenta
#define CC_YELLOW	7	//current plain is yellow
#define CC_BLACK	4	//current plain is black

// Block Image 2 Compression routines
WORD B2Compress(LPBYTE, LPBYTE, LPBYTE, WORD);
LPBYTE RLE_comp(LPBYTE);
WORD RLEencoding(LPBYTE, LPBYTE, WORD);

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

typedef struct tagVLASERDV 
{
  BOOL  bFirst;
  WORD  wCyanLastScanLineLen;
  WORD  wMagentaLastScanLineLen;
  WORD  wYellowLastScanLineLen;
  WORD  wBlackLastScanLineLen;
  BYTE  lpCyanLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpMagentaLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpYellowLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpBlackLastScanLine[SCANLINE_BUFFER_SIZE];
  UINT	fColor;
} VLASERDV, FAR *LPVLASERDV;


BOOL MiniDrvEnablePDEV(LPDV lpdv, ULONG *pdevcaps)
{
    lpdv->fMdv = FALSE;
    if (!(lpdv->lpMdv = UniDrvAllocMem(sizeof(VLASERDV))))
         return FALSE;

    lpdv->fMdv = TRUE;
	((LPVLASERDV)lpdv->lpMdv)->bFirst = FALSE;
	((LPVLASERDV)lpdv->lpMdv)->wCyanLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wMagentaLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wYellowLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wBlackLastScanLineLen = 0;

    return TRUE;
}


VOID MiniDrvDisablePDEV(LPDV lpdv)
{
    if (lpdv->fMdv)
    {
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }
}


VOID FAR PASCAL fnOEMOutputCmd(LPDV lpdv, WORD wCmdCbId, PDWORD lpdwParams)
{
	DWORD  i, nYMove;
	BYTE  cYMoveCommand[ALL_COLOR_Y_MOVE_CMD_LEN];
	LPBYTE lpBuf;
	
	switch (wCmdCbId) // StartPage
	{
		case 1:	// StartPage
				WriteSpoolBuf(lpdv, "\x1B}0;0;6B", 8);
				((LPVLASERDV)lpdv->lpMdv)->bFirst = TRUE;
				break;
		case 2: // AbortDoc
				lpBuf = UniDrvAllocMem(256);
				ZeroMemory(lpBuf, 256);
				WriteSpoolBuf(lpdv, lpBuf, 256);
				WriteSpoolBuf(lpdv, "\001\001\003\014\033}0D\0331S", 10);
				UniDrvFreeMem(lpBuf);
				break;
		case 100: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_CYAN; break;
		case 101: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_MAGENTA; break;
		case 102: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_YELLOW; break;
		case 103: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_BLACK; break;
		case 150:	for (nYMove = *lpdwParams; nYMove > 255; nYMove -= 255) // 0xFF
					{
						WriteSpoolBuf(lpdv, (LPBYTE)
							"\x04\x00\xFF\x05\x00\xFF\x06\x00\xFF\x07\x00\xFF",
							ALL_COLOR_Y_MOVE_CMD_LEN);
					}
					if (nYMove > 0)
					{
						cYMoveCommand[0] = 0x04;
						cYMoveCommand[1] = 0;
						cYMoveCommand[2] = (BYTE) nYMove;
						cYMoveCommand[3] = 0x05;
						cYMoveCommand[4] = 0;
						cYMoveCommand[5] = (BYTE) nYMove;
						cYMoveCommand[6] = 0x06;
						cYMoveCommand[7] = 0;
						cYMoveCommand[8] = (BYTE) nYMove;
						cYMoveCommand[9] = 0x07;
						cYMoveCommand[10] = 0;
						cYMoveCommand[11] = (BYTE) nYMove;
						WriteSpoolBuf(lpdv, (LPBYTE) cYMoveCommand,
										ALL_COLOR_Y_MOVE_CMD_LEN);
					}
    				break;
		default: ;
	}
}


WORD FAR PASCAL CBFilterGraphics(LPDV lpdv, LPBYTE lpBuf, WORD wLen)
{
	WORD  wLastScanLineLen;
	LPBYTE  lpLastScanLine;
	BYTE  CompressedScanLine[SCANLINE_BUFFER_SIZE];
	BYTE  HeaderColorPlain;
	BYTE  HeaderScanLine[3];
	WORD  nCompBufLen;
	LPVLASERDV  lpQDV = lpdv->lpMdv;

	if (lpQDV->bFirst)
	{
		ZeroMemory(lpQDV->lpCyanLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpMagentaLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpYellowLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpBlackLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		lpQDV->bFirst = FALSE;
	}
	
	switch (lpQDV->fColor)
	{
		case CC_CYAN:
			HeaderColorPlain = 0x05;
			wLastScanLineLen = lpQDV->wCyanLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpCyanLastScanLine;
			break;
		case CC_MAGENTA:
			HeaderColorPlain = 0x06;
			wLastScanLineLen = lpQDV->wMagentaLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpMagentaLastScanLine;
			break;
		case CC_YELLOW:
			HeaderColorPlain = 0x07;
			wLastScanLineLen = lpQDV->wYellowLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpYellowLastScanLine;
			break;
		case CC_BLACK:
			HeaderColorPlain = 0x04;
			wLastScanLineLen = lpQDV->wBlackLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpBlackLastScanLine;
			break;
		default:	// Black&White mode
			HeaderColorPlain = 0x04;
			wLastScanLineLen = lpQDV->wBlackLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpBlackLastScanLine;
	}
	
	nCompBufLen = B2Compress(lpLastScanLine, lpBuf,
					CompressedScanLine, (wLastScanLineLen > wLen)
					? wLastScanLineLen : wLen);
	
	// send color plain command				
	WriteSpoolBuf(lpdv, (LPBYTE) &HeaderColorPlain, 1);
	
	if (nCompBufLen == 0)  // same two line
	{
		WriteSpoolBuf(lpdv, (LPBYTE) "\x01", 1);
	}
	else
	{
		HeaderScanLine[0] = 0x02;
		HeaderScanLine[1] = (BYTE) (nCompBufLen >> 8);
		HeaderScanLine[2] = (BYTE) nCompBufLen;
		WriteSpoolBuf(lpdv, (LPBYTE) HeaderScanLine, 3);
		WriteSpoolBuf(lpdv, (LPBYTE) CompressedScanLine, nCompBufLen);
		switch (((LPVLASERDV)lpdv->lpMdv)->fColor)
		{
			case CC_CYAN:	 lpQDV->wCyanLastScanLineLen = wLen;  break;
			case CC_MAGENTA: lpQDV->wMagentaLastScanLineLen = wLen;  break;
			case CC_YELLOW:	 lpQDV->wYellowLastScanLineLen = wLen;  break;
			case CC_BLACK:	 lpQDV->wBlackLastScanLineLen = wLen;  break;
			default:  lpQDV->wBlackLastScanLineLen = wLen; // Black&White mode
		}
	}
	
    return nCompBufLen;
}


DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,    (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,   (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMOutputCmd,         (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,     (PFN)CBFilterGraphics  },
};


BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver
    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

//
//  Block Image 2 Compression
//
WORD B2Compress(LPBYTE pLastScanLine, LPBYTE pCurrentScanLine, LPBYTE pPrnBuf, WORD nImageWidth)
{
    LPBYTE  pLast, pCurrent, pComp;
    LPBYTE  pByteNum, pCountByte;
	WORD  i;
	BYTE  nSameCount, nDiffCount;
	BOOL  bSame = TRUE;

    pLast = pLastScanLine;
    pCurrent = pCurrentScanLine;
    pComp = pPrnBuf;

    pByteNum = pComp;
    nSameCount = 0;
    nDiffCount = 0;
    pCountByte = pComp++;

    for(i=0; i < nImageWidth; i++) {
        if(*pCurrent != *pLast) {
        	bSame = FALSE;
            nDiffCount++;
            if(nSameCount) {
                *pCountByte = nSameCount;
                pCountByte = pComp++;
                nSameCount = 0;
            }
            if(nDiffCount > 127) {
                *pCountByte = 127 + 128;
                pComp = RLE_comp(pCountByte);
                pCountByte = pComp++;
                nDiffCount -= 127;
            }
            *pLast = *pCurrent;
            *pComp++ = *pCurrent;
        } else {
            nSameCount++;
            if(nDiffCount) {
                *pCountByte = nDiffCount + 128;
                pComp = RLE_comp(pCountByte);
                pCountByte = pComp++;
                nDiffCount = 0;
            }
            if(nSameCount > 127) {
                *pCountByte = 127;
                pCountByte = pComp++;
                nSameCount -= 127;
            }
        }
        pCurrent++;
        pLast++;
    }  // end of for loop
    
    if(nSameCount) *pCountByte = nSameCount;
    if(nDiffCount) {
        *pCountByte = nDiffCount+128;
        pComp = RLE_comp(pCountByte);
    }
    
//    if (bSame)
//    	return((WORD) 0);
//    else
	    return((WORD) (pComp - pByteNum));
}

LPBYTE RLE_comp(LPBYTE p)
{
	WORD  i, count, RLEEncodedCount;
    LPBYTE  p1;
	BYTE  RLEBuffer[SCANLINE_BUFFER_SIZE];
            
    count = (WORD) (*p - 128);
	if(count > 4) {
		RLEEncodedCount = RLEencoding(p+1, (LPBYTE) RLEBuffer, count);
		if(RLEEncodedCount < count) {
			*p++ = 0;	// RLE encode indicator
			*p++ = (BYTE) RLEEncodedCount;
			p1 = RLEBuffer;
			for(i=0; i<RLEEncodedCount; i++) {
				*p++ = *p1++;
			}
			return(p);
		}
	}
	return(p+1+count);
}

WORD RLEencoding(LPBYTE pCurrent, LPBYTE pComp, WORD count)
{
	WORD	i, nByteNum;
    BYTE	curr, next, RLEcount;

	nByteNum = 0;
	RLEcount = 1;
	for(i=0; i<count-1; i++) {
		curr = *pCurrent++;
		next = *pCurrent;
		if(curr == next) {
			if(RLEcount == 255) {
				*pComp++ = RLEcount;
                *pComp++ = curr;
				nByteNum += 2;
				RLEcount = 1;
			} else {
				RLEcount++;
			} 
		} else {
			*pComp++ = RLEcount;
            *pComp++ = curr;
			nByteNum += 2;
			RLEcount = 1;
		}
	}
	*pComp++ = RLEcount;
    *pComp++ = next;
	nByteNum += 2;

	return(nByteNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\ddi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           DDI.C

Abstract:       Implementation of OEM DDI exports & OEM DDI hooks.

Functions:      OEMEnablePDEV
                OEMDisablePDEV
                OEMResetPDEV
                OEMEnableDriver
                OEMDisableDriver
                OEMxxx (DDI hooks)

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    03/15/2000 -Masatoshi Kubokura-
        V.1.11
    08/01/2000 -Masatoshi Kubokura-
        Modified for NT4
    09/07/2000 -Masatoshi Kubokura-
        Last Modified

--*/

#include <ctype.h>
#include "pdev.h"

#ifdef DDIHOOK
static const DRVFN OEMHookFuncs[] =
{
//  { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
//  { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
//  { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
//  { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
//  { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
//  { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
//  { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
//  { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
//  { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
//  { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
//  { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
//  { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
//  { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
//  { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
//  { INDEX_DrvPaint,               (PFN) OEMPaint               },
//  { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
//  { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
//  { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
//  { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            }
//, { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
//  { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
//  { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
//  { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
//  { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
//  { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
//  { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
//  { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
//  { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }
};
#endif // DDIHOOK


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)       // Unidrv's hook table
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(("OEMEnablePDEV() entry.\n"));

    // Allocate the OEMPDEV
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    // Initialize OEMPDEV
//  poempdev->fGeneral = 0;

#ifdef DDIHOOK
    // Fill Unidrv's hooks in OEMPDEV
    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        // search through Unidrv's hooks and locate the function ptr
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            poempdev->pfnUnidrv[i] = NULL;
        }
    }
#endif // DDIHOOK
    return (POEMPDEV) poempdev;
} //*** OEMEnablePDEV


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE(("OEMDisablePDEV() entry.\n"));

    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    MemFree(MINIDEV_DATA(pdevobj));
} //*** OEMDisablePDEV


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    POEMPDEV    poempdevOld = MINIDEV_DATA(pdevobjOld);
    POEMPDEV    poempdevNew = MINIDEV_DATA(pdevobjNew);

    VERBOSE(("OEMResetPDEV() entry.\n"));

    if (poempdevOld && poempdevNew)
    {
        LPBYTE      pSrc = (LPBYTE)poempdevOld;
        LPBYTE      pDst = (LPBYTE)poempdevNew;
        DWORD       dwCount = sizeof(OEMPDEV);

        // carry over from old OEMPDEV to new OEMPDEV
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;

        // set pointers of old OEMPDEV to NULL not to free memory
//        poempdevOld->pRPDLHeap2K = NULL;
    }
    return TRUE;
} //*** OEMResetPDEV


VOID APIENTRY OEMDisableDriver()
{
        VERBOSE(("OEMDisableDriver() entry.\n"));
} //*** OEMDisableDriver


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // VERBOSE(("OEMEnableDriver() entry.\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
#ifdef DDIHOOK
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;
#else
    pded->c = 0;
    pded->pdrvfn = NULL;
#endif // DDIHOOK


    return TRUE;
} //*** OEMEnableDriver


#ifdef DDIHOOK
//
// DDI hooks
//
BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);
    INT         iLen;

#if DBG
    // You can see debug messages on debugger terminal. (debug mode boot)
    giDebugLevel = DBG_VERBOSE;

    // You can debug with MS Visual Studio. (normal mode boot)
//    DebugBreak();
#endif // DBG

    VERBOSE(("OEMStartDoc() entry.\n"));
    VERBOSE(("  DocName=%ls\n", pwszDocName));

#ifdef WINNT_40     // @Aug/01/2000
    if (pwszDocName)
    {
        USHORT OemCodePage, AnsiCodePage;

        EngGetCurrentCodePage(&OemCodePage, &AnsiCodePage);
        EngWideCharToMultiByte((UINT)AnsiCodePage, (LPWSTR)pwszDocName,
                               (INT)(JOBNAMESIZE * sizeof(WCHAR)),
                               (LPSTR)poempdev->JobName, (INT)JOBNAMESIZE);
    }
#else  // !WINNT_40
    if (pwszDocName)
        CharToOemBuff((LPWSTR)pwszDocName, (LPSTR)poempdev->JobName, JOBNAMESIZE);
#endif // !WINNT_40
#if DBG
    giDebugLevel = DBG_ERROR;
#endif // DBG

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
} //*** OEMStartDoc

#if 0
BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTrg->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMBitBlt() entry.\n"));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));
} //*** OEMBitBlt


BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBlt() entry.\n"));

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMStretchBlt


BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBltROP() entry.\n"));

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));
} //*** OEMStretchBltROP


BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMCopyBits() entry.\n"));

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            pptlSrc));
} //*** OEMCopyBits


BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPlgBlt() entry.\n"));

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMPlgBlt


BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMAlphaBlend() entry.\n"));

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            pBlendObj
            ));
} //*** OEMAlphaBlend


BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGradientFill() entry.\n"));

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDst,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));
} //*** OEMGradientFill


BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTextOut() entry.\n"));

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));
} //*** OEMTextOut


BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStokePath() entry.\n"));

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));
} //*** OEMStrokePath


BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFillPath() entry.\n"));

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));
} //*** OEMFillPath


BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));
} //*** OEMStrokeAndFillPath


BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTarget->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
} //*** OEMRealizeBrush


BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartPage() entry.\n"));

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));
} //*** OEMStartPage


#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndPage() entry.\n"));

#if 0
    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }
#endif

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));
} //*** OEMSendPage


ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEscape() entry.\n"));

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMEscape


BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndDoc() entry.\n"));

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));
} //*** OEMEndDoc


////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFont() entry.\n"));

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));
} //*** OEMQueryFont


PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontTree() entry.\n"));

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));
} //*** OEMQueryFontTree


LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontData() entry.\n"));

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));
} //*** OEMQueryFontData


BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryAdvanceWidths() entry.\n"));

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));
} //*** OEMQueryAdvanceWidths


ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFontManagement() entry.\n"));

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMFontManagement

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGetGlyphMode() entry.\n"));

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));
} //*** OEMGetGlyphMode

/////// <- six font related DDI calls


BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMNextBand() entry.\n"));

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));
} //*** OEMNextBand


BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartBanding() entry.\n"));

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));
} //*** OEMStartBanding


ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMDitherColor() entry.\n"));

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));
} //*** OEMDitherColor


BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPaint() entry.\n"));

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));
} //*** OEMPaint


BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMLineTo() entry.\n"));

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));
} //*** OEMLineTo


BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTransparentBlt() entry.\n"));

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));
} //*** OEMTransparentBlt
#endif // if 0
#endif // DDIHOOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\comoem.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv OEM rendering plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e plugin from RPDL code.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
//      return E_NOTIMPL;

        OEMEnableDriver(dwDriverVersion, cbSize, pded);

        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
//      return E_NOTIMPL;
        OEMDisableDriver();
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
//      return E_NOTIMPL;
        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //
//        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;

        *pDevOem = pTemp;
        return S_OK;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
//      return E_NOTIMPL;
        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
//          pIUnknown->AddRef();
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void**)&(this->pOEMHelp));
            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }
//      this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);
        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\qplkres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// ######################

// Function Name: GetInfo
// Plug-in: Any
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::GetInfo(
    DWORD dwMode,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

// ######################

//
// Function Name: PublishDriverInterface
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

int __cdecl
iCompNames(
    void *p1,
    void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
}

LONG __stdcall
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            (int (__cdecl *)(const void *, const void *))iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

// #######################

//
// Function Name: EnableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: EnablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
//  return E_NOTIMPL;
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

//
// Function Name: DisablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
//  return E_NOTIMPL;
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//  return E_NOTIMPL;
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

//
// Function Name: DevMode
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

// ################


//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if (OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

HRESULT __stdcall
IOemCF::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\fcommon.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           FCOMMON.C

Abstract:       This includes the common functions file for rendering & UI plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/29/2000 -Masatoshi Kubokura-
        Created it.
    05/31/2000 -Masatoshi Kubokura-
        V.1.11

--*/

#include "COMMON.C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           PDEV.H

Abstract:       Header file for OEM rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Created it.
    10/11/2000 -Masatoshi Kubokura-
        Last modified.

--*/


//
// Files necessary for OEM plugin.
//

#include <minidrv.h>
#include <stdio.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"

//
// Misc definitions follows.
//

#ifdef DLLTEXT
#undef DLLTEXT
#endif // ifdef DLLTEXT
#define DLLTEXT(s)      "RENDER: " s

// ASSERT(VALID_PDEVOBJ) can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

////////////////////////////////////////////////////////
// DDI hooks
// Warning: the following enum order must match the
//          order in OEMHookFuncs[] in DDI.C.
////////////////////////////////////////////////////////
#ifdef DDIHOOK
enum {
//  UD_DrvRealizeBrush,
//  UD_DrvDitherColor,
//  UD_DrvCopyBits,
//  UD_DrvBitBlt,
//  UD_DrvStretchBlt,
//  UD_DrvStretchBltROP,
//  UD_DrvPlgBlt,
//  UD_DrvTransparentBlt,
//  UD_DrvAlphaBlend,
//  UD_DrvGradientFill,
//  UD_DrvTextOut,
//  UD_DrvStrokePath,
//  UD_DrvFillPath,
//  UD_DrvStrokeAndFillPath,
//  UD_DrvPaint,
//  UD_DrvLineTo,
//  UD_DrvStartPage,
//  UD_DrvSendPage,
//  UD_DrvEscape,
    UD_DrvStartDoc,
//  UD_DrvEndDoc,
//  UD_DrvNextBand,
//  UD_DrvStartBanding,
//  UD_DrvQueryFont,
//  UD_DrvQueryFontTree,
//  UD_DrvQueryFontData,
//  UD_DrvQueryAdvanceWidths,
//  UD_DrvFontManagement,
//  UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
#endif // DDIHOOK

#define JOBNAMESIZE         224

// rendering plugin device data
typedef struct _OEMPDEV {
    DWORD   fGeneral;                   // bit flags for general status
    BYTE    JobName[(JOBNAMESIZE*2)];   // for CharToOemBuff().
#ifdef DDIHOOK
    PFN     pfnUnidrv[MAX_DDI_HOOKS];   // Unidrv's hook function pointer
#endif // DDIHOOK
} OEMPDEV, *POEMPDEV;

// PCL Command callback IDs
#define CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF    1
#define CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON     2
#define CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF    3
#define CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON     4
#define CMD_ENDJOB_P5                           5
#define CMD_ENDJOB_P6                           6
#define CMD_STARTJOB_AUTOTRAYCHANGE_OFF         7
#define CMD_STARTJOB_AUTOTRAYCHANGE_ON          8
#define CMD_COLLATE_JOBOFFSET_OFF               9
#define CMD_COLLATE_JOBOFFSET_ROTATE            10
#define CMD_COLLATE_JOBOFFSET_SHIFT             11
#define CMD_COPIES_P5                           12
#define CMD_ENDPAGE_P6                          13
#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\riafres.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           RIAFRES.C

Abstract:       Main file for OEM rendering plugin module.

Functions:      OEMCommandCallback

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Created it.
    06/07/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    10/17/2000 -Masatoshi Kubokura-
        Last modified.

--*/

#include "pdev.h"

//
// Misc definitions and declarations.
//
#ifndef WINNT_40
#define sprintf     wsprintfA
#define strcmp      lstrcmpA
#define strlen      lstrlenA    // @Aug/01/2000
#endif // WINNT_40

// external prototypes
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);

// command definition
static BYTE PJL_PROOFJOB[]       = "@PJL PROOFJOB\n";
static BYTE PJL_SECUREJOB[]      = "@PJL SECUREJOB\n";  // Aficio AP3200 and later (GW model)
static BYTE PJL_DISKIMAGE_OFF[]  = "@PJL SET DISKIMAGE=OFF\n";
static BYTE PJL_DISKIMAGE_PORT[] = "@PJL SET DISKIMAGE=PORTRAIT\n";
static BYTE PJL_DISKIMAGE_LAND[] = "@PJL SET DISKIMAGE=LANDSCAPE\n";
static BYTE PJL_ORIENT_PORT[]    = "@PJL SET ORIENTATION=PORTRAIT\n";
static BYTE PJL_ORIENT_LAND[]    = "@PJL SET ORIENTATION=LANDSCAPE\n";
static BYTE PJL_JOBPASSWORD[]    = "@PJL SET JOBPASSWORD=%s\n";
static BYTE PJL_USERID[]         = "@PJL SET USERID=\x22%s\x22\n";
static BYTE PJL_USERCODE[]       = "@PJL SET USERCODE=\x22%s\x22\n";
static BYTE PJL_TIME_DATE[]      = "@PJL SET TIME=\x22%02d:%02d:%02d\x22\n@PJL SET DATE=\x22%04d/%02d/%02d\x22\n";
static BYTE PJL_STARTJOB_AUTOTRAYCHANGE_OFF[] = "\x1B%%-12345X@PJL JOB NAME=\x22%s\x22\n@PJL SET AUTOTRAYCHANGE=OFF\n";
static BYTE PJL_STARTJOB_AUTOTRAYCHANGE_ON[]  = "\x1B%%-12345X@PJL JOB NAME=\x22%s\x22\n@PJL SET AUTOTRAYCHANGE=ON\n";
static BYTE PJL_ENDJOB[]         = "\x1B%%-12345X@PJL EOJ NAME=\x22%s\x22\n\x1B%%-12345X";
static BYTE PJL_QTY_JOBOFFSET_OFF[]    = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=OFF\n";
static BYTE PJL_QTY_JOBOFFSET_ROTATE[] = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=ROTATE\n";
static BYTE PJL_QTY_JOBOFFSET_SHIFT[]  = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=SHIFT\n";

static BYTE P5_COPIES[]          = "\x1B&l%dX";
static BYTE P6_ENDPAGE[]         = "\xc1%c%c\xf8\x31\x44";
static BYTE P6_ENDSESSION[]      = "\x49\x42";


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams)
{
    INT     ocmd;
    BYTE    Cmd[256];
#ifdef WINNT_40     // @Aug/01/2000
    ENG_TIME_FIELDS st;
#else  // !WINNT_40
    SYSTEMTIME  st;
#endif // !WINNT_40
    FILEDATA    FileData;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);
    DWORD       dwCopy;

#if DBG
    // You can see debug messages on debugger terminal. (debug mode boot)
    giDebugLevel = DBG_VERBOSE;

    // You can debug with MS Visual Studio. (normal mode boot)
//    DebugBreak();
#endif // DBG

    VERBOSE(("OEMCommandCallback() entry (%ld).\n", dwCmdCbID));

    // verify pdevobj okay
    ASSERT(VALID_PDEVOBJ(pdevobj));

    // Check whether copy# is in the range.  @Sep/07/2000
    switch (dwCmdCbID)
    {
      case CMD_COLLATE_JOBOFFSET_OFF:
      case CMD_COLLATE_JOBOFFSET_ROTATE:
      case CMD_COLLATE_JOBOFFSET_SHIFT:
      case CMD_COPIES_P5:
      case CMD_ENDPAGE_P6:
        if((dwCopy = *pdwParams) > 999L)        // *pdwParams: NumOfCopies
            dwCopy = 999L;
        else if(dwCopy < 1L)
            dwCopy = 1L;
        break;
    }

    // Emit commands.
    ocmd = 0;
    switch (dwCmdCbID)
    {
      case CMD_STARTJOB_AUTOTRAYCHANGE_OFF:         // Aficio AP3200 and later (GW model)
      case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
      case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
        ocmd = sprintf(Cmd, PJL_STARTJOB_AUTOTRAYCHANGE_OFF, pOEM->JobName);
        goto _EMIT_JOB_NAME;

      case CMD_STARTJOB_AUTOTRAYCHANGE_ON:          // Aficio AP3200 and later (GW model)
      case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:     // Aficio 551,700,850,1050
      case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:     // Aficio 551,700,850,1050
        ocmd = sprintf(Cmd, PJL_STARTJOB_AUTOTRAYCHANGE_ON, pOEM->JobName);

      _EMIT_JOB_NAME:
        // Emit job name
        VERBOSE(("  Start Job=%s\n", Cmd));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
        switch (pOEMExtra->JobType)
        {
          default:
          case IDC_RADIO_JOB_NORMAL:
            if (CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON  == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON  == dwCmdCbID)
            {
                ocmd = sprintf(Cmd, PJL_DISKIMAGE_OFF);
            }
            if (IDC_RADIO_LOG_ENABLED == pOEMExtra->LogDisabled)
                goto _EMIT_USERID_USERCODE;
            break;

          case IDC_RADIO_JOB_SAMPLE:
            ocmd = sprintf(Cmd, PJL_PROOFJOB);
            if (CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON  == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON  == dwCmdCbID)
            {
                ocmd += sprintf(&Cmd[ocmd], PJL_DISKIMAGE_OFF);
            }
            goto _CHECK_PRINT_DONE;

          case IDC_RADIO_JOB_SECURE:
            switch (dwCmdCbID)
            {
              case CMD_STARTJOB_AUTOTRAYCHANGE_OFF:         // Aficio AP3200 and later (GW model)
              case CMD_STARTJOB_AUTOTRAYCHANGE_ON:
                ocmd = sprintf(Cmd, PJL_SECUREJOB);
                break;
              case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
              case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:
                ocmd = sprintf(Cmd, PJL_DISKIMAGE_PORT);
                break;
              case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
              case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:
                ocmd = sprintf(Cmd, PJL_DISKIMAGE_LAND);
                break;
            }
            ocmd += sprintf(&Cmd[ocmd], PJL_JOBPASSWORD, pOEMExtra->PasswordBuf);
          _CHECK_PRINT_DONE:
            // If previous print is finished and hold-options flag isn't valid,
            // do not emit sample-print/secure-print command.
            // This prevents unexpected job until user pushes Apply button on the
            // Job/Log property sheet.
            FileData.fUiOption = 0;
            RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
            if (BITTEST32(FileData.fUiOption, PRINT_DONE) &&
                !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
            {
                VERBOSE(("** Emit Nothing. **\n"));
                ocmd = 0;
            }
          _EMIT_USERID_USERCODE:
            if (1 <= strlen(pOEMExtra->UserIdBuf))
                ocmd += sprintf(&Cmd[ocmd], PJL_USERID, pOEMExtra->UserIdBuf);
            else
                ocmd += sprintf(&Cmd[ocmd], PJL_USERID, "?");

            if (1 <= strlen(pOEMExtra->UserCodeBuf))
                ocmd += sprintf(&Cmd[ocmd], PJL_USERCODE, pOEMExtra->UserCodeBuf);

#ifdef WINNT_40     // @Aug/01/2000
            EngQueryLocalTime(&st); 
            ocmd += sprintf(&Cmd[ocmd], PJL_TIME_DATE, st.usHour, st.usMinute, st.usSecond,
                            st.usYear, st.usMonth, st.usDay);
#else  // !WINNT_40
            GetLocalTime(&st);
            ocmd += sprintf(&Cmd[ocmd], PJL_TIME_DATE, st.wHour, st.wMinute, st.wSecond,
                            st.wYear, st.wMonth, st.wDay);
#endif // !WINNT_40
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            break;
        }
        // Emit orientation (Aficio 551,700,850,1050)
        switch (dwCmdCbID)
        {
          case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:
          case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:
            WRITESPOOLBUF(pdevobj, PJL_ORIENT_PORT, sizeof(PJL_ORIENT_PORT)-1);
            break;
          case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:
          case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:
            WRITESPOOLBUF(pdevobj, PJL_ORIENT_LAND, sizeof(PJL_ORIENT_LAND)-1);
            break;
        }
        break;


      case CMD_COLLATE_JOBOFFSET_OFF:           // @Sep/08/2000
        if (IDC_RADIO_JOB_SAMPLE != pOEMExtra->JobType)     // if NOT Sample Print, QTY=1 is emitted here.
            dwCopy = 1L;
        ocmd = sprintf(Cmd, PJL_QTY_JOBOFFSET_OFF, dwCopy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COLLATE_JOBOFFSET_ROTATE:        // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print
            ocmd = sprintf(Cmd, PJL_QTY_JOBOFFSET_ROTATE, dwCopy);  // QTY=n is emitted here.
        else
            ocmd = sprintf(Cmd, PJL_QTY_JOBOFFSET_OFF, 1);          // QTY=1 is emitted here.
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COLLATE_JOBOFFSET_SHIFT:         // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print
            ocmd = sprintf(Cmd, PJL_QTY_JOBOFFSET_SHIFT, dwCopy);   // QTY=n is emitted here.
        else
            ocmd = sprintf(Cmd, PJL_QTY_JOBOFFSET_OFF, 1);          // QTY=1 is emitted here.
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COPIES_P5:                       // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print (QTY=n was emitted before.)
            dwCopy = 1L;
        ocmd = sprintf(Cmd, P5_COPIES, dwCopy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_ENDPAGE_P6:                      // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print (QTY=n was emitted before.)
            dwCopy = 1L;
        ocmd = sprintf(Cmd, P6_ENDPAGE, (BYTE)dwCopy, (BYTE)(dwCopy >> 8));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_ENDJOB_P6:                       // @Aug/23/2000
        WRITESPOOLBUF(pdevobj, P6_ENDSESSION, sizeof(P6_ENDSESSION)-1);
        // go through
      case CMD_ENDJOB_P5:
        ocmd = sprintf(Cmd, PJL_ENDJOB, pOEM->JobName);
        VERBOSE(("  End Job=%s\n", Cmd));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        switch (pOEMExtra->JobType)
        {
          case IDC_RADIO_JOB_SAMPLE:
          case IDC_RADIO_JOB_SECURE:
            // Set PRINT_DONE flag in the file 
            FileData.fUiOption = pOEMExtra->fUiOption;
            BITSET32(FileData.fUiOption, PRINT_DONE);
            RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_WRITE);
            break;

          default:
            break;
        }
        break;

      default:
        ERR((("Unknown callback ID = %d.\n"), dwCmdCbID));
        break;
    }

#if DBG
    giDebugLevel = DBG_ERROR;
#endif // DBG
    return 0;
} //*** OEMCommandCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",        // This disables other compression.
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR_GS=$(PRNROOT)\gpd\geste\usa
GPDDIR_IF=$(PRNROOT)\gpd\intec\usa
GPDDIR_LR=$(PRNROOT)\gpd\lanie\usa
GPDDIR_NR=$(PRNROOT)\gpd\nrg\usa
GPDDIR_RI=$(PRNROOT)\gpd\ricoh\usa
GPDDIR_SV=$(PRNROOT)\gpd\savin\usa
SRCDIR=..

TARGETNAME=riafres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),riafres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(SRCDIR)\..\riafui;$(PRNROOT)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\riafres.rc \
    $(SRCDIR)\riafres.c \
    $(SRCDIR)\fcommon.c \
    $(SRCDIR)\ddi.c

MISCFILES=\
    $(GPDDIR_GS)\GS32105.GPD \
    $(GPDDIR_GS)\GS3215S.GPD \
    $(GPDDIR_GS)\GS3218.GPD \
    $(GPDDIR_GS)\GS3222.GPD \
    $(GPDDIR_GS)\GS3227.GPD \
    $(GPDDIR_GS)\GS3235.GPD \
    $(GPDDIR_GS)\GS3235E.GPD \
    $(GPDDIR_GS)\GS3235S.GPD \
    $(GPDDIR_GS)\GS3245.GPD \
    $(GPDDIR_GS)\GS3245E.GPD \
    $(GPDDIR_GS)\GS3255.GPD \
    $(GPDDIR_GS)\GS3265.GPD \
    $(GPDDIR_GS)\GS3285.GPD \
    $(GPDDIR_GS)\GS3355.GPD \
    $(GPDDIR_GS)\GS3370.GPD \
    $(GPDDIR_GS)\GSP7014.GPD \
    $(GPDDIR_GS)\GSP7016.GPD \
    $(GPDDIR_GS)\GSP7020.GPD \
    $(GPDDIR_GS)\GSP7021.GPD \
    $(GPDDIR_GS)\GSP7026.GPD \
    $(GPDDIR_GS)\GSP7026N.GPD \
    $(GPDDIR_GS)\GSP7027.GPD \
    $(GPDDIR_GS)\GSP7032.GPD \
    $(GPDDIR_GS)\GSP7045.GPD \
    $(GPDDIR_IF)\IF4105MF.GPD \
    $(GPDDIR_IF)\IF4150MF.GPD \
    $(GPDDIR_IF)\IF4180MF.GPD \
    $(GPDDIR_IF)\IF4220MF.GPD \
    $(GPDDIR_IF)\IF4270MF.GPD \
    $(GPDDIR_IF)\IF4351MF.GPD \
    $(GPDDIR_IF)\IF4352MF.GPD \
    $(GPDDIR_IF)\IF4451MF.GPD \
    $(GPDDIR_IF)\IF4550MF.GPD \
    $(GPDDIR_IF)\IF4551MF.GPD \
    $(GPDDIR_IF)\IF4651MF.GPD \
    $(GPDDIR_IF)\IF4700MF.GPD \
    $(GPDDIR_IF)\IF4850MF.GPD \
    $(GPDDIR_IF)\IFP320.GPD \
    $(GPDDIR_IF)\IFP450.GPD \
    $(GPDDIR_LR)\LR5218.GPD \
    $(GPDDIR_LR)\LR5222.GPD \
    $(GPDDIR_LR)\LR5227.GPD \
    $(GPDDIR_LR)\LR5235.GPD \
    $(GPDDIR_LR)\LR5245.GPD \
    $(GPDDIR_LR)\LR5255.GPD \
    $(GPDDIR_LR)\LR5265.GPD \
    $(GPDDIR_LR)\LR5435.GPD \
    $(GPDDIR_LR)\LR5445.GPD \
    $(GPDDIR_LR)\LR5455.GPD \
    $(GPDDIR_LR)\LR5470.GPD \
    $(GPDDIR_LR)\LR5485.GPD \
    $(GPDDIR_LR)\LR5505.GPD \
    $(GPDDIR_NR)\NRD4105.GPD \
    $(GPDDIR_NR)\NRD415S.GPD \
    $(GPDDIR_NR)\NRD418.GPD \
    $(GPDDIR_NR)\NRD422.GPD \
    $(GPDDIR_NR)\NRD427.GPD \
    $(GPDDIR_NR)\NRD435.GPD \
    $(GPDDIR_NR)\NRD435S.GPD \
    $(GPDDIR_NR)\NRD445.GPD \
    $(GPDDIR_NR)\NRD455.GPD \
    $(GPDDIR_NR)\NRD465.GPD \
    $(GPDDIR_NR)\NRD485.GPD \
    $(GPDDIR_NR)\NRD555.GPD \
    $(GPDDIR_NR)\NRD570.GPD \
    $(GPDDIR_NR)\NRP7014.GPD \
    $(GPDDIR_NR)\NRP7016.GPD \
    $(GPDDIR_NR)\NRP7020.GPD \
    $(GPDDIR_NR)\NRP7021.GPD \
    $(GPDDIR_NR)\NRP7026.GPD \
    $(GPDDIR_NR)\NRP7026N.GPD \
    $(GPDDIR_NR)\NRP7027.GPD \
    $(GPDDIR_NR)\NRP7032.GPD \
    $(GPDDIR_NR)\NRP7045.GPD \
    $(GPDDIR_RI)\RIAF1050.GPD \
    $(GPDDIR_RI)\RIAF150.GPD \
    $(GPDDIR_RI)\RIAF180.GPD \
    $(GPDDIR_RI)\RIAF18X.GPD \
    $(GPDDIR_RI)\RIAF220.GPD \
    $(GPDDIR_RI)\RIAF270.GPD \
    $(GPDDIR_RI)\RIAF27X.GPD \
    $(GPDDIR_RI)\RIAF340.GPD \
    $(GPDDIR_RI)\RIAF34X.GPD \
    $(GPDDIR_RI)\RIAF350.GPD \
    $(GPDDIR_RI)\RIAF350E.GPD \
    $(GPDDIR_RI)\RIAF35EX.GPD \
    $(GPDDIR_RI)\RIAF35X.GPD \
    $(GPDDIR_RI)\RIAF450.GPD \
    $(GPDDIR_RI)\RIAF450E.GPD \
    $(GPDDIR_RI)\RIAF45EX.GPD \
    $(GPDDIR_RI)\RIAF45X.GPD \
    $(GPDDIR_RI)\RIAF550.GPD \
    $(GPDDIR_RI)\RIAF551.GPD \
    $(GPDDIR_RI)\RIAF5MAC.GPD \
    $(GPDDIR_RI)\RIAF650.GPD \
    $(GPDDIR_RI)\RIAF65X.GPD \
    $(GPDDIR_RI)\RIAF6MAC.GPD \
    $(GPDDIR_RI)\RIAF700.GPD \
    $(GPDDIR_RI)\RIAF70X.GPD \
    $(GPDDIR_RI)\RIAF850.GPD \
    $(GPDDIR_RI)\RIAF85X.GPD \
    $(GPDDIR_RI)\RIAP1400.GPD \
    $(GPDDIR_RI)\RIAP140X.GPD \
    $(GPDDIR_RI)\RIAP1600.GPD \
    $(GPDDIR_RI)\RIAP2000.GPD \
    $(GPDDIR_RI)\RIAP200X.GPD \
    $(GPDDIR_RI)\RIAP2100.GPD \
    $(GPDDIR_RI)\RIAP2600.GPD \
    $(GPDDIR_RI)\RIAP260E.GPD \
    $(GPDDIR_RI)\RIAP260N.GPD \
    $(GPDDIR_RI)\RIAP260X.GPD \
    $(GPDDIR_RI)\RIAP26NE.GPD \
    $(GPDDIR_RI)\RIAP2700.GPD \
    $(GPDDIR_RI)\RIAP270X.GPD \
    $(GPDDIR_RI)\RIAP3200.GPD \
    $(GPDDIR_RI)\RIAP320X.GPD \
    $(GPDDIR_RI)\RIAP4500.GPD \
    $(GPDDIR_RI)\RIAP450X.GPD \
    $(GPDDIR_SV)\SV2015DP.GPD \
    $(GPDDIR_SV)\SV2055DP.GPD \
    $(GPDDIR_SV)\SV2070DP.GPD \
    $(GPDDIR_SV)\SV2085DP.GPD \
    $(GPDDIR_SV)\SV2105DP.GPD \
    $(GPDDIR_SV)\SV9918DP.GPD \
    $(GPDDIR_SV)\SV9922DP.GPD \
    $(GPDDIR_SV)\SV9927DP.GPD \
    $(GPDDIR_SV)\SV9935D.GPD \
    $(GPDDIR_SV)\SV9935DE.GPD \
    $(GPDDIR_SV)\SV9935DP.GPD \
    $(GPDDIR_SV)\SV9945DE.GPD \
    $(GPDDIR_SV)\SV9945DP.GPD \
    $(GPDDIR_SV)\SV9955DP.GPD \
    $(GPDDIR_SV)\SV9965DP.GPD \
    $(GPDDIR_SV)\SVSLP14.GPD \
    $(GPDDIR_SV)\SVSLP16.GPD \
    $(GPDDIR_SV)\SVSLP20.GPD \
    $(GPDDIR_SV)\SVSLP21.GPD \
    $(GPDDIR_SV)\SVSLP26.GPD \
    $(GPDDIR_SV)\SVSLP26N.GPD \
    $(GPDDIR_SV)\SVSLP27.GPD \
    $(GPDDIR_SV)\SVSLP32.GPD \
    $(GPDDIR_SV)\SVSLP45.GPD \
    $(SRCDIR)\riafres1.ini \
    $(SRCDIR)\riafres2.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\oem.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           OEM.H

Abstract:       Header file for OEM UI/rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    03/02/2000 -Masatoshi Kubokura-
        Created it.
    09/22/2000 -Masatoshi Kubokura-
        Last modified.

--*/


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_VERSION      0x00010000L
#define WRITESPOOLBUF(p, s, n) ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#define MINIDEV_DATA(p)     ((POEMPDEV)((p)->pdevOEM))         // device data during job
#define MINIPRIVATE_DM(p)   ((POEMUD_EXTRADATA)((p)->pOEMDM))  // private devmode

#define OEM_SIGNATURE   'RIAF'      // RICOH Aficio printers
#define DLLTEXT(s)      "UI: " s
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RIAFMSVS.RC
//
#define IDS_ERR_USERID_TITLE            200
#define IDS_ERR_USERID_MSG              201
#define IDS_ERR_PASSWORD_TITLE          202
#define IDS_ERR_PASSWORD_MSG            203
#define IDS_ERR_USERCODE_TITLE          204
#define IDS_ERR_USERCODE_MSG            205
#define IDS_ITEM_HARDDISK               206
#define IDS_ITEM_MEMORY_HARDDISK        207
#define ITEM_HARDDISK_NAMES             (IDS_ITEM_MEMORY_HARDDISK-IDS_ITEM_HARDDISK+1)
#define IDD_JOBMAIN                     500
#define IDC_LABEL_JOBMAIN_USERID        1000
#define IDC_LABEL_JOBMAIN_USERID2       1001
#define IDC_LABEL_JOBMAIN_USERID3       1002
#define IDC_LABEL_JOBMAIN_JOB           1003
#define IDC_LABEL_JOBMAIN_PASSWORD      1004
#define IDC_LABEL_JOBMAIN_PASSWORD2     1005
#define IDC_LABEL_JOBMAIN_LOG           1006
#define IDC_LABEL_JOBMAIN_USERCODE      1007
#define IDC_LABEL_JOBMAIN_USERCODE2     1008
#define IDC_EDIT_JOBMAIN_USERID         1009
#define IDC_EDIT_JOBMAIN_PASSWORD       1010
#define IDC_EDIT_JOBMAIN_USERCODE       1011
#define IDC_RADIO_JOB_NORMAL            1012
#define IDC_RADIO_JOB_SAMPLE            1013
#define IDC_RADIO_JOB_SECURE            1014
#define IDC_RADIO_LOG_DISABLED          1015
#define IDC_RADIO_LOG_ENABLED           1016
#define IDC_CHECK_JOB_DEFAULT           1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        501
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           208
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\devmode.h ===
//
//  Copyright (c) 1998-2000  Microsoft Corporation & RICOH Co., Ltd.
//  All rights reserved.
//
//  FILE:       Devmode.h
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for devmode functions.
//
//  PLATFORMS:  Windows NT
//
//  Revision History:
//      03/02/2000 -Masatoshi Kubokura-
//          Modified DDK sample code.
//      09/22/2000 -Masatoshi Kubokura-
//          Last modified.
//

#ifndef _DEVMODE_H
#define _DEVMODE_H

#include <windows.h>   // for UI
#include <compstui.h>  // for UI
#include <winddiui.h>  // for UI
#include <prcomoem.h>

////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

// buffer size
#define USERID_LEN                  8
#define PASSWORD_LEN                4
#define USERCODE_LEN                8
#define MY_MAX_PATH                 80

// private devmode
typedef struct _OEMUD_EXTRADATA{
    OEM_DMEXTRAHEADER   dmOEMExtra;
// common data between UI & rendering plugin ->
    DWORD   fUiOption;      // bit flags for UI option  (This must be after dmOEMExtra)
    WORD    JobType;
    WORD    LogDisabled;
    BYTE    UserIdBuf[USERID_LEN+1];
    BYTE    PasswordBuf[PASSWORD_LEN+1];
    BYTE    UserCodeBuf[USERCODE_LEN+1];
    WCHAR   SharedFileName[MY_MAX_PATH+16];
// <-
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef const OEMUD_EXTRADATA *PCOEMUD_EXTRADATA;

// options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA pOEMExtra;
    WORD    JobType;
    WORD    LogDisabled;
    WCHAR   UserIdBuf[USERID_LEN+1];
    WCHAR   PasswordBuf[PASSWORD_LEN+1];
    WCHAR   UserCodeBuf[USERCODE_LEN+1];
} UIDATA, *PUIDATA;

// file data for UI & rendering plugin
typedef struct _FILEDATA{
    DWORD   fUiOption;      // UI option flag
} FILEDATA, *PFILEDATA;

// bit definitions of fUiOption
#define HOLD_OPTIONS            0   // 1:hold options after printing
#define PRINT_DONE              1   // 1:printing done (rendering plugin sets this)
//   UI plugin local ->
#define UIPLUGIN_NOPERMISSION   16  // same as DM_NOPERMISSION
#define JOBLOGDLG_UPDATED       17  // 1:Job/Log dialog updated
//   <-

// registry value name
#define REG_HARDDISK_INSTALLED  L"HardDiskInstalled"

// flag bit operation
#define BIT(num)                ((DWORD)1<<(num))
#define BITCLR32(flag,num)      ((flag) &= ~BIT(num))
#define BITSET32(flag,num)      ((flag) |= BIT(num))
#define BITTEST32(flag,num)     ((flag) & BIT(num))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\riafui.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           RIAFUI.CPP

Abstract:       Main file for OEM UI plugin module.

Functions:      OEMDocumentPropertySheets
                OEMCommonUIProp

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Began to modify for PCL5e/PScript plugin from RPDL code.
    03/31/2000 -Masatoshi Kubokura-
        SetWindowLong -> SetWindowLongPtr for 64bit build.
    06/07/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    11/29/2000 -Masatoshi Kubokura-
        Last modified

--*/


#include <minidrv.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"
#include <prsht.h>
#include <mbstring.h>   // _ismbcdigit, _ismbcalnum

////////////////////////////////////////////////////////
//      GLOBALS
////////////////////////////////////////////////////////
HINSTANCE ghInstance = NULL;


extern "C" {
////////////////////////////////////////////////////////
//      EXTERNAL PROTOTYPES
////////////////////////////////////////////////////////
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////
INT_PTR APIENTRY JobPageProc(HWND, UINT, WPARAM, LPARAM);


//////////////////////////////////////////////////////////////////////////
//  Function:   DllMain
//
//  Description:  Dll entry point for initialization..
//
//////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
#if DBG
//giDebugLevel = DBG_VERBOSE;
////#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif // DBG
    VERBOSE((DLLTEXT("** enter DllMain **\n")));
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            VERBOSE((DLLTEXT("** Process attach. **\n")));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            VERBOSE((DLLTEXT("Thread attach.\n")));
            break;

        case DLL_PROCESS_DETACH:
            VERBOSE((DLLTEXT("Process detach.\n")));
            break;

        case DLL_THREAD_DETACH:
            VERBOSE((DLLTEXT("Thread detach.\n")));
            break;
    }

    return TRUE;
} //*** DllMain


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDocumentPropertySheets
//////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY OEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LRESULT lResult = FALSE;

#if DBG
    giDebugLevel = DBG_VERBOSE;
#endif // DBG

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        IsBadWritePtr(pPSUIInfo, pPSUIInfo->cbSize)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
        ||
        ( (PROPSHEETUI_REASON_INIT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_INFO_HEADER != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_ICON != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_SET_RESULT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_DESTROY != pPSUIInfo->Reason)
        )
      )
    {
        ERR((DLLTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\n")));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    VERBOSE(("\n"));
    VERBOSE((DLLTEXT("OEMDocumentPropertySheets() entry. Reason=%d\n"), pPSUIInfo->Reason));

// @Aug/29/2000 ->
#ifdef DISKLESSMODEL
    {
        DWORD   dwError, dwType, dwNeeded;
        BYTE    ValueData;
        POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

        dwError = GetPrinterData(pOEMUIPSParam->hPrinter, REG_HARDDISK_INSTALLED, &dwType,
                                 (PBYTE)&ValueData, sizeof(BYTE), &dwNeeded);
        if (ERROR_SUCCESS != dwError)
        {
            VERBOSE((DLLTEXT("  CAN'T READ REGISTRY (%d).\n"), dwError));
            return FALSE;
        }
        else if (!ValueData)
        {
            VERBOSE((DLLTEXT("  HARD DISK ISN'T INSTALLED.\n")));
            return FALSE;
        }
    }
#endif // DISKLESSMODEL
// @Aug/29/2000 <-

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;
                POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pOEMUIPSParam);
#ifdef WINNT_40
                VERBOSE((DLLTEXT("** dwFlags=%lx **\n"), pOEMUIPSParam->dwFlags));
                if (pOEMUIPSParam->dwFlags & DM_NOPERMISSION)
                    BITSET32(pOEMExtra->fUiOption, UIPLUGIN_NOPERMISSION);
#endif // WINNT_40

                pPSUIInfo->UserData = NULL;

                if ((pPSUIInfo->UserData = (LPARAM)HeapAlloc(pOEMUIPSParam->hOEMHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             sizeof(UIDATA))))
                {
                    PROPSHEETPAGE   Page;
                    PUIDATA         pUiData = (PUIDATA)pPSUIInfo->UserData;
                    FILEDATA        FileData;   // <- pFileData (formerly use MemAllocZ) @2000/03/15

                    // read PRINT_DONE flag from data file
                    FileData.fUiOption = 0;
                    RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
                    // set PRINT_DONE flag
                    if (BITTEST32(FileData.fUiOption, PRINT_DONE))
                        BITSET32(pOEMExtra->fUiOption, PRINT_DONE);
                    VERBOSE((DLLTEXT("** Flag=%lx,File Name=%ls **\n"),
                            pOEMExtra->fUiOption, pOEMExtra->SharedFileName));

                    pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
                    pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                    pUiData->pOEMExtra = pOEMExtra;

                    // Init property page.
                    memset(&Page, 0, sizeof(PROPSHEETPAGE));
                    Page.dwSize = sizeof(PROPSHEETPAGE);
                    Page.dwFlags = PSP_DEFAULT;
                    Page.hInstance = ghInstance;
                    Page.pszTemplate = MAKEINTRESOURCE(IDD_JOBMAIN);
                    Page.pfnDlgProc = (DLGPROC)JobPageProc;
                    Page.lParam = (LPARAM)pUiData;

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                         CPSFUNC_ADD_PROPSHEETPAGE,
                                                         (LPARAM)&Page, 0);
                    pUiData->hPropPage = (HANDLE)lResult;
                    VERBOSE((DLLTEXT("** INIT: lResult=%x **\n"), lResult));
                    lResult = (lResult > 0)? TRUE : FALSE;
                }
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            lResult = TRUE;
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            if (pPSUIInfo->UserData)
            {
                POEMUIPSPARAM   pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

                HeapFree(pOEMUIPSParam->hOEMHeap, 0, (void*)pPSUIInfo->UserData);
            }
            break;
    }

    pPSUIInfo->Result = lResult;
    return lResult;
} //*** OEMDocumentPropertySheets


/***************************************************************************
    Function Name : InitMainDlg
***************************************************************************/
VOID InitMainDlg(
HWND hDlg,
PUIDATA pUiData)
{
    // initialize edit box
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERID, EM_LIMITTEXT, USERID_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, EM_LIMITTEXT, PASSWORD_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERCODE, EM_LIMITTEXT, USERCODE_LEN, 0);

    // initialize radio button
    CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE, pUiData->JobType);
    CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED, pUiData->LogDisabled);

    // initialize check box
    SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                       (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);

    if (1 <= lstrlen(pUiData->UserIdBuf))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
    }
    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
    }

#ifdef WINNT_40
    // Disable tab options when user has no permission.
    if (BITTEST32(pUiData->fUiOption, UIPLUGIN_NOPERMISSION))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID3), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_JOB), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_LOG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_NORMAL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_DISABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_ENABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
#endif // WINNT_40
} //*** InitMainDlg


/***************************************************************************
    Function Name : GetInfoFromOEMPdev
                    get data from private devmode
***************************************************************************/
VOID GetInfoFromOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    VERBOSE((DLLTEXT("GetInfoFromOEMPdev: print done?(%d)\n"),
            BITTEST32(pOEMExtra->fUiOption, PRINT_DONE)));
    // if previous printing is finished and hold-options flag isn't valid,
    // reset job setting.
    if (BITTEST32(pOEMExtra->fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        pUiData->JobType = IDC_RADIO_JOB_NORMAL;
        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
        // do not clear PRINT_DONE flag here
    }
    else
    {
        pUiData->JobType = pOEMExtra->JobType;
        // ascii to unicode
        OemToChar((LPSTR)pOEMExtra->PasswordBuf, pUiData->PasswordBuf);
    }

    pUiData->fUiOption = pOEMExtra->fUiOption;
    pUiData->LogDisabled = pOEMExtra->LogDisabled;
    // ascii to unicode
    OemToChar((LPSTR)pOEMExtra->UserIdBuf, pUiData->UserIdBuf);
    OemToChar((LPSTR)pOEMExtra->UserCodeBuf, pUiData->UserCodeBuf);
} //*** GetInfoFromOEMPdev


/***************************************************************************
    Function Name : SetInfoToOEMPdev
                    set data to private devmode
***************************************************************************/
VOID SetInfoToOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    // if only main dialog is changed
    if (!BITTEST32(pUiData->fUiOption, JOBLOGDLG_UPDATED))
        return;

    // unicode to ascii
    CharToOem(pUiData->UserIdBuf, (LPSTR)pOEMExtra->UserIdBuf);
    CharToOem(pUiData->PasswordBuf, (LPSTR)pOEMExtra->PasswordBuf);
    CharToOem(pUiData->UserCodeBuf, (LPSTR)pOEMExtra->UserCodeBuf);

    pOEMExtra->fUiOption = pUiData->fUiOption & 0x00FF; // clear local bit
    pOEMExtra->JobType = pUiData->JobType;
    pOEMExtra->LogDisabled = pUiData->LogDisabled;
#if DBG
//DebugBreak();
#endif // DBG
    return;
} //*** SetInfoToOEMPdev


/***************************************************************************
    Function Name : JobPageProc

    Parameters    : HWND    hDlg            Handle of this Dialog
                    UINT    uMessage
                    WPARAM  wParam
                    LPARAM  lParam

    Modify Note   : Modify.                 03/01/2000 Masatoshi Kubokura
***************************************************************************/
INT_PTR APIENTRY JobPageProc(
HWND hDlg,
UINT uMessage,
WPARAM wParam,
LPARAM lParam)
{
    PUIDATA pUiData;
    WORD    wOldVal, fModified = FALSE, fError = FALSE;
    INT     iOldLen, iNewLen, iCnt;

#if DBG
giDebugLevel = DBG_VERBOSE;
#endif // DBG

    switch (uMessage)
    {
      case WM_INITDIALOG:
        pUiData = (PUIDATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pUiData);

        // get data from private devmode
        GetInfoFromOEMPdev(pUiData);

        InitMainDlg(hDlg, pUiData);
        BITCLR32(pUiData->fUiOption, JOBLOGDLG_UPDATED);
        break;

      case WM_COMMAND:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        switch(LOWORD(wParam))
        {
          case IDC_EDIT_JOBMAIN_USERID:
            iOldLen = lstrlen(pUiData->UserIdBuf);
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf,
                           sizeof(pUiData->UserIdBuf));
            iNewLen = lstrlen(pUiData->UserIdBuf);
            if (1 <= iNewLen)
            {
                if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
                }
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
            }
            // if UserID isn't set, disable Print Job setting.
            else
            {
                CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                                 (pUiData->JobType = IDC_RADIO_JOB_NORMAL));
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (iOldLen != iNewLen)
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_PASSWORD:
            iOldLen = lstrlen(pUiData->PasswordBuf);
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf,
                           sizeof(pUiData->PasswordBuf));
            if (iOldLen != lstrlen(pUiData->PasswordBuf))
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_USERCODE:
            iOldLen = lstrlen(pUiData->UserCodeBuf);
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf,
                           sizeof(pUiData->UserCodeBuf));
            if (iOldLen != lstrlen(pUiData->UserCodeBuf))
                fModified = TRUE;
            break;

          case IDC_RADIO_JOB_NORMAL:
          case IDC_RADIO_JOB_SAMPLE:
          case IDC_RADIO_JOB_SECURE:
            wOldVal = pUiData->JobType;
            CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                             (pUiData->JobType = LOWORD(wParam)));
            if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (wOldVal != pUiData->JobType)
                fModified = TRUE;
            break;

          case IDC_RADIO_LOG_DISABLED:
          case IDC_RADIO_LOG_ENABLED:
            wOldVal = pUiData->LogDisabled;
            CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED,
                             (pUiData->LogDisabled = LOWORD(wParam)));
            if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
            }
            if (wOldVal != pUiData->LogDisabled)
                fModified = TRUE;
            break;

          case IDC_CHECK_JOB_DEFAULT:
            if (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS))
                BITCLR32(pUiData->fUiOption, HOLD_OPTIONS);
            else
                BITSET32(pUiData->fUiOption, HOLD_OPTIONS);
            SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                               (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);
            fModified = TRUE;
            break;

          default:
            return FALSE;
        }
        break;

      case WM_NOTIFY:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        {
            NMHDR FAR *lpnmhdr = (NMHDR FAR *)lParam;

            switch (lpnmhdr->code)
            {
              case PSN_SETACTIVE:
                break;

              // In case of PSN_KILLACTIVE, return FALSE to get PSN_APPLY.
              case PSN_KILLACTIVE:  // this is when user pushs OK/APPLY button.(1)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_KILLACTIVE **\n")));
                BITSET32(pUiData->fUiOption, JOBLOGDLG_UPDATED);

                // Check User ID (Up to 8 alphanumeric characters)
                iNewLen = lstrlen(pUiData->UserIdBuf);
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
                    // SBCS alphanumeric?
                    if (!_ismbcalnum(pUiData->UserIdBuf[iCnt]))
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    WCHAR   wcTmp1[64], wcTmp2[64];

                    // set cursor to User ID edit box
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID));

                    // Display warning dialog
// yasho's point-out  @Nov/29/2000 ->
//                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1));
//                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
// @Nov/29/2000 <-
                    MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                    // Do not close property sheets
                    return TRUE;
                }

                // Check Password (4 digits)
                iNewLen = lstrlen(pUiData->PasswordBuf);
                if (PASSWORD_LEN != iNewLen)    // Password must be exactly 4 digits.
                {
                    fError = TRUE;
                }
                else
                {
                    for (iCnt = 0; iCnt < iNewLen; iCnt++)
                    {
                        // SBCS digit?
                        if (!_ismbcdigit(pUiData->PasswordBuf[iCnt]))
                        {
                            fError = TRUE;
                            break;
                        }
                    }
                }
                if (fError)
                {
                    // if Secure Print is enabled
                    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to Password edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_PASSWORD_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_PASSWORD_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid Password
                        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
                    }
                    fError = FALSE;
                }

                // Check User Code (Up to 8 characters)
                iNewLen = lstrlen(pUiData->UserCodeBuf);
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
#if 1
                    // SBCS digit?
                    if (!_ismbcdigit(pUiData->UserCodeBuf[iCnt]))
#else  // if 0
                    // SBCS alphanumeric?
                    if (!_ismbcalnum(pUiData->UserCodeBuf[iCnt]))
#endif // if 0
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    // if Log is enabled
                    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to User Code edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_USERCODE_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_USERCODE_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid User Code
                        memset(pUiData->UserCodeBuf, 0, sizeof(pUiData->UserCodeBuf));
                    }
                    fError = FALSE;
                }
                return FALSE;

              case PSN_APPLY:       // this is when user pushs OK/APPLY button.(2)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_APPLY **\n")));

                // clear PRINT_DONE flag and delete file.
// BUGBUG: When printing document twice, printing job settings are cleared on app's print dialog
// in 2nd printing.  @Sep/05/2000 ->
//              if (BITTEST32(pUiData->pOEMExtra->fUiOption, PRINT_DONE))
//              {
//                  BITCLR32(pUiData->pOEMExtra->fUiOption, PRINT_DONE);
//                  VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
//                  DeleteFile(pUiData->pOEMExtra->SharedFileName);
//              }
                if (BITTEST32(pUiData->fUiOption, PRINT_DONE))
                {
                    BITCLR32(pUiData->fUiOption, PRINT_DONE);
                    VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
                    DeleteFile(pUiData->pOEMExtra->SharedFileName);
                }
// @Sep/05/2000 <-

                // set data to private devmode
                SetInfoToOEMPdev(pUiData);

                // update private devmode
                pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_SET_RESULT,
                                         (LPARAM)pUiData->hPropPage,
                                         (LPARAM)CPSUI_OK);
                VERBOSE((DLLTEXT("** PSN_APPLY fUiOption=%x **\n"), pUiData->fUiOption));
                break;

              case PSN_RESET:       // this is when user pushs CANCEL button
                VERBOSE((DLLTEXT("** JobPageProc: PSN_RESET **\n")));
                break;
            }
        }
        break;

      default:
        return FALSE;
    }

    // activate APPLY button
    if (fModified)
        PropSheet_Changed(GetParent(hDlg), hDlg);
    return TRUE;
} //*** JobPageProc

} // End of extern "C"


// @Aug/29/2000 ->
#ifdef DISKLESSMODEL
LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    Action = CPSUICB_ACTION_NONE;

#if DBG
    giDebugLevel = DBG_VERBOSE;
    VERBOSE((DLLTEXT("OEMUICallBack() entry.\n")));
#endif // DBG

    switch (pCallbackParam->Reason)
    {
      case CPSUICB_REASON_APPLYNOW:
        Action = CPSUICB_ACTION_ITEMS_APPLIED;
        {
            POPTITEM    pOptItem;
            WCHAR       wcHDName[128];
            INT         iCnt2;
            INT         iCnt = ITEM_HARDDISK_NAMES;
            INT         cOptItem = (INT)pOEMUIParam->cDrvOptItems;
            UINT        uID = IDS_ITEM_HARDDISK;
            BYTE        ValueData = 0;  // We suppose Hard Disk isn't installed as default.

            // Check item name with several candidate ("Hard Disk", "Memory / Hard Disk",...).
            while (iCnt-- > 0)
            {
                LoadString(ghInstance, uID, wcHDName, sizeof(wcHDName) / sizeof(*wcHDName));
                uID++; 

                pOptItem = pOEMUIParam->pDrvOptItems;
                for (iCnt2 = 0; iCnt2 < cOptItem; iCnt2++, pOptItem++)
                {
                    VERBOSE((DLLTEXT("%d: %ls\n"), iCnt2, pOptItem->pName));
                    if (lstrlen(pOptItem->pName))
                    {
                        // Is item name same as "Hard Disk" or something like?
                        if (!lstrcmp(pOptItem->pName, wcHDName))
                        {
                            // if Hard Disk is installed, value will be 1
                            ValueData = (BYTE)(pOptItem->Sel % 2);
                            goto _CHECKNAME_FINISH;
                        }
                    }
                }
            }
_CHECKNAME_FINISH:
            // Because pOEMUIParam->pOEMDM (pointer to private devmode) is NULL when
            // DrvDevicePropertySheets calls this callback, we use registry.
            SetPrinterData(pOEMUIParam->hPrinter, REG_HARDDISK_INSTALLED, REG_BINARY,
                           (PBYTE)&ValueData, sizeof(BYTE));
        }
        break;
    }
    return Action;
} //*** OEMUICallBack

extern "C" {
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommonUIProp
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMCommonUIProp(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
#if DBG
    LPCSTR OEMCommonUIProp_Mode[] = {
        "Bad Index",
        "OEMCUIP_DOCPROP",
        "OEMCUIP_PRNPROP",
    };

    giDebugLevel = DBG_VERBOSE;
#endif // DBG
    if(NULL == pOEMUIParam->pOEMOptItems)   // The first call
    {
        VERBOSE((DLLTEXT("OEMCommonUI(%s) entry 1st.\n"), OEMCommonUIProp_Mode[dwMode]));
        if (OEMCUIP_PRNPROP == dwMode)
            pOEMUIParam->cOEMOptItems = 1;  // dummy item
        else
            pOEMUIParam->cOEMOptItems = 0;
    }
    else                                    // The second call
    {
        VERBOSE((DLLTEXT("OEMCommonUI(%s) entry 2nd.\n"), OEMCommonUIProp_Mode[dwMode]));

        if (OEMCUIP_PRNPROP == dwMode)          // called from DrvDevicePropertySheets
        {
            POPTITEM    pOptItem = pOEMUIParam->pOEMOptItems;
            // fill out data for dummy item
            pOptItem->cbSize   = sizeof(OPTITEM);
            pOptItem->Level    = 2;             // Level 2
            pOptItem->pName    = NULL;
            pOptItem->pOptType = NULL;
            pOptItem->DMPubID  = DMPUB_NONE;
            pOptItem->Flags    = OPTIF_HIDE | OPTIF_CALLBACK;   // invisible and with callback
            pOEMUIParam->OEMCUIPCallback = OEMUICallBack;
        }
#ifdef WINNT_40
        else                                    // called from DrvDocumentPropertySheets
        {
            INT         iCnt;
            INT         cOptItem = (INT)pOEMUIParam->cDrvOptItems;
            POPTITEM    pOptItem = pOEMUIParam->pDrvOptItems;

            // If collate check box exists (i.e. printer collate is available),
            // set dmCollate.
            // -- Search Copies&Collate item --
            for (iCnt = 0; iCnt < cOptItem; iCnt++, pOptItem++)
            {
                if (DMPUB_COPIES_COLLATE == pOptItem->DMPubID)
                {
                    if (pOptItem->pExtChkBox && pOEMUIParam->pPublicDM)
                    {
                        pOEMUIParam->pPublicDM->dmCollate = DMCOLLATE_TRUE;
                        pOEMUIParam->pPublicDM->dmFields |= DM_COLLATE;
                    }
                    break;
                }
            }
        }
#endif // WINNT_40
    }
    return TRUE;
} //*** OEMCommonUIProp

} // End of extern "C"
#endif // DISKLESSMODEL
// @Aug/29/2000 <-
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\common.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    05/31/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    09/22/2000 -Masatoshi Kubokura-
        Last modified.

--*/

#include <minidrv.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"

// shared data file between rendering and UI plugin
#ifndef WINNT_40
#define SHAREDFILENAME          L"RIAF5.BIN"
#else  // WINNT_40
#define SHAREDFILENAME          L"\\2\\RIA%.3ls%02x.BIN"
DWORD gdwDrvMemPoolTag = 'meoD';    // minidrv.h requires this global var
#endif // WINNT_40

#if DBG && !defined(KM_DRIVER)
INT giDebugLevel = DBG_ERROR;
#endif

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#if defined(WINNT_40) && defined(DISKLESSMODEL)     // @Aug/02/2000
        // Because NT4 spooler doesn't support collate, we clear dmCollate.
        // Later at OEMUICallBack, if printer collate is available, we set
        // dmCollate.
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
#endif
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/1997      APresley Created.
//          02/28/2000      Masatoshi Kubokura Modified for PCL5e/PScript
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmOEMExtra.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmOEMExtra.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmOEMExtra.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->JobType = IDC_RADIO_JOB_NORMAL;
    pOEMExtra->LogDisabled = IDC_RADIO_LOG_DISABLED;

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/1997      APresley Created.
//          04/08/1997      ZhanW    Modified the interface
//          08/11/1997      Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/1997      APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/1997      APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/1998      Masatoshi Kubokura Created.
//              08/16/1999      takashim modified for Unidrv5.4 on NT4.
//              09/01/1999      Kubokura modified for Unidrv5.4 on NT4.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

#if DBG
giDebugLevel = DBG_VERBOSE;
#endif

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    //
    // CAUTION:
    //   TempPath is different whether EMF spool is enable(system) or not(user).
    //   We need to store the file name to private devmode.
    //

    // Set data data file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
        wcscpy(&szFileName[dwSize], SHAREDFILENAME);
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
#else  // WINNT_40
    //
    // CAUTION:
    //   The file path differs on each PC in printer sharing.
    //   We always update the file name (with path) of private devmode.
    //   (@Sep/03/99)
    //

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIAXXXNN.BIN". "XXX" is filled with top 3char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create data file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
#if DBG
giDebugLevel = DBG_ERROR;
#endif
    return bRet;
} //*** RWFileData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=md_riafres

!include $(PRNROOT)\print.inc

TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=\
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\winspool.lib \
    $(SDK_LIB_PATH)\uuid.lib

C_DEFINES=$(C_DEFINES) -DUNICODE -DOEMCOM -DDISKLESSMODEL

DLLENTRY=_DllMainCRTStartup
DLLBASE=0x50000000
USE_MSVCRT=1
USE_CTRLDLL=1

WIN32_WINNT_VERSION=0x0500
WIN32_IE_VERSION=0x0500

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=1252

UMTYPE=windows

SOURCES=\
    riafui.rc \
    riafui.cpp \
    common.c \
    comoem.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\riafui\comoem.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv OEM UI plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    03/17/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    08/29/2000 -Masatoshi Kubokura-
        Last modified

--*/

#define INITGUID // for GUID one-time initialization

#include <minidrv.h>
#include "devmode.h"
#include "oem.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUI
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n")));
        }
        else if (iid == IID_IPrintOemUI)
        {
            *ppv = static_cast<IPrintOemUI*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n")));
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n")));
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam)
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //


    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
        return S_OK;
    }

    //
    // CommonUIProp
    //

    STDMETHODIMP
    CommonUIProp(
        DWORD  dwMode,
        POEMCUIPPARAM   pOemCUIPParam)
    {
#ifdef DISKLESSMODEL        // @Aug/29/2000
        if (OEMCommonUIProp(dwMode, pOemCUIPParam))
            return S_OK;
        else
            return E_FAIL;
#else  // !DISKLESSMODEL
        return E_NOTIMPL;
#endif // !DISKLESSMODEL
    }

    //
    // DocumentPropertySheets
    //

    STDMETHODIMP
    DocumentPropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {

#if defined(WINNT_40) && defined(NOPROOFPRINT)      // @Aug/02/2000
        return E_NOTIMPL;
#else
        if (OEMDocumentPropertySheets(pPSUIInfo, lParam))
            return S_OK;
        else
            return E_FAIL;
#endif
    }

    //
    // DevicePropertySheets
    //

    STDMETHODIMP
    DevicePropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DevQueryPrintEx
    //

    STDMETHODIMP
    DevQueryPrintEx(
        POEMUIOBJ               poemuiobj,
        PDEVQUERYPRINT_INFO     pDQPInfo,
        PDEVMODE                pPublicDM,
        PVOID                   pOEMDM)
    {
        return E_NOTIMPL;
    }

    //
    // DeviceCapabilities
    //

    STDMETHODIMP
    DeviceCapabilities(
        POEMUIOBJ   poemuiobj,
        HANDLE      hPrinter,
        PWSTR       pDeviceName,
        WORD        wCapability,
        PVOID       pOutput,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        DWORD       dwOld,
        DWORD       *dwResult)
    {
        return E_NOTIMPL;
    }

    //
    // UpgradePrinter
    //

    STDMETHODIMP
    UpgradePrinter(
        DWORD   dwLevel,
        PBYTE   pDriverUpgradeInfo)
    {
        return E_NOTIMPL;
    }

    //
    // PrinterEvent
    //

    STDMETHODIMP
    PrinterEvent(
        PWSTR   pPrinterName,
        INT     iDriverEvent,
        DWORD   dwFlags,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DriverEvent
    //

    STDMETHODIMP
    DriverEvent(
        DWORD   dwDriverEvent,
        DWORD   dwLevel,
        LPBYTE  pDriverInfo,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // QueryColorProfile
    //

    STDMETHODIMP
    QueryColorProfile(
        HANDLE      hPrinter,
        POEMUIOBJ   poemuiobj,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        ULONG       ulReserved,
        VOID       *pvProfileData,
        ULONG      *pcbProfileData,
        FLONG      *pflProfileData)
    {
        return E_NOTIMPL;
    }

    //
    // FontInstallerDlgProc
    //

    STDMETHODIMP
    FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // UpdateExternalFonts
    //

    STDMETHODIMP
    UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
    {
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
            InterlockedIncrement(&g_cServerLocks);
        else
            InterlockedDecrement(&g_cServerLocks);
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
        return S_OK;
    else
        return E_FAIL;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMUI,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMUI,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\common.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    02/11/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    03/17/2000 -Masatoshi Kubokura-
        Eliminate "\\" from temp file name.
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4
    09/22/2000 -Masatoshi Kubokura-
        Last modified.

--*/

#include "pdev.h"
#include "resource.h"

// shared data file between rendering and UI plugin
#ifndef WINNT_40
#define SHAREDFILENAME          L"RIMD5.BIN"        // eliminate "\\"  @Mar/15/2000
#else  // WINNT_40
#define SHAREDFILENAME          L"\\2\\RI%.4ls%02x.BIN" // %02x<-%02d  @Sep/21/99
DWORD gdwDrvMemPoolTag = 'meoD';    // minidrv.h requires this global var
#endif // WINNT_40

#if DBG && !defined(KM_DRIVER)
INT giDebugLevel = DBG_ERROR;
#endif

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#ifdef WINNT_40     // @Sep/20/99
        // Because NT4 spooler doesn't support collate, we clear dmCollate.
        // Later at OEMUICallBack, if printer collate is available, we set
        // dmCollate.
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
#endif // WINNT_40
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
// @Jul/08/98 ->
//        // nothing to convert for this private devmode. So just initialize it.
//        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
// @Jul/08/98 <-
    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->UiScale = VAR_SCALING_DEFAULT;
    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;
    pOEMExtra->UiBindMargin = DEFAULT_0;
    pOEMExtra->nUiTomboAdjX = pOEMExtra->nUiTomboAdjY = DEFAULT_0;  // add @Sep/14/98
    memset(pOEMExtra->SharedFileName, 0, sizeof(pOEMExtra->SharedFileName));    // @Aug/31/99
#ifdef JOBLOGSUPPORT_DM     // @Oct/05/2000
    pOEMExtra->JobType = IDC_RADIO_JOB_NORMAL;
    pOEMExtra->LogDisabled = IDC_RADIO_LOG_DISABLED;
#endif // JOBLOGSUPPORT_DM

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/98        Masatoshi Kubokura Created.
//              08/16/99        takashim modified for Unidrv5.4 on NT4.
//              09/01/99        Kubokura modified for Unidrv5.4 on NT4.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    //
    // CAUTION:
    //   TempPath is different whether EMF spool is enable(system) or not(user).
    //   We need to store the file name to private devmode.
    //

    // Set shared file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
        wcscpy(&szFileName[dwSize], SHAREDFILENAME);
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
#else  // WINNT_40
    //
    // CAUTION:
    //   The file path differs on each PC in printer sharing.
    //   We always update the file name (with path) of private devmode.
    //   (@Sep/03/99)
    //

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIXXXXNN.BIN". "XXXX" is filled with top 4char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create shared file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
    return bRet;
} //*** RWFileData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\ddi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           DDI.C

Abstract:       Implementation of OEM DDI exports & OEM DDI hooks.

Functions:      OEMEnablePDEV
                OEMDisablePDEV
                OEMResetPDEV
                OEMEnableDriver
                OEMDisableDriver
                OEMxxx (DDI hooks)

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    10/05/98 -Masatoshi Kubokura-
        Began to modify for RPDL.
    03/03/99 -Masatoshi Kubokura-
        Last modified for Windows2000.

--*/

#include "pdev.h"

#if 0 //DBG
#undef VERBOSE
#define VERBOSE WARNING
#define GETDRIVERSETTING(p1, p2, p3, p4, p5, p6) \
    ((p1)->pDrvProcs->DrvGetDriverSetting((p1), (p2), (p3), (p4), (p5), (p6)))
#endif // if DBG

#ifdef DDIHOOK
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }
};
#endif // DDIHOOK


#if 0
VOID
TestGetDriverSetting(
    PDEVOBJ pdevobj,
    BOOL    bDocSticky)
{
    DWORD   dwIndex, cbNeeded, cOptions;
    CHAR    buf[64];

    if (bDocSticky)
    {
        for (dwIndex=OEMGDS_UNIDM_GPDVER; dwIndex <= OEMGDS_UNIDM_FLAGS+1; dwIndex++)
        {
            if (GETDRIVERSETTING(pdevobj, (PCSTR) dwIndex, buf, 64, &cbNeeded, &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting OutputBin: "));

        if (GETDRIVERSETTING(pdevobj, "OutputBin", buf, 64, &cbNeeded, &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
    else
    {
        for (dwIndex=OEMGDS_PRINTFLAGS; dwIndex <= OEMGDS_PROTOCOL+1; dwIndex++)
        {
            if (GETDRIVERSETTING(pdevobj, (PCSTR) dwIndex, buf, 64, &cbNeeded, &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting InstalledMemory: "));
        if (GETDRIVERSETTING(pdevobj, "InstalledMemory", buf, 64, &cbNeeded, &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
} //*** TestGetDriverSetting
#endif // if 0

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)       // Unidrv's hook table
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(("OEMEnablePDEV() entry.\n"));

    // Allocate the OEMPDEV
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    // Initialize OEMPDEV
    poempdev->fGeneral1 = poempdev->fGeneral2 = poempdev->fModel = 0;
    poempdev->Scale = VAR_SCALING_DEFAULT;
    poempdev->BaseOffset.x = poempdev->BaseOffset.y = 0;
    poempdev->Offset.x = poempdev->Offset.y = 0;
    poempdev->nResoRatio = MASTERUNIT/240;
    poempdev->TextCurPos.x = poempdev->TextCurPos.y = 0;
    poempdev->TextCurPosRealY = 0;
    poempdev->FontH_DOT = 0;
    poempdev->StapleType = poempdev->PunchType = 0;
    poempdev->CollateType = COLLATE_OFF;
    poempdev->MediaType = MEDIATYPE_STD;        // @Mar/03/99
    poempdev->BindPoint = BIND_ANY;
    poempdev->Nin1RemainPage = 0;
    poempdev->PageMax.x = poempdev->PageMax.y = poempdev->PageMaxMoveY = 32767;
    poempdev->pRPDLHeap2K = NULL;
#ifdef DOWNLOADFONT
    poempdev->nCharPosMoveX  = 0;
    poempdev->DLFontMaxMemKB = 0;
    poempdev->DLFontMaxID    = DLFONT_ID_4;
    poempdev->DLFontMaxGlyph = DLFONT_GLYPH_TOTAL;
    poempdev->pDLFontGlyphInfo = NULL;
#endif // DOWNLOADFONT

#ifdef DDIHOOK
    // Fill Unidrv's hooks in OEMPDEV
    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        // search through Unidrv's hooks and locate the function ptr
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            poempdev->pfnUnidrv[i] = NULL;
        }
    }
#endif // DDIHOOK
#if 0
    TestGetDriverSetting(pdevobj, TRUE);
    TestGetDriverSetting(pdevobj, FALSE);
#endif // if 0

    return (POEMPDEV) poempdev;
} //*** OEMEnablePDEV


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE(("OEMDisablePDEV() entry.\n"));

    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    MemFree(MINIDEV_DATA(pdevobj));
} //*** OEMDisablePDEV


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
// @Feb/11/99 ->
    POEMPDEV    poempdevOld = MINIDEV_DATA(pdevobjOld);
    POEMPDEV    poempdevNew = MINIDEV_DATA(pdevobjNew);

    VERBOSE(("OEMResetPDEV() entry.\n"));

    if (poempdevOld && poempdevNew)
    {
        LPBYTE      pSrc = (LPBYTE)poempdevOld;
        LPBYTE      pDst = (LPBYTE)poempdevNew;
        DWORD       dwCount = sizeof(OEMPDEV);

        // carry over from old OEMPDEV to new OEMPDEV
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;

        // set pointers of old OEMPDEV to NULL not to free memory
        poempdevOld->pRPDLHeap2K = NULL;
#ifdef DOWNLOADFONT
        poempdevOld->pDLFontGlyphInfo = NULL;
#endif // DOWNLOADFONT
// @Feb/11/99 <-
    }
    return TRUE;
} //*** OEMResetPDEV


VOID APIENTRY OEMDisableDriver()
{
        VERBOSE(("OEMDisableDriver() entry.\n"));
} //*** OEMDisableDriver


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // VERBOSE(("OEMEnableDriver() entry.\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
#ifdef DDIHOOK
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;
#else
    pded->c = 0;
    pded->pdrvfn = NULL;
#endif // DDIHOOK


    return TRUE;
} //*** OEMEnableDriver


#ifdef DDIHOOK
//
// DDI hooks
//
BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTrg->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMBitBlt() entry.\n"));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));
} //*** OEMBitBlt


BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBlt() entry.\n"));

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMStretchBlt


BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBltROP() entry.\n"));

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));
} //*** OEMStretchBltROP


BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMCopyBits() entry.\n"));

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            pptlSrc));
} //*** OEMCopyBits


BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPlgBlt() entry.\n"));

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMPlgBlt


BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMAlphaBlend() entry.\n"));

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            pBlendObj
            ));
} //*** OEMAlphaBlend


BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGradientFill() entry.\n"));

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDst,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));
} //*** OEMGradientFill


BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTextOut() entry.\n"));

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));
} //*** OEMTextOut


BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStokePath() entry.\n"));

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));
} //*** OEMStrokePath


BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFillPath() entry.\n"));

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));
} //*** OEMFillPath


BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));
} //*** OEMStrokeAndFillPath


BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTarget->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
} //*** OEMRealizeBrush


BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartPage() entry.\n"));

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));
} //*** OEMStartPage


#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndPage() entry.\n"));

#if 0
    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }
#endif

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));
} //*** OEMSendPage


ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEscape() entry.\n"));

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMEscape


BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartDoc() entry.\n"));

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
} //*** OEMStartDoc


BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndDoc() entry.\n"));

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));
} //*** OEMEndDoc


////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFont() entry.\n"));

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));
} //*** OEMQueryFont


PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontTree() entry.\n"));

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));
} //*** OEMQueryFontTree


LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontData() entry.\n"));

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));
} //*** OEMQueryFontData


BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryAdvanceWidths() entry.\n"));

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));
} //*** OEMQueryAdvanceWidths


ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFontManagement() entry.\n"));

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMFontManagement

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGetGlyphMode() entry.\n"));

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));
} //*** OEMGetGlyphMode

/////// <- six font related DDI calls


BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMNextBand() entry.\n"));

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));
} //*** OEMNextBand


BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartBanding() entry.\n"));

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));
} //*** OEMStartBanding


ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMDitherColor() entry.\n"));

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));
} //*** OEMDitherColor


BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPaint() entry.\n"));

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));
} //*** OEMPaint


BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMLineTo() entry.\n"));

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));
} //*** OEMLineTo


BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTransparentBlt() entry.\n"));

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));
} //*** OEMTransparentBlt
#endif // DDIHOOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\comoem.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv
                OEM rendering plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
        98/4/24 takashim:
        Written the original sample so that it is more C++.
        99/2/16 Masatoshi Kubokura:
        Last modified for Windows2000.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMEnableDriver(dwDriverVersion, cbSize, pded); // @Oct/05/98

        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMDisableDriver(); // @Oct/05/98
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
// @Oct/06/98 ->
//      return E_NOTIMPL;
        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //
//        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;

        *pDevOem = pTemp;
        return S_OK;
// @Oct/06/98 <-
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
// @Oct/05/98 ->
//      return E_NOTIMPL;
        OEMDisablePDEV(pdevobj);
        return S_OK;
// @Oct/05/98 <-
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
// @Oct/05/98 ->
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
// @Oct/05/98 <-
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
// @Sep/10/98 ->
//          pIUnknown->AddRef();
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void**)&(this->pOEMHelp));
            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }
//      this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
// @Sep/10/98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
// FilterGraphics disables other compression!  @Feb/16/99 ->
#if 0   // SP8BUGFIX_RASTER
        OEMFilterGraphics(pdevobj, pBuf, dwLen);    // @Feb/09/99
        return S_OK;
#else
        return E_NOTIMPL;
#endif // 'if 0 - else'
// @Feb/16/99 <-
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
// @Jul/29/98 ->
//      return E_NOTIMPL;
        if (0 < (*piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
// @Jul/29/98 <-
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

/*++

Copyright (c) 1996-2000  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           PDEV.H

Abstract:       Header file for OEM UI & rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/15/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    02/05/2001 -Masatoshi Kubokura-
        Add "Thick Paper"

--*/


//
// Files necessary for OEM plug-in.
//

#include <windows.h>   // for UI
#include <compstui.h>  // for UI
#include <winddiui.h>  // for UI
#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define MASTERUNIT          1200
#define DEVICE_MASTER_UNIT  7200
#define DRIVER_MASTER_UNIT  MASTERUNIT

//
// Compile options
//
#define DOWNLOADFONT        // support TrueType download
//#define JISGTT            // Current GTT is JIS code set
//#define DDIHOOK           // ddi hook is available
//#define JOBLOGSUPPORT_DM  // Job/Log is supported (about devmode)
//#define JOBLOGSUPPORT_DLG // Job/Log is supported (about dialog)

//
// Misc definitions follows.
//
#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#define MINIDEV_DATA(p) \
    ((POEMPDEV)((p)->pdevOEM))          // device data during job
#define MINIPRIVATE_DM(p) \
    ((POEMUD_EXTRADATA)((p)->pOEMDM))   // private devmode
// OBSOLETE  @Sep/27/99 ->
//#define UI_GETDRIVERSETTING(p1, p2, p3, p4, p5, p6) \
//    ((p1)->pOemUIProcs->DrvGetDriverSetting(p1, p2, p3, p4, p5, p6))
// @Sep/27/99 <-

// ASSERT(VALID_PDEVOBJ) can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

// Debug text.
#if DBG
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)
#ifdef UIMODULE
#define DLLTEXT(s)      "RPDLUI: " s
#else  // !UIMODULE
#define DLLTEXT(s)      "RPDLRES: " s
#endif // !UIMODULE
#endif // DBG

////////////////////////////////////////////////////////
// OEM Signature and version.
////////////////////////////////////////////////////////
#define OEM_SIGNATURE   'RPDL'      // RICOH RPDL printers
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
// DDI hooks
// Warning: the following enum order must match the
//           order in OEMHookFuncs[].
////////////////////////////////////////////////////////
#ifdef DDIHOOK
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
#endif // DDIHOOK


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////
#define ABS(x) ((x > 0)? (x):-(x))

// heap memory size
#define HEAPSIZE64                  64    // this must be bigger than 32
#define HEAPSIZE2K                  2048  // @Sep/09/98

#ifdef DOWNLOADFONT
// definitions for download font
#define MEM128KB                    128 // Kbyte
#define MEM256KB                    256
#define MEM512KB                    512
#define DLFONT_ID_4                 4   // 4 IDs
#define DLFONT_ID_8                 8   // 8 IDs
#define DLFONT_ID_16                16  // 16 IDs  @Oct/20/98
#define DLFONT_ID_MIN_GPD           0   // *MinFontID in GPD
#define DLFONT_ID_MAX_GPD           15  // *MaxFontID in GPD (6->3 @May/07/98,->7 @Jun/17/98,->15 @Oct/20/98)
#define DLFONT_ID_TOTAL             (DLFONT_ID_MAX_GPD - DLFONT_ID_MIN_GPD + 1)
#define DLFONT_GLYPH_MIN_GPD        0   // *MinGlyphID in GPD
#define DLFONT_GLYPH_MAX_GPD        69  // *MaxGlyphID in GPD (103->115 @May/07/98,->69 @Oct/20/98)
#define DLFONT_GLYPH_TOTAL          (DLFONT_GLYPH_MAX_GPD - DLFONT_GLYPH_MIN_GPD + 1)
#define DLFONT_SIZE_DBCS11PT_MU     216 // actual value(MSMincho 400dpi)    @Nov/18/98
#define DLFONT_SIZE_DBCS9PT_MU      160 // actual value(MSMincho 600dpi)    @Nov/18/98
#define DLFONT_SIZE_SBCS11PT_MU     512 // actual value(Arial&Times 600dpi) @Nov/18/98
#define DLFONT_SIZE_SBCS9PT_MU      192 // actual value(Century 400&600dpi) @Nov/18/98
#define DLFONT_HEADER_SIZE          16  // RPDL header size of each download character
#define DLFONT_MIN_BLOCK            32  // RPDL min block size: 32bytes
#define DLFONT_MIN_BLOCK_ID         5   // RPDL min block size ID of 32bytes

typedef struct
{
    SHORT   nPitch;
    SHORT   nOffsetX;
    SHORT   nOffsetY;
} FONTPOS, FAR *LPFONTPOS;
#endif // DOWNLOADFONT


// buffer size
#define FAXBUFSIZE256               256
#define FAXEXTNUMBUFSIZE            8
#define FAXTIMEBUFSIZE              6
#define MY_MAX_PATH                 80  // 100->80 @Sep/02/99
#define USERID_LEN                  8
#define PASSWORD_LEN                4
#define USERCODE_LEN                8

// private devmode
typedef struct _OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
// common data between UI & rendering plugin ->
    DWORD   fUiOption;          // bit flags for UI option  (This must be after dmExtraHdr)
    WORD    UiScale;            // variable scaling value (%)
    WORD    UiBarHeight;        // barcode height (mm)
    WORD    UiBindMargin;       // left or upper binding margin at duplex printing (mm)
    SHORT   nUiTomboAdjX;       // horizontal distance adjustment at TOMBO (0.1mm unit)
    SHORT   nUiTomboAdjY;       // vertical distance adjustment at TOMBO (0.1mm unit)
    // We use private devmode, not use file, because EMF disables reading/writing the file.
    BYTE    FaxNumBuf[FAXBUFSIZE256];       // fax number
    BYTE    FaxExtNumBuf[FAXEXTNUMBUFSIZE]; // extra number (external)
    BYTE    FaxSendTime[FAXTIMEBUFSIZE];    // reservation time
    WORD    FaxReso;            // fax send resolution (0:400,1:200,2:100dpi)
    WORD    FaxCh;              // fax send channel (0:G3,1:G4,2:G3-1ch,3:G3-2ch)
#ifdef JOBLOGSUPPORT_DM
    WORD    JobType;
    WORD    LogDisabled;
    BYTE    UserIdBuf[USERID_LEN+1];
    BYTE    PasswordBuf[PASSWORD_LEN+1];
    BYTE    UserCodeBuf[USERCODE_LEN+1];
#endif // JOBLOGSUPPORT_DM
    WCHAR   SharedFileName[MY_MAX_PATH+16]; // shared data file name  @Aug/31/99 (+16 @Sep/02/99)
// <-
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


#ifndef GWMODEL
// Fax options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA  pOEMExtra;
    WCHAR   FaxNumBuf[FAXBUFSIZE256];
    WCHAR   FaxExtNumBuf[FAXEXTNUMBUFSIZE];
    WCHAR   FaxSendTime[FAXTIMEBUFSIZE];
    WORD    FaxReso;
    WORD    FaxCh;
// temporary save buffer ->
    DWORD   fUiOptionTmp;
    WCHAR   FaxSendTimeTmp[FAXTIMEBUFSIZE];
    WORD    FaxResoTmp;
    WORD    FaxChTmp;
// <-
} UIDATA, *PUIDATA;

#else  // GWMODEL
// Job/Log options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA  pOEMExtra;
    WORD    JobType;
    WORD    LogDisabled;
    WCHAR   UserIdBuf[USERID_LEN+1];
    WCHAR   PasswordBuf[PASSWORD_LEN+1];
    WCHAR   UserCodeBuf[USERCODE_LEN+1];
} UIDATA, *PUIDATA;
#endif // GWMODEL


// shared file data for UI & rendering plugin
typedef struct _FILEDATA{
    DWORD   fUiOption;          // UI option flag
} FILEDATA, *PFILEDATA;


// rendering plugin device data (separate OEMUD_EXTRADATA @Oct/05/98)
typedef struct _OEMPDEV {
    DWORD   fGeneral1;          // bit flags for RPDL general status(1)
    DWORD   fGeneral2;          // bit flags for RPDL general status(2)
    DWORD   fModel;             // bit flags for printer models
    DWORD   dwFontH_CPT;        // font height(cpt) for AssignIBMfont()  (1cpt=1/7200inch)
    DWORD   dwFontW_CPT;        // font width (cpt) for AssignIBMfont()
    WORD    FontH_DOT;          // font height(dot) for TextMode clipping
    WORD    DocPaperID;         // document papersize ID
    SHORT   nResoRatio;         // MASTERUNIT divided by resolution (short->SHORT @Sep/14/98)
    WORD    Scale;              // scaling value for offset calculation
    POINT   TextCurPos;         // TextMode current position
    POINT   PageMax;            // x:page_width, y:page_length
    POINT   Offset;             // total offset
    POINT   BaseOffset;         // offset by PrinterProperty or offset for MF530,150(e),160
    LONG    PageMaxMoveY;       // RPDL max y_position  int->LONG @Aug/28/98
    LONG    TextCurPosRealY;    // TextMode current position y without page_length adjustment
    DWORD   dwBarRatioW;        // barcode width ratio (ratio_1.0=1000)
    SHORT   nBarType;           // barcode type
    SHORT   nBarMaxLen;         // barcode character max length
    WORD    StapleType;         // staple  (0:disable,1:1staple,2:2staples)
    WORD    PunchType;          // punch   (0:disable,1:enable)
    WORD    CollateType;        // collate (0:disable,1:enable,2:uni-dir,3:rotated,4:shifted)
    WORD    MediaType;          // media type (0:standard,1:OHP,2:thick,3:special)
    WORD    BindPoint;          // staple/punch point
    WORD    Nin1RemainPage;     // remain pages in Nin1 (2in1:0-1,4in1:0-3)
    WORD    TextRectGray;       // gray percentage(1-100) of TextMode Rectangle
    POINT   TextRect;           // height & width of TextMode Rectangle
    POINT   TextRectPrevPos;    // previous position of TextMode Rectangle
    DWORD   PhysPaperWidth;     // paper width for CustomSize
    DWORD   PhysPaperLength;    // paper length for CustomSize
    DWORD   dwSrcBmpWidthByte;  // for raster data emission (width in byte)
    DWORD   dwSrcBmpHeight;     // for raster data emission (height in dot)
    PBYTE   pRPDLHeap2K;        // heap memory for OEMOutputCharStr&OEMDownloadCharGlyph @Sep/09/98
    BYTE    RPDLHeap64[HEAPSIZE64]; // 64byte heap memory
    WORD    RPDLHeapCount;      // current heap usage
#ifdef DOWNLOADFONT
    DWORD   dwDLFontUsedMem;    // used memory size for Download font
    WORD    DLFontCurGlyph;
    WORD    DLFontMaxMemKB;
    WORD    DLFontMaxID;
    WORD    DLFontMaxGlyph;
    SHORT   nCharPosMoveX;
    FONTPOS* pDLFontGlyphInfo;  // download glyph info (array->pointer @Sep/08/98)
#endif // DOWNLOADFONT
#ifdef DDIHOOK
    PFN     pfnUnidrv[MAX_DDI_HOOKS];   // Unidrv's hook function pointer
#endif // DDIHOOK
} OEMPDEV, *POEMPDEV;


// bit definitions of fGeneral1
#define RLE_COMPRESS_ON          0  // Raster image compression is on (<-IMAGE_NOCOMPRESS  MSKK)
#define TEXT_CLIP_VALID          1  // TextMode(font/image) clipping is valid
#define TEXT_CLIP_SET_GONNAOUT   2  // TextMode clipping-set command is going to be outputed
#define TEXT_CLIP_CLR_GONNAOUT   3  // TextMode clipping-clear command is going to be outputed
#define FONT_VERTICAL_ON         4  // vertical font mode on
#define FONT_BOLD_ON             5  // bold on
#define FONT_ITALIC_ON           6  // italic on
#define FONT_WHITETEXT_ON        7  // white text on
#define ORIENT_LANDSCAPE         8  // orientation is landscape
#define SWITCH_PORT_LAND         9  // switching portrait/landscape is needed
#define DUPLEX_LEFTMARGIN_VALID  10 // left margin at duplex printing is set
#define DUPLEX_UPPERMARGIN_VALID 11 // upper margin at duplex printing is set
#define PAPER_CUSTOMSIZE         12 // Paper is CustomSize
#define PAPER_DOUBLEPOSTCARD     13 // Paper is DoublePostcard
#define IMGCTRL_2IN1_67          14 // ImageControl:2in1(Scale 67%)
#define IMGCTRL_2IN1_100         15 // ImageControl:2in1(Scale 100%)
#define IMGCTRL_4IN1_50          16 // ImageControl:4in1(Scale 50%)
#define IMGCTRL_AA67             17 // ImageControl:A->A(Scale 67%)
#define IMGCTRL_BA80             18 // ImageControl:B->A(Scale 80%)
#define IMGCTRL_BA115            19 // ImageControl:B->A(Scale 115%)
#define DUPLEX_VALID             20 // duplex is valid
#define XM_ABS_GONNAOUT          21 // Move_X command is going to be outputed
#define YM_ABS_GONNAOUT          22 // Move_Y command is going to be outputed
#define CUSTOMSIZE_USE_LAND       23 // orientation adjustment in CustomSize
#define CUSTOMSIZE_MAKE_LAND_PORT 24 // orientation adjustment in CustomSize
#define IMGCTRL_AA141            25 // ImageControl:A->A(Scale 141%)
#define IMGCTRL_AA200            26 // ImageControl:A->A(Scale 200%)
#define IMGCTRL_AA283            27 // ImageControl:A->A(Scale 283%)
#define IMGCTRL_A1_400           28 // ImageControl:A1(Scale 400%)
//#define MEDIATYPE_OHP            29 // MediaType:Transparency(OHP)
//#define MEDIATYPE_THICK          30 // MediaType:Thick Paper
//#define MEDIATYPE_CHANGED        31 // MediaType is changed
#define VARIABLE_SCALING_VALID   29 // variable scaling command emitted  @Jan/27/2000

// bit definitions of fGeneral2
//   if you modify them, don't forget to update BITCLR_BARCODE below
#define BARCODE_MODE_IN          0  // enter barcode mode
#define BARCODE_DATA_VALID       1  // barcode data is valid
#define BARCODE_FINISH           2  // barcode data is finished
#define BARCODE_CHECKDIGIT_ON    3  // add checkdigit in barcode
#define BARCODE_ROT90            4  // vartical(rotation90) barcode
#define BARCODE_ROT270           5  // vartical(rotation270) barcode
#define TEXTRECT_CONTINUE        6  // TextMode Rectangle drawing continues
#define EDGE2EDGE_PRINT          7  // Edge to Edge printing
#define LONG_EDGE_FEED           8  // Long Edge Feed at Multi Tray
#define OEM_COMPRESS_ON          9  // OEM Compress is available
#define DIVIDE_DATABLOCK         10 // Divide raster data block for SP4mkII,5,7,8

// bit definitions of fModel
//   if you modify this, don't forget to update PRODUCTS_SINCExx or follows.
#define GRP_MF530                0  // model=MF530
#define GRP_MF150                1  // model=MF150
#define GRP_MF150e               2  // model=MF150e,160
#define GRP_MFP250               3  // model=MF-P250,355,250(FAX),355(FAX),MF-FD355
#define GRP_SP4mkII              4  // model=SP4mkII,5
#define GRP_SP8                  5  // model=SP7,8,7mkII,8mkII,80
#define GRP_SP10                 6  // model=SP-10,10mkII
#define GRP_SP9                  7  // model=SP9,10Pro
#define GRP_SP9II                8  // model=SP9II,10ProII,90
#define GRP_NX100                9  // model=NX-100
#define GRP_NX500                10 // model=NX-500,1000,110,210,510,1100
//#define GRP_MFP250e              11 // model=MF-P250e,355e
#define GRP_MF250M               11 // model=MF250M
#define GRP_MF3550               12 // model=MF2700,3500,3550,4550,5550,6550,3530,3570,4570,
                                    // 5550EX,6550EX,3530e,3570e,4570e,5570,7070,8570,105Pro
#define GRP_MF3300               13 // model=MF3300W,3350W,3540W,3580W
#define GRP_IP1                  14 // model=IP-1
#define GRP_NX70                 15 // model=NX70,71
#define GRP_NX700                16 // model=NX700,600,FAX Printer,MF700
#define GRP_MF200                17 // model=MF200,MF-p150,MF2200  (separate GRP_SP9II @Sep/01/98)
#define GRP_NX900                18 // model=NX900
#define GRP_MF1530               19 // model=MF1530,2230,2730,NX800,910,810
#define GRP_NX710                20 // model=710,610 (separate GRP_MF1530 @Jun/23/2000)
#define GRP_NX720                21 // model=NX620,620N,720N,Neo350,350D,450,220,270

/// bit definitions of fUiOption
#define FAX_SEND                 0  // 1=send fax at imagio FAX
#define FAX_USEADDRESSBOOK       1  // 1=use addressbook
#define HOLD_OPTIONS             2  // 1=hold options after sending
#define FAX_SETTIME              3  // 1=reservation time available
#define FAX_SIMULPRINT           4  // 1=send fax and print simultaneously
#define FAX_RPDLCMD              5  // 1=send RPDL command
#define FAX_MH                   6  // 0=use MMR, 1=use MH
#define PRINT_DONE               7  // 1=print done (rendering plugin set this)
#define DISABLE_BAR_SUBFONT      8  // disable printing readable font under barcode
#define ENABLE_BIND_RIGHT        9  // enable stapling right side
#define ENABLE_TOMBO             10 // print TOMBO  @Sep/14/98
//   UI plugin local ->
#define OPT_NODUPLEX             16
#define OPT_VARIABLE_SCALING     17
#define FAX_MODEL                18
#define FAXMAINDLG_UPDATED       19 // 1=fax main dialog updated
#define FAXSUBDLG_UPDATED        20 // 1=fax sub dialog updated
#define FAXSUBDLG_UPDATE_APPLIED 21 // 1=fax sub dialog update applied
#define FAXSUBDLG_INITDONE       22
#define UIPLUGIN_NOPERMISSION    23 // same as DM_NOPERMISSION
#define JOBLOGDLG_UPDATED        24 // 1=Job/Log dialog updated
// <-

// staple/punch point in duplex printing(BindPoint)
#define BIND_ANY                 0
#define BIND_LEFT                1
#define BIND_RIGHT               2
#define BIND_UPPER               3

// flag bit operation
#define BIT(num)                ((DWORD)1<<(num))
#define BITCLR32(flag,num)      ((flag) &= ~BIT(num))
#define BITSET32(flag,num)      ((flag) |= BIT(num))
#define BITTEST32(flag,num)     ((flag) & BIT(num))
#define TO1BIT(flag,num)        (((flag)>>(num)) & (DWORD)1)
#define BITCPY32(dst,src,num)   ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) | BIT(num) : (DWORD)(dst) & ~BIT(num))
#define BITNCPY32(dst,src,num)  ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) & ~BIT(num) : (DWORD)(dst) | BIT(num))
#define TEST_OBJ_CHANGE(flag)   ((flag) & (BIT(BRUSH_CHANGE)|BIT(PEN_CHANGE)| \
                                           BIT(SCAN_PEN_WIDTH_1)|BIT(SCAN_PEN_WIDTH_ORG)))
#define TEST_2IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)))
#define TEST_4IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_4IN1_50)))
#define TEST_NIN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define BITCLR_NIN1_MODE(flag)  ((flag) &= ~(BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define TEST_SCALING_SEL_TRAY(flag)   ((flag) & (BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_SCALING_SEL_TRAY(flag) ((flag) &= ~(BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_BARCODE(flag)    ((flag) &= ~(BIT(BARCODE_MODE_IN)|BIT(BARCODE_DATA_VALID)| \
                                             BIT(BARCODE_FINISH)|BIT(BARCODE_CHECKDIGIT_ON)| \
                                             BIT(BARCODE_ROT90)|BIT(BARCODE_ROT270)))
#define BITCLR_UPPER_FLAG(flag) ((flag) &= 0x0000FFFF)

// models since 2000
#define PRODUCTS_SINCE2000      (BIT(GRP_NX720))
// models since '99
#define PRODUCTS_SINCE99        (BIT(GRP_NX900)|BIT(GRP_MF1530)|BIT(GRP_NX710)|PRODUCTS_SINCE2000)
// models since '98
#define PRODUCTS_SINCE98        (BIT(GRP_MF3550)|BIT(GRP_MF3300)|BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99)
// models since '97 (delete GRP_MFP250e  @Apr/15/99)
#define PRODUCTS_SINCE97        (BIT(GRP_NX500)|BIT(GRP_MF250M)|PRODUCTS_SINCE98)
// models since '96 (add GPR_MF200 @Sep/01/98)
#define PRODUCTS_SINCE96        (BIT(GRP_SP9II)|BIT(GRP_MF200)|BIT(GRP_NX100)|PRODUCTS_SINCE97)

// capabilty of media type option(Standard, OHP, Thick)
#define TEST_CAPABLE_MEDIATYPE(flag)  ((flag) & (BIT(GRP_MF3550)|BIT(GRP_MF1530)|BIT(GRP_NX710)|BIT(GRP_NX720)))

// A2 printer
#define TEST_CAPABLE_PAPER_A2(flag)   ((flag) & (BIT(GRP_MF3300)))

// scailing over 141% of A2 printer/A1 plotter
#define TEST_PLOTTERMODEL_SCALING(flag)    ((flag) & (BIT(GRP_MF3300)|BIT(GRP_IP1)))

// A3 printer && CustomSize width == 297
#define TEST_CAPABLE_PAPER_A3_W297(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF3300)))

//// dual RPGL(RPGL&RPGL2) in memory card
//#define TEST_CAPABLE_DUALRPGL(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF250M)))

// A4 printer
#define TEST_CAPABLE_PAPER_A4MAX(flag)  ((flag) & (BIT(GRP_NX70)))

// capability of Select_Tray_by_Papersize("papername+X")
#define TEST_CAPABLE_PAPERX(flag)       ((flag) & (BIT(GRP_MF150e)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))

// fixed bug about reset smoothing/tonner_save_mode at ENDDOC (We must not reset SP8 series.)
#define TEST_BUGFIX_RESET_SMOOTH(flag)  ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|PRODUCTS_SINCE96))

// fixed bug about formfeed around ymax-coordinate.
#define TEST_BUGFIX_FORMFEED(flag)      ((flag) & PRODUCTS_SINCE98)

// DeltaRow Compression while TrueType font downloading
#define TEST_CAPABLE_DOWNLOADFONT_DRC(flag)  ((flag) & (BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99))

// GW architecture model
#define TEST_GWMODEL(flag)              ((flag) & (BIT(GRP_NX720)))

#define TEST_AFTER_SP9II(flag)  ((flag) & PRODUCTS_SINCE96)
#define TEST_AFTER_SP10(flag)   ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_AFTER_SP8(flag)    ((flag) & (BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_GRP_240DPI(flag)   ((flag) & (BIT(GRP_SP4mkII)|BIT(GRP_SP8)))
#define TEST_GRP_OLDMF(flag)    ((flag) & (BIT(GRP_MF530)|BIT(GRP_MF150)|BIT(GRP_MF150e)))
#define TEST_MAXCOPIES_99(flag) ((flag) & (BIT(GRP_SP4mkII)|BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MF150)|BIT(GRP_MF150e)|BIT(GRP_MF200)|BIT(GRP_MF250M)|BIT(GRP_IP1)))  // @Sep/01/98


// approximate value for using 10pt raster font (240dpi model) & standard width of
// barcode.
// if you make NEAR10PT_MIN less, see font-clipping at OEMOutputChar() of rpdlms.c
#define NEAR10PT_MIN                900     // 9pt
#define NEAR10PT_MAX                1110    // 11pt

// RPDL characters assigned block for AssignIBMfont()
#define IBMFONT_ENABLE_ALL          1       // <-JIS1_BLOCK @Sep/14/98
#define IBMFONT_RESUME              4       // <-INSUFFICIENT_BLOCK @Sep/14/98

// DrawTOMBO() action item  @Sep/14/98
#define INIT_TOMBO                  0
#define DRAW_TOMBO                  1

// RPDL GrayFill
#define RPDLGRAYMAX                 64
#define RPDLGRAYMIN                 2  // @Aug/15/98

// RPDL staple position
#define STAPLE_UPPERLEFT            0   // upper left
#define STAPLE_LEFT2                2   // left 2 position
#define STAPLE_RIGHT2               10  // right 2 position
#define STAPLE_UPPERRIGHT           12  // upper right
#define STAPLE_UPPER2               14  // upper 2 position
#define STAPLE_UPPERLEFT_CORNER     0   // upper left  (corner mode)
#define STAPLE_UPPERRIGHT_CORNER    3   // upper right (corner mode)

// RPDL punch position
#define PUNCH_LEFT                  0
#define PUNCH_RIGHT                 2
#define PUNCH_UPPER                 3

// collate type
#define COLLATE_OFF                 0
#define COLLATE_ON                  1
#define COLLATE_UNIDIR              2
#define COLLATE_ROTATED             3
#define COLLATE_SHIFTED             4

// media type
#define MEDIATYPE_STD               0   // Standard
#define MEDIATYPE_OHP               1   // Transparency(OHP)
#define MEDIATYPE_THICK             2   // Thick Paper
#define MEDIATYPE_SPL               3   // Special
#define MEDIATYPE_TRACE             4   // Tracing Paper
#define MEDIATYPE_LABEL             12  // Labels
#define MEDIATYPE_THIN              20  // Thin Paper

// definition for barcode
#define BARCODE_MAX                 HEAPSIZE64  // max# of barcode character
#define BAR_UNIT_JAN                330 // 0.33mm:default module unit of JAN
#define BAR_UNIT1_2OF5              300 // 0.3mm: default module unit1 of 2of5,CODE39
#define BAR_UNIT2_2OF5              750 // 0.75mm:default module unit2 of 2of5,CODE39
#define BAR_UNIT1_NW7               210 // 0.21mm:default module unit1 of NW-7
#define BAR_UNIT2_NW7               462 // 0.462mm:default module unit2 of NW-7
#define BAR_W_MIN_5PT               504 // scaling minimum limit of 5pt
#define BAR_H_DEFAULT               10  // 10mm:default bar height
#define BAR_H_MAX                   999 // 999mm:max bar height
#define BAR_H_MIN                   1   // 1mm:min bar height
// @Feb/08/2000 ->
#define BAR_TYPE_JAN_STD            0   // JAN(STANDARD)
#define BAR_TYPE_JAN_SHORT          1   // JAN(SHORT)
#define BAR_TYPE_2OF5IND            2   // 2of5(INDUSTRIAL)
#define BAR_TYPE_2OF5MTX            3   // 2of5(MATRIX)
#define BAR_TYPE_2OF5ITF            4   // 2of5(ITF)
#define BAR_TYPE_CODE39             5   // CODE39
#define BAR_TYPE_NW7                6   // NW-7
#define BAR_TYPE_CUSTOMER           7   // CUSTOMER
#define BAR_TYPE_CODE128            8   // CODE128
#define BAR_TYPE_UPC_A              9   // UPC(A)
#define BAR_TYPE_UPC_E              10  // UPC(E)
#define BAR_H_CUSTOMER              36  // 3.6mm:default bar height
#define BAR_CODE128_START           104 // CODE128-B start character
// @Feb/08/2000 <-

// max/min binding margin in RPDL
#define BIND_MARGIN_MAX             50
#define BIND_MARGIN_MIN             0

// variable scaling
#define VAR_SCALING_DEFAULT         100
#define VAR_SCALING_MAX             200
#ifndef GWMODEL     // @Sep/21/2000
#define VAR_SCALING_MIN             50
#else  // GWMODEL
#define VAR_SCALING_MIN             40
#endif // GWMODEL

// adjust distance of TOMBO
#define DEFAULT_0                   0
#define TOMBO_ADJ_MAX               50
#define TOMBO_ADJ_MIN               (-50)

// margin to disable FF by RPDL
#define DISABLE_FF_MARGIN_STD       48  // unit:masterunit
#define DISABLE_FF_MARGIN_E2E       72  // unit:masterunit  at Edge to Edge Print

// for clipping of font at paper bottom
#define CLIPHEIGHT_12PT             100 // (dot) 12pt at 600dpi

// clear clipping
#define CLIP_IFNEED                 0
#define CLIP_MUST                   1

// user defined papersize
#define USRD_W_A3_OLD               296
#define USRD_W_A3                   297
#define USRD_W_A2                   432
#define USRD_W_A4                   216
#define USRD_H_MIN148               148


// font resource # in GPD (if you reorder of PFM files at GPD, check here.)
#define EURO_FNT_FIRST              1
#define BOLDFACEPS                  2
#define EURO_MSFNT_FIRST            5
#define SYMBOL                      18
#define EURO_FNT_LAST               19      // if you change this, watch TEST_VERTICALFONT below.
#define JPN_FNT_FIRST               (EURO_FNT_LAST+1)
#define MINCHO_1                    JPN_FNT_FIRST
#define MINCHO_B1                   (JPN_FNT_FIRST+2)
#define MINCHO_E1                   (JPN_FNT_FIRST+4)
#define GOTHIC_B1                   (JPN_FNT_FIRST+6)
#define GOTHIC_M1                   (JPN_FNT_FIRST+8)
#define GOTHIC_E1                   (JPN_FNT_FIRST+10)
#define MARUGOTHIC_B1               (JPN_FNT_FIRST+12)
#define MARUGOTHIC_M1               (JPN_FNT_FIRST+14)
#define MARUGOTHIC_L1               (JPN_FNT_FIRST+16)
#define GYOSHO_1                    (JPN_FNT_FIRST+18)
#define KAISHO_1                    (JPN_FNT_FIRST+20)
#define KYOKASHO_1                  (JPN_FNT_FIRST+22)
#define MINCHO10_RAS                (JPN_FNT_FIRST+24) // for 240dpi model
#define MINCHO_3                    (JPN_FNT_FIRST+26) // for NX-100 only
#define GOTHIC_B3                   (JPN_FNT_FIRST+28) // for NX-100 only
#define AFTER_SP9II_FNT_FIRST       (JPN_FNT_FIRST+30) // MINCHO_2
#define JPN_MSPFNT_FIRST            (JPN_FNT_FIRST+54) // PMINCHO
#define JPN_FNT_LAST                (JPN_FNT_FIRST+56) // PGOTHIC

#define TEST_VERTICALFONT(id)       ((id)%2)


// Command callback IDs (Almost all IDs come from Win95/NT4 GPC.)
#define CMD_SEND_BLOCK              24  // <- CMD_SEND_BLOCK_COMPRESS  MSKK
//#define CMD_SET_CLIPRECT            25
//#define CMD_CLEAR_CLIPRECT          26
#define CMD_ENDDOC_SP4              27
#define CMD_ENDDOC_SP8              28
#define CMD_ENDDOC_SP9              29
#define CMD_ENDDOC_400DPI_MODEL     30
#define CMD_MULTI_COPIES            31
//#define CMD_BEGIN_POLYGON           32
//#define CMD_CONTINUE_POLYLINE       33
//#define CMD_CONTINUE_POLYGON        34
//#define CMD_RECTANGLE               35
//#define CMD_CIRCLE                  36
#define CMD_FF                      37
#define CMD_FONT_BOLD_ON            38
#define CMD_FONT_BOLD_OFF           39
#define CMD_FONT_ITALIC_ON          40
#define CMD_FONT_ITALIC_OFF         41
#define CMD_FONT_WHITETEXT_ON       42
#define CMD_FONT_WHITETEXT_OFF      43
#define CMD_XM_ABS                  44  // These 6 IDs must be in this order.
#define CMD_XM_REL                  45  //
#define CMD_XM_RELLEFT              46  //
#define CMD_YM_ABS                  47  //
#define CMD_YM_REL                  48  //
#define CMD_YM_RELUP                49  //
#define CMD_BEGINDOC_SP9            50
#define CMD_BEGINDOC_MF150E         51
#define CMD_RES240                  52
#define CMD_RES400                  53
#define CMD_RES600                  54
#define CMD_SELECT_PAPER_CUSTOM     55
#define CMD_SET_PORTRAIT            56
#define CMD_SET_LANDSCAPE           57
//#define CMD_SELECT_SOLID            58
//#define CMD_SELECT_HS_HORZ          59
//#define CMD_SELECT_HS_VERT          60
//#define CMD_SELECT_HS_FDIAG         61
//#define CMD_SELECT_HS_BDIAG         62
//#define CMD_SELECT_HS_CROSS         63
//#define CMD_SELECT_HS_DIAGCROSS     64
//#define CMD_DELETE_BRUSHSTYLE       65
//#define CMD_EXIT_VECT               66
#define CMD_BEGINDOC_SP4            67
#define CMD_BEGINDOC_SP8            68
#define CMD_BEGINDOC_MF530          69
//#define CMD_DUPLEX_ON               70
#define CMD_DUPLEX_VERT             71
#define CMD_DUPLEX_HORZ             72
#define CMD_SELECT_AUTOFEED         73
#define CMD_SELECT_MANUALFEED       74
#define CMD_SELECT_MULTIFEEDER      75
#define CMD_SELECT_PAPER_A6         76
#define CMD_BEGINDOC_SP9II          77
#define CMD_BEGINDOC_MF150          78
#define CMD_BEGINDOC_SP10           79
#define CMD_RLE_COMPRESS_ON         80  // <- CMD_SEND_BLOCK_NOCOMPRESS  MSKK
//#define CMD_CIRCLE_PIE              81  // These 6 IDs must be in this order.
//#define CMD_CIRCLE_ARC              82  //
//#define CMD_CIRCLE_CHORD            83  //
//#define CMD_ELLIPSE_PIE             84  //
//#define CMD_ELLIPSE_ARC             85  //
//#define CMD_ELLIPSE_CHORD           86  // 
#define CMD_BEGINDOC_MFP250         87
#define CMD_END_POLYGON             88
#define CMD_SELECT_PAPER_A3         89
#define CMD_SELECT_PAPER_A4         90
#define CMD_SELECT_PAPER_A5         91
#define CMD_SELECT_PAPER_B4         92
#define CMD_SELECT_PAPER_B5         93
#define CMD_SELECT_PAPER_B6         94
#define CMD_SELECT_PAPER_TABLOID    95
#define CMD_SELECT_PAPER_LEGAL      96
#define CMD_SELECT_PAPER_LETTER     97
#define CMD_SELECT_PAPER_STATEMENT  98
#define CMD_IMGCTRL_AA67            99
#define CMD_IMGCTRL_BA80            100
#define CMD_SELECT_PAPER_A2TOA3     101
#define CMD_SET_TEXTRECT_W          102
#define CMD_SET_TEXTRECT_H          103
#define CMD_DRAW_TEXTRECT           104
#define CMD_CR                      105
#define CMD_LF                      106
#define CMD_BS                      107
#define CMD_DRV_2IN1_67             108
#define CMD_DRV_2IN1_100            109
#define CMD_BEGINDOC_NX100          110
#define CMD_IMGCTRL_BA115           111
#define CMD_BEGINDOC_NX500          112
#define CMD_DL_SET_FONT_ID          113
#define CMD_DL_SELECT_FONT_ID       114
#define CMD_SELECT_PAPER_DOUBLEPOSTCARD 115
//#define CMD_BEGINDOC_MFP250E        116
#define CMD_BEGINDOC_MF250M         117
#define CMD_BEGINDOC_MF3550         118
#define CMD_SELECT_MULTITRAY        119
#define CMD_IMGCTRL_100             120 // These 11 IDs must be in this order.
#define CMD_IMGCTRL_88              121 //
#define CMD_IMGCTRL_80              122 //
#define CMD_IMGCTRL_75              123 //
#define CMD_IMGCTRL_70              124 //
#define CMD_IMGCTRL_67              125 //
#define CMD_IMGCTRL_115             126 //
#define CMD_IMGCTRL_122             127 //
#define CMD_IMGCTRL_141             128 //
#define CMD_IMGCTRL_200             129 //
#define CMD_IMGCTRL_50              130 //
#define CMD_DRV_4IN1_50             131
#define CMD_BEGINDOC_MF200          132 // @Sep/01/98
#define CMD_SELECT_PAPER_A2         133
#define CMD_SELECT_PAPER_C          134
#define CMD_BEGINDOC_MF3300         135
#define CMD_COMPRESS_OFF            136 // MSKK
#define CMD_BEGINDOC_IP1            137
#define CMD_SELECT_ROLL1            138
#define CMD_SELECT_ROLL2            139
#define CMD_IMGCTRL_AA141           140
#define CMD_IMGCTRL_AA200           141
#define CMD_IMGCTRL_AA283           142
#define CMD_IMGCTRL_A1_400          143
#define CMD_IMGCTRL_283             144
#define CMD_IMGCTRL_400             145
#define CMD_MEDIATYPE_STANDARD      146
#define CMD_MEDIATYPE_OHP           147
#define CMD_MEDIATYPE_THICK         148
#define CMD_REGION_STANDARD         149
#define CMD_REGION_EDGE2EDGE        150
#define CMD_SELECT_STAPLE_NONE      151
#define CMD_SELECT_STAPLE_1         152
#define CMD_SELECT_STAPLE_2         153
#define CMD_SELECT_PUNCH_NONE       154
#define CMD_SELECT_PUNCH_1          155
#define CMD_DRAW_TEXTRECT_REL       156
#define CMD_DL_SET_FONT_GLYPH       157
#define CMD_SET_MEM0KB              158
#define CMD_SET_MEM128KB            159
#define CMD_SET_MEM256KB            160
#define CMD_SET_MEM512KB            161
#define CMD_BEGINDOC_NX70           164
#define CMD_SELECT_PAPER_B3         165
#define CMD_SELECT_PAPER_A3TOA4     166
#define CMD_SELECT_PAPER_B4TOA4     167
#define CMD_SELECT_PAPER_POSTCARD   168
#define CMD_SET_BASEOFFSETX_0       169
#define CMD_SET_BASEOFFSETX_1       170
#define CMD_SET_BASEOFFSETX_2       171
#define CMD_SET_BASEOFFSETX_3       172
#define CMD_SET_BASEOFFSETX_4       173
#define CMD_SET_BASEOFFSETX_5       174
#define CMD_SET_BASEOFFSETY_0       175
#define CMD_SET_BASEOFFSETY_1       176
#define CMD_SET_BASEOFFSETY_2       177
#define CMD_SET_BASEOFFSETY_3       178
#define CMD_SET_BASEOFFSETY_4       179
#define CMD_SET_BASEOFFSETY_5       180
#define CMD_SET_LONG_EDGE_FEED      181
#define CMD_SET_SHORT_EDGE_FEED     182
#define CMD_OEM_COMPRESS_ON         183
#define CMD_SET_SRCBMP_W            184
#define CMD_SET_SRCBMP_H            185
#define CMD_BEGINDOC_NX700          186
#define CMD_SET_COLLATE_OFF         187
#define CMD_SET_COLLATE_ON          188
#define CMD_SELECT_COLLATE_UNIDIR   189
#define CMD_SELECT_COLLATE_ROTATED  190
#define CMD_DRAW_TEXTRECT_WHITE     191 // MSKK  Aug/14/98
#define CMD_DRAW_TEXTRECT_WHITE_REL 192
#define CMD_SELECT_COLLATE_SHIFTED  193
#define CMD_BEGINDOC_NX900          194
#define CMD_BEGINDOC_MF1530         195
#define CMD_MEDIATYPE_SPL           196
#define CMD_RES1200                 197
#define CMD_SELECT_STAPLE_MAX1      198
#define CMD_SELECT_PAPER_11x15TOA4  199 // @Jan/27/2000
#define CMD_SELECT_TRAY1            200 // These 5 IDs must be in this order.
#define CMD_SELECT_TRAY2            201 //
#define CMD_SELECT_TRAY3            202 //
#define CMD_SELECT_TRAY4            203 //
#define CMD_SELECT_TRAY5            204 //
#define CMD_MEDIATYPE_TRACE         205 // @Feb/15/2000
#define CMD_BEGINDOC_NX710          206 // @Jun/23/2000
#define CMD_BEGINDOC_NX720          207 // @Sep/26/2000
#define CMD_MEDIATYPE_LABEL         208 // @Oct/12/2000
#define CMD_MEDIATYPE_THIN          209 // @Feb/05/2001
#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\debug.c ===
#include <minidrv.h>

VOID DbgPrint(LPCSTR lpszMessage,  ...)
{
    char    szMsgBuf[1024];
    va_list VAList;

    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
    }
    return;
} //*** DbgPrint


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgA
//
//  Description:  Outputs variable argument ANSI debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgA(LPCSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    char    szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgA


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgW
//
//  Description:  Outputs variable argument UNICODE debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgW(LPCWSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    WCHAR   szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfW(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringW(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",        // This disables other compression.
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\hlp\rpdlcfg.hh ===
;IDH_Orientation=
;IDH_InputBin=
;IDH_Resolution=
;IDH_PaperSize=
;IDH_Collate=
;IDH_Duplex=
IDH_EdgeToEdgePrint=1
IDH_LeftMarginInPrinting=2
IDH_TopMarginInPrinting=3
IDH_EmulationMode=4
IDH_MediaType=5
IDH_OutputBin=6
IDH_Sorting=7
IDH_Stapling=8
IDH_Punching=9
IDH_ScanForRules=10
IDH_PrintQuality=11
IDH_PrintDensity=12
IDH_ImageControl=13
IDH_Halftone=14
IDH_Memory=15
IDH_LongEdgeFeed=16
IDH_CollateType=17
IDH_PrintTextAsBlack=18
;IDH_HardDisk=
;IDH_Finisher=
;IDH_PrintPost=
IDH_UI_VariableScaling=50
IDH_UI_BarHeight=51
IDH_UI_BarSubFont=52
IDH_UI_DuplexMargin=53
IDH_UI_BindRight=54
IDH_UI_TomboAdd=55
IDH_UI_TomboAdjX=56
IDH_UI_TomboAdjY=57
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\rpdlres.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation & RICOH Co., Ltd. All rights reserved.

FILE:           RPDLRES.C

Abstract:       Main file for OEM rendering plugin module.

Functions:      OEMCommandCallback
                OEMSendFontCmd
                OEMOutputCharStr
                OEMDownloadFontHeader
                OEMDownloadCharGlyph
                OEMTTDownloadMethod
                OEMCompression

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    08/11/1997 -Masatoshi Kubokura-
        Began to modify for RPDL.
    04/22/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/1999 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/1999 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    02/17/2000 -Masatoshi Kubokura-
        V.1.02 release
    04/07/2000 -Masatoshi Kubokura-
        Fix bug of SET_IBM_EXT_BLOCK with 1200dpi printer (RPDL bug)
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4  release
    06/30/2000 -Masatoshi Kubokura-
        V.1.04 release
    01/22/2001 -Masatoshi Kubokura-
        V.1.05 release
    02/05/2001 -Masatoshi Kubokura-
        Add "Thick Paper"
    03/15/2001 -Masatoshi Kubokura-
        Fix RectangleFill bug

--*/

#include <stdio.h>
#include "pdev.h"

#if DBG
//#define DBG_OUTPUTCHARSTR 1
//#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif

//
// Misc definitions and declarations.
//
#define STDVAR_BUFSIZE(n) \
    (sizeof (GETINFO_STDVAR) + sizeof(DWORD) * 2 * ((n) - 1))  // MSKK 1/24/98
#define MASTER_TO_SPACING_UNIT(p, n) \
    ((n) / (p)->nResoRatio)
#ifndef WINNT_40
#define sprintf     wsprintfA   // @Sep/30/98
#define strcmp      lstrcmpA    // @Sep/30/98
#endif // WINNT_40

// External Functions' prototype
// @Aug/31/99 ->
//extern BOOL RWFileData(PFILEDATA pFileData, LONG type);
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);
// @Aug/31/99 <-

// Local Functions' prototype
static BYTE IsDBCSLeadByteRPDL(BYTE Ch);
static BYTE IsDifferentPRNFONT(BYTE Ch);
static VOID DrawTOMBO(PDEVOBJ pdevobj, SHORT action);
static VOID AssignIBMfont(PDEVOBJ pdevobj, SHORT rcID, SHORT action);
static VOID SendFaxNum(PDEVOBJ pdevobj);
#ifdef JISGTT
static VOID jis2sjis(BYTE jis[], BYTE sjis[]);
#endif // JISGTT
static INT DRCompression(PBYTE pInBuf, PBYTE pOutBuf, DWORD dwInLen, DWORD dwOutLen,
                         DWORD dwWidthByte, DWORD dwHeight);

//
// Static data to be used by this minidriver.
//

static BYTE ShiftJisRPDL[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

// Some vertical device font differ from TrueType font
static BYTE VerticalFontCheck[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,  //70
        1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,  //80
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  //D0
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //E0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   //F0
};

static BYTE UpdateDate[] = "03/15/2001";

// OBSOLETE (described in GPD) @Feb/15/98 ->
// Emulation Mode after printing
//static BYTE *RPDLProgName[] = {
//    "1@R98", "1@R16", "1@RPS", "1@R55",                         //  0- 3
//    "1@RGL", "1@GL2", "1@R52", "1@R73",                         //  4- 7
//    "1@R35", "1@R01",                                           //  8- 9
//    "0@P1",  "0@P2",  "0@P3",  "0@P4",                          // 10-13
//    "0@P5",  "0@P6",  "0@P7",  "0@P8",                          // 14-17
//    "0@P9",  "0@P10", "0@P11", "0@P12",                         // 18-21
//    "0@P13", "0@P14", "0@P15", "0@P16"                          // 22-25
//};
//static BYTE *RPDLProgName2[] = {
//    "-1,1,1@R98", "-1,1,1@R16", "-1,1,1@RPS", "-1,1,1@R55",     //  0- 3
//    "-1,1,1@RGL", "-1,1,1@GL2", "-1,1,1@R52", "-1,1,1@R73",     //  4- 7
//    "-1,1,1@R35", "-1,1,1@R01",                                 //  8- 9
//    "0,1,2@P1",   "0,1,2@P2",   "0,1,2@P3",   "0,1,2@P4",       // 10-13
//    "0,1,2@P5",   "0,1,2@P6",   "0,1,2@P7",   "0,1,2@P8",       // 14-17
//    "0,1,2@P9",   "0,1,2@P10",  "0,1,2@P11",  "0,1,2@P12",      // 18-21
//    "0,1,2@P13",  "0,1,2@P14",  "0,1,2@P15",  "0,1,2@P16"       // 22-25
//};
//#define PRG_RPGL    4
// @Feb/15/98 <-

// RPDL pagesize (unit:masterunit)
static POINT RPDLPageSize[] = {
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3
    {1872L*MASTERUNIT/240L, 2720L*MASTERUNIT/240L},  // A4
    {1280L*MASTERUNIT/240L, 1904L*MASTERUNIT/240L},  // A5
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L},  // A6
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4
    {1600L*MASTERUNIT/240L, 2352L*MASTERUNIT/240L},  // B5
    {1104L*MASTERUNIT/240L, 1640L*MASTERUNIT/240L},  // B6
    {2528L*MASTERUNIT/240L, 4000L*MASTERUNIT/240L},  // Tabloid
    {1920L*MASTERUNIT/240L, 3280L*MASTERUNIT/240L},  // Legal
    {1920L*MASTERUNIT/240L, 2528L*MASTERUNIT/240L},  // Letter
    {1200L*MASTERUNIT/240L, 1968L*MASTERUNIT/240L},  // Statement
    {3969L*MASTERUNIT/240L, 5613L*MASTERUNIT/240L},  // A2->A3
    {6480L*MASTERUNIT/400L, 8960L*MASTERUNIT/400L},  // A2
    {6667L*MASTERUNIT/400L, 8448L*MASTERUNIT/400L},  // C
    {5587L*MASTERUNIT/400L, 7792L*MASTERUNIT/400L},  // B3      @Jan/07/98
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3->A4  @Feb/04/98
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4->A4  @Feb/04/98
    {6600L*MASTERUNIT/600L, 8160L*MASTERUNIT/600L},  // 11x15->A4  @Jan/27/2000
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L}   // Postcard since NX700 @Feb/13/98
};
#define PAGESPACE_2IN1_100  12      // mm
static WORD PageSpace_2IN1_67[] = {
    30, 23, 22, 18,     // A3,A4,A5,A6
    25, 23, 19, 56,     // B4,B5,B6,Tabloid
     6,  6, 35,  6,     // Legal(disable),Letter,Statement,A2->A3(disable)
     6,  6,  6,  6,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     6,  6,  6          // B4->A4(disable),11x15->A4(disable),Postcard(disable)
};

static POINT RPDLPageSizeE2E[] = {
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3
    {(2100000L/254L+5L)/10L*MASTERUNIT/100L, (2970000L/254L+5L)/10L*MASTERUNIT/100L},  // A4
    {(1480000L/254L+5L)/10L*MASTERUNIT/100L, (2100000L/254L+5L)/10L*MASTERUNIT/100L},  // A5
    {(1050000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L},  // A6
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4
    {(1820000L/254L+5L)/10L*MASTERUNIT/100L, (2570000L/254L+5L)/10L*MASTERUNIT/100L},  // B5
    {(1280000L/254L+5L)/10L*MASTERUNIT/100L, (1820000L/254L+5L)/10L*MASTERUNIT/100L},  // B6
    {110L*MASTERUNIT/10L, 170L*MASTERUNIT/10L},                                        // Tabloid
    { 85L*MASTERUNIT/10L, 140L*MASTERUNIT/10L},                                        // Legal
    { 85L*MASTERUNIT/10L, 110L*MASTERUNIT/10L},                                        // Letter
    { 55L*MASTERUNIT/10L,  85L*MASTERUNIT/10L},                                        // Statement
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2->A3
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2
    {170L*MASTERUNIT/10L, 220L*MASTERUNIT/10L},                                        // C
    {(3640000L/254L+5L)/10L*MASTERUNIT/100L, (5140000L/254L+5L)/10L*MASTERUNIT/100L},  // B3
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3->A4
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4->A4
    {110L*MASTERUNIT/10L, 150L*MASTERUNIT/10L},                                        // 11x15 -> A4  @Jan/27/2000
    {(1000000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L}   // Postcard since NX700
};
#define PAGESPACE_2IN1_100E2E  0    // mm
static WORD PageSpace_2IN1_67E2E[] = {
    18, 11, 10,  6,     // A3,A4,A5,A6
    15, 11,  9, 43,     // B4,B5,B6,Tabloid
     0,  0, 23,  0,     // Legal(disable),Letter,Statement,A2->A3(disable)
     0,  0,  0,  0,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     0,  0,  0          // B4->A4(disable),11x15->A4(disable),Postcard(disable)
};

#define RPDL_A3     0
#define RPDL_A4     1
#define RPDL_A5     2
#define RPDL_A6     3   // A6/Postcard
#define RPDL_B4     4
#define RPDL_B5     5
#define RPDL_B6     6
#define RPDL_TABD   7
#define RPDL_LEGL   8
#define RPDL_LETR   9
#define RPDL_STAT   10
#define RPDL_A2A3   11
#define RPDL_A2     12
#define RPDL_C      13
#define RPDL_B3     14
#define RPDL_A3A4   15
#define RPDL_B4A4   16
#define RPDL_11x15A4    17  // @Jan/27/2000
#define RPDL_POSTCARD   18  // Postcard since NX700
#define RPDL_CUSTOMSIZE 99

// RPDL command definition
static BYTE BS[]                  = "\x08";
static BYTE FF[]                  = "\x0C";
static BYTE CR[]                  = "\x0D";
static BYTE LF[]                  = "\x0A";
static BYTE DOUBLE_BS[]           = "\x08\x08";
static BYTE DOUBLE_SPACE[]        = "\x20\x20";
static BYTE BEGIN_SEND_BLOCK_C[]  = "\x1B\x12G3,%d,%d,,2,,,%u@";
static BYTE BEGIN_SEND_BLOCK_NC[] = "\x1B\x12G3,%d,%d,,,@";
static BYTE BEGIN_SEND_BLOCK_DRC[] = "\x1B\x12G3,%d,%d,,5,,@";
static BYTE ESC_ROT0[]            = "\x1B\x12\x46\x30\x20";
static BYTE ESC_ROT90[]           = "\x1B\x12\x46\x39\x30\x20";
static BYTE ESC_VERT_ON[]         = "\x1B\x12&2\x20";
static BYTE ESC_VERT_OFF[]        = "\x1B\x12&1\x20";
static BYTE ESC_SHIFT_IN[]        = "\x1B\x0F";
static BYTE ESC_SHIFT_OUT[]       = "\x1B\x0E";
static BYTE ESC_CTRLCODE[]        = "\x1B\x12K1\x20";
static BYTE ESC_HALFDOWN[]        = "\x1B\x55";
static BYTE ESC_HALFUP[]          = "\x1B\x44";
static BYTE ESC_DOWN[]            = "\x1B\x55\x1B\x55";
static BYTE ESC_UP[]              = "\x1B\x44\x1B\x44";
static BYTE ESC_BOLD_ON[]         = "\x1BO";
static BYTE ESC_BOLD_OFF[]        = "\x1B&";
static BYTE ESC_ITALIC_ON[]       = "\x1B\x12I-16\x20";
static BYTE ESC_ITALIC_OFF[]      = "\x1B\x12I0\x20";
static BYTE ESC_WHITETEXT_ON[]    = "\x1B\x12W5,0\x20";
static BYTE ESC_WHITETEXT_OFF[]   = "\x1B\x12W0,0\x20";
static BYTE ESC_XM_ABS[]          = "\x1B\x12H%d\x20";
static BYTE ESC_XM_REL[]          = "\x1B\x12\x20+%d\x20";
static BYTE ESC_XM_RELLEFT[]      = "\x1B\x12\x20-%d\x20";
static BYTE ESC_YM_ABS[]          = "\x1B\x12V%d\x20";
static BYTE ESC_YM_REL[]          = "\x1B\x12\x0A+%d\x20";
static BYTE ESC_YM_RELUP[]        = "\x1B\x12\x0A-%d\x20";
static BYTE ESC_CLIPPING[]        = "\x1B\x12*%d,%d,%d,%d\x20";
static BYTE SELECT_PAPER_CUSTOM[] = "\x1B\x12\x3F\x35%ld,%ld\x1B\x20";
static BYTE SELECT_PAPER_CUSTOM2[]= "\x1B\x12\x3F\x35%ld,%ld,%d\x1B\x20";   // %ld<-%d @Sep/27/2000, %d<-%c @Oct/13/2000
static BYTE SELECT_TRAY_N[]       = "\x1B\x19%d";                           // %d<-%c  @Oct/13/2000
static BYTE SELECT_PAPER_HEAD[]   = "\x1B\x12\x35\x32@";
static BYTE SEL_TRAY_PAPER_HEAD[] = "\x1B\x12\x35@";
static BYTE SELECT_PAPER_HEAD_IP1[] = "\x1B\x12\x35\x33@";
static BYTE SELECT_PAPER_A1[]     = "A1\x1B\x20";
static BYTE SELECT_PAPER_A2[]     = "A2\x1B\x20";
static BYTE SELECT_PAPER_A3[]     = "A3\x1B\x20";
static BYTE SELECT_PAPER_A4[]     = "A4\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A4R[]    = "A4R\x1B\x20";
static BYTE SELECT_PAPER_A4X[]    = "A4X\x1B\x20";
static BYTE SELECT_PAPER_A4W[]    = "A4R\x1B\x20\x1B\x12\x35@A4\x1B\x20";
static BYTE SELECT_PAPER_A5[]     = "A5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A5R[]    = "A5R\x1B\x20";
static BYTE SELECT_PAPER_A5X[]    = "A5X\x1B\x20";
static BYTE SELECT_PAPER_A5W[]    = "A5R\x1B\x20\x1B\x12\x35@A5\x1B\x20";
static BYTE SELECT_PAPER_A6[]     = "A6\x1B\x20";
static BYTE SELECT_PAPER_PC[]     = "PC\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_PCR[]    = "PCR\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_PCX[]    = "PCX\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_B3[]     = "B3\x1B\x20";   // @Jan/07/98
static BYTE SELECT_PAPER_B4[]     = "B4\x1B\x20";
static BYTE SELECT_PAPER_B5[]     = "B5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_B5R[]    = "B5R\x1B\x20";
static BYTE SELECT_PAPER_B5X[]    = "B5X\x1B\x20";
static BYTE SELECT_PAPER_B5W[]    = "B5R\x1B\x20\x1B\x12\x35@B5\x1B\x20";
static BYTE SELECT_PAPER_B6[]     = "B6\x1B\x20";
static BYTE SELECT_PAPER_C[]      = "FLT\x1B\x20";
static BYTE SELECT_PAPER_TABD[]   = "DLT\x1B\x20";
static BYTE SELECT_PAPER_LEGL[]   = "LG\x1B\x20";
static BYTE SELECT_PAPER_LETR[]   = "LT\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_LETRR[]  = "LTR\x1B\x20";
static BYTE SELECT_PAPER_LETRX[]  = "LTX\x1B\x20";
static BYTE SELECT_PAPER_LETRW[]  = "LTR\x1B\x20\x1B\x12\x35@LT\x1B\x20";
static BYTE SELECT_PAPER_STAT[]   = "HL\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_STATR[]  = "HLR\x1B\x20";
static BYTE SELECT_PAPER_STATX[]  = "HLX\x1B\x20";
static BYTE SELECT_PAPER_STATW[]  = "HLR\x1B\x20\x1B\x12\x35@HLT\x1B\x20";
static BYTE SET_LIMITLESS_SUPPLY[]= "\x1B\x12Z2\x20";
static BYTE RESET_LIMITLESS_SUPPLY[]= "\x1B\x12Z1\x20"; // @Sep/27/2000
static BYTE SELECT_MANUALFEED[]   = "\x1B\x19T";
static BYTE SELECT_MULTIFEEDER[]  = "\x1B\x19M";
static BYTE SELECT_ROLL1[]        = "\x1B\x12Y1,2\x20";
static BYTE SELECT_ROLL2[]        = "\x1B\x12Y1,4\x20";
//static BYTE SET_EMULATION[]       = "\x1B\x12!%s\x1B\x20";
//static BYTE SET_EMULATION_GL_EX[] = "MS-1,6,11;";
static BYTE SET_PORTRAIT[]        = "\x1B\x12\x44\x31\x20";
static BYTE SET_LANDSCAPE[]       = "\x1B\x12\x44\x32\x20";
static BYTE SET_LEFTMARGIN[]      = "\x1B\x12YK,%d\x20";
static BYTE SET_UPPERMARGIN[]     = "\x1B\x12YL,%d\x20";
static BYTE SET_LEFTMARGIN_9II[]  = "\x1B\x12?Y,K:%d\x1B\x20";
static BYTE SET_UPPERMARGIN_9II[] = "\x1B\x12?Y,L:%d\x1B\x20";
static BYTE SET_MULTI_COPY[]      = "\x1B\x12N%d\x20";
// PRINTER SIDE ISSUE: MF3550 RPDL  @Feb/22/99 ->
// Since 'backslash' can't be printed in Japanese region ('KUNIBETSU'),
// set 1st param to 1 for USA region.
//static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@,,1\x1B\x20";
static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@1,,1\x1B\x20";
// @Feb/22/99 <-
static BYTE SET_PAGEMAX_VALID[]   = "\x1B\x12?+1\x1B\x20";
static BYTE DUPLEX_ON[]           = "\x1B\x12\x36\x31,1\x20";
static BYTE DUPLEX_HORZ[]         = "\x1B\x12YA3,1\x20";
static BYTE DUPLEX_VERT[]         = "\x1B\x12YA3,2\x20";
static BYTE DUPLEX_VERT_R[]       = "\x1B\x12YA3,3\x20";
//static BYTE IMAGE_2IN1[]          = "\x1B\x12\x36\x32,\x20";
static BYTE IMAGE_OPT_OFF[]       = "\x1B\x12\x36\x30,1,0\x20";
static BYTE IMAGE_SCALING_100[]   = "\x1B\x12YM,1\x20";
static BYTE IMAGE_SCALING_88[]    = "\x1B\x12YM,2\x20";
static BYTE IMAGE_SCALING_80[]    = "\x1B\x12YM,3\x20";
static BYTE IMAGE_SCALING_75[]    = "\x1B\x12YM,4\x20";
static BYTE IMAGE_SCALING_70[]    = "\x1B\x12YM,5\x20";
static BYTE IMAGE_SCALING_67[]    = "\x1B\x12YM,6\x20";
static BYTE IMAGE_SCALING_115[]   = "\x1B\x12YM,7\x20";
static BYTE IMAGE_SCALING_122[]   = "\x1B\x12YM,8\x20";
static BYTE IMAGE_SCALING_141[]   = "\x1B\x12YM,9\x20";
static BYTE IMAGE_SCALING_200[]   = "\x1B\x12YM,10\x20";
static BYTE IMAGE_SCALING_283[]   = "\x1B\x12YM,11\x20";
static BYTE IMAGE_SCALING_400[]   = "\x1B\x12YM,12\x20";
static BYTE IMAGE_SCALING_122V[]  = "\x1B\x12?M122,1\x1B\x20";      // variable ratio
static BYTE IMAGE_SCALING_141V[]  = "\x1B\x12?M141,1\x1B\x20";
static BYTE IMAGE_SCALING_200V[]  = "\x1B\x12?M200,1\x1B\x20";
static BYTE IMAGE_SCALING_50V[]   = "\x1B\x12?M50,1\x1B\x20";
static BYTE IMAGE_SCALING_VAR[]   = "\x1B\x12?M%d,1\x1B\x20";

static BYTE SET_PAPERDEST_OUTTRAY[]  = "\x1B\x12\x38\x33,2\x20";
static BYTE SET_PAPERDEST_FINISHER[] = "\x1B\x12\x38\x46,2,1\x20";
static BYTE SET_PAPERDEST_1BINSHIFT[] = "\x1B\x12\x38\x49,,1\x20";  // @Oct/10/2000
// RPDL SPEC changed at NX900. @Jan/08/99 ->
//static BYTE SET_SORT_ON[]            = "\x1B\x12\x36,,1\x20";
static BYTE SET_SORT_ON[]            = "\x1B\x12\x36%d,,1\x20";
// @Jan/08/99 <-
static BYTE SET_STAPLE_ON[]          = "\x1B\x12?O22,0,%d\x1B\x20";
static BYTE SET_STAPLE_CORNER_ON[]   = "\x1B\x12?O22,1,%d\x1B\x20";
static BYTE SET_PUNCH_ON[]           = "\x1B\x12?O32,%d\x1B\x20";
static BYTE SELECT_MEDIATYPE[]       = "\x1B\x12?6%c,%d\x1B\x20";   // %d<-%c @Oct/13/2000
static BYTE COLLATE_DISABLE_ROT[]    = "\x1B\x12?O11\x1B\x20";      // @May/27/98
static BYTE COLLATE_ENABLE_ROT[]     = "\x1B\x12?O12\x1B\x20";      // @Jul/31/98

static BYTE SET_TEXTRECT_BLACK[]  = "\x1B\x12P3,64\x20";
static BYTE SET_TEXTRECT_WHITE[]  = "\x1B\x12W0,3\x20\x1B\x12P3,1\x20"; // @Aug/15/98
static BYTE SET_TEXTRECT_GRAY[]   = "\x1B\x12P3,%d,1\x20";          // add ",1" @Aug/15/98
static BYTE DRAW_TEXTRECT[]       = "\x1B\x12R%d,%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P3[]  = "\x1B\x12r%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P4[]  = "\x1B\x12r%d,%d,%d,%d\x20";

static BYTE BEGINDOC1[]           = "\x1B\x12!1@R00\x1B\x20\x1B\x34\x1B\x12YJ,3\x20";
static BYTE BEGINDOC2_1[]         = "\x1B\x12YP,1\x20\x1B\x12YQ,2\x20";
static BYTE BEGINDOC2_2[]         = "\x1B\x12YQ,2\x20";
static BYTE BEGINDOC3[]           = "\x1B\x12YA6,1\x20";
static BYTE SELECT_RES240_1[]     = "\x1B\x12YI,6\x20";
static BYTE SELECT_RES240_2[]     = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20\x1B\x12#3\x20";
static BYTE SELECT_RES400_1[]     = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,7\x20\x1B\x12YW,1\x20";
static BYTE SELECT_RES400_2[]     = "\x1B\x12YA4,1\x20";
static BYTE SELECT_RES400_3[]     = "\x1B\x12#2\x20";
static BYTE SELECT_RES600[]       = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,8\x20\x1B\x12YW,3\x20\x1B\x12YA4,3\x20\x1B\x12#4\x20";
static BYTE SELECT_RES1200[]      = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,9\x20\x1B\x12YW,4\x20\x1B\x12YA4,4\x20\x1B\x12#5\x20";  // @Mar/02/99
static BYTE SELECT_REGION_STD[]   = "\x1B\x12YB,1\x20";
static BYTE SELECT_REGION_E2E[]   = "\x1B\x12YB,2\x20";
static BYTE ENDDOC1[]             = "\x1B\x12YB,1\x20\x1B\x12YI,1\x20\x1B\x12YJ,1\x20\x1B\x12YM,1\x20";
static BYTE ENDDOC2_240DPI[]      = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20";
static BYTE ENDDOC2_SP9[]         = "\x1B\x12YW,2\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC2_400DPI[]      = "\x1B\x12YW,1\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC3[]             = "\x1B\x12#0\x20";
static BYTE ENDDOC4[]             = "\x1B\x12\x36\x30,0,0\x20";
static BYTE ENDDOC4_FINISHER[]    = "\x1B\x12\x36\x30,0\x20";
static BYTE ENDDOC_JOBDEF_END[]   = "\x1B\x12?JE@\x1B@\x1B@\x1B@\x1B@\x1B\x20"; // @Jan/08/99
static BYTE ENDDOC5[]             = "\x1B\x1AI";
static BYTE SELECT_SMOOTHING2[]   = "\x1B\x12YA2,2\x20";
// If you change FONT_NAME, see AssignIBMfont().
static BYTE SET_IBM_FONT_SCALE[]  = "\x1B\x12\x43%d,M,%ld,%ld,4@I55\x20";
static BYTE SET_IBM_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43%d,M,,%ld,4@I55\x20";    // @Jan/29/99
static BYTE *SET_IBM_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-E B\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-M\x1B\x20",
                                     "GOTHIC-E B\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-M\x1B\x20",
                                     "MARUGOTHIC-L\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
static BYTE SET_JIS_FONT_SCALE[]  = "\x1B\x12\x43\x5A,M,%ld,%ld@";
static BYTE SET_JIS_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43\x5A,M,,%ld@";           // @Jan/29/99
static BYTE *SET_JIS_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-EXTRA BOLD\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-MEDIUM\x1B\x20",
                                     "GOTHIC-EXTRA BOLD\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-MEDIUM\x1B\x20",
                                     "MARUGOTHIC-LIGHT\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
#ifdef DOWNLOADFONT
//static BYTE DLFONT_MALLOC[]       = "\x1B\x12/128,8\x20";
static BYTE DLFONT_MALLOC[]       = "\x1B\x12/%d,%d\x20";
static BYTE DLFONT_SEND_BLOCK[]   = "\x1B\x12G7,%d,%d,%d,@";
static BYTE DLFONT_SEND_BLOCK_DRC[] = "\x1B\x12G7,%d,%d,%d,5,,,%d@";
static BYTE DLFONT_PRINT[]        = "\x1B\x12g%d,,%d\x20";
#endif // DOWNLOADFONT

static BYTE ENTER_VECTOR[]       = "\x1B\x33";
static BYTE EXIT_VECTOR[]        = "\x1B\x34";
static BYTE TERMINATOR[]         = ";";
static BYTE MOVE_ABSOLUTE[]      = "MA%d,%d";
static BYTE BAR_CHECKDIGIT[]     = "BC1";
static BYTE BAR_H_SET[]          = "BH%d";
static BYTE BAR_W_SET_JAN[]      = "JW%d";
static BYTE BAR_W_SET_2OF5[]     = "TW";
static BYTE BAR_W_SET_C39[]      = "CW";
static BYTE BAR_W_SET_NW7[]      = "NW";
static BYTE BAR_W_PARAMS[]       = "%d,%d,%d,%d,%d";
static BYTE BAR_ROT90[ ]         = "RO90";
static BYTE BAR_ROT270[]         = "RO270";
// @Dec/07/99 FK#50 ->
static BYTE BAR_W_SET_CUST[]     = "CS";
// @Dec/07/99 FK#50 <-
static BYTE *BAR_TYPE[]          = {"JL",               // JAN(STANDARD)
                                    "JS",               // JAN(SHORT)
                                    "TI%d,",            // 2of5(INDUSTRIAL)
                                    "TX%d,",            // 2of5(MATRIX)
                                    "TL%d,",            // 2of5(ITF)
                                    "CD%d,",            // CODE39
                                    "NB%d,",            // NW-7
// @Dec/07/99 FK#50 ->
                                    "CU%d,",            // CUSTOMER
                                    "CE%d",             // CODE128(B)
                                    "JU",               // UPC(A)
                                    "JE"                // UPC(W)
// @Dec/07/99 FK#50 <-
                                   };
static BYTE *BAR_NOFONT[]        = {"FJ1,-1",           // JAN(STANDARD)
                                    "FJ1,-1",           // JAN(SHORT)
                                    "FT2,-1",           // 2of5(INDUSTRIAL)
                                    "FT2,-1",           // 2of5(MATRIX)
                                    "FT2,-1",           // 2of5(ITF)
                                    "FC2,-1",           // CODE39
                                    "FN2,-1",           // NW-7
// @Dec/07/99 FK#50 ->
                                    "",                 // CUSTOMER
                                    "FC2,-1",           // CODE128
                                    "FJ1,-1",           // UPC(A)
                                    "FJ1,-1"            // UPC(W)
// @Dec/07/99 FK#50 <-
                                   };

static BYTE PEN_WIDTH[]           = "LW%d";                     // @Sep/14/98
static BYTE DRAW_TOMBO_POLYLINE[] = "MA%d,%dMRPD%d,%d,%d,%d";   // @Sep/14/98
static BYTE BEGINFAX_HEAD[]       = "\x1B\x12!1@R00\x1B\x20\x1B\x12?F1,%d,%d,%d,180,1,";
static BYTE BEGINFAX_CH[]         = "@%d:";
static BYTE BEGINFAX_EXTNUM[]     = "%s-";
static BYTE BEGINFAX_TAIL[]       = ",%08d,RPDLMINI,%d,1,2,1,1,,1,%d,%s,1,,1,,,1,\x1B\x20";
static BYTE ENDFAX[]              = "\x1B\x12?F2,1\x1B\x20";


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams)
{
    INT     ocmd, iRet;
    BYTE    Cmd[256];
    SHORT   nTmp;
    LPSTR   lpcmd;
    WORD    fLandscape, fFinisherSR30Active, fDoFormFeed, fPaperX;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98

//  VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    ocmd = 0;
    iRet = 0;

    // If TextMode RectangleFill or Move_X,Y are not called now &&
    // Move_X,Y command is saved, then flush the command here.
    if (dwCmdCbID != CMD_SET_TEXTRECT_W && dwCmdCbID != CMD_SET_TEXTRECT_H &&
        dwCmdCbID != CMD_DRAW_TEXTRECT &&
        dwCmdCbID != CMD_DRAW_TEXTRECT_REL &&                       // @Dec/11/97
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE &&                     // @Aug/14/98
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE_REL &&                 // @Aug/14/98
        !(dwCmdCbID >= CMD_XM_ABS && dwCmdCbID <= CMD_YM_RELUP))    // @Aug/28/98
    {
        if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))          // @Dec/11/97
        {
            BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
            // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
            if (!pOEM->TextRectGray)
            {
                if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
                else
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
            }
        }

        if (dwCmdCbID == CMD_FF)
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            // Output Move_Y command here.
            ocmd = sprintf(Cmd, ESC_YM_ABS, pOEM->TextCurPos.y);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
            // Output Move_X command here.
            ocmd = sprintf(Cmd, ESC_XM_ABS, pOEM->TextCurPos.x);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
    }

    switch (dwCmdCbID) {
      case CMD_SET_TEXTRECT_W:          // pdwParams:RectXSize
        pOEM->TextRect.x = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_SET_TEXTRECT_H:          // pdwParams:RectYSize
        pOEM->TextRect.y = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_DRAW_TEXTRECT_WHITE:     // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT;

      case CMD_DRAW_TEXTRECT:           // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = sprintf(Cmd, SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = sprintf(Cmd, SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT:       // @Aug/14/98
// @Jan/13/99 ->
        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
// @Jan/13/99 <-
        {
            LONG x = pOEM->TextCurPos.x;
            LONG y = pOEM->TextCurPosRealY;     // y without page_length adjustment
            LONG w = pOEM->TextRect.x;
            LONG h = pOEM->TextRect.y;
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;

            // UNIDRV5 SIDE ISSUE
            // We can rely on DestX, except when CmdCR is emitted.
            // Following bugs are concerned.
            // - RPDL117&124: Current x isn't updated by CMD_XM_ABS while device font
            //   direct(not-substituted) printing. -> DestX is reliable.
            // - #236215: DestX doesn't become 0 after CmdCR when current y is 0.
            //   (SP8 WINPARTy printarea.exe)      -> TextCurPos.x is reliable.
            // - DestX doesn't become 0 after CmdCR, even though current y isn't 0.
            //   (NX720N WINPARTy printarea.exe at 1200dpi) -> TextCurPos.x is reliable.
// @Mar/15/2001 ->
//          if (!(x != dest_x && x == pOEM->Offset.x && y == pOEM->Offset.y))
            if (!(x != dest_x && x == pOEM->Offset.x))
// @Mar/15/2001 <-
                pOEM->TextCurPos.x = x = dest_x;

            // Convert unit from dot to 1/720inch_unit at OLD models
            if (!(TEST_AFTER_SP10(pOEM->fModel) || BITTEST32(pOEM->fModel, GRP_MF150e)))
            {
                if (pOEM->nResoRatio == MASTERUNIT/240)   // 240dpi printer
                {
                    x *= 3;     // 3 = 720/240
                    y *= 3;
                    w *= 3;
                    h *= 3;
                }
                else    // MF530,150
                {
                    x *= 18;    // 18 = 720/400*10
                    w = (w * 18 + x % 10) / 10;     // Adjust fractional part
                    x /= 10;                        // KIRISUTE
                    y *= 18;
                    h = (h * 18 + y % 10) / 10;
                    y /= 10;
                }
            }
            ocmd = sprintf(Cmd, DRAW_TEXTRECT, x, y, w, h);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        break;

      case CMD_DRAW_TEXTRECT_WHITE_REL: // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT_REL;

      // Relative-coordinate rectangle command since NX-510  @Dec/12/97
      case CMD_DRAW_TEXTRECT_REL:       // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = sprintf(Cmd, SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = sprintf(Cmd, SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT_REL:   // @Aug/14/98
        {
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;

            // UNIDRV5 SIDE ISSUE
// @Mar/15/2001 ->
//          if (!(pOEM->TextCurPos.x != dest_x && pOEM->TextCurPos.x == pOEM->Offset.x &&
//                pOEM->TextCurPosRealY == pOEM->Offset.y))
            if (!(pOEM->TextCurPos.x != dest_x && pOEM->TextCurPos.x == pOEM->Offset.x))
// @Mar/15/2001 <-
            {
                pOEM->TextCurPos.x = dest_x;
            }
        }

        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
            ocmd = sprintf(Cmd, DRAW_TEXTRECT,
                           pOEM->TextCurPos.x, pOEM->TextCurPosRealY,
                           pOEM->TextRect.x, pOEM->TextRect.y);
        }
        else
        {
            LONG x = pOEM->TextCurPos.x - pOEM->TextRectPrevPos.x;
            LONG y = pOEM->TextCurPosRealY - pOEM->TextRectPrevPos.y;

            // If height is 1dot, this parameter can be omitted.
            if (pOEM->TextRect.y != 1)
                ocmd = sprintf(Cmd, DRAW_TEXTRECT_R_P4, x, y,
                               pOEM->TextRect.x, pOEM->TextRect.y);
            else
                ocmd = sprintf(Cmd, DRAW_TEXTRECT_R_P3, x, y,
                               pOEM->TextRect.x);
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        pOEM->TextRectPrevPos.x = pOEM->TextCurPos.x;
        pOEM->TextRectPrevPos.y = pOEM->TextCurPosRealY;
        break;


      case CMD_SET_SRCBMP_H:            // @Jun/04/98
        pOEM->dwSrcBmpHeight = *pdwParams;
        break;

      case CMD_SET_SRCBMP_W:            // @Jun/04/98
        pOEM->dwSrcBmpWidthByte = *pdwParams;
        break;

      case CMD_OEM_COMPRESS_ON:         // @Jun/04/98
//      VERBOSE(("** OEM_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral2, OEM_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        break;

      case CMD_RLE_COMPRESS_ON:
//      VERBOSE(("** RLE_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_COMPRESS_OFF:
//      VERBOSE(("** COMPRESS_OFF **\n"));
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_SEND_BLOCK:              // pdwParams:NumOfDataBytes,RasterDataH&W
        // Do FE-DeltaRow compression  @Jun/04/98
        if (BITTEST32(pOEM->fGeneral2, OEM_COMPRESS_ON))
        {
//          VERBOSE(("** OEM_COMPRESS_SEND (%d) **\n", *pdwParams));
            ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_DRC,
                           (WORD)*(pdwParams+2) * 8,      // RasterDataWidthInBytes
                           (WORD)*(pdwParams+1));         // RasterDataHeightInPixels
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        else
        {
            // Do FE-RunLength compression
            if (BITTEST32(pOEM->fGeneral1, RLE_COMPRESS_ON))
            {
//              VERBOSE(("** RLE_COMPRESS_SEND (%d) **\n", *pdwParams));
                ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_C,
                               (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                               (WORD)*(pdwParams+1),      // RasterDataHeightInPixels
                               (WORD)*pdwParams);         // NumOfDataBytes
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            }
            // No compression
            else
            {
//              VERBOSE(("** NO_COMPRESS_SEND (%d) **\n", *pdwParams));

// OBSOLETE (FilterGraphics disables other compression!) @Feb/16/99 ->
#if 0   // SP8BUGFIX_RASTER
// @Feb/10/99 ->
                BITCLR32(pOEM->fGeneral2, DIVIDE_DATABLOCK);
                // PRINTER SIDE ISSUE: RPDL
                // SP7&8 can't handle over-32768byte block with default printer memory
                if (BITTEST32(pOEM->fModel, GRP_SP8))
                {
                    // send divided blocks at OEMFilterGraphics().
                    BITSET32(pOEM->fGeneral2, DIVIDE_DATABLOCK);
                    pOEM->dwSrcBmpHeight = *(pdwParams+1);
                    pOEM->dwSrcBmpWidthByte = *(pdwParams+2);
                }
                else
// @Feb/10/99 <-
#endif // if 0
// @Feb/16/99 <-
                {
                    ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_NC,
                                   (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                                   (WORD)*(pdwParams+1));     // RasterDataHeightInPixels
                    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                }
            }
        }
        break;


      case CMD_XM_ABS:                  // pdwParams:DestX
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
#ifdef DOWNLOADFONT
            pOEM->nCharPosMoveX = 0;
#endif // DOWNLOADFONT
            iRet = pOEM->TextCurPos.x = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPos.x += pOEM->Offset.x;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_XM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_YM_ABS:                  // pdwParams:DestY
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = pOEM->TextCurPos.y = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

            // PRINTER SIDE ISSUE: RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            pOEM->TextCurPos.y += pOEM->Offset.y;
            pOEM->TextCurPosRealY += pOEM->Offset.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_YM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_XM_REL:                  // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x += iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_XM_RELLEFT:              // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x -= iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_REL:                  // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y += iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_RELUP:                // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y -= iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_CR:
#ifdef DOWNLOADFONT
        pOEM->nCharPosMoveX = 0;    // @Jan/19/98
#endif // DOWNLOADFONT
        ocmd = sprintf(Cmd, CR);
        if ((pOEM->TextCurPos.x = pOEM->Offset.x) != 0)
            ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
//      VERBOSE(("** CMD_CR **\n"));
        break;

      case CMD_LF:
        WRITESPOOLBUF(pdevobj, LF, sizeof(LF)-1);
        break;

      case CMD_BS:
        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
        break;

      case CMD_FF:
        fDoFormFeed = FALSE;
        // If 2in1
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
        {
            // If 2nd page finished
            if (pOEM->Nin1RemainPage)
            {
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
            }
            // If not 2nd page, disable formfeed and increase offset.
            else
            {
                WORD PageSpace, wTmp;

                pOEM->Nin1RemainPage++;
                // space(dot) between 2pages of 2in1.
                if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67E2E[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100E2E;
                }
                else
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100;
                }
                PageSpace = ((WORD)(MASTERUNIT*10)/(WORD)254) * wTmp /
                             pOEM->nResoRatio;

                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                    pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y + PageSpace;
                else
                    pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x + PageSpace;
            } // 'if (Nin1RemainPage) else' end
        }
        // If 4in1
        else if (TEST_4IN1_MODE(pOEM->fGeneral1))     // OLD MF do not support this
        {
            switch (++pOEM->Nin1RemainPage)     // bug fix @Jan/20/99
            {
              default:  // If illegal, treat as 1st page finished.
                pOEM->Nin1RemainPage = 1;
                pOEM->Offset.y = pOEM->BaseOffset.y;
              case 1:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 2:
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y;
                break;
              case 3:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 4:   // 4th page finished
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
                break;
            }
        }
        // Usual case (non Nin1 mode)
        else
        {
            // Output formfeed command later
            fDoFormFeed = TRUE;
        } // 'if (TEST_2IN1_MODE) else if (TEST_4IN1_MODE) else' end

        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);

        if (fDoFormFeed)
        {
            if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/14/98
                DrawTOMBO(pdevobj, DRAW_TOMBO);

            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);       // moved here @Sep/14/98

            // SPEC of RPDL
            // Because RPDL's formfeed resets font status(vertical-text, bold, italic,
            // white-text and  TextMode clipping), we must output these commands again.
            if (BITTEST32(pOEM->fGeneral1, FONT_VERTICAL_ON))
                ocmd = sprintf(Cmd, ESC_VERT_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_BOLD_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_ITALIC_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_WHITETEXT_ON);
        } // 'if (fDoFormFeed)' end

        // Reset coordinate x&y
        pOEM->TextCurPos.x = pOEM->Offset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y;
        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += sprintf(&Cmd[ocmd], ESC_YM_ABS, pOEM->TextCurPos.y);
        // reset coordinate y without page_length adjustment, too.
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_FONT_BOLD_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))      // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_ON, sizeof(ESC_BOLD_ON)-1);
        }
        break;

      case CMD_FONT_BOLD_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))       // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_OFF, sizeof(ESC_BOLD_OFF)-1);
        }
        break;

      case CMD_FONT_ITALIC_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))    // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_ON, sizeof(ESC_ITALIC_ON)-1);
        }
        break;

      case CMD_FONT_ITALIC_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))     // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_OFF, sizeof(ESC_ITALIC_OFF)-1);
        }
        break;

      case CMD_FONT_WHITETEXT_ON:
        BITSET32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
        break;

      case CMD_FONT_WHITETEXT_OFF:
        BITCLR32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        break;


#ifdef DOWNLOADFONT
      case CMD_DL_SET_FONT_ID:      // pdwParams:FontHeight
// OBSOLETE @Nov/20/98 ->
//      pOEM->DLFontH_MU = (WORD)*pdwParams;        // @Jun/30/98
// @Nov/20/98 <-
        break;

      case CMD_DL_SELECT_FONT_ID:
// OBSOLETE @Jun/30/98 ->
//      pOEM->DLFontCurID = (WORD)*pdwParams;       // CurrentFontID
// @Jun/30/98 <-
        break;

      case CMD_DL_SET_FONT_GLYPH:   // pdwParams:NextGlyph
//      VERBOSE(("[DL_SET_FONT_GLYPH] glyph=%d\n", (SHORT)*pdwParams));
        pOEM->DLFontCurGlyph = (WORD)*pdwParams;
        break;

//
// Following cases are called at the beginning of a print-job
//
      case CMD_SET_MEM0KB:          // JOB_SETUP.10  @Jan/14/98
        pOEM->DLFontMaxMemKB = 0;                   // disabled
        pOEM->pDLFontGlyphInfo = NULL;              // @Sep/08/98
        break;

      case CMD_SET_MEM128KB:
        pOEM->DLFontMaxMemKB = MEM128KB;            // 128Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_4;         // 2->4 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM256KB:
        pOEM->DLFontMaxMemKB = MEM256KB;            // 256Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_8;         // 4->8 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM512KB:
        pOEM->DLFontMaxMemKB = MEM512KB;            // 512Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_16;        // 8->16 @Oct/20/98
//      goto _SET_MEM_ENABLE;

      _SET_MEM_ENABLE:      // @Sep/08/98
        pOEM->DLFontMaxGlyph = DLFONT_GLYPH_TOTAL;  // 116->70 @Oct/20/98
        // allocate glyph info structure for TrueType download.
        if(!(pOEM->pDLFontGlyphInfo = (FONTPOS*)MemAllocZ(pOEM->DLFontMaxID *
                                                          pOEM->DLFontMaxGlyph *
                                                          sizeof(FONTPOS))))
        {
            pOEM->DLFontMaxMemKB = 0;   // disabled
        }
        break;
#endif // DOWNLOADFONT

      case CMD_SELECT_STAPLE_NONE:  // JOB_SETUP.20  @Dec/02/97
        pOEM->StapleType = 0;
        break;

      case CMD_SELECT_STAPLE_1:
        pOEM->StapleType = 1;
        break;

      case CMD_SELECT_STAPLE_2:
        pOEM->StapleType = 2;
        break;

      case CMD_SELECT_STAPLE_MAX1:  // @Mar/18/99
        pOEM->StapleType = 3;       // stapling with FinisherSR12(max 1staple)
        break;

      case CMD_SELECT_PUNCH_NONE:   // JOB_SETUP.30  @Dec/02/97
        pOEM->PunchType = 0;
        break;

      case CMD_SELECT_PUNCH_1:
        pOEM->PunchType = 1;
        break;


      case CMD_BEGINDOC_SP4:        // SP4mkII,5
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP4mkII);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF530:      // MF530
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF530);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF150:      // MF150
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF150E:     // MF150e,160
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150e);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP8:        // SP8(7),8(7)mkII,80
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP8);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MFP250:     // MF-P250,355,250(FAX),355(FAX),MF-FD355,MF-P250e,355e
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MFP250);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP10:       // SP10,10mkII
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP10);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9:        // SP9,10Pro
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9II:      // SP9II,10ProII,90
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9II);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF200:      // MF200,MF-p150,MF2200
        pOEM->fModel = 0;           // (separate BEGINDOC_SP9II @Sep/01/98)
        BITSET32(pOEM->fModel, GRP_MF200);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX100:      // NX-100
        pOEM->fModel = 0;
        // not support IBM extended character block
        BITSET32(pOEM->fModel, GRP_NX100);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX500:      // NX-500,1000,110,210,510,1100
        pOEM->fModel = 0;
        // TT font download capable
        BITSET32(pOEM->fModel, GRP_NX500);
        goto _BEGINDOC_FINISH1;

// OBSOLETE @Apr/15/99
//    case CMD_BEGINDOC_MFP250E:    // MF-P250e,355e
//      pOEM->fModel = 0;
//      BITSET32(pOEM->fModel, GRP_MFP250e);
//      goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF250M:    // MF250M
        // staple capable
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF250M);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3550:    // MF2700,3500,3550,4550,5550,6550,3530,3570,4570,
                                   // 5550EX,6550EX,3530e,3570e,4570e,5570,7070,8570,105Pro
        // staple & punch & media type option
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF3550);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3300:    // MF3300W,3350W,3540W,3580W
        pOEM->fModel = 0;
        // A2 printer
        BITSET32(pOEM->fModel, GRP_MF3300);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_IP1:       // IP-1
        pOEM->fModel = 0;
        // A1 plotter
        BITSET32(pOEM->fModel, GRP_IP1);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX70:      // NX70,71  @Feb/04/98
        pOEM->fModel = 0;
        // A4 printer, FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX70);   // BITSET->BITSET32  @Jun/01/98
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX700:     // NX700,600,FAX Printer,MF700  @Jun/12/98
        pOEM->fModel = 0;
        // FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX700);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX900:     // NX900  @Jan/08/99
        pOEM->fModel = 0;
        // job define command(of ENDJOB) is needed for staple/punch
        BITSET32(pOEM->fModel, GRP_NX900);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF1530:    // MF1530,2230,2730,NX800,910,810  @Mar/03/99
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option
        BITSET32(pOEM->fModel, GRP_MF1530);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX710:    // NX710,610  @Jun/23/2000
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option (& variable scaling bug)
        BITSET32(pOEM->fModel, GRP_NX710);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX720:    // NX620,620N,720N,Neo350,350D,450,220,270  @Sep/26/2000
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option (GW model)
        BITSET32(pOEM->fModel, GRP_NX720);
//      goto _BEGINDOC_FINISH1;

      _BEGINDOC_FINISH1:
        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            SendFaxNum(pdevobj);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_1);
        // Set Duplex:off
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC3);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
#ifdef DOWNLOADFONT
        pOEM->dwDLFontUsedMem = 0;
        if (pOEM->DLFontMaxMemKB)
        {
            ocmd = sprintf(Cmd, DLFONT_MALLOC, pOEM->DLFontMaxMemKB, DLFONT_MIN_BLOCK_ID);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
#endif // DOWNLOADFONT

      _BEGINDOC_FINISH2:   // @Sep/09/98
        // Allocate heap memory for OEMOutputCharStr&OEMDownloadCharGlyph. 
        pOEM->pRPDLHeap2K = (PBYTE)MemAllocZ(HEAPSIZE2K);
        break;


      case CMD_SET_BASEOFFSETX_0:   // @May/07/98
      case CMD_SET_BASEOFFSETX_1:
      case CMD_SET_BASEOFFSETX_2:
      case CMD_SET_BASEOFFSETX_3:
      case CMD_SET_BASEOFFSETX_4:
      case CMD_SET_BASEOFFSETX_5:
        pOEM->BaseOffset.x = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETX_0);
        break;

      case CMD_SET_BASEOFFSETY_0:   // @May/07/98
      case CMD_SET_BASEOFFSETY_1:
      case CMD_SET_BASEOFFSETY_2:
      case CMD_SET_BASEOFFSETY_3:
      case CMD_SET_BASEOFFSETY_4:
      case CMD_SET_BASEOFFSETY_5:
        pOEM->BaseOffset.y = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETY_0);
        break;


      case CMD_RES240:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/240;
        // Set Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        if (!BITTEST32(pOEM->fModel, GRP_SP4mkII))
            ocmd = sprintf(Cmd, IMAGE_OPT_OFF);
        // Set Spacing_Unit:1/240inch
        ocmd += sprintf(&Cmd[ocmd], SELECT_RES240_1);
        if (TEST_AFTER_SP10(pOEM->fModel))                // SP10,9,etc
            // Set Graphics_Unit & Coordinate_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += sprintf(&Cmd[ocmd], SELECT_RES240_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES400:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/400;
        // Set Spacing_Unit & Graphics_Unit:1/400inch
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        ocmd = sprintf(Cmd, SELECT_RES400_1);
        if (!BITTEST32(pOEM->fModel, GRP_MF530))
        {
            // Set Engine_Resolution:400dpi
            ocmd += sprintf(&Cmd[ocmd], SELECT_RES400_2);
            if (TEST_AFTER_SP10(pOEM->fModel) ||
                BITTEST32(pOEM->fModel, GRP_MF150e))      // MF150e,160
            {
                // Set Coordinate_Unit:1/400inch
                ocmd += sprintf(&Cmd[ocmd], SELECT_RES400_3);
            }
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES600:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/600;
#ifdef DOWNLOADFONT
        // If non-DRC&&600dpi then make it half.  @Jun/15/98
        if (!TEST_CAPABLE_DOWNLOADFONT_DRC(pOEM->fModel))
            pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/600inch,
        // Engine_Resolution:600dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES600, sizeof(SELECT_RES600)-1);
        break;

      case CMD_RES1200:             // @Mar/02/99
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/1200;
#ifdef DOWNLOADFONT
        pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/1200inch,
        // Engine_Resolution:1200dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES1200, sizeof(SELECT_RES1200)-1);
        break;


      case CMD_REGION_STANDARD:     // @Nov/29/97
        BITCLR32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/15/98
            WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_REGION_STD, sizeof(SELECT_REGION_STD)-1);
        break;

      case CMD_REGION_EDGE2EDGE:    // @Nov/29/97
        BITSET32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        break;


      case CMD_IMGCTRL_100:
        if (pOEMExtra->UiScale != VAR_SCALING_DEFAULT)  // @Feb/06/98
        {
            pOEM->Scale = pOEMExtra->UiScale;           // @Mar/18/98
            ocmd = sprintf(Cmd, IMAGE_SCALING_VAR, pOEM->Scale);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
            break;
        }
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_88:
        pOEM->Scale = 88;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_88, sizeof(IMAGE_SCALING_88)-1);
        break;

      case CMD_IMGCTRL_80:
        pOEM->Scale = 80;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_75:
        pOEM->Scale = 75;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_75, sizeof(IMAGE_SCALING_75)-1);
        break;

      case CMD_IMGCTRL_70:
        pOEM->Scale = 70;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_70, sizeof(IMAGE_SCALING_70)-1);
        break;

      case CMD_IMGCTRL_67:
        pOEM->Scale = 67;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_115:
        pOEM->Scale = 115;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_IMGCTRL_122:
        pOEM->Scale = 122;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122, sizeof(IMAGE_SCALING_122)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122V, sizeof(IMAGE_SCALING_122V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_141:
        pOEM->Scale = 141;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141V, sizeof(IMAGE_SCALING_141V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_200:
        pOEM->Scale = 200;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200V, sizeof(IMAGE_SCALING_200V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_50:
        pOEM->Scale = 50;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        break;

      case CMD_IMGCTRL_AA67:        // A->A scaling(67%)
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA67);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_BA80:        // B->A scaling(80%)
        pOEM->Scale = 80;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA80);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_BA115:       // B->A scaling(115%)
        pOEM->Scale = 115;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA115);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_DRV_4IN1_50:         // 4in1
        pOEM->Scale = 50;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_4IN1_50);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        break;

      case CMD_DRV_2IN1_67:         // 2in1
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_67);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_DRV_2IN1_100:        // 2in1
        pOEM->Scale = 100;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_100);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_AA141:       // IP-1,3300W,3350W:A->A scaling(141%)
        pOEM->Scale = 141;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA141);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        break;

      case CMD_IMGCTRL_AA200:       // IP-1:A->A scaling(200%)
        pOEM->Scale = 200;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA200);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        break;

      case CMD_IMGCTRL_AA283:       // IP-1:A->A scaling(283%)
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA283);
      case CMD_IMGCTRL_283:         // IP-1
        pOEM->Scale = 283;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_283, sizeof(IMAGE_SCALING_283)-1);
        break;

      case CMD_IMGCTRL_A1_400:      // IP-1:400% with A1
        BITSET32(pOEM->fGeneral1, IMGCTRL_A1_400);
      case CMD_IMGCTRL_400:         // IP-1
        pOEM->Scale = 400;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_400, sizeof(IMAGE_SCALING_400)-1);
        break;


      case CMD_SET_LANDSCAPE:
        BITSET32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;

      case CMD_SET_PORTRAIT:
        BITCLR32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;


// OBSOLETE (actually obsoleted at converting GPC to GPD) @Jan/08/99 ->
//    case CMD_DUPLEX_ON:
//      BITSET32(pOEM->fGeneral1, DUPLEX_VALID);
//      break;
// @Jan/08/99 <-

      case CMD_DUPLEX_VERT:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
      _DUP_V:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID);
            // Convert mm to 5mm_unit(2=5mm,3=10mm,...,11=50mm)
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = sprintf(Cmd, SET_LEFTMARGIN, nTmp);
            // SP9II(except 1st lot),10ProII can set binding margin every 1 mm
            if (TEST_AFTER_SP9II(pOEM->fModel))
                ocmd += sprintf(&Cmd[ocmd], SET_LEFTMARGIN_9II, pOEMExtra->UiBindMargin);
        }
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT))
        {
            pOEM->BindPoint = BIND_RIGHT;
            ocmd += sprintf(&Cmd[ocmd], DUPLEX_VERT_R);
        }
        else
        {
            pOEM->BindPoint = BIND_LEFT;
            ocmd += sprintf(&Cmd[ocmd], DUPLEX_VERT);
        }
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_ON);
// DCR  @Jan/27/2000 ->
        // Emit IMAGE_SCALING_xxxV here, because DUPLEX_VERT resets IMAGE_SCALING_xxxV
        if (BITTEST32(pOEM->fGeneral1, VARIABLE_SCALING_VALID));
            ocmd += sprintf(&Cmd[ocmd], IMAGE_SCALING_VAR, pOEM->Scale);
// @Jan/27/2000 <-
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_DUPLEX_HORZ:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
      _DUP_H:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID);
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = sprintf(Cmd, SET_UPPERMARGIN, nTmp);
            if (TEST_AFTER_SP9II(pOEM->fModel))
            {
                ocmd += sprintf(&Cmd[ocmd], SET_UPPERMARGIN_9II, pOEMExtra->UiBindMargin);
            }
        }
        pOEM->BindPoint = BIND_UPPER;
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_HORZ);
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_ON);
// DCR  @Jan/27/2000 ->
        // Emit IMAGE_SCALING_xxxV here, because DUPLEX_HORZ resets IMAGE_SCALING_xxxV
        if (BITTEST32(pOEM->fGeneral1, VARIABLE_SCALING_VALID));
            ocmd += sprintf(&Cmd[ocmd], IMAGE_SCALING_VAR, pOEM->Scale);
// @Jan/27/2000 <-
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_MEDIATYPE_STANDARD:
            pOEM->MediaType = MEDIATYPE_STD;    // use pOEM->MediaType  @Mar/03/99
            break;

      case CMD_MEDIATYPE_OHP:
            pOEM->MediaType = MEDIATYPE_OHP;
            break;

      case CMD_MEDIATYPE_THICK:
            pOEM->MediaType = MEDIATYPE_THICK;
            break;

      case CMD_MEDIATYPE_SPL:       // since MF1530  @Mar/03/99
            pOEM->MediaType = MEDIATYPE_SPL;
            break;

      case CMD_MEDIATYPE_TRACE:     // since MF5570  @Feb/15/2000
            pOEM->MediaType = MEDIATYPE_TRACE;
            break;

      case CMD_MEDIATYPE_LABEL:     // since Neo450  @Oct/12/2000
            pOEM->MediaType = MEDIATYPE_LABEL;
            break;

      case CMD_MEDIATYPE_THIN:      // since Neo270  @Feb/05/2001
            pOEM->MediaType = MEDIATYPE_THIN;
            break;

      case CMD_SELECT_PAPER_A2:
        pOEM->DocPaperID = RPDL_A2;
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A2;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        // Because incapable, clear setting
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A3:
        pOEM->DocPaperID = RPDL_A3;
        // If able to select tray with "papername+X" && no staple && no punch
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO) &&
            TEST_CAPABLE_PAPER_A2(pOEM->fModel))
        {
            lpcmd = SELECT_PAPER_B3;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        // If A->A(141%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A2;
        // If A->A(200%) || A1(400%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_A3;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        // Because incapable, clear setting
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A4:
        pOEM->DocPaperID = RPDL_A4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_B4;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If 2in1(100%), scale up papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A3;
        // If A->A(67%), scale down papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A2;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A5:
        pOEM->DocPaperID = RPDL_A5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A6:
        pOEM->DocPaperID = RPDL_A6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A6;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_POSTCARD:       // since NX700  @Feb/13/98
        pOEM->DocPaperID = RPDL_POSTCARD;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A4X;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        lpcmd = SELECT_PAPER_PCX;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B3:             // @Jan/07/98
        pOEM->DocPaperID = RPDL_B3;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = SELECT_PAPER_B3;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B4:
        pOEM->DocPaperID = RPDL_B4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A3;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_B4;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B5:
        pOEM->DocPaperID = RPDL_B5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_B4;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B6:
        pOEM->DocPaperID = RPDL_B6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else
            lpcmd = SELECT_PAPER_B6;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_C:
        pOEM->DocPaperID = RPDL_C;
        lpcmd = SELECT_PAPER_C;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_TABLOID:
        pOEM->DocPaperID = RPDL_TABD;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_TABD;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LEGAL:
        pOEM->DocPaperID = RPDL_LEGL;
        lpcmd = SELECT_PAPER_LEGL;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LETTER:
        pOEM->DocPaperID = RPDL_LETR;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_TABD;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_STATEMENT:
        pOEM->DocPaperID = RPDL_STAT;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_STATX : SELECT_PAPER_STATW;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
            goto _IMGCTRL_OFF1;
        break;

      case CMD_SELECT_PAPER_A2TOA3:
        pOEM->DocPaperID = RPDL_A2A3;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A3;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_A3TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_A3A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_B4TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_B4A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_11x15TOA4:      // @Feb/07/2000
        pOEM->DocPaperID = RPDL_11x15A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);

        // Emulate NEC MultiWriter 2200
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            pOEM->BaseOffset.x = 37;    // mm
            pOEM->BaseOffset.y = 15;
        }
        else
        {
            pOEM->BaseOffset.x = 15;
            pOEM->BaseOffset.y = 37;
        }

        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;


      case CMD_SELECT_PAPER_DOUBLEPOSTCARD:
        BITSET32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD);
        goto _SET_CUSTOMSIZE;

      case CMD_SELECT_PAPER_CUSTOM:     // pdwParams:PhysPaperWidth,Length
        pOEM->PhysPaperWidth  = (WORD)*pdwParams;       // @Dec/26/97
        pOEM->PhysPaperLength = (WORD)*(pdwParams+1);
        BITSET32(pOEM->fGeneral1, PAPER_CUSTOMSIZE);

      _SET_CUSTOMSIZE:
        pOEM->DocPaperID = RPDL_CUSTOMSIZE;
        pOEM->RPDLHeapCount = 0;
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      _IMGCTRL_OFF1:
        // Invalidate image controls
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
      _IMGCTRL_OFF2:
        BITCLR_SCALING_SEL_TRAY(pOEM->fGeneral1);
        BITCLR_NIN1_MODE(pOEM->fGeneral1);
        break;


      case CMD_SET_LONG_EDGE_FEED:          // for Multi Tray  @May/25/98
        BITSET32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;

      case CMD_SET_SHORT_EDGE_FEED:         // for Multi Tray  @May/25/98
        BITCLR32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;


      case CMD_SELECT_AUTOFEED:
        // Set MediaType (modify  @Mar/03/99, @Feb/15/2000, moved top@Sep/27/2000)
        if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
        {
// @Oct/13/2000 ->
//          ocmd = sprintf(Cmd, SELECT_MEDIATYPE, 'T', '0'+pOEM->MediaType);
            ocmd = sprintf(Cmd, SELECT_MEDIATYPE, 'T', pOEM->MediaType);
// @Oct/13/2000 <-
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            ocmd = 0;
        }
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
            goto _SELECTPAPER_CUSTOMSIZE;
        }
        // Output Set_Limitless_Paper_Supply_Mode
        WRITESPOOLBUF(pdevobj, SET_LIMITLESS_SUPPLY, sizeof(SET_LIMITLESS_SUPPLY)-1);
        // Output Select_Tray_By_Papersize command.
        //   if letter size, select A4 first in case of no letter paper.
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4X, sizeof(SELECT_PAPER_A4X)-1);
        }
        else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4W, sizeof(SELECT_PAPER_A4W)-1);
        }
        WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;

// @Dec/10/99 FK#49, add TRAY1,3,4,5 & reset limitless @Sep/27/2000 ->
      case CMD_SELECT_TRAY1:
      case CMD_SELECT_TRAY2:
      case CMD_SELECT_TRAY3:
      case CMD_SELECT_TRAY4:
      case CMD_SELECT_TRAY5:
        ocmd = sprintf(Cmd, SELECT_TRAY_N, dwCmdCbID - CMD_SELECT_TRAY1 + 2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        if (TEST_GWMODEL(pOEM->fModel))
            WRITESPOOLBUF(pdevobj, RESET_LIMITLESS_SUPPLY, sizeof(RESET_LIMITLESS_SUPPLY)-1);
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            goto _SELECTPAPER_CUSTOMSIZE;
        }
        break;
// @Dec/10/99, @Sep/27/2000 <-

      case CMD_SELECT_MANUALFEED:
      case CMD_SELECT_MULTIFEEDER:
      case CMD_SELECT_MULTITRAY:        // NXs' MultiTray
// Moved forward, because NX710(MultiTray) support MediaType  @Mar/11/99 ->
        // Set MediaType (modify @Mar/03/99, @Feb/15/2000)
        if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
        {
// @Oct/13/2000 ->
//          ocmd = sprintf(Cmd, SELECT_MEDIATYPE, 'T', '0'+pOEM->MediaType);
            ocmd = sprintf(Cmd, SELECT_MEDIATYPE, 'T', pOEM->MediaType);
// @Oct/13/2000 <-
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            ocmd = 0;
        }
// @Mar/11/99 <-
        // Select Feeder
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
        {
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        }
        else
        {
            // Select MultiFeeder/MultTray
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
//@Sep/27/2000 ->
            if (TEST_GWMODEL(pOEM->fModel))
                WRITESPOOLBUF(pdevobj, RESET_LIMITLESS_SUPPLY, sizeof(RESET_LIMITLESS_SUPPLY)-1);
//@Sep/27/2000 <-
        }
        // If CustomSize, jump.
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            goto _SELECTPAPER_CUSTOMSIZE;
        }

        // Set papersize
        // If papersize without transverse (A1,A2,A3,A6,B3,B4,B6,C,Tabloid,Legal)
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A1)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A2)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B3)    ||    // @Feb/05/98
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_C)     ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD)  ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
        {
            // Output Select_Papersize command
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD, sizeof(SELECT_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        }
        else
        {
            if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4X) ||
                !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4W))
            {
                // If long edge feed is enabled, set transverse paper.  @May/25/98
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A4;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A4R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_B5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_B5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_LETR;
                }
                else
                {
                    lpcmd = SELECT_PAPER_LETRR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_STAT;
                }
                else
                {
                    lpcmd = SELECT_PAPER_STATR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_PCX))   // @Feb/13/98
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_PC;
                }
                else
                {
                    lpcmd = SELECT_PAPER_PCR;
                }
            }
            else
                break;  // exit

            // Output Select_Papersize command
            ocmd = sprintf(Cmd, SELECT_PAPER_HEAD);
            ocmd += sprintf(&Cmd[ocmd], lpcmd);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        } // 'if (A1,A2,A3,A6,B4,B6,C,TABLOID,LEGAL) else' end
        // Reconfirm ManualFeed/AutoFeed.
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
        break;

      _SELECTPAPER_CUSTOMSIZE:
        {
            DWORD   dwWidth, dwHeight;

            // If DoublePostcard
            if (BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = 148;     // mm
                    dwHeight = 200;
                }
                else
                {
                    dwWidth  = 200;
                    dwHeight = 148;
                }
                // Set max pagesize (mm to dot with KIRISUTE)
                pOEM->PageMax.x = (LONG)(dwWidth * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
                pOEM->PageMax.y = (LONG)(dwHeight * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
            }
            // If CustomSize
            else
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = pOEM->PhysPaperLength;           // masterunit
                    dwHeight = pOEM->PhysPaperWidth;
                }
                else
                {
                    dwWidth  = pOEM->PhysPaperWidth;            // masterunit
                    dwHeight = pOEM->PhysPaperLength;
                }
                // Set max pagesize
                pOEM->PageMax.x = (LONG)(dwWidth  / pOEM->nResoRatio);   // dot
                pOEM->PageMax.y = (LONG)(dwHeight / pOEM->nResoRatio);
                // masterunit to mm with SISHAGONYU
                dwWidth  = (dwWidth * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
                dwHeight = (dwHeight * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
            }

            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);

            // Because app sometimes sets under-limit in landscape,
            // we need to swap width and height.  @Oct/21/98
            if (dwHeight < USRD_H_MIN148)           // < 148
            {
                DWORD dwTmp;
                dwTmp = dwWidth;
                dwWidth = dwHeight;
                dwHeight = dwTmp;
            }
            else if (dwWidth >= dwHeight)
            {
                WORD fSwap = FALSE;

                // Because app sometimes sets over-limit width in portrait,
                // we need to swap width and height.
                if (TEST_CAPABLE_PAPER_A2(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A2)            // > 432
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A3_W297(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A3)            // > 297
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A4MAX(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A4)            // > 216
                        fSwap = TRUE;
                }
                else
                {
                    if (dwWidth > USRD_W_A3_OLD)        // > 296
                        fSwap = TRUE;
                }

                if (fSwap)
                {
                    DWORD dwTmp;
                    dwTmp = dwWidth;
                    dwWidth = dwHeight;
                    dwHeight = dwTmp;
                }
                // SPEC of RPDL
                // If width is larger than length, we need to set landscape.
                else
                {
                    BITSET32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
                }
            }
            else
            {
                BITSET32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);
            }

// @Dec/10/99 FK#49, add TRAY1-5 & eliminate TRAYA-D @Sep/27/2000 ->
//          ocmd = sprintf(Cmd, SELECT_PAPER_CUSTOM, (WORD)dwWidth, (WORD)dwHeight);
//          WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
            if (dwCmdCbID >= CMD_SELECT_TRAY1 && dwCmdCbID <= CMD_SELECT_TRAY5)
            {
                ocmd = sprintf(Cmd, SELECT_PAPER_CUSTOM2, (WORD)dwWidth, (WORD)dwHeight,
                               dwCmdCbID - CMD_SELECT_TRAY1 + 2);
            }
            else    // manual feed
            {
                ocmd = sprintf(Cmd, SELECT_PAPER_CUSTOM, (WORD)dwWidth, (WORD)dwHeight);
                ocmd += sprintf(&Cmd[ocmd], SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
// @Dec/10/99, @Sep/27/2000 <-
        }
        break;

      case CMD_SELECT_ROLL1:                // IP-1
      case CMD_SELECT_ROLL2:
        // Select roll (plotter)
        if (dwCmdCbID == CMD_SELECT_ROLL1)
            WRITESPOOLBUF(pdevobj, SELECT_ROLL1, sizeof(SELECT_ROLL1)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_ROLL2, sizeof(SELECT_ROLL2)-1);
        // Output Select_Papersize command ("papername+X" only)
        WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD_IP1, sizeof(SELECT_PAPER_HEAD_IP1)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;

//
//    Here comes PAPER_DESTINATION command in printing.
//    All of these commands are written in GPD.
//

      case CMD_SET_COLLATE_OFF:         // @Jul/31/98
        pOEM->CollateType = COLLATE_OFF;            // COLLATE_OFF<-0     @Dec/02/98
        break;

      case CMD_SET_COLLATE_ON:          // @Jul/31/98
        pOEM->CollateType = COLLATE_ON;             // COLLATE_ON<-1      @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_UNIDIR:   // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_UNIDIR;     // COLLATE_UNIDIR<-2  @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_ROTATED:  // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_ROTATED;    // COLLATE_ROTATED<-3 @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_SHIFTED:  // @Dec/02/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_SHIFTED;
        break;


      // Final command before print
      case CMD_MULTI_COPIES:                // pdwParams:NumOfCopies
        // If not CustomSize, set max pagesize.
        if ((nTmp = pOEM->DocPaperID) != RPDL_CUSTOMSIZE)
        {
            if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
            {
                pOEM->PageMax.x = RPDLPageSizeE2E[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSizeE2E[nTmp].y / pOEM->nResoRatio;
            }
            else
            {
                pOEM->PageMax.x = RPDLPageSize[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSize[nTmp].y / pOEM->nResoRatio;
            }

            if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
            {
                LONG tmp;
                tmp = pOEM->PageMax.x;    // swap x-y
                pOEM->PageMax.x = pOEM->PageMax.y;
                pOEM->PageMax.y = tmp;
            }
        }

        if (TEST_BUGFIX_FORMFEED(pOEM->fModel) ||           // add @Sep/15/98
            BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            pOEM->PageMaxMoveY = pOEM->PageMax.y;
        }
        else
        {
            // PRINTER SIDE ISSUE: RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            // Set PageMaxMoveY for checking max vertical position.
            nTmp = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?     // @Nov/27/97
                   DISABLE_FF_MARGIN_E2E : DISABLE_FF_MARGIN_STD;
            pOEM->PageMaxMoveY = pOEM->PageMax.y - 1 -
                                 (nTmp + pOEM->nResoRatio - 1) /
                                 pOEM->nResoRatio;                  // KIRIAGE
        }

        // If 2in1, switch orientation(portrait<->landscape).
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
            BITSET32(pOEM->fGeneral1, SWITCH_PORT_LAND);
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND) ||
                BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT))
            {
                fLandscape = FALSE;
            }
            else
            {
                fLandscape = TRUE;
            }
        }
        else    // portrait
        {
            fLandscape = BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND)? TRUE : FALSE;
        }
        // Output RPDL orientation command
        if (fLandscape || BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND))
            WRITESPOOLBUF(pdevobj, SET_LANDSCAPE, sizeof(SET_LANDSCAPE)-1);
        else                // portrait
            WRITESPOOLBUF(pdevobj, SET_PORTRAIT, sizeof(SET_PORTRAIT)-1);

        // Output copy#
        // Check whether copy# is in the range.  @Sep/01/98
        {
            DWORD dwCopy, dwMax;

            dwCopy = *pdwParams;    // NumOfCopies
            dwMax = TEST_MAXCOPIES_99(pOEM->fModel)? 99 : 999;

            if(dwCopy > dwMax)
                dwCopy = dwMax;
            else if(dwCopy < 1)
                dwCopy = 1;

            ocmd = sprintf(Cmd, SET_MULTI_COPY, (WORD)dwCopy);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
// @Jan/08/99 ->
            if (1 == dwCopy)
                pOEM->CollateType = COLLATE_OFF;
// @Jan/08/99 <-
        }

        fFinisherSR30Active = FALSE;    // @Mar/19/99

        // staple
        if (pOEM->StapleType)
        {
            ocmd = 0;
            if (BITTEST32(pOEM->fModel, GRP_MF250M))    // model = MF250M (No Punch Unit)
            {
                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = sprintf(Cmd, SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:outer tray
                ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_OUTTRAY);
                // staple:on
                ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON,
                                (fLandscape)?
                                STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER);
            }
            else    // model = MF2700,3500,3550,4550,5550,6550,NXs
            {
                WORD pnt;

                fFinisherSR30Active = TRUE;     // @Mar/19/99

                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = sprintf(Cmd, SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:finisher shift tray
                if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
                    ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
                // Disable rotated collate.
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);   // @Mar/19/99

                if (pOEM->StapleType == 2)          // 2 staples on the paper
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_LEFT2;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_RIGHT2;
                        break;
                      case BIND_UPPER:
                        pnt = STAPLE_UPPER2;
                        break;
//                    case BIND_ANY:
                      default:
                        pnt = (fLandscape)? STAPLE_UPPER2 : STAPLE_LEFT2;
                        break;
                    }
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_ON, pnt);
                }
// @Mar/18/99 ->
                else if (pOEM->StapleType == 3)     // 1 staple with FinisherSR12
                {
// @Apr/06/99 ->
//                  if (BIND_RIGHT == pOEM->BindPoint)
//                      pnt = STAPLE_UPPERRIGHT_CORNER;
//                  else
//                      pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        // If papersize without transverse (A3,B4,Tabloid,Legal)
                        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD) ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
                        {
                            pnt = (fLandscape)? STAPLE_UPPERLEFT_CORNER : STAPLE_UPPERRIGHT_CORNER;
                        }
                        else
                        {
                            pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                        }
                        break;
                    }
// @Apr/06/99 <-
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON, pnt);
                }
// @Mar/18/99 <-
                else                                // 1 staple
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                    }
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON, pnt);
                }
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // punch
        if (pOEM->PunchType)
        {
            WORD pnt;

            ocmd = 0;

            if (!fFinisherSR30Active)   // modify  @Mar/19/99
            {
                if (COLLATE_OFF != pOEM->CollateType)
                {
                    // sort:on (add duplex param since NX900 @Jan/08/99)
                    ocmd = sprintf(Cmd, SET_SORT_ON,
                                   BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
                }
                // paper_destination:finisher shift tray
                if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
                    ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
                // SPEC of RPDL  @May/27/98
                // We must disable rotated collate here.
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);
            }

            switch (pOEM->BindPoint)
            {
              case BIND_LEFT:
                pnt = PUNCH_LEFT;
                break;
              case BIND_RIGHT:
                pnt = PUNCH_RIGHT;
                break;
              case BIND_UPPER:
                pnt = PUNCH_UPPER;
                break;
              default:
                pnt = (fLandscape)? PUNCH_UPPER : PUNCH_LEFT;
                break;
            }
            // punch:on
            ocmd += sprintf(&Cmd[ocmd], SET_PUNCH_ON, pnt);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // collate  (@Jul/31/98, entirely-modify @Dec/02/98)
        if (!pOEM->StapleType && !pOEM->PunchType)
        {
            // sort:on (add duplex param since NX900 @Jan/08/99)
            ocmd = sprintf(Cmd, SET_SORT_ON,
                           BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
            switch (pOEM->CollateType)
            {
              case COLLATE_UNIDIR:
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              case COLLATE_ROTATED:
                ocmd += sprintf(&Cmd[ocmd], COLLATE_ENABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // If shifted collate, select finisher shift tray.
              case COLLATE_SHIFTED:
                if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
                    ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // if collate for MF-p150,MF200,250M,2200,NXs
              case COLLATE_ON:
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              default:
                break;
            }
        }

        ocmd = 0;
        if (TEST_AFTER_SP9II(pOEM->fModel) && !BITTEST32(pOEM->fModel, GRP_NX100))
        {
//@Jun/23/2000 ->
            // PRINTER SIDE ISSUE: NX610,710,71 RPDL
            // Printer hangs up with variable scaling command. Dummy font select is
            // effective on this problem.
            if (BITTEST32(pOEM->fModel, GRP_NX70) || BITTEST32(pOEM->fModel, GRP_NX710))
            {
                // Emit dummy Mincho font select.
                ocmd = sprintf(Cmd, SET_JIS_FONT_SCALE_H_ONLY, 1000L);
                ocmd += sprintf(&Cmd[ocmd], SET_JIS_FONT_NAME[0]);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                ocmd = 0;
            }
//@Jun/23/2000 <-
            // Set IBM extended character code block, and set region to 'USA'. (latter @Feb/22/99)
            ocmd += sprintf(&Cmd[ocmd], SET_IBM_EXT_BLOCK);
            // Disable formfeed when charcter position is around ymax-coordinate
            ocmd += sprintf(&Cmd[ocmd], SET_PAGEMAX_VALID);
        }

        // Set color of Textmode RectangleFill black
        ocmd += sprintf(&Cmd[ocmd], SET_TEXTRECT_BLACK);
        pOEM->TextRectGray = 100;           // @Jan/07/98

        // Set 5mm offset at MF530,150,150e,160.
        // (At these models, CMD_SET_BASEOFFSETs aren't called.)
        if (TEST_GRP_OLDMF(pOEM->fModel) &&
            !BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT) &&
            !BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO)) // add @Sep/15/98
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.y = 5;    // mm
        }

        // Convert mm to dot here ((LONG)<-(DWORD) @Feb/02/99)
        pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;
        pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;

        // Think about scaling  (@May/18/98, (LONG)<-(DWORD) @Feb/02/99)
        if (pOEM->Scale != 100 && pOEM->Scale != 0)
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)100 / (LONG)pOEM->Scale;
            pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)100 / (LONG)pOEM->Scale;
        }

        // Calculate offset for TOMBO.(BaseOffset will be changed.) @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
            DrawTOMBO(pdevobj, INIT_TOMBO);

        // Initialize current position
        pOEM->TextCurPos.x = pOEM->Offset.x = pOEM->BaseOffset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y = pOEM->BaseOffset.y;
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += sprintf(&Cmd[ocmd], ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        break;

//
// Following cases are called at the end of a print-job (JOB_FINISH)
//

      case CMD_ENDDOC_SP4:          // SP4mkII,5
        // If Nin1 && document finished with remaining pages, output FF.
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = sprintf(Cmd, ENDDOC1);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP8:          // SP8(7),8(7)mkII,80,10,10mkII
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = sprintf(Cmd, ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel))    // SP10,10mkII
        {
            // Set Graphics_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += sprintf(&Cmd[ocmd], ENDDOC2_240DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        }
        // Set Options[duplex/2in1:off,reversed_output:off,sort/stack:off]
        ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP9:          // SP9,10Pro,9II,10ProII,90
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = sprintf(Cmd, ENDDOC1);
        // Set Graphics_Unit:1/240inch,Engine_Resolution:400dpi
        ocmd += sprintf(&Cmd[ocmd], ENDDOC2_SP9);
        ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_400DPI_MODEL: // MF,MF-P,NX,IP-1
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = sprintf(Cmd, ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel) ||        // MF-P,NX,MF200,250M,MF-p150,MF2200
            BITTEST32(pOEM->fModel, GRP_MF150e))    // MF150e,160
        {
            // Set Graphics_Unit:1/400inch,Engine_Resolution:400dpi
            ocmd += sprintf(&Cmd[ocmd], ENDDOC2_400DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        }
        // If staple mode, do not change sort/stack of Options.
        if (pOEM->StapleType || pOEM->PunchType)
            ocmd += sprintf(&Cmd[ocmd], ENDDOC4_FINISHER);
        else
            ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
//      goto _ENDDOC_FINISH;

      _ENDDOC_FINISH:
        // Reset smoothing/tonner_save_mode. (PRINTER SIDE ISSUE: We must not reset SP8.)
        if (TEST_BUGFIX_RESET_SMOOTH(pOEM->fModel))
            ocmd += sprintf(&Cmd[ocmd],  SELECT_SMOOTHING2);
        // Terminate fax at imagio FAX
        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            ocmd += sprintf((LPSTR)&Cmd[ocmd], ENDFAX);

// @Jan/08/99 ->
        // PRINTER SIDE ISSUE: NX900 RPDL (job define command is needed)
        if (BITTEST32(pOEM->fModel, GRP_NX900) &&
            (COLLATE_OFF != pOEM->CollateType || pOEM->StapleType || pOEM->PunchType))
        {
            ocmd += sprintf(&Cmd[ocmd], ENDDOC_JOBDEF_END);
        }
// @Jan/08/99 <-
        // Initialize printer
        ocmd += sprintf(&Cmd[ocmd], ENDDOC5);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
        // If binding margin is set,reset it to 0mm.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID))
            ocmd += sprintf(&Cmd[ocmd], SET_LEFTMARGIN, 1);
        else if (BITTEST32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID))
            ocmd += sprintf(&Cmd[ocmd], SET_UPPERMARGIN, 1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        if(pOEM->pRPDLHeap2K)               // @Sep/09/98
            MemFree(pOEM->pRPDLHeap2K);     // add ;  @Aug/02/2000
#ifdef DOWNLOADFONT
        if(pOEM->pDLFontGlyphInfo)          // @Sep/09/98
            MemFree(pOEM->pDLFontGlyphInfo);
#endif // DOWNLOADFONT
        break;


    default:
        ERR((("Unknown callback ID = %d.\n"), dwCmdCbID));
    }

    return iRet;
} //*** OEMCommandCallback


VOID APIENTRY OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[STDVAR_BUFSIZE(3) / sizeof(DWORD)];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
    DWORD       dwNeeded, dwUFO_FontH, dwUFO_FontW;
    DWORD       dwUFO_FontMaxW;     // MSKK Jul/23/98
    LONG        lTmp;

    VERBOSE(("** OEMSendFontCmd() entry. **\n"));

// MSKK 1/24/98 UnSelect ->
    if (0 == pFInv->dwCount)
    {
        // No select command.  pProbably some of the
        // un-select case where no invokation command is
        // available.  (No explicit un-select.)
        return;
    }   
// MSKK 1/24/98 <-

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = STDVAR_BUFSIZE(3);
    pSV->dwNumOfVariable = 3;

    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_FONTWIDTH;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                            pSV->dwSize, &dwNeeded))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

//  VERBOSE((("FONTHEIGHT=%d\n"), pSV->StdVar[0].lStdVariable));
//  VERBOSE((("FONTMAXWIDTH=%d\n"), pSV->StdVar[1].lStdVariable));
//  VERBOSE((("FONTWIDTH=%d\n"), pSV->StdVar[2].lStdVariable));

    dwUFO_FontH    = (DWORD)pSV->StdVar[0].lStdVariable;
    dwUFO_FontMaxW = (DWORD)pSV->StdVar[1].lStdVariable;    // MSKK Jul/23/98
    dwUFO_FontW    = (DWORD)pSV->StdVar[2].lStdVariable;

    dwOut = 0;

    BITCLR_BARCODE(pOEM->fGeneral2);
    for (dwIn = 0; dwIn < pFInv->dwCount;)
    {
        if (pubCmd[dwIn] == '#')
        {
            //** set width & height of scalable font for Japanese font **
            if (pubCmd[dwIn+1] == 'A')
            {
                DWORD   dwWidth, dwHeight;
                // pOEM->FontH_DOT(unit:dot) for TextMode clipping
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                // dwHeight(unit:cpt) for RPDL command parameter
                dwHeight = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);

                if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                  dwWidth = dwUFO_FontW * 2;
                    dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                else
                    dwWidth = dwUFO_FontW;
                dwWidth *= DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT;

//              VERBOSE(("[OEMSCALABLEFONT] w=%d,h=%d(%ddot)\n",
//                      (WORD)dwWidth, (WORD)dwHeight, pOEM->FontH_DOT));

// @Jun/25/98 ->
                // If width is slightly different to height, we suppose they are same.
                if ((lTmp = dwHeight - dwWidth) != 0)
                {
                    if (lTmp < 0)
                        lTmp = -lTmp;
                    if ((DWORD)lTmp < dwHeight / 25)    // 1/25 = 4%
                        dwWidth = dwHeight;
                }
// @Jun/25/98 <-

                // Use 10pt-size raster font at SP4mkII,5,8(7),8(7)mkII
                if (TEST_GRP_240DPI(pOEM->fModel) && dwWidth == dwHeight &&
                    dwWidth >= NEAR10PT_MIN && dwWidth <= NEAR10PT_MAX)
                {
                    dwWidth = dwHeight = 960;   // unit:cpt(centi point)
                }
                pOEM->dwFontW_CPT = dwWidth;
                pOEM->dwFontH_CPT = dwHeight;
// @Jan/29/99 ->
                // If width equals to height, we emit height parameter only.
                // (This is applied to after SP9II because we want to avoid testing
                //  at too old models.)
                if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
                    dwOut += sprintf(&aubCmd[dwOut], ",%ld", dwHeight);
                else
// @Jan/29/99 <-
                    dwOut += sprintf(&aubCmd[dwOut], "%ld,%ld", dwWidth, dwHeight);
                dwIn += 2;
            } // 'if 'A'' end

            //** set width & height of scalable font for IBM ext font **
            else if (pubCmd[dwIn+1] == 'B')
            {
// @Jan/29/99 ->
                if (TEST_AFTER_SP9II(pOEM->fModel) && pOEM->dwFontW_CPT == pOEM->dwFontH_CPT)
                    dwOut += sprintf(&aubCmd[dwOut], ",%ld", pOEM->dwFontH_CPT);
                else
// @Jan/29/99 <-
                    dwOut += sprintf(&aubCmd[dwOut], "%ld,%ld",
                                     pOEM->dwFontW_CPT, pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'B'' end

            // Set flag for barcode
            else if (pubCmd[dwIn+1] == 'C')
            {
                switch (pubCmd[dwIn+2])
                {
                  case '0':     // JAN(STANDARD)
                    pOEM->nBarMaxLen = 13 + 1;          goto _BARCODE_READY;

                  case '1':     // JAN(SHORT)
                    pOEM->nBarMaxLen = 8 + 1;           goto _BARCODE_READY;
// @Dec/07/99 FK#50 ->
                  case '7':     // CUSTOMER
                    pOEM->nBarMaxLen = 20 + 1;          goto _BARCODE_READY;
                  case '9':     // UPC(A)
                    pOEM->nBarMaxLen = 12 + 1;          goto _BARCODE_READY;
                  case 'A':     // UPC(A)
                    pOEM->nBarMaxLen = 8 + 1;           goto _BARCODE_READY;
                  case '8':     // CODE128
// @Dec/07/99 FK#50 <-
                  case '2':     // 2of5(INDUSTRIAL)
                  case '3':     // 2of5(MATRIX)
                  case '4':     // 2of5(ITF)
                  case '5':     // CODE39
                  case '6':     // NW-7
                    pOEM->nBarMaxLen = BARCODE_MAX;
                  _BARCODE_READY:
                    BITSET32(pOEM->fGeneral2, BARCODE_MODE_IN);
                    pOEM->dwBarRatioW = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
// @Dec/17/99 FK#50 ->
//                  pOEM->nBarType = pubCmd[dwIn+2] - '0';
                    if (pubCmd[dwIn+2] < 'A')
                        pOEM->nBarType = pubCmd[dwIn+2] - '0';
                    else
                        pOEM->nBarType = pubCmd[dwIn+2] - 'A' + 10;
// @Dec/17/99 FK#50 <-
                    pOEM->RPDLHeapCount = 0;
                    VERBOSE(("** BARCODE(1) ratio=%d **\n",pOEM->dwBarRatioW));
                    break;

                  default:
                    break;
                }
                dwIn += 3;
            } // 'if 'C'' end

            //** set width of scalable font **
            else if (pubCmd[dwIn+1] == 'W')
            {
// MSKK Jul/23/98 ->
//              if (dwUFO_FontW > 0)
                if (dwUFO_FontW > 0 || dwUFO_FontMaxW > 0)
// MSKK Jul/23/98 <-
                {
                    DWORD dwWidth;
    
                    if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                      dwWidth = dwUFO_FontW * 2;
                        dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                    else
                        dwWidth = dwUFO_FontW;
                    pOEM->dwFontW_CPT = dwWidth * (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                    dwOut += sprintf(&aubCmd[dwOut], "%ld", pOEM->dwFontW_CPT);
                }
                dwIn += 2;
            } // 'if 'W'' end

            //** set height of scalable font (include Japanese proportional font) **
            else if (pubCmd[dwIn+1] == 'H')
            {
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                pOEM->dwFontH_CPT = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                dwOut += sprintf(&aubCmd[dwOut], "%ld", pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'H'' end

            //** set font pitch (Horizontal-Motion-Index) **
            else if (pubCmd[dwIn+1] == 'P')
            {
                SHORT nTmp1, nTmp2;

                switch (pubCmd[dwIn+2])     // modify(add Arial,Century,etc)
                {
                  case 'D':     // DBCS (Japanese font ZENKAKU)
//95/NT4            nTmp1 = lpFont->dfAvgWidth * 2;
// MSKK 1/25/98     nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2 * 2;
// MSKK Jul/23/98   nTmp1 = (SHORT)dwUFO_FontW * 2;
                    nTmp1 = (SHORT)dwUFO_FontMaxW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    VERBOSE(("** FontMaxW=%d dot **\n", nTmp1));
// @Aug/10/98       nTmp1 = (nTmp1 / 2 + 1) * 2;    // bigger even  @Jan/30/98
                    break;

                  case 'S':     // SBCS (Japanese font HANKAKU)
// RPDL pitch setting command of HANKAKU is EFFECTIVE to SPACE.
// OBSOLETE @Mar/26/99 ->
//// @Jan/29/99 ->
//                  // RPDL pitch setting command of HANKAKU is not effective, so
//                  // do not emit this. (We may not delete this string in UFM.)
//                  if (dwOut >= 4 && aubCmd[dwOut-4] == '\x1B' && aubCmd[dwOut-3] == 'N')
//                  {
//                      dwIn  += 3; // count up input '#PS'
//                      dwOut -= 4; // delete previous output '\x1BN\x1B\x1F'
//                      continue;   // goto for loop-end
//                  }
//                  else    // Maybe none comes here.
// @Jan/29/99 <-
// @Mar/26/99 <-
                    {
//95/NT4                nTmp1 = lpFont->dfAvgWidth;
// NSKK 1/25/98         nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2;
                        nTmp1 = (SHORT)dwUFO_FontW;
                        nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                        VERBOSE(("** FontW=%d dot **\n", nTmp1));
// @Aug/10/98           nTmp1++;                        // 1dot bigger  @Jan/30/98
                    }
                    break;

                  case '1':     // SBCS (BoldFacePS)
                  case '2':     // SBCS (Arial)
                  case '3':     // SBCS (Century)
                    nTmp1 = (SHORT)(dwUFO_FontH * 3L / 10L);        // * 0.3
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '4':     // SBCS (TimesNewRoman)
                    nTmp1 = (SHORT)(dwUFO_FontH * 27L / 100L);      // * 0.27
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '5':     // SBCS (Symbol)
                    nTmp1 = (SHORT)dwUFO_FontH / 4;                 // * 0.25
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '6':     // SBCS (Wingding)
                    nTmp1 = (SHORT)dwUFO_FontH;                     // * 1
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '7':     // DBCS (Japanese proportional font HANKAKU)
                    nTmp1 = (SHORT)(dwUFO_FontH * 78L / 256L);
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;
// OBSOLETE @Mar/26/99 ->
//                case '8':     // DBCS (Japanese proportional font ZENKAKU)
//                  nTmp1 = (SHORT)(dwUFO_FontH * 170L / 256L);
//                  nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
//                  break;
// @Mar/26/99 <-
                  default:      // SBCS (Courier,LetterGothic,PrestigeElite)
//95/NT4            nTmp1 = lpFont->dfPixWidth;
                    nTmp1 = (SHORT)dwUFO_FontW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    dwIn --;
                    break;
                }

                if (nTmp1 >= 0x7E)
                {
                    aubCmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // PRINTER SIDE ISSUE: RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    aubCmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    aubCmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 3;
            } // 'if 'P'' end

            //** set Vertical-Motion-Index to draw combined font('^'+'A',etc). **
            //** (Courier,LetterGothic,PrestigeElite,BoldFacePS)               **
            else if (pubCmd[dwIn+1] == 'V')
            {
                SHORT nTmp1, nTmp2;
    
                // Set 1/3 height (adequate value to move vertically)
                nTmp1 = (SHORT)dwUFO_FontH / 3;
                nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);
                if (nTmp1 >= 0x7E)
                {
                    aubCmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // PRINTER SIDE ISSUE: RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    aubCmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    aubCmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 2;
            } // 'if 'V'' end
        } // 'if '#'' end
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    } // 'for (dwIn = 0; dwIn < pFInv->dwCount;)' end

//  VERBOSE(("dwOut = %d\n", dwOut)); // MSKK 1/24/98

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

} //*** OEMSendFontCmd


static BYTE IsDBCSLeadByteRPDL(BYTE Ch)
{
    return ShiftJisRPDL[Ch];
}

static BYTE IsDifferentPRNFONT(BYTE Ch)
{
    return VerticalFontCheck[Ch];
}

//---------------------------*[LOCAL] DrawTOMBO*-------------------------------
// Action:
//  (a) INIT_TOMBO: calculate offset in printing. (BaseOffset will be changed)
//  (b) DRAW_TOMBO: drawing TOMBO.
// Setp/14/98
//-----------------------------------------------------------------------------
static VOID DrawTOMBO(
    PDEVOBJ pdevobj,
    SHORT action)
{
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
    POINT   P0;
    POINT   PaperSizeDoc, PaperSizeUse;
    BYTE    Cmd[256];         // build command here
    INT     ocmd = 0;
    LONG    lLen3, lLen10, lLen13, lWidth0_1, lSav, lTmp;
    SHORT   nPaperUse;

    switch (pOEM->DocPaperID)
    {
      case RPDL_A3:
        nPaperUse = RPDL_B3;    break;
      case RPDL_B4:
        nPaperUse = RPDL_A3;    break;
      case RPDL_A4:
        nPaperUse = RPDL_B4;    break;
      case RPDL_A5:
      case RPDL_A6:
      case RPDL_POSTCARD:
      case RPDL_B5:
      case RPDL_B6:
        nPaperUse = RPDL_A4;    break;
      default:
        return;     // draw nothing
    }

    // Set acutual printed paper size & document paper size
    PaperSizeUse = RPDLPageSizeE2E[nPaperUse];
    PaperSizeDoc = RPDLPageSizeE2E[pOEM->DocPaperID];

    // Orientation?
    if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
    {
        lTmp = PaperSizeUse.x;   // swap x-y
        PaperSizeUse.x = PaperSizeUse.y;
        PaperSizeUse.y = lTmp;
        lTmp = PaperSizeDoc.x;
        PaperSizeDoc.x = PaperSizeDoc.y;
        PaperSizeDoc.y = lTmp;
    }

    // upper-left TOMBO
    P0.x = (PaperSizeUse.x - PaperSizeDoc.x) / 2 / pOEM->nResoRatio;
    P0.y = (PaperSizeUse.y - PaperSizeDoc.y) / 2 / pOEM->nResoRatio;

    //   If action is INIT_TOMBO, set BaseOffset and return
    if (INIT_TOMBO == action)
    {
        LONG lUnprintable = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?
                            0 : 240L / pOEM->nResoRatio;    // 240masterunit at GPD
        pOEM->BaseOffset.x += P0.x + lUnprintable;
        pOEM->BaseOffset.y += P0.y + lUnprintable;
        return;     // exit
    }

    lSav = P0.x;    // save left P0.x
    lLen3  =  3L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 3mm
    lLen10 = 10L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 10mm
    lLen13 = 13L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 13mm
    lWidth0_1 = (LONG)MASTERUNIT / 254L / pOEM->nResoRatio;            // 0.1mm
    if (lWidth0_1 < 1)
        lWidth0_1 = 1;
    else if (lWidth0_1 >= 2)
        lWidth0_1 = lWidth0_1 / 2 * 2 + 1;      // make it odd

    ocmd = sprintf(Cmd, ENTER_VECTOR);          // enter VectorMode
    ocmd += sprintf(&Cmd[ocmd], PEN_WIDTH, lWidth0_1);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, -lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y - lLen13,
                    0, lLen13, -lLen10, 0);

    // upper-right TOMBO
    // Add horizontal distance and adjustment (PaperSizeDoc.x:masterunit, AdjX:0.1mm unit)
    P0.x += (PaperSizeDoc.x + (LONG)pOEMExtra->nUiTomboAdjX * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y - lLen13,
                    0, lLen13, lLen10, 0);

    // lower-left TOMBO
    lTmp = P0.x;
    P0.x = lSav;    // restore left P0.x
    lSav = lTmp;    // save right P0.x
    // Add vertical distance and adjustment (PaperSizeDoc.y:masterunit, AdjY:0.1mm unit)
    P0.y += (PaperSizeDoc.y + (LONG)pOEMExtra->nUiTomboAdjY * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, -lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y + lLen13,
                    0, -lLen13, -lLen10, 0);

    // lower-right TOMBO
    P0.x = lSav;    // restore right P0.x
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y + lLen13,
                    0, -lLen13, lLen10, 0);
    ocmd += sprintf(&Cmd[ocmd], EXIT_VECTOR);   // exit VectorMode
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
} // *** DrawTOMBO

//---------------------------*[LOCAL] AssignIBMfont*---------------------------
// Action:
//  (a) IBMFONT_ENABLE_ALL: assign IBM extended characters to block#1 where
//       JIS1 characters used to be assigned.
//  (b) IBMFONT_RESUME: resume (re-assign IBM extended characters to block#4.
//      block#4 is insufficient for all 388 IBM characters.)
//-----------------------------------------------------------------------------
static VOID AssignIBMfont(
    PDEVOBJ pdevobj,
    SHORT   rcID,
    SHORT   action)
{
    BYTE    Cmd[56];          // build command here
    INT     ocmd = 0;
    WORD    num;
    WORD    fHeightParamOnly;                   // @Jan/29/99
    DWORD   dwWidth, dwHeight;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);      // @Oct/06/98

    switch (rcID)
    {
      case MINCHO_1:      case MINCHO_1+1:      // horizontal font: vertical font:
      case MINCHO_B1:     case MINCHO_B1+1:
      case MINCHO_E1:     case MINCHO_E1+1:
      case GOTHIC_B1:     case GOTHIC_B1+1:
      case GOTHIC_M1:     case GOTHIC_M1+1:
      case GOTHIC_E1:     case GOTHIC_E1+1:
      case MARUGOTHIC_B1: case MARUGOTHIC_B1+1:
      case MARUGOTHIC_M1: case MARUGOTHIC_M1+1:
      case MARUGOTHIC_L1: case MARUGOTHIC_L1+1:
      case GYOSHO_1:      case GYOSHO_1+1:
      case KAISHO_1:      case KAISHO_1+1:
      case KYOKASHO_1:    case KYOKASHO_1+1:
        num = (rcID - MINCHO_1) / 2;
        goto _SET_W_H;

      case MINCHO_3:      case MINCHO_3+1:    // for NX-100
        num = 0;
        goto _SET_W_H;
      case GOTHIC_B3:     case GOTHIC_B3+1:
        num = 3;
      _SET_W_H:
        dwWidth  = pOEM->dwFontW_CPT;
        dwHeight = pOEM->dwFontH_CPT;
        break;

      case MINCHO10_RAS:  case MINCHO10_RAS+1:
        num = 0;                    // same to MINCHO_1
        dwWidth = dwHeight = 960;   // unit:cpt(centi point)
        break;

      default:
        return; // exit AssignIBMfont()
    }
    
// @Jan/29/99 ->
    // If width equals to height, we emit height parameter only.
    // (This is applied to only NX-100 here.)
    if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
        fHeightParamOnly = TRUE;
    else
        fHeightParamOnly = FALSE;
// @Jan/29/99 <-

    if (IBMFONT_RESUME == action)
    {
        // Resume JIS1 characters block where they used to be. (JIS1 -> block#1)
// @Jan/29/99 ->
        if (fHeightParamOnly)
            ocmd = sprintf(Cmd, SET_JIS_FONT_SCALE_H_ONLY, dwHeight);
        else
// @Jan/29/99 <-
            ocmd = sprintf(Cmd, SET_JIS_FONT_SCALE, dwWidth, dwHeight);
        ocmd += sprintf(&Cmd[ocmd], SET_JIS_FONT_NAME[num]);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

    // Assign IBM extended characters to block.
// @Jan/29/99 ->
    if (fHeightParamOnly)
        ocmd = sprintf(Cmd, SET_IBM_FONT_SCALE_H_ONLY, action, dwHeight);
    else
// @Jan/29/99 <-
        ocmd = sprintf(Cmd, SET_IBM_FONT_SCALE, action, dwWidth, dwHeight);
    ocmd += sprintf(&Cmd[ocmd], SET_IBM_FONT_NAME[num]);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    return;
} //*** AssignIBMfont


//---------------------------*[LOCAL] SendFaxNum*------------------------------
// Action: send fax number
// (Use fax data file @Sep/30/98, Use private devmode @Oct/15/98)
//-----------------------------------------------------------------------------
static VOID SendFaxNum(                                     // @Sep/17/98
    PDEVOBJ pdevobj)
{
    BYTE        Cmd[256], PreNumBuf[4+16], NumBuf[32+4];
    SHORT       PreNumLen, cnt, SrcLen, NumLen;
    INT         ocmd;
    LPSTR       lpSrc, lpDst;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);
    FILEDATA     FileData;  // <-pFileData (formerly use MemAllocZ) @Mar/17/2000

    FileData.fUiOption = 0;
    RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);

    // If previous fax is finished and hold-options flag isn't valid,
    // do nothing and return.
    // This prevents unexpected fax until user pushes Apply button on the
    // fax property sheet.
    if (BITTEST32(FileData.fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        VERBOSE(("** SendFaxNum: Exit without doing anything. **\n"));
        return;
    }

    // If not fax option ready, exit.
    if (!BITTEST32(pOEMExtra->fUiOption, FAX_SEND) || pOEMExtra->FaxNumBuf[0] == 0)
    {
        return;
    }

    // Set data_type(1:image, 2:RPDL command), compression (1:MH, 3:MMR),
    // simultaneous print avalilable, etc
    ocmd = sprintf(Cmd, BEGINFAX_HEAD,
                   BITTEST32(pOEMExtra->fUiOption, FAX_RPDLCMD)? 2 : 1,
                   BITTEST32(pOEMExtra->fUiOption, FAX_MH)? 1 : 3,
                   BITTEST32(pOEMExtra->fUiOption, FAX_SIMULPRINT)? 2 : 1);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Copy fax channel & extra number to pre_number buffer
    PreNumLen = (SHORT)sprintf(PreNumBuf, BEGINFAX_CH, pOEMExtra->FaxCh + 1);
    if (pOEMExtra->FaxExtNumBuf[0] != 0)
        PreNumLen += (SHORT)sprintf(&PreNumBuf[PreNumLen], BEGINFAX_EXTNUM, pOEMExtra->FaxExtNumBuf);

    // Search each fax number (directly set number & addressbook set number)
    lpSrc  = pOEMExtra->FaxNumBuf;  // fax number which is set directly
    SrcLen = FAXBUFSIZE256-1;       // FaxNumBuf limit = 255
    lpDst  = NumBuf;
    NumLen = 0;
    {
        while (SrcLen-- > 0 && *lpSrc != 0)
        {
            // If character is DBCS, skip.
            if (IsDBCSLeadByteRPDL(*lpSrc))
            {
                lpSrc++;
            }
            // If character is valid, input it to NumBuf.
            else if (*lpSrc >= '0' && *lpSrc <= '9' || *lpSrc == '-' || *lpSrc == '#')
            {
                *lpDst++ = *lpSrc;
                if (NumLen++ > 32)          // limit of MF-P
                {
                    return;                 // error exit
                }
            }
            // If character is ',' , output fax number.
            else if (*lpSrc == ',')
            {
                *lpDst = 0;
                // Send fax number
                if (NumLen > 0)
                {
                    WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
                    WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
                }
                lpDst = NumBuf;
                NumLen = 0;
            }
            lpSrc++;
        } // 'while (SrcLen-- > 0 && *lpSrc != 0)' end

        // Flush last fax number
        if (NumLen > 0)
        {
            WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
            WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
        }
    } // 'while (cnt-- > 0)' end

    // Get tickcount for ID
    cnt = (SHORT)(GetTickCount() / 1000L);
    cnt = ABS(cnt);
    // Input ID & resolution & send time, etc
    if (BITTEST32(pOEMExtra->fUiOption, FAX_SETTIME) && pOEMExtra->FaxSendTime[0] != 0)
        ocmd = sprintf(Cmd, BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 2, pOEMExtra->FaxSendTime);
    else
        ocmd = sprintf(Cmd, BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 1, "");
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Set PRINT_DONE flag in the file  @Oct/20/98
    FileData.fUiOption = pOEMExtra->fUiOption;
    BITSET32(FileData.fUiOption, PRINT_DONE);
    RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_WRITE);

    return;
} //*** SendFaxNum


#ifdef JISGTT
//-----------------------------*[LOCAL] jis2sjis*------------------------------
// Action: convert JIS code to SJIS code
//-----------------------------------------------------------------------------
static VOID jis2sjis(       // @Oct/27/98
    BYTE jis[],
    BYTE sjis[])
{
        BYTE            h, l;

        h = jis[0];
        l = jis[1];
        if (h == 0)
        {
            sjis[0] = l;
            sjis[1] = 0;
            return;
        }
        l += 0x1F;
        if (h & 0x01)
            h >>= 1;
        else
        {
            h >>= 1;
            l += 0x5E;
            h--;
        }
        if (l >= 0x7F)
            l++;
        if (h < 0x2F)
            h += 0x71;
        else
            h += 0xB1;
        sjis[0] = h;
        sjis[1] = l;
} //*** jis2sjis
#endif // JISGTT


VOID APIENTRY OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE aubBuff;              // <-BYTE aubBuff[256]  MSKK Aug/13/98
    PTRANSDATA pTrans;
#ifdef DBG_OUTPUTCHARSTR
    PWORD  pwUnicode;
#endif // DBG_OUTPUTCHARSTR
    DWORD  dwI;
    BYTE   Cmd[128];
    INT    ocmd = 0;            // INT<-SHORT  @Feb/22/99
    SHORT  rcID;
    WORD   fVertFont = FALSE, fEuroFont = FALSE, fIBMFontSupport = FALSE;
    WORD   fEuroFontFullset = FALSE;
#ifdef JISGTT
    WORD   fJisCode = FALSE;    // @Oct/27/98
#endif // JISGTT
    LPSTR  lpChar;
    BYTE   CharTmp1, CharTmp2;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
#ifdef DOWNLOADFONT
    SHORT   mov;
    WORD    wSerialNum;         // short->DWORD @Jun/30/98, DWORD->WORD @Aug/21/98
    LONG    lFontID, lGlyphID;  // @Aug/21/98
    LPFONTPOS lpDLFont;
#endif // DOWNLOADFONT
    DWORD   dwNeeded;
    WORD    fMemAllocated;      // @Sep/09/98

//  VERBOSE(("** OEMOutputCharStr() entry. **\n"));

    if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))  // add  @Dec/11/97
    {
        BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
    }

    //** flush Move_X,Y command saved at OEMCommandCallback
    if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        // Output Move_Y command here.
        ocmd = sprintf(Cmd, ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }
    if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        // Output Move_X command here.
        ocmd = sprintf(Cmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

//  VERBOSE(("dwType = %d\n", dwType)); // MKSKK 1/24/98

    switch (dwType)
    {
      case TYPE_GLYPHHANDLE:    // device font
// #333653: Change I/F for GETINFO_GLYPHSTRING // MSKK 5/17/99 {
        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        // Get the size of buffer for pGlyphOut.
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }
        if (pOEM->pRPDLHeap2K && GStr.dwGlyphOutSize <= HEAPSIZE2K)
        {
            aubBuff = pOEM->pRPDLHeap2K;
            fMemAllocated = FALSE;
        }
        else
        {
            if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
            {
                ERR(("aubBuff memory allocation failed.\n"));
                return;
            }
            fMemAllocated = TRUE;
        }
// } MSKK 5/17/99

#ifdef DBG_OUTPUTCHARSTR
        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }

        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            VERBOSE((("Unicode[%d] = %x\n"), dwI, pwUnicode[dwI]));
        }
#endif // DBG_OUTPUTCHARSTR

#ifdef DOWNLOADFONT
    // If moving value of download font remain
    if (pOEM->nCharPosMoveX)
    {
        // Flush moving value of pre-printed download font.
        if (pOEM->nCharPosMoveX > 0)
            ocmd = sprintf(Cmd, ESC_XM_REL, pOEM->nCharPosMoveX);
        else
            ocmd = sprintf(Cmd, ESC_XM_RELLEFT, -pOEM->nCharPosMoveX);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);

        // Clear moving value
        pOEM->nCharPosMoveX = 0;
    } // 'if (nCharPosMoveX)' end
#endif // DOWNLOADFONT

        //
        // Call the Unidriver service routine to convert
        // glyph-handles into the character code data.
        //

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }

        pTrans = (PTRANSDATA)aubBuff;

//** Draw barcode **
// fix bug with Excel @Nov/24/98
        if (BITTEST32(pOEM->fGeneral2, BARCODE_MODE_IN))
        {
            WORD    unit1, unit2, offset_y;
            WORD    fCheckdigitCapable, fSetBarWidth, fJANDecrease1Char;
            WORD    fCode128;           // @Feb/08/2000
            LPSTR   lpDst, lpCmd;
            PTRANSDATA pTransTmp;       // @Nov/24/98
            WORD    wLen, wTmp;

            ocmd = 0;
            // Check start character
            wTmp = wLen = (WORD)dwCount;
            pTransTmp = pTrans;
            while (wTmp-- > 0)
            {
                if (pTransTmp->uCode.ubCode == '[')
                {
                    // barcode character is valid from now
                    BITSET32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                    BITCLR32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT90);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount = 0;
                    wLen   = wTmp;
                    pTrans = pTransTmp+1;
#ifdef DEBUG
                    for (wTmp = 0; wTmp < BARCODE_MAX; wTmp++)
                        pOEM->RPDLHeap64[wTmp] = 0;
#endif // DEBUG
                    break;
                }
                pTransTmp++;
            }

            // Check barcode character length
            VERBOSE(("** BARCODE(2.2) len=%d **\n",wLen));
            fJANDecrease1Char = FALSE;
            if (wLen > (wTmp = pOEM->nBarMaxLen - pOEM->RPDLHeapCount))
            {
                wLen = wTmp;
                BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                VERBOSE(("** BARCODE(3) limit len=%d(last=%c) **\n", wLen,
                         (pTrans+wLen-1)->uCode.ubCode));
                // Decrease RPDLHeapCount later at JAN
                if (pOEM->nBarType == BAR_TYPE_JAN_STD || pOEM->nBarType == BAR_TYPE_JAN_SHORT)
                    fJANDecrease1Char = TRUE;
            }

            // Copy barcode characters to RPDLHeap64 (temporary buffer)
            lpDst = &pOEM->RPDLHeap64[pOEM->RPDLHeapCount];
            fCheckdigitCapable = TEST_AFTER_SP8(pOEM->fModel)? TRUE : FALSE;
            while (wLen-- > 0)
            {
                // Check checkdigit-on-flag-character(?) in pTrans->uCode.ubCode
                if (pTrans->uCode.ubCode == '?' && fCheckdigitCapable)
                {
                    BITSET32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    pTrans++;
                    continue;
                }
                // Check end character
                if (pTrans->uCode.ubCode == ']')
                {
                    VERBOSE(("** BARCODE(4) terminator **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                    break;
                }
                *lpDst++ = pTrans->uCode.ubCode;
                pTrans++;
                pOEM->RPDLHeapCount++;
            }
            VERBOSE(("** BARCODE(5) copy-end BarNum=%d **\n", pOEM->RPDLHeapCount));
            VERBOSE(("   [%s]\n",pOEM->RPDLHeap64));
            VERBOSE(("   CHK = %d\n", BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON)));

            // Finish
            if (BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID) &&
                BITTEST32(pOEM->fGeneral2, BARCODE_FINISH))
            {
                VERBOSE(("** BARCODE(6) finish [%s] **\n", pOEM->RPDLHeap64));
                // 1 barcode has been completed here
                BITCLR32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                BITCLR32(pOEM->fGeneral2, BARCODE_FINISH);

                ocmd = sprintf(Cmd, ENTER_VECTOR);    // enter VectorMode

                // Add checkdigit
                if (BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_CHECKDIGIT);
                }

                // Check barcode-height
                if (pOEMExtra->UiBarHeight == 0)
                {
                    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;     // default (=10mm)
                }
                else if (pOEMExtra->UiBarHeight != BAR_H_DEFAULT)
                {
                    // Set barcode-height (convert unit from mm to dot)  (SISHAGONYU)
                    unit1 = (WORD)(((DWORD)pOEMExtra->UiBarHeight * (DWORD)(MASTERUNIT*10)
                            / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
                    VERBOSE(("** BARCODE(7) set height %d **\n", unit1));
                    ocmd += sprintf(&Cmd[ocmd], BAR_H_SET, unit1);
                }

                if (BITTEST32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT))
                {
                    // Disable printing font under barcode
                    ocmd += sprintf(&Cmd[ocmd], BAR_NOFONT[pOEM->nBarType]);
                    // Set guard-bar-height of JAN
                    if ((pOEM->nBarType == BAR_TYPE_JAN_STD || pOEM->nBarType == BAR_TYPE_JAN_SHORT) &&
                        !TEST_AFTER_SP8(pOEM->fModel))
                    {
                        offset_y = 2;
                    }
                    else    // no guard-bar
                    {
                        offset_y = 0;
                    }
                }
                else
                {
                    offset_y = 3;   // font-height = 3mm
                }
// @Dec/8/99 FK#50 ->
                if (pOEM->nBarType == BAR_TYPE_CUSTOMER)
                {
                    // calculate vertical offset (barcode-height)
                    offset_y = (WORD)(((DWORD)(BAR_H_CUSTOMER)      // 36 x 0.1mm
                               * (DWORD)MASTERUNIT
                               / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
                }
                else
                {
// @Dec/8/99 FK#50 <-
                // Calculate vertical offset (barcode-height + font-height)
                    offset_y = (WORD)(((DWORD)(pOEMExtra->UiBarHeight + offset_y)
                               * (DWORD)(MASTERUNIT*10)
                               / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
// @Dec/8/99 FK#50 ->
                }
// @Dec/8/99 FK#50 <-

                // Check vertical-flag-character('@') in RPDLHeap64
                VERBOSE(("** BARCODE(7-1) vertical check len=%d(%c..%c) **\n",
                        pOEM->RPDLHeapCount, pOEM->RPDLHeap64[0],
                        pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] ));
                // If characters are "@...", vertical(ROT270) barcode
                if (pOEM->RPDLHeap64[0] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT270) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount--;
                }
                // If characters are "...@", vertical(ROT90) barcode
                else if (pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT90) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT90);
                    pOEM->RPDLHeapCount--;
                }
                // 1 charcter margin for '@' at JAN, we decrease here.
                else if (fJANDecrease1Char)
                {
                    pOEM->RPDLHeapCount--;
                }

                // Set barcode draw position
                if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270) &&
                    !TEST_NIN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_ROT270);
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.y,
                                    pOEM->PageMax.x - pOEM->TextCurPos.x - offset_y);
                }
                else if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT90) &&
                         !TEST_4IN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_ROT90);
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->PageMax.y - pOEM->TextCurPos.y,
                                    pOEM->TextCurPos.x - offset_y);
                }
                else
                {
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.x,
                                    pOEM->TextCurPos.y - offset_y);
                }

                // Check whether setting barcode-width or not.
                // (Scaling is valid when 5pt<=fontsize<9pt or fontsize>11pt)
                if ((pOEM->dwBarRatioW >= BAR_W_MIN_5PT &&
                    pOEM->dwBarRatioW < NEAR10PT_MIN) ||
                    pOEM->dwBarRatioW > NEAR10PT_MAX)
                {
                    fSetBarWidth = TRUE;
                }
                else
                {
                    fSetBarWidth = FALSE;
                }

                fCode128 = 0;           // @Feb/08/2000
                switch (pOEM->nBarType)
                {
                  case BAR_TYPE_JAN_STD:        // 0:JAN(STANDARD)
                  case BAR_TYPE_JAN_SHORT:      // 1:JAN(SHORT)
                  case BAR_TYPE_UPC_A:          // 9:UPC(A) @Dec/17/99 FK#50
                  case BAR_TYPE_UPC_E:          // 10:UPC(E) @Dec/17/99 FK#50
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)BAR_UNIT_JAN * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d **\n", unit1));
                        ocmd += sprintf(&Cmd[ocmd], BAR_W_SET_JAN, unit1);
                    }
                    // Output barcode command
                    ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType]);
                    break;

                  case BAR_TYPE_2OF5IND:        // 2:2of5(INDUSTRIAL)
                  case BAR_TYPE_2OF5MTX:        // 3:2of5(MATRIX)
                  case BAR_TYPE_2OF5ITF:        // 4:2of5(ITF)
                    lpCmd = BAR_W_SET_2OF5;
                    goto _BARCODE_CMD_OUT1;
                  case BAR_TYPE_CODE39:         // 5:CODE39
                    lpCmd = BAR_W_SET_C39;
// @Dec/17/99 FK#50 ->
                    goto _BARCODE_CMD_OUT1;
                  case BAR_TYPE_CODE128:        // 8:CODE128
                    lpCmd = BAR_W_SET_C39;
                    fCode128 = 1;
// @Dec/17/99 FK#50 <-
                  _BARCODE_CMD_OUT1:
                    // Set standard size of module unit  (1/1000mm_unit)
                    unit1 = BAR_UNIT1_2OF5;
                    unit2 = BAR_UNIT2_2OF5;
                    goto _BARCODE_CMD_OUT2;

                  case BAR_TYPE_NW7:            // 6:NW-7
                    lpCmd = BAR_W_SET_NW7;
                    // Set standard size of module unit
                    unit1 = BAR_UNIT1_NW7;
                    unit2 = BAR_UNIT2_NW7;
                  _BARCODE_CMD_OUT2:
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)unit1 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        unit2 = (WORD)(((DWORD)unit2 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d,%d **\n", unit1,unit2));
                        ocmd += sprintf(&Cmd[ocmd], lpCmd);
                        ocmd += sprintf(&Cmd[ocmd], BAR_W_PARAMS, unit1, unit1,
                                        unit2, unit2, unit1);
                    }
                    // Output barcode command(operand) & character#
// @Dec/17/99 FK#50 ->
//                  ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType],
//                                  pOEM->RPDLHeapCount);
                    ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType],
                                    pOEM->RPDLHeapCount + fCode128);
// @Dec/17/99 FK#50 <-
                    break;

// @Dec/07/99 FK#50 ->
                  case BAR_TYPE_CUSTOMER:       // 7:CUSTOMER
                    lpCmd = BAR_W_SET_CUST;
                    ocmd += sprintf(&Cmd[ocmd], lpCmd);
                    unit1 = (WORD)(((pOEM->dwBarRatioW / 10) + 4) / 5) * 5 ;
                    if ((unit1 >= 80) && (unit1 <= 115))
                    {
                        ocmd += sprintf(&Cmd[ocmd], "%d", unit1);
                    }
                    // output barcode command(operand) & character#
                    ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType],
                                                        pOEM->RPDLHeapCount);
                    break;
// @Dec/07/99 FK#50 <-

                  default:
                    break;
                }

                WRITESPOOLBUF(pdevobj, Cmd, ocmd);

// @Dec/17/99 FK#50 ->
                // Code128 data format ",xx,xx,..."
                if (pOEM->nBarType == BAR_TYPE_CODE128)
                {
                    INT   len, cnt;
                    BYTE  Code128Buf[8];
                    LPSTR lpTemp;

                    lpTemp = pOEM->RPDLHeap64;
                    if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270))
                        lpTemp++;
                    // send start char
                    len = sprintf(Code128Buf,",%d",(BYTE)BAR_CODE128_START);
                    WRITESPOOLBUF(pdevobj, Code128Buf, len);
                    for (cnt = 0; cnt < (int)pOEM->RPDLHeapCount; cnt++)
                    {
                        len = sprintf(Code128Buf,",%d",(BYTE)(lpTemp[cnt]-32));
                        WRITESPOOLBUF(pdevobj, Code128Buf, len);
                    }
                }
                else
                {
// @Dec/17/99 FK#50 <-
                    // Output barcode characters
                    if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270))     // @Oct/22/97
                        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64+1, pOEM->RPDLHeapCount);
                    else
                        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
// @Dec/17/99 FK#50 ->
                }
// @Dec/17/99 FK#50 <-

                pOEM->RPDLHeapCount = 0;
                // We add ';' for safe finish in case of insufficient character at JAN.
                ocmd = sprintf(Cmd, TERMINATOR);
                ocmd += sprintf(&Cmd[ocmd], EXIT_VECTOR); // exit VectorMode
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            } // 'if BARCODE_DATA_VALID && BARCODE_FINISH' end

            if(fMemAllocated)
                MemFree(aubBuff);

            return;
        }
//** Draw barcode END **

//** Draw device font **
        BITCLR32(pOEM->fGeneral1, FONT_VERTICAL_ON);
        rcID = (SHORT)pUFObj->ulFontID;

        if (rcID >= JPN_FNT_FIRST && rcID <= JPN_FNT_LAST)
        {
            if (TEST_VERTICALFONT(rcID))
            {
                fVertFont = TRUE;   // vertical font
                BITSET32(pOEM->fGeneral1, FONT_VERTICAL_ON);
            }
            // IBM ext char(SJIS) supported from SP9II
            if (rcID >= AFTER_SP9II_FNT_FIRST)
                fIBMFontSupport = TRUE;
// @Oct/27/98 ->
#ifdef JISGTT
            // Current UFM of PMincho & PGothic declare JIS code set.
            if (rcID >= JPN_MSPFNT_FIRST)
                fJisCode = TRUE;
#endif // JISGTT
// @Oct/27/98 <-
        }
        else if (rcID >= EURO_FNT_FIRST && rcID <= EURO_FNT_LAST)
        {
            fEuroFont = TRUE; // European font(Courier,BoldFacePS,etc).
            // Fullset(0x20-0xFF) fonts(Arial,Century,TimesNewRoman,etc) are supported
            // from NX-110
            if (rcID >= EURO_MSFNT_FIRST)
                fEuroFontFullset = TRUE;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans ++)     // increment pTrans  MSKK 98/3/16
        {
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
              case MTYPE_DIRECT:    // SBCS (European font & Japanese font HANKAkU)
//              VERBOSE((("TYPE_TRANSDATA:ubCode:0x%x\n"), pTrans->uCode.ubCode));

                lpChar = &pTrans->uCode.ubCode;
                CharTmp1 = *lpChar;

                if (fEuroFont)  //** European font  **
                {
                    // ** print 1st SBCS font(0x20-0x7F) **
                    if (CharTmp1 < 0x80)
                    {
                        // PRINTER SIDE ISSUE: RPDL
                        // take care of device font bug
                        if (rcID == SYMBOL && CharTmp1 == 0x60)     // "radical extention"
                        {
                            WRITESPOOLBUF(pdevobj, DOUBLE_SPACE, sizeof(DOUBLE_SPACE)-1);
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                            WRITESPOOLBUF(pdevobj, DOUBLE_BS, sizeof(DOUBLE_BS)-1);
                        }
                        else
                        {
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        }
                        continue;       // goto for-loop end
                    }


                    // ** print 2nd SBCS font(0x80-0xFF) **
                    // If full-set(0x20-0xFF) font
                    if (fEuroFontFullset)
                    {
                        // If same to DBCS 1st byte
                        if (IsDBCSLeadByteRPDL(CharTmp1))
                            WRITESPOOLBUF(pdevobj, ESC_CTRLCODE, sizeof(ESC_CTRLCODE)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        continue;       // goto for-loop end
                    }

                    // If not full-set font
                    switch (CharTmp1)
                    {
                      case 0x82:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0x88:
                        CharTmp1 = '^';     goto _WRITE1BYTE;
                      case 0x8B:
                        CharTmp1 = '<';     goto _WRITE1BYTE;
                      case 0x9B:
                        CharTmp1 = '>';     goto _WRITE1BYTE;
                      case 0x91:        // single quatation
                      case 0x92:
                        CharTmp1 = 0x27;    goto _WRITE1BYTE;
                      case 0x93:        // double quatation
                      case 0x94:
                        CharTmp1 = 0x22;    goto _WRITE1BYTE;
                      case 0x96:
                      case 0x97:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0x98:
                        CharTmp1 = '~';     goto _WRITE1BYTE;
                      case 0xA6:
                        CharTmp1 = '|';     goto _WRITE1BYTE;
                      case 0xAD:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0xB8:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0xD7:
                        CharTmp1 = 'x';     goto _WRITE1BYTE;

                      case 0x83:
                        CharTmp1 = 0xBF;    goto _WRITE1BYTE;
                      case 0x86:
                        CharTmp1 = 0xA8;    goto _WRITE1BYTE;
                      case 0x99:
                        CharTmp1 = 0xA9;    goto _WRITE1BYTE;
                      case 0xE7:
                        CharTmp1 = 0xA2;    goto _WRITE1BYTE;
                      case 0xE8:
                        CharTmp1 = 0xBD;    goto _WRITE1BYTE;
                      case 0xE9:
                        CharTmp1 = 0xBB;    goto _WRITE1BYTE;
                      case 0xF9:
                        CharTmp1 = 0xBC;    goto _WRITE1BYTE;
                      case 0xFC:
                        CharTmp1 = 0xFD;    goto _WRITE1BYTE;

                      case 0xA0:
                      case 0xA3:
                      case 0xA4:
                        goto _WRITE1BYTE;

                      case 0xA2:
                        CharTmp1 = 0xDE;    goto _WRITE1BYTE;
                      case 0xA5:        //YEN mark
                        CharTmp1 = 0xCC;    goto _WRITE1BYTE;
                      case 0xA7:
                        CharTmp1 = 0xC0;    goto _WRITE1BYTE;
                      case 0xA8:
                        CharTmp1 = 0xBE;    goto _WRITE1BYTE;
                      case 0xA9:
                        CharTmp1 = 0xAB;    goto _WRITE1BYTE;
                      case 0xAE:
                        CharTmp1 = 0xAA;    goto _WRITE1BYTE;
                      case 0xAF:
                        CharTmp1 = 0xB0;    goto _WRITE1BYTE;
                      case 0xB0:
                      case 0xBA:
                        CharTmp1 = 0xA6;    goto _WRITE1BYTE;
                      case 0xB4:
                        CharTmp1 = 0xA7;    goto _WRITE1BYTE;
                      case 0xB5:
                        CharTmp1 = 0xA5;    goto _WRITE1BYTE;
                      case 0xB6:
                        CharTmp1 = 0xAF;    goto _WRITE1BYTE;
                      case 0xBC:
                        CharTmp1 = 0xAC;    goto _WRITE1BYTE;
                      case 0xBD:
                        CharTmp1 = 0xAE;    goto _WRITE1BYTE;
                      case 0xBE:
                        CharTmp1 = 0xAD;    goto _WRITE1BYTE;
                      case 0xC4:
                        CharTmp1 = 0xDB;    goto _WRITE1BYTE;
                      case 0xC5:
                        CharTmp1 = 0xD6;    goto _WRITE1BYTE;
                      case 0xC9:
                        CharTmp1 = 0xB8;    goto _WRITE1BYTE;
                      case 0xD6:
                        CharTmp1 = 0xDC;    goto _WRITE1BYTE;
                      case 0xDC:
                        CharTmp1 = 0xDD;    goto _WRITE1BYTE;
                      case 0xDF:
                        CharTmp1 = 0xFE;    goto _WRITE1BYTE;

                      _WRITE1BYTE:
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      // Combine 2 fonts, because next fonts do not exist in device font
                      case 0x87:
                        CharTmp1 = '=';  CharTmp2 = '|';    goto _COMBINEDFONT;
                      case 0xD0:        // 'D' with middle bar
                        CharTmp1 = 'D';  CharTmp2 = '-';    goto _COMBINEDFONT;
                      case 0xD8:        // 'O' with slash
                        CharTmp1 = 'O';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xE0:        // 'a' with right-down dash
                        CharTmp1 = 'a';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xE1:        // 'a' with left-down dash
                        CharTmp1 = 'a';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xE2:        // 'a' with hat
                        CharTmp1 = 'a';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xE3:        // 'a' with tilde
                        CharTmp1 = 'a';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xE4:        // 'a' with umlaut
                        CharTmp1 = 'a';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xE5:        // 'a' with circle
                        CharTmp1 = 'a';  CharTmp2 = 0xA6;   goto _COMBINEDFONT;
                      case 0xEA:        // 'e' with hat
                        CharTmp1 = 'e';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xEB:        // 'e' with umlaut
                        CharTmp1 = 'e';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF1:        // 'n' with tilde
                        CharTmp1 = 'n';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF2:        // 'o' with right-down dash
                        CharTmp1 = 'o';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xF3:        // 'o' with left-down dash
                        CharTmp1 = 'o';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xF4:        // 'o' with hat
                        CharTmp1 = 'o';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xF5:        // 'o' with tilde
                        CharTmp1 = 'o';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF6:        // 'o' with umlaut
                        CharTmp1 = 'o';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF8:        // 'o' with slash
                        CharTmp1 = 'o';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xFA:        // 'u' with left-down dash
                        CharTmp1 = 'u';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFB:        // 'u' with hat
                        CharTmp1 = 'u';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xFD:        // 'y' with left-down dash
                        CharTmp1 = 'y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFF:        // 'y' with umlaut
                        CharTmp1 = 'y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      _COMBINEDFONT:
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'D')  // BoldFacePS(except 'D'+'-')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;

                      case 0x9F:        // 'Y' with umlaut
                        CharTmp1 = 'Y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xC0:        // 'A' with right-down dash
                        CharTmp1 = 'A';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xC1:        // 'A' with left-down dash
                        CharTmp1 = 'A';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xC2:        // 'A' with hat
                        CharTmp1 = 'A';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xC3:        // 'A' with tilde
                        CharTmp1 = 'A';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xC8:        // 'E' with right-down dash
                        CharTmp1 = 'E';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCA:        // 'E' with hat
                        CharTmp1 = 'E';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCB:        // 'E' with umlaut
                        CharTmp1 = 'E';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xCC:        // 'I' with right-down dash
                        CharTmp1 = 'I';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCD:        // 'I' with left-down dash
                        CharTmp1 = 'I';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xCE:        // 'I' with hat
                        CharTmp1 = 'I';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCF:        // 'I' with umlaut
                        CharTmp1 = 'I';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xD1:        // 'N' with tilde
                        CharTmp1 = 'N';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD2:        // 'O' with right-down dash
                        CharTmp1 = 'O';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xD3:        // 'O' with left-down dash
                        CharTmp1 = 'O';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xD4:        // 'O' with hat
                        CharTmp1 = 'O';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xD5:        // 'O' with tilde
                        CharTmp1 = 'O';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD9:        // 'U' with right-down dash
                        CharTmp1 = 'U';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xDA:        // 'U' with left-down dash
                        CharTmp1 = 'U';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xDB:        // 'U' with hat
                        CharTmp1 = 'U';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xDD:        // 'Y' with left-down dash
                        CharTmp1 = 'Y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      _COMBINEDFONT_HALFUP:
                        WRITESPOOLBUF(pdevobj, ESC_HALFUP, sizeof(ESC_HALFUP)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, ESC_HALFDOWN, sizeof(ESC_HALFDOWN)-1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'I')  // BoldFacePS(except 'I')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      case 0x84:        // double quatation at bottom
                        CharTmp1 = 0x22;
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0xB1:        // plus-minus
                        if (rcID == BOLDFACEPS)
                        {
                            CharTmp2 = '_';  CharTmp1 = '+';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        }
                        else
                        {
                            CharTmp2 = '+';  CharTmp1 = '-';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        }
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0x95:
                      case 0xB7:
                      default:          // print unprintable font by dot(KATAKANA)
                        // Set 2nd SBCS font table(0x80-0xFF) as KATAKANA
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_IN, sizeof(ESC_SHIFT_IN)-1);
                        CharTmp1 = 0xA5;
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        // Set 2nd SBCS font table(0x80-0xFF) as 2ndANK
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_OUT, sizeof(ESC_SHIFT_OUT)-1);
                        break;
                    } // 'switch (CharTmp1)' end
                }
                else            //** Japanese font (HANKAKU) **
                {
                    if (fVertFont)  // vertical font
                    {
                        // HANKAKU(Alphabetical&Numeric) fonts must not become vertical.
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                    }
                    else            // normal (non vertical) font
                    {
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                    }
                } // 'if European font else Japanese font(HANKAKU)' end


                break;

              case MTYPE_PAIRED:    // DBCS (Japanes font ZENKAKU)
//              VERBOSE((("TYPE_TRANSDATA:ubPairs:0x%x\n"), *(PWORD)(pTrans->uCode.ubPairs)));

                lpChar = pTrans->uCode.ubPairs;

// For proportional font UFM which has GTT @Oct/27/98 ->
#ifdef JISGTT
                if (fJisCode)
                {
                    BYTE    jis[2], sjis[2];

                    jis[0] = *lpChar;
                    jis[1] = *(lpChar+1);
                    jis2sjis(jis, sjis);
                    (BYTE)*lpChar     = sjis[0];
                    (BYTE)*(lpChar+1) = sjis[1];
                }
#endif // JISGTT
// @Oct/27/98 <-
                CharTmp1 = *lpChar;
                CharTmp2 = *(lpChar+1);
                // Some vertical device font differ from TrueType font
                if (fVertFont)
                {
                    if (CharTmp1 == 0x81)
                    {
                        // Make vertical device font same to TrueType
                        if (IsDifferentPRNFONT(CharTmp2))
                        {
                            WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                            WRITESPOOLBUF(pdevobj, ESC_ROT90, sizeof(ESC_ROT90)-1);
                            WRITESPOOLBUF(pdevobj, lpChar, 2);
                            WRITESPOOLBUF(pdevobj, ESC_ROT0, sizeof(ESC_ROT0)-1);
                            WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                            continue;   // goto for-loop end
                        }
                        else if (CharTmp2 >= 0xA8 && CharTmp2 <= 0xAB)
                        {   //IMAGIO's GOTHIC device font differ from TrueType font
                            goto _WITHOUTROTATION;
                        }
                    }

                    if (CharTmp1 == 0x84 &&
                        CharTmp2 >= 0x9F && CharTmp2 <= 0xBE)
                    {
                  _WITHOUTROTATION:
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 2);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                        continue;       // goto for-loop end
                    }
                } // 'if(fVertFont)' end

                // Code of HEISEI mark of device font differs from SJIS
                if (CharTmp1 == 0x87 && CharTmp2 == 0x7E)
                {
                    (BYTE)*(lpChar+1) = 0x9E;
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // If models which support IBM ext char code
                if (fIBMFontSupport)
                {
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // Handle IBM ext char code here at models which do not support it
                switch (CharTmp1)
                {
                  case 0xFA:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0xFC)
                        (BYTE)*lpChar = 0x0EB;
                    goto _WRITE2BYTE;

                  case 0xFB:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x9E)
                    {
                        (BYTE)*lpChar = 0xEC;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x9F && CharTmp2 <= 0xDD)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xDE && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5E;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;

                  case 0xFC:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x4B)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) += 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;


                  case 0xED:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0xE0)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0xE1 && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) -= 0xA1;
                        goto _WRITE2BYTE;
                    }
                    goto _WRITE2BYTE;

                  case 0xEE:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0x82)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x83 && CharTmp2 <= 0xC1)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x43;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xC2 && CharTmp2 <= 0xEC)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x42;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xEF && CharTmp2 <= 0xF8)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) -= 0xAF;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0xF9 && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) -= 0xA5;
                        goto _WRITE2BYTE;
                    }
                    goto _WRITE2BYTE;

                  _WRITE2BYTE_SWITCHBLOCK:
                    // Assign IBM char to JIS1 block
                    AssignIBMfont(pdevobj, rcID, IBMFONT_ENABLE_ALL);
                    // Output char code
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    // Resume the block
                    AssignIBMfont(pdevobj, rcID, IBMFONT_RESUME);
                    break;

                  default:
                  _WRITE2BYTE:
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    break;
                } // 'switch (CharTmp1)' end

                break;
            } // 'switch (pTrans->ubType & MTYPE_FORMAT_MASK)' end
        } // 'for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)' end
//** Draw device font END **

       if(fMemAllocated)
           MemFree(aubBuff);

        break;


      case TYPE_GLYPHID:        // donwload font
#ifdef DOWNLOADFONT
        // If negative, do not draw. (lFontID should begin from 0.)
//      VERBOSE((("** ulFontID=%d **\n"), pUFObj->ulFontID));
        if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0)
            break;    // exit

//** Draw download font **
        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            // If negative, do not draw. (lGlyphID should begin from 0.)
            if ((lGlyphID = (LONG)*(PWORD)pGlyph - DLFONT_GLYPH_MIN_GPD) < 0)
                break;  // exit for-loop
            wSerialNum = (WORD)lGlyphID + (WORD)lFontID * DLFONT_GLYPH_TOTAL;
            lpDLFont = &pOEM->pDLFontGlyphInfo[wSerialNum];

//          VERBOSE((("** pGlyph=%d, local glyph_id=%d **\n"), *(PWORD)pGlyph, lGlyphID));

            // If space character
            if (lpDLFont->nPitch < 0)
            {
                // Save moving value for next font print with reseting flag
                pOEM->nCharPosMoveX += -lpDLFont->nPitch;
            }
            else
            {
                // Locate print position.
                if ((mov = pOEM->nCharPosMoveX + lpDLFont->nOffsetX) != 0)
                {
                    if (mov > 0)
                        ocmd = sprintf(Cmd, ESC_XM_REL, mov);
                    else
                        ocmd = sprintf(Cmd, ESC_XM_RELLEFT, -mov);
                }

                // Print download font
                ocmd += sprintf(&Cmd[ocmd], DLFONT_PRINT, wSerialNum,
                                pOEM->TextCurPos.y - lpDLFont->nOffsetY);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                ocmd = 0;

                // Save moving value for next font print.
                pOEM->nCharPosMoveX = lpDLFont->nPitch - lpDLFont->nOffsetX;
            } // 'if (pitch < 0) else' end
        } // 'for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)' end
#endif // DOWNLOADFONT
        break;
//** Draw download font END **
    } // 'switch (dwType)' end
} //*** OEMOutputCharStr


DWORD APIENTRY OEMDownloadFontHeader(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj)
{
#ifndef DOWNLOADFONT
    return 0;   // not available
#else  // DOWNLOADFONT
    VERBOSE(("** OEMDownloadFontHeader() entry. **\n"));
    VERBOSE(("  FontID=%d\n", pUFObj->ulFontID));
// OBSOLETE @Apr/02/99 ->
// SPEC of Unidrv5
// Unidrv5 doesn't handle 0-return, once OEMTTDownloadMethod returns TTDOWNLOAD_BITMAP.
//  POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
//  LONG        lFontID;    // @Aug/21/98
//  // If FontID is beyond limit, exit.
//  if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0 ||
//      lFontID >= (LONG)pOEM->DLFontMaxID)
//  {
//      return 0;
//  }
// @Apr/02/99 <-
    return 1;   // available
#endif // DOWNLOADFONT
} //*** OEMDownloadFontHeader


DWORD APIENTRY OEMDownloadCharGlyph(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH hGlyph,
    PDWORD pdwWidth)
{
#ifndef DOWNLOADFONT
    return 0;       // not available
#else  // DOWNLOADFONT
    WORD        wSerialNum, wHeight, wWidthByte;
    DWORD       dwNeeded, dwSize;
    LPBYTE      lpBitmap;
    LPFONTPOS   lpDLFont;
    GETINFO_GLYPHBITMAP GBmp;
    POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
    LONG        lFontID, lGlyphID;

    VERBOSE(("** OEMDownloadCharGlyph() entry. **\n"));

    // If negative or beyond limit, do not download. (lGlyphID should begin from 0.)
    if ((lGlyphID = (LONG)pOEM->DLFontCurGlyph - DLFONT_GLYPH_MIN_GPD) < 0 ||
        lGlyphID >= pOEM->DLFontMaxGlyph)
    {
        return 0;   // exit
    }

    // If beyond limit, do not download. (lFontID should begin from 0.)
    if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0 ||
        lFontID >= (LONG)pOEM->DLFontMaxID)
    {
        return 0;   // exit
    }
    VERBOSE(("  FontID=%d, GlyphID=%d\n", lFontID, lGlyphID));

    wSerialNum = (WORD)lGlyphID + (WORD)lFontID * DLFONT_GLYPH_TOTAL;

    //
    // GETINFO_GLYPHBITMAP
    //
    GBmp.dwSize = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph = hGlyph;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp,
                            GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;   // exit
    }
    wWidthByte = ((WORD)GBmp.pGlyphData->gdf.pgb->sizlBitmap.cx + 7) >> 3;  // byte:8bit-boundary
    wHeight    = (WORD)GBmp.pGlyphData->gdf.pgb->sizlBitmap.cy;
    lpBitmap   = (LPBYTE)GBmp.pGlyphData->gdf.pgb->aj;
    lpDLFont   = &pOEM->pDLFontGlyphInfo[wSerialNum];
    lpDLFont->nPitch   = (SHORT)(GBmp.pGlyphData->fxD >> 4);
    lpDLFont->nOffsetX = (SHORT)GBmp.pGlyphData->gdf.pgb->ptlOrigin.x;
    lpDLFont->nOffsetY = -(SHORT)GBmp.pGlyphData->gdf.pgb->ptlOrigin.y;
    dwSize = wHeight * wWidthByte;

//  VERBOSE(("  width=%dbyte,height=%ddot,bmp[0]=%x\n", wWidthByte, wHeight, *lpBitmap));
//  VERBOSE(("  pitch=%d(FIX(28.4):%lxh),offsetx=%d,offsety=%d\n",
//           GBmp.pGlyphData->fxD >> 4, GBmp.pGlyphData->fxD,
//           lpDLFont->nOffsetX, lpDLFont->nOffsetY));
//  VERBOSE(("  dwSize(raw)=%ldbyte\n", dwSize));

    // If space character
    if (dwSize == 0 || dwSize == 1 && *lpBitmap == 0)
    {
        // Negate pitch to indicate space character
        lpDLFont->nPitch = -lpDLFont->nPitch;
        return 1;   // success return  (1<-0 @Jun/15/98)
    }
    else
    {
        BYTE        Cmd[64];
        INT         ocmd;   // INT<-SHORT  @Feb/22/99
        WORD        fDRC = FALSE;
        DWORD       dwSizeRPDL, dwSizeDRC;

        // Do FE-DeltaRow compression  (@Jun/15/98, pOEM->pRPDLHeap2K<-OutBuf[1024] @Sep/09/98)
        if (TEST_CAPABLE_DOWNLOADFONT_DRC(pOEM->fModel) && pOEM->pRPDLHeap2K &&
            -1 != (dwSizeDRC = DRCompression(lpBitmap, pOEM->pRPDLHeap2K, dwSize, HEAPSIZE2K,
                                             (DWORD)wWidthByte, (DWORD)wHeight)))
        {
            fDRC = TRUE;
            dwSize = dwSizeDRC;
            lpBitmap = pOEM->pRPDLHeap2K;
        }

        // Include header size and make it 32byte-boudary.
        dwSizeRPDL = (dwSize + (DLFONT_HEADER_SIZE + DLFONT_MIN_BLOCK - 1))
                     / DLFONT_MIN_BLOCK * DLFONT_MIN_BLOCK;

        // Check available memory size
        if((pOEM->dwDLFontUsedMem += dwSizeRPDL) > ((DWORD)pOEM->DLFontMaxMemKB << 10))
        {
            ERR(("DOWNLOAD MEMORY OVERFLOW.\n"));
            return 0;   // exit
        }
        VERBOSE(("  Consumed Memory=%ldbyte\n", pOEM->dwDLFontUsedMem));

        // Register glyph bitmap image
        if (fDRC)   // @Jun/15/98
            ocmd = sprintf(Cmd, DLFONT_SEND_BLOCK_DRC, wWidthByte*8, wHeight, wSerialNum, dwSize);
        else
            ocmd = sprintf(Cmd, DLFONT_SEND_BLOCK, wWidthByte*8, wHeight, wSerialNum);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        WRITESPOOLBUF(pdevobj, lpBitmap, dwSize);
        return dwSizeRPDL;
    }
#endif // DOWNLOADFONT
} //*** OEMDownloadCharGlyph


DWORD APIENTRY OEMTTDownloadMethod(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj)
{
#ifndef DOWNLOADFONT
    return TTDOWNLOAD_DONTCARE;
#else  // DOWNLOADFONT
// @Nov/18/98 ->
    GETINFO_FONTOBJ GFo;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);
    DWORD    dwNeeded, dwWidth;

    VERBOSE(("** OEMTTDownloadMethod() entry. **\n"));

    // If printer doesn't support or user disabled downloading, do not download.
    if (!pOEM->DLFontMaxMemKB)
        return TTDOWNLOAD_DONTCARE;

    //
    // GETINFO_FONTOBJ
    //
    GFo.dwSize = sizeof(GETINFO_FONTOBJ);
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &GFo,
                            GFo.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_FONTOBJ failed.\n"));
        return TTDOWNLOAD_GRAPHICS;     // <-TTDOWNLOAD_DONTCARE @Apr/02/99
    }

    // If bold or italic font, do not download.
    // (SBCS font which has bold or italic glyph (e.g. Arial) doesn't fit this condition.)
    if (GFo.pFontObj->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
    {
        VERBOSE(("  UNAVAILABLE: BOLD/ITALIC\n"));
        return TTDOWNLOAD_GRAPHICS;     // <-TTDOWNLOAD_DONTCARE @Apr/02/99
    }

    dwWidth = GFo.pFontObj->cxMax * pOEM->nResoRatio;  // masterunit
//  VERBOSE(("  FontSize=%d\n", GFo.pFontObj->cxMax));

    // If font width is beyond limit, do not download.
    if (IS_DBCSCHARSET(pUFObj->pIFIMetrics->jWinCharSet))
    {
        if (dwWidth > DLFONT_SIZE_DBCS11PT_MU || dwWidth < DLFONT_SIZE_DBCS9PT_MU)
        {
            VERBOSE(("  UNAVAILABLE: DBCS FONTSIZE OUT OF RANGE(%ddot,%dcpt)\n",
                     GFo.pFontObj->cxMax, dwWidth*7200L/MASTERUNIT));
            return TTDOWNLOAD_GRAPHICS; // <-TTDOWNLOAD_DONTCARE @Apr/02/99
        }
    }
    else
    {
        if (dwWidth > DLFONT_SIZE_SBCS11PT_MU || dwWidth < DLFONT_SIZE_SBCS9PT_MU)
        {
            VERBOSE(("  UNAVAILABLE: SBCS FONTSIZE OUT OF RANGE(%ddot,%dcpt)\n",
                     GFo.pFontObj->cxMax, dwWidth*7200L/MASTERUNIT));
            return TTDOWNLOAD_GRAPHICS; // <-TTDOWNLOAD_DONTCARE @Apr/02/99
        }
    }
    VERBOSE(("  AVAILABLE\n"));
// @Nov/18/98 <-
    return TTDOWNLOAD_BITMAP;
#endif // DOWNLOADFONT
} //*** OEMTTDownloadMethod


INT APIENTRY OEMCompression(                        // @Jun/04/98
    PDEVOBJ pdevobj,
    PBYTE pInBuf,
    PBYTE pOutBuf,
    DWORD dwInLen, 
    DWORD dwOutLen)
{
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98

//  VERBOSE(("OEMCompression() entry.\n"));
    return DRCompression(pInBuf, pOutBuf, dwInLen, dwOutLen,
                         pOEM->dwSrcBmpWidthByte, pOEM->dwSrcBmpHeight);
} //*** OEMCompression


//---------------------------*[LOCAL] DRCompression*---------------------------
// Action: Compress data by FE-DeltaRow method
// Return: number of compressed bytes if successful
//         -1 if unable to compress the data within the specific buffer
// History:
//      Oct/25/97 Tatsuro Yoshioka(RICOH) Created.
//      Jun/11/98 Masatoshi Kubokura(RICOH) Modified.
//-----------------------------------------------------------------------------
static INT DRCompression(
    PBYTE pInBuf,       // Pointer to raster data to compress
    PBYTE pOutBuf,      // Pointer to output buffer for compressed data
    DWORD dwInLen,      // size of input data to compress
    DWORD dwOutLen,     // size of output buffer in bytes
    DWORD dwWidthByte,  // width of raster data in bytes
    DWORD dwHeight)     // height of raster data
{
    DWORD   dwCurRow, dwCurByte, dwSameByteCnt, dwRepeatByteCnt, dwTmp;
    DWORD   dwCompLen, dwCnt, dwCnt2;
    BYTE    *pTmpPre, *pTmpCur, *pCurRow, *pPreRow;
    BYTE    DiffBytes[16], FlagBit;

//  VERBOSE(("  dwInLen, dwOutLen=%d, %d\n", dwInLen, dwOutLen));
//  VERBOSE(("  Width, Height=%d, %d\n", dwWidthByte, dwHeight));

    if (dwOutLen > dwInLen)     // add  @Jun/19/98
        dwOutLen = dwInLen;

// @Apr/07/2000 ->
    // PRINTER SIDE ISSUE: RPDL
    // Bitmap image is destorted when width or height >= 10000dots
    if (dwWidthByte >= (10000L/8L) || dwHeight >= 10000L)
        return -1;
// @Apr/07/2000 <-
    if (dwHeight <= 3 || dwOutLen <= dwWidthByte * 3)
        return -1;
    pPreRow = pTmpPre = pOutBuf + dwOutLen - dwWidthByte;
    dwCnt = dwWidthByte;
    while (dwCnt--)         // fill seed row with 0
        *pTmpPre++ = 0;
    dwCompLen = 0;

    // Loop of each row
    for (dwCurRow = 0, pCurRow = pInBuf; dwCurRow < dwHeight;
         dwCurRow++, pCurRow += dwWidthByte)
    {
        dwCurByte = 0;
        // Loop of each byte-data in row
        while (dwCurByte < dwWidthByte)
        {
            // Search same byte-data between current row and previous row
            dwSameByteCnt = 0;
            dwTmp = dwCurByte;
            pTmpPre = pPreRow + dwTmp;
            pTmpCur = pCurRow + dwTmp;
            while (*pTmpCur++ == *pTmpPre++)
            {
// bug fix @Nov/19/98 ->
//              if (dwTmp++ >= dwWidthByte)
//                  break;
//              dwSameByteCnt++;
                dwSameByteCnt++;
                if (++dwTmp >= dwWidthByte)
                    break;
// @Nov/19/98 <-
            }

            // If we have same byte-data between current row and previous row
            if (dwSameByteCnt)
            {
                if (dwSameByteCnt != dwWidthByte)
                {
                    if ((dwCnt = dwSameByteCnt) >= 63)
                    {
                        dwCnt -= 63;
                        if (++dwCompLen > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(1)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xBF;      // control data (same to previous row)

                        while (dwCnt >= 255)
                        {
                            dwCnt -= 255;
                            if (++dwCompLen > dwOutLen)
                            {
                                VERBOSE(("  OVERSIZE COMPRESSION(2)\n"));
                                return -1;
                            }
                            *pOutBuf++ = 0xFF;  // repeating count
                        }
                    }
                    else    // less than 63
                    {
                        dwCnt |= 0x80;
                    }

                    if (++dwCompLen > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(3)\n"));
                        return -1;
                    }
                    // If 63 or more, set the last repeating count, else set control data.
                    *pOutBuf++ = (BYTE)dwCnt;
                }
                dwCurByte += dwSameByteCnt;
            }
            // Same byte-data in previous row is none
            else
            {
                BYTE bTmp = *(pCurRow + dwCurByte);

                // How many same byte-data in current row?
                dwRepeatByteCnt = 1;
                dwTmp = dwCurByte + 1;
                pTmpCur = pCurRow + dwTmp;
                while (bTmp == *pTmpCur++)
                {
// bug fix @Nov/19/98 ->
//                  if (dwTmp++ >= dwWidthByte)
//                      break;
//                  dwRepeatByteCnt++;
                    dwRepeatByteCnt++;
                    if (++dwTmp >= dwWidthByte)
                        break;
// @Nov/19/98 <-
                }

                // If we have same byte-data in current row
                if (dwRepeatByteCnt > 1)
                {
                    if ((dwCnt = dwRepeatByteCnt) >= 63)
                    {
                        dwCnt -= 63;
                        if (++dwCompLen > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(4)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xFF;      // repeating count

                        while (dwCnt >= 255)
                        {
                            dwCnt -= 255;
                            if (++dwCompLen > dwOutLen)
                            {
                                VERBOSE(("  OVERSIZE COMPRESSION(5)\n"));
                                return -1;
                            }
                            *pOutBuf++ = 0xFF;  // repeating count
                        }
                    }
                    // Less than 63
                    else
                    {
                        dwCnt |= 0xC0;
                    }

                    if ((dwCompLen += 2) > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(6)\n"));
                        return -1;
                    }
                    // If 63 or more, set the last repeating count, else set control data.
                    *pOutBuf++ = (BYTE)dwCnt;
                    *pOutBuf++ = *(pCurRow+dwCurByte);  // replacing data

                    dwCurByte += dwRepeatByteCnt;
                }
                // Same byte-data in current row is none
                else
                {
                     // If next serial 2 byte-data are same
                    if (dwWidthByte - dwCurByte > 2 &&
                        *(pCurRow+dwCurByte+1) == *(pCurRow+dwCurByte+2))
                    {
                        if ((dwCompLen += 2) > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(7)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xC1;  // control data (1 data)
                        *pOutBuf++ = *(pCurRow+dwCurByte);  // replacing data

                        dwCurByte++;
                        continue;   // continue while(dwCurByte < dwWidthByte)
                    }

                    // We can pack 8 serial byte-data (may or may not be different to previus row)
                    DiffBytes[0] = 0x00; 
                    DiffBytes[1] = *(pCurRow+dwCurByte);
                    dwCnt2 = 2;
                    dwTmp = dwCurByte + 1;
                    pTmpPre = pPreRow + dwTmp;
                    pTmpCur = pCurRow + dwTmp;
                    FlagBit = 0x01;
                    if ((dwCnt = dwWidthByte - dwTmp) > 7)
                        dwCnt = 7;
                    while (dwCnt--)
                    {
                        // If encountered different data
                        if (*pTmpCur != *pTmpPre++)
                        {  
                            DiffBytes[0] |= FlagBit;        // set different-flag
                            DiffBytes[dwCnt2++] = *pTmpCur; // data
                        }
                        FlagBit <<= 1;
                        pTmpCur++;
                    }

                    if ((dwCompLen += dwCnt2) > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(8)\n"));
                        return -1;
                    }
                    pTmpCur = &DiffBytes[0];
                    while (dwCnt2--)
                        *pOutBuf++ = *pTmpCur++;    // different packed-data

                    dwCurByte += 8;                 // 8 byte-data are packed
                } // 'if (dwRepeatByteCnt > 1) else' end
            } // 'if (dwSameByteCnt) else' end
        } // 'while (dwCurByte < dwWidthByte)' end

        if (++dwCompLen > dwOutLen)
        {
            VERBOSE(("  OVERSIZE COMPRESSION(9)\n"));
            return -1;
        }
        *pOutBuf++ = 0x80;      // terminator of row

        pPreRow = pCurRow; 
    } // 'for (...; dwCurRow < dwHeight; ...)' end

//  VERBOSE(("  dwCompLen=%d\n", dwCompLen));
    return dwCompLen;
} //*** DRCompression


// OBSOLETE (FilterGraphics disables other compression!) @Feb/16/99 ->
#if 0   // SP8BUGFIX_RASTER
BOOL APIENTRY OEMFilterGraphics(                    // @Feb/10/99
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);

    // SP7&8 can't handle over-32768byte block with default printer memory
    if (BITTEST32(pOEM->fGeneral2, DIVIDE_DATABLOCK))
    {
        DWORD dwHeight, dwMaxHeight, dwSendSize;
        PBYTE pCurBuf = pBuf;
        BYTE  Cmd[64];
        INT   ocmd;         // INT<-SHORT  @Feb/22/99

        if (pOEM->dwSrcBmpWidthByte <= 0)
        {
//#if DBG
//DebugBreak();
//#endif
            return TRUE;    // error exit
        }

        // Set position
        ocmd = sprintf(Cmd, ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = sprintf(Cmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);

        dwHeight = pOEM->dwSrcBmpHeight;
        dwMaxHeight = 32768L / pOEM->dwSrcBmpWidthByte;

        // Divide into under-32768byte blocks
        while (dwHeight > dwMaxHeight)
        {
            dwHeight -= dwMaxHeight;
            ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_NC, pOEM->dwSrcBmpWidthByte * 8, dwMaxHeight);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            WRITESPOOLBUF(pdevobj, pCurBuf, (dwSendSize = pOEM->dwSrcBmpWidthByte * dwMaxHeight));
            ocmd = sprintf(Cmd, ESC_YM_REL, dwMaxHeight);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            pCurBuf += dwSendSize;
        }
        ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_NC, pOEM->dwSrcBmpWidthByte * 8, dwHeight);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        WRITESPOOLBUF(pdevobj, pCurBuf, pOEM->dwSrcBmpWidthByte * dwHeight);
    }
    // others (almost all RPDL printers) send just data block (without RPDL opecode).
    else
    {
        WRITESPOOLBUF(pdevobj, pBuf, dwLen);
    } // 'if (BITTEST32(pOEM->fGeneral2, DIVIDE_DATABLOCK)) else' end

    return TRUE;
} // *** OEMFilterGraphics
#endif // if 0
// @Feb/16/99 <-
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\ricoh\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=rpdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),rpdlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;..\..\rpdlui

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\rpdlres.rc \
    $(SRCDIR)\rpdlres.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\ddi.c

MISCFILES=\
    $(SRCDIR)\rpdlres.ini \
    $(SRCDIR)\rpdlres2.ini \
    $(SRCDIR)\hlp\rpdlcfg.hlp \
    $(SRCDIR)\hlp\rpdlcfg2.hlp \
    $(GPDDIR)\riip1j.gpd \
    $(GPDDIR)\rim105pj.gpd \
    $(GPDDIR)\rim353ej.gpd \
    $(GPDDIR)\rim354j.gpd \
    $(GPDDIR)\rim357ej.gpd \
    $(GPDDIR)\rim358j.gpd \
    $(GPDDIR)\rim457ej.gpd \
    $(GPDDIR)\rim555ej.gpd \
    $(GPDDIR)\rim557j.gpd \
    $(GPDDIR)\rim557xj.gpd \
    $(GPDDIR)\rim655ej.gpd \
    $(GPDDIR)\rim707j.gpd \
    $(GPDDIR)\rim857j.gpd \
    $(GPDDIR)\rim857xj.gpd \
    $(GPDDIR)\rimd35j.gpd \
    $(GPDDIR)\rimf153j.gpd \
    $(GPDDIR)\rimf15ej.gpd \
    $(GPDDIR)\rimf15j.gpd \
    $(GPDDIR)\rimf16j.gpd \
    $(GPDDIR)\rimf20j.gpd \
    $(GPDDIR)\rimf220j.gpd \
    $(GPDDIR)\rimf223j.gpd \
    $(GPDDIR)\rimf25j.gpd \
    $(GPDDIR)\rimf270j.gpd \
    $(GPDDIR)\rimf273j.gpd \
    $(GPDDIR)\rimf330j.gpd \
    $(GPDDIR)\rimf335j.gpd \
    $(GPDDIR)\rimf350j.gpd \
    $(GPDDIR)\rimf353j.gpd \
    $(GPDDIR)\rimf355j.gpd \
    $(GPDDIR)\rimf357j.gpd \
    $(GPDDIR)\rimf455j.gpd \
    $(GPDDIR)\rimf457j.gpd \
    $(GPDDIR)\rimf53j.gpd \
    $(GPDDIR)\rimf555j.gpd \
    $(GPDDIR)\rimf655j.gpd \
    $(GPDDIR)\rimf70j.gpd \
    $(GPDDIR)\rimp15j.gpd \
    $(GPDDIR)\rimp25ej.gpd \
    $(GPDDIR)\rimp25j.gpd \
    $(GPDDIR)\rimp35ej.gpd \
    $(GPDDIR)\rimp35j.gpd \
    $(GPDDIR)\rine22j.gpd \
    $(GPDDIR)\rine27j.gpd \
    $(GPDDIR)\rine35dj.gpd \
    $(GPDDIR)\rine35j.gpd \
    $(GPDDIR)\rine45j.gpd \
    $(GPDDIR)\rinx100j.gpd \
    $(GPDDIR)\rinx10j.gpd \
    $(GPDDIR)\rinx110j.gpd \
    $(GPDDIR)\rinx11j.gpd \
    $(GPDDIR)\rinx21j.gpd \
    $(GPDDIR)\rinx41j.gpd \
    $(GPDDIR)\rinx62j.gpd \
    $(GPDDIR)\rinx62nj.gpd \
    $(GPDDIR)\rinx72nj.gpd \
    $(GPDDIR)\rinx72xj.gpd \
    $(GPDDIR)\rinx81j.gpd \
    $(GPDDIR)\rinx50j.gpd \
    $(GPDDIR)\rinx51j.gpd \
    $(GPDDIR)\rinx60j.gpd \
    $(GPDDIR)\rinx61j.gpd \
    $(GPDDIR)\rinx70j.gpd \
    $(GPDDIR)\rinx71j.gpd \
    $(GPDDIR)\rinx7j.gpd \
    $(GPDDIR)\rinx7_1j.gpd \
    $(GPDDIR)\rinx80j.gpd \
    $(GPDDIR)\rinx90j.gpd \
    $(GPDDIR)\rinx91j.gpd \
    $(GPDDIR)\risp101j.gpd \
    $(GPDDIR)\risp102j.gpd \
    $(GPDDIR)\risp103j.gpd \
    $(GPDDIR)\risp104j.gpd \
    $(GPDDIR)\risp105j.gpd \
    $(GPDDIR)\risp106j.gpd \
    $(GPDDIR)\risp107j.gpd \
    $(GPDDIR)\risp4_2j.gpd \
    $(GPDDIR)\risp5j.gpd \
    $(GPDDIR)\risp7_2j.gpd \
    $(GPDDIR)\risp7j.gpd \
    $(GPDDIR)\risp8_2j.gpd \
    $(GPDDIR)\risp80j.gpd \
    $(GPDDIR)\risp8j.gpd \
    $(GPDDIR)\risp9_2j.gpd \
    $(GPDDIR)\risp90j.gpd \
    $(GPDDIR)\risp9j.gpd \
    $(GPDDIR)\rix153j.gpd \
    $(GPDDIR)\rix223j.gpd \
    $(GPDDIR)\rix25j.gpd \
    $(GPDDIR)\rix270j.gpd \
    $(GPDDIR)\rix273j.gpd \
    $(GPDDIR)\rix350j.gpd \
    $(GPDDIR)\rix353ej.gpd \
    $(GPDDIR)\rix353j.gpd \
    $(GPDDIR)\rix354j.gpd \
    $(GPDDIR)\rix355j.gpd \
    $(GPDDIR)\rix357ej.gpd \
    $(GPDDIR)\rix357j.gpd \
    $(GPDDIR)\rix358j.gpd \
    $(GPDDIR)\rix35j.gpd \
    $(GPDDIR)\rix455j.gpd \
    $(GPDDIR)\rix457ej.gpd \
    $(GPDDIR)\rix457j.gpd \
    $(GPDDIR)\rixprnj.gpd \
    $(GPDDIR)\rpdlmac.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",        // This disables other compression.
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\hlp\rpdlcfg2.hh ===
;IDH_Orientation=
;IDH_InputBin=
;IDH_Resolution=
;IDH_PaperSize=
;IDH_Collate=
;IDH_Duplex=
IDH_EdgeToEdgePrint=1
IDH_LeftMarginInPrinting=2
IDH_TopMarginInPrinting=3
IDH_EmulationMode=4
IDH_MediaType=5
IDH_OutputBin=6
IDH_Sorting=7
IDH_Stapling=8
IDH_Punching=9
IDH_ScanForRules=10
IDH_PrintQuality=11
IDH_PrintDensity=12
IDH_ImageControl=13
IDH_Halftone=14
IDH_Memory=15
IDH_LongEdgeFeed=16
IDH_CollateType=17
IDH_PrintTextAsBlack=18
;IDH_HardDisk=
;IDH_Finisher=
;IDH_PrintPost=
IDH_UI_VariableScaling=50
IDH_UI_BarHeight=51
IDH_UI_BarSubFont=52
IDH_UI_DuplexMargin=53
IDH_UI_BindRight=54
IDH_UI_TomboAdd=55
IDH_UI_TomboAdjX=56
IDH_UI_TomboAdjY=57
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    02/11/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.

--*/

#include "pdev.h"

#if 0  // DBG
#define giDebugLevel DBG_VERBOSE
#endif

#ifdef WINNT_40     // @Aug/31/99
DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging
#endif // WINNT_40

// fax data file
// @Sep/03/99 ->
//#define FAXOPTFILENAME   L"\\Temp\\RPDLMD5F.TMP"  // Add "\\Temp\\"  @Oct/20/98
#ifndef WINNT_40
#define FAXOPTFILENAME          L"\\RIMD5.BIN"
#else  // WINNT_40
#define FAXOPTFILENAME          L"\\2\\RI%.4ls%02x.BIN" // %02x<-%02d  @Sep/21/99
#endif // WINNT_40
// @Sep/03/99 <-

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#ifdef WINNT_40     // @Sep/20/99
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
        VERBOSE(("** dmCollate(IN)=%d **\n", pOEMDevModeParam->pPublicDMIn->dmCollate));
#endif // WINNT_40
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
// @Jul/08/98 ->
//        // nothing to convert for this private devmode. So just initialize it.
//        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
// @Jul/08/98 <-
    case OEMDM_MERGE:
// OBSOLETE, because this causes unchecking collate check box every time open
// document property sheet.  @Sep/27/99 ->
//#ifdef WINNT_40     // @Sep/20/99
//        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
//        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
//        pOEMDevModeParam->pPublicDMOut->dmCollate = DMCOLLATE_FALSE;
//        pOEMDevModeParam->pPublicDMOut->dmFields &= ~DM_COLLATE;
//#endif // WINNT_40
// @Sep/27/99 <-
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->UiScale = VAR_SCALING_DEFAULT;
    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;
    pOEMExtra->UiBindMargin = DEFAULT_0;
    pOEMExtra->nUiTomboAdjX = pOEMExtra->nUiTomboAdjY = DEFAULT_0;  // add @Sep/14/98
    memset(pOEMExtra->FaxDataFileName, 0, sizeof(pOEMExtra->FaxDataFileName)); // @Aug/31/99

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/98        Masatoshi Kubokura Created.
//              08/16/99        takashim modified for Unidrv5.4 on NT4.
//              09/01/99        Kubokura modified for Unidrv5.4 on NT4.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

// Store file name to private devmode @Sep/01/99 ->
//// Since szFileName of GetTempPath is different whether EMF is enable or not,
//// we use GetWindowsDirectory(). @Oct/20/98 ->
////    dwSize = GetTempPath(MAX_PATH, szFileName);
////    wsprintf(&szFileName[dwSize], FAXOPTFILENAME);
//    dwSize = GetWindowsDirectory(szFileName, MAX_PATH);
//    wcscpy(&szFileName[dwSize], FAXOPTFILENAME);
//    VERBOSE(("** RWFileData: filename=%ls **\n", szFileName));
//// @Oct/20/98 <-
// @Sep/01/99 <-

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    // Set fax data file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
        wcscpy(&szFileName[dwSize], FAXOPTFILENAME);
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
#else  // WINNT_40
    // Since the file path differs on each PC in printer sharing, we always
    // update the file name (with path) of private devmode.  @Sep/03/99

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIXXXXNN.BIN". "XXXX" is filled with top 4char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], FAXOPTFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], FAXOPTFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create fax file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
    return bRet;
} //*** RWFileData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

/*++

Copyright (c) 1996-1999  Microsoft Corporation

FILE:           PDEV.H

Abstract:       Header file for OEM UI & rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/15/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/31/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.

--*/


//
// Files necessary for OEM plug-in.
//

#include <windows.h>   // for UI
#include <compstui.h>  // for UI
#include <winddiui.h>  // for UI
#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define MASTERUNIT          1200
#define DEVICE_MASTER_UNIT  7200
#define DRIVER_MASTER_UNIT  MASTERUNIT

//
// Compile options
//
#define DOWNLOADFONT        // support TrueType download
//#define JISGTT            // Current GTT is JIS code set
//#define DDIHOOK           // ddi hook is available
//#define FAXADDRESSBOOK    // fax addressbook is available
//#define TEXTCLIPPING      // support TextMode clipping

//
// Misc definitions follows.
//
#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#define MINIDEV_DATA(p) \
    ((POEMPDEV)((p)->pdevOEM))          // device data during job
#define MINIPRIVATE_DM(p) \
    ((POEMUD_EXTRADATA)((p)->pOEMDM))   // private devmode
// OBSOLETE  @Sep/27/99 ->
//#define UI_GETDRIVERSETTING(p1, p2, p3, p4, p5, p6) \
//    ((p1)->pOemUIProcs->DrvGetDriverSetting(p1, p2, p3, p4, p5, p6))
// @Sep/27/99 <-

// ASSERT(VALID_PDEVOBJ) can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

// Debug text.
#if DBG
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)
#ifdef UIMODULE
#define DLLTEXT(s)      "RPDLUI: " s
#else  // !UIMODULE
#define DLLTEXT(s)      "RPDLRES: " s
#endif // !UIMODULE
#endif // DBG

////////////////////////////////////////////////////////
// OEM Signature and version.
////////////////////////////////////////////////////////
#define OEM_SIGNATURE   'RPDL'      // RICOH RPDL printers
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
// DDI hooks
// Warning: the following enum order must match the
//           order in OEMHookFuncs[].
////////////////////////////////////////////////////////
#ifdef DDIHOOK
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
#endif // DDIHOOK


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////
#define ABS(x) ((x > 0)? (x):-(x))

// heap memory size
#define HEAPSIZE64                  64    // this must be bigger than 32
#define HEAPSIZE2K                  2048  // @Sep/09/98

#ifdef DOWNLOADFONT
// definitions for download font
#define MEM128KB                    128 // Kbyte
#define MEM256KB                    256
#define MEM512KB                    512
#define DLFONT_ID_4                 4   // 4 IDs
#define DLFONT_ID_8                 8   // 8 IDs
#define DLFONT_ID_16                16  // 16 IDs  @Oct/20/98
#define DLFONT_ID_MIN_GPD           0   // *MinFontID in GPD
#define DLFONT_ID_MAX_GPD           15  // *MaxFontID in GPD (6->3 @May/07/98,->7 @Jun/17/98,->15 @Oct/20/98)
#define DLFONT_ID_TOTAL             (DLFONT_ID_MAX_GPD - DLFONT_ID_MIN_GPD + 1)
#define DLFONT_GLYPH_MIN_GPD        0   // *MinGlyphID in GPD
#define DLFONT_GLYPH_MAX_GPD        69  // *MaxGlyphID in GPD (103->115 @May/07/98,->69 @Oct/20/98)
#define DLFONT_GLYPH_TOTAL          (DLFONT_GLYPH_MAX_GPD - DLFONT_GLYPH_MIN_GPD + 1)
#define DLFONT_SIZE_DBCS11PT_MU     216 // actual value(MSMincho 400dpi)    @Nov/18/98
#define DLFONT_SIZE_DBCS9PT_MU      160 // actual value(MSMincho 600dpi)    @Nov/18/98
#define DLFONT_SIZE_SBCS11PT_MU     512 // actual value(Arial&Times 600dpi) @Nov/18/98
#define DLFONT_SIZE_SBCS9PT_MU      192 // actual value(Century 400&600dpi) @Nov/18/98
#define DLFONT_HEADER_SIZE          16  // RPDL header size of each download character
#define DLFONT_MIN_BLOCK            32  // RPDL min block size: 32bytes
#define DLFONT_MIN_BLOCK_ID         5   // RPDL min block size ID of 32bytes

// Fax option data buffer size
#define FAXBUFSIZE256               256
#define FAXEXTNUMBUFSIZE            8
#define FAXTIMEBUFSIZE              6
#define MY_MAX_PATH                 80  // 100->80 @Sep/02/99

typedef struct
{
    SHORT   nPitch;
    SHORT   nOffsetX;
    SHORT   nOffsetY;
} FONTPOS, FAR *LPFONTPOS;
#endif // DOWNLOADFONT


// private devmode
typedef struct _OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
// common data between UI & rendering plugin ->
    DWORD   fUiOption;          // bit flags for UI option  (This must be after dmExtraHdr)
    WORD    UiScale;            // variable scaling value (%)
    WORD    UiBarHeight;        // barcode height (mm)
    WORD    UiBindMargin;       // left or upper binding margin at duplex printing (mm)
    SHORT   nUiTomboAdjX;       // horizontal distance adjustment at TOMBO (0.1mm unit)
    SHORT   nUiTomboAdjY;       // vertical distance adjustment at TOMBO (0.1mm unit)
    // We use private devmode, not use file, because EMF disables reading/writing the file.
    BYTE    FaxNumBuf[FAXBUFSIZE256];       // fax number
#ifdef FAXADDRESSBOOK
    BYTE    FaxNumBookBuf[FAXBUFSIZE256];   // fax number which is set by addressbook(not yet)
#endif // FAXADDRESSBOOK
    BYTE    FaxExtNumBuf[FAXEXTNUMBUFSIZE]; // extra number (external)
    BYTE    FaxSendTime[FAXTIMEBUFSIZE];    // reservation time
    WORD    FaxReso;            // fax send resolution (0:400,1:200,2:100dpi)
    WORD    FaxCh;              // fax send channel (0:G3,1:G4,2:G3-1ch,3:G3-2ch)
    WCHAR   FaxDataFileName[MY_MAX_PATH+16];  // fax data file name  @Aug/31/99 (+16 @Sep/02/99)
// <-
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


// Fax options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA  pOEMExtra;
    WCHAR   FaxNumBuf[FAXBUFSIZE256];
#ifdef FAXADDRESSBOOK
    WCHAR   FaxNumBookBuf[FAXBUFSIZE256];
#endif // FAXADDRESSBOOK
    WCHAR   FaxExtNumBuf[FAXEXTNUMBUFSIZE];
    WCHAR   FaxSendTime[FAXTIMEBUFSIZE];
    WORD    FaxReso;
    WORD    FaxCh;
// temporary save buffer ->
    DWORD   fUiOptionTmp;
    WCHAR   FaxSendTimeTmp[FAXTIMEBUFSIZE];
    WORD    FaxResoTmp;
    WORD    FaxChTmp;
// <-
} UIDATA, *PUIDATA;


// file data for UI & rendering plugin
typedef struct _FILEDATA{
    DWORD   fUiOption;          // UI option flag
} FILEDATA, *PFILEDATA;


// rendering plugin device data (separate OEMUD_EXTRADATA @Oct/05/98)
typedef struct _OEMPDEV {
    DWORD   fGeneral1;          // bit flags for RPDL general status(1)
    DWORD   fGeneral2;          // bit flags for RPDL general status(2)
    DWORD   fModel;             // bit flags for printer models
    DWORD   dwFontH_CPT;        // font height(cpt) for AssignIBMfont()  (1cpt=1/7200inch)
    DWORD   dwFontW_CPT;        // font width (cpt) for AssignIBMfont()
    WORD    FontH_DOT;          // font height(dot) for TextMode clipping
    WORD    DocPaperID;         // document papersize ID
    SHORT   nResoRatio;         // MASTERUNIT divided by resolution (short->SHORT @Sep/14/98)
    WORD    Scale;              // scaling value for offset calculation
    POINT   TextCurPos;         // TextMode current position
    POINT   PageMax;            // x:page_width, y:page_length
    POINT   Offset;             // total offset
    POINT   BaseOffset;         // offset by PrinterProperty or offset for MF530,150(e),160
    LONG    PageMaxMoveY;       // RPDL max y_position  int->LONG @Aug/28/98
    LONG    TextCurPosRealY;    // TextMode current position y without page_length adjustment
    DWORD   dwBarRatioW;        // barcode width ratio (ratio_1.0=1000)
    SHORT   nBarType;           // barcode type
    SHORT   nBarMaxLen;         // barcode character max length
    WORD    StapleType;         // staple  (0:disable,1:1staple,2:2staples)
    WORD    PunchType;          // punch   (0:disable,1:enable)
    WORD    CollateType;        // collate (0:disable,1:enable,2:uni-dir,3:rotated,4:shifted)
    WORD    MediaType;          // media type (0:standard,1:OHP,2:thick,3:special)
    WORD    BindPoint;          // staple/punch point
    WORD    Nin1RemainPage;     // remain pages in Nin1 (2in1:0-1,4in1:0-3)
    WORD    TextRectGray;       // gray percentage(1-100) of TextMode Rectangle
    POINT   TextRect;           // height & width of TextMode Rectangle
    POINT   TextRectPrevPos;    // previous position of TextMode Rectangle
    DWORD   PhysPaperWidth;     // paper width for CustomSize
    DWORD   PhysPaperLength;    // paper length for CustomSize
    DWORD   dwSrcBmpWidthByte;  // for raster data emission (width in byte)
    DWORD   dwSrcBmpHeight;     // for raster data emission (height in dot)
    PBYTE   pRPDLHeap2K;        // heap memory for OEMOutputCharStr&OEMDownloadCharGlyph @Sep/09/98
    BYTE    RPDLHeap64[HEAPSIZE64]; // 64byte heap memory
    WORD    RPDLHeapCount;      // current heap usage
#ifdef DOWNLOADFONT
    DWORD   dwDLFontUsedMem;    // used memory size for Download font
    WORD    DLFontCurGlyph;
    WORD    DLFontMaxMemKB;
    WORD    DLFontMaxID;
    WORD    DLFontMaxGlyph;
    SHORT   nCharPosMoveX;
    FONTPOS* pDLFontGlyphInfo;  // download glyph info (array->pointer @Sep/08/98)
#endif // DOWNLOADFONT
#ifdef TEXTCLIPPING
    RECT    TextClipRect;       // TextMode clipping area
#endif // TEXTCLIPPING
#ifdef DDIHOOK
    PFN     pfnUnidrv[MAX_DDI_HOOKS];   // Unidrv's hook function pointer
#endif // DDIHOOK
} OEMPDEV, *POEMPDEV;


// bit definitions of fGeneral1
#define RLE_COMPRESS_ON          0  // Raster image compression is on (<-IMAGE_NOCOMPRESS  MSKK)
#define TEXT_CLIP_VALID          1  // TextMode(font/image) clipping is valid
#define TEXT_CLIP_SET_GONNAOUT   2  // TextMode clipping-set command is going to be outputed
#define TEXT_CLIP_CLR_GONNAOUT   3  // TextMode clipping-clear command is going to be outputed
#define FONT_VERTICAL_ON         4  // vertical font mode on
#define FONT_BOLD_ON             5  // bold on
#define FONT_ITALIC_ON           6  // italic on
#define FONT_WHITETEXT_ON        7  // white text on
#define ORIENT_LANDSCAPE         8  // orientation is landscape
#define SWITCH_PORT_LAND         9  // switching portrait/landscape is needed
#define DUPLEX_LEFTMARGIN_VALID  10 // left margin at duplex printing is set
#define DUPLEX_UPPERMARGIN_VALID 11 // upper margin at duplex printing is set
#define PAPER_CUSTOMSIZE         12 // Paper is CustomSize
#define PAPER_DOUBLEPOSTCARD     13 // Paper is DoublePostcard
#define IMGCTRL_2IN1_67          14 // ImageControl:2in1(Scale 67%)
#define IMGCTRL_2IN1_100         15 // ImageControl:2in1(Scale 100%)
#define IMGCTRL_4IN1_50          16 // ImageControl:4in1(Scale 50%)
#define IMGCTRL_AA67             17 // ImageControl:A->A(Scale 67%)
#define IMGCTRL_BA80             18 // ImageControl:B->A(Scale 80%)
#define IMGCTRL_BA115            19 // ImageControl:B->A(Scale 115%)
#define DUPLEX_VALID             20 // duplex is valid
#define XM_ABS_GONNAOUT          21 // Move_X command is going to be outputed
#define YM_ABS_GONNAOUT          22 // Move_Y command is going to be outputed
#define CUSTOMSIZE_USE_LAND       23 // orientation adjustment in CustomSize
#define CUSTOMSIZE_MAKE_LAND_PORT 24 // orientation adjustment in CustomSize
#define IMGCTRL_AA141            25 // ImageControl:A->A(Scale 141%)
#define IMGCTRL_AA200            26 // ImageControl:A->A(Scale 200%)
#define IMGCTRL_AA283            27 // ImageControl:A->A(Scale 283%)
#define IMGCTRL_A1_400           28 // ImageControl:A1(Scale 400%)
//#define MEDIATYPE_OHP            29 // MediaType:Transparency(OHP)
//#define MEDIATYPE_THICK          30 // MediaType:Thick Paper
//#define MEDIATYPE_CHANGED        31 // MediaType is changed

// bit definitions of fGeneral2
//   if you modify them, don't forget to update BITCLR_BARCODE below
#define BARCODE_MODE_IN          0  // enter barcode mode
#define BARCODE_DATA_VALID       1  // barcode data is valid
#define BARCODE_FINISH           2  // barcode data is finished
#define BARCODE_CHECKDIGIT_ON    3  // add checkdigit in barcode
#define BARCODE_ROT90            4  // vartical(rotation90) barcode
#define BARCODE_ROT270           5  // vartical(rotation270) barcode
#define TEXTRECT_CONTINUE        6  // TextMode Rectangle drawing continues
#define EDGE2EDGE_PRINT          7  // Edge to Edge printing
#define LONG_EDGE_FEED           8  // Long Edge Feed at Multi Tray
#define OEM_COMPRESS_ON          9  // OEM Compress is available
#define DIVIDE_DATABLOCK         10 // Divide raster data block for SP4mkII,5,7,8

// bit definitions of fModel
//   if you modify this, don't forget to update PRODUCTS_SINCExx or follows.
#define GRP_MF530                0  // model=MF530
#define GRP_MF150                1  // model=MF150
#define GRP_MF150e               2  // model=MF150e,160
#define GRP_MFP250               3  // model=MF-P250,355,250(FAX),355(FAX),MF-FD355
#define GRP_SP4mkII              4  // model=SP4mkII,5
#define GRP_SP8                  5  // model=SP7,8,7mkII,8mkII,80
#define GRP_SP10                 6  // model=SP-10,10mkII
#define GRP_SP9                  7  // model=SP9,10Pro
#define GRP_SP9II                8  // model=SP9II,10ProII,90
#define GRP_NX100                9  // model=NX-100
#define GRP_NX500                10 // model=NX-500,1000,110,210,510,1100
//#define GRP_MFP250e              11 // model=MF-P250e,355e
#define GRP_MF250M               11 // model=MF250M
#define GRP_MF3550               12 // model=MF2700,3500,3550,4550,5550,6550,3530,3570,4570
#define GRP_MF3300               13 // model=MF3300W,3350W
#define GRP_IP1                  14 // model=IP-1
#define GRP_NX70                 15 // model=NX70
#define GRP_NX700                16 // model=NX700,600,FAX_Printer
#define GRP_MF200                17 // model=MF200,MF-p150,MF2200  (separate GRP_SP9II @Sep/01/98)
#define GRP_NX900                18 // model=NX900
#define GRP_MF1530               19 // model=MF1530,2230,2730,NX800,710,610

/// bit definitions of fUiOption
#define FAX_SEND                 0  // 1:send fax at imagio FAX
#define FAX_USEADDRESSBOOK       1  // 1:use addressbook
#define FAX_NOTRESET_UI          2  // 1:leave fax options after sending
#define FAX_SETTIME              3  // 1:reservation time available
#define FAX_SIMULPRINT           4  // 1:send fax and print simultaneously
#define FAX_RPDLCMD              5  // 1:send RPDL command
#define FAX_MH                   6  // 0:use MMR, 1:use MH
#define FAX_DONE                 7  // 1:fax done at imagio FAX (rendering plugin set this)
#define DISABLE_BAR_SUBFONT      8  // disable printing readable font under barcode
#define ENABLE_BIND_RIGHT        9  // enable stapling right side
#define ENABLE_TOMBO             10 // print TOMBO  @Sep/14/98
#define NOPERMISSION             11 // same flag as DM_NOPERMISSION  @Sep/02/99
// printer capability bit and temporary bit ->
#define OPT_NODUPLEX             16
#define OPT_VARIABLE_SCALING     17
#define FAX_MODEL                18
#define FAXMAINDLG_UPDATED       19 // 1:fax main dialog updated
#define FAXSUBDLG_UPDATED        20 // 1:fax sub dialog updated
#define FAXSUBDLG_UPDATE_APPLIED 21 // 1:fax sub dialog update applied
#define FAXSUBDLG_INITDONE       22
// <-

// staple/punch point in duplex printing(BindPoint)
#define BIND_ANY                 0
#define BIND_LEFT                1
#define BIND_RIGHT               2
#define BIND_UPPER               3

// flag bit operation
#define BIT(num)                ((DWORD)1<<(num))
#define BITCLR32(flag,num)      ((flag) &= ~BIT(num))
#define BITSET32(flag,num)      ((flag) |= BIT(num))
#define BITTEST32(flag,num)     ((flag) & BIT(num))
#define TO1BIT(flag,num)        (((flag)>>(num)) & (DWORD)1)
#define BITCPY32(dst,src,num)   ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) | BIT(num) : (DWORD)(dst) & ~BIT(num))
#define BITNCPY32(dst,src,num)  ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) & ~BIT(num) : (DWORD)(dst) | BIT(num))
#define TEST_OBJ_CHANGE(flag)   ((flag) & (BIT(BRUSH_CHANGE)|BIT(PEN_CHANGE)| \
                                           BIT(SCAN_PEN_WIDTH_1)|BIT(SCAN_PEN_WIDTH_ORG)))
#define TEST_2IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)))
#define TEST_4IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_4IN1_50)))
#define TEST_NIN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define BITCLR_NIN1_MODE(flag)  ((flag) &= ~(BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define TEST_SCALING_SEL_TRAY(flag)   ((flag) & (BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_SCALING_SEL_TRAY(flag) ((flag) &= ~(BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_BARCODE(flag)    ((flag) &= ~(BIT(BARCODE_MODE_IN)|BIT(BARCODE_DATA_VALID)| \
                                             BIT(BARCODE_FINISH)|BIT(BARCODE_CHECKDIGIT_ON)| \
                                             BIT(BARCODE_ROT90)|BIT(BARCODE_ROT270)))
#define BITCLR_UPPER_FLAG(flag) ((flag) &= 0x0000FFFF)

// models since '99
#define PRODUCTS_SINCE99        (BIT(GRP_NX900)|BIT(GRP_MF1530))
// models since '98
#define PRODUCTS_SINCE98        (BIT(GRP_MF3550)|BIT(GRP_MF3300)|BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99)
// models since '97 (delete GRP_MFP250e  @Apr/15/99)
#define PRODUCTS_SINCE97        (BIT(GRP_NX500)|BIT(GRP_MF250M)|PRODUCTS_SINCE98)
// models since '96 (add GPR_MF200 @Sep/01/98)
#define PRODUCTS_SINCE96        (BIT(GRP_SP9II)|BIT(GRP_MF200)|BIT(GRP_NX100)|PRODUCTS_SINCE97)

// capabilty of media type option(Standard, OHP, Thick)
#define TEST_CAPABLE_MEDIATYPE(flag)  ((flag) & (BIT(GRP_MF3550)|BIT(GRP_MF1530)))

// A2 printer
#define TEST_CAPABLE_PAPER_A2(flag)   ((flag) & (BIT(GRP_MF3300)))

// scailing over 141% of A2 printer/A1 plotter
#define TEST_PLOTTERMODEL_SCALING(flag)    ((flag) & (BIT(GRP_MF3300)|BIT(GRP_IP1)))

// A3 printer && CustomSize width == 297
#define TEST_CAPABLE_PAPER_A3_W297(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF3300)))

//// dual RPGL(RPGL&RPGL2) in memory card
//#define TEST_CAPABLE_DUALRPGL(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF250M)))

// A4 printer
#define TEST_CAPABLE_PAPER_A4MAX(flag)  ((flag) & (BIT(GRP_NX70)))

// capability of Select_Tray_by_Papersize("papername+X")
#define TEST_CAPABLE_PAPERX(flag)       ((flag) & (BIT(GRP_MF150e)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))

// fixed bug about reset smoothing/tonner_save_mode at ENDDOC (We must not reset SP8 series.)
#define TEST_BUGFIX_RESET_SMOOTH(flag)  ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|PRODUCTS_SINCE96))

// fixed bug about formfeed around ymax-coordinate.
#define TEST_BUGFIX_FORMFEED(flag)      ((flag) & PRODUCTS_SINCE98)

// DeltaRow Compression while TrueType font downloading
#define TEST_CAPABLE_DOWNLOADFONT_DRC(flag)  ((flag) & (BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99))

#define TEST_AFTER_SP9II(flag)  ((flag) & PRODUCTS_SINCE96)
#define TEST_AFTER_SP10(flag)   ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_AFTER_SP8(flag)    ((flag) & (BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_GRP_240DPI(flag)   ((flag) & (BIT(GRP_SP4mkII)|BIT(GRP_SP8)))
#define TEST_GRP_OLDMF(flag)    ((flag) & (BIT(GRP_MF530)|BIT(GRP_MF150)|BIT(GRP_MF150e)))
#define TEST_MAXCOPIES_99(flag) ((flag) & (BIT(GRP_SP4mkII)|BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MF150)|BIT(GRP_MF150e)|BIT(GRP_MF200)|BIT(GRP_MF250M)|BIT(GRP_IP1)))  // @Sep/01/98


// approximate value for using 10pt raster font (240dpi model) & standard width of
// barcode.
// if you make NEAR10PT_MIN less, see font-clipping at OEMOutputChar() of rpdlms.c
#define NEAR10PT_MIN                900     // 9pt
#define NEAR10PT_MAX                1110    // 11pt

// RPDL characters assigned block for AssignIBMfont()
#define IBMFONT_ENABLE_ALL          1       // <-JIS1_BLOCK @Sep/14/98
#define IBMFONT_RESUME              4       // <-INSUFFICIENT_BLOCK @Sep/14/98

// DrawTOMBO() action item  @Sep/14/98
#define INIT_TOMBO                  0
#define DRAW_TOMBO                  1

// RPDL GrayFill
#define RPDLGRAYMAX                 64
#define RPDLGRAYMIN                 2  // @Aug/15/98

// RPDL staple position
#define STAPLE_UPPERLEFT            0   // upper left
#define STAPLE_LEFT2                2   // left 2 position
#define STAPLE_RIGHT2               10  // right 2 position
#define STAPLE_UPPERRIGHT           12  // upper right
#define STAPLE_UPPER2               14  // upper 2 position
#define STAPLE_UPPERLEFT_CORNER     0   // upper left  (corner mode)
#define STAPLE_UPPERRIGHT_CORNER    3   // upper right (corner mode)

// RPDL punch position
#define PUNCH_LEFT                  0
#define PUNCH_RIGHT                 2
#define PUNCH_UPPER                 3

// collate type
#define COLLATE_OFF                 0
#define COLLATE_ON                  1
#define COLLATE_UNIDIR              2
#define COLLATE_ROTATED             3
#define COLLATE_SHIFTED             4

// media type
#define MEDIATYPE_STD               0   // Standard
#define MEDIATYPE_OHP               1   // Transparency(OHP)
#define MEDIATYPE_THICK             2   // Thick Paper
#define MEDIATYPE_SPL               3   // Special

// definition for barcode
#define BARCODE_MAX                 HEAPSIZE64  // max# of barcode character
#define BAR_UNIT_JAN                330 // 0.33mm:default module unit of JAN
#define BAR_UNIT1_2OF5              300 // 0.3mm: default module unit1 of 2of5,CODE39
#define BAR_UNIT2_2OF5              750 // 0.75mm:default module unit2 of 2of5,CODE39
#define BAR_UNIT1_NW7               210 // 0.21mm:default module unit1 of NW-7
#define BAR_UNIT2_NW7               462 // 0.462mm:default module unit2 of NW-7
#define BAR_W_MIN_5PT               504 // scaling minimum limit of 5pt
#define BAR_H_DEFAULT               10  // 10mm:default bar height
#define BAR_H_MAX                   999 // 999mm:max bar height
#define BAR_H_MIN                   1   // 1mm:min bar height

// max/min binding margin in RPDL
#define BIND_MARGIN_MAX             50
#define BIND_MARGIN_MIN             0

// variable scaling
#define VAR_SCALING_DEFAULT         100
#define VAR_SCALING_MAX             200
#define VAR_SCALING_MIN             50

// adjust distance of TOMBO
#define DEFAULT_0                   0
#define TOMBO_ADJ_MAX               50
#define TOMBO_ADJ_MIN               (-50)

// margin to disable FF by RPDL
#define DISABLE_FF_MARGIN_STD       48  // unit:masterunit
#define DISABLE_FF_MARGIN_E2E       72  // unit:masterunit  at Edge to Edge Print

// for clipping of font at paper bottom
#define CLIPHEIGHT_12PT             100 // (dot) 12pt at 600dpi

// clear clipping
#define CLIP_IFNEED                 0
#define CLIP_MUST                   1

// user defined papersize
#define USRD_W_A3_OLD               296
#define USRD_W_A3                   297
#define USRD_W_A2                   432
#define USRD_W_A4                   216
#define USRD_H_MIN148               148


// font resource # in GPD (if you reorder of PFM files at GPD, check here.)
#define EURO_FNT_FIRST              1
#define BOLDFACEPS                  2
#define EURO_MSFNT_FIRST            5
#define SYMBOL                      18
#define EURO_FNT_LAST               19      // if you change this, watch TEST_VERTICALFONT below.
#define JPN_FNT_FIRST               (EURO_FNT_LAST+1)
#define MINCHO_1                    JPN_FNT_FIRST
#define MINCHO_B1                   (JPN_FNT_FIRST+2)
#define MINCHO_E1                   (JPN_FNT_FIRST+4)
#define GOTHIC_B1                   (JPN_FNT_FIRST+6)
#define GOTHIC_M1                   (JPN_FNT_FIRST+8)
#define GOTHIC_E1                   (JPN_FNT_FIRST+10)
#define MARUGOTHIC_B1               (JPN_FNT_FIRST+12)
#define MARUGOTHIC_M1               (JPN_FNT_FIRST+14)
#define MARUGOTHIC_L1               (JPN_FNT_FIRST+16)
#define GYOSHO_1                    (JPN_FNT_FIRST+18)
#define KAISHO_1                    (JPN_FNT_FIRST+20)
#define KYOKASHO_1                  (JPN_FNT_FIRST+22)
#define MINCHO10_RAS                (JPN_FNT_FIRST+24) // for 240dpi model
#define MINCHO_3                    (JPN_FNT_FIRST+26) // for NX-100 only
#define GOTHIC_B3                   (JPN_FNT_FIRST+28) // for NX-100 only
#define AFTER_SP9II_FNT_FIRST       (JPN_FNT_FIRST+30) // MINCHO_2
#define JPN_MSPFNT_FIRST            (JPN_FNT_FIRST+54) // PMINCHO
#define JPN_FNT_LAST                (JPN_FNT_FIRST+56) // PGOTHIC

#define TEST_VERTICALFONT(id)       ((id)%2)


// Command callback IDs (Almost all IDs come from Win95/NT4 GPC.)
#define CMD_SEND_BLOCK              24  // <- CMD_SEND_BLOCK_COMPRESS  MSKK
//#define CMD_SET_CLIPRECT            25
//#define CMD_CLEAR_CLIPRECT          26
#define CMD_ENDDOC_SP4              27
#define CMD_ENDDOC_SP8              28
#define CMD_ENDDOC_SP9              29
#define CMD_ENDDOC_400DPI_MODEL     30
#define CMD_MULTI_COPIES            31
//#define CMD_BEGIN_POLYGON           32
//#define CMD_CONTINUE_POLYLINE       33
//#define CMD_CONTINUE_POLYGON        34
//#define CMD_RECTANGLE               35
//#define CMD_CIRCLE                  36
#define CMD_FF                      37
#define CMD_FONT_BOLD_ON            38
#define CMD_FONT_BOLD_OFF           39
#define CMD_FONT_ITALIC_ON          40
#define CMD_FONT_ITALIC_OFF         41
#define CMD_FONT_WHITETEXT_ON       42
#define CMD_FONT_WHITETEXT_OFF      43
#define CMD_XM_ABS                  44  // These 6 IDs must be in this order.
#define CMD_XM_REL                  45  //
#define CMD_XM_RELLEFT              46  //
#define CMD_YM_ABS                  47  //
#define CMD_YM_REL                  48  //
#define CMD_YM_RELUP                49  //
#define CMD_BEGINDOC_SP9            50
#define CMD_BEGINDOC_MF150E         51
#define CMD_RES240                  52
#define CMD_RES400                  53
#define CMD_RES600                  54
#define CMD_SELECT_PAPER_CUSTOM     55
#define CMD_SET_PORTRAIT            56
#define CMD_SET_LANDSCAPE           57
//#define CMD_SELECT_SOLID            58
//#define CMD_SELECT_HS_HORZ          59
//#define CMD_SELECT_HS_VERT          60
//#define CMD_SELECT_HS_FDIAG         61
//#define CMD_SELECT_HS_BDIAG         62
//#define CMD_SELECT_HS_CROSS         63
//#define CMD_SELECT_HS_DIAGCROSS     64
//#define CMD_DELETE_BRUSHSTYLE       65
//#define CMD_EXIT_VECT               66
#define CMD_BEGINDOC_SP4            67
#define CMD_BEGINDOC_SP8            68
#define CMD_BEGINDOC_MF530          69
//#define CMD_DUPLEX_ON               70
#define CMD_DUPLEX_VERT             71
#define CMD_DUPLEX_HORZ             72
#define CMD_SELECT_AUTOFEED         73
#define CMD_SELECT_MANUALFEED       74
#define CMD_SELECT_MULTIFEEDER      75
#define CMD_SELECT_PAPER_A6         76
#define CMD_BEGINDOC_SP9II          77
#define CMD_BEGINDOC_MF150          78
#define CMD_BEGINDOC_SP10           79
#define CMD_RLE_COMPRESS_ON         80  // <- CMD_SEND_BLOCK_NOCOMPRESS  MSKK
//#define CMD_CIRCLE_PIE              81  // These 6 IDs must be in this order.
//#define CMD_CIRCLE_ARC              82  //
//#define CMD_CIRCLE_CHORD            83  //
//#define CMD_ELLIPSE_PIE             84  //
//#define CMD_ELLIPSE_ARC             85  //
//#define CMD_ELLIPSE_CHORD           86  // 
#define CMD_BEGINDOC_MFP250         87
#define CMD_END_POLYGON             88
#define CMD_SELECT_PAPER_A3         89
#define CMD_SELECT_PAPER_A4         90
#define CMD_SELECT_PAPER_A5         91
#define CMD_SELECT_PAPER_B4         92
#define CMD_SELECT_PAPER_B5         93
#define CMD_SELECT_PAPER_B6         94
#define CMD_SELECT_PAPER_TABLOID    95
#define CMD_SELECT_PAPER_LEGAL      96
#define CMD_SELECT_PAPER_LETTER     97
#define CMD_SELECT_PAPER_STATEMENT  98
#define CMD_IMGCTRL_AA67            99
#define CMD_IMGCTRL_BA80            100
#define CMD_SELECT_PAPER_A2TOA3     101
#define CMD_SET_TEXTRECT_W          102
#define CMD_SET_TEXTRECT_H          103
#define CMD_DRAW_TEXTRECT           104
#define CMD_CR                      105
#define CMD_LF                      106
#define CMD_BS                      107
#define CMD_DRV_2IN1_67             108
#define CMD_DRV_2IN1_100            109
#define CMD_BEGINDOC_NX100          110
#define CMD_IMGCTRL_BA115           111
#define CMD_BEGINDOC_NX500          112
#define CMD_DL_SET_FONT_ID          113
#define CMD_DL_SELECT_FONT_ID       114
#define CMD_SELECT_PAPER_DOUBLEPOSTCARD 115
//#define CMD_BEGINDOC_MFP250E        116
#define CMD_BEGINDOC_MF250M         117
#define CMD_BEGINDOC_MF3550         118
#define CMD_SELECT_MULTITRAY        119
#define CMD_IMGCTRL_100             120 // These 11 IDs must be in this order.
#define CMD_IMGCTRL_88              121 //
#define CMD_IMGCTRL_80              122 //
#define CMD_IMGCTRL_75              123 //
#define CMD_IMGCTRL_70              124 //
#define CMD_IMGCTRL_67              125 //
#define CMD_IMGCTRL_115             126 //
#define CMD_IMGCTRL_122             127 //
#define CMD_IMGCTRL_141             128 //
#define CMD_IMGCTRL_200             129 //
#define CMD_IMGCTRL_50              130 //
#define CMD_DRV_4IN1_50             131
#define CMD_BEGINDOC_MF200          132 // @Sep/01/98
#define CMD_SELECT_PAPER_A2         133
#define CMD_SELECT_PAPER_C          134
#define CMD_BEGINDOC_MF3300         135
#define CMD_COMPRESS_OFF            136 // MSKK
#define CMD_BEGINDOC_IP1            137
#define CMD_SELECT_ROLL1            138
#define CMD_SELECT_ROLL2            139
#define CMD_IMGCTRL_AA141           140
#define CMD_IMGCTRL_AA200           141
#define CMD_IMGCTRL_AA283           142
#define CMD_IMGCTRL_A1_400          143
#define CMD_IMGCTRL_283             144
#define CMD_IMGCTRL_400             145
#define CMD_MEDIATYPE_STANDARD      146
#define CMD_MEDIATYPE_OHP           147
#define CMD_MEDIATYPE_THICK         148
#define CMD_REGION_STANDARD         149
#define CMD_REGION_EDGE2EDGE        150
#define CMD_SELECT_STAPLE_NONE      151
#define CMD_SELECT_STAPLE_1         152
#define CMD_SELECT_STAPLE_2         153
#define CMD_SELECT_PUNCH_NONE       154
#define CMD_SELECT_PUNCH_1          155
#define CMD_DRAW_TEXTRECT_REL       156
#define CMD_DL_SET_FONT_GLYPH       157
#define CMD_SET_MEM0KB              158
#define CMD_SET_MEM128KB            159
#define CMD_SET_MEM256KB            160
#define CMD_SET_MEM512KB            161
#define CMD_BEGINDOC_NX70           164
#define CMD_SELECT_PAPER_B3         165
#define CMD_SELECT_PAPER_A3TOA4     166
#define CMD_SELECT_PAPER_B4TOA4     167
#define CMD_SELECT_PAPER_POSTCARD   168
#define CMD_SET_BASEOFFSETX_0       169
#define CMD_SET_BASEOFFSETX_1       170
#define CMD_SET_BASEOFFSETX_2       171
#define CMD_SET_BASEOFFSETX_3       172
#define CMD_SET_BASEOFFSETX_4       173
#define CMD_SET_BASEOFFSETX_5       174
#define CMD_SET_BASEOFFSETY_0       175
#define CMD_SET_BASEOFFSETY_1       176
#define CMD_SET_BASEOFFSETY_2       177
#define CMD_SET_BASEOFFSETY_3       178
#define CMD_SET_BASEOFFSETY_4       179
#define CMD_SET_BASEOFFSETY_5       180
#define CMD_SET_LONG_EDGE_FEED      181
#define CMD_SET_SHORT_EDGE_FEED     182
#define CMD_OEM_COMPRESS_ON         183
#define CMD_SET_SRCBMP_W            184
#define CMD_SET_SRCBMP_H            185
#define CMD_BEGINDOC_NX700          186
#define CMD_SET_COLLATE_OFF         187
#define CMD_SET_COLLATE_ON          188
#define CMD_SELECT_COLLATE_UNIDIR   189
#define CMD_SELECT_COLLATE_ROTATED  190
#define CMD_DRAW_TEXTRECT_WHITE     191 // MSKK  Aug/14/98
#define CMD_DRAW_TEXTRECT_WHITE_REL 192
#define CMD_SELECT_COLLATE_SHIFTED  193
#define CMD_BEGINDOC_NX900          194
#define CMD_BEGINDOC_MF1530         195
#define CMD_MEDIATYPE_SPL           196
#define CMD_RES1200                 197
#define CMD_SELECT_STAPLE_MAX1      198

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\prp\mkprpufm.c ===
/*
 *      mkwidth - Make WIDTHTABLE on ufm for Prop. DBCS device fonts.
 *
 *      TODO:
 *
 *      HISTORY:
 *
 *      9/4/98 yasuho           Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <prntfont.h>

typedef struct _GLYPHTABLE {
        WCHAR           wCode;
        WORD            wCount;
        WORD            wGID;
} GLYPHTABLE, *PGLYPHTABLE;

DWORD           ufmsize, gttsize;
DWORD           wtoffset;
DWORD           runsize;
PGLYPHTABLE     pGlyph;
UNIFM_HDR       ufm;
IFIMETRICS      IFI;
UNI_GLYPHSETDATA        gtt;
WIDTHTABLE      WidthTable;
PWIDTHRUN       pWidthRun;
DWORD           nWidthRun;
DWORD           loWidth;
PWORD           pWidth;
WORD            nWidth;

static int      vflag;
static int      Vflag;
static char     rbuf[256];

static void usage();
static void fatal(char *s);
static void error(char *s);

static void checkufm(char *name)
{
        FILE            *fp;
        struct _stat    sb;

        if (_stat(name, &sb) < 0)
                fatal(name);
        ufmsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fread ufmhdr");
        if (ufm.dwSize != ufmsize)
                error("Invalid ufmsize");
        if (ufm.loWidthTable != 0)
                error("loWidthTable != 0");
        fclose(fp);
}

static void getgtt(char *name)
{
        FILE            *fp;
        WORD            GID;
        DWORD           i;
        struct _stat    sb;
        GLYPHRUN        run;

        if (_stat(name, &sb) < 0)
                fatal(name);
        gttsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&gtt, sizeof gtt, 1, fp) != 1)
                fatal(name);
        if (gtt.dwSize != gttsize)
                error("Invalid gttsize");

        runsize = gtt.dwRunCount * sizeof(GLYPHTABLE);
        if ((pGlyph = malloc(runsize)) == NULL)
                fatal("GLYPHTABLE");
        if (fseek(fp, gtt.loRunOffset, 0) < 0)
                fatal("loRunOffset");
        GID = 1;
        if (vflag) {
                printf("=== GTT ===\n");
                printf("Code\tCount\tGLYPHID\n");
                printf("---\t---\t---\n");
        }
        for (i = 0; i < gtt.dwRunCount; i++) {
                if (fread(&run, sizeof run, 1, fp) != 1)
                        fatal("GLYPHRUN");
                pGlyph[i].wCode = run.wcLow;
                pGlyph[i].wCount = run.wGlyphCount;
                pGlyph[i].wGID = GID;
                GID += run.wGlyphCount;
                if (vflag)
                        printf("0x%04x\t%d\t%ld\n", pGlyph[i].wCode,
                                pGlyph[i].wCount, pGlyph[i].wGID);
        }

        fclose(fp);
}

static WORD uni2gid(WORD code)
{
        DWORD           i;
        PGLYPHTABLE     p;

        for (i = 0, p = pGlyph; i < gtt.dwRunCount; i++, p++) {
                if (code >= p->wCode && code < p->wCode + p->wCount)
                        return p->wGID + (code - p->wCode);
        }
        return 0;
}

static void getdef(char *name)
{
        FILE            *fp;
        int             res;
        WORD            uni, width, count, v1, v2;
        WORD            GID, curGID;
        DWORD           i, j, line;
        PWORD           p;
        char            buf[80];

        if ((fp = fopen(name, "r")) == NULL)
                fatal(name);

        curGID = 0;
        nWidth = 0;
        count = 0;
        line = 0;
        while (fgets(rbuf, sizeof rbuf, fp)) {
                line++;
                if (!isxdigit(rbuf[0]))
                        continue;
                if ((res = sscanf(rbuf, "%x %d %d", &uni, &v1, &v2)) != 3) {
                        sprintf(buf, "sscanf=%d", res);
                        error(buf);
                }
                width = Vflag ? -v2 : v1;
                if ((GID = uni2gid(uni)) == 0) {
                        sprintf(buf, "Invalid code: %04x", uni);
                        error(buf);
                }
                if (GID <= curGID) {
                        sprintf(buf, "dup code: Line:%d: Uni=%d,GID=%d",
                                line, uni, GID);
                        error(buf);
                }
                if (curGID == 0 || GID != curGID + 1) {
                        if (pWidthRun == NULL) {
                                if ((pWidthRun = malloc(sizeof(*pWidthRun))) ==
                                        NULL)
                                        fatal("malloc pWidthRun");
                        } else {
                                pWidthRun[nWidthRun].wGlyphCount = count;
                                nWidthRun++;
                                if ((pWidthRun = realloc(pWidthRun,
                                        sizeof(*pWidthRun) * (nWidthRun + 1)))
                                        == NULL)
                                        fatal("realloc pWidthRun");
                        }
                        pWidthRun[nWidthRun].wStartGlyph = GID;
                        count = 0;
                }
                if (pWidth == NULL) {
                        if ((pWidth = malloc(sizeof(*pWidth))) == NULL)
                                fatal("malloc pWidth");
                } else {
                        if ((pWidth = realloc(pWidth, sizeof(*pWidth) *
                                (nWidth + 1))) == NULL)
                                fatal("realloc pWidth");
                }
                pWidth[nWidth] = width;
                nWidth++;
                count++;
                curGID = GID;
        }
        if (nWidth) {
                pWidthRun[nWidthRun].wGlyphCount = count;
                nWidthRun++;
        }

        if (vflag) {
                printf("\n=== WIDTHRUN ===\n");
                p = pWidth;
                for (i = 0; i < nWidthRun; i++) {
                        count = pWidthRun[i].wGlyphCount;
                        printf("Glyph=%-5d , Count=%-5d\n",
                                pWidthRun[i].wStartGlyph, count);
                        for (j = 0; j < count; j++)
                                printf("\tWidth[%5d]=%d\n", j, *p++);
                }
        }

        fclose(fp);
}

static void buildufm(char *name)
{
        FILE            *fp;
        DWORD           off, size;
        DWORD           i;
        PWIDTHRUN       pRun;

        if ((fp = fopen(name, "r+b")) == NULL)
                fatal(name);

#if 1 // v-masatk Oct/30/98
        ufm.loWidthTable = 0;
        off = ufmsize;
#else
        ufm.loWidthTable = off = ufmsize;
#endif // if 1 else end
        if (fwrite(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fwrite ufmhdr");

        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fread(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fread IFIMETRICS");
        IFI.flInfo &= ~(FM_INFO_OPTICALLY_FIXED_PITCH|FM_INFO_DBCS_FIXED_PITCH);
        IFI.jWinPitchAndFamily |= VARIABLE_PITCH;
        IFI.jWinPitchAndFamily &= ~FIXED_PITCH;
        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fwrite(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fwrite IFIMETRICS");
#if 0 // v-masatk Oct/30/98
        if (fseek(fp, off, 0) < 0)
                fatal(name);
        WidthTable.dwSize = sizeof(WidthTable) + sizeof(WIDTHRUN) *
                (nWidthRun - 1);
        WidthTable.dwRunNum = nWidthRun;
        size = sizeof(WidthTable) - sizeof(WIDTHRUN);
        if (fwrite(&WidthTable, size, 1, fp) != 1)
                fatal("fwrite WidthTable");
        off = WidthTable.dwSize;

        for (i = 0, pRun = pWidthRun; i < nWidthRun; i++, pRun++) {
                pRun->loCharWidthOffset = off;
                off += sizeof(*pWidth) * pRun->wGlyphCount;
        }
        if (fwrite(pWidthRun, sizeof(WIDTHRUN) * nWidthRun, 1, fp) != 1)
                fatal("fwrite WidthRun");
        if (fwrite(pWidth, sizeof(*pWidth) * nWidth, 1, fp) != 1)
                fatal("fwrite *pWidth");
#endif // if 0
}

void __cdecl main(int argc, char *argv[])
{
        argc--, argv++;
        for (; argc && **argv == '-'; argc--, argv++) switch (argv[0][1]) {
        case 'v':
                vflag++;
                break;
        case 'V':
                Vflag++;
                break;
        }
#if 0 // v-masatk Oct/30/98
        if (argc != 3)
                usage();

#endif // if 0
        checkufm(argv[0]);
#if 0 // v-masatk Oct/30/98
        getgtt(argv[1]);
        getdef(argv[2]);
#endif // if 0
        buildufm(argv[0]);

        exit(0);
}

static char     Usage[] = "Usage: %s [-v][-V] ufm-file gtt-file def-file\n";
static char     CmdName[] = "mkwidth";

static void usage()
{
        fprintf(stderr, Usage, CmdName);
        exit(1);
}

static void fatal(char *s)
{
        fprintf(stderr, "%s: ", CmdName);
        perror(s);
        exit(1);
}

static void error(char *s)
{
        fprintf(stderr, "%s: %s\n", CmdName, s);
        exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv
                OEM rendering plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
        98/4/24 takashim:
        Written the original sample so that it is more C++.
        99/2/16 Masatoshi Kubokura:
        Last modified for Windows2000.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMEnableDriver(dwDriverVersion, cbSize, pded); // @Oct/05/98

        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMDisableDriver(); // @Oct/05/98
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
// @Oct/06/98 ->
//      return E_NOTIMPL;
        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //
//        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;

        *pDevOem = pTemp;
        return S_OK;
// @Oct/06/98 <-
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
// @Oct/05/98 ->
//      return E_NOTIMPL;
        OEMDisablePDEV(pdevobj);
        return S_OK;
// @Oct/05/98 <-
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
// @Oct/05/98 ->
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
// @Oct/05/98 <-
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
// @Sep/10/98 ->
//          pIUnknown->AddRef();
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void**)&(this->pOEMHelp));
            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }
//      this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
// @Sep/10/98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
// FilterGraphics disables other compression!  @Feb/16/99 ->
#if 0   // SP8BUGFIX_RASTER
        OEMFilterGraphics(pdevobj, pBuf, dwLen);    // @Feb/09/99
        return S_OK;
#else
        return E_NOTIMPL;
#endif // 'if 0 - else'
// @Feb/16/99 <-
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
// @Jul/29/98 ->
//      return E_NOTIMPL;
        if (0 < (*piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
// @Jul/29/98 <-
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\rpdlres\nt4\rpdlres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

FILE:           RPDLRES.C

Abstract:       Main file for OEM rendering plugin module.

Functions:      OEMCommandCallback
                OEMSendFontCmd
                OEMOutputCharStr
                OEMDownloadFontHeader
                OEMDownloadCharGlyph
                OEMTTDownloadMethod
                OEMCompression

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    08/11/97 -Masatoshi Kubokura-
        Began to modify for RPDL.
    04/22/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.

--*/

#include <stdio.h>
#include "pdev.h"

#if 0  // DBG
//#define DBG_OUTPUTCHARSTR 1
#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif

//
// Misc definitions and declarations.
//
#define STDVAR_BUFSIZE(n) \
    (sizeof (GETINFO_STDVAR) + sizeof(DWORD) * 2 * ((n) - 1))  // MSKK 1/24/98
#define MASTER_TO_SPACING_UNIT(p, n) \
    ((n) / (p)->nResoRatio)
#ifndef WINNT_40
#define sprintf     wsprintfA   // @Sep/30/98
#define strcmp      lstrcmpA    // @Sep/30/98
#endif // WINNT_40

// External Functions' prototype
// @Aug/31/99 ->
//extern BOOL RWFileData(PFILEDATA pFileData, LONG type);
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);
// @Aug/31/99 <-

// Local Functions' prototype
static BYTE IsDBCSLeadByteRPDL(BYTE Ch);
static BYTE IsDifferentPRNFONT(BYTE Ch);
static VOID DrawTOMBO(PDEVOBJ pdevobj, SHORT action);
static VOID AssignIBMfont(PDEVOBJ pdevobj, SHORT rcID, SHORT action);
static VOID SendFaxNum(PDEVOBJ pdevobj);
#ifdef TEXTCLIPPING
static VOID ClearTextClip(PDEVOBJ pdevobj, WORD flag);
#endif // TEXTCLIPPING
#ifdef JISGTT
static VOID jis2sjis(BYTE jis[], BYTE sjis[]);
#endif // JISGTT
static INT DRCompression(PBYTE pInBuf, PBYTE pOutBuf, DWORD dwInLen, DWORD dwOutLen,
                         DWORD dwWidthByte, DWORD dwHeight);

//
// Static data to be used by this minidriver.
//

static BYTE ShiftJisRPDL[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

// Some vertical device font differ from TrueType font
static BYTE VerticalFontCheck[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,  //70
        1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,  //80
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  //D0
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //E0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   //F0
};

static BYTE UpdateDate[] = "09/27/99";

// OBSOLETE (described in GPD) @Feb/15/98 ->
// Emulation Mode after printing
//static BYTE *RPDLProgName[] = {
//    "1@R98", "1@R16", "1@RPS", "1@R55",                         //  0- 3
//    "1@RGL", "1@GL2", "1@R52", "1@R73",                         //  4- 7
//    "1@R35", "1@R01",                                           //  8- 9
//    "0@P1",  "0@P2",  "0@P3",  "0@P4",                          // 10-13
//    "0@P5",  "0@P6",  "0@P7",  "0@P8",                          // 14-17
//    "0@P9",  "0@P10", "0@P11", "0@P12",                         // 18-21
//    "0@P13", "0@P14", "0@P15", "0@P16"                          // 22-25
//};
//static BYTE *RPDLProgName2[] = {
//    "-1,1,1@R98", "-1,1,1@R16", "-1,1,1@RPS", "-1,1,1@R55",     //  0- 3
//    "-1,1,1@RGL", "-1,1,1@GL2", "-1,1,1@R52", "-1,1,1@R73",     //  4- 7
//    "-1,1,1@R35", "-1,1,1@R01",                                 //  8- 9
//    "0,1,2@P1",   "0,1,2@P2",   "0,1,2@P3",   "0,1,2@P4",       // 10-13
//    "0,1,2@P5",   "0,1,2@P6",   "0,1,2@P7",   "0,1,2@P8",       // 14-17
//    "0,1,2@P9",   "0,1,2@P10",  "0,1,2@P11",  "0,1,2@P12",      // 18-21
//    "0,1,2@P13",  "0,1,2@P14",  "0,1,2@P15",  "0,1,2@P16"       // 22-25
//};
//#define PRG_RPGL    4
// @Feb/15/98 <-

// RPDL pagesize (unit:masterunit)
static POINT RPDLPageSize[] = {
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3
    {1872L*MASTERUNIT/240L, 2720L*MASTERUNIT/240L},  // A4
    {1280L*MASTERUNIT/240L, 1904L*MASTERUNIT/240L},  // A5
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L},  // A6
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4
    {1600L*MASTERUNIT/240L, 2352L*MASTERUNIT/240L},  // B5
    {1104L*MASTERUNIT/240L, 1640L*MASTERUNIT/240L},  // B6
    {2528L*MASTERUNIT/240L, 4000L*MASTERUNIT/240L},  // Tabloid
    {1920L*MASTERUNIT/240L, 3280L*MASTERUNIT/240L},  // Legal
    {1920L*MASTERUNIT/240L, 2528L*MASTERUNIT/240L},  // Letter
    {1200L*MASTERUNIT/240L, 1968L*MASTERUNIT/240L},  // Statement
    {3969L*MASTERUNIT/240L, 5613L*MASTERUNIT/240L},  // A2->A3
    {6480L*MASTERUNIT/400L, 8960L*MASTERUNIT/400L},  // A2
    {6667L*MASTERUNIT/400L, 8448L*MASTERUNIT/400L},  // C
    {5587L*MASTERUNIT/400L, 7792L*MASTERUNIT/400L},  // B3      @Jan/07/98
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3->A4  @Feb/04/98
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4->A4  @Feb/04/98
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L}   // Postcard since NX700 @Feb/13/98
};
#define PAGESPACE_2IN1_100  12      // mm
static WORD PageSpace_2IN1_67[] = {
    30, 23, 22, 18,     // A3,A4,A5,A6
    25, 23, 19, 56,     // B4,B5,B6,Tabloid
     6,  6, 35,  6,     // Legal(disable),Letter,Statement,A2->A3(disable)
     6,  6,  6,  6,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     6,  6              // B4->A4(disable),Postcard(disable)
};

static POINT RPDLPageSizeE2E[] = {
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3
    {(2100000L/254L+5L)/10L*MASTERUNIT/100L, (2970000L/254L+5L)/10L*MASTERUNIT/100L},  // A4
    {(1480000L/254L+5L)/10L*MASTERUNIT/100L, (2100000L/254L+5L)/10L*MASTERUNIT/100L},  // A5
    {(1050000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L},  // A6
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4
    {(1820000L/254L+5L)/10L*MASTERUNIT/100L, (2570000L/254L+5L)/10L*MASTERUNIT/100L},  // B5
    {(1280000L/254L+5L)/10L*MASTERUNIT/100L, (1820000L/254L+5L)/10L*MASTERUNIT/100L},  // B6
    {110L*MASTERUNIT/10L, 170L*MASTERUNIT/10L},                                        // Tabloid
    { 85L*MASTERUNIT/10L, 140L*MASTERUNIT/10L},                                        // Legal
    { 85L*MASTERUNIT/10L, 110L*MASTERUNIT/10L},                                        // Letter
    { 55L*MASTERUNIT/10L,  85L*MASTERUNIT/10L},                                        // Statement
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2->A3
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2
    {170L*MASTERUNIT/10L, 220L*MASTERUNIT/10L},                                        // C
    {(3640000L/254L+5L)/10L*MASTERUNIT/100L, (5140000L/254L+5L)/10L*MASTERUNIT/100L},  // B3
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3->A4
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4->A4
    {(1000000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L}   // Postcard since NX700
};
#define PAGESPACE_2IN1_100E2E  0    // mm
static WORD PageSpace_2IN1_67E2E[] = {
    18, 11, 10,  6,     // A3,A4,A5,A6
    15, 11,  9, 43,     // B4,B5,B6,Tabloid
     0,  0, 23,  0,     // Legal(disable),Letter,Statement,A2->A3(disable)
     0,  0,  0,  0,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     0,  0              // B4->A4(disable),Postcard(disable)
};

#define RPDL_A3     0
#define RPDL_A4     1
#define RPDL_A5     2
#define RPDL_A6     3   // A6/Postcard
#define RPDL_B4     4
#define RPDL_B5     5
#define RPDL_B6     6
#define RPDL_TABD   7
#define RPDL_LEGL   8
#define RPDL_LETR   9
#define RPDL_STAT   10
#define RPDL_A2A3   11
#define RPDL_A2     12
#define RPDL_C      13
#define RPDL_B3     14
#define RPDL_A3A4   15
#define RPDL_B4A4   16
#define RPDL_POSTCARD   17  // Postcard since NX700  (17<-14 @Feb/22/99)
#define RPDL_CUSTOMSIZE 99

// RPDL command definition
static BYTE BS[]                  = "\x08";
static BYTE FF[]                  = "\x0C";
static BYTE CR[]                  = "\x0D";
static BYTE LF[]                  = "\x0A";
static BYTE DOUBLE_BS[]           = "\x08\x08";
static BYTE DOUBLE_SPACE[]        = "\x20\x20";
static BYTE BEGIN_SEND_BLOCK_C[]  = "\x1B\x12G3,%d,%d,,2,,,%u@";
static BYTE BEGIN_SEND_BLOCK_NC[] = "\x1B\x12G3,%d,%d,,,@";
static BYTE BEGIN_SEND_BLOCK_DRC[] = "\x1B\x12G3,%d,%d,,5,,@";
static BYTE ESC_ROT0[]            = "\x1B\x12\x46\x30\x20";
static BYTE ESC_ROT90[]           = "\x1B\x12\x46\x39\x30\x20";
static BYTE ESC_VERT_ON[]         = "\x1B\x12&2\x20";
static BYTE ESC_VERT_OFF[]        = "\x1B\x12&1\x20";
static BYTE ESC_SHIFT_IN[]        = "\x1B\x0F";
static BYTE ESC_SHIFT_OUT[]       = "\x1B\x0E";
static BYTE ESC_CTRLCODE[]        = "\x1B\x12K1\x20";
static BYTE ESC_HALFDOWN[]        = "\x1B\x55";
static BYTE ESC_HALFUP[]          = "\x1B\x44";
static BYTE ESC_DOWN[]            = "\x1B\x55\x1B\x55";
static BYTE ESC_UP[]              = "\x1B\x44\x1B\x44";
static BYTE ESC_BOLD_ON[]         = "\x1BO";
static BYTE ESC_BOLD_OFF[]        = "\x1B&";
static BYTE ESC_ITALIC_ON[]       = "\x1B\x12I-16\x20";
static BYTE ESC_ITALIC_OFF[]      = "\x1B\x12I0\x20";
static BYTE ESC_WHITETEXT_ON[]    = "\x1B\x12W5,0\x20";
static BYTE ESC_WHITETEXT_OFF[]   = "\x1B\x12W0,0\x20";
static BYTE ESC_XM_ABS[]          = "\x1B\x12H%d\x20";
static BYTE ESC_XM_REL[]          = "\x1B\x12\x20+%d\x20";
static BYTE ESC_XM_RELLEFT[]      = "\x1B\x12\x20-%d\x20";
static BYTE ESC_YM_ABS[]          = "\x1B\x12V%d\x20";
static BYTE ESC_YM_REL[]          = "\x1B\x12\x0A+%d\x20";
static BYTE ESC_YM_RELUP[]        = "\x1B\x12\x0A-%d\x20";
static BYTE ESC_CLIPPING[]        = "\x1B\x12*%d,%d,%d,%d\x20";
static BYTE SELECT_PAPER_CUSTOM[] = "\x1B\x12\x3F\x35%ld,%ld\x1B\x20";
static BYTE SELECT_PAPER_HEAD[]   = "\x1B\x12\x35\x32@";
static BYTE SEL_TRAY_PAPER_HEAD[] = "\x1B\x12\x35@";
static BYTE SELECT_PAPER_HEAD_IP1[] = "\x1B\x12\x35\x33@";
static BYTE SELECT_PAPER_A1[]     = "A1\x1B\x20";
static BYTE SELECT_PAPER_A2[]     = "A2\x1B\x20";
static BYTE SELECT_PAPER_A3[]     = "A3\x1B\x20";
static BYTE SELECT_PAPER_A4[]     = "A4\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A4R[]    = "A4R\x1B\x20";
static BYTE SELECT_PAPER_A4X[]    = "A4X\x1B\x20";
static BYTE SELECT_PAPER_A4W[]    = "A4R\x1B\x20\x1B\x12\x35@A4\x1B\x20";
static BYTE SELECT_PAPER_A5[]     = "A5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A5R[]    = "A5R\x1B\x20";
static BYTE SELECT_PAPER_A5X[]    = "A5X\x1B\x20";
static BYTE SELECT_PAPER_A5W[]    = "A5R\x1B\x20\x1B\x12\x35@A5\x1B\x20";
static BYTE SELECT_PAPER_A6[]     = "A6\x1B\x20";
static BYTE SELECT_PAPER_PC[]     = "PC\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_PCR[]    = "PCR\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_PCX[]    = "PCX\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_B3[]     = "B3\x1B\x20";   // @Jan/07/98
static BYTE SELECT_PAPER_B4[]     = "B4\x1B\x20";
static BYTE SELECT_PAPER_B5[]     = "B5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_B5R[]    = "B5R\x1B\x20";
static BYTE SELECT_PAPER_B5X[]    = "B5X\x1B\x20";
static BYTE SELECT_PAPER_B5W[]    = "B5R\x1B\x20\x1B\x12\x35@B5\x1B\x20";
static BYTE SELECT_PAPER_B6[]     = "B6\x1B\x20";
static BYTE SELECT_PAPER_C[]      = "FLT\x1B\x20";
static BYTE SELECT_PAPER_TABD[]   = "DLT\x1B\x20";
static BYTE SELECT_PAPER_LEGL[]   = "LG\x1B\x20";
static BYTE SELECT_PAPER_LETR[]   = "LT\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_LETRR[]  = "LTR\x1B\x20";
static BYTE SELECT_PAPER_LETRX[]  = "LTX\x1B\x20";
static BYTE SELECT_PAPER_LETRW[]  = "LTR\x1B\x20\x1B\x12\x35@LT\x1B\x20";
static BYTE SELECT_PAPER_STAT[]   = "HL\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_STATR[]  = "HLR\x1B\x20";
static BYTE SELECT_PAPER_STATX[]  = "HLX\x1B\x20";
static BYTE SELECT_PAPER_STATW[]  = "HLR\x1B\x20\x1B\x12\x35@HLT\x1B\x20";
static BYTE SET_LIMITLESS_SUPPLY[]= "\x1B\x12Z2\x20";
static BYTE SELECT_MANUALFEED[]   = "\x1B\x19T";
static BYTE SELECT_MULTIFEEDER[]  = "\x1B\x19M";
static BYTE SELECT_ROLL1[]        = "\x1B\x12Y1,2\x20";
static BYTE SELECT_ROLL2[]        = "\x1B\x12Y1,4\x20";
//static BYTE SET_EMULATION[]       = "\x1B\x12!%s\x1B\x20";
//static BYTE SET_EMULATION_GL_EX[] = "MS-1,6,11;";
static BYTE SET_PORTRAIT[]        = "\x1B\x12\x44\x31\x20";
static BYTE SET_LANDSCAPE[]       = "\x1B\x12\x44\x32\x20";
static BYTE SET_LEFTMARGIN[]      = "\x1B\x12YK,%d\x20";
static BYTE SET_UPPERMARGIN[]     = "\x1B\x12YL,%d\x20";
static BYTE SET_LEFTMARGIN_9II[]  = "\x1B\x12?Y,K:%d\x1B\x20";
static BYTE SET_UPPERMARGIN_9II[] = "\x1B\x12?Y,L:%d\x1B\x20";
static BYTE SET_MULTI_COPY[]      = "\x1B\x12N%d\x20";
// DCR:MF3550 RPDL  @Feb/22/99 ->
// Since 'backslash' can't be printed in Japanese region ('KUNIBETSU'),
// set 1st param to 1 for USA region.
//static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@,,1\x1B\x20";
static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@1,,1\x1B\x20";
// @Feb/22/99 <-
static BYTE SET_PAGEMAX_VALID[]   = "\x1B\x12?+1\x1B\x20";
static BYTE DUPLEX_ON[]           = "\x1B\x12\x36\x31,1\x20";
static BYTE DUPLEX_HORZ[]         = "\x1B\x12YA3,1\x20";
static BYTE DUPLEX_VERT[]         = "\x1B\x12YA3,2\x20";
static BYTE DUPLEX_VERT_R[]       = "\x1B\x12YA3,3\x20";
//static BYTE IMAGE_2IN1[]          = "\x1B\x12\x36\x32,\x20";
static BYTE IMAGE_OPT_OFF[]       = "\x1B\x12\x36\x30,1,0\x20";
static BYTE IMAGE_SCALING_100[]   = "\x1B\x12YM,1\x20";
static BYTE IMAGE_SCALING_88[]    = "\x1B\x12YM,2\x20";
static BYTE IMAGE_SCALING_80[]    = "\x1B\x12YM,3\x20";
static BYTE IMAGE_SCALING_75[]    = "\x1B\x12YM,4\x20";
static BYTE IMAGE_SCALING_70[]    = "\x1B\x12YM,5\x20";
static BYTE IMAGE_SCALING_67[]    = "\x1B\x12YM,6\x20";
static BYTE IMAGE_SCALING_115[]   = "\x1B\x12YM,7\x20";
static BYTE IMAGE_SCALING_122[]   = "\x1B\x12YM,8\x20";
static BYTE IMAGE_SCALING_141[]   = "\x1B\x12YM,9\x20";
static BYTE IMAGE_SCALING_200[]   = "\x1B\x12YM,10\x20";
static BYTE IMAGE_SCALING_283[]   = "\x1B\x12YM,11\x20";
static BYTE IMAGE_SCALING_400[]   = "\x1B\x12YM,12\x20";
static BYTE IMAGE_SCALING_122V[]  = "\x1B\x12?M122,1\x1B\x20";  // variable ratio
static BYTE IMAGE_SCALING_141V[]  = "\x1B\x12?M141,1\x1B\x20";
static BYTE IMAGE_SCALING_200V[]  = "\x1B\x12?M200,1\x1B\x20";
static BYTE IMAGE_SCALING_50V[]   = "\x1B\x12?M50,1\x1B\x20";
static BYTE IMAGE_SCALING_VAR[]   = "\x1B\x12?M%d,1\x1B\x20";

static BYTE SET_PAPERDEST_OUTTRAY[]  = "\x1B\x12\x38\x33,2\x20";
static BYTE SET_PAPERDEST_FINISHER[] = "\x1B\x12\x38\x46,2,1\x20";
// RPDL SPEC changed at NX900. @Jan/08/99 ->
//static BYTE SET_SORT_ON[]            = "\x1B\x12\x36,,1\x20";
static BYTE SET_SORT_ON[]            = "\x1B\x12\x36%d,,1\x20";
// @Jan/08/99 <-
static BYTE SET_STAPLE_ON[]          = "\x1B\x12?O22,0,%d\x1B\x20";
static BYTE SET_STAPLE_CORNER_ON[]   = "\x1B\x12?O22,1,%d\x1B\x20";
static BYTE SET_PUNCH_ON[]           = "\x1B\x12?O32,%d\x1B\x20";
static BYTE SELECT_MEDIATYPE_STD[]   = "\x1B\x12?6%c,0\x1B\x20";
static BYTE SELECT_MEDIATYPE_THICK[] = "\x1B\x12?6%c,1\x1B\x20";
static BYTE SELECT_MEDIATYPE_OHP[]   = "\x1B\x12?6%c,2\x1B\x20";
static BYTE SELECT_MEDIATYPE_SPL[]   = "\x1B\x12?6%c,3\x1B\x20";    // @Mar/03/99
static BYTE COLLATE_DISABLE_ROT[]    = "\x1B\x12?O11\x1B\x20";      // @May/27/98
static BYTE COLLATE_ENABLE_ROT[]     = "\x1B\x12?O12\x1B\x20";      // @Jul/31/98

static BYTE SET_TEXTRECT_BLACK[]  = "\x1B\x12P3,64\x20";
static BYTE SET_TEXTRECT_WHITE[]  = "\x1B\x12W0,3\x20\x1B\x12P3,1\x20"; // @Aug/15/98
static BYTE SET_TEXTRECT_GRAY[]   = "\x1B\x12P3,%d,1\x20";          // add ",1" @Aug/15/98
static BYTE DRAW_TEXTRECT[]       = "\x1B\x12R%d,%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P3[]  = "\x1B\x12r%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P4[]  = "\x1B\x12r%d,%d,%d,%d\x20";

static BYTE BEGINDOC1[]           = "\x1B\x12!1@R00\x1B\x20\x1B\x34\x1B\x12YJ,3\x20";
static BYTE BEGINDOC2_1[]         = "\x1B\x12YP,1\x20\x1B\x12YQ,2\x20";
static BYTE BEGINDOC2_2[]         = "\x1B\x12YQ,2\x20";
static BYTE BEGINDOC3[]           = "\x1B\x12YA6,1\x20";
static BYTE SELECT_RES240_1[]     = "\x1B\x12YI,6\x20";
static BYTE SELECT_RES240_2[]     = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20\x1B\x12#3\x20";
static BYTE SELECT_RES400_1[]     = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,7\x20\x1B\x12YW,1\x20";
static BYTE SELECT_RES400_2[]     = "\x1B\x12YA4,1\x20";
static BYTE SELECT_RES400_3[]     = "\x1B\x12#2\x20";
static BYTE SELECT_RES600[]       = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,8\x20\x1B\x12YW,3\x20\x1B\x12YA4,3\x20\x1B\x12#4\x20";
static BYTE SELECT_RES1200[]      = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,9\x20\x1B\x12YW,4\x20\x1B\x12YA4,4\x20\x1B\x12#5\x20";  // @Mar/02/99
static BYTE SELECT_REGION_STD[]   = "\x1B\x12YB,1\x20";
static BYTE SELECT_REGION_E2E[]   = "\x1B\x12YB,2\x20";
static BYTE ENDDOC1[]             = "\x1B\x12YB,1\x20\x1B\x12YI,1\x20\x1B\x12YJ,1\x20\x1B\x12YM,1\x20";
static BYTE ENDDOC2_240DPI[]      = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20";
static BYTE ENDDOC2_SP9[]         = "\x1B\x12YW,2\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC2_400DPI[]      = "\x1B\x12YW,1\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC3[]             = "\x1B\x12#0\x20";
static BYTE ENDDOC4[]             = "\x1B\x12\x36\x30,0,0\x20";
static BYTE ENDDOC4_FINISHER[]    = "\x1B\x12\x36\x30,0\x20";
static BYTE ENDDOC_JOBDEF_END[]   = "\x1B\x12?JE@\x1B@\x1B@\x1B@\x1B@\x1B\x20"; // @Jan/08/99
static BYTE ENDDOC5[]             = "\x1B\x1AI";
static BYTE SELECT_SMOOTHING2[]   = "\x1B\x12YA2,2\x20";
// If you change FONT_NAME, see AssignIBMfont().
static BYTE SET_IBM_FONT_SCALE[]  = "\x1B\x12\x43%d,M,%ld,%ld,4@I55\x20";
static BYTE SET_IBM_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43%d,M,,%ld,4@I55\x20";    // @Jan/29/99
static BYTE *SET_IBM_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-E B\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-M\x1B\x20",
                                     "GOTHIC-E B\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-M\x1B\x20",
                                     "MARUGOTHIC-L\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
static BYTE SET_JIS_FONT_SCALE[]  = "\x1B\x12\x43\x5A,M,%ld,%ld@";
static BYTE SET_JIS_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43\x5A,M,,%ld@";           // @Jan/29/99
static BYTE *SET_JIS_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-EXTRA BOLD\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-MEDIUM\x1B\x20",
                                     "GOTHIC-EXTRA BOLD\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-MEDIUM\x1B\x20",
                                     "MARUGOTHIC-LIGHT\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
#ifdef DOWNLOADFONT
//static BYTE DLFONT_MALLOC[]       = "\x1B\x12/128,8\x20";
static BYTE DLFONT_MALLOC[]       = "\x1B\x12/%d,%d\x20";
static BYTE DLFONT_SEND_BLOCK[]   = "\x1B\x12G7,%d,%d,%d,@";
static BYTE DLFONT_SEND_BLOCK_DRC[] = "\x1B\x12G7,%d,%d,%d,5,,,%d@";
static BYTE DLFONT_PRINT[]        = "\x1B\x12g%d,,%d\x20";
#endif // DOWNLOADFONT

static BYTE ENTER_VECTOR[]       = "\x1B\x33";
static BYTE EXIT_VECTOR[]        = "\x1B\x34";
static BYTE TERMINATOR[]         = ";";
static BYTE MOVE_ABSOLUTE[]      = "MA%d,%d";
static BYTE BAR_CHECKDIGIT[]     = "BC1";
static BYTE BAR_H_SET[]          = "BH%d";
static BYTE BAR_W_SET_JAN[]      = "JW%d";
static BYTE BAR_W_SET_2OF5[]     = "TW";
static BYTE BAR_W_SET_C39[]      = "CW";
static BYTE BAR_W_SET_NW7[]      = "NW";
static BYTE BAR_W_PARAMS[]       = "%d,%d,%d,%d,%d";
static BYTE BAR_ROT90[ ]         = "RO90";
static BYTE BAR_ROT270[]         = "RO270";
static BYTE *BAR_TYPE[]          = {"JL",               // JAN(STANDARD)
                                    "JS",               // JAN(SHORT)
                                    "TI%d,",            // 2of5(INDUSTRIAL)
                                    "TX%d,",            // 2of5(MATRIX)
                                    "TL%d,",            // 2of5(ITF)
                                    "CD%d,",            // CODE39
                                    "NB%d,"};           // NW-7
static BYTE *BAR_NOFONT[]        = {"FJ1,-1",           // JAN(STANDARD)
                                    "FJ1,-1",           // JAN(SHORT)
                                    "FT2,-1",           // 2of5(INDUSTRIAL)
                                    "FT2,-1",           // 2of5(MATRIX)
                                    "FT2,-1",           // 2of5(ITF)
                                    "FC2,-1",           // CODE39
                                    "FN2,-1"};          // NW-7

static BYTE PEN_WIDTH[]           = "LW%d";                     // @Sep/14/98
static BYTE DRAW_TOMBO_POLYLINE[] = "MA%d,%dMRPD%d,%d,%d,%d";   // @Sep/14/98
static BYTE BEGINFAX_HEAD[]       = "\x1B\x12!1@R00\x1B\x20\x1B\x12?F1,%d,%d,%d,180,1,";
static BYTE BEGINFAX_CH[]         = "@%d:";
static BYTE BEGINFAX_EXTNUM[]     = "%s-";
static BYTE BEGINFAX_TAIL[]       = ",%08d,RPDLMINI,%d,1,2,1,1,,1,%d,%s,1,,1,,,1,\x1B\x20";
static BYTE ENDFAX[]              = "\x1B\x12?F2,1\x1B\x20";


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams)
{
    INT     ocmd, iRet;
    BYTE    Cmd[256];
    SHORT   nTmp;
    LPSTR   lpcmd;
    WORD    fLandscape, fFinisherSR30Active, fDoFormFeed, fPaperX;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98

//  VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    ocmd = 0;
    iRet = 0;

    // If TextMode RectangleFill or Move_X,Y are not called now &&
    // Move_X,Y command is saved, then flush the command here.
    if (dwCmdCbID != CMD_SET_TEXTRECT_W && dwCmdCbID != CMD_SET_TEXTRECT_H &&
        dwCmdCbID != CMD_DRAW_TEXTRECT &&
        dwCmdCbID != CMD_DRAW_TEXTRECT_REL &&                       // @Dec/11/97
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE &&                     // @Aug/14/98
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE_REL &&                 // @Aug/14/98
        !(dwCmdCbID >= CMD_XM_ABS && dwCmdCbID <= CMD_YM_RELUP))    // @Aug/28/98
    {
        if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))          // @Dec/11/97
        {
            BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
            // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
            if (!pOEM->TextRectGray)
            {
                if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
                else
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
            }
        }

        if (dwCmdCbID == CMD_FF)
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            // Output Move_Y command here.
            ocmd = sprintf(Cmd, ESC_YM_ABS, pOEM->TextCurPos.y);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
            // Output Move_X command here.
            ocmd = sprintf(Cmd, ESC_XM_ABS, pOEM->TextCurPos.x);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
    }

    switch (dwCmdCbID) {
      case CMD_SET_TEXTRECT_W:          // pdwParams:RectXSize
        pOEM->TextRect.x = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_SET_TEXTRECT_H:          // pdwParams:RectYSize
        pOEM->TextRect.y = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_DRAW_TEXTRECT_WHITE:     // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT;

      case CMD_DRAW_TEXTRECT:           // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = sprintf(Cmd, SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = sprintf(Cmd, SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT:       // @Aug/14/98
// @Jan/13/99 ->
        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
// @Jan/13/99 <-
#ifdef TEXTCLIPPING
        // Clear TextMode clipping
        if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_VALID))
        {
            BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);
            ClearTextClip(pdevobj, CLIP_IFNEED);
        }
#endif // TEXTCLIPPING
        {
            LONG x = pOEM->TextCurPos.x;
            LONG y = pOEM->TextCurPosRealY;     // y without page_length adjustment
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;
            LONG w = pOEM->TextRect.x;
            LONG h = pOEM->TextRect.y;

            // DCR:Unidrv5
            // Current x should be updated by DestX usually, except when
            // current position is (0, 0).  (Last modified @Mar/05/99)
            // Following bugs are concerned.
            // RPDL117&124: Current x isn't updated by CMD_XM_ABS while device font
            //   direct(not-substituted) printing.    -> DestX should be used.
            // #236215: DestX doesn't become 0 after CMD_CR when current y is 0.
            //   (SP8 WINPARTy Printable Area Check)  -> TextCurPos.x should be used.
            if (!(x != dest_x && x == pOEM->Offset.x && y == pOEM->Offset.y))
                pOEM->TextCurPos.x = x = dest_x;

            // Convert unit from dot to 1/720inch_unit at OLD models
            if (!(TEST_AFTER_SP10(pOEM->fModel) || BITTEST32(pOEM->fModel, GRP_MF150e)))
            {
                if (pOEM->nResoRatio == MASTERUNIT/240)   // 240dpi printer
                {
                    x *= 3;     // 3 = 720/240
                    y *= 3;
                    w *= 3;
                    h *= 3;
                }
                else    // MF530,150
                {
                    x *= 18;    // 18 = 720/400*10
                    w = (w * 18 + x % 10) / 10;     // Adjust fractional part
                    x /= 10;                        // KIRISUTE
                    y *= 18;
                    h = (h * 18 + y % 10) / 10;
                    y /= 10;
                }
            }
            ocmd = sprintf(Cmd, DRAW_TEXTRECT, x, y, w, h);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        break;

      case CMD_DRAW_TEXTRECT_WHITE_REL: // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT_REL;

      // Relative-coordinate rectangle command since NX-510  @Dec/12/97
      case CMD_DRAW_TEXTRECT_REL:       // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = sprintf(Cmd, SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = sprintf(Cmd, SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT_REL:   // @Aug/14/98
// @Jan/13/99 ->
        {
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;

            // DCR:Unidrv5
            // Current x should be updated by DestX usually, except when
            // current position is (0, 0).  (Last modified @Mar/03/99)
            if (!(pOEM->TextCurPos.x != dest_x && pOEM->TextCurPos.x == pOEM->Offset.x &&
                  pOEM->TextCurPosRealY == pOEM->Offset.y))
            {
                pOEM->TextCurPos.x = dest_x;
            }
        }

        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
#ifdef TEXTCLIPPING
            // Clear TextMode clipping
            if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_VALID))
            {
                BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);
                ClearTextClip(pdevobj, CLIP_IFNEED);
            }
#endif // TEXTCLIPPING
            ocmd = sprintf(Cmd, DRAW_TEXTRECT,
                           pOEM->TextCurPos.x, pOEM->TextCurPosRealY,
                           pOEM->TextRect.x, pOEM->TextRect.y);
        }
        else
        {
            LONG x = pOEM->TextCurPos.x - pOEM->TextRectPrevPos.x;
            LONG y = pOEM->TextCurPosRealY - pOEM->TextRectPrevPos.y;

            // If height is 1dot, this parameter can be omitted.
            if (pOEM->TextRect.y != 1)
                ocmd = sprintf(Cmd, DRAW_TEXTRECT_R_P4, x, y,
                               pOEM->TextRect.x, pOEM->TextRect.y);
            else
                ocmd = sprintf(Cmd, DRAW_TEXTRECT_R_P3, x, y,
                               pOEM->TextRect.x);
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        pOEM->TextRectPrevPos.x = pOEM->TextCurPos.x;
        pOEM->TextRectPrevPos.y = pOEM->TextCurPosRealY;
        break;


      case CMD_SET_SRCBMP_H:            // @Jun/04/98
        pOEM->dwSrcBmpHeight = *pdwParams;
        break;

      case CMD_SET_SRCBMP_W:            // @Jun/04/98
        pOEM->dwSrcBmpWidthByte = *pdwParams;
        break;

      case CMD_OEM_COMPRESS_ON:         // @Jun/04/98
//      VERBOSE(("** OEM_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral2, OEM_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        break;

      case CMD_RLE_COMPRESS_ON:
//      VERBOSE(("** RLE_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_COMPRESS_OFF:
//      VERBOSE(("** COMPRESS_OFF **\n"));
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_SEND_BLOCK:              // pdwParams:NumOfDataBytes,RasterDataH&W
#ifdef TEXTCLIPPING
        // Clear TextMode clipping
        if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_VALID))
        {
            BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);
            ClearTextClip(pdevobj, CLIP_IFNEED);
        }
#endif // TEXTCLIPPING

        // Do FE-DeltaRow compression  @Jun/04/98
        if (BITTEST32(pOEM->fGeneral2, OEM_COMPRESS_ON))
        {
//          VERBOSE(("** OEM_COMPRESS_SEND (%d) **\n", *pdwParams));
            ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_DRC,
                           (WORD)*(pdwParams+2) * 8,      // RasterDataWidthInBytes
                           (WORD)*(pdwParams+1));         // RasterDataHeightInPixels
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        else
        {
            // Do FE-RunLength compression
            if (BITTEST32(pOEM->fGeneral1, RLE_COMPRESS_ON))
            {
//              VERBOSE(("** RLE_COMPRESS_SEND (%d) **\n", *pdwParams));
                ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_C,
                               (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                               (WORD)*(pdwParams+1),      // RasterDataHeightInPixels
                               (WORD)*pdwParams);         // NumOfDataBytes
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            }
            // No compression
            else
            {
//              VERBOSE(("** NO_COMPRESS_SEND (%d) **\n", *pdwParams));

// OBSOLETE (FilterGraphics disables other compression!) @Feb/16/99 ->
#if 0   // SP8BUGFIX_RASTER
// @Feb/10/99 ->
                BITCLR32(pOEM->fGeneral2, DIVIDE_DATABLOCK);
                // DCR:RPDL
                // SP7&8 can't handle over-32768byte block with default printer memory
                if (BITTEST32(pOEM->fModel, GRP_SP8))
                {
                    // send divided blocks at OEMFilterGraphics().
                    BITSET32(pOEM->fGeneral2, DIVIDE_DATABLOCK);
                    pOEM->dwSrcBmpHeight = *(pdwParams+1);
                    pOEM->dwSrcBmpWidthByte = *(pdwParams+2);
                }
                else
// @Feb/10/99 <-
#endif // if 0
// @Feb/16/99 <-
                {
                    ocmd = sprintf(Cmd, BEGIN_SEND_BLOCK_NC,
                                   (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                                   (WORD)*(pdwParams+1));     // RasterDataHeightInPixels
                    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                }
            }
        }
        break;


      case CMD_XM_ABS:                  // pdwParams:DestX
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
#ifdef DOWNLOADFONT
            pOEM->nCharPosMoveX = 0;
#endif // DOWNLOADFONT
            iRet = pOEM->TextCurPos.x = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPos.x += pOEM->Offset.x;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_XM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_YM_ABS:                  // pdwParams:DestY
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = pOEM->TextCurPos.y = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

            // DCR:RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            pOEM->TextCurPos.y += pOEM->Offset.y;
            pOEM->TextCurPosRealY += pOEM->Offset.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_YM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_XM_REL:                  // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x += iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_XM_RELLEFT:              // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x -= iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_REL:                  // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y += iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_RELUP:                // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y -= iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_CR:
#ifdef DOWNLOADFONT
        pOEM->nCharPosMoveX = 0;    // @Jan/19/98
#endif // DOWNLOADFONT
        ocmd = sprintf(Cmd, CR);
        if ((pOEM->TextCurPos.x = pOEM->Offset.x) != 0)
            ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
//      VERBOSE(("** CMD_CR **\n"));
        break;

      case CMD_LF:
        WRITESPOOLBUF(pdevobj, LF, sizeof(LF)-1);
        break;

      case CMD_BS:
        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
        break;

      case CMD_FF:
        fDoFormFeed = FALSE;
        // If 2in1
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
        {
            // If 2nd page finished
            if (pOEM->Nin1RemainPage)
            {
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
            }
            // If not 2nd page, disable formfeed and increase offset.
            else
            {
                WORD PageSpace, wTmp;

                pOEM->Nin1RemainPage++;
                // space(dot) between 2pages of 2in1.
                if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67E2E[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100E2E;
                }
                else
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100;
                }
                PageSpace = ((WORD)(MASTERUNIT*10)/(WORD)254) * wTmp /
                             pOEM->nResoRatio;

                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                    pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y + PageSpace;
                else
                    pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x + PageSpace;
            } // 'if (Nin1RemainPage) else' end
#ifdef TEXTCLIPPING
            ClearTextClip(pdevobj, CLIP_MUST);
#endif // TEXTCLIPPING
        }
        // If 4in1
        else if (TEST_4IN1_MODE(pOEM->fGeneral1))     // OLD MF do not support this
        {
            switch (++pOEM->Nin1RemainPage)     // bug fix @Jan/20/99
            {
              default:  // If illegal, treat as 1st page finished.
                pOEM->Nin1RemainPage = 1;
                pOEM->Offset.y = pOEM->BaseOffset.y;
              case 1:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 2:
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y;
                break;
              case 3:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 4:   // 4th page finished
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
                break;
            }
#ifdef TEXTCLIPPING
            ClearTextClip(pdevobj, CLIP_MUST);
#endif // TEXTCLIPPING
        }
        // Usual case (non Nin1 mode)
        else
        {
            // Output formfeed command later
            fDoFormFeed = TRUE;
        } // 'if (TEST_2IN1_MODE) else if (TEST_4IN1_MODE) else' end

        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);

        if (fDoFormFeed)
        {
            if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/14/98
                DrawTOMBO(pdevobj, DRAW_TOMBO);

            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);       // moved here @Sep/14/98

            // SPEC of RPDL
            // Because RPDL's formfeed resets font status(vertical-text, bold, italic,
            // white-text and  TextMode clipping), we must output these commands again.
            if (BITTEST32(pOEM->fGeneral1, FONT_VERTICAL_ON))
                ocmd = sprintf(Cmd, ESC_VERT_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_BOLD_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_ITALIC_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                ocmd += sprintf(&Cmd[ocmd], ESC_WHITETEXT_ON);
        } // 'if (fDoFormFeed)' end

        // Reset coordinate x&y
        pOEM->TextCurPos.x = pOEM->Offset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y;
        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += sprintf(&Cmd[ocmd], ESC_YM_ABS, pOEM->TextCurPos.y);
        // reset coordinate y without page_length adjustment, too.
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_FONT_BOLD_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))      // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_ON, sizeof(ESC_BOLD_ON)-1);
        }
        break;

      case CMD_FONT_BOLD_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))       // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_OFF, sizeof(ESC_BOLD_OFF)-1);
        }
        break;

      case CMD_FONT_ITALIC_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))    // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_ON, sizeof(ESC_ITALIC_ON)-1);
        }
        break;

      case CMD_FONT_ITALIC_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))     // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_OFF, sizeof(ESC_ITALIC_OFF)-1);
        }
        break;

      case CMD_FONT_WHITETEXT_ON:
        BITSET32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
        break;

      case CMD_FONT_WHITETEXT_OFF:
        BITCLR32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        break;


#ifdef DOWNLOADFONT
      case CMD_DL_SET_FONT_ID:      // pdwParams:FontHeight
// OBSOLETE @Nov/20/98 ->
//      pOEM->DLFontH_MU = (WORD)*pdwParams;        // @Jun/30/98
// @Nov/20/98 <-
        break;

      case CMD_DL_SELECT_FONT_ID:
// OBSOLETE @Jun/30/98 ->
//      pOEM->DLFontCurID = (WORD)*pdwParams;       // CurrentFontID
// @Jun/30/98 <-
        break;

      case CMD_DL_SET_FONT_GLYPH:   // pdwParams:NextGlyph
//      VERBOSE(("[DL_SET_FONT_GLYPH] glyph=%d\n", (SHORT)*pdwParams));
        pOEM->DLFontCurGlyph = (WORD)*pdwParams;
        break;

//
// Following cases are called at the beginning of a print-job
//
      case CMD_SET_MEM0KB:          // JOB_SETUP.10  @Jan/14/98
        pOEM->DLFontMaxMemKB = 0;                   // disabled
        pOEM->pDLFontGlyphInfo = NULL;              // @Sep/08/98
        break;

      case CMD_SET_MEM128KB:
        pOEM->DLFontMaxMemKB = MEM128KB;            // 128Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_4;         // 2->4 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM256KB:
        pOEM->DLFontMaxMemKB = MEM256KB;            // 256Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_8;         // 4->8 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM512KB:
        pOEM->DLFontMaxMemKB = MEM512KB;            // 512Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_16;        // 8->16 @Oct/20/98
//      goto _SET_MEM_ENABLE;

      _SET_MEM_ENABLE:      // @Sep/08/98
        pOEM->DLFontMaxGlyph = DLFONT_GLYPH_TOTAL;  // 116->70 @Oct/20/98
        // allocate glyph info structure for TrueType download.
        if(!(pOEM->pDLFontGlyphInfo = (FONTPOS*)MemAllocZ(pOEM->DLFontMaxID *
                                                          pOEM->DLFontMaxGlyph *
                                                          sizeof(FONTPOS))))
        {
            pOEM->DLFontMaxMemKB = 0;   // disabled
        }
        break;
#endif // DOWNLOADFONT

      case CMD_SELECT_STAPLE_NONE:  // JOB_SETUP.20  @Dec/02/97
        pOEM->StapleType = 0;
        break;

      case CMD_SELECT_STAPLE_1:
        pOEM->StapleType = 1;
        break;

      case CMD_SELECT_STAPLE_2:
        pOEM->StapleType = 2;
        break;

      case CMD_SELECT_STAPLE_MAX1:  // @Mar/18/99
        pOEM->StapleType = 3;       // stapling with FinisherSR12(max 1staple)
        break;

      case CMD_SELECT_PUNCH_NONE:   // JOB_SETUP.30  @Dec/02/97
        pOEM->PunchType = 0;
        break;

      case CMD_SELECT_PUNCH_1:
        pOEM->PunchType = 1;
        break;


      case CMD_BEGINDOC_SP4:        // SP4mkII,5
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP4mkII);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF530:      // MF530
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF530);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF150:      // MF150
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF150E:     // MF150e,160
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150e);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP8:        // SP8(7),8(7)mkII,80
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP8);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MFP250:     // MF-P250,355,250(FAX),355(FAX),MF-FD355,MF-P250e,355e
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MFP250);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP10:       // SP10,10mkII
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP10);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9:        // SP9,10Pro
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9II:      // SP9II,10ProII,90
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9II);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF200:      // MF200,MF-p150,MF2200
        pOEM->fModel = 0;           // (separate BEGINDOC_SP9II @Sep/01/98)
        BITSET32(pOEM->fModel, GRP_MF200);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX100:      // NX-100
        pOEM->fModel = 0;
        // not support IBM extended character block
        BITSET32(pOEM->fModel, GRP_NX100);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX500:      // NX-500,1000,110,210,510,1100
        pOEM->fModel = 0;
        // TT font download capable
        BITSET32(pOEM->fModel, GRP_NX500);
        goto _BEGINDOC_FINISH1;

// OBSOLETE @Apr/15/99
//    case CMD_BEGINDOC_MFP250E:    // MF-P250e,355e
//      pOEM->fModel = 0;
//      BITSET32(pOEM->fModel, GRP_MFP250e);
//      goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF250M:    // MF250M
        // staple capable
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF250M);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3550:    // MF2700,3500,3550,4550,5550,6550,3530,3570,4570
        // staple & punch & media type option
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF3550);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3300:    // MF3300W,3350W
        pOEM->fModel = 0;
        // A2 printer
        BITSET32(pOEM->fModel, GRP_MF3300);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_IP1:       // IP-1
        pOEM->fModel = 0;
        // A1 plotter
        BITSET32(pOEM->fModel, GRP_IP1);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX70:      // NX70  @Feb/04/98
        pOEM->fModel = 0;
        // A4 printer, FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX70);   // BITSET->BITSET32  @Jun/01/98
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX700:     // NX700,600  @Jun/12/98
        pOEM->fModel = 0;
        // FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX700);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX900:     // NX900  @Jan/08/99
        pOEM->fModel = 0;
        // job define command(of ENDJOB) is needed for staple/punch
        BITSET32(pOEM->fModel, GRP_NX900);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF1530:    // MF1530,2230,2730,NX800,710,610  @Mar/03/99
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option
        BITSET32(pOEM->fModel, GRP_MF1530);
//      goto _BEGINDOC_FINISH1;

      _BEGINDOC_FINISH1:
        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            SendFaxNum(pdevobj);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = sprintf(Cmd, BEGINDOC1);
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC2_1);
        // Set Duplex:off
        ocmd += sprintf(&Cmd[ocmd], BEGINDOC3);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
#ifdef DOWNLOADFONT
        pOEM->dwDLFontUsedMem = 0;
        if (pOEM->DLFontMaxMemKB)
        {
            ocmd = sprintf(Cmd, DLFONT_MALLOC, pOEM->DLFontMaxMemKB, DLFONT_MIN_BLOCK_ID);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
#endif // DOWNLOADFONT

      _BEGINDOC_FINISH2:   // @Sep/09/98
        // Allocate heap memory for OEMOutputCharStr&OEMDownloadCharGlyph. 
        pOEM->pRPDLHeap2K = (PBYTE)MemAllocZ(HEAPSIZE2K);
        break;


      case CMD_SET_BASEOFFSETX_0:   // @May/07/98
      case CMD_SET_BASEOFFSETX_1:
      case CMD_SET_BASEOFFSETX_2:
      case CMD_SET_BASEOFFSETX_3:
      case CMD_SET_BASEOFFSETX_4:
      case CMD_SET_BASEOFFSETX_5:
        pOEM->BaseOffset.x = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETX_0);
        break;

      case CMD_SET_BASEOFFSETY_0:   // @May/07/98
      case CMD_SET_BASEOFFSETY_1:
      case CMD_SET_BASEOFFSETY_2:
      case CMD_SET_BASEOFFSETY_3:
      case CMD_SET_BASEOFFSETY_4:
      case CMD_SET_BASEOFFSETY_5:
        pOEM->BaseOffset.y = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETY_0);
        break;


      case CMD_RES240:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/240;
        // Set Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        if (!BITTEST32(pOEM->fModel, GRP_SP4mkII))
            ocmd = sprintf(Cmd, IMAGE_OPT_OFF);
        // Set Spacing_Unit:1/240inch
        ocmd += sprintf(&Cmd[ocmd], SELECT_RES240_1);
        if (TEST_AFTER_SP10(pOEM->fModel))                // SP10,9,etc
            // Set Graphics_Unit & Coordinate_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += sprintf(&Cmd[ocmd], SELECT_RES240_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES400:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/400;
        // Set Spacing_Unit & Graphics_Unit:1/400inch
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        ocmd = sprintf(Cmd, SELECT_RES400_1);
        if (!BITTEST32(pOEM->fModel, GRP_MF530))
        {
            // Set Engine_Resolution:400dpi
            ocmd += sprintf(&Cmd[ocmd], SELECT_RES400_2);
            if (TEST_AFTER_SP10(pOEM->fModel) ||
                BITTEST32(pOEM->fModel, GRP_MF150e))      // MF150e,160
            {
                // Set Coordinate_Unit:1/400inch
                ocmd += sprintf(&Cmd[ocmd], SELECT_RES400_3);
            }
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES600:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/600;
#ifdef DOWNLOADFONT
        // If non-DRC&&600dpi then make it half.  @Jun/15/98
        if (!TEST_CAPABLE_DOWNLOADFONT_DRC(pOEM->fModel))
            pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/600inch,
        // Engine_Resolution:600dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES600, sizeof(SELECT_RES600)-1);
        break;

      case CMD_RES1200:             // @Mar/02/99
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/1200;
#ifdef DOWNLOADFONT
        pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/1200inch,
        // Engine_Resolution:1200dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES1200, sizeof(SELECT_RES1200)-1);
        break;


      case CMD_REGION_STANDARD:     // @Nov/29/97
        BITCLR32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/15/98
            WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_REGION_STD, sizeof(SELECT_REGION_STD)-1);
        break;

      case CMD_REGION_EDGE2EDGE:    // @Nov/29/97
        BITSET32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        break;


      case CMD_IMGCTRL_100:
        if (pOEMExtra->UiScale != VAR_SCALING_DEFAULT)  // @Feb/06/98
        {
            pOEM->Scale = pOEMExtra->UiScale;           // @Mar/18/98
            ocmd = sprintf(Cmd, IMAGE_SCALING_VAR, pOEMExtra->UiScale);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            break;
        }
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_88:
        pOEM->Scale = 88;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_88, sizeof(IMAGE_SCALING_88)-1);
        break;

      case CMD_IMGCTRL_80:
        pOEM->Scale = 80;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_75:
        pOEM->Scale = 75;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_75, sizeof(IMAGE_SCALING_75)-1);
        break;

      case CMD_IMGCTRL_70:
        pOEM->Scale = 70;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_70, sizeof(IMAGE_SCALING_70)-1);
        break;

      case CMD_IMGCTRL_67:
        pOEM->Scale = 67;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_115:
        pOEM->Scale = 115;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_IMGCTRL_122:
        pOEM->Scale = 122;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122, sizeof(IMAGE_SCALING_122)-1);
        else
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122V, sizeof(IMAGE_SCALING_122V)-1);
        break;

      case CMD_IMGCTRL_141:
        pOEM->Scale = 141;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        else
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141V, sizeof(IMAGE_SCALING_141V)-1);
        break;

      case CMD_IMGCTRL_200:
        pOEM->Scale = 200;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        else
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200V, sizeof(IMAGE_SCALING_200V)-1);
        break;

      case CMD_IMGCTRL_50:
        pOEM->Scale = 50;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        break;

      case CMD_IMGCTRL_AA67:        // A->A scaling(67%)
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA67);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_BA80:        // B->A scaling(80%)
        pOEM->Scale = 80;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA80);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_BA115:       // B->A scaling(115%)
        pOEM->Scale = 115;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA115);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_DRV_4IN1_50:         // 4in1
        pOEM->Scale = 50;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_4IN1_50);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        break;

      case CMD_DRV_2IN1_67:         // 2in1
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_67);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_DRV_2IN1_100:        // 2in1
        pOEM->Scale = 100;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_100);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_AA141:       // IP-1,3300W,3350W:A->A scaling(141%)
        pOEM->Scale = 141;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA141);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        break;

      case CMD_IMGCTRL_AA200:       // IP-1:A->A scaling(200%)
        pOEM->Scale = 200;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA200);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        break;

      case CMD_IMGCTRL_AA283:       // IP-1:A->A scaling(283%)
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA283);
      case CMD_IMGCTRL_283:         // IP-1
        pOEM->Scale = 283;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_283, sizeof(IMAGE_SCALING_283)-1);
        break;

      case CMD_IMGCTRL_A1_400:      // IP-1:400% with A1
        BITSET32(pOEM->fGeneral1, IMGCTRL_A1_400);
      case CMD_IMGCTRL_400:         // IP-1
        pOEM->Scale = 400;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_400, sizeof(IMAGE_SCALING_400)-1);
        break;


      case CMD_SET_LANDSCAPE:
        BITSET32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;

      case CMD_SET_PORTRAIT:
        BITCLR32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;


// OBSOLETE (actually obsoleted at converting GPC to GPD) @Jan/08/99 ->
//    case CMD_DUPLEX_ON:
//      BITSET32(pOEM->fGeneral1, DUPLEX_VALID);
//      break;
// @Jan/08/99 <-

      case CMD_DUPLEX_VERT:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
      _DUP_V:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID);
            // Convert mm to 5mm_unit(2=5mm,3=10mm,...,11=50mm)
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = sprintf(Cmd, SET_LEFTMARGIN, nTmp);
            // SP9II(except 1st lot),10ProII can set binding margin every 1 mm
            if (TEST_AFTER_SP9II(pOEM->fModel))
                ocmd += sprintf(&Cmd[ocmd], SET_LEFTMARGIN_9II, pOEMExtra->UiBindMargin);
        }
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT))
        {
            pOEM->BindPoint = BIND_RIGHT;
            ocmd += sprintf(&Cmd[ocmd], DUPLEX_VERT_R);
        }
        else
        {
            pOEM->BindPoint = BIND_LEFT;
            ocmd += sprintf(&Cmd[ocmd], DUPLEX_VERT);
        }
//      ocmd += sprintf(&Cmd[ocmd], DUPLEX_VERT);
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_ON);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_DUPLEX_HORZ:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
      _DUP_H:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID);
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = sprintf(Cmd, SET_UPPERMARGIN, nTmp);
            if (TEST_AFTER_SP9II(pOEM->fModel))
            {
                ocmd += sprintf(&Cmd[ocmd], SET_UPPERMARGIN_9II, pOEMExtra->UiBindMargin);
            }
        }
        pOEM->BindPoint = BIND_UPPER;
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_HORZ);
        ocmd += sprintf(&Cmd[ocmd], DUPLEX_ON);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_MEDIATYPE_STANDARD:
            pOEM->MediaType = MEDIATYPE_STD;    // use pOEM->MediaType  @Mar/03/99
            break;

      case CMD_MEDIATYPE_OHP:
            pOEM->MediaType = MEDIATYPE_OHP;
            break;

      case CMD_MEDIATYPE_THICK:
            pOEM->MediaType = MEDIATYPE_THICK;
            break;

      case CMD_MEDIATYPE_SPL:       // since MF1530  @Mar/03/99
            pOEM->MediaType = MEDIATYPE_SPL;
            break;

      case CMD_SELECT_PAPER_A2:
        pOEM->DocPaperID = RPDL_A2;
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A2;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        // Because incapable, clear setting
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A3:
        pOEM->DocPaperID = RPDL_A3;
        // If able to select tray with "papername+X" && no staple && no punch
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO) &&
            TEST_CAPABLE_PAPER_A2(pOEM->fModel))
        {
            lpcmd = SELECT_PAPER_B3;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        // If A->A(141%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A2;
        // If A->A(200%) || A1(400%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_A3;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        // Because incapable, clear setting
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A4:
        pOEM->DocPaperID = RPDL_A4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_B4;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If 2in1(100%), scale up papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A3;
        // If A->A(67%), scale down papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A2;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A5:
        pOEM->DocPaperID = RPDL_A5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A6:
        pOEM->DocPaperID = RPDL_A6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A6;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_POSTCARD:       // since NX700  @Feb/13/98
        pOEM->DocPaperID = RPDL_POSTCARD;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A4X;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        lpcmd = SELECT_PAPER_PCX;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B3:             // @Jan/07/98
        pOEM->DocPaperID = RPDL_B3;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = SELECT_PAPER_B3;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B4:
        pOEM->DocPaperID = RPDL_B4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A3;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_B4;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B5:
        pOEM->DocPaperID = RPDL_B5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_B4;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B6:
        pOEM->DocPaperID = RPDL_B6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else
            lpcmd = SELECT_PAPER_B6;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_C:
        pOEM->DocPaperID = RPDL_C;
        lpcmd = SELECT_PAPER_C;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_TABLOID:
        pOEM->DocPaperID = RPDL_TABD;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_TABD;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LEGAL:
        pOEM->DocPaperID = RPDL_LEGL;
        lpcmd = SELECT_PAPER_LEGL;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LETTER:
        pOEM->DocPaperID = RPDL_LETR;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_TABD;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_STATEMENT:
        pOEM->DocPaperID = RPDL_STAT;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_STATX : SELECT_PAPER_STATW;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
            goto _IMGCTRL_OFF1;
        break;

      case CMD_SELECT_PAPER_A2TOA3:
        pOEM->DocPaperID = RPDL_A2A3;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        lpcmd = SELECT_PAPER_A3;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_A3TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_A3A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_B4TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_B4A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)sprintf(pOEM->RPDLHeap64, lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_DOUBLEPOSTCARD:
        BITSET32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD);
        goto _SET_CUSTOMSIZE;

      case CMD_SELECT_PAPER_CUSTOM:     // pdwParams:PhysPaperWidth,Length
        pOEM->PhysPaperWidth  = (WORD)*pdwParams;       // @Dec/26/97
        pOEM->PhysPaperLength = (WORD)*(pdwParams+1);
        BITSET32(pOEM->fGeneral1, PAPER_CUSTOMSIZE);

      _SET_CUSTOMSIZE:
        pOEM->DocPaperID = RPDL_CUSTOMSIZE;
        pOEM->RPDLHeapCount = 0;
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      _IMGCTRL_OFF1:
        // Invalidate image controls
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
      _IMGCTRL_OFF2:
        BITCLR_SCALING_SEL_TRAY(pOEM->fGeneral1);
        BITCLR_NIN1_MODE(pOEM->fGeneral1);
        break;


      case CMD_SET_LONG_EDGE_FEED:          // for Multi Tray  @May/25/98
        BITSET32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;

      case CMD_SET_SHORT_EDGE_FEED:         // for Multi Tray  @May/25/98
        BITCLR32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;


      case CMD_SELECT_AUTOFEED:
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            // Set MediaType (modify  @Mar/03/99)
            if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
            {
                switch (pOEM->MediaType)
                {
                  case MEDIATYPE_OHP:
                    ocmd = sprintf(Cmd, SELECT_MEDIATYPE_OHP, 'T');
                    break;
                  case MEDIATYPE_THICK:
                    ocmd = sprintf(Cmd, SELECT_MEDIATYPE_THICK, 'T');
                    break;
                  case MEDIATYPE_SPL:   // since MF1530
                    ocmd = sprintf(Cmd, SELECT_MEDIATYPE_SPL, 'T');
                    break;
                  default:
                  case MEDIATYPE_STD:
                    ocmd = sprintf(Cmd, SELECT_MEDIATYPE_STD, 'T');
                    break;
                }
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                ocmd = 0;
            }
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
            goto _SELECTPAPER_CUSTOMSIZE;
        }
        // Output Set_Limitless_Paper_Supply_Mode
        WRITESPOOLBUF(pdevobj, SET_LIMITLESS_SUPPLY,sizeof(SET_LIMITLESS_SUPPLY)-1);
        // Output Select_Tray_By_Papersize command.
        //   if letter size, select A4 first in case of no letter paper.
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4X, sizeof(SELECT_PAPER_A4X)-1);
        }
        else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4W, sizeof(SELECT_PAPER_A4W)-1);
        }
        WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;

      case CMD_SELECT_MANUALFEED:
      case CMD_SELECT_MULTIFEEDER:
      case CMD_SELECT_MULTITRAY:        // NXs' MultiTray
// Moved forward, because NX710(MultTray) support MediaType  @Mar/11/99 ->
        // Set MediaType (modify @Mar/03/99)
        if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
        {
            switch (pOEM->MediaType)
            {
              case MEDIATYPE_OHP:
                ocmd = sprintf(Cmd, SELECT_MEDIATYPE_OHP, 'T');
                break;
              case MEDIATYPE_THICK:
                ocmd = sprintf(Cmd, SELECT_MEDIATYPE_THICK, 'T');
                break;
              case MEDIATYPE_SPL:   // since MF1530
                ocmd = sprintf(Cmd, SELECT_MEDIATYPE_SPL, 'T');
                break;
              default:
              case MEDIATYPE_STD:
                ocmd = sprintf(Cmd, SELECT_MEDIATYPE_STD, 'T');
                break;
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            ocmd = 0;
        }
// @Mar/11/99 <-
        // Select Feeder
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
        {
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        }
        else
        {
            // Select MultiFeeder/MultTray
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
        }
        // If CustomSize, jump.
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            goto _SELECTPAPER_CUSTOMSIZE;
        }

        // Set papersize
        // If papersize without transverse (A1,A2,A3,A6,B3,B4,B6,C,Tabloid,Legal)
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A1)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A2)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B3)    ||    // @Feb/05/98
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_C)     ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD)  ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
        {
            // Output Select_Papersize command
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD, sizeof(SELECT_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        }
        else
        {
            if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4X) ||
                !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4W))
            {
                // If long edge feed is enabled, set transverse paper.  @May/25/98
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A4;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A4R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_B5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_B5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_LETR;
                }
                else
                {
                    lpcmd = SELECT_PAPER_LETRR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_STAT;
                }
                else
                {
                    lpcmd = SELECT_PAPER_STATR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_PCX))   // @Feb/13/98
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_PC;
                }
                else
                {
                    lpcmd = SELECT_PAPER_PCR;
                }
            }
            else
                break;  // exit

            // Output Select_Papersize command
            ocmd = sprintf(Cmd, SELECT_PAPER_HEAD);
            ocmd += sprintf(&Cmd[ocmd], lpcmd);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        } // 'if (A1,A2,A3,A6,B4,B6,C,TABLOID,LEGAL) else' end
        // Reconfirm ManualFeed/AutoFeed.
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
        break;

      _SELECTPAPER_CUSTOMSIZE:
        {
            DWORD   dwWidth, dwHeight;

            // If DoublePostcard
            if (BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = 148;     // mm
                    dwHeight = 200;
                }
                else
                {
                    dwWidth  = 200;
                    dwHeight = 148;
                }
                // Set max pagesize (mm to dot with KIRISUTE)
                pOEM->PageMax.x = (LONG)(dwWidth * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
                pOEM->PageMax.y = (LONG)(dwHeight * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
            }
            // If CustomSize
            else
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = pOEM->PhysPaperLength;           // masterunit
                    dwHeight = pOEM->PhysPaperWidth;
                }
                else
                {
                    dwWidth  = pOEM->PhysPaperWidth;            // masterunit
                    dwHeight = pOEM->PhysPaperLength;
                }
                // Set max pagesize
                pOEM->PageMax.x = (LONG)(dwWidth  / pOEM->nResoRatio);   // dot
                pOEM->PageMax.y = (LONG)(dwHeight / pOEM->nResoRatio);
                // masterunit to mm with SISHAGONYU
                dwWidth  = (dwWidth * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
                dwHeight = (dwHeight * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
            }

            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);

            // Because app sometimes sets under-limit in landscape,
            // we need to swap width and height.  @Oct/21/98
            if (dwHeight < USRD_H_MIN148)           // < 148
            {
                DWORD dwTmp;
                dwTmp = dwWidth;
                dwWidth = dwHeight;
                dwHeight = dwTmp;
            }
            else if (dwWidth >= dwHeight)
            {
                WORD fSwap = FALSE;

                // Because app sometimes sets over-limit width in portrait,
                // we need to swap width and height.
                if (TEST_CAPABLE_PAPER_A2(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A2)            // > 432
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A3_W297(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A3)            // > 297
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A4MAX(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A4)            // > 216
                        fSwap = TRUE;
                }
                else
                {
                    if (dwWidth > USRD_W_A3_OLD)        // > 296
                        fSwap = TRUE;
                }

                if (fSwap)
                {
                    DWORD dwTmp;
                    dwTmp = dwWidth;
                    dwWidth = dwHeight;
                    dwHeight = dwTmp;
                }
                // SPEC of RPDL
                // If width is larger than length, we need to set landscape.
                else
                {
                    BITSET32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
                }
            }
            else
            {
                BITSET32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);
            }

            ocmd = sprintf(Cmd, SELECT_PAPER_CUSTOM, (WORD)dwWidth, (WORD)dwHeight);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }
        break;

      case CMD_SELECT_ROLL1:                // IP-1
      case CMD_SELECT_ROLL2:
        // Select roll (plotter)
        if (dwCmdCbID == CMD_SELECT_ROLL1)
            WRITESPOOLBUF(pdevobj, SELECT_ROLL1, sizeof(SELECT_ROLL1)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_ROLL2, sizeof(SELECT_ROLL2)-1);
        // Output Select_Papersize command ("papername+X" only)
        WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD_IP1, sizeof(SELECT_PAPER_HEAD_IP1)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;

//
//    Here comes PAPER_DESTINATION command in printing.
//    All of these commands are written in GPD.
//

      case CMD_SET_COLLATE_OFF:         // @Jul/31/98
        pOEM->CollateType = COLLATE_OFF;            // COLLATE_OFF<-0     @Dec/02/98
        break;

      case CMD_SET_COLLATE_ON:          // @Jul/31/98
        pOEM->CollateType = COLLATE_ON;             // COLLATE_ON<-1      @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_UNIDIR:   // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_UNIDIR;     // COLLATE_UNIDIR<-2  @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_ROTATED:  // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_ROTATED;    // COLLATE_ROTATED<-3 @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_SHIFTED:  // @Dec/02/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_SHIFTED;
        break;


      // Final command before print
      case CMD_MULTI_COPIES:                // pdwParams:NumOfCopies
        // If not CustomSize, set max pagesize.
        if ((nTmp = pOEM->DocPaperID) != RPDL_CUSTOMSIZE)
        {
            if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
            {
                pOEM->PageMax.x = RPDLPageSizeE2E[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSizeE2E[nTmp].y / pOEM->nResoRatio;
            }
            else
            {
                pOEM->PageMax.x = RPDLPageSize[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSize[nTmp].y / pOEM->nResoRatio;
            }

            if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
            {
                LONG tmp;
                tmp = pOEM->PageMax.x;    // swap x-y
                pOEM->PageMax.x = pOEM->PageMax.y;
                pOEM->PageMax.y = tmp;
            }
        }

        if (TEST_BUGFIX_FORMFEED(pOEM->fModel) ||           // add @Sep/15/98
            BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            pOEM->PageMaxMoveY = pOEM->PageMax.y;
        }
        else
        {
            // DCR:RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            // Set PageMaxMoveY for checking max vertical position.
            nTmp = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?     // @Nov/27/97
                   DISABLE_FF_MARGIN_E2E : DISABLE_FF_MARGIN_STD;
            pOEM->PageMaxMoveY = pOEM->PageMax.y - 1 -
                                 (nTmp + pOEM->nResoRatio - 1) /
                                 pOEM->nResoRatio;                  // KIRIAGE
        }

#ifdef TEXTCLIPPING
        // Initialize TextMode ClippingArea
        pOEM->TextClipRect.left = pOEM->TextClipRect.top = 0;
        pOEM->TextClipRect.right = pOEM->PageMax.x;
        pOEM->TextClipRect.bottom = pOEM->PageMax.y;
#endif // TEXTCLIPPING

        // If 2in1, switch orientation(portrait<->landscape).
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
            BITSET32(pOEM->fGeneral1, SWITCH_PORT_LAND);
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND) ||
                BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT))
            {
                fLandscape = FALSE;
            }
            else
            {
                fLandscape = TRUE;
            }
        }
        else    // portrait
        {
            fLandscape = BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND)? TRUE : FALSE;
        }
        // Output RPDL orientation command
        if (fLandscape || BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND))
            WRITESPOOLBUF(pdevobj, SET_LANDSCAPE, sizeof(SET_LANDSCAPE)-1);
        else                // portrait
            WRITESPOOLBUF(pdevobj, SET_PORTRAIT, sizeof(SET_PORTRAIT)-1);

        // Output copy#
        // Check whether copy# is in the range.  @Sep/01/98
        {
            DWORD dwCopy, dwMax;

            dwCopy = *pdwParams;    // NumOfCopies
            dwMax = TEST_MAXCOPIES_99(pOEM->fModel)? 99 : 999;

            if(dwCopy > dwMax)
                dwCopy = dwMax;
            else if(dwCopy < 1)
                dwCopy = 1;

            ocmd = sprintf(Cmd, SET_MULTI_COPY, (WORD)dwCopy);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
// @Jan/08/99 ->
            if (1 == dwCopy)
                pOEM->CollateType = COLLATE_OFF;
// @Jan/08/99 <-
        }

        fFinisherSR30Active = FALSE;    // @Mar/19/99

        // staple
        if (pOEM->StapleType)
        {
            ocmd = 0;
            if (BITTEST32(pOEM->fModel, GRP_MF250M))    // model = MF250M (No Punch Unit)
            {
                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = sprintf(Cmd, SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:outer tray
                ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_OUTTRAY);
                // staple:on
                ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON,
                                (fLandscape)?
                                STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER);
            }
            else    // model = MF2700,3500,3550,4550,5550,6550,NXs
            {
                WORD pnt;

                fFinisherSR30Active = TRUE;     // @Mar/19/99

                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = sprintf(Cmd, SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:finisher shift tray
                ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
// @Mar/19/99 ->
                // Disable rotated collate.
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);
// @Mar/19/99 <-

                if (pOEM->StapleType == 2)          // 2 staples on the paper
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_LEFT2;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_RIGHT2;
                        break;
                      case BIND_UPPER:
                        pnt = STAPLE_UPPER2;
                        break;
//                    case BIND_ANY:
                      default:
                        pnt = (fLandscape)? STAPLE_UPPER2 : STAPLE_LEFT2;
                        break;
                    }
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_ON, pnt);
                }
// @Mar/18/99 ->
                else if (pOEM->StapleType == 3)     // 1 staple with FinisherSR12
                {
// @Apr/06/99 ->
//                  if (BIND_RIGHT == pOEM->BindPoint)
//                      pnt = STAPLE_UPPERRIGHT_CORNER;
//                  else
//                      pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        // If papersize without transverse (A3,B4,Tabloid,Legal)
                        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD) ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
                        {
                            pnt = (fLandscape)? STAPLE_UPPERLEFT_CORNER : STAPLE_UPPERRIGHT_CORNER;
                        }
                        else
                        {
                            pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                        }
                        break;
                    }
// @Apr/06/99 <-
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON, pnt);
                }
// @Mar/18/99 <-
                else                                // 1 staple
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                    }
                    // staple:on
                    ocmd += sprintf(&Cmd[ocmd], SET_STAPLE_CORNER_ON, pnt);
                }
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // punch
        if (pOEM->PunchType)
        {
            WORD pnt;

            ocmd = 0;

            if (!fFinisherSR30Active)   // modify  @Mar/19/99
            {
                if (COLLATE_OFF != pOEM->CollateType)
                {
                    // sort:on (add duplex param since NX900 @Jan/08/99)
                    ocmd = sprintf(Cmd, SET_SORT_ON,
                                   BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
                }
                // paper_destination:finisher shift tray
                ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
                // SPEC of RPDL  @May/27/98
                // We must disable rotated collate here.
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);
            }

            switch (pOEM->BindPoint)
            {
              case BIND_LEFT:
                pnt = PUNCH_LEFT;
                break;
              case BIND_RIGHT:
                pnt = PUNCH_RIGHT;
                break;
              case BIND_UPPER:
                pnt = PUNCH_UPPER;
                break;
              default:
                pnt = (fLandscape)? PUNCH_UPPER : PUNCH_LEFT;
                break;
            }
            // punch:on
            ocmd += sprintf(&Cmd[ocmd], SET_PUNCH_ON, pnt);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // collate  (@Jul/31/98, entirely-modify @Dec/02/98)
        if (!pOEM->StapleType && !pOEM->PunchType)
        {
            // sort:on (add duplex param since NX900 @Jan/08/99)
            ocmd = sprintf(Cmd, SET_SORT_ON,
                           BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
            switch (pOEM->CollateType)
            {
              case COLLATE_UNIDIR:
                ocmd += sprintf(&Cmd[ocmd], COLLATE_DISABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              case COLLATE_ROTATED:
                ocmd += sprintf(&Cmd[ocmd], COLLATE_ENABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // If shifted collate, select finisher shift tray.
              case COLLATE_SHIFTED:
                ocmd += sprintf(&Cmd[ocmd], SET_PAPERDEST_FINISHER);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // if collate for MF-p150,MF200,250M,2200,NXs
              case COLLATE_ON:
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              default:
                break;
            }
        }

        ocmd = 0;
        if (TEST_AFTER_SP9II(pOEM->fModel) && !BITTEST32(pOEM->fModel, GRP_NX100))
        {
            // Set IBM extended character code block, and set region to 'USA'. (latter @Feb/22/99)
            ocmd += sprintf(&Cmd[ocmd], SET_IBM_EXT_BLOCK);
            // Disable formfeed when charcter position is around ymax-coordinate
            ocmd += sprintf(&Cmd[ocmd], SET_PAGEMAX_VALID);
        }

        // Set color of Textmode RectangleFill black
        ocmd += sprintf(&Cmd[ocmd], SET_TEXTRECT_BLACK);
        pOEM->TextRectGray = 100;           // @Jan/07/98

        // Set 5mm offset at MF530,150,150e,160.
        // (At these models, CMD_SET_BASEOFFSETs aren't called.)
        if (TEST_GRP_OLDMF(pOEM->fModel) &&
            !BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT) &&
            !BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO)) // add @Sep/15/98
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.y = 5;    // mm
        }

        // Convert mm to dot here ((LONG)<-(DWORD) @Feb/02/99)
        pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;
        pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;

        // Think about scaling  (@May/18/98, (LONG)<-(DWORD) @Feb/02/99)
        if (pOEM->Scale != 100 && pOEM->Scale != 0)
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)100 / (LONG)pOEM->Scale;
            pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)100 / (LONG)pOEM->Scale;
        }

        // Calculate offset for TOMBO.(BaseOffset will be changed.) @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
            DrawTOMBO(pdevobj, INIT_TOMBO);

        // Initialize current position
        pOEM->TextCurPos.x = pOEM->Offset.x = pOEM->BaseOffset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y = pOEM->BaseOffset.y;
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += sprintf(&Cmd[ocmd], ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += sprintf(&Cmd[ocmd], ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd); 

#ifdef TEXTCLIPPING
        // If Nin1, clear TextMode clipping in 1st page.
        if (TEST_NIN1_MODE(pOEM->fGeneral1))
            ClearTextClip(pdevobj, CLIP_MUST);
#endif // TEXTCLIPPING
        break;

//
// Following cases are called at the end of a print-job (JOB_FINISH)
//

      case CMD_ENDDOC_SP4:          // SP4mkII,5
        // If Nin1 && document finished with remaining pages, output FF.
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = sprintf(Cmd, ENDDOC1);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP8:          // SP8(7),8(7)mkII,80,10,10mkII
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = sprintf(Cmd, ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel))    // SP10,10mkII
        {
            // Set Graphics_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += sprintf(&Cmd[ocmd], ENDDOC2_240DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        }
        // Set Options[duplex/2in1:off,reversed_output:off,sort/stack:off]
        ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP9:          // SP9,10Pro,9II,10ProII,90
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = sprintf(Cmd, ENDDOC1);
        // Set Graphics_Unit:1/240inch,Engine_Resolution:400dpi
        ocmd += sprintf(&Cmd[ocmd], ENDDOC2_SP9);
        ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_400DPI_MODEL: // MF,MF-P,NX,IP-1
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = sprintf(Cmd, ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel) ||        // MF-P,NX,MF200,250M,MF-p150,MF2200
            BITTEST32(pOEM->fModel, GRP_MF150e))    // MF150e,160
        {
            // Set Graphics_Unit:1/400inch,Engine_Resolution:400dpi
            ocmd += sprintf(&Cmd[ocmd], ENDDOC2_400DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += sprintf(&Cmd[ocmd], ENDDOC3);
        }
        // If staple mode, do not change sort/stack of Options.
        if (pOEM->StapleType || pOEM->PunchType)
            ocmd += sprintf(&Cmd[ocmd], ENDDOC4_FINISHER);
        else
            ocmd += sprintf(&Cmd[ocmd], ENDDOC4);
//      goto _ENDDOC_FINISH;

      _ENDDOC_FINISH:
        // Reset smoothing/tonner_save_mode. (DCR:We must not reset SP8 series.)
        if (TEST_BUGFIX_RESET_SMOOTH(pOEM->fModel))
            ocmd += sprintf(&Cmd[ocmd],  SELECT_SMOOTHING2);
        // Terminate fax at imagio FAX
        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            ocmd += sprintf((LPSTR)&Cmd[ocmd], ENDFAX);

// OBSOLETE @Apr/22/99
//      // Reset MediaType to Standard  (modify @Mar/03/99)
//      if (MEDIATYPE_STD != pOEM->MediaType)
//          ocmd += sprintf(&Cmd[ocmd], SELECT_MEDIATYPE_STD, 'T');

// @Jan/08/99 ->
        // DCR:NX900 RPDL (job define command is needed)
        if (BITTEST32(pOEM->fModel, GRP_NX900) &&
            (COLLATE_OFF != pOEM->CollateType || pOEM->StapleType || pOEM->PunchType))
        {
            ocmd += sprintf(&Cmd[ocmd], ENDDOC_JOBDEF_END);
        }
// @Jan/08/99 <-
        // Initialize printer
        ocmd += sprintf(&Cmd[ocmd], ENDDOC5);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
        // If binding margin is set,reset it to 0mm.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID))
            ocmd += sprintf(&Cmd[ocmd], SET_LEFTMARGIN, 1);
        else if (BITTEST32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID))
            ocmd += sprintf(&Cmd[ocmd], SET_UPPERMARGIN, 1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        if(pOEM->pRPDLHeap2K)               // @Sep/09/98
            MemFree(pOEM->pRPDLHeap2K)
#ifdef DOWNLOADFONT
        if(pOEM->pDLFontGlyphInfo)          // @Sep/09/98
            MemFree(pOEM->pDLFontGlyphInfo);
#endif // DOWNLOADFONT
        break;


    default:
        ERR((("Unknown callback ID = %d.\n"), dwCmdCbID));
    }

    return iRet;
} //*** OEMCommandCallback


VOID APIENTRY OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[STDVAR_BUFSIZE(3) / sizeof(DWORD)];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
    DWORD       dwNeeded, dwUFO_FontH, dwUFO_FontW;
    DWORD       dwUFO_FontMaxW;     // MSKK Jul/23/98
    LONG        lTmp;

    VERBOSE(("** OEMSendFontCmd() entry. **\n"));

// MSKK 1/24/98 UnSelect ->
    if (0 == pFInv->dwCount)
    {
        // No select command.  pProbably some of the
        // un-select case where no invokation command is
        // available.  (No explicit un-select.)
        return;
    }   
// MSKK 1/24/98 <-

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = STDVAR_BUFSIZE(3);
    pSV->dwNumOfVariable = 3;

    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_FONTWIDTH;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                            pSV->dwSize, &dwNeeded))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

//  VERBOSE((("FONTHEIGHT=%d\n"), pSV->StdVar[0].lStdVariable));
//  VERBOSE((("FONTMAXWIDTH=%d\n"), pSV->StdVar[1].lStdVariable));
//  VERBOSE((("FONTWIDTH=%d\n"), pSV->StdVar[2].lStdVariable));

    dwUFO_FontH    = (DWORD)pSV->StdVar[0].lStdVariable;
    dwUFO_FontMaxW = (DWORD)pSV->StdVar[1].lStdVariable;    // MSKK Jul/23/98
    dwUFO_FontW    = (DWORD)pSV->StdVar[2].lStdVariable;

    dwOut = 0;

    BITCLR_BARCODE(pOEM->fGeneral2);
    for (dwIn = 0; dwIn < pFInv->dwCount;)
    {
        if (pubCmd[dwIn] == '#')
        {
            //** set width & height of scalable font for Japanese font **
            if (pubCmd[dwIn+1] == 'A')
            {
                DWORD   dwWidth, dwHeight;
                // pOEM->FontH_DOT(unit:dot) for TextMode clipping
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                // dwHeight(unit:cpt) for RPDL command parameter
                dwHeight = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);

                if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                  dwWidth = dwUFO_FontW * 2;
                    dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                else
                    dwWidth = dwUFO_FontW;
                dwWidth *= DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT;

//              VERBOSE(("[OEMSCALABLEFONT] w=%d,h=%d(%ddot)\n",
//                      (WORD)dwWidth, (WORD)dwHeight, pOEM->FontH_DOT));

// @Jun/25/98 ->
                // If width is slightly different to height, we suppose they are same.
                if ((lTmp = dwHeight - dwWidth) != 0)
                {
                    if (lTmp < 0)
                        lTmp = -lTmp;
                    if ((DWORD)lTmp < dwHeight / 25)    // 1/25 = 4%
                        dwWidth = dwHeight;
                }
// @Jun/25/98 <-

                // Use 10pt-size raster font at SP4mkII,5,8(7),8(7)mkII
                if (TEST_GRP_240DPI(pOEM->fModel) && dwWidth == dwHeight &&
                    dwWidth >= NEAR10PT_MIN && dwWidth <= NEAR10PT_MAX)
                {
                    dwWidth = dwHeight = 960;   // unit:cpt(centi point)
                }
                pOEM->dwFontW_CPT = dwWidth;
                pOEM->dwFontH_CPT = dwHeight;
// @Jan/29/99 ->
                // If width equals to height, we emit height parameter only.
                // (This is applied to after SP9II because we want to avoid testing
                //  at too old models.)
                if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
                    dwOut += sprintf(&aubCmd[dwOut], ",%ld", dwHeight);
                else
// @Jan/29/99 <-
                    dwOut += sprintf(&aubCmd[dwOut], "%ld,%ld", dwWidth, dwHeight);
                dwIn += 2;
            } // 'if 'A'' end

            //** set width & height of scalable font for IBM ext font **
            else if (pubCmd[dwIn+1] == 'B')
            {
// @Jan/29/99 ->
                if (TEST_AFTER_SP9II(pOEM->fModel) && pOEM->dwFontW_CPT == pOEM->dwFontH_CPT)
                    dwOut += sprintf(&aubCmd[dwOut], ",%ld", pOEM->dwFontH_CPT);
                else
// @Jan/29/99 <-
                    dwOut += sprintf(&aubCmd[dwOut], "%ld,%ld",
                                     pOEM->dwFontW_CPT, pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'B'' end

            // Set flag for barcode
            else if (pubCmd[dwIn+1] == 'C')
            {
                switch (pubCmd[dwIn+2])
                {
                  case '0':     // JAN(STANDARD)
                    pOEM->nBarMaxLen = 13 + 1;          goto _BARCODE_READY;

                  case '1':     // JAN(SHORT)
                    pOEM->nBarMaxLen = 8 + 1;           goto _BARCODE_READY;

                  case '2':     // 2of5(INDUSTRIAL)
                  case '3':     // 2of5(MATRIX)
                  case '4':     // 2of5(ITF)
                  case '5':     // CODE39
                  case '6':     // NW-7
                    pOEM->nBarMaxLen = BARCODE_MAX;
                  _BARCODE_READY:
                    BITSET32(pOEM->fGeneral2, BARCODE_MODE_IN);
                    pOEM->dwBarRatioW = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                    pOEM->nBarType = pubCmd[dwIn+2] - '0';
                    pOEM->RPDLHeapCount = 0;
                    VERBOSE(("** BARCODE(1) ratio=%d **\n",pOEM->dwBarRatioW));
                    break;

                  default:
                    break;
                }
                dwIn += 3;
            } // 'if 'C'' end

            //** set width of scalable font **
            else if (pubCmd[dwIn+1] == 'W')
            {
// MSKK Jul/23/98 ->
//              if (dwUFO_FontW > 0)
                if (dwUFO_FontW > 0 || dwUFO_FontMaxW > 0)
// MSKK Jul/23/98 <-
                {
                    DWORD dwWidth;
    
                    if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                      dwWidth = dwUFO_FontW * 2;
                        dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                    else
                        dwWidth = dwUFO_FontW;
                    pOEM->dwFontW_CPT = dwWidth * (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                    dwOut += sprintf(&aubCmd[dwOut], "%ld", pOEM->dwFontW_CPT);
                }
                dwIn += 2;
            } // 'if 'W'' end

            //** set height of scalable font (include Japanese proportional font) **
            else if (pubCmd[dwIn+1] == 'H')
            {
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                pOEM->dwFontH_CPT = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                dwOut += sprintf(&aubCmd[dwOut], "%ld", pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'H'' end

            //** set font pitch (Horizontal-Motion-Index) **
            else if (pubCmd[dwIn+1] == 'P')
            {
                SHORT nTmp1, nTmp2;

                switch (pubCmd[dwIn+2])     // modify(add Arial,Century,etc)
                {
                  case 'D':     // DBCS (Japanese font ZENKAKU)
//95/NT4            nTmp1 = lpFont->dfAvgWidth * 2;
// MSKK 1/25/98     nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2 * 2;
// MSKK Jul/23/98   nTmp1 = (SHORT)dwUFO_FontW * 2;
                    nTmp1 = (SHORT)dwUFO_FontMaxW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    VERBOSE(("** FontMaxW=%d dot **\n", nTmp1));
// @Aug/10/98       nTmp1 = (nTmp1 / 2 + 1) * 2;    // bigger even  @Jan/30/98
                    break;

                  case 'S':     // SBCS (Japanese font HANKAKU)
// RPDL pitch setting command of HANKAKU is EFFECTIVE to SPACE.
// OBSOLETE @Mar/26/99 ->
//// @Jan/29/99 ->
//                  // RPDL pitch setting command of HANKAKU is not effective, so
//                  // do not emit this. (We may not delete this string in UFM.)
//                  if (dwOut >= 4 && aubCmd[dwOut-4] == '\x1B' && aubCmd[dwOut-3] == 'N')
//                  {
//                      dwIn  += 3; // count up input '#PS'
//                      dwOut -= 4; // delete previous output '\x1BN\x1B\x1F'
//                      continue;   // goto for loop-end
//                  }
//                  else    // Maybe none comes here.
// @Jan/29/99 <-
// @Mar/26/99 <-
                    {
//95/NT4                nTmp1 = lpFont->dfAvgWidth;
// NSKK 1/25/98         nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2;
                        nTmp1 = (SHORT)dwUFO_FontW;
                        nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                        VERBOSE(("** FontW=%d dot **\n", nTmp1));
// @Aug/10/98           nTmp1++;                        // 1dot bigger  @Jan/30/98
                    }
                    break;

                  case '1':     // SBCS (BoldFacePS)
                  case '2':     // SBCS (Arial)
                  case '3':     // SBCS (Century)
                    nTmp1 = (SHORT)(dwUFO_FontH * 3L / 10L);        // * 0.3
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '4':     // SBCS (TimesNewRoman)
                    nTmp1 = (SHORT)(dwUFO_FontH * 27L / 100L);      // * 0.27
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '5':     // SBCS (Symbol)
                    nTmp1 = (SHORT)dwUFO_FontH / 4;                 // * 0.25
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '6':     // SBCS (Wingding)
                    nTmp1 = (SHORT)dwUFO_FontH;                     // * 1
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '7':     // DBCS (Japanese proportional font HANKAKU)
                    nTmp1 = (SHORT)(dwUFO_FontH * 78L / 256L);
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;
// OBSOLETE @Mar/26/99 ->
//                case '8':     // DBCS (Japanese proportional font ZENKAKU)
//                  nTmp1 = (SHORT)(dwUFO_FontH * 170L / 256L);
//                  nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
//                  break;
// @Mar/26/99 <-
                  default:      // SBCS (Courier,LetterGothic,PrestigeElite)
//95/NT4            nTmp1 = lpFont->dfPixWidth;
                    nTmp1 = (SHORT)dwUFO_FontW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    dwIn --;
                    break;
                }

                if (nTmp1 >= 0x7E)
                {
                    aubCmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // DCR:RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    aubCmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    aubCmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 3;
            } // 'if 'P'' end

            //** set Vertical-Motion-Index to draw combined font('^'+'A',etc). **
            //** (Courier,LetterGothic,PrestigeElite,BoldFacePS)               **
            else if (pubCmd[dwIn+1] == 'V')
            {
                SHORT nTmp1, nTmp2;
    
                // Set 1/3 height (adequate value to move vertically)
                nTmp1 = (SHORT)dwUFO_FontH / 3;
                nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);
                if (nTmp1 >= 0x7E)
                {
                    aubCmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // DCR:RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    aubCmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    aubCmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 2;
            } // 'if 'V'' end
        } // 'if '#'' end
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    } // 'for (dwIn = 0; dwIn < pFInv->dwCount;)' end

//  VERBOSE(("dwOut = %d\n", dwOut)); // MSKK 1/24/98

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

} //*** OEMSendFontCmd


static BYTE IsDBCSLeadByteRPDL(BYTE Ch)
{
    return ShiftJisRPDL[Ch];
}

static BYTE IsDifferentPRNFONT(BYTE Ch)
{
    return VerticalFontCheck[Ch];
}

//---------------------------*[LOCAL] DrawTOMBO*-------------------------------
// Action:
//  (a) INIT_TOMBO: calculate offset in printing. (BaseOffset will be changed)
//  (b) DRAW_TOMBO: drawing TOMBO.
// Setp/14/98
//-----------------------------------------------------------------------------
static VOID DrawTOMBO(
    PDEVOBJ pdevobj,
    SHORT action)
{
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
    POINT   P0;
    POINT   PaperSizeDoc, PaperSizeUse;
    BYTE    Cmd[256];         // build command here
    INT     ocmd = 0;
    LONG    lLen3, lLen10, lLen13, lWidth0_1, lSav, lTmp;
    SHORT   nPaperUse;

    switch (pOEM->DocPaperID)
    {
      case RPDL_A3:
        nPaperUse = RPDL_B3;    break;
      case RPDL_B4:
        nPaperUse = RPDL_A3;    break;
      case RPDL_A4:
        nPaperUse = RPDL_B4;    break;
      case RPDL_A5:
      case RPDL_A6:
      case RPDL_POSTCARD:
      case RPDL_B5:
      case RPDL_B6:
        nPaperUse = RPDL_A4;    break;
      default:
        return;     // draw nothing
    }

    // Set acutual printed paper size & document paper size
    PaperSizeUse = RPDLPageSizeE2E[nPaperUse];
    PaperSizeDoc = RPDLPageSizeE2E[pOEM->DocPaperID];

    // Orientation?
    if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
    {
        lTmp = PaperSizeUse.x;   // swap x-y
        PaperSizeUse.x = PaperSizeUse.y;
        PaperSizeUse.y = lTmp;
        lTmp = PaperSizeDoc.x;
        PaperSizeDoc.x = PaperSizeDoc.y;
        PaperSizeDoc.y = lTmp;
    }

    // upper-left TOMBO
    P0.x = (PaperSizeUse.x - PaperSizeDoc.x) / 2 / pOEM->nResoRatio;
    P0.y = (PaperSizeUse.y - PaperSizeDoc.y) / 2 / pOEM->nResoRatio;

    //   If action is INIT_TOMBO, set BaseOffset and return
    if (INIT_TOMBO == action)
    {
        LONG lUnprintable = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?
                            0 : 240L / pOEM->nResoRatio;    // 240masterunit at GPD
        pOEM->BaseOffset.x += P0.x + lUnprintable;
        pOEM->BaseOffset.y += P0.y + lUnprintable;
        return;     // exit
    }

    lSav = P0.x;    // save left P0.x
    lLen3  =  3L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 3mm
    lLen10 = 10L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 10mm
    lLen13 = 13L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 13mm
    lWidth0_1 = (LONG)MASTERUNIT / 254L / pOEM->nResoRatio;            // 0.1mm
    if (lWidth0_1 < 1)
        lWidth0_1 = 1;
    else if (lWidth0_1 >= 2)
        lWidth0_1 = lWidth0_1 / 2 * 2 + 1;      // make it odd

    ocmd = sprintf(Cmd, ENTER_VECTOR);          // enter VectorMode
    ocmd += sprintf(&Cmd[ocmd], PEN_WIDTH, lWidth0_1);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, -lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y - lLen13,
                    0, lLen13, -lLen10, 0);

    // upper-right TOMBO
    // Add horizontal distance and adjustment (PaperSizeDoc.x:masterunit, AdjX:0.1mm unit)
    P0.x += (PaperSizeDoc.x + (LONG)pOEMExtra->nUiTomboAdjX * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y - lLen13,
                    0, lLen13, lLen10, 0);

    // lower-left TOMBO
    lTmp = P0.x;
    P0.x = lSav;    // restore left P0.x
    lSav = lTmp;    // save right P0.x
    // Add vertical distance and adjustment (PaperSizeDoc.y:masterunit, AdjY:0.1mm unit)
    P0.y += (PaperSizeDoc.y + (LONG)pOEMExtra->nUiTomboAdjY * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, -lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y + lLen13,
                    0, -lLen13, -lLen10, 0);

    // lower-right TOMBO
    P0.x = lSav;    // restore right P0.x
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, lLen13, 0);
    ocmd += sprintf(&Cmd[ocmd], DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y + lLen13,
                    0, -lLen13, lLen10, 0);
    ocmd += sprintf(&Cmd[ocmd], EXIT_VECTOR);   // exit VectorMode
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
} // *** DrawTOMBO

//---------------------------*[LOCAL] AssignIBMfont*---------------------------
// Action:
//  (a) IBMFONT_ENABLE_ALL: assign IBM extended characters to block#1 where
//       JIS1 characters used to be assigned.
//  (b) IBMFONT_RESUME: resume (re-assign IBM extended characters to block#4.
//      block#4 is insufficient for all 388 IBM characters.)
//-----------------------------------------------------------------------------
static VOID AssignIBMfont(
    PDEVOBJ pdevobj,
    SHORT   rcID,
    SHORT   action)
{
    BYTE    Cmd[56];          // build command here
    INT     ocmd = 0;
    WORD    num;
    WORD    fHeightParamOnly;                   // @Jan/29/99
    DWORD   dwWidth, dwHeight;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);      // @Oct/06/98

    switch (rcID)
    {
      case MINCHO_1:      case MINCHO_1+1:      // horizontal font: vertical font:
      case MINCHO_B1:     case MINCHO_B1+1:
      case MINCHO_E1:     case MINCHO_E1+1:
      case GOTHIC_B1:     case GOTHIC_B1+1:
      case GOTHIC_M1:     case GOTHIC_M1+1:
      case GOTHIC_E1:     case GOTHIC_E1+1:
      case MARUGOTHIC_B1: case MARUGOTHIC_B1+1:
      case MARUGOTHIC_M1: case MARUGOTHIC_M1+1:
      case MARUGOTHIC_L1: case MARUGOTHIC_L1+1:
      case GYOSHO_1:      case GYOSHO_1+1:
      case KAISHO_1:      case KAISHO_1+1:
      case KYOKASHO_1:    case KYOKASHO_1+1:
        num = (rcID - MINCHO_1) / 2;
        goto _SET_W_H;

      case MINCHO_3:      case MINCHO_3+1:    // for NX-100
        num = 0;
        goto _SET_W_H;
      case GOTHIC_B3:     case GOTHIC_B3+1:
        num = 3;
      _SET_W_H:
        dwWidth  = pOEM->dwFontW_CPT;
        dwHeight = pOEM->dwFontH_CPT;
        break;

      case MINCHO10_RAS:  case MINCHO10_RAS+1:
        num = 0;                    // same to MINCHO_1
        dwWidth = dwHeight = 960;   // unit:cpt(centi point)
        break;

      default:
        return; // exit AssignIBMfont()
    }
    
// @Jan/29/99 ->
    // If width equals to height, we emit height parameter only.
    // (This is applied to only NX-100 here.)
    if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
        fHeightParamOnly = TRUE;
    else
        fHeightParamOnly = FALSE;
// @Jan/29/99 <-

    if (IBMFONT_RESUME == action)
    {
        // Resume JIS1 characters block where they used to be. (JIS1 -> block#1)
// @Jan/29/99 ->
        if (fHeightParamOnly)
            ocmd = sprintf(Cmd, SET_JIS_FONT_SCALE_H_ONLY, dwHeight);
        else
// @Jan/29/99 <-
            ocmd = sprintf(Cmd, SET_JIS_FONT_SCALE, dwWidth, dwHeight);
        ocmd += sprintf(&Cmd[ocmd], SET_JIS_FONT_NAME[num]);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

    // Assign IBM extended characters to block.
// @Jan/29/99 ->
    if (fHeightParamOnly)
        ocmd = sprintf(Cmd, SET_IBM_FONT_SCALE_H_ONLY, action, dwHeight);
    else
// @Jan/29/99 <-
        ocmd = sprintf(Cmd, SET_IBM_FONT_SCALE, action, dwWidth, dwHeight);
    ocmd += sprintf(&Cmd[ocmd], SET_IBM_FONT_NAME[num]);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    return;
} //*** AssignIBMfont


//---------------------------*[LOCAL] SendFaxNum*------------------------------
// Action: send fax number
// (Use fax data file @Sep/30/98, Use private devmode @Oct/15/98)
//-----------------------------------------------------------------------------
static VOID SendFaxNum(                                     // @Sep/17/98
    PDEVOBJ pdevobj)
{
    BYTE        Cmd[256], PreNumBuf[4+16], NumBuf[32+4];
    SHORT       PreNumLen, cnt, SrcLen, NumLen;
    INT         ocmd;
    LPSTR       lpSrc, lpDst;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);
    PFILEDATA    pFileData;

// @Oct/20/98 ->
    if(!(pFileData = (PFILEDATA)MemAllocZ(sizeof(FILEDATA))))
    {
        return;
    }

    memset(pFileData, 0, sizeof(FILEDATA));
// @Aug/31/99 ->
//  RWFileData(pFileData, GENERIC_READ);
    RWFileData(pFileData, pOEMExtra->FaxDataFileName, GENERIC_READ);
    VERBOSE(("** SendFaxNum: pFileData->fUiOption=%lx **\n", pFileData->fUiOption));
    VERBOSE(("**             pOEMExtra->fUiOption=%lx **\n", pOEMExtra->fUiOption));
// @Aug/31/99 <-

    // If previous fax is finished and reset-fax-options flag is valid,
    // do nothing and return. This prevents unexpected fax when user
    // doesn't update previous fax settings on the propertysheet.
    if (BITTEST32(pFileData->fUiOption, FAX_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, FAX_NOTRESET_UI))
    {
        VERBOSE(("** SendFaxNum: Exit without doing anything. **\n"));
        MemFree(pFileData);
        return;
    }
// @Oct/20/98 <-

    // If not fax option ready, exit.
    if (!BITTEST32(pOEMExtra->fUiOption, FAX_SEND) ||
#ifdef FAXADDRESSBOOK
        (pOEMExtra->FaxNumBuf[0] == 0 && pOEMExtra->FaxNumBookBuf[0] == 0))
#else  // !FAXADDRESSBOOK
        pOEMExtra->FaxNumBuf[0] == 0)
#endif // !FAXADDRESSBOOK
    {
        MemFree(pFileData);     // @Oct/20/98
        return;
    }

    // Set data_type(1:image, 2:RPDL command), compression (1:MH, 3:MMR),
    // simultaneous print avalilable, etc
    ocmd = sprintf(Cmd, BEGINFAX_HEAD,
                   BITTEST32(pOEMExtra->fUiOption, FAX_RPDLCMD)? 2 : 1,
                   BITTEST32(pOEMExtra->fUiOption, FAX_MH)? 1 : 3,
                   BITTEST32(pOEMExtra->fUiOption, FAX_SIMULPRINT)? 2 : 1);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Copy fax channel & extra number to pre_number buffer
    PreNumLen = (SHORT)sprintf(PreNumBuf, BEGINFAX_CH, pOEMExtra->FaxCh + 1);
    if (pOEMExtra->FaxExtNumBuf[0] != 0)
        PreNumLen += (SHORT)sprintf(&PreNumBuf[PreNumLen], BEGINFAX_EXTNUM, pOEMExtra->FaxExtNumBuf);

    // Search each fax number (directly set number & addressbook set number)
    lpSrc  = pOEMExtra->FaxNumBuf;  // fax number which is set directly
    SrcLen = FAXBUFSIZE256-1;       // FaxNumBuf limit = 255
    lpDst  = NumBuf;
    NumLen = 0;
#ifdef FAXADDRESSBOOK
    cnt = 2;
    while (cnt-- > 0)   // loop twice
#endif // FAXADDRESSBOOK
    {
        while (SrcLen-- > 0 && *lpSrc != 0)
        {
            // If character is DBCS, skip.
            if (IsDBCSLeadByteRPDL(*lpSrc))
            {
                lpSrc++;
            }
            // If character is valid, input it to NumBuf.
            else if (*lpSrc >= '0' && *lpSrc <= '9' || *lpSrc == '-' || *lpSrc == '#')
            {
                *lpDst++ = *lpSrc;
                if (NumLen++ > 32)          // limit of MF-P
                {
                    MemFree(pFileData);     // @Oct/20/98
                    return;                 // error exit
                }
            }
            // If character is ',' , output fax number.
            else if (*lpSrc == ',')
            {
                *lpDst = 0;
                // Send fax number
                if (NumLen > 0)
                {
                    WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
                    WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
                }
                lpDst = NumBuf;
                NumLen = 0;
            }
            lpSrc++;
        } // 'while (SrcLen-- > 0 && *lpSrc != 0)' end

        // Flush last fax number
        if (NumLen > 0)
        {
            WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
            WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
        }
#ifdef FAXADDRESSBOOK
        lpSrc  = pOEMExtra->FaxNumBookBuf;  // fax number which is set by addressbook
        SrcLen = FAXBUFSIZE256-1;           // FaxNumBookBuf limit = 255
        lpDst  = NumBuf;
        NumLen = 0;
#endif // FAXADDRESSBOOK
    } // 'while (cnt-- > 0)' end

    // Get tickcount for ID
    cnt = (SHORT)(GetTickCount() / 1000L);
    cnt = ABS(cnt);
    // Input ID & resolution & send time, etc
    if (BITTEST32(pOEMExtra->fUiOption, FAX_SETTIME) && pOEMExtra->FaxSendTime[0] != 0)
        ocmd = sprintf(Cmd, BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 2, pOEMExtra->FaxSendTime);
    else
        ocmd = sprintf(Cmd, BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 1, "");
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Set FAX_DONE flag in the file  @Oct/20/98
    memset(pFileData, 0, sizeof(FILEDATA));
    pFileData->fUiOption = pOEMExtra->fUiOption;
    BITSET32(pFileData->fUiOption, FAX_DONE);
// @Aug/31/99 ->
//  RWFileData(pFileData, GENERIC_WRITE);
    RWFileData(pFileData, pOEMExtra->FaxDataFileName, GENERIC_WRITE);
// @Aug/31/99 <-
    MemFree(pFileData);

    return;
} //*** SendFaxNum


#ifdef TEXTCLIPPING
//---------------------------*[LOCAL] ClearTextClip*---------------------------
// Action: clear TextMode clipping
//-----------------------------------------------------------------------------
static VOID ClearTextClip(
    PDEVOBJ pdevobj,
    WORD    flag)
{
    LONG    left, top, right, bottom;
    LONG    dx, dy;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);      // @Oct/06/98

    // After SP8, TextMode clipping is capable.
    if (!TEST_AFTER_SP8(pOEM->fModel))
        return;

    dx     = pOEM->PageMax.x;
    dy     = pOEM->PageMax.y;
    left   = pOEM->Offset.x;
    top    = pOEM->Offset.y;
    right  = left + dx;
    bottom = top + dy;

    // If forced to clip or current clipping-area is not same to pagesize,
    // do clipping-off.
    if (flag == CLIP_MUST                  ||
        pOEM->TextClipRect.left   != left  ||
        pOEM->TextClipRect.top    != top   ||
        pOEM->TextClipRect.right  != right ||
        pOEM->TextClipRect.bottom != bottom)
    {
        BYTE    Cmd[32];    // build command here
        INT     ocmd;

        // Make clippin-area same to pagesize.
        pOEM->TextClipRect.left   = left;
        pOEM->TextClipRect.top    = top;
        pOEM->TextClipRect.right  = right;
        pOEM->TextClipRect.bottom = bottom;

        // Expand clipping width +3mm in 2in1 for Netscape Navigator
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67))
            // (mm to dot with KIRIAGE)
            dx += (LONG)(((WORD)((DWORD)3*(DWORD)(MASTERUNIT*10)/(DWORD)254) +
                          (WORD)(pOEM->nResoRatio-1)) / (WORD)pOEM->nResoRatio);

        // If MODEL is SP8(7)/8(7)mkII, convert unit from dot to 1/720inch_unit.
        if (BITTEST32(pOEM->fModel, GRP_SP8))
        {
            left *= 3;      // 3 = 720/240
            top  *= 3;
            dx   *= 3;
            dy   *= 3;
        }
        ocmd = sprintf(Cmd, ESC_CLIPPING, left, top, dx, dy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }
    return;
} //*** ClearTextClip
#endif // TEXTCLIPPING


#ifdef JISGTT
//-----------------------------*[LOCAL] jis2sjis*------------------------------
// Action: convert JIS code to SJIS code
//-----------------------------------------------------------------------------
static VOID jis2sjis(       // @Oct/27/98
    BYTE jis[],
    BYTE sjis[])
{
        BYTE            h, l;

        h = jis[0];
        l = jis[1];
        if (h == 0)
        {
            sjis[0] = l;
            sjis[1] = 0;
            return;
        }
        l += 0x1F;
        if (h & 0x01)
            h >>= 1;
        else
        {
            h >>= 1;
            l += 0x5E;
            h--;
        }
        if (l >= 0x7F)
            l++;
        if (h < 0x2F)
            h += 0x71;
        else
            h += 0xB1;
        sjis[0] = h;
        sjis[1] = l;
} //*** jis2sjis
#endif // JISGTT


VOID APIENTRY OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE aubBuff;              // <-BYTE aubBuff[256]  MSKK Aug/13/98
    PTRANSDATA pTrans;
#ifdef DBG_OUTPUTCHARSTR
    PWORD  pwUnicode;
#endif // DBG_OUTPUTCHARSTR
    DWORD  dwI;
    BYTE   Cmd[128];
    INT    ocmd = 0;            // INT<-SHORT  @Feb/22/99
    SHORT  rcID;
    WORD   fVertFont = FALSE, fEuroFont = FALSE, fIBMFontSupport = FALSE;
    WORD   fEuroFontFullset = FALSE;
#ifdef JISGTT
    WORD   fJisCode = FALSE;    // @Oct/27/98
#endif // JISGTT
    LPSTR  lpChar;
    BYTE   CharTmp1, CharTmp2;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
#ifdef DOWNLOADFONT
    SHORT   mov;
    WORD    wSerialNum;         // short->DWORD @Jun/30/98, DWORD->WORD @Aug/21/98
    LONG    lFontID, lGlyphID;  // @Aug/21/98
    LPFONTPOS lpDLFont;
#endif // DOWNLOADFONT
    DWORD   dwNeeded;
    WORD    fMemAllocated;      // @Sep/09/98

//  VERBOSE(("** OEMOutputCharStr() entry. **\n"));

#ifdef TEXTCLIPPING
    //** TextMode clipping **
    if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_SET_GONNAOUT) &&
        !BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
    {
        LONG    left, top, dx, dy, offset;
        LPRECT  lpCR;

        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_SET_GONNAOUT);
        BITSET32(pOEM->fGeneral1, TEXT_CLIP_VALID);
        lpCR = &pOEM->TextClipRect;
        left = lpCR->left;
        dx   = lpCR->right - lpCR->left;
        top  = lpCR->top;
        dy   = lpCR->bottom - lpCR->top;

        // DCR:RPDL
        // Expand clipping-height for DBCS device font. (for PageMaker)
        // After SP9II, move top position and expand clipping-height.
        if (TEST_AFTER_SP9II(pOEM->fModel))
        {
            // Upper-expand ratio is 1.045 for HANKAKU font bug
            offset = (pOEM->FontH_DOT * 9 + 199) / 200;     // KIRIAGE
            // Move top position of clipping.
            // If it become lower than 0, make it 0 and reduce offset.
            if ((top -= offset) < 0)
            {
                offset += top;      // offset = original value of top
                top = 0;
            }
            // Keep lower position of clipping, not to cut off font bottom of
            // device font in case of direct-selected (not substituted case).
            if (dy < (LONG)pOEM->FontH_DOT + offset)
                dy += offset;
        }
        // Before SP9II(exclude 9II),expand clipping-height.
        else
        {
            // Upper-expand ratio is 1.05 (tilde'~' is missed at SP-10Pro)
            offset = (pOEM->FontH_DOT * 5 + 99) / 100;      // KIRIAGE
            if ((top -= offset) < 0)
            {
                offset += top;
                top = 0;
            }
            // Lower-expand ratio is 1.03
            offset += (pOEM->FontH_DOT * 3 + 99) / 100;     // KIRIAGE
            if (dy < (LONG)pOEM->FontH_DOT + offset)
                dy += offset;
        }

        // If MODEL is SP8(7)/8(7)mkII,convert unit from dot to 1/720inch_unit.
        if (BITTEST32(pOEM->fModel, GRP_SP8))
        {
            left *= 3;      // 3 = 720/240
            top  *= 3;
            dx   *= 3;
            dy   *= 3;
        }
        // Set TextMode clipping
        ocmd = sprintf(Cmd, ESC_CLIPPING, left, top, dx, dy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }
    else if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_CLR_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_CLR_GONNAOUT);
        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);
        ClearTextClip(pdevobj, CLIP_IFNEED);
    }
#endif // TEXTCLIPPING

    if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))  // add  @Dec/11/97
    {
        BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
    }

    //** flush Move_X,Y command saved at OEMCommandCallback
    if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        // Output Move_Y command here.
        ocmd = sprintf(Cmd, ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }
    if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        // Output Move_X command here.
        ocmd = sprintf(Cmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

//  VERBOSE(("dwType = %d\n", dwType)); // MKSKK 1/24/98

    switch (dwType)
    {
      case TYPE_GLYPHHANDLE:    // device font
// #333653: Change I/F for GETINFO_GLYPHSTRING // MSKK 5/17/99 {
        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        // Get the size of buffer for pGlyphOut.
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }
        if (pOEM->pRPDLHeap2K && GStr.dwGlyphOutSize <= HEAPSIZE2K)
        {
            aubBuff = pOEM->pRPDLHeap2K;
            fMemAllocated = FALSE;
        }
        else
        {
            if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
            {
                ERR(("aubBuff memory allocation failed.\n"));
                return;
            }
            fMemAllocated = TRUE;
        }
// } MSKK 5/17/99

#ifdef DBG_OUTPUTCHARSTR
        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }

        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            VERBOSE((("Unicode[%d] = %x\n"), dwI, pwUnicode[dwI]));
        }
#endif // DBG_OUTPUTCHARSTR

#ifdef DOWNLOADFONT
    // If moving value of download font remain
    if (pOEM->nCharPosMoveX)
    {
        // Flush moving value of pre-printed download font.
        if (pOEM->nCharPosMoveX > 0)
            ocmd = sprintf(Cmd, ESC_XM_REL, pOEM->nCharPosMoveX);
        else
            ocmd = sprintf(Cmd, ESC_XM_RELLEFT, -pOEM->nCharPosMoveX);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);

        // Clear moving value
        pOEM->nCharPosMoveX = 0;
    } // 'if (nCharPosMoveX)' end
#endif // DOWNLOADFONT

        //
        // Call the Unidriver service routine to convert
        // glyph-handles into the character code data.
        //

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }

        pTrans = (PTRANSDATA)aubBuff;

//** Draw barcode **
// fix bug with Excel @Nov/24/98
        if (BITTEST32(pOEM->fGeneral2, BARCODE_MODE_IN))
        {
            WORD    unit1, unit2, offset_y;
            WORD    fCheckdigitCapable, fSetBarWidth, fJANDecrease1Char;
            LPSTR   lpDst, lpCmd;
            PTRANSDATA pTransTmp;       // @Nov/24/98
            WORD    wLen, wTmp;

            ocmd = 0;
            // Check start character
            wTmp = wLen = (WORD)dwCount;
            pTransTmp = pTrans;
            while (wTmp-- > 0)
            {
                if (pTransTmp->uCode.ubCode == '[')
                {
                    // barcode character is valid from now
                    BITSET32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                    BITCLR32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT90);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount = 0;
                    wLen   = wTmp;
                    pTrans = pTransTmp+1;
#ifdef TEXTCLIPPING
                    // Clear TextMode clipping
                    if (BITTEST32(pOEM->fGeneral1, TEXT_CLIP_VALID))
                    {
                        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);
                        ClearTextClip(pdevobj, CLIP_IFNEED);
                    }
#endif // TEXTCLIPPING
#ifdef DEBUG
                    for (wTmp = 0; wTmp < BARCODE_MAX; wTmp++)
                        pOEM->RPDLHeap64[wTmp] = 0;
#endif // DEBUG
                    break;
                }
                pTransTmp++;
            }

            // Check barcode character length
            VERBOSE(("** BARCODE(2.2) len=%d **\n",wLen));
            fJANDecrease1Char = FALSE;
            if (wLen > (wTmp = pOEM->nBarMaxLen - pOEM->RPDLHeapCount))
            {
                wLen = wTmp;
                BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                VERBOSE(("** BARCODE(3) limit len=%d(last=%c) **\n", wLen,
                         (pTrans+wLen-1)->uCode.ubCode));
                // Decrease RPDLHeapCount later at JAN
                if (pOEM->nBarType == 0 || pOEM->nBarType == 1)
                    fJANDecrease1Char = TRUE;
            }

            // Copy barcode characters to RPDLHeap64 (temporary buffer)
            lpDst = &pOEM->RPDLHeap64[pOEM->RPDLHeapCount];
            fCheckdigitCapable = TEST_AFTER_SP8(pOEM->fModel)? TRUE : FALSE;
            while (wLen-- > 0)
            {
                // Check checkdigit-on-flag-character(?) in pTrans->uCode.ubCode
                if (pTrans->uCode.ubCode == '?' && fCheckdigitCapable)
                {
                    BITSET32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    pTrans++;
                    continue;
                }
                // Check end character
                if (pTrans->uCode.ubCode == ']')
                {
                    VERBOSE(("** BARCODE(4) terminator **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                    break;
                }
                *lpDst++ = pTrans->uCode.ubCode;
                pTrans++;
                pOEM->RPDLHeapCount++;
            }
            VERBOSE(("** BARCODE(5) copy-end BarNum=%d **\n", pOEM->RPDLHeapCount));
            VERBOSE(("   [%s]\n",pOEM->RPDLHeap64));
            VERBOSE(("   CHK = %d\n", BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON)));

            // Finish
            if (BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID) &&
                BITTEST32(pOEM->fGeneral2, BARCODE_FINISH))
            {
                VERBOSE(("** BARCODE(6) finish [%s] **\n", pOEM->RPDLHeap64));
                // 1 barcode has been completed here
                BITCLR32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                BITCLR32(pOEM->fGeneral2, BARCODE_FINISH);

                ocmd = sprintf(Cmd, ENTER_VECTOR);    // enter VectorMode

                // Add checkdigit
                if (BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_CHECKDIGIT);
                }

                // Check barcode-height
                if (pOEMExtra->UiBarHeight == 0)
                {
                    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;     // default (=10mm)
                }
                else if (pOEMExtra->UiBarHeight != BAR_H_DEFAULT)
                {
                    // Set barcode-height (convert unit from mm to dot)  (SISHAGONYU)
                    unit1 = (WORD)(((DWORD)pOEMExtra->UiBarHeight * (DWORD)(MASTERUNIT*10)
                            / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
                    VERBOSE(("** BARCODE(7) set height %d **\n", unit1));
                    ocmd += sprintf(&Cmd[ocmd], BAR_H_SET, unit1);
                }

                if (BITTEST32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT))
                {
                    // Disable printing font under barcode
                    ocmd += sprintf(&Cmd[ocmd], BAR_NOFONT[pOEM->nBarType]);
                    // Set guard-bar-height of JAN
                    if ((pOEM->nBarType == 0 || pOEM->nBarType == 1) &&
                        !TEST_AFTER_SP8(pOEM->fModel))
                    {
                        offset_y = 2;
                    }
                    else    // no guard-bar
                    {
                        offset_y = 0;
                    }
                }
                else
                {
                    offset_y = 3;   // font-height = 3mm
                }
                // Calculate vertical offset (barcode-height + font-height)
                offset_y = (WORD)(((DWORD)(pOEMExtra->UiBarHeight + offset_y)
                           * (DWORD)(MASTERUNIT*10)
                           / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);

                // Check vertical-flag-character('@') in RPDLHeap64
                VERBOSE(("** BARCODE(7-1) vertical check len=%d(%c..%c) **\n",
                        pOEM->RPDLHeapCount, pOEM->RPDLHeap64[0],
                        pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] ));
                // If characters are "@...", vertical(ROT270) barcode
                if (pOEM->RPDLHeap64[0] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT270) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount--;
                }
                // If characters are "...@", vertical(ROT90) barcode
                else if (pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT90) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT90);
                    pOEM->RPDLHeapCount--;
                }
                // 1 charcter margin for '@' at JAN, we decrease here.
                else if (fJANDecrease1Char)
                {
                    pOEM->RPDLHeapCount--;
                }

                // Set barcode draw position
                if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270) &&
                    !TEST_NIN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_ROT270);
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.y,
                                    pOEM->PageMax.x - pOEM->TextCurPos.x - offset_y);
                }
                else if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT90) &&
                         !TEST_4IN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += sprintf(&Cmd[ocmd], BAR_ROT90);
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->PageMax.y - pOEM->TextCurPos.y,
                                    pOEM->TextCurPos.x - offset_y);
                }
                else
                {
                    ocmd += sprintf(&Cmd[ocmd], MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.x,
                                    pOEM->TextCurPos.y - offset_y);
                }

                // Check whether setting barcode-width or not.
                // (Scaling is valid when 5pt<=fontsize<9pt or fontsize>11pt)
                if ((pOEM->dwBarRatioW >= BAR_W_MIN_5PT &&
                    pOEM->dwBarRatioW < NEAR10PT_MIN) ||
                    pOEM->dwBarRatioW > NEAR10PT_MAX)
                {
                    fSetBarWidth = TRUE;
                }
                else
                {
                    fSetBarWidth = FALSE;
                }

                switch (pOEM->nBarType)
                {
                  case 0:                       // JAN(STANDARD)
                  case 1:                       // JAN(SHORT)
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)BAR_UNIT_JAN * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d **\n", unit1));
                        ocmd += sprintf(&Cmd[ocmd], BAR_W_SET_JAN, unit1);
                    }
                    // Output barcode command
                    ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType]);
                    break;

                  case 2:                       // 2of5(INDUSTRIAL)
                  case 3:                       // 2of5(MATRIX)
                  case 4:                       // 2of5(ITF)
                    lpCmd = BAR_W_SET_2OF5;
                    goto _BARCODE_CMD_OUT1;
                  case 5:                       // CODE39
                    lpCmd = BAR_W_SET_C39;
                  _BARCODE_CMD_OUT1:
                    // Set standard size of module unit  (1/1000mm_unit)
                    unit1 = BAR_UNIT1_2OF5;
                    unit2 = BAR_UNIT2_2OF5;
                    goto _BARCODE_CMD_OUT2;

                  case 6:                       // NW-7
                    lpCmd = BAR_W_SET_NW7;
                    // Set standard size of module unit
                    unit1 = BAR_UNIT1_NW7;
                    unit2 = BAR_UNIT2_NW7;
                  _BARCODE_CMD_OUT2:
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)unit1 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        unit2 = (WORD)(((DWORD)unit2 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d,%d **\n", unit1,unit2));
                        ocmd += sprintf(&Cmd[ocmd], lpCmd);
                        ocmd += sprintf(&Cmd[ocmd], BAR_W_PARAMS, unit1, unit1,
                                        unit2, unit2, unit1);
                    }
                    // Output barcode command(operand) & character#
                    ocmd += sprintf(&Cmd[ocmd], BAR_TYPE[pOEM->nBarType],
                                    pOEM->RPDLHeapCount);
                    break;

                  default:
                    break;
                }

                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                // Output barcode characters
                if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270))     // @Oct/22/97
                    WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64+1, pOEM->RPDLHeapCount);
                else
                    WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);

                pOEM->RPDLHeapCount = 0;
                // We add ';' for safe finish in case of insufficient character at JAN.
                ocmd = sprintf(Cmd, TERMINATOR);
                ocmd += sprintf(&Cmd[ocmd], EXIT_VECTOR); // exit VectorMode
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            } // 'if BARCODE_DATA_VALID && BARCODE_FINISH' end

            if(fMemAllocated)
                MemFree(aubBuff);

            return;
        }
//** Draw barcode END **

//** Draw device font **
        BITCLR32(pOEM->fGeneral1, FONT_VERTICAL_ON);
        rcID = (SHORT)pUFObj->ulFontID;

        if (rcID >= JPN_FNT_FIRST && rcID <= JPN_FNT_LAST)
        {
            if (TEST_VERTICALFONT(rcID))
            {
                fVertFont = TRUE;   // vertical font
                BITSET32(pOEM->fGeneral1, FONT_VERTICAL_ON);
            }
            // IBM ext char(SJIS) supported from SP9II
            if (rcID >= AFTER_SP9II_FNT_FIRST)
                fIBMFontSupport = TRUE;
// @Oct/27/98 ->
#ifdef JISGTT
            // Current UFM of PMincho & PGothic declare JIS code set.
            if (rcID >= JPN_MSPFNT_FIRST)
                fJisCode = TRUE;
#endif // JISGTT
// @Oct/27/98 <-
        }
        else if (rcID >= EURO_FNT_FIRST && rcID <= EURO_FNT_LAST)
        {
            fEuroFont = TRUE; // European font(Courier,BoldFacePS,etc).
            // Fullset(0x20-0xFF) fonts(Arial,Century,TimesNewRoman,etc) are supported
            // from NX-110
            if (rcID >= EURO_MSFNT_FIRST)
                fEuroFontFullset = TRUE;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans ++)     // increment pTrans  MSKK 98/3/16
        {
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
              case MTYPE_DIRECT:    // SBCS (European font & Japanese font HANKAkU)
//              VERBOSE((("TYPE_TRANSDATA:ubCode:0x%x\n"), pTrans->uCode.ubCode));

                lpChar = &pTrans->uCode.ubCode;
                CharTmp1 = *lpChar;

                if (fEuroFont)  //** European font  **
                {
                    // ** print 1st SBCS font(0x20-0x7F) **
                    if (CharTmp1 < 0x80)
                    {
                        // DCR:RPDL
                        // take care of device font bug
                        if (rcID == SYMBOL && CharTmp1 == 0x60)     // "radical extention"
                        {
                            WRITESPOOLBUF(pdevobj, DOUBLE_SPACE, sizeof(DOUBLE_SPACE)-1);
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                            WRITESPOOLBUF(pdevobj, DOUBLE_BS, sizeof(DOUBLE_BS)-1);
                        }
                        else
                        {
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        }
                        continue;       // goto for-loop end
                    }


                    // ** print 2nd SBCS font(0x80-0xFF) **
                    // If full-set(0x20-0xFF) font
                    if (fEuroFontFullset)
                    {
                        // If same to DBCS 1st byte
                        if (IsDBCSLeadByteRPDL(CharTmp1))
                            WRITESPOOLBUF(pdevobj, ESC_CTRLCODE, sizeof(ESC_CTRLCODE)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        continue;       // goto for-loop end
                    }

                    // If not full-set font
                    switch (CharTmp1)
                    {
                      case 0x82:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0x88:
                        CharTmp1 = '^';     goto _WRITE1BYTE;
                      case 0x8B:
                        CharTmp1 = '<';     goto _WRITE1BYTE;
                      case 0x9B:
                        CharTmp1 = '>';     goto _WRITE1BYTE;
                      case 0x91:        // single quatation
                      case 0x92:
                        CharTmp1 = 0x27;    goto _WRITE1BYTE;
                      case 0x93:        // double quatation
                      case 0x94:
                        CharTmp1 = 0x22;    goto _WRITE1BYTE;
                      case 0x96:
                      case 0x97:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0x98:
                        CharTmp1 = '~';     goto _WRITE1BYTE;
                      case 0xA6:
                        CharTmp1 = '|';     goto _WRITE1BYTE;
                      case 0xAD:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0xB8:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0xD7:
                        CharTmp1 = 'x';     goto _WRITE1BYTE;

                      case 0x83:
                        CharTmp1 = 0xBF;    goto _WRITE1BYTE;
                      case 0x86:
                        CharTmp1 = 0xA8;    goto _WRITE1BYTE;
                      case 0x99:
                        CharTmp1 = 0xA9;    goto _WRITE1BYTE;
                      case 0xE7:
                        CharTmp1 = 0xA2;    goto _WRITE1BYTE;
                      case 0xE8:
                        CharTmp1 = 0xBD;    goto _WRITE1BYTE;
                      case 0xE9:
                        CharTmp1 = 0xBB;    goto _WRITE1BYTE;
                      case 0xF9:
                        CharTmp1 = 0xBC;    goto _WRITE1BYTE;
                      case 0xFC:
                        CharTmp1 = 0xFD;    goto _WRITE1BYTE;

                      case 0xA0:
                      case 0xA3:
                      case 0xA4:
                        goto _WRITE1BYTE;

                      case 0xA2:
                        CharTmp1 = 0xDE;    goto _WRITE1BYTE;
                      case 0xA5:        //YEN mark
                        CharTmp1 = 0xCC;    goto _WRITE1BYTE;
                      case 0xA7:
                        CharTmp1 = 0xC0;    goto _WRITE1BYTE;
                      case 0xA8:
                        CharTmp1 = 0xBE;    goto _WRITE1BYTE;
                      case 0xA9:
                        CharTmp1 = 0xAB;    goto _WRITE1BYTE;
                      case 0xAE:
                        CharTmp1 = 0xAA;    goto _WRITE1BYTE;
                      case 0xAF:
                        CharTmp1 = 0xB0;    goto _WRITE1BYTE;
                      case 0xB0:
                      case 0xBA:
                        CharTmp1 = 0xA6;    goto _WRITE1BYTE;
                      case 0xB4:
                        CharTmp1 = 0xA7;    goto _WRITE1BYTE;
                      case 0xB5:
                        CharTmp1 = 0xA5;    goto _WRITE1BYTE;
                      case 0xB6:
                        CharTmp1 = 0xAF;    goto _WRITE1BYTE;
                      case 0xBC:
                        CharTmp1 = 0xAC;    goto _WRITE1BYTE;
                      case 0xBD:
                        CharTmp1 = 0xAE;    goto _WRITE1BYTE;
                      case 0xBE:
                        CharTmp1 = 0xAD;    goto _WRITE1BYTE;
                      case 0xC4:
                        CharTmp1 = 0xDB;    goto _WRITE1BYTE;
                      case 0xC5:
                        CharTmp1 = 0xD6;    goto _WRITE1BYTE;
                      case 0xC9:
                        CharTmp1 = 0xB8;    goto _WRITE1BYTE;
                      case 0xD6:
                        CharTmp1 = 0xDC;    goto _WRITE1BYTE;
                      case 0xDC:
                        CharTmp1 = 0xDD;    goto _WRITE1BYTE;
                      case 0xDF:
                        CharTmp1 = 0xFE;    goto _WRITE1BYTE;

                      _WRITE1BYTE:
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      // Combine 2 fonts, because next fonts do not exist in device font
                      case 0x87:
                        CharTmp1 = '=';  CharTmp2 = '|';    goto _COMBINEDFONT;
                      case 0xD0:        // 'D' with middle bar
                        CharTmp1 = 'D';  CharTmp2 = '-';    goto _COMBINEDFONT;
                      case 0xD8:        // 'O' with slash
                        CharTmp1 = 'O';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xE0:        // 'a' with right-down dash
                        CharTmp1 = 'a';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xE1:        // 'a' with left-down dash
                        CharTmp1 = 'a';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xE2:        // 'a' with hat
                        CharTmp1 = 'a';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xE3:        // 'a' with tilde
                        CharTmp1 = 'a';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xE4:        // 'a' with umlaut
                        CharTmp1 = 'a';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xE5:        // 'a' with circle
                        CharTmp1 = 'a';  CharTmp2 = 0xA6;   goto _COMBINEDFONT;
                      case 0xEA:        // 'e' with hat
                        CharTmp1 = 'e';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xEB:        // 'e' with umlaut
                        CharTmp1 = 'e';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF1:        // 'n' with tilde
                        CharTmp1 = 'n';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF2:        // 'o' with right-down dash
                        CharTmp1 = 'o';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xF3:        // 'o' with left-down dash
                        CharTmp1 = 'o';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xF4:        // 'o' with hat
                        CharTmp1 = 'o';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xF5:        // 'o' with tilde
                        CharTmp1 = 'o';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF6:        // 'o' with umlaut
                        CharTmp1 = 'o';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF8:        // 'o' with slash
                        CharTmp1 = 'o';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xFA:        // 'u' with left-down dash
                        CharTmp1 = 'u';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFB:        // 'u' with hat
                        CharTmp1 = 'u';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xFD:        // 'y' with left-down dash
                        CharTmp1 = 'y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFF:        // 'y' with umlaut
                        CharTmp1 = 'y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      _COMBINEDFONT:
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'D')  // BoldFacePS(except 'D'+'-')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;

                      case 0x9F:        // 'Y' with umlaut
                        CharTmp1 = 'Y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xC0:        // 'A' with right-down dash
                        CharTmp1 = 'A';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xC1:        // 'A' with left-down dash
                        CharTmp1 = 'A';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xC2:        // 'A' with hat
                        CharTmp1 = 'A';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xC3:        // 'A' with tilde
                        CharTmp1 = 'A';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xC8:        // 'E' with right-down dash
                        CharTmp1 = 'E';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCA:        // 'E' with hat
                        CharTmp1 = 'E';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCB:        // 'E' with umlaut
                        CharTmp1 = 'E';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xCC:        // 'I' with right-down dash
                        CharTmp1 = 'I';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCD:        // 'I' with left-down dash
                        CharTmp1 = 'I';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xCE:        // 'I' with hat
                        CharTmp1 = 'I';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCF:        // 'I' with umlaut
                        CharTmp1 = 'I';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xD1:        // 'N' with tilde
                        CharTmp1 = 'N';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD2:        // 'O' with right-down dash
                        CharTmp1 = 'O';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xD3:        // 'O' with left-down dash
                        CharTmp1 = 'O';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xD4:        // 'O' with hat
                        CharTmp1 = 'O';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xD5:        // 'O' with tilde
                        CharTmp1 = 'O';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD9:        // 'U' with right-down dash
                        CharTmp1 = 'U';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xDA:        // 'U' with left-down dash
                        CharTmp1 = 'U';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xDB:        // 'U' with hat
                        CharTmp1 = 'U';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xDD:        // 'Y' with left-down dash
                        CharTmp1 = 'Y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      _COMBINEDFONT_HALFUP:
                        WRITESPOOLBUF(pdevobj, ESC_HALFUP, sizeof(ESC_HALFUP)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, ESC_HALFDOWN, sizeof(ESC_HALFDOWN)-1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'I')  // BoldFacePS(except 'I')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      case 0x84:        // double quatation at bottom
                        CharTmp1 = 0x22;
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0xB1:        // plus-minus
                        if (rcID == BOLDFACEPS)
                        {
                            CharTmp2 = '_';  CharTmp1 = '+';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        }
                        else
                        {
                            CharTmp2 = '+';  CharTmp1 = '-';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        }
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0x95:
                      case 0xB7:
                      default:          // print unprintable font by dot(KATAKANA)
                        // Set 2nd SBCS font table(0x80-0xFF) as KATAKANA
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_IN, sizeof(ESC_SHIFT_IN)-1);
                        CharTmp1 = 0xA5;
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        // Set 2nd SBCS font table(0x80-0xFF) as 2ndANK
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_OUT, sizeof(ESC_SHIFT_OUT)-1);
                        break;
                    } // 'switch (CharTmp1)' end
                }
                else            //** Japanese font (HANKAKU) **
                {
                    if (fVertFont)  // vertical font
                    {
                        // HANKAKU(Alphabetical&Numeric) fonts must not become vertical.
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                    }
                    else            // normal (non vertical) font
                    {
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                    }
                } // 'if European font else Japanese font(HANKAKU)' end


                break;

              case MTYPE_PAIRED:    // DBCS (Japanes font ZENKAKU)
//              VERBOSE((("TYPE_TRANSDATA:ubPairs:0x%x\n"), *(PWORD)(pTrans->uCode.ubPairs)));

                lpChar = pTrans->uCode.ubPairs;

// For proportional font UFM which has GTT @Oct/27/98 ->
#ifdef JISGTT
                if (fJisCode)
                {
                    BYTE    jis[2], sjis[2];

                    jis[0] = *lpChar;
                    jis[1] = *(lpChar+1);
                    jis2sjis(jis, sjis);
                    (BYTE)*lpChar     = sjis[0];
                    (BYTE)*(lpChar+1) = sjis[1];
                }
#endif // JISGTT
// @Oct/27/98 <-
                CharTmp1 = *lpChar;
                CharTmp2 = *(lpChar+1);
                // Some vertical device font differ from TrueType font
                if (fVertFont)
                {
                    if (CharTmp1 == 0x81)
                    {
                        // Make vertical device font same to TrueType
                        if (IsDifferentPRNFONT(CharTmp2))
                        {
                            WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                            WRITESPOOLBUF(pdevobj, ESC_ROT90, sizeof(ESC_ROT90)-1);
                            WRITESPOOLBUF(pdevobj, lpChar, 2);
                            WRITESPOOLBUF(pdevobj, ESC_ROT0, sizeof(ESC_ROT0)-1);
                            WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                            continue;   // goto for-loop end
                        }
                        else if (CharTmp2 >= 0xA8 && CharTmp2 <= 0xAB)
                        {   //IMAGIO's GOTHIC device font differ from TrueType font
                            goto _WITHOUTROTATION;
                        }
                    }

                    if (CharTmp1 == 0x84 &&
                        CharTmp2 >= 0x9F && CharTmp2 <= 0xBE)
                    {
                  _WITHOUTROTATION:
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 2);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                        continue;       // goto for-loop end
                    }
                } // 'if(fVertFont)' end

                // Code of HEISEI mark of device font differs from SJIS
                if (CharTmp1 == 0x87 && CharTmp2 == 0x7E)
                {
                    (BYTE)*(lpChar+1) = 0x9E;
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // If models which support IBM ext char code
                if (fIBMFontSupport)
                {
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // Handle IBM ext char code here at models which do not support it
                switch (CharTmp1)
                {
                  case 0xFA:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0xFC)
                        (BYTE)*lpChar = 0x0EB;
                    goto _WRITE2BYTE;

                  case 0xFB:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x9E)
                    {
                        (BYTE)*lpChar = 0xEC;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x9F && CharTmp2 <= 0xDD)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xDE && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5E;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;

                  case 0xFC:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x4B)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) += 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;


                  case 0xED:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0xE0)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0xE1 && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) -= 0xA1;
                        goto _WRITE2BYTE;
                    }
                    goto _WRITE2BYTE;

                  case 0xEE:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0x82)
                 